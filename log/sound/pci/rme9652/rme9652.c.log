commit fb95aae6e67c4e319a24b3eea32032d4246a5335
Merge: bd2463ac7d7e 90fb04f890bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 16:26:57 2020 -0800

    Merge tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "As the diffstat shows we've had again a lot of works done for this
      cycle: the majority of changes are the continued componentization and
      code refactoring in ASoC, the tree-wide PCM API updates and cleanups
      and SOF updates while a few ASoC driver updates are seen, too.
    
      Here we go, some highlights:
    
      Core:
       - Finally y2038 support landed to ALSA ABI; some ioctls have been
         extended and lots of tricks were applied
       - Applying the new managed PCM buffer API to all drivers; the API
         itself was already merged in 5.5
       - The already deprecated dimension support in ALSA control API is
         dropped completely now
       - Verification of ALSA control elements to catch API misuses
    
      ASoC:
       - Further code refactorings and moving things to the component level
       - Lots of updates and improvements on SOF / Intel drivers; now
         including common HDMI driver and SoundWire support
       - New driver support for Ingenic JZ4770, Mediatek MT6660, Qualcomm
         WCD934x and WSA881x, and Realtek RT700, RT711, RT715, RT1011,
         RT1015 and RT1308
    
      HD-audio:
       - Improved ring-buffer communications using waitqueue
       - Drop the superfluous buffer preallocation on x86
    
      Others:
       - Many code cleanups, mostly constifications over the whole tree
       - USB-audio: quirks for MOTU, Corsair Virtuoso, Line6 Helix
       - FireWire: code refactoring for oxfw and dice drivers"
    
    * tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (638 commits)
      ALSA: usb-audio: add quirks for Line6 Helix devices fw>=2.82
      ALSA: hda: Add Clevo W65_67SB the power_save blacklist
      ASoC: soc-core: remove null_snd_soc_ops
      ASoC: soc-pcm: add soc_rtd_trigger()
      ASoC: soc-pcm: add soc_rtd_hw_free()
      ASoC: soc-pcm: add soc_rtd_hw_params()
      ASoC: soc-pcm: add soc_rtd_prepare()
      ASoC: soc-pcm: add soc_rtd_shutdown()
      ASoC: soc-pcm: add soc_rtd_startup()
      ASoC: rt1015: add rt1015 amplifier driver
      ASoC: madera: Correct some kernel doc
      ASoC: topology: fix soc_tplg_fe_link_create() - link->dobj initialization order
      ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
      ASoC: madera: Correct DMIC only input hook ups
      ALSA: cs46xx: fix spelling mistake "to" -> "too"
      ALSA: hda - Add docking station support for Lenovo Thinkpad T420s
      ASoC: Add MediaTek MT6660 Speaker Amp Driver
      ASoC: dt-bindings: rt5645: add suppliers
      ASoC: max98090: fix deadlock in max98090_dapm_put_enum_double()
      ASoC: dapm: add snd_soc_dapm_put_enum_double_locked
      ...

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index ef5c2f8e17c7..bb9130747fbb 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2466,7 +2466,7 @@ static int snd_rme9652_create(struct snd_card *card,
 	if ((err = pci_request_regions(pci, "rme9652")) < 0)
 		return err;
 	rme9652->port = pci_resource_start(pci, 0);
-	rme9652->iobase = ioremap_nocache(rme9652->port, RME9652_IO_EXTENT);
+	rme9652->iobase = ioremap(rme9652->port, RME9652_IO_EXTENT);
 	if (rme9652->iobase == NULL) {
 		dev_err(card->dev, "unable to remap region 0x%lx-0x%lx\n",
 			rme9652->port, rme9652->port + RME9652_IO_EXTENT - 1);

commit 1e393ef4e3dbcea814ccadc08f10026e40267669
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:35 2020 +0100

    ALSA: rme9652: More constifications
    
    Apply const prefix to the channel map tables.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-21-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 2cb5b03f84d3..c20e590eb570 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -229,7 +229,7 @@ struct snd_rme9652 {
 	int last_spdif_sample_rate;	/* so that we can catch externally ... */
 	int last_adat_sample_rate;	/* ... induced rate changes            */
 
-        char *channel_map;
+	const char *channel_map;
 
 	struct snd_card *card;
 	struct snd_pcm *pcm;
@@ -246,12 +246,12 @@ struct snd_rme9652 {
    where the data for that channel can be read/written from/to.
 */
 
-static char channel_map_9652_ss[26] = {
+static const char channel_map_9652_ss[26] = {
 	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
 	18, 19, 20, 21, 22, 23, 24, 25
 };
 
-static char channel_map_9636_ss[26] = {
+static const char channel_map_9636_ss[26] = {
 	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
 	/* channels 16 and 17 are S/PDIF */
 	24, 25,
@@ -259,7 +259,7 @@ static char channel_map_9636_ss[26] = {
 	-1, -1, -1, -1, -1, -1, -1, -1
 };
 
-static char channel_map_9652_ds[26] = {
+static const char channel_map_9652_ds[26] = {
 	/* ADAT channels are remapped */
 	1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23,
 	/* channels 12 and 13 are S/PDIF */
@@ -268,7 +268,7 @@ static char channel_map_9652_ds[26] = {
 	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
 };
 
-static char channel_map_9636_ds[26] = {
+static const char channel_map_9636_ds[26] = {
 	/* ADAT channels are remapped */
 	1, 3, 5, 7, 9, 11, 13, 15,
 	/* channels 8 and 9 are S/PDIF */

commit b4e5e70775546480035e156b40040e5d0d4264d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:53 2020 +0100

    ALSA: pci: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-38-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 6fda027d28a4..2cb5b03f84d3 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1454,7 +1454,7 @@ static int snd_rme9652_get_tc_value(void *private_data,
 
 #endif				/* ALSA_HAS_STANDARD_WAY_OF_RETURNING_TIMECODE */
 
-static struct snd_kcontrol_new snd_rme9652_controls[] = {
+static const struct snd_kcontrol_new snd_rme9652_controls[] = {
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -1509,10 +1509,10 @@ RME9652_TC_VALID("Timecode Valid", 0),
 RME9652_PASSTHRU("Passthru", 0)
 };
 
-static struct snd_kcontrol_new snd_rme9652_adat3_check =
+static const struct snd_kcontrol_new snd_rme9652_adat3_check =
 RME9652_ADAT_SYNC("ADAT3 Sync Check", 0, 2);
 
-static struct snd_kcontrol_new snd_rme9652_adat1_input =
+static const struct snd_kcontrol_new snd_rme9652_adat1_input =
 RME9652_ADAT1_IN("ADAT1 Input Source", 0);
 
 static int snd_rme9652_create_controls(struct snd_card *card, struct snd_rme9652 *rme9652)

commit 39cccf4511fd00c591c989edb47c8ed51aba0282
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:32 2019 +0100

    ALSA: rme9652: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-34-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index ef5c2f8e17c7..6fda027d28a4 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2479,6 +2479,7 @@ static int snd_rme9652_create(struct snd_card *card,
 		return -EBUSY;
 	}
 	rme9652->irq = pci->irq;
+	card->sync_irq = rme9652->irq;
 	rme9652->precise_ptr = precise_ptr;
 
 	/* Determine the h/w rev level of the card. This seems like

commit 1a810436a2eff372aa1a934fe4d1bef50bd9dac8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:54 2019 +0100

    ALSA: rme: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Along with it, drop the unnecessary assignment before the
    snd_dma_alloc_pages() call and simplify by returning the error code
    directly.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-23-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 4c851f8dcaf8..ef5c2f8e17c7 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -279,12 +279,7 @@ static char channel_map_9636_ds[26] = {
 
 static int snd_hammerfall_get_buffer(struct pci_dev *pci, struct snd_dma_buffer *dmab, size_t size)
 {
-	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
-	dmab->dev.dev = snd_dma_pci_data(pci);
-	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
-				size, dmab) < 0)
-		return -ENOMEM;
-	return 0;
+	return snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev, size, dmab);
 }
 
 static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_dev *pci)

commit 2f235d92ac225361a9c653cb76c7ca8ef99621de
Author: Hariprasad Kelam <hariprasad.kelam@gmail.com>
Date:   Thu Jul 11 22:51:07 2019 +0530

    ALSA: rme9652: Unneeded variable: "result".
    
    This patch fixes below issue reported by coccicheck
    
    sound/pci/rme9652/rme9652.c:2161:5-11: Unneeded variable: "result".
    Return "0" on line 2167
    
    Signed-off-by: Hariprasad Kelam <hariprasad.kelam@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index cb9818af5b41..4c851f8dcaf8 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2158,13 +2158,12 @@ static int snd_rme9652_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	unsigned long flags;
-	int result = 0;
 
 	spin_lock_irqsave(&rme9652->lock, flags);
 	if (!rme9652->running)
 		rme9652_reset_hw_pointer(rme9652);
 	spin_unlock_irqrestore(&rme9652->lock, flags);
-	return result;
+	return 0;
 }
 
 static const struct snd_pcm_hardware snd_rme9652_playback_subinfo =

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 5228b982da5a..cb9818af5b41 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1,23 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   ALSA driver for RME Digi9652 audio interfaces 
  *
  *	Copyright (c) 1999 IEM - Winfried Ritsch
  *      Copyright (c) 1999-2001  Paul Davis
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/delay.h>

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index edd765e22377..5228b982da5a 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1737,10 +1737,8 @@ snd_rme9652_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buff
 
 static void snd_rme9652_proc_init(struct snd_rme9652 *rme9652)
 {
-	struct snd_info_entry *entry;
-
-	if (! snd_card_proc_new(rme9652->card, "rme9652", &entry))
-		snd_info_set_text_ops(entry, rme9652, snd_rme9652_proc_read);
+	snd_card_ro_proc_new(rme9652->card, "rme9652", rme9652,
+			     snd_rme9652_proc_read);
 }
 
 static void snd_rme9652_free_buffers(struct snd_rme9652 *rme9652)

commit f526afcd8f71945c23ce581d7864ace93de8a4f7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 08:04:41 2018 +0200

    ALSA: rme9652: Hardening for potential Spectre v1
    
    As recently Smatch suggested, one place in RME9652 driver may expand
    the array directly from the user-space value with speculation:
      sound/pci/rme9652/rme9652.c:2074 snd_rme9652_channel_info() warn: potential spectre issue 'rme9652->channel_map' (local cap)
    
    This patch puts array_index_nospec() for hardening against it.
    
    BugLink: https://marc.info/?l=linux-kernel&m=152411496503418&w=2
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index df648b1d9217..edd765e22377 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -26,6 +26,7 @@
 #include <linux/pci.h>
 #include <linux/module.h>
 #include <linux/io.h>
+#include <linux/nospec.h>
 
 #include <sound/core.h>
 #include <sound/control.h>
@@ -2071,9 +2072,10 @@ static int snd_rme9652_channel_info(struct snd_pcm_substream *substream,
 	if (snd_BUG_ON(info->channel >= RME9652_NCHANNELS))
 		return -EINVAL;
 
-	if ((chn = rme9652->channel_map[info->channel]) < 0) {
+	chn = rme9652->channel_map[array_index_nospec(info->channel,
+						      RME9652_NCHANNELS)];
+	if (chn < 0)
 		return -EINVAL;
-	}
 
 	info->offset = chn * RME9652_CHANNEL_BUFFER_BYTES;
 	info->first = 0;

commit 2675be5a004ee0d8155d2ad48cad95920f727921
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Aug 14 22:00:40 2017 +0200

    ALSA: rme9652: Use common error handling code in two functions
    
    Add a jump target so that a bit of exception handling can be better reused
    in these functions.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index eff499355b52..df648b1d9217 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2618,19 +2618,17 @@ static int snd_rme9652_probe(struct pci_dev *pci,
 	card->private_free = snd_rme9652_card_free;
 	rme9652->dev = dev;
 	rme9652->pci = pci;
-
-	if ((err = snd_rme9652_create(card, rme9652, precise_ptr[dev])) < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	err = snd_rme9652_create(card, rme9652, precise_ptr[dev]);
+	if (err)
+		goto free_card;
 
 	strcpy(card->shortname, rme9652->card_name);
 
 	sprintf(card->longname, "%s at 0x%lx, irq %d",
 		card->shortname, rme9652->port, rme9652->irq);
-
-	
-	if ((err = snd_card_register(card)) < 0) {
+	err = snd_card_register(card);
+	if (err) {
+free_card:
 		snd_card_free(card);
 		return err;
 	}

commit 18ed1cf00b9ad47021fda5d7392b32dadc788097
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:25 2017 +0530

    ALSA: rme9652: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 150d08898db8..eff499355b52 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2181,7 +2181,7 @@ static int snd_rme9652_prepare(struct snd_pcm_substream *substream)
 	return result;
 }
 
-static struct snd_pcm_hardware snd_rme9652_playback_subinfo =
+static const struct snd_pcm_hardware snd_rme9652_playback_subinfo =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_MMAP_VALID |
@@ -2205,7 +2205,7 @@ static struct snd_pcm_hardware snd_rme9652_playback_subinfo =
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_rme9652_capture_subinfo =
+static const struct snd_pcm_hardware snd_rme9652_capture_subinfo =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_MMAP_VALID |

commit f9fee5534dedd15e69572d2fc2f050e4be3b1d6a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:22:43 2017 +0200

    ALSA: rme9652: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 59684bf5cac0..150d08898db8 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2228,9 +2228,9 @@ static struct snd_pcm_hardware snd_rme9652_capture_subinfo =
 	.fifo_size =		0,
 };
 
-static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+static const unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
 
-static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
+static const struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 	.count = ARRAY_SIZE(period_sizes),
 	.list = period_sizes,
 	.mask = 0

commit 7b6ae34da6302ea1b64b45c957c1a323e1fb2e08
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 20:31:41 2017 +0200

    ALSA: rme9652: Convert to the new PCM ops
    
    Replace the copy and the silence ops with the new PCM ops.
    The conversion is straightforward with standard helper functions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 55172c689991..59684bf5cac0 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1883,13 +1883,14 @@ static char *rme9652_channel_buffer_location(struct snd_rme9652 *rme9652,
 	}
 }
 
-static int snd_rme9652_playback_copy(struct snd_pcm_substream *substream, int channel,
-				     snd_pcm_uframes_t pos, void __user *src, snd_pcm_uframes_t count)
+static int snd_rme9652_playback_copy(struct snd_pcm_substream *substream,
+				     int channel, unsigned long pos,
+				     void __user *src, unsigned long count)
 {
 	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
-	if (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES / 4))
+	if (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES))
 		return -EINVAL;
 
 	channel_buf = rme9652_channel_buffer_location (rme9652,
@@ -1897,18 +1898,35 @@ static int snd_rme9652_playback_copy(struct snd_pcm_substream *substream, int ch
 						       channel);
 	if (snd_BUG_ON(!channel_buf))
 		return -EIO;
-	if (copy_from_user(channel_buf + pos * 4, src, count * 4))
+	if (copy_from_user(channel_buf + pos, src, count))
 		return -EFAULT;
-	return count;
+	return 0;
 }
 
-static int snd_rme9652_capture_copy(struct snd_pcm_substream *substream, int channel,
-				    snd_pcm_uframes_t pos, void __user *dst, snd_pcm_uframes_t count)
+static int snd_rme9652_playback_copy_kernel(struct snd_pcm_substream *substream,
+					    int channel, unsigned long pos,
+					    void *src, unsigned long count)
 {
 	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
-	if (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES / 4))
+	channel_buf = rme9652_channel_buffer_location(rme9652,
+						      substream->pstr->stream,
+						      channel);
+	if (snd_BUG_ON(!channel_buf))
+		return -EIO;
+	memcpy(channel_buf + pos, src, count);
+	return 0;
+}
+
+static int snd_rme9652_capture_copy(struct snd_pcm_substream *substream,
+				    int channel, unsigned long pos,
+				    void __user *dst, unsigned long count)
+{
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	if (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES))
 		return -EINVAL;
 
 	channel_buf = rme9652_channel_buffer_location (rme9652,
@@ -1916,13 +1934,30 @@ static int snd_rme9652_capture_copy(struct snd_pcm_substream *substream, int cha
 						       channel);
 	if (snd_BUG_ON(!channel_buf))
 		return -EIO;
-	if (copy_to_user(dst, channel_buf + pos * 4, count * 4))
+	if (copy_to_user(dst, channel_buf + pos, count))
 		return -EFAULT;
-	return count;
+	return 0;
 }
 
-static int snd_rme9652_hw_silence(struct snd_pcm_substream *substream, int channel,
-				  snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+static int snd_rme9652_capture_copy_kernel(struct snd_pcm_substream *substream,
+					   int channel, unsigned long pos,
+					   void *dst, unsigned long count)
+{
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	channel_buf = rme9652_channel_buffer_location(rme9652,
+						      substream->pstr->stream,
+						      channel);
+	if (snd_BUG_ON(!channel_buf))
+		return -EIO;
+	memcpy(dst, channel_buf + pos, count);
+	return 0;
+}
+
+static int snd_rme9652_hw_silence(struct snd_pcm_substream *substream,
+				  int channel, unsigned long pos,
+				  unsigned long count)
 {
 	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	char *channel_buf;
@@ -1932,8 +1967,8 @@ static int snd_rme9652_hw_silence(struct snd_pcm_substream *substream, int chann
 						       channel);
 	if (snd_BUG_ON(!channel_buf))
 		return -EIO;
-	memset(channel_buf + pos * 4, 0, count * 4);
-	return count;
+	memset(channel_buf + pos, 0, count);
+	return 0;
 }
 
 static int snd_rme9652_reset(struct snd_pcm_substream *substream)
@@ -2376,8 +2411,9 @@ static const struct snd_pcm_ops snd_rme9652_playback_ops = {
 	.prepare =	snd_rme9652_prepare,
 	.trigger =	snd_rme9652_trigger,
 	.pointer =	snd_rme9652_hw_pointer,
-	.copy =		snd_rme9652_playback_copy,
-	.silence =	snd_rme9652_hw_silence,
+	.copy_user =	snd_rme9652_playback_copy,
+	.copy_kernel =	snd_rme9652_playback_copy_kernel,
+	.fill_silence =	snd_rme9652_hw_silence,
 };
 
 static const struct snd_pcm_ops snd_rme9652_capture_ops = {
@@ -2388,7 +2424,8 @@ static const struct snd_pcm_ops snd_rme9652_capture_ops = {
 	.prepare =	snd_rme9652_prepare,
 	.trigger =	snd_rme9652_trigger,
 	.pointer =	snd_rme9652_hw_pointer,
-	.copy =		snd_rme9652_capture_copy,
+	.copy_user =	snd_rme9652_capture_copy,
+	.copy_kernel =	snd_rme9652_capture_copy_kernel,
 };
 
 static int snd_rme9652_create_pcm(struct snd_card *card,

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index fdbc0aa2776a..55172c689991 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2368,7 +2368,7 @@ static int snd_rme9652_capture_release(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static struct snd_pcm_ops snd_rme9652_playback_ops = {
+static const struct snd_pcm_ops snd_rme9652_playback_ops = {
 	.open =		snd_rme9652_playback_open,
 	.close =	snd_rme9652_playback_release,
 	.ioctl =	snd_rme9652_ioctl,
@@ -2380,7 +2380,7 @@ static struct snd_pcm_ops snd_rme9652_playback_ops = {
 	.silence =	snd_rme9652_hw_silence,
 };
 
-static struct snd_pcm_ops snd_rme9652_capture_ops = {
+static const struct snd_pcm_ops snd_rme9652_capture_ops = {
 	.open =		snd_rme9652_capture_open,
 	.close =	snd_rme9652_capture_release,
 	.ioctl =	snd_rme9652_ioctl,

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 648911c1a226..fdbc0aa2776a 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -25,6 +25,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/module.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/control.h>
@@ -34,7 +35,6 @@
 #include <sound/initval.h>
 
 #include <asm/current.h>
-#include <asm/io.h>
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */

commit ff6defa6a8fae12205d64f55db395b1fcf35af8e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 3 22:55:54 2015 +0100

    ALSA: Deletion of checks before the function call "iounmap"
    
    The iounmap() function performs also input parameter validation.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 6521521853b8..648911c1a226 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1756,8 +1756,7 @@ static int snd_rme9652_free(struct snd_rme9652 *rme9652)
 
 	if (rme9652->irq >= 0)
 		free_irq(rme9652->irq, (void *)rme9652);
-	if (rme9652->iobase)
-		iounmap(rme9652->iobase);
+	iounmap(rme9652->iobase);
 	if (rme9652->port)
 		pci_release_regions(rme9652->pci);
 

commit 7298ece7a26753b073a9ce5f979a4942d3904d44
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 20 18:19:53 2014 +0200

    ALSA: rme9652: Use snd_ctl_enum_info()
    
    ... and reduce the open codes.  Also add missing const to text arrays.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index fa9a2a8dce5a..6521521853b8 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -920,15 +920,9 @@ static int rme9652_set_adat1_input(struct snd_rme9652 *rme9652, int internal)
 
 static int snd_rme9652_info_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[2] = {"ADAT1", "Internal"};
+	static const char * const texts[2] = {"ADAT1", "Internal"};
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 2;
-	if (uinfo->value.enumerated.item > 1)
-		uinfo->value.enumerated.item = 1;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 2, texts);
 }
 
 static int snd_rme9652_get_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
@@ -991,15 +985,9 @@ static int rme9652_set_spdif_input(struct snd_rme9652 *rme9652, int in)
 
 static int snd_rme9652_info_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[3] = {"ADAT1", "Coaxial", "Internal"};
+	static const char * const texts[3] = {"ADAT1", "Coaxial", "Internal"};
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-	if (uinfo->value.enumerated.item > 2)
-		uinfo->value.enumerated.item = 2;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 3, texts);
 }
 
 static int snd_rme9652_get_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
@@ -1140,15 +1128,11 @@ static int rme9652_set_sync_mode(struct snd_rme9652 *rme9652, int mode)
 
 static int snd_rme9652_info_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[3] = {"AutoSync", "Master", "Word Clock"};
+	static const char * const texts[3] = {
+		"AutoSync", "Master", "Word Clock"
+	};
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-	if (uinfo->value.enumerated.item > 2)
-		uinfo->value.enumerated.item = 2;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 3, texts);
 }
 
 static int snd_rme9652_get_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
@@ -1231,16 +1215,14 @@ static int rme9652_set_sync_pref(struct snd_rme9652 *rme9652, int pref)
 
 static int snd_rme9652_info_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[4] = {"IEC958 In", "ADAT1 In", "ADAT2 In", "ADAT3 In"};
+	static const char * const texts[4] = {
+		"IEC958 In", "ADAT1 In", "ADAT2 In", "ADAT3 In"
+	};
 	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = rme9652->ss_channels == RME9652_NCHANNELS ? 4 : 3;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1,
+				 rme9652->ss_channels == RME9652_NCHANNELS ? 4 : 3,
+				 texts);
 }
 
 static int snd_rme9652_get_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
@@ -1392,15 +1374,11 @@ static int snd_rme9652_get_spdif_rate(struct snd_kcontrol *kcontrol, struct snd_
 
 static int snd_rme9652_info_adat_sync(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[4] = {"No Lock", "Lock", "No Lock Sync", "Lock Sync"};
+	static const char * const texts[4] = {
+		"No Lock", "Lock", "No Lock Sync", "Lock Sync"
+	};
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 4;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 4, texts);
 }
 
 static int snd_rme9652_get_adat_sync(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 1d9be90f7748..fa9a2a8dce5a 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -307,7 +307,7 @@ static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_d
 }
 
 
-static DEFINE_PCI_DEVICE_TABLE(snd_rme9652_ids) = {
+static const struct pci_device_id snd_rme9652_ids[] = {
 	{
 		.vendor	   = 0x10ee,
 		.device	   = 0x3fc4,

commit 09ae539e4d8fda9729e44e57967f7133dadc3f1e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 12:06:24 2014 +0100

    ALSA: rme9652: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index a62d6e13d8ce..1d9be90f7748 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -394,7 +394,9 @@ static snd_pcm_uframes_t rme9652_hw_pointer(struct snd_rme9652 *rme9652)
 	if (offset < period_size) {
 		if (offset > rme9652->max_jitter) {
 			if (frag)
-				printk(KERN_ERR "Unexpected hw_pointer position (bufid == 0): status: %x offset: %d\n", status, offset);
+				dev_err(rme9652->card->dev,
+					"Unexpected hw_pointer position (bufid == 0): status: %x offset: %d\n",
+					status, offset);
 		} else if (!frag)
 			return 0;
 		offset -= rme9652->max_jitter;
@@ -403,7 +405,9 @@ static snd_pcm_uframes_t rme9652_hw_pointer(struct snd_rme9652 *rme9652)
 	} else {
 		if (offset > period_size + rme9652->max_jitter) {
 			if (!frag)
-				printk(KERN_ERR "Unexpected hw_pointer position (bufid == 1): status: %x offset: %d\n", status, offset);
+				dev_err(rme9652->card->dev,
+					"Unexpected hw_pointer position (bufid == 1): status: %x offset: %d\n",
+					status, offset);
 		} else if (frag)
 			return period_size;
 		offset -= rme9652->max_jitter;
@@ -769,7 +773,8 @@ static inline int rme9652_spdif_sample_rate(struct snd_rme9652 *s)
 		break;
 
 	default:
-		snd_printk(KERN_ERR "%s: unknown S/PDIF input rate (bits = 0x%x)\n",
+		dev_err(s->card->dev,
+			"%s: unknown S/PDIF input rate (bits = 0x%x)\n",
 			   s->card_name, rate_bits);
 		return 0;
 		break;
@@ -1790,7 +1795,8 @@ static int snd_rme9652_initialize_memory(struct snd_rme9652 *rme9652)
 	    snd_hammerfall_get_buffer(rme9652->pci, &rme9652->playback_dma_buf, RME9652_DMA_AREA_BYTES) < 0) {
 		if (rme9652->capture_dma_buf.area)
 			snd_dma_free_pages(&rme9652->capture_dma_buf);
-		printk(KERN_ERR "%s: no buffers available\n", rme9652->card_name);
+		dev_err(rme9652->card->dev,
+			"%s: no buffers available\n", rme9652->card_name);
 		return -ENOMEM;
 	}
 
@@ -2468,13 +2474,14 @@ static int snd_rme9652_create(struct snd_card *card,
 	rme9652->port = pci_resource_start(pci, 0);
 	rme9652->iobase = ioremap_nocache(rme9652->port, RME9652_IO_EXTENT);
 	if (rme9652->iobase == NULL) {
-		snd_printk(KERN_ERR "unable to remap region 0x%lx-0x%lx\n", rme9652->port, rme9652->port + RME9652_IO_EXTENT - 1);
+		dev_err(card->dev, "unable to remap region 0x%lx-0x%lx\n",
+			rme9652->port, rme9652->port + RME9652_IO_EXTENT - 1);
 		return -EBUSY;
 	}
 	
 	if (request_irq(pci->irq, snd_rme9652_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, rme9652)) {
-		snd_printk(KERN_ERR "unable to request IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to request IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}
 	rme9652->irq = pci->irq;

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 1503ee3585fd..a62d6e13d8ce 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2587,8 +2587,8 @@ static int snd_rme9652_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE,
-			      sizeof(struct snd_rme9652), &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   sizeof(struct snd_rme9652), &card);
 
 	if (err < 0)
 		return err;
@@ -2597,7 +2597,6 @@ static int snd_rme9652_probe(struct pci_dev *pci,
 	card->private_free = snd_rme9652_card_free;
 	rme9652->dev = dev;
 	rme9652->pci = pci;
-	snd_card_set_dev(card, &pci->dev);
 
 	if ((err = snd_rme9652_create(card, rme9652, precise_ptr[dev])) < 0) {
 		snd_card_free(card);

commit 47d98c026ef9a9888c36f3c4f26b81f548a0ca86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 8 16:12:25 2014 +0100

    ALSA: Remove memory reservation code from memalloc helper
    
    Nowadays we have CMA for obtaining the contiguous memory pages
    efficiently.  Let's kill the old kludge for reserving the memory pages
    for large buffers.  It was rarely useful (only for preserving pages
    among module reloading or a little help by an early boot scripting),
    used only by a couple of drivers, and yet it gives too much ugliness
    than its benefit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 3717f2dd30be..1503ee3585fd 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -294,10 +294,6 @@ static int snd_hammerfall_get_buffer(struct pci_dev *pci, struct snd_dma_buffer
 {
 	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 	dmab->dev.dev = snd_dma_pci_data(pci);
-	if (snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {
-		if (dmab->bytes >= size)
-			return 0;
-	}
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
 				size, dmab) < 0)
 		return -ENOMEM;
@@ -306,10 +302,8 @@ static int snd_hammerfall_get_buffer(struct pci_dev *pci, struct snd_dma_buffer
 
 static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_dev *pci)
 {
-	if (dmab->area) {
-		dmab->dev.dev = NULL; /* make it anonymous */
-		snd_dma_reserve_buf(dmab, snd_dma_pci_buf_id(pci));
-	}
+	if (dmab->area)
+		snd_dma_free_pages(dmab);
 }
 
 

commit 770bd4bf2e664939a9dacd3d26ec9ff7a3933210
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Dec 27 00:13:08 2013 +0200

    ALSA: rme9652: fix a missing comma in channel_map_9636_ds[]
    
    The lack of comma leads to the wrong channel for an SPDIF channel.
    Unfortunately this wasn't caught by compiler because it's still a
    valid expression.
    
    Reported-by: Alexander Aristov <aristov.alexander@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index b96d9e1adf6d..3717f2dd30be 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -285,7 +285,7 @@ static char channel_map_9636_ds[26] = {
 	/* ADAT channels are remapped */
 	1, 3, 5, 7, 9, 11, 13, 15,
 	/* channels 8 and 9 are S/PDIF */
-	24, 25
+	24, 25,
 	/* others don't exist */
 	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
 };

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 773a67fff4cd..b96d9e1adf6d 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2628,7 +2628,6 @@ static int snd_rme9652_probe(struct pci_dev *pci,
 static void snd_rme9652_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver rme9652_driver = {

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index a15fc100ab0c..773a67fff4cd 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1757,7 +1757,7 @@ snd_rme9652_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buff
 	snd_iprintf(buffer, "\n");
 }
 
-static void __devinit snd_rme9652_proc_init(struct snd_rme9652 *rme9652)
+static void snd_rme9652_proc_init(struct snd_rme9652 *rme9652)
 {
 	struct snd_info_entry *entry;
 
@@ -1788,7 +1788,7 @@ static int snd_rme9652_free(struct snd_rme9652 *rme9652)
 	return 0;
 }
 
-static int __devinit snd_rme9652_initialize_memory(struct snd_rme9652 *rme9652)
+static int snd_rme9652_initialize_memory(struct snd_rme9652 *rme9652)
 {
 	unsigned long pb_bus, cb_bus;
 
@@ -2414,8 +2414,8 @@ static struct snd_pcm_ops snd_rme9652_capture_ops = {
 	.copy =		snd_rme9652_capture_copy,
 };
 
-static int __devinit snd_rme9652_create_pcm(struct snd_card *card,
-					 struct snd_rme9652 *rme9652)
+static int snd_rme9652_create_pcm(struct snd_card *card,
+				  struct snd_rme9652 *rme9652)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -2438,9 +2438,9 @@ static int __devinit snd_rme9652_create_pcm(struct snd_card *card,
 	return 0;
 }
 
-static int __devinit snd_rme9652_create(struct snd_card *card,
-				     struct snd_rme9652 *rme9652,
-				     int precise_ptr)
+static int snd_rme9652_create(struct snd_card *card,
+			      struct snd_rme9652 *rme9652,
+			      int precise_ptr)
 {
 	struct pci_dev *pci = rme9652->pci;
 	int err;
@@ -2578,8 +2578,8 @@ static void snd_rme9652_card_free(struct snd_card *card)
 		snd_rme9652_free(rme9652);
 }
 
-static int __devinit snd_rme9652_probe(struct pci_dev *pci,
-				       const struct pci_device_id *pci_id)
+static int snd_rme9652_probe(struct pci_dev *pci,
+			     const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_rme9652 *rme9652;
@@ -2625,7 +2625,7 @@ static int __devinit snd_rme9652_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit snd_rme9652_remove(struct pci_dev *pci)
+static void snd_rme9652_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -2635,7 +2635,7 @@ static struct pci_driver rme9652_driver = {
 	.name	  = KBUILD_MODNAME,
 	.id_table = snd_rme9652_ids,
 	.probe	  = snd_rme9652_probe,
-	.remove	  = __devexit_p(snd_rme9652_remove),
+	.remove	  = snd_rme9652_remove,
 };
 
 module_pci_driver(rme9652_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index b737d1619cc7..a15fc100ab0c 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2631,22 +2631,11 @@ static void __devexit snd_rme9652_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-static struct pci_driver driver = {
+static struct pci_driver rme9652_driver = {
 	.name	  = KBUILD_MODNAME,
 	.id_table = snd_rme9652_ids,
 	.probe	  = snd_rme9652_probe,
 	.remove	  = __devexit_p(snd_rme9652_remove),
 };
 
-static int __init alsa_card_hammerfall_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_hammerfall_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_hammerfall_init)
-module_exit(alsa_card_hammerfall_exit)
+module_pci_driver(rme9652_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 732c5e837437..b737d1619cc7 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -38,8 +38,8 @@
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
-static int precise_ptr[SNDRV_CARDS];			/* Enable precise pointer */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static bool precise_ptr[SNDRV_CARDS];			/* Enable precise pointer */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for RME Digi9652 (Hammerfall) soundcard.");

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 1c7bc1ef8186..732c5e837437 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -24,7 +24,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 
 #include <sound/core.h>
 #include <sound/control.h>

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 9646a8422a85..1c7bc1ef8186 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2479,7 +2479,7 @@ static int __devinit snd_rme9652_create(struct snd_card *card,
 	}
 	
 	if (request_irq(pci->irq, snd_rme9652_interrupt, IRQF_SHARED,
-			"rme9652", rme9652)) {
+			KBUILD_MODNAME, rme9652)) {
 		snd_printk(KERN_ERR "unable to request IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index c492af5b25f3..9646a8422a85 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2632,7 +2632,7 @@ static void __devexit snd_rme9652_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver driver = {
-	.name	  = "RME Digi9652 (Hammerfall)",
+	.name	  = KBUILD_MODNAME,
 	.id_table = snd_rme9652_ids,
 	.probe	  = snd_rme9652_probe,
 	.remove	  = __devexit_p(snd_rme9652_remove),

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 44a3e2d8c556..c492af5b25f3 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -24,7 +24,6 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
-#include <linux/slab.h>
 #include <linux/moduleparam.h>
 
 #include <sound/core.h>

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index bc539abb2105..44a3e2d8c556 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -314,7 +314,7 @@ static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_d
 }
 
 
-static struct pci_device_id snd_rme9652_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_rme9652_ids) = {
 	{
 		.vendor	   = 0x10ee,
 		.device	   = 0x3fc4,

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 2570907134d7..bc539abb2105 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2594,11 +2594,11 @@ static int __devinit snd_rme9652_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-			    sizeof(struct snd_rme9652));
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE,
+			      sizeof(struct snd_rme9652), &card);
 
-	if (!card)
-		return -ENOMEM;
+	if (err < 0)
+		return err;
 
 	rme9652 = (struct snd_rme9652 *) card->private_data;
 	card->private_free = snd_rme9652_card_free;

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index a123f0e6ba23..2570907134d7 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -595,8 +595,6 @@ static void rme9652_set_thru(struct snd_rme9652 *rme9652, int channel, int enabl
 	} else {
 		int mapped_channel;
 
-		snd_assert(channel == RME9652_NCHANNELS, return);
-
 		mapped_channel = rme9652->channel_map[channel];
 
 		if (enable) {
@@ -1893,7 +1891,8 @@ static char *rme9652_channel_buffer_location(struct snd_rme9652 *rme9652,
 {
 	int mapped_channel;
 
-        snd_assert(channel >= 0 || channel < RME9652_NCHANNELS, return NULL);
+	if (snd_BUG_ON(channel < 0 || channel >= RME9652_NCHANNELS))
+		return NULL;
         
 	if ((mapped_channel = rme9652->channel_map[channel]) < 0) {
 		return NULL;
@@ -1914,12 +1913,14 @@ static int snd_rme9652_playback_copy(struct snd_pcm_substream *substream, int ch
 	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
-	snd_assert(pos + count <= RME9652_CHANNEL_BUFFER_BYTES / 4, return -EINVAL);
+	if (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES / 4))
+		return -EINVAL;
 
 	channel_buf = rme9652_channel_buffer_location (rme9652,
 						       substream->pstr->stream,
 						       channel);
-	snd_assert(channel_buf != NULL, return -EIO);
+	if (snd_BUG_ON(!channel_buf))
+		return -EIO;
 	if (copy_from_user(channel_buf + pos * 4, src, count * 4))
 		return -EFAULT;
 	return count;
@@ -1931,12 +1932,14 @@ static int snd_rme9652_capture_copy(struct snd_pcm_substream *substream, int cha
 	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
-	snd_assert(pos + count <= RME9652_CHANNEL_BUFFER_BYTES / 4, return -EINVAL);
+	if (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES / 4))
+		return -EINVAL;
 
 	channel_buf = rme9652_channel_buffer_location (rme9652,
 						       substream->pstr->stream,
 						       channel);
-	snd_assert(channel_buf != NULL, return -EIO);
+	if (snd_BUG_ON(!channel_buf))
+		return -EIO;
 	if (copy_to_user(dst, channel_buf + pos * 4, count * 4))
 		return -EFAULT;
 	return count;
@@ -1951,7 +1954,8 @@ static int snd_rme9652_hw_silence(struct snd_pcm_substream *substream, int chann
 	channel_buf = rme9652_channel_buffer_location (rme9652,
 						       substream->pstr->stream,
 						       channel);
-	snd_assert(channel_buf != NULL, return -EIO);
+	if (snd_BUG_ON(!channel_buf))
+		return -EIO;
 	memset(channel_buf + pos * 4, 0, count * 4);
 	return count;
 }
@@ -2053,7 +2057,8 @@ static int snd_rme9652_channel_info(struct snd_pcm_substream *substream,
 	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	int chn;
 
-	snd_assert(info->channel < RME9652_NCHANNELS, return -EINVAL);
+	if (snd_BUG_ON(info->channel >= RME9652_NCHANNELS))
+		return -EINVAL;
 
 	if ((chn = rme9652->channel_map[info->channel]) < 0) {
 		return -EINVAL;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 1d73be692b08..a123f0e6ba23 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -20,7 +20,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit 561de31a23a8a5d23baeb8b2ce7c6102cb649616
Author: Joe Perches <joe@perches.com>
Date:   Tue Dec 18 13:13:47 2007 +0100

    [ALSA] sound/: Spelling fixes
    
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 34f96f12e5bf..1d73be692b08 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -148,7 +148,7 @@ MODULE_SUPPORTED_DEVICE("{{RME,Hammerfall},"
 #define RME9652_start_bit	   (1<<0)	/* start record/play */
                                                 /* bits 1-3 encode buffersize/latency */
 #define RME9652_Master		   (1<<4)	/* Clock Mode Master=1,Slave/Auto=0 */
-#define RME9652_IE		   (1<<5)	/* Interupt Enable */
+#define RME9652_IE		   (1<<5)	/* Interrupt Enable */
 #define RME9652_freq		   (1<<6)       /* samplerate 0=44.1/88.2, 1=48/96 kHz */
 #define RME9652_freq1		   (1<<7)       /* if 0, 32kHz, else always 1 */
 #define RME9652_DS                 (1<<8)	/* Doule Speed 0=44.1/48, 1=88.2/96 Khz */
@@ -1826,7 +1826,7 @@ static void snd_rme9652_set_defaults(struct snd_rme9652 *rme9652)
 
 	/* ASSUMPTION: rme9652->lock is either held, or
 	   there is no need to hold it (e.g. during module
-	   initalization).
+	   initialization).
 	 */
 
 	/* set defaults:

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 2de27405a0bd..34f96f12e5bf 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1067,14 +1067,7 @@ static int rme9652_set_spdif_output(struct snd_rme9652 *rme9652, int out)
 	return 0;
 }
 
-static int snd_rme9652_info_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_rme9652_info_spdif_out	snd_ctl_boolean_mono_info
 
 static int snd_rme9652_get_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
@@ -1338,14 +1331,7 @@ static int snd_rme9652_put_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_el
   .put = snd_rme9652_put_passthru, \
   .get = snd_rme9652_get_passthru }
 
-static int snd_rme9652_info_passthru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_rme9652_info_passthru	snd_ctl_boolean_mono_info
 
 static int snd_rme9652_get_passthru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
@@ -1445,14 +1431,7 @@ static int snd_rme9652_get_adat_sync(struct snd_kcontrol *kcontrol, struct snd_c
   .info = snd_rme9652_info_tc_valid, \
   .get = snd_rme9652_get_tc_valid }
 
-static int snd_rme9652_info_tc_valid(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_rme9652_info_tc_valid	snd_ctl_boolean_mono_info
 
 static int snd_rme9652_get_tc_valid(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {

commit 304e3bb7a15d839cef64b24a1bcc1230b2ae6fa6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 30 12:46:21 2007 +0200

    [ALSA] rme9652 - Fix the hw_pointer check
    
    The negative check in hw_pointer callback doesn't work because the
    value is unsigned.  Cast to int in the comparison to fix this.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index bd7dbd267ed1..2de27405a0bd 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -406,7 +406,7 @@ static snd_pcm_uframes_t rme9652_hw_pointer(struct snd_rme9652 *rme9652)
 		} else if (!frag)
 			return 0;
 		offset -= rme9652->max_jitter;
-		if (offset < 0)
+		if ((int)offset < 0)
 			offset += period_size * 2;
 	} else {
 		if (offset > period_size + rme9652->max_jitter) {

commit ef991b95aa1351a5782cfaccb9aefba76ca8b990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:52:53 2007 +0100

    [ALSA] Add snd_pcm_group_for_each_entry() for code cleanup
    
    Added a new macro snd_pcm_group_for_each_entry() just for code cleanup.
    Old macros, snd_pcm_group_for_each() and snd_pcm_group_substream_entry(),
    are removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index cc3bdececce7..bd7dbd267ed1 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1992,11 +1992,9 @@ static int snd_rme9652_reset(struct snd_pcm_substream *substream)
 	else
 		runtime->status->hw_ptr = 0;
 	if (other) {
-		struct list_head *pos;
 		struct snd_pcm_substream *s;
 		struct snd_pcm_runtime *oruntime = other->runtime;
-		snd_pcm_group_for_each(pos, substream) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, substream) {
 			if (s == other) {
 				oruntime->status->hw_ptr = runtime->status->hw_ptr;
 				break;
@@ -2140,10 +2138,8 @@ static int snd_rme9652_trigger(struct snd_pcm_substream *substream,
 		other = rme9652->playback_substream;
 
 	if (other) {
-		struct list_head *pos;
 		struct snd_pcm_substream *s;
-		snd_pcm_group_for_each(pos, substream) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, substream) {
 			if (s == other) {
 				snd_pcm_trigger_done(s, substream);
 				if (cmd == SNDRV_PCM_TRIGGER_START)

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index dadd588dccc6..cc3bdececce7 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2500,7 +2500,8 @@ static int __devinit snd_rme9652_create(struct snd_card *card,
 		return -EBUSY;
 	}
 	
-	if (request_irq(pci->irq, snd_rme9652_interrupt, IRQF_DISABLED|IRQF_SHARED, "rme9652", (void *)rme9652)) {
+	if (request_irq(pci->irq, snd_rme9652_interrupt, IRQF_SHARED,
+			"rme9652", rme9652)) {
 		snd_printk(KERN_ERR "unable to request IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 7ab399262ee636d19db5163a35ac406d5b892a0a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Oct 9 08:13:32 2006 +0200

    [ALSA] use the ALIGN macro
    
    Use the ALIGN macro instead of manual calculations.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index cf0427b4bfde..dadd588dccc6 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1827,8 +1827,8 @@ static int __devinit snd_rme9652_initialize_memory(struct snd_rme9652 *rme9652)
 
 	/* Align to bus-space 64K boundary */
 
-	cb_bus = (rme9652->capture_dma_buf.addr + 0xFFFF) & ~0xFFFFl;
-	pb_bus = (rme9652->playback_dma_buf.addr + 0xFFFF) & ~0xFFFFl;
+	cb_bus = ALIGN(rme9652->capture_dma_buf.addr, 0x10000ul);
+	pb_bus = ALIGN(rme9652->playback_dma_buf.addr, 0x10000ul);
 
 	/* Tell the card where it is */
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index fc15f61ad5d1..cf0427b4bfde 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1882,7 +1882,7 @@ static void snd_rme9652_set_defaults(struct snd_rme9652 *rme9652)
 	rme9652_set_rate(rme9652, 48000);
 }
 
-static irqreturn_t snd_rme9652_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_rme9652_interrupt(int irq, void *dev_id)
 {
 	struct snd_rme9652 *rme9652 = (struct snd_rme9652 *) dev_id;
 

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 9534e1834138..fc15f61ad5d1 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -315,7 +315,7 @@ static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_d
 }
 
 
-static struct pci_device_id snd_rme9652_ids[] __devinitdata = {
+static struct pci_device_id snd_rme9652_ids[] = {
 	{
 		.vendor	   = 0x10ee,
 		.device	   = 0x3fc4,

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 3b945e8c1b15..9534e1834138 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2500,7 +2500,7 @@ static int __devinit snd_rme9652_create(struct snd_card *card,
 		return -EBUSY;
 	}
 	
-	if (request_irq(pci->irq, snd_rme9652_interrupt, SA_INTERRUPT|SA_SHIRQ, "rme9652", (void *)rme9652)) {
+	if (request_irq(pci->irq, snd_rme9652_interrupt, IRQF_DISABLED|IRQF_SHARED, "rme9652", (void *)rme9652)) {
 		snd_printk(KERN_ERR "unable to request IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 6581f4e74d8541dd7d579f64e94822622cbb1654
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 17 17:14:51 2006 +0200

    [ALSA] Remove zero-initialization of static variables
    
    Removed zero-initializations of static variables.
    A tiny optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index ac14b2733f7c..3b945e8c1b15 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -41,7 +41,7 @@
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
-static int precise_ptr[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 }; /* Enable precise pointer */
+static int precise_ptr[SNDRV_CARDS];			/* Enable precise pointer */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for RME Digi9652 (Hammerfall) soundcard.");

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 75d6406303d3..ac14b2733f7c 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1787,7 +1787,7 @@ static void __devinit snd_rme9652_proc_init(struct snd_rme9652 *rme9652)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(rme9652->card, "rme9652", &entry))
-		snd_info_set_text_ops(entry, rme9652, 1024, snd_rme9652_proc_read);
+		snd_info_set_text_ops(entry, rme9652, snd_rme9652_proc_read);
 }
 
 static void snd_rme9652_free_buffers(struct snd_rme9652 *rme9652)

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index a687eb63236f..75d6406303d3 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -315,7 +315,7 @@ static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_d
 }
 
 
-static struct pci_device_id snd_rme9652_ids[] = {
+static struct pci_device_id snd_rme9652_ids[] __devinitdata = {
 	{
 		.vendor	   = 0x10ee,
 		.device	   = 0x3fc4,

commit abfd67bd6fcc07b54d54e00a9105900f478323a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:52:53 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI RME9652
    
    Modules: RME9652 driver
    
    Remove xxx_t typedefs from the PCI RME9652 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index f9d0c126c213..a687eb63236f 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -198,7 +198,7 @@ MODULE_SUPPORTED_DEVICE("{{RME,Hammerfall},"
 #define RME9652_DMA_AREA_BYTES ((RME9652_NCHANNELS+1) * RME9652_CHANNEL_BUFFER_BYTES)
 #define RME9652_DMA_AREA_KILOBYTES (RME9652_DMA_AREA_BYTES/1024)
 
-typedef struct snd_rme9652 {
+struct snd_rme9652 {
 	int dev;
 
 	spinlock_t lock;
@@ -234,8 +234,8 @@ typedef struct snd_rme9652 {
 	pid_t capture_pid;
 	pid_t playback_pid;
 
-	snd_pcm_substream_t *capture_substream;
-	snd_pcm_substream_t *playback_substream;
+	struct snd_pcm_substream *capture_substream;
+	struct snd_pcm_substream *playback_substream;
 	int running;
 
         int passthru;                   /* non-zero if doing pass-thru */
@@ -246,12 +246,12 @@ typedef struct snd_rme9652 {
 
         char *channel_map;
 
-	snd_card_t *card;
-	snd_pcm_t *pcm;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
 	struct pci_dev *pci;
-	snd_kcontrol_t *spdif_ctl;
+	struct snd_kcontrol *spdif_ctl;
 
-} rme9652_t;
+};
 
 /* These tables map the ALSA channels 1..N to the channels that we
    need to use in order to find the relevant channel buffer. RME
@@ -327,17 +327,17 @@ static struct pci_device_id snd_rme9652_ids[] = {
 
 MODULE_DEVICE_TABLE(pci, snd_rme9652_ids);
 
-static inline void rme9652_write(rme9652_t *rme9652, int reg, int val)
+static inline void rme9652_write(struct snd_rme9652 *rme9652, int reg, int val)
 {
 	writel(val, rme9652->iobase + reg);
 }
 
-static inline unsigned int rme9652_read(rme9652_t *rme9652, int reg)
+static inline unsigned int rme9652_read(struct snd_rme9652 *rme9652, int reg)
 {
 	return readl(rme9652->iobase + reg);
 }
 
-static inline int snd_rme9652_use_is_exclusive(rme9652_t *rme9652)
+static inline int snd_rme9652_use_is_exclusive(struct snd_rme9652 *rme9652)
 {
 	unsigned long flags;
 	int ret = 1;
@@ -351,7 +351,7 @@ static inline int snd_rme9652_use_is_exclusive(rme9652_t *rme9652)
 	return ret;
 }
 
-static inline int rme9652_adat_sample_rate(rme9652_t *rme9652)
+static inline int rme9652_adat_sample_rate(struct snd_rme9652 *rme9652)
 {
 	if (rme9652_running_double_speed(rme9652)) {
 		return (rme9652_read(rme9652, RME9652_status_register) &
@@ -362,7 +362,7 @@ static inline int rme9652_adat_sample_rate(rme9652_t *rme9652)
 	}
 }
 
-static inline void rme9652_compute_period_size(rme9652_t *rme9652)
+static inline void rme9652_compute_period_size(struct snd_rme9652 *rme9652)
 {
 	unsigned int i;
 
@@ -373,7 +373,7 @@ static inline void rme9652_compute_period_size(rme9652_t *rme9652)
 	rme9652->max_jitter = 80;
 }
 
-static snd_pcm_uframes_t rme9652_hw_pointer(rme9652_t *rme9652)
+static snd_pcm_uframes_t rme9652_hw_pointer(struct snd_rme9652 *rme9652)
 {
 	int status;
 	unsigned int offset, frag;
@@ -420,7 +420,7 @@ static snd_pcm_uframes_t rme9652_hw_pointer(rme9652_t *rme9652)
 	return offset;
 }
 
-static inline void rme9652_reset_hw_pointer(rme9652_t *rme9652)
+static inline void rme9652_reset_hw_pointer(struct snd_rme9652 *rme9652)
 {
 	int i;
 
@@ -437,19 +437,19 @@ static inline void rme9652_reset_hw_pointer(rme9652_t *rme9652)
 	rme9652->prev_hw_offset = 0;
 }
 
-static inline void rme9652_start(rme9652_t *s)
+static inline void rme9652_start(struct snd_rme9652 *s)
 {
 	s->control_register |= (RME9652_IE | RME9652_start_bit);
 	rme9652_write(s, RME9652_control_register, s->control_register);
 }
 
-static inline void rme9652_stop(rme9652_t *s)
+static inline void rme9652_stop(struct snd_rme9652 *s)
 {
 	s->control_register &= ~(RME9652_start_bit | RME9652_IE);
 	rme9652_write(s, RME9652_control_register, s->control_register);
 }
 
-static int rme9652_set_interrupt_interval(rme9652_t *s,
+static int rme9652_set_interrupt_interval(struct snd_rme9652 *s,
 					  unsigned int frames)
 {
 	int restart = 0;
@@ -483,7 +483,7 @@ static int rme9652_set_interrupt_interval(rme9652_t *s,
 	return 0;
 }
 
-static int rme9652_set_rate(rme9652_t *rme9652, int rate)
+static int rme9652_set_rate(struct snd_rme9652 *rme9652, int rate)
 {
 	int restart;
 	int reject_if_open = 0;
@@ -571,7 +571,7 @@ static int rme9652_set_rate(rme9652_t *rme9652, int rate)
 	return 0;
 }
 
-static void rme9652_set_thru(rme9652_t *rme9652, int channel, int enable)
+static void rme9652_set_thru(struct snd_rme9652 *rme9652, int channel, int enable)
 {
 	int i;
 
@@ -612,7 +612,7 @@ static void rme9652_set_thru(rme9652_t *rme9652, int channel, int enable)
 	}
 }
 
-static int rme9652_set_passthru(rme9652_t *rme9652, int onoff)
+static int rme9652_set_passthru(struct snd_rme9652 *rme9652, int onoff)
 {
 	if (onoff) {
 		rme9652_set_thru(rme9652, -1, 1);
@@ -640,7 +640,7 @@ static int rme9652_set_passthru(rme9652_t *rme9652, int onoff)
 	return 0;
 }
 
-static void rme9652_spdif_set_bit (rme9652_t *rme9652, int mask, int onoff)
+static void rme9652_spdif_set_bit (struct snd_rme9652 *rme9652, int mask, int onoff)
 {
 	if (onoff) 
 		rme9652->control_register |= mask;
@@ -650,7 +650,7 @@ static void rme9652_spdif_set_bit (rme9652_t *rme9652, int mask, int onoff)
 	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
 }
 
-static void rme9652_spdif_write_byte (rme9652_t *rme9652, const int val)
+static void rme9652_spdif_write_byte (struct snd_rme9652 *rme9652, const int val)
 {
 	long mask;
 	long i;
@@ -666,7 +666,7 @@ static void rme9652_spdif_write_byte (rme9652_t *rme9652, const int val)
 	}
 }
 
-static int rme9652_spdif_read_byte (rme9652_t *rme9652)
+static int rme9652_spdif_read_byte (struct snd_rme9652 *rme9652)
 {
 	long mask;
 	long val;
@@ -684,7 +684,7 @@ static int rme9652_spdif_read_byte (rme9652_t *rme9652)
 	return val;
 }
 
-static void rme9652_write_spdif_codec (rme9652_t *rme9652, const int address, const int data)
+static void rme9652_write_spdif_codec (struct snd_rme9652 *rme9652, const int address, const int data)
 {
 	rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);
 	rme9652_spdif_write_byte (rme9652, 0x20);
@@ -694,7 +694,7 @@ static void rme9652_write_spdif_codec (rme9652_t *rme9652, const int address, co
 }
 
 
-static int rme9652_spdif_read_codec (rme9652_t *rme9652, const int address)
+static int rme9652_spdif_read_codec (struct snd_rme9652 *rme9652, const int address)
 {
 	int ret;
 
@@ -711,7 +711,7 @@ static int rme9652_spdif_read_codec (rme9652_t *rme9652, const int address)
 	return ret;
 }
 
-static void rme9652_initialize_spdif_receiver (rme9652_t *rme9652)
+static void rme9652_initialize_spdif_receiver (struct snd_rme9652 *rme9652)
 {
 	/* XXX what unsets this ? */
 
@@ -722,7 +722,7 @@ static void rme9652_initialize_spdif_receiver (rme9652_t *rme9652)
 	rme9652_write_spdif_codec (rme9652, 6, 0x02);
 }
 
-static inline int rme9652_spdif_sample_rate(rme9652_t *s)
+static inline int rme9652_spdif_sample_rate(struct snd_rme9652 *s)
 {
 	unsigned int rate_bits;
 
@@ -790,7 +790,7 @@ static inline int rme9652_spdif_sample_rate(rme9652_t *s)
   Control Interface
   ----------------------------------------------------------------------------*/
 
-static u32 snd_rme9652_convert_from_aes(snd_aes_iec958_t *aes)
+static u32 snd_rme9652_convert_from_aes(struct snd_aes_iec958 *aes)
 {
 	u32 val = 0;
 	val |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME9652_PRO : 0;
@@ -802,7 +802,7 @@ static u32 snd_rme9652_convert_from_aes(snd_aes_iec958_t *aes)
 	return val;
 }
 
-static void snd_rme9652_convert_to_aes(snd_aes_iec958_t *aes, u32 val)
+static void snd_rme9652_convert_to_aes(struct snd_aes_iec958 *aes, u32 val)
 {
 	aes->status[0] = ((val & RME9652_PRO) ? IEC958_AES0_PROFESSIONAL : 0) |
 			 ((val & RME9652_Dolby) ? IEC958_AES0_NONAUDIO : 0);
@@ -812,24 +812,24 @@ static void snd_rme9652_convert_to_aes(snd_aes_iec958_t *aes, u32 val)
 		aes->status[0] |= (val & RME9652_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;
 }
 
-static int snd_rme9652_control_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_control_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_rme9652_control_spdif_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_control_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	
 	snd_rme9652_convert_to_aes(&ucontrol->value.iec958, rme9652->creg_spdif);
 	return 0;
 }
 
-static int snd_rme9652_control_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_control_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	int change;
 	u32 val;
 	
@@ -841,24 +841,24 @@ static int snd_rme9652_control_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem
 	return change;
 }
 
-static int snd_rme9652_control_spdif_stream_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_control_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_rme9652_control_spdif_stream_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_control_spdif_stream_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	
 	snd_rme9652_convert_to_aes(&ucontrol->value.iec958, rme9652->creg_spdif_stream);
 	return 0;
 }
 
-static int snd_rme9652_control_spdif_stream_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_control_spdif_stream_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	int change;
 	u32 val;
 	
@@ -872,14 +872,14 @@ static int snd_rme9652_control_spdif_stream_put(snd_kcontrol_t * kcontrol, snd_c
 	return change;
 }
 
-static int snd_rme9652_control_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_control_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_rme9652_control_spdif_mask_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_control_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	ucontrol->value.iec958.status[0] = kcontrol->private_value;
 	return 0;
@@ -891,14 +891,14 @@ static int snd_rme9652_control_spdif_mask_get(snd_kcontrol_t * kcontrol, snd_ctl
   .get = snd_rme9652_get_adat1_in, \
   .put = snd_rme9652_put_adat1_in }
 
-static unsigned int rme9652_adat1_in(rme9652_t *rme9652)
+static unsigned int rme9652_adat1_in(struct snd_rme9652 *rme9652)
 {
 	if (rme9652->control_register & RME9652_ADAT1_INTERNAL)
 		return 1; 
 	return 0;
 }
 
-static int rme9652_set_adat1_input(rme9652_t *rme9652, int internal)
+static int rme9652_set_adat1_input(struct snd_rme9652 *rme9652, int internal)
 {
 	int restart = 0;
 
@@ -923,7 +923,7 @@ static int rme9652_set_adat1_input(rme9652_t *rme9652, int internal)
 	return 0;
 }
 
-static int snd_rme9652_info_adat1_in(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[2] = {"ADAT1", "Internal"};
 
@@ -936,9 +936,9 @@ static int snd_rme9652_info_adat1_in(snd_kcontrol_t *kcontrol, snd_ctl_elem_info
 	return 0;
 }
 
-static int snd_rme9652_get_adat1_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme9652->lock);
 	ucontrol->value.enumerated.item[0] = rme9652_adat1_in(rme9652);
@@ -946,9 +946,9 @@ static int snd_rme9652_get_adat1_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
 	return 0;
 }
 
-static int snd_rme9652_put_adat1_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_put_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 	
@@ -968,13 +968,13 @@ static int snd_rme9652_put_adat1_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
   .info = snd_rme9652_info_spdif_in, \
   .get = snd_rme9652_get_spdif_in, .put = snd_rme9652_put_spdif_in }
 
-static unsigned int rme9652_spdif_in(rme9652_t *rme9652)
+static unsigned int rme9652_spdif_in(struct snd_rme9652 *rme9652)
 {
 	return rme9652_decode_spdif_in(rme9652->control_register &
 				       RME9652_inp);
 }
 
-static int rme9652_set_spdif_input(rme9652_t *rme9652, int in)
+static int rme9652_set_spdif_input(struct snd_rme9652 *rme9652, int in)
 {
 	int restart = 0;
 
@@ -994,7 +994,7 @@ static int rme9652_set_spdif_input(rme9652_t *rme9652, int in)
 	return 0;
 }
 
-static int snd_rme9652_info_spdif_in(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[3] = {"ADAT1", "Coaxial", "Internal"};
 
@@ -1007,9 +1007,9 @@ static int snd_rme9652_info_spdif_in(snd_kcontrol_t *kcontrol, snd_ctl_elem_info
 	return 0;
 }
 
-static int snd_rme9652_get_spdif_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme9652->lock);
 	ucontrol->value.enumerated.item[0] = rme9652_spdif_in(rme9652);
@@ -1017,9 +1017,9 @@ static int snd_rme9652_get_spdif_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
 	return 0;
 }
 
-static int snd_rme9652_put_spdif_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_put_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 	
@@ -1039,12 +1039,12 @@ static int snd_rme9652_put_spdif_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
   .info = snd_rme9652_info_spdif_out, \
   .get = snd_rme9652_get_spdif_out, .put = snd_rme9652_put_spdif_out }
 
-static int rme9652_spdif_out(rme9652_t *rme9652)
+static int rme9652_spdif_out(struct snd_rme9652 *rme9652)
 {
 	return (rme9652->control_register & RME9652_opt_out) ? 1 : 0;
 }
 
-static int rme9652_set_spdif_output(rme9652_t *rme9652, int out)
+static int rme9652_set_spdif_output(struct snd_rme9652 *rme9652, int out)
 {
 	int restart = 0;
 
@@ -1067,7 +1067,7 @@ static int rme9652_set_spdif_output(rme9652_t *rme9652, int out)
 	return 0;
 }
 
-static int snd_rme9652_info_spdif_out(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1076,9 +1076,9 @@ static int snd_rme9652_info_spdif_out(snd_kcontrol_t *kcontrol, snd_ctl_elem_inf
 	return 0;
 }
 
-static int snd_rme9652_get_spdif_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme9652->lock);
 	ucontrol->value.integer.value[0] = rme9652_spdif_out(rme9652);
@@ -1086,9 +1086,9 @@ static int snd_rme9652_get_spdif_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 	return 0;
 }
 
-static int snd_rme9652_put_spdif_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_put_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 	
@@ -1107,7 +1107,7 @@ static int snd_rme9652_put_spdif_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
   .info = snd_rme9652_info_sync_mode, \
   .get = snd_rme9652_get_sync_mode, .put = snd_rme9652_put_sync_mode }
 
-static int rme9652_sync_mode(rme9652_t *rme9652)
+static int rme9652_sync_mode(struct snd_rme9652 *rme9652)
 {
 	if (rme9652->control_register & RME9652_wsel) {
 		return 2;
@@ -1118,7 +1118,7 @@ static int rme9652_sync_mode(rme9652_t *rme9652)
 	}
 }
 
-static int rme9652_set_sync_mode(rme9652_t *rme9652, int mode)
+static int rme9652_set_sync_mode(struct snd_rme9652 *rme9652, int mode)
 {
 	int restart = 0;
 
@@ -1150,7 +1150,7 @@ static int rme9652_set_sync_mode(rme9652_t *rme9652, int mode)
 	return 0;
 }
 
-static int snd_rme9652_info_sync_mode(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[3] = {"AutoSync", "Master", "Word Clock"};
 
@@ -1163,9 +1163,9 @@ static int snd_rme9652_info_sync_mode(snd_kcontrol_t *kcontrol, snd_ctl_elem_inf
 	return 0;
 }
 
-static int snd_rme9652_get_sync_mode(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme9652->lock);
 	ucontrol->value.enumerated.item[0] = rme9652_sync_mode(rme9652);
@@ -1173,9 +1173,9 @@ static int snd_rme9652_get_sync_mode(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 	return 0;
 }
 
-static int snd_rme9652_put_sync_mode(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_put_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 	
@@ -1192,7 +1192,7 @@ static int snd_rme9652_put_sync_mode(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
   .info = snd_rme9652_info_sync_pref, \
   .get = snd_rme9652_get_sync_pref, .put = snd_rme9652_put_sync_pref }
 
-static int rme9652_sync_pref(rme9652_t *rme9652)
+static int rme9652_sync_pref(struct snd_rme9652 *rme9652)
 {
 	switch (rme9652->control_register & RME9652_SyncPref_Mask) {
 	case RME9652_SyncPref_ADAT1:
@@ -1208,7 +1208,7 @@ static int rme9652_sync_pref(rme9652_t *rme9652)
 	return 0;
 }
 
-static int rme9652_set_sync_pref(rme9652_t *rme9652, int pref)
+static int rme9652_set_sync_pref(struct snd_rme9652 *rme9652, int pref)
 {
 	int restart;
 
@@ -1241,10 +1241,10 @@ static int rme9652_set_sync_pref(rme9652_t *rme9652, int pref)
 	return 0;
 }
 
-static int snd_rme9652_info_sync_pref(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[4] = {"IEC958 In", "ADAT1 In", "ADAT2 In", "ADAT3 In"};
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
@@ -1255,9 +1255,9 @@ static int snd_rme9652_info_sync_pref(snd_kcontrol_t *kcontrol, snd_ctl_elem_inf
 	return 0;
 }
 
-static int snd_rme9652_get_sync_pref(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme9652->lock);
 	ucontrol->value.enumerated.item[0] = rme9652_sync_pref(rme9652);
@@ -1265,9 +1265,9 @@ static int snd_rme9652_get_sync_pref(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 	return 0;
 }
 
-static int snd_rme9652_put_sync_pref(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_put_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	int change, max;
 	unsigned int val;
 	
@@ -1282,9 +1282,9 @@ static int snd_rme9652_put_sync_pref(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 	return change;
 }
 
-static int snd_rme9652_info_thru(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = rme9652->ss_channels;
 	uinfo->value.integer.min = 0;
@@ -1292,9 +1292,9 @@ static int snd_rme9652_info_thru(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	return 0;
 }
 
-static int snd_rme9652_get_thru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	unsigned int k;
 	u32 thru_bits = rme9652->thru_bits;
 
@@ -1304,9 +1304,9 @@ static int snd_rme9652_get_thru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 
-static int snd_rme9652_put_thru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_put_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int chn;
 	u32 thru_bits = 0;
@@ -1338,7 +1338,7 @@ static int snd_rme9652_put_thru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
   .put = snd_rme9652_put_passthru, \
   .get = snd_rme9652_get_passthru }
 
-static int snd_rme9652_info_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_passthru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1347,9 +1347,9 @@ static int snd_rme9652_info_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_inf
 	return 0;
 }
 
-static int snd_rme9652_get_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_passthru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&rme9652->lock);
 	ucontrol->value.integer.value[0] = rme9652->passthru;
@@ -1357,9 +1357,9 @@ static int snd_rme9652_get_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
 	return 0;
 }
 
-static int snd_rme9652_put_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_put_passthru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 	int err = 0;
@@ -1384,7 +1384,7 @@ static int snd_rme9652_put_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
   .info = snd_rme9652_info_spdif_rate, \
   .get = snd_rme9652_get_spdif_rate }
 
-static int snd_rme9652_info_spdif_rate(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_spdif_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -1393,9 +1393,9 @@ static int snd_rme9652_info_spdif_rate(snd_kcontrol_t *kcontrol, snd_ctl_elem_in
 	return 0;
 }
 
-static int snd_rme9652_get_spdif_rate(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_spdif_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme9652->lock);
 	ucontrol->value.integer.value[0] = rme9652_spdif_sample_rate(rme9652);
@@ -1409,7 +1409,7 @@ static int snd_rme9652_get_spdif_rate(snd_kcontrol_t * kcontrol, snd_ctl_elem_va
   .info = snd_rme9652_info_adat_sync, \
   .get = snd_rme9652_get_adat_sync, .private_value = xidx }
 
-static int snd_rme9652_info_adat_sync(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_adat_sync(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[4] = {"No Lock", "Lock", "No Lock Sync", "Lock Sync"};
 
@@ -1422,9 +1422,9 @@ static int snd_rme9652_info_adat_sync(snd_kcontrol_t *kcontrol, snd_ctl_elem_inf
 	return 0;
 }
 
-static int snd_rme9652_get_adat_sync(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_adat_sync(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	unsigned int mask1, mask2, val;
 	
 	switch (kcontrol->private_value) {
@@ -1445,7 +1445,7 @@ static int snd_rme9652_get_adat_sync(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
   .info = snd_rme9652_info_tc_valid, \
   .get = snd_rme9652_get_tc_valid }
 
-static int snd_rme9652_info_tc_valid(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme9652_info_tc_valid(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1454,9 +1454,9 @@ static int snd_rme9652_info_tc_valid(snd_kcontrol_t *kcontrol, snd_ctl_elem_info
 	return 0;
 }
 
-static int snd_rme9652_get_tc_valid(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme9652_get_tc_valid(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	struct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);
 	
 	ucontrol->value.integer.value[0] = 
 		(rme9652_read(rme9652, RME9652_status_register) & RME9652_tc_valid) ? 1 : 0;
@@ -1471,7 +1471,7 @@ static int snd_rme9652_get_tc_value(void *private_data,
 				    snd_kswitch_t *kswitch,
 				    snd_switch_t *uswitch)
 {
-	rme9652_t *s = (rme9652_t *) private_data;
+	struct snd_rme9652 *s = (struct snd_rme9652 *) private_data;
 	u32 value;
 	int i;
 
@@ -1520,7 +1520,7 @@ static int snd_rme9652_get_tc_value(void *private_data,
 
 #endif				/* ALSA_HAS_STANDARD_WAY_OF_RETURNING_TIMECODE */
 
-static snd_kcontrol_new_t snd_rme9652_controls[] = {
+static struct snd_kcontrol_new snd_rme9652_controls[] = {
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -1575,17 +1575,17 @@ RME9652_TC_VALID("Timecode Valid", 0),
 RME9652_PASSTHRU("Passthru", 0)
 };
 
-static snd_kcontrol_new_t snd_rme9652_adat3_check =
+static struct snd_kcontrol_new snd_rme9652_adat3_check =
 RME9652_ADAT_SYNC("ADAT3 Sync Check", 0, 2);
 
-static snd_kcontrol_new_t snd_rme9652_adat1_input =
+static struct snd_kcontrol_new snd_rme9652_adat1_input =
 RME9652_ADAT1_IN("ADAT1 Input Source", 0);
 
-static int snd_rme9652_create_controls(snd_card_t *card, rme9652_t *rme9652)
+static int snd_rme9652_create_controls(struct snd_card *card, struct snd_rme9652 *rme9652)
 {
 	unsigned int idx;
 	int err;
-	snd_kcontrol_t *kctl;
+	struct snd_kcontrol *kctl;
 
 	for (idx = 0; idx < ARRAY_SIZE(snd_rme9652_controls); idx++) {
 		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme9652_controls[idx], rme9652))) < 0)
@@ -1610,9 +1610,9 @@ static int snd_rme9652_create_controls(snd_card_t *card, rme9652_t *rme9652)
  ------------------------------------------------------------*/
 
 static void
-snd_rme9652_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+snd_rme9652_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
-	rme9652_t *rme9652 = (rme9652_t *) entry->private_data;
+	struct snd_rme9652 *rme9652 = (struct snd_rme9652 *) entry->private_data;
 	u32 thru_bits = rme9652->thru_bits;
 	int show_auto_sync_source = 0;
 	int i;
@@ -1782,21 +1782,21 @@ snd_rme9652_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
 	snd_iprintf(buffer, "\n");
 }
 
-static void __devinit snd_rme9652_proc_init(rme9652_t *rme9652)
+static void __devinit snd_rme9652_proc_init(struct snd_rme9652 *rme9652)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(rme9652->card, "rme9652", &entry))
 		snd_info_set_text_ops(entry, rme9652, 1024, snd_rme9652_proc_read);
 }
 
-static void snd_rme9652_free_buffers(rme9652_t *rme9652)
+static void snd_rme9652_free_buffers(struct snd_rme9652 *rme9652)
 {
 	snd_hammerfall_free_buffer(&rme9652->capture_dma_buf, rme9652->pci);
 	snd_hammerfall_free_buffer(&rme9652->playback_dma_buf, rme9652->pci);
 }
 
-static int snd_rme9652_free(rme9652_t *rme9652)
+static int snd_rme9652_free(struct snd_rme9652 *rme9652)
 {
 	if (rme9652->irq >= 0)
 		rme9652_stop(rme9652);
@@ -1813,7 +1813,7 @@ static int snd_rme9652_free(rme9652_t *rme9652)
 	return 0;
 }
 
-static int __devinit snd_rme9652_initialize_memory(rme9652_t *rme9652)
+static int __devinit snd_rme9652_initialize_memory(struct snd_rme9652 *rme9652)
 {
 	unsigned long pb_bus, cb_bus;
 
@@ -1841,7 +1841,7 @@ static int __devinit snd_rme9652_initialize_memory(rme9652_t *rme9652)
 	return 0;
 }
 
-static void snd_rme9652_set_defaults(rme9652_t *rme9652)
+static void snd_rme9652_set_defaults(struct snd_rme9652 *rme9652)
 {
 	unsigned int k;
 
@@ -1884,7 +1884,7 @@ static void snd_rme9652_set_defaults(rme9652_t *rme9652)
 
 static irqreturn_t snd_rme9652_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	rme9652_t *rme9652 = (rme9652_t *) dev_id;
+	struct snd_rme9652 *rme9652 = (struct snd_rme9652 *) dev_id;
 
 	if (!(rme9652_read(rme9652, RME9652_status_register) & RME9652_IRQ)) {
 		return IRQ_NONE;
@@ -1902,13 +1902,13 @@ static irqreturn_t snd_rme9652_interrupt(int irq, void *dev_id, struct pt_regs *
 	return IRQ_HANDLED;
 }
 
-static snd_pcm_uframes_t snd_rme9652_hw_pointer(snd_pcm_substream_t *substream)
+static snd_pcm_uframes_t snd_rme9652_hw_pointer(struct snd_pcm_substream *substream)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	return rme9652_hw_pointer(rme9652);
 }
 
-static char *rme9652_channel_buffer_location(rme9652_t *rme9652,
+static char *rme9652_channel_buffer_location(struct snd_rme9652 *rme9652,
 					     int stream,
 					     int channel)
 
@@ -1930,10 +1930,10 @@ static char *rme9652_channel_buffer_location(rme9652_t *rme9652,
 	}
 }
 
-static int snd_rme9652_playback_copy(snd_pcm_substream_t *substream, int channel,
+static int snd_rme9652_playback_copy(struct snd_pcm_substream *substream, int channel,
 				     snd_pcm_uframes_t pos, void __user *src, snd_pcm_uframes_t count)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
 	snd_assert(pos + count <= RME9652_CHANNEL_BUFFER_BYTES / 4, return -EINVAL);
@@ -1947,10 +1947,10 @@ static int snd_rme9652_playback_copy(snd_pcm_substream_t *substream, int channel
 	return count;
 }
 
-static int snd_rme9652_capture_copy(snd_pcm_substream_t *substream, int channel,
+static int snd_rme9652_capture_copy(struct snd_pcm_substream *substream, int channel,
 				    snd_pcm_uframes_t pos, void __user *dst, snd_pcm_uframes_t count)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
 	snd_assert(pos + count <= RME9652_CHANNEL_BUFFER_BYTES / 4, return -EINVAL);
@@ -1964,10 +1964,10 @@ static int snd_rme9652_capture_copy(snd_pcm_substream_t *substream, int channel,
 	return count;
 }
 
-static int snd_rme9652_hw_silence(snd_pcm_substream_t *substream, int channel,
+static int snd_rme9652_hw_silence(struct snd_pcm_substream *substream, int channel,
 				  snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
 	channel_buf = rme9652_channel_buffer_location (rme9652,
@@ -1978,11 +1978,11 @@ static int snd_rme9652_hw_silence(snd_pcm_substream_t *substream, int channel,
 	return count;
 }
 
-static int snd_rme9652_reset(snd_pcm_substream_t *substream)
+static int snd_rme9652_reset(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
-	snd_pcm_substream_t *other;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_substream *other;
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		other = rme9652->capture_substream;
 	else
@@ -1993,8 +1993,8 @@ static int snd_rme9652_reset(snd_pcm_substream_t *substream)
 		runtime->status->hw_ptr = 0;
 	if (other) {
 		struct list_head *pos;
-		snd_pcm_substream_t *s;
-		snd_pcm_runtime_t *oruntime = other->runtime;
+		struct snd_pcm_substream *s;
+		struct snd_pcm_runtime *oruntime = other->runtime;
 		snd_pcm_group_for_each(pos, substream) {
 			s = snd_pcm_group_substream_entry(pos);
 			if (s == other) {
@@ -2006,10 +2006,10 @@ static int snd_rme9652_reset(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_rme9652_hw_params(snd_pcm_substream_t *substream,
-				 snd_pcm_hw_params_t *params)
+static int snd_rme9652_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	int err;
 	pid_t this_pid;
 	pid_t other_pid;
@@ -2071,10 +2071,10 @@ static int snd_rme9652_hw_params(snd_pcm_substream_t *substream,
 	return 0;
 }
 
-static int snd_rme9652_channel_info(snd_pcm_substream_t *substream,
-				    snd_pcm_channel_info_t *info)
+static int snd_rme9652_channel_info(struct snd_pcm_substream *substream,
+				    struct snd_pcm_channel_info *info)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	int chn;
 
 	snd_assert(info->channel < RME9652_NCHANNELS, return -EINVAL);
@@ -2089,7 +2089,7 @@ static int snd_rme9652_channel_info(snd_pcm_substream_t *substream,
 	return 0;
 }
 
-static int snd_rme9652_ioctl(snd_pcm_substream_t *substream,
+static int snd_rme9652_ioctl(struct snd_pcm_substream *substream,
 			     unsigned int cmd, void *arg)
 {
 	switch (cmd) {
@@ -2099,7 +2099,7 @@ static int snd_rme9652_ioctl(snd_pcm_substream_t *substream,
 	}
 	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
 	{
-		snd_pcm_channel_info_t *info = arg;
+		struct snd_pcm_channel_info *info = arg;
 		return snd_rme9652_channel_info(substream, info);
 	}
 	default:
@@ -2109,16 +2109,16 @@ static int snd_rme9652_ioctl(snd_pcm_substream_t *substream,
 	return snd_pcm_lib_ioctl(substream, cmd, arg);
 }
 
-static void rme9652_silence_playback(rme9652_t *rme9652)
+static void rme9652_silence_playback(struct snd_rme9652 *rme9652)
 {
 	memset(rme9652->playback_buffer, 0, RME9652_DMA_AREA_BYTES);
 }
 
-static int snd_rme9652_trigger(snd_pcm_substream_t *substream,
+static int snd_rme9652_trigger(struct snd_pcm_substream *substream,
 			       int cmd)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
-	snd_pcm_substream_t *other;
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_substream *other;
 	int running;
 	spin_lock(&rme9652->lock);
 	running = rme9652->running;
@@ -2141,7 +2141,7 @@ static int snd_rme9652_trigger(snd_pcm_substream_t *substream,
 
 	if (other) {
 		struct list_head *pos;
-		snd_pcm_substream_t *s;
+		struct snd_pcm_substream *s;
 		snd_pcm_group_for_each(pos, substream) {
 			s = snd_pcm_group_substream_entry(pos);
 			if (s == other) {
@@ -2178,9 +2178,9 @@ static int snd_rme9652_trigger(snd_pcm_substream_t *substream,
 	return 0;
 }
 
-static int snd_rme9652_prepare(snd_pcm_substream_t *substream)
+static int snd_rme9652_prepare(struct snd_pcm_substream *substream)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 	unsigned long flags;
 	int result = 0;
 
@@ -2191,7 +2191,7 @@ static int snd_rme9652_prepare(snd_pcm_substream_t *substream)
 	return result;
 }
 
-static snd_pcm_hardware_t snd_rme9652_playback_subinfo =
+static struct snd_pcm_hardware snd_rme9652_playback_subinfo =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_MMAP_VALID |
@@ -2215,7 +2215,7 @@ static snd_pcm_hardware_t snd_rme9652_playback_subinfo =
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_rme9652_capture_subinfo =
+static struct snd_pcm_hardware snd_rme9652_capture_subinfo =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_MMAP_VALID |
@@ -2240,36 +2240,36 @@ static snd_pcm_hardware_t snd_rme9652_capture_subinfo =
 
 static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
 
-static snd_pcm_hw_constraint_list_t hw_constraints_period_sizes = {
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 	.count = ARRAY_SIZE(period_sizes),
 	.list = period_sizes,
 	.mask = 0
 };
 
-static int snd_rme9652_hw_rule_channels(snd_pcm_hw_params_t *params,
-					snd_pcm_hw_rule_t *rule)
+static int snd_rme9652_hw_rule_channels(struct snd_pcm_hw_params *params,
+					struct snd_pcm_hw_rule *rule)
 {
-	rme9652_t *rme9652 = rule->private;
-	snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_rme9652 *rme9652 = rule->private;
+	struct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
 	unsigned int list[2] = { rme9652->ds_channels, rme9652->ss_channels };
 	return snd_interval_list(c, 2, list, 0);
 }
 
-static int snd_rme9652_hw_rule_channels_rate(snd_pcm_hw_params_t *params,
-					     snd_pcm_hw_rule_t *rule)
+static int snd_rme9652_hw_rule_channels_rate(struct snd_pcm_hw_params *params,
+					     struct snd_pcm_hw_rule *rule)
 {
-	rme9652_t *rme9652 = rule->private;
-	snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
-	snd_interval_t *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_rme9652 *rme9652 = rule->private;
+	struct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 	if (r->min > 48000) {
-		snd_interval_t t = {
+		struct snd_interval t = {
 			.min = rme9652->ds_channels,
 			.max = rme9652->ds_channels,
 			.integer = 1,
 		};
 		return snd_interval_refine(c, &t);
 	} else if (r->max < 88200) {
-		snd_interval_t t = {
+		struct snd_interval t = {
 			.min = rme9652->ss_channels,
 			.max = rme9652->ss_channels,
 			.integer = 1,
@@ -2279,21 +2279,21 @@ static int snd_rme9652_hw_rule_channels_rate(snd_pcm_hw_params_t *params,
 	return 0;
 }
 
-static int snd_rme9652_hw_rule_rate_channels(snd_pcm_hw_params_t *params,
-					     snd_pcm_hw_rule_t *rule)
+static int snd_rme9652_hw_rule_rate_channels(struct snd_pcm_hw_params *params,
+					     struct snd_pcm_hw_rule *rule)
 {
-	rme9652_t *rme9652 = rule->private;
-	snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
-	snd_interval_t *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_rme9652 *rme9652 = rule->private;
+	struct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 	if (c->min >= rme9652->ss_channels) {
-		snd_interval_t t = {
+		struct snd_interval t = {
 			.min = 44100,
 			.max = 48000,
 			.integer = 1,
 		};
 		return snd_interval_refine(r, &t);
 	} else if (c->max <= rme9652->ds_channels) {
-		snd_interval_t t = {
+		struct snd_interval t = {
 			.min = 88200,
 			.max = 96000,
 			.integer = 1,
@@ -2303,10 +2303,10 @@ static int snd_rme9652_hw_rule_rate_channels(snd_pcm_hw_params_t *params,
 	return 0;
 }
 
-static int snd_rme9652_playback_open(snd_pcm_substream_t *substream)
+static int snd_rme9652_playback_open(struct snd_pcm_substream *substream)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	spin_lock_irq(&rme9652->lock);
 
@@ -2345,9 +2345,9 @@ static int snd_rme9652_playback_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_rme9652_playback_release(snd_pcm_substream_t *substream)
+static int snd_rme9652_playback_release(struct snd_pcm_substream *substream)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&rme9652->lock);
 
@@ -2363,10 +2363,10 @@ static int snd_rme9652_playback_release(snd_pcm_substream_t *substream)
 }
 
 
-static int snd_rme9652_capture_open(snd_pcm_substream_t *substream)
+static int snd_rme9652_capture_open(struct snd_pcm_substream *substream)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	spin_lock_irq(&rme9652->lock);
 
@@ -2400,9 +2400,9 @@ static int snd_rme9652_capture_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_rme9652_capture_release(snd_pcm_substream_t *substream)
+static int snd_rme9652_capture_release(struct snd_pcm_substream *substream)
 {
-	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	struct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&rme9652->lock);
 
@@ -2413,7 +2413,7 @@ static int snd_rme9652_capture_release(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static snd_pcm_ops_t snd_rme9652_playback_ops = {
+static struct snd_pcm_ops snd_rme9652_playback_ops = {
 	.open =		snd_rme9652_playback_open,
 	.close =	snd_rme9652_playback_release,
 	.ioctl =	snd_rme9652_ioctl,
@@ -2425,7 +2425,7 @@ static snd_pcm_ops_t snd_rme9652_playback_ops = {
 	.silence =	snd_rme9652_hw_silence,
 };
 
-static snd_pcm_ops_t snd_rme9652_capture_ops = {
+static struct snd_pcm_ops snd_rme9652_capture_ops = {
 	.open =		snd_rme9652_capture_open,
 	.close =	snd_rme9652_capture_release,
 	.ioctl =	snd_rme9652_ioctl,
@@ -2436,10 +2436,10 @@ static snd_pcm_ops_t snd_rme9652_capture_ops = {
 	.copy =		snd_rme9652_capture_copy,
 };
 
-static int __devinit snd_rme9652_create_pcm(snd_card_t *card,
-					 rme9652_t *rme9652)
+static int __devinit snd_rme9652_create_pcm(struct snd_card *card,
+					 struct snd_rme9652 *rme9652)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if ((err = snd_pcm_new(card,
@@ -2460,8 +2460,8 @@ static int __devinit snd_rme9652_create_pcm(snd_card_t *card,
 	return 0;
 }
 
-static int __devinit snd_rme9652_create(snd_card_t *card,
-				     rme9652_t *rme9652,
+static int __devinit snd_rme9652_create(struct snd_card *card,
+				     struct snd_rme9652 *rme9652,
 				     int precise_ptr)
 {
 	struct pci_dev *pci = rme9652->pci;
@@ -2591,9 +2591,9 @@ static int __devinit snd_rme9652_create(snd_card_t *card,
 	return 0;
 }
 
-static void snd_rme9652_card_free(snd_card_t *card)
+static void snd_rme9652_card_free(struct snd_card *card)
 {
-	rme9652_t *rme9652 = (rme9652_t *) card->private_data;
+	struct snd_rme9652 *rme9652 = (struct snd_rme9652 *) card->private_data;
 
 	if (rme9652)
 		snd_rme9652_free(rme9652);
@@ -2603,8 +2603,8 @@ static int __devinit snd_rme9652_probe(struct pci_dev *pci,
 				       const struct pci_device_id *pci_id)
 {
 	static int dev;
-	rme9652_t *rme9652;
-	snd_card_t *card;
+	struct snd_rme9652 *rme9652;
+	struct snd_card *card;
 	int err;
 
 	if (dev >= SNDRV_CARDS)
@@ -2615,12 +2615,12 @@ static int __devinit snd_rme9652_probe(struct pci_dev *pci,
 	}
 
 	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-			    sizeof(rme9652_t));
+			    sizeof(struct snd_rme9652));
 
 	if (!card)
 		return -ENOMEM;
 
-	rme9652 = (rme9652_t *) card->private_data;
+	rme9652 = (struct snd_rme9652 *) card->private_data;
 	card->private_free = snd_rme9652_card_free;
 	rme9652->dev = dev;
 	rme9652->pci = pci;

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 59fcef9b6b81..f9d0c126c213 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2654,7 +2654,6 @@ static void __devexit snd_rme9652_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name	  = "RME Digi9652 (Hammerfall)",
-	.owner	  = THIS_MODULE,
 	.id_table = snd_rme9652_ids,
 	.probe	  = snd_rme9652_probe,
 	.remove	  = __devexit_p(snd_rme9652_remove),

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index b600f45e1834..59fcef9b6b81 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -779,7 +779,7 @@ static inline int rme9652_spdif_sample_rate(rme9652_t *s)
 		break;
 
 	default:
-		snd_printk("%s: unknown S/PDIF input rate (bits = 0x%x)\n",
+		snd_printk(KERN_ERR "%s: unknown S/PDIF input rate (bits = 0x%x)\n",
 			   s->card_name, rate_bits);
 		return 0;
 		break;
@@ -2496,12 +2496,12 @@ static int __devinit snd_rme9652_create(snd_card_t *card,
 	rme9652->port = pci_resource_start(pci, 0);
 	rme9652->iobase = ioremap_nocache(rme9652->port, RME9652_IO_EXTENT);
 	if (rme9652->iobase == NULL) {
-		snd_printk("unable to remap region 0x%lx-0x%lx\n", rme9652->port, rme9652->port + RME9652_IO_EXTENT - 1);
+		snd_printk(KERN_ERR "unable to remap region 0x%lx-0x%lx\n", rme9652->port, rme9652->port + RME9652_IO_EXTENT - 1);
 		return -EBUSY;
 	}
 	
 	if (request_irq(pci->irq, snd_rme9652_interrupt, SA_INTERRUPT|SA_SHIRQ, "rme9652", (void *)rme9652)) {
-		snd_printk("unable to request IRQ %d\n", pci->irq);
+		snd_printk(KERN_ERR "unable to request IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}
 	rme9652->irq = pci->irq;

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index da317e8c0857..b600f45e1834 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2654,6 +2654,7 @@ static void __devexit snd_rme9652_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name	  = "RME Digi9652 (Hammerfall)",
+	.owner	  = THIS_MODULE,
 	.id_table = snd_rme9652_ids,
 	.probe	  = snd_rme9652_probe,
 	.remove	  = __devexit_p(snd_rme9652_remove),

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 8ee4d6fd6ea7..da317e8c0857 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -120,13 +120,6 @@ MODULE_SUPPORTED_DEVICE("{{RME,Hammerfall},"
 
 #define RME9652_REV15_buf_pos(x) ((((x)&0xE0000000)>>26)|((x)&RME9652_buf_pos))
 
-#ifndef PCI_VENDOR_ID_XILINX
-#define PCI_VENDOR_ID_XILINX		0x10ee
-#endif
-#ifndef PCI_DEVICE_ID_XILINX_HAMMERFALL
-#define PCI_DEVICE_ID_XILINX_HAMMERFALL	0x3fc4
-#endif
-
 /* amount of io space we remap for register access. i'm not sure we
    even need this much, but 1K is nice round number :)
 */

commit 5549d54992391d81a8cbfbaac45a958876fbc9cb
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Aug 3 13:50:30 2005 +0200

    [ALSA] use PCM interface for IEC958 controls
    
    Digigram VX core,ENS1370/1+ driver,CA0106 driver,EMU10K1/EMU10K2 driver
    RME HDSP driver,RME9652 driver
    For consistency, use the PCM interface instead of MIXER for IEC958
    default/mask/stream mixer controls.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 6e3a91dba3eb..8ee4d6fd6ea7 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1529,7 +1529,7 @@ static int snd_rme9652_get_tc_value(void *private_data,
 
 static snd_kcontrol_new_t snd_rme9652_controls[] = {
 {
-	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
 	.info =		snd_rme9652_control_spdif_info,
 	.get =		snd_rme9652_control_spdif_get,
@@ -1537,7 +1537,7 @@ static snd_kcontrol_new_t snd_rme9652_controls[] = {
 },
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
-	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
 	.info =		snd_rme9652_control_spdif_stream_info,
 	.get =		snd_rme9652_control_spdif_stream_get,
@@ -1545,7 +1545,7 @@ static snd_kcontrol_new_t snd_rme9652_controls[] = {
 },
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
-	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,CON_MASK),
 	.info =		snd_rme9652_control_spdif_mask_info,
 	.get =		snd_rme9652_control_spdif_mask_get,
@@ -1555,7 +1555,7 @@ static snd_kcontrol_new_t snd_rme9652_controls[] = {
 },
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
-	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PRO_MASK),
 	.info =		snd_rme9652_control_spdif_mask_info,
 	.get =		snd_rme9652_control_spdif_mask_get,

commit 67ed4161f60d76b3b27efc085b36357a6a90768c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Jul 29 15:32:58 2005 +0200

    [ALSA] sound - fix .iface field of mixer control elements
    
    Documentation,CS46xx driver,EMU10K1/EMU10K2 driver,AD1848 driver
    SB16/AWE driver,CMIPCI driver,ENS1370/1+ driver,RME32 driver
    RME96 driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    RME HDSP driver,RME9652 driver
    This patch changes .iface to SNDRV_CTL_ELEM_IFACE_MIXER whre _PCM or
    _HWDEP was used in controls that are not associated with a specific PCM
    (sub)stream or hwdep device, and changes some controls that got
    inconsitent .iface values due to copy+paste errors.  Furthermore, it
    makes sure that all control that do use _PCM or _HWDEP use the correct
    number in the .device field.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 1bc9d0df8516..6e3a91dba3eb 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -893,7 +893,7 @@ static int snd_rme9652_control_spdif_mask_get(snd_kcontrol_t * kcontrol, snd_ctl
 }
 
 #define RME9652_ADAT1_IN(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_rme9652_info_adat1_in, \
   .get = snd_rme9652_get_adat1_in, \
   .put = snd_rme9652_put_adat1_in }
@@ -971,7 +971,7 @@ static int snd_rme9652_put_adat1_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
 }
 
 #define RME9652_SPDIF_IN(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_rme9652_info_spdif_in, \
   .get = snd_rme9652_get_spdif_in, .put = snd_rme9652_put_spdif_in }
 
@@ -1042,7 +1042,7 @@ static int snd_rme9652_put_spdif_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
 }
 
 #define RME9652_SPDIF_OUT(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_rme9652_info_spdif_out, \
   .get = snd_rme9652_get_spdif_out, .put = snd_rme9652_put_spdif_out }
 
@@ -1110,7 +1110,7 @@ static int snd_rme9652_put_spdif_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 }
 
 #define RME9652_SYNC_MODE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_rme9652_info_sync_mode, \
   .get = snd_rme9652_get_sync_mode, .put = snd_rme9652_put_sync_mode }
 
@@ -1195,7 +1195,7 @@ static int snd_rme9652_put_sync_mode(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 }
 
 #define RME9652_SYNC_PREF(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_rme9652_info_sync_pref, \
   .get = snd_rme9652_get_sync_pref, .put = snd_rme9652_put_sync_pref }
 
@@ -1340,7 +1340,7 @@ static int snd_rme9652_put_thru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 }
 
 #define RME9652_PASSTHRU(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_rme9652_info_passthru, \
   .put = snd_rme9652_put_passthru, \
   .get = snd_rme9652_get_passthru }
@@ -1386,7 +1386,7 @@ static int snd_rme9652_put_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
 /* Read-only switches */
 
 #define RME9652_SPDIF_RATE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
   .info = snd_rme9652_info_spdif_rate, \
   .get = snd_rme9652_get_spdif_rate }
@@ -1411,7 +1411,7 @@ static int snd_rme9652_get_spdif_rate(snd_kcontrol_t * kcontrol, snd_ctl_elem_va
 }
 
 #define RME9652_ADAT_SYNC(xname, xindex, xidx) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
   .info = snd_rme9652_info_adat_sync, \
   .get = snd_rme9652_get_adat_sync, .private_value = xidx }
@@ -1447,7 +1447,7 @@ static int snd_rme9652_get_adat_sync(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 }
 
 #define RME9652_TC_VALID(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
   .info = snd_rme9652_info_tc_valid, \
   .get = snd_rme9652_get_tc_valid }
@@ -1529,7 +1529,7 @@ static int snd_rme9652_get_tc_value(void *private_data,
 
 static snd_kcontrol_new_t snd_rme9652_controls[] = {
 {
-	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
 	.info =		snd_rme9652_control_spdif_info,
 	.get =		snd_rme9652_control_spdif_get,
@@ -1537,7 +1537,7 @@ static snd_kcontrol_new_t snd_rme9652_controls[] = {
 },
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
-	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
 	.info =		snd_rme9652_control_spdif_stream_info,
 	.get =		snd_rme9652_control_spdif_stream_get,
@@ -1568,7 +1568,7 @@ RME9652_SPDIF_OUT("IEC958 Output also on ADAT1", 0),
 RME9652_SYNC_MODE("Sync Mode", 0),
 RME9652_SYNC_PREF("Preferred Sync Source", 0),
 {
-	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Channels Thru",
 	.index = 0,
 	.info = snd_rme9652_info_thru,

commit 44456d37b59d8e541936ed26d8b6e08d27e88ac1
Author: Olaf Hering <olh@suse.de>
Date:   Wed Jul 27 11:45:17 2005 -0700

    [PATCH] turn many #if $undefined_string into #ifdef $undefined_string
    
    turn many #if $undefined_string into #ifdef $undefined_string to fix some
    warnings after -Wno-def was added to global CFLAGS
    
    Signed-off-by: Olaf Hering <olh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index f3037402d58f..1bc9d0df8516 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -1470,7 +1470,7 @@ static int snd_rme9652_get_tc_valid(snd_kcontrol_t * kcontrol, snd_ctl_elem_valu
 	return 0;
 }
 
-#if ALSA_HAS_STANDARD_WAY_OF_RETURNING_TIMECODE
+#ifdef ALSA_HAS_STANDARD_WAY_OF_RETURNING_TIMECODE
 
 /* FIXME: this routine needs a port to the new control API --jk */
 

commit b6a969155b04416185f368bd4e2f1d49b17c1ee1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 30 18:27:03 2005 +0200

    [ALSA] Add write support to snd-page-alloc proc file
    
    Documentation,Memalloc module,RME HDSP driver,RME9652 driver
    Add the write support to snd-page-alloc proc file for buffer pre-allocation.
    Removed the pre-allocation codes via module options.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 5861f234af21..f3037402d58f 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -303,18 +303,22 @@ static int snd_hammerfall_get_buffer(struct pci_dev *pci, struct snd_dma_buffer
 {
 	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
 	dmab->dev.dev = snd_dma_pci_data(pci);
-	if (! snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {
-		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
-					size, dmab) < 0)
-			return -ENOMEM;
+	if (snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {
+		if (dmab->bytes >= size)
+			return 0;
 	}
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+				size, dmab) < 0)
+		return -ENOMEM;
 	return 0;
 }
 
 static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_dev *pci)
 {
-	if (dmab->area)
+	if (dmab->area) {
+		dmab->dev.dev = NULL; /* make it anonymous */
 		snd_dma_reserve_buf(dmab, snd_dma_pci_buf_id(pci));
+	}
 }
 
 

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 69cd81eaa111..5861f234af21 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2664,7 +2664,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_hammerfall_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_hammerfall_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
new file mode 100644
index 000000000000..69cd81eaa111
--- /dev/null
+++ b/sound/pci/rme9652/rme9652.c
@@ -0,0 +1,2676 @@
+/*
+ *   ALSA driver for RME Digi9652 audio interfaces 
+ *
+ *	Copyright (c) 1999 IEM - Winfried Ritsch
+ *      Copyright (c) 1999-2001  Paul Davis
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/asoundef.h>
+#include <sound/initval.h>
+
+#include <asm/current.h>
+#include <asm/io.h>
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int precise_ptr[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 }; /* Enable precise pointer */
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for RME Digi9652 (Hammerfall) soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for RME Digi9652 (Hammerfall) soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable/disable specific RME96{52,36} soundcards.");
+module_param_array(precise_ptr, bool, NULL, 0444);
+MODULE_PARM_DESC(precise_ptr, "Enable precise pointer (doesn't work reliably).");
+MODULE_AUTHOR("Paul Davis <pbd@op.net>, Winfried Ritsch");
+MODULE_DESCRIPTION("RME Digi9652/Digi9636");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{RME,Hammerfall},"
+		"{RME,Hammerfall-Light}}");
+
+/* The Hammerfall has two sets of 24 ADAT + 2 S/PDIF channels, one for
+   capture, one for playback. Both the ADAT and S/PDIF channels appear
+   to the host CPU in the same block of memory. There is no functional
+   difference between them in terms of access.
+   
+   The Hammerfall Light is identical to the Hammerfall, except that it
+   has 2 sets 18 channels (16 ADAT + 2 S/PDIF) for capture and playback.
+*/
+
+#define RME9652_NCHANNELS       26
+#define RME9636_NCHANNELS       18
+
+/* Preferred sync source choices - used by "sync_pref" control switch */
+
+#define RME9652_SYNC_FROM_SPDIF 0
+#define RME9652_SYNC_FROM_ADAT1 1
+#define RME9652_SYNC_FROM_ADAT2 2
+#define RME9652_SYNC_FROM_ADAT3 3
+
+/* Possible sources of S/PDIF input */
+
+#define RME9652_SPDIFIN_OPTICAL 0	/* optical (ADAT1) */
+#define RME9652_SPDIFIN_COAXIAL 1	/* coaxial (RCA) */
+#define RME9652_SPDIFIN_INTERN  2	/* internal (CDROM) */
+
+/* ------------- Status-Register bits --------------------- */
+
+#define RME9652_IRQ	   (1<<0)	/* IRQ is High if not reset by irq_clear */
+#define RME9652_lock_2	   (1<<1)	/* ADAT 3-PLL: 1=locked, 0=unlocked */
+#define RME9652_lock_1	   (1<<2)	/* ADAT 2-PLL: 1=locked, 0=unlocked */
+#define RME9652_lock_0	   (1<<3)	/* ADAT 1-PLL: 1=locked, 0=unlocked */
+#define RME9652_fs48	   (1<<4)	/* sample rate is 0=44.1/88.2,1=48/96 Khz */
+#define RME9652_wsel_rd	   (1<<5)	/* if Word-Clock is used and valid then 1 */
+                                        /* bits 6-15 encode h/w buffer pointer position */
+#define RME9652_sync_2	   (1<<16)	/* if ADAT-IN 3 in sync to system clock */
+#define RME9652_sync_1	   (1<<17)	/* if ADAT-IN 2 in sync to system clock */
+#define RME9652_sync_0	   (1<<18)	/* if ADAT-IN 1 in sync to system clock */
+#define RME9652_DS_rd	   (1<<19)	/* 1=Double Speed Mode, 0=Normal Speed */
+#define RME9652_tc_busy	   (1<<20)	/* 1=time-code copy in progress (960ms) */
+#define RME9652_tc_out	   (1<<21)	/* time-code out bit */
+#define RME9652_F_0	   (1<<22)	/* 000=64kHz, 100=88.2kHz, 011=96kHz  */
+#define RME9652_F_1	   (1<<23)	/* 111=32kHz, 110=44.1kHz, 101=48kHz, */
+#define RME9652_F_2	   (1<<24)	/* external Crystal Chip if ERF=1 */
+#define RME9652_ERF	   (1<<25)	/* Error-Flag of SDPIF Receiver (1=No Lock) */
+#define RME9652_buffer_id  (1<<26)	/* toggles by each interrupt on rec/play */
+#define RME9652_tc_valid   (1<<27)	/* 1 = a signal is detected on time-code input */
+#define RME9652_SPDIF_READ (1<<28)      /* byte available from Rev 1.5+ S/PDIF interface */
+
+#define RME9652_sync	  (RME9652_sync_0|RME9652_sync_1|RME9652_sync_2)
+#define RME9652_lock	  (RME9652_lock_0|RME9652_lock_1|RME9652_lock_2)
+#define RME9652_F	  (RME9652_F_0|RME9652_F_1|RME9652_F_2)
+#define rme9652_decode_spdif_rate(x) ((x)>>22)
+
+/* Bit 6..15 : h/w buffer pointer */
+
+#define RME9652_buf_pos	  0x000FFC0
+
+/* Bits 31,30,29 are bits 5,4,3 of h/w pointer position on later
+   Rev G EEPROMS and Rev 1.5 cards or later.
+*/ 
+
+#define RME9652_REV15_buf_pos(x) ((((x)&0xE0000000)>>26)|((x)&RME9652_buf_pos))
+
+#ifndef PCI_VENDOR_ID_XILINX
+#define PCI_VENDOR_ID_XILINX		0x10ee
+#endif
+#ifndef PCI_DEVICE_ID_XILINX_HAMMERFALL
+#define PCI_DEVICE_ID_XILINX_HAMMERFALL	0x3fc4
+#endif
+
+/* amount of io space we remap for register access. i'm not sure we
+   even need this much, but 1K is nice round number :)
+*/
+
+#define RME9652_IO_EXTENT     1024
+
+#define RME9652_init_buffer       0
+#define RME9652_play_buffer       32	/* holds ptr to 26x64kBit host RAM */
+#define RME9652_rec_buffer        36	/* holds ptr to 26x64kBit host RAM */
+#define RME9652_control_register  64
+#define RME9652_irq_clear         96
+#define RME9652_time_code         100	/* useful if used with alesis adat */
+#define RME9652_thru_base         128	/* 132...228 Thru for 26 channels */
+
+/* Read-only registers */
+
+/* Writing to any of the register locations writes to the status
+   register. We'll use the first location as our point of access.
+*/
+
+#define RME9652_status_register    0
+
+/* --------- Control-Register Bits ---------------- */
+
+
+#define RME9652_start_bit	   (1<<0)	/* start record/play */
+                                                /* bits 1-3 encode buffersize/latency */
+#define RME9652_Master		   (1<<4)	/* Clock Mode Master=1,Slave/Auto=0 */
+#define RME9652_IE		   (1<<5)	/* Interupt Enable */
+#define RME9652_freq		   (1<<6)       /* samplerate 0=44.1/88.2, 1=48/96 kHz */
+#define RME9652_freq1		   (1<<7)       /* if 0, 32kHz, else always 1 */
+#define RME9652_DS                 (1<<8)	/* Doule Speed 0=44.1/48, 1=88.2/96 Khz */
+#define RME9652_PRO		   (1<<9)	/* S/PDIF out: 0=consumer, 1=professional */
+#define RME9652_EMP		   (1<<10)	/*  Emphasis 0=None, 1=ON */
+#define RME9652_Dolby		   (1<<11)	/*  Non-audio bit 1=set, 0=unset */
+#define RME9652_opt_out	           (1<<12)	/* Use 1st optical OUT as SPDIF: 1=yes,0=no */
+#define RME9652_wsel		   (1<<13)	/* use Wordclock as sync (overwrites master) */
+#define RME9652_inp_0		   (1<<14)	/* SPDIF-IN: 00=optical (ADAT1),     */
+#define RME9652_inp_1		   (1<<15)	/* 01=koaxial (Cinch), 10=Internal CDROM */
+#define RME9652_SyncPref_ADAT2	   (1<<16)
+#define RME9652_SyncPref_ADAT3	   (1<<17)
+#define RME9652_SPDIF_RESET        (1<<18)      /* Rev 1.5+: h/w S/PDIF receiver */
+#define RME9652_SPDIF_SELECT       (1<<19)
+#define RME9652_SPDIF_CLOCK        (1<<20)
+#define RME9652_SPDIF_WRITE        (1<<21)
+#define RME9652_ADAT1_INTERNAL     (1<<22)      /* Rev 1.5+: if set, internal CD connector carries ADAT */
+
+/* buffersize = 512Bytes * 2^n, where n is made from Bit2 ... Bit0 */
+
+#define RME9652_latency            0x0e
+#define rme9652_encode_latency(x)  (((x)&0x7)<<1)
+#define rme9652_decode_latency(x)  (((x)>>1)&0x7)
+#define rme9652_running_double_speed(s) ((s)->control_register & RME9652_DS)
+#define RME9652_inp                (RME9652_inp_0|RME9652_inp_1)
+#define rme9652_encode_spdif_in(x) (((x)&0x3)<<14)
+#define rme9652_decode_spdif_in(x) (((x)>>14)&0x3)
+
+#define RME9652_SyncPref_Mask      (RME9652_SyncPref_ADAT2|RME9652_SyncPref_ADAT3)
+#define RME9652_SyncPref_ADAT1	   0
+#define RME9652_SyncPref_SPDIF	   (RME9652_SyncPref_ADAT2|RME9652_SyncPref_ADAT3)
+
+/* the size of a substream (1 mono data stream) */
+
+#define RME9652_CHANNEL_BUFFER_SAMPLES  (16*1024)
+#define RME9652_CHANNEL_BUFFER_BYTES    (4*RME9652_CHANNEL_BUFFER_SAMPLES)
+
+/* the size of the area we need to allocate for DMA transfers. the
+   size is the same regardless of the number of channels - the 
+   9636 still uses the same memory area.
+
+   Note that we allocate 1 more channel than is apparently needed
+   because the h/w seems to write 1 byte beyond the end of the last
+   page. Sigh.
+*/
+
+#define RME9652_DMA_AREA_BYTES ((RME9652_NCHANNELS+1) * RME9652_CHANNEL_BUFFER_BYTES)
+#define RME9652_DMA_AREA_KILOBYTES (RME9652_DMA_AREA_BYTES/1024)
+
+typedef struct snd_rme9652 {
+	int dev;
+
+	spinlock_t lock;
+	int irq;
+	unsigned long port;
+	void __iomem *iobase;
+	
+	int precise_ptr;
+
+	u32 control_register;	/* cached value */
+	u32 thru_bits;		/* thru 1=on, 0=off channel 1=Bit1... channel 26= Bit26 */
+
+	u32 creg_spdif;
+	u32 creg_spdif_stream;
+
+	char *card_name;		/* hammerfall or hammerfall light names */
+
+        size_t hw_offsetmask;     	/* &-with status register to get real hw_offset */
+	size_t prev_hw_offset;		/* previous hw offset */
+	size_t max_jitter;		/* maximum jitter in frames for 
+					   hw pointer */
+	size_t period_bytes;		/* guess what this is */
+
+	unsigned char ds_channels;
+	unsigned char ss_channels;	/* different for hammerfall/hammerfall-light */
+
+	struct snd_dma_buffer playback_dma_buf;
+	struct snd_dma_buffer capture_dma_buf;
+
+	unsigned char *capture_buffer;	/* suitably aligned address */
+	unsigned char *playback_buffer;	/* suitably aligned address */
+
+	pid_t capture_pid;
+	pid_t playback_pid;
+
+	snd_pcm_substream_t *capture_substream;
+	snd_pcm_substream_t *playback_substream;
+	int running;
+
+        int passthru;                   /* non-zero if doing pass-thru */
+        int hw_rev;                     /* h/w rev * 10 (i.e. 1.5 has hw_rev = 15) */
+
+	int last_spdif_sample_rate;	/* so that we can catch externally ... */
+	int last_adat_sample_rate;	/* ... induced rate changes            */
+
+        char *channel_map;
+
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	struct pci_dev *pci;
+	snd_kcontrol_t *spdif_ctl;
+
+} rme9652_t;
+
+/* These tables map the ALSA channels 1..N to the channels that we
+   need to use in order to find the relevant channel buffer. RME
+   refer to this kind of mapping as between "the ADAT channel and
+   the DMA channel." We index it using the logical audio channel,
+   and the value is the DMA channel (i.e. channel buffer number)
+   where the data for that channel can be read/written from/to.
+*/
+
+static char channel_map_9652_ss[26] = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
+	18, 19, 20, 21, 22, 23, 24, 25
+};
+
+static char channel_map_9636_ss[26] = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
+	/* channels 16 and 17 are S/PDIF */
+	24, 25,
+	/* channels 18-25 don't exist */
+	-1, -1, -1, -1, -1, -1, -1, -1
+};
+
+static char channel_map_9652_ds[26] = {
+	/* ADAT channels are remapped */
+	1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23,
+	/* channels 12 and 13 are S/PDIF */
+	24, 25,
+	/* others don't exist */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
+};
+
+static char channel_map_9636_ds[26] = {
+	/* ADAT channels are remapped */
+	1, 3, 5, 7, 9, 11, 13, 15,
+	/* channels 8 and 9 are S/PDIF */
+	24, 25
+	/* others don't exist */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
+};
+
+static int snd_hammerfall_get_buffer(struct pci_dev *pci, struct snd_dma_buffer *dmab, size_t size)
+{
+	dmab->dev.type = SNDRV_DMA_TYPE_DEV;
+	dmab->dev.dev = snd_dma_pci_data(pci);
+	if (! snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {
+		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+					size, dmab) < 0)
+			return -ENOMEM;
+	}
+	return 0;
+}
+
+static void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_dev *pci)
+{
+	if (dmab->area)
+		snd_dma_reserve_buf(dmab, snd_dma_pci_buf_id(pci));
+}
+
+
+static struct pci_device_id snd_rme9652_ids[] = {
+	{
+		.vendor	   = 0x10ee,
+		.device	   = 0x3fc4,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+	},	/* RME Digi9652 */
+	{ 0, },
+};
+
+MODULE_DEVICE_TABLE(pci, snd_rme9652_ids);
+
+static inline void rme9652_write(rme9652_t *rme9652, int reg, int val)
+{
+	writel(val, rme9652->iobase + reg);
+}
+
+static inline unsigned int rme9652_read(rme9652_t *rme9652, int reg)
+{
+	return readl(rme9652->iobase + reg);
+}
+
+static inline int snd_rme9652_use_is_exclusive(rme9652_t *rme9652)
+{
+	unsigned long flags;
+	int ret = 1;
+
+	spin_lock_irqsave(&rme9652->lock, flags);
+	if ((rme9652->playback_pid != rme9652->capture_pid) &&
+	    (rme9652->playback_pid >= 0) && (rme9652->capture_pid >= 0)) {
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&rme9652->lock, flags);
+	return ret;
+}
+
+static inline int rme9652_adat_sample_rate(rme9652_t *rme9652)
+{
+	if (rme9652_running_double_speed(rme9652)) {
+		return (rme9652_read(rme9652, RME9652_status_register) &
+			RME9652_fs48) ? 96000 : 88200;
+	} else {
+		return (rme9652_read(rme9652, RME9652_status_register) &
+			RME9652_fs48) ? 48000 : 44100;
+	}
+}
+
+static inline void rme9652_compute_period_size(rme9652_t *rme9652)
+{
+	unsigned int i;
+
+	i = rme9652->control_register & RME9652_latency;
+	rme9652->period_bytes = 1 << ((rme9652_decode_latency(i) + 8));
+	rme9652->hw_offsetmask = 
+		(rme9652->period_bytes * 2 - 1) & RME9652_buf_pos;
+	rme9652->max_jitter = 80;
+}
+
+static snd_pcm_uframes_t rme9652_hw_pointer(rme9652_t *rme9652)
+{
+	int status;
+	unsigned int offset, frag;
+	snd_pcm_uframes_t period_size = rme9652->period_bytes / 4;
+	snd_pcm_sframes_t delta;
+
+	status = rme9652_read(rme9652, RME9652_status_register);
+	if (!rme9652->precise_ptr)
+		return (status & RME9652_buffer_id) ? period_size : 0;
+	offset = status & RME9652_buf_pos;
+
+	/* The hardware may give a backward movement for up to 80 frames
+           Martin Kirst <martin.kirst@freenet.de> knows the details.
+	*/
+
+	delta = rme9652->prev_hw_offset - offset;
+	delta &= 0xffff;
+	if (delta <= (snd_pcm_sframes_t)rme9652->max_jitter * 4)
+		offset = rme9652->prev_hw_offset;
+	else
+		rme9652->prev_hw_offset = offset;
+	offset &= rme9652->hw_offsetmask;
+	offset /= 4;
+	frag = status & RME9652_buffer_id;
+
+	if (offset < period_size) {
+		if (offset > rme9652->max_jitter) {
+			if (frag)
+				printk(KERN_ERR "Unexpected hw_pointer position (bufid == 0): status: %x offset: %d\n", status, offset);
+		} else if (!frag)
+			return 0;
+		offset -= rme9652->max_jitter;
+		if (offset < 0)
+			offset += period_size * 2;
+	} else {
+		if (offset > period_size + rme9652->max_jitter) {
+			if (!frag)
+				printk(KERN_ERR "Unexpected hw_pointer position (bufid == 1): status: %x offset: %d\n", status, offset);
+		} else if (frag)
+			return period_size;
+		offset -= rme9652->max_jitter;
+	}
+
+	return offset;
+}
+
+static inline void rme9652_reset_hw_pointer(rme9652_t *rme9652)
+{
+	int i;
+
+	/* reset the FIFO pointer to zero. We do this by writing to 8
+	   registers, each of which is a 32bit wide register, and set
+	   them all to zero. Note that s->iobase is a pointer to
+	   int32, not pointer to char.  
+	*/
+
+	for (i = 0; i < 8; i++) {
+		rme9652_write(rme9652, i * 4, 0);
+		udelay(10);
+	}
+	rme9652->prev_hw_offset = 0;
+}
+
+static inline void rme9652_start(rme9652_t *s)
+{
+	s->control_register |= (RME9652_IE | RME9652_start_bit);
+	rme9652_write(s, RME9652_control_register, s->control_register);
+}
+
+static inline void rme9652_stop(rme9652_t *s)
+{
+	s->control_register &= ~(RME9652_start_bit | RME9652_IE);
+	rme9652_write(s, RME9652_control_register, s->control_register);
+}
+
+static int rme9652_set_interrupt_interval(rme9652_t *s,
+					  unsigned int frames)
+{
+	int restart = 0;
+	int n;
+
+	spin_lock_irq(&s->lock);
+
+	if ((restart = s->running)) {
+		rme9652_stop(s);
+	}
+
+	frames >>= 7;
+	n = 0;
+	while (frames) {
+		n++;
+		frames >>= 1;
+	}
+
+	s->control_register &= ~RME9652_latency;
+	s->control_register |= rme9652_encode_latency(n);
+
+	rme9652_write(s, RME9652_control_register, s->control_register);
+
+	rme9652_compute_period_size(s);
+
+	if (restart)
+		rme9652_start(s);
+
+	spin_unlock_irq(&s->lock);
+
+	return 0;
+}
+
+static int rme9652_set_rate(rme9652_t *rme9652, int rate)
+{
+	int restart;
+	int reject_if_open = 0;
+	int xrate;
+
+	if (!snd_rme9652_use_is_exclusive (rme9652)) {
+		return -EBUSY;
+	}
+
+	/* Changing from a "single speed" to a "double speed" rate is
+	   not allowed if any substreams are open. This is because
+	   such a change causes a shift in the location of 
+	   the DMA buffers and a reduction in the number of available
+	   buffers. 
+
+	   Note that a similar but essentially insoluble problem
+	   exists for externally-driven rate changes. All we can do
+	   is to flag rate changes in the read/write routines.
+	 */
+
+	spin_lock_irq(&rme9652->lock);
+	xrate = rme9652_adat_sample_rate(rme9652);
+
+	switch (rate) {
+	case 44100:
+		if (xrate > 48000) {
+			reject_if_open = 1;
+		}
+		rate = 0;
+		break;
+	case 48000:
+		if (xrate > 48000) {
+			reject_if_open = 1;
+		}
+		rate = RME9652_freq;
+		break;
+	case 88200:
+		if (xrate < 48000) {
+			reject_if_open = 1;
+		}
+		rate = RME9652_DS;
+		break;
+	case 96000:
+		if (xrate < 48000) {
+			reject_if_open = 1;
+		}
+		rate = RME9652_DS | RME9652_freq;
+		break;
+	default:
+		spin_unlock_irq(&rme9652->lock);
+		return -EINVAL;
+	}
+
+	if (reject_if_open && (rme9652->capture_pid >= 0 || rme9652->playback_pid >= 0)) {
+		spin_unlock_irq(&rme9652->lock);
+		return -EBUSY;
+	}
+
+	if ((restart = rme9652->running)) {
+		rme9652_stop(rme9652);
+	}
+	rme9652->control_register &= ~(RME9652_freq | RME9652_DS);
+	rme9652->control_register |= rate;
+	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
+
+	if (restart) {
+		rme9652_start(rme9652);
+	}
+
+	if (rate & RME9652_DS) {
+		if (rme9652->ss_channels == RME9652_NCHANNELS) {
+			rme9652->channel_map = channel_map_9652_ds;
+		} else {
+			rme9652->channel_map = channel_map_9636_ds;
+		}
+	} else {
+		if (rme9652->ss_channels == RME9652_NCHANNELS) {
+			rme9652->channel_map = channel_map_9652_ss;
+		} else {
+			rme9652->channel_map = channel_map_9636_ss;
+		}
+	}
+
+	spin_unlock_irq(&rme9652->lock);
+	return 0;
+}
+
+static void rme9652_set_thru(rme9652_t *rme9652, int channel, int enable)
+{
+	int i;
+
+	rme9652->passthru = 0;
+
+	if (channel < 0) {
+
+		/* set thru for all channels */
+
+		if (enable) {
+			for (i = 0; i < RME9652_NCHANNELS; i++) {
+				rme9652->thru_bits |= (1 << i);
+				rme9652_write(rme9652, RME9652_thru_base + i * 4, 1);
+			}
+		} else {
+			for (i = 0; i < RME9652_NCHANNELS; i++) {
+				rme9652->thru_bits &= ~(1 << i);
+				rme9652_write(rme9652, RME9652_thru_base + i * 4, 0);
+			}
+		}
+
+	} else {
+		int mapped_channel;
+
+		snd_assert(channel == RME9652_NCHANNELS, return);
+
+		mapped_channel = rme9652->channel_map[channel];
+
+		if (enable) {
+			rme9652->thru_bits |= (1 << mapped_channel);
+		} else {
+			rme9652->thru_bits &= ~(1 << mapped_channel);
+		}
+
+		rme9652_write(rme9652,
+			       RME9652_thru_base + mapped_channel * 4,
+			       enable ? 1 : 0);			       
+	}
+}
+
+static int rme9652_set_passthru(rme9652_t *rme9652, int onoff)
+{
+	if (onoff) {
+		rme9652_set_thru(rme9652, -1, 1);
+
+		/* we don't want interrupts, so do a
+		   custom version of rme9652_start().
+		*/
+
+		rme9652->control_register =
+			RME9652_inp_0 | 
+			rme9652_encode_latency(7) |
+			RME9652_start_bit;
+
+		rme9652_reset_hw_pointer(rme9652);
+
+		rme9652_write(rme9652, RME9652_control_register,
+			      rme9652->control_register);
+		rme9652->passthru = 1;
+	} else {
+		rme9652_set_thru(rme9652, -1, 0);
+		rme9652_stop(rme9652);		
+		rme9652->passthru = 0;
+	}
+
+	return 0;
+}
+
+static void rme9652_spdif_set_bit (rme9652_t *rme9652, int mask, int onoff)
+{
+	if (onoff) 
+		rme9652->control_register |= mask;
+	else 
+		rme9652->control_register &= ~mask;
+		
+	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
+}
+
+static void rme9652_spdif_write_byte (rme9652_t *rme9652, const int val)
+{
+	long mask;
+	long i;
+
+	for (i = 0, mask = 0x80; i < 8; i++, mask >>= 1) {
+		if (val & mask)
+			rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_WRITE, 1);
+		else 
+			rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_WRITE, 0);
+
+		rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 1);
+		rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 0);
+	}
+}
+
+static int rme9652_spdif_read_byte (rme9652_t *rme9652)
+{
+	long mask;
+	long val;
+	long i;
+
+	val = 0;
+
+	for (i = 0, mask = 0x80;  i < 8; i++, mask >>= 1) {
+		rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 1);
+		if (rme9652_read (rme9652, RME9652_status_register) & RME9652_SPDIF_READ)
+			val |= mask;
+		rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 0);
+	}
+
+	return val;
+}
+
+static void rme9652_write_spdif_codec (rme9652_t *rme9652, const int address, const int data)
+{
+	rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);
+	rme9652_spdif_write_byte (rme9652, 0x20);
+	rme9652_spdif_write_byte (rme9652, address);
+	rme9652_spdif_write_byte (rme9652, data);
+	rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 0);
+}
+
+
+static int rme9652_spdif_read_codec (rme9652_t *rme9652, const int address)
+{
+	int ret;
+
+	rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);
+	rme9652_spdif_write_byte (rme9652, 0x20);
+	rme9652_spdif_write_byte (rme9652, address);
+	rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 0);
+	rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);
+
+	rme9652_spdif_write_byte (rme9652, 0x21);
+	ret = rme9652_spdif_read_byte (rme9652);
+	rme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 0);
+
+	return ret;
+}
+
+static void rme9652_initialize_spdif_receiver (rme9652_t *rme9652)
+{
+	/* XXX what unsets this ? */
+
+	rme9652->control_register |= RME9652_SPDIF_RESET;
+
+	rme9652_write_spdif_codec (rme9652, 4, 0x40);
+	rme9652_write_spdif_codec (rme9652, 17, 0x13);
+	rme9652_write_spdif_codec (rme9652, 6, 0x02);
+}
+
+static inline int rme9652_spdif_sample_rate(rme9652_t *s)
+{
+	unsigned int rate_bits;
+
+	if (rme9652_read(s, RME9652_status_register) & RME9652_ERF) {
+		return -1;	/* error condition */
+	}
+	
+	if (s->hw_rev == 15) {
+
+		int x, y, ret;
+		
+		x = rme9652_spdif_read_codec (s, 30);
+
+		if (x != 0) 
+			y = 48000 * 64 / x;
+		else
+			y = 0;
+
+		if      (y > 30400 && y < 33600)  ret = 32000; 
+		else if (y > 41900 && y < 46000)  ret = 44100;
+		else if (y > 46000 && y < 50400)  ret = 48000;
+		else if (y > 60800 && y < 67200)  ret = 64000;
+		else if (y > 83700 && y < 92000)  ret = 88200;
+		else if (y > 92000 && y < 100000) ret = 96000;
+		else                              ret = 0;
+		return ret;
+	}
+
+	rate_bits = rme9652_read(s, RME9652_status_register) & RME9652_F;
+
+	switch (rme9652_decode_spdif_rate(rate_bits)) {
+	case 0x7:
+		return 32000;
+		break;
+
+	case 0x6:
+		return 44100;
+		break;
+
+	case 0x5:
+		return 48000;
+		break;
+
+	case 0x4:
+		return 88200;
+		break;
+
+	case 0x3:
+		return 96000;
+		break;
+
+	case 0x0:
+		return 64000;
+		break;
+
+	default:
+		snd_printk("%s: unknown S/PDIF input rate (bits = 0x%x)\n",
+			   s->card_name, rate_bits);
+		return 0;
+		break;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+  Control Interface
+  ----------------------------------------------------------------------------*/
+
+static u32 snd_rme9652_convert_from_aes(snd_aes_iec958_t *aes)
+{
+	u32 val = 0;
+	val |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME9652_PRO : 0;
+	val |= (aes->status[0] & IEC958_AES0_NONAUDIO) ? RME9652_Dolby : 0;
+	if (val & RME9652_PRO)
+		val |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? RME9652_EMP : 0;
+	else
+		val |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? RME9652_EMP : 0;
+	return val;
+}
+
+static void snd_rme9652_convert_to_aes(snd_aes_iec958_t *aes, u32 val)
+{
+	aes->status[0] = ((val & RME9652_PRO) ? IEC958_AES0_PROFESSIONAL : 0) |
+			 ((val & RME9652_Dolby) ? IEC958_AES0_NONAUDIO : 0);
+	if (val & RME9652_PRO)
+		aes->status[0] |= (val & RME9652_EMP) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;
+	else
+		aes->status[0] |= (val & RME9652_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;
+}
+
+static int snd_rme9652_control_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_rme9652_control_spdif_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	
+	snd_rme9652_convert_to_aes(&ucontrol->value.iec958, rme9652->creg_spdif);
+	return 0;
+}
+
+static int snd_rme9652_control_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	int change;
+	u32 val;
+	
+	val = snd_rme9652_convert_from_aes(&ucontrol->value.iec958);
+	spin_lock_irq(&rme9652->lock);
+	change = val != rme9652->creg_spdif;
+	rme9652->creg_spdif = val;
+	spin_unlock_irq(&rme9652->lock);
+	return change;
+}
+
+static int snd_rme9652_control_spdif_stream_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_rme9652_control_spdif_stream_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	
+	snd_rme9652_convert_to_aes(&ucontrol->value.iec958, rme9652->creg_spdif_stream);
+	return 0;
+}
+
+static int snd_rme9652_control_spdif_stream_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	int change;
+	u32 val;
+	
+	val = snd_rme9652_convert_from_aes(&ucontrol->value.iec958);
+	spin_lock_irq(&rme9652->lock);
+	change = val != rme9652->creg_spdif_stream;
+	rme9652->creg_spdif_stream = val;
+	rme9652->control_register &= ~(RME9652_PRO | RME9652_Dolby | RME9652_EMP);
+	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register |= val);
+	spin_unlock_irq(&rme9652->lock);
+	return change;
+}
+
+static int snd_rme9652_control_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_rme9652_control_spdif_mask_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = kcontrol->private_value;
+	return 0;
+}
+
+#define RME9652_ADAT1_IN(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+  .info = snd_rme9652_info_adat1_in, \
+  .get = snd_rme9652_get_adat1_in, \
+  .put = snd_rme9652_put_adat1_in }
+
+static unsigned int rme9652_adat1_in(rme9652_t *rme9652)
+{
+	if (rme9652->control_register & RME9652_ADAT1_INTERNAL)
+		return 1; 
+	return 0;
+}
+
+static int rme9652_set_adat1_input(rme9652_t *rme9652, int internal)
+{
+	int restart = 0;
+
+	if (internal) {
+		rme9652->control_register |= RME9652_ADAT1_INTERNAL;
+	} else {
+		rme9652->control_register &= ~RME9652_ADAT1_INTERNAL;
+	}
+
+	/* XXX do we actually need to stop the card when we do this ? */
+
+	if ((restart = rme9652->running)) {
+		rme9652_stop(rme9652);
+	}
+
+	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
+
+	if (restart) {
+		rme9652_start(rme9652);
+	}
+
+	return 0;
+}
+
+static int snd_rme9652_info_adat1_in(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[2] = {"ADAT1", "Internal"};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item > 1)
+		uinfo->value.enumerated.item = 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_rme9652_get_adat1_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme9652->lock);
+	ucontrol->value.enumerated.item[0] = rme9652_adat1_in(rme9652);
+	spin_unlock_irq(&rme9652->lock);
+	return 0;
+}
+
+static int snd_rme9652_put_adat1_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+	
+	if (!snd_rme9652_use_is_exclusive(rme9652))
+		return -EBUSY;
+	val = ucontrol->value.enumerated.item[0] % 2;
+	spin_lock_irq(&rme9652->lock);
+	change = val != rme9652_adat1_in(rme9652);
+	if (change)
+		rme9652_set_adat1_input(rme9652, val);
+	spin_unlock_irq(&rme9652->lock);
+	return change;
+}
+
+#define RME9652_SPDIF_IN(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+  .info = snd_rme9652_info_spdif_in, \
+  .get = snd_rme9652_get_spdif_in, .put = snd_rme9652_put_spdif_in }
+
+static unsigned int rme9652_spdif_in(rme9652_t *rme9652)
+{
+	return rme9652_decode_spdif_in(rme9652->control_register &
+				       RME9652_inp);
+}
+
+static int rme9652_set_spdif_input(rme9652_t *rme9652, int in)
+{
+	int restart = 0;
+
+	rme9652->control_register &= ~RME9652_inp;
+	rme9652->control_register |= rme9652_encode_spdif_in(in);
+
+	if ((restart = rme9652->running)) {
+		rme9652_stop(rme9652);
+	}
+
+	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
+
+	if (restart) {
+		rme9652_start(rme9652);
+	}
+
+	return 0;
+}
+
+static int snd_rme9652_info_spdif_in(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[3] = {"ADAT1", "Coaxial", "Internal"};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item > 2)
+		uinfo->value.enumerated.item = 2;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_rme9652_get_spdif_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme9652->lock);
+	ucontrol->value.enumerated.item[0] = rme9652_spdif_in(rme9652);
+	spin_unlock_irq(&rme9652->lock);
+	return 0;
+}
+
+static int snd_rme9652_put_spdif_in(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+	
+	if (!snd_rme9652_use_is_exclusive(rme9652))
+		return -EBUSY;
+	val = ucontrol->value.enumerated.item[0] % 3;
+	spin_lock_irq(&rme9652->lock);
+	change = val != rme9652_spdif_in(rme9652);
+	if (change)
+		rme9652_set_spdif_input(rme9652, val);
+	spin_unlock_irq(&rme9652->lock);
+	return change;
+}
+
+#define RME9652_SPDIF_OUT(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+  .info = snd_rme9652_info_spdif_out, \
+  .get = snd_rme9652_get_spdif_out, .put = snd_rme9652_put_spdif_out }
+
+static int rme9652_spdif_out(rme9652_t *rme9652)
+{
+	return (rme9652->control_register & RME9652_opt_out) ? 1 : 0;
+}
+
+static int rme9652_set_spdif_output(rme9652_t *rme9652, int out)
+{
+	int restart = 0;
+
+	if (out) {
+		rme9652->control_register |= RME9652_opt_out;
+	} else {
+		rme9652->control_register &= ~RME9652_opt_out;
+	}
+
+	if ((restart = rme9652->running)) {
+		rme9652_stop(rme9652);
+	}
+
+	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
+
+	if (restart) {
+		rme9652_start(rme9652);
+	}
+
+	return 0;
+}
+
+static int snd_rme9652_info_spdif_out(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_rme9652_get_spdif_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme9652->lock);
+	ucontrol->value.integer.value[0] = rme9652_spdif_out(rme9652);
+	spin_unlock_irq(&rme9652->lock);
+	return 0;
+}
+
+static int snd_rme9652_put_spdif_out(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+	
+	if (!snd_rme9652_use_is_exclusive(rme9652))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&rme9652->lock);
+	change = (int)val != rme9652_spdif_out(rme9652);
+	rme9652_set_spdif_output(rme9652, val);
+	spin_unlock_irq(&rme9652->lock);
+	return change;
+}
+
+#define RME9652_SYNC_MODE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+  .info = snd_rme9652_info_sync_mode, \
+  .get = snd_rme9652_get_sync_mode, .put = snd_rme9652_put_sync_mode }
+
+static int rme9652_sync_mode(rme9652_t *rme9652)
+{
+	if (rme9652->control_register & RME9652_wsel) {
+		return 2;
+	} else if (rme9652->control_register & RME9652_Master) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static int rme9652_set_sync_mode(rme9652_t *rme9652, int mode)
+{
+	int restart = 0;
+
+	switch (mode) {
+	case 0:
+		rme9652->control_register &=
+		    ~(RME9652_Master | RME9652_wsel);
+		break;
+	case 1:
+		rme9652->control_register =
+		    (rme9652->control_register & ~RME9652_wsel) | RME9652_Master;
+		break;
+	case 2:
+		rme9652->control_register |=
+		    (RME9652_Master | RME9652_wsel);
+		break;
+	}
+
+	if ((restart = rme9652->running)) {
+		rme9652_stop(rme9652);
+	}
+
+	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
+
+	if (restart) {
+		rme9652_start(rme9652);
+	}
+
+	return 0;
+}
+
+static int snd_rme9652_info_sync_mode(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[3] = {"AutoSync", "Master", "Word Clock"};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item > 2)
+		uinfo->value.enumerated.item = 2;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_rme9652_get_sync_mode(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme9652->lock);
+	ucontrol->value.enumerated.item[0] = rme9652_sync_mode(rme9652);
+	spin_unlock_irq(&rme9652->lock);
+	return 0;
+}
+
+static int snd_rme9652_put_sync_mode(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+	
+	val = ucontrol->value.enumerated.item[0] % 3;
+	spin_lock_irq(&rme9652->lock);
+	change = (int)val != rme9652_sync_mode(rme9652);
+	rme9652_set_sync_mode(rme9652, val);
+	spin_unlock_irq(&rme9652->lock);
+	return change;
+}
+
+#define RME9652_SYNC_PREF(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+  .info = snd_rme9652_info_sync_pref, \
+  .get = snd_rme9652_get_sync_pref, .put = snd_rme9652_put_sync_pref }
+
+static int rme9652_sync_pref(rme9652_t *rme9652)
+{
+	switch (rme9652->control_register & RME9652_SyncPref_Mask) {
+	case RME9652_SyncPref_ADAT1:
+		return RME9652_SYNC_FROM_ADAT1;
+	case RME9652_SyncPref_ADAT2:
+		return RME9652_SYNC_FROM_ADAT2;
+	case RME9652_SyncPref_ADAT3:
+		return RME9652_SYNC_FROM_ADAT3;
+	case RME9652_SyncPref_SPDIF:
+		return RME9652_SYNC_FROM_SPDIF;
+	}
+	/* Not reachable */
+	return 0;
+}
+
+static int rme9652_set_sync_pref(rme9652_t *rme9652, int pref)
+{
+	int restart;
+
+	rme9652->control_register &= ~RME9652_SyncPref_Mask;
+	switch (pref) {
+	case RME9652_SYNC_FROM_ADAT1:
+		rme9652->control_register |= RME9652_SyncPref_ADAT1;
+		break;
+	case RME9652_SYNC_FROM_ADAT2:
+		rme9652->control_register |= RME9652_SyncPref_ADAT2;
+		break;
+	case RME9652_SYNC_FROM_ADAT3:
+		rme9652->control_register |= RME9652_SyncPref_ADAT3;
+		break;
+	case RME9652_SYNC_FROM_SPDIF:
+		rme9652->control_register |= RME9652_SyncPref_SPDIF;
+		break;
+	}
+
+	if ((restart = rme9652->running)) {
+		rme9652_stop(rme9652);
+	}
+
+	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
+
+	if (restart) {
+		rme9652_start(rme9652);
+	}
+
+	return 0;
+}
+
+static int snd_rme9652_info_sync_pref(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[4] = {"IEC958 In", "ADAT1 In", "ADAT2 In", "ADAT3 In"};
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = rme9652->ss_channels == RME9652_NCHANNELS ? 4 : 3;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_rme9652_get_sync_pref(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme9652->lock);
+	ucontrol->value.enumerated.item[0] = rme9652_sync_pref(rme9652);
+	spin_unlock_irq(&rme9652->lock);
+	return 0;
+}
+
+static int snd_rme9652_put_sync_pref(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	int change, max;
+	unsigned int val;
+	
+	if (!snd_rme9652_use_is_exclusive(rme9652))
+		return -EBUSY;
+	max = rme9652->ss_channels == RME9652_NCHANNELS ? 4 : 3;
+	val = ucontrol->value.enumerated.item[0] % max;
+	spin_lock_irq(&rme9652->lock);
+	change = (int)val != rme9652_sync_pref(rme9652);
+	rme9652_set_sync_pref(rme9652, val);
+	spin_unlock_irq(&rme9652->lock);
+	return change;
+}
+
+static int snd_rme9652_info_thru(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = rme9652->ss_channels;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_rme9652_get_thru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	unsigned int k;
+	u32 thru_bits = rme9652->thru_bits;
+
+	for (k = 0; k < rme9652->ss_channels; ++k) {
+		ucontrol->value.integer.value[k] = !!(thru_bits & (1 << k));
+	}
+	return 0;
+}
+
+static int snd_rme9652_put_thru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int chn;
+	u32 thru_bits = 0;
+
+	if (!snd_rme9652_use_is_exclusive(rme9652))
+		return -EBUSY;
+
+	for (chn = 0; chn < rme9652->ss_channels; ++chn) {
+		if (ucontrol->value.integer.value[chn])
+			thru_bits |= 1 << chn;
+	}
+	
+	spin_lock_irq(&rme9652->lock);
+	change = thru_bits ^ rme9652->thru_bits;
+	if (change) {
+		for (chn = 0; chn < rme9652->ss_channels; ++chn) {
+			if (!(change & (1 << chn)))
+				continue;
+			rme9652_set_thru(rme9652,chn,thru_bits&(1<<chn));
+		}
+	}
+	spin_unlock_irq(&rme9652->lock);
+	return !!change;
+}
+
+#define RME9652_PASSTHRU(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+  .info = snd_rme9652_info_passthru, \
+  .put = snd_rme9652_put_passthru, \
+  .get = snd_rme9652_get_passthru }
+
+static int snd_rme9652_info_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_rme9652_get_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&rme9652->lock);
+	ucontrol->value.integer.value[0] = rme9652->passthru;
+	spin_unlock_irq(&rme9652->lock);
+	return 0;
+}
+
+static int snd_rme9652_put_passthru(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+	int err = 0;
+
+	if (!snd_rme9652_use_is_exclusive(rme9652))
+		return -EBUSY;
+
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&rme9652->lock);
+	change = (ucontrol->value.integer.value[0] != rme9652->passthru);
+	if (change)
+		err = rme9652_set_passthru(rme9652, val);
+	spin_unlock_irq(&rme9652->lock);
+	return err ? err : change;
+}
+
+/* Read-only switches */
+
+#define RME9652_SPDIF_RATE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_rme9652_info_spdif_rate, \
+  .get = snd_rme9652_get_spdif_rate }
+
+static int snd_rme9652_info_spdif_rate(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 96000;
+	return 0;
+}
+
+static int snd_rme9652_get_spdif_rate(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme9652->lock);
+	ucontrol->value.integer.value[0] = rme9652_spdif_sample_rate(rme9652);
+	spin_unlock_irq(&rme9652->lock);
+	return 0;
+}
+
+#define RME9652_ADAT_SYNC(xname, xindex, xidx) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_rme9652_info_adat_sync, \
+  .get = snd_rme9652_get_adat_sync, .private_value = xidx }
+
+static int snd_rme9652_info_adat_sync(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[4] = {"No Lock", "Lock", "No Lock Sync", "Lock Sync"};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 4;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_rme9652_get_adat_sync(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	unsigned int mask1, mask2, val;
+	
+	switch (kcontrol->private_value) {
+	case 0: mask1 = RME9652_lock_0; mask2 = RME9652_sync_0; break;	
+	case 1: mask1 = RME9652_lock_1; mask2 = RME9652_sync_1; break;	
+	case 2: mask1 = RME9652_lock_2; mask2 = RME9652_sync_2; break;	
+	default: return -EINVAL;
+	}
+	val = rme9652_read(rme9652, RME9652_status_register);
+	ucontrol->value.enumerated.item[0] = (val & mask1) ? 1 : 0;
+	ucontrol->value.enumerated.item[0] |= (val & mask2) ? 2 : 0;
+	return 0;
+}
+
+#define RME9652_TC_VALID(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname, .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_rme9652_info_tc_valid, \
+  .get = snd_rme9652_get_tc_valid }
+
+static int snd_rme9652_info_tc_valid(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_rme9652_get_tc_valid(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme9652_t *rme9652 = snd_kcontrol_chip(kcontrol);
+	
+	ucontrol->value.integer.value[0] = 
+		(rme9652_read(rme9652, RME9652_status_register) & RME9652_tc_valid) ? 1 : 0;
+	return 0;
+}
+
+#if ALSA_HAS_STANDARD_WAY_OF_RETURNING_TIMECODE
+
+/* FIXME: this routine needs a port to the new control API --jk */
+
+static int snd_rme9652_get_tc_value(void *private_data,
+				    snd_kswitch_t *kswitch,
+				    snd_switch_t *uswitch)
+{
+	rme9652_t *s = (rme9652_t *) private_data;
+	u32 value;
+	int i;
+
+	uswitch->type = SNDRV_SW_TYPE_DWORD;
+
+	if ((rme9652_read(s, RME9652_status_register) &
+	     RME9652_tc_valid) == 0) {
+		uswitch->value.data32[0] = 0;
+		return 0;
+	}
+
+	/* timecode request */
+
+	rme9652_write(s, RME9652_time_code, 0);
+
+	/* XXX bug alert: loop-based timing !!!! */
+
+	for (i = 0; i < 50; i++) {
+		if (!(rme9652_read(s, i * 4) & RME9652_tc_busy))
+			break;
+	}
+
+	if (!(rme9652_read(s, i * 4) & RME9652_tc_busy)) {
+		return -EIO;
+	}
+
+	value = 0;
+
+	for (i = 0; i < 32; i++) {
+		value >>= 1;
+
+		if (rme9652_read(s, i * 4) & RME9652_tc_out)
+			value |= 0x80000000;
+	}
+
+	if (value > 2 * 60 * 48000) {
+		value -= 2 * 60 * 48000;
+	} else {
+		value = 0;
+	}
+
+	uswitch->value.data32[0] = value;
+
+	return 0;
+}
+
+#endif				/* ALSA_HAS_STANDARD_WAY_OF_RETURNING_TIMECODE */
+
+static snd_kcontrol_new_t snd_rme9652_controls[] = {
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.info =		snd_rme9652_control_spdif_info,
+	.get =		snd_rme9652_control_spdif_get,
+	.put =		snd_rme9652_control_spdif_put,
+},
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
+	.info =		snd_rme9652_control_spdif_stream_info,
+	.get =		snd_rme9652_control_spdif_stream_get,
+	.put =		snd_rme9652_control_spdif_stream_put,
+},
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,CON_MASK),
+	.info =		snd_rme9652_control_spdif_mask_info,
+	.get =		snd_rme9652_control_spdif_mask_get,
+	.private_value = IEC958_AES0_NONAUDIO |
+			IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_CON_EMPHASIS,	                                                                                      
+},
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PRO_MASK),
+	.info =		snd_rme9652_control_spdif_mask_info,
+	.get =		snd_rme9652_control_spdif_mask_get,
+	.private_value = IEC958_AES0_NONAUDIO |
+			IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_PRO_EMPHASIS,
+},
+RME9652_SPDIF_IN("IEC958 Input Connector", 0),
+RME9652_SPDIF_OUT("IEC958 Output also on ADAT1", 0),
+RME9652_SYNC_MODE("Sync Mode", 0),
+RME9652_SYNC_PREF("Preferred Sync Source", 0),
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.name = "Channels Thru",
+	.index = 0,
+	.info = snd_rme9652_info_thru,
+	.get = snd_rme9652_get_thru,
+	.put = snd_rme9652_put_thru,
+},
+RME9652_SPDIF_RATE("IEC958 Sample Rate", 0),
+RME9652_ADAT_SYNC("ADAT1 Sync Check", 0, 0),
+RME9652_ADAT_SYNC("ADAT2 Sync Check", 0, 1),
+RME9652_TC_VALID("Timecode Valid", 0),
+RME9652_PASSTHRU("Passthru", 0)
+};
+
+static snd_kcontrol_new_t snd_rme9652_adat3_check =
+RME9652_ADAT_SYNC("ADAT3 Sync Check", 0, 2);
+
+static snd_kcontrol_new_t snd_rme9652_adat1_input =
+RME9652_ADAT1_IN("ADAT1 Input Source", 0);
+
+static int snd_rme9652_create_controls(snd_card_t *card, rme9652_t *rme9652)
+{
+	unsigned int idx;
+	int err;
+	snd_kcontrol_t *kctl;
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_rme9652_controls); idx++) {
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme9652_controls[idx], rme9652))) < 0)
+			return err;
+		if (idx == 1)	/* IEC958 (S/PDIF) Stream */
+			rme9652->spdif_ctl = kctl;
+	}
+
+	if (rme9652->ss_channels == RME9652_NCHANNELS)
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme9652_adat3_check, rme9652))) < 0)
+			return err;
+
+	if (rme9652->hw_rev >= 15)
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme9652_adat1_input, rme9652))) < 0)
+			return err;
+
+	return 0;
+}
+
+/*------------------------------------------------------------
+   /proc interface 
+ ------------------------------------------------------------*/
+
+static void
+snd_rme9652_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	rme9652_t *rme9652 = (rme9652_t *) entry->private_data;
+	u32 thru_bits = rme9652->thru_bits;
+	int show_auto_sync_source = 0;
+	int i;
+	unsigned int status;
+	int x;
+
+	status = rme9652_read(rme9652, RME9652_status_register);
+
+	snd_iprintf(buffer, "%s (Card #%d)\n", rme9652->card_name, rme9652->card->number + 1);
+	snd_iprintf(buffer, "Buffers: capture %p playback %p\n",
+		    rme9652->capture_buffer, rme9652->playback_buffer);
+	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
+		    rme9652->irq, rme9652->port, (unsigned long)rme9652->iobase);
+	snd_iprintf(buffer, "Control register: %x\n", rme9652->control_register);
+
+	snd_iprintf(buffer, "\n");
+
+	x = 1 << (6 + rme9652_decode_latency(rme9652->control_register & 
+					     RME9652_latency));
+
+	snd_iprintf(buffer, "Latency: %d samples (2 periods of %lu bytes)\n", 
+		    x, (unsigned long) rme9652->period_bytes);
+	snd_iprintf(buffer, "Hardware pointer (frames): %ld\n",
+		    rme9652_hw_pointer(rme9652));
+	snd_iprintf(buffer, "Passthru: %s\n",
+		    rme9652->passthru ? "yes" : "no");
+
+	if ((rme9652->control_register & (RME9652_Master | RME9652_wsel)) == 0) {
+		snd_iprintf(buffer, "Clock mode: autosync\n");
+		show_auto_sync_source = 1;
+	} else if (rme9652->control_register & RME9652_wsel) {
+		if (status & RME9652_wsel_rd) {
+			snd_iprintf(buffer, "Clock mode: word clock\n");
+		} else {
+			snd_iprintf(buffer, "Clock mode: word clock (no signal)\n");
+		}
+	} else {
+		snd_iprintf(buffer, "Clock mode: master\n");
+	}
+
+	if (show_auto_sync_source) {
+		switch (rme9652->control_register & RME9652_SyncPref_Mask) {
+		case RME9652_SyncPref_ADAT1:
+			snd_iprintf(buffer, "Pref. sync source: ADAT1\n");
+			break;
+		case RME9652_SyncPref_ADAT2:
+			snd_iprintf(buffer, "Pref. sync source: ADAT2\n");
+			break;
+		case RME9652_SyncPref_ADAT3:
+			snd_iprintf(buffer, "Pref. sync source: ADAT3\n");
+			break;
+		case RME9652_SyncPref_SPDIF:
+			snd_iprintf(buffer, "Pref. sync source: IEC958\n");
+			break;
+		default:
+			snd_iprintf(buffer, "Pref. sync source: ???\n");
+		}
+	}
+
+	if (rme9652->hw_rev >= 15)
+		snd_iprintf(buffer, "\nADAT1 Input source: %s\n",
+			    (rme9652->control_register & RME9652_ADAT1_INTERNAL) ?
+			    "Internal" : "ADAT1 optical");
+
+	snd_iprintf(buffer, "\n");
+
+	switch (rme9652_decode_spdif_in(rme9652->control_register & 
+					RME9652_inp)) {
+	case RME9652_SPDIFIN_OPTICAL:
+		snd_iprintf(buffer, "IEC958 input: ADAT1\n");
+		break;
+	case RME9652_SPDIFIN_COAXIAL:
+		snd_iprintf(buffer, "IEC958 input: Coaxial\n");
+		break;
+	case RME9652_SPDIFIN_INTERN:
+		snd_iprintf(buffer, "IEC958 input: Internal\n");
+		break;
+	default:
+		snd_iprintf(buffer, "IEC958 input: ???\n");
+		break;
+	}
+
+	if (rme9652->control_register & RME9652_opt_out) {
+		snd_iprintf(buffer, "IEC958 output: Coaxial & ADAT1\n");
+	} else {
+		snd_iprintf(buffer, "IEC958 output: Coaxial only\n");
+	}
+
+	if (rme9652->control_register & RME9652_PRO) {
+		snd_iprintf(buffer, "IEC958 quality: Professional\n");
+	} else {
+		snd_iprintf(buffer, "IEC958 quality: Consumer\n");
+	}
+
+	if (rme9652->control_register & RME9652_EMP) {
+		snd_iprintf(buffer, "IEC958 emphasis: on\n");
+	} else {
+		snd_iprintf(buffer, "IEC958 emphasis: off\n");
+	}
+
+	if (rme9652->control_register & RME9652_Dolby) {
+		snd_iprintf(buffer, "IEC958 Dolby: on\n");
+	} else {
+		snd_iprintf(buffer, "IEC958 Dolby: off\n");
+	}
+
+	i = rme9652_spdif_sample_rate(rme9652);
+
+	if (i < 0) {
+		snd_iprintf(buffer,
+			    "IEC958 sample rate: error flag set\n");
+	} else if (i == 0) {
+		snd_iprintf(buffer, "IEC958 sample rate: undetermined\n");
+	} else {
+		snd_iprintf(buffer, "IEC958 sample rate: %d\n", i);
+	}
+
+	snd_iprintf(buffer, "\n");
+
+	snd_iprintf(buffer, "ADAT Sample rate: %dHz\n",
+		    rme9652_adat_sample_rate(rme9652));
+
+	/* Sync Check */
+
+	x = status & RME9652_sync_0;
+	if (status & RME9652_lock_0) {
+		snd_iprintf(buffer, "ADAT1: %s\n", x ? "Sync" : "Lock");
+	} else {
+		snd_iprintf(buffer, "ADAT1: No Lock\n");
+	}
+
+	x = status & RME9652_sync_1;
+	if (status & RME9652_lock_1) {
+		snd_iprintf(buffer, "ADAT2: %s\n", x ? "Sync" : "Lock");
+	} else {
+		snd_iprintf(buffer, "ADAT2: No Lock\n");
+	}
+
+	x = status & RME9652_sync_2;
+	if (status & RME9652_lock_2) {
+		snd_iprintf(buffer, "ADAT3: %s\n", x ? "Sync" : "Lock");
+	} else {
+		snd_iprintf(buffer, "ADAT3: No Lock\n");
+	}
+
+	snd_iprintf(buffer, "\n");
+
+	snd_iprintf(buffer, "Timecode signal: %s\n",
+		    (status & RME9652_tc_valid) ? "yes" : "no");
+
+	/* thru modes */
+
+	snd_iprintf(buffer, "Punch Status:\n\n");
+
+	for (i = 0; i < rme9652->ss_channels; i++) {
+		if (thru_bits & (1 << i)) {
+			snd_iprintf(buffer, "%2d:  on ", i + 1);
+		} else {
+			snd_iprintf(buffer, "%2d: off ", i + 1);
+		}
+
+		if (((i + 1) % 8) == 0) {
+			snd_iprintf(buffer, "\n");
+		}
+	}
+
+	snd_iprintf(buffer, "\n");
+}
+
+static void __devinit snd_rme9652_proc_init(rme9652_t *rme9652)
+{
+	snd_info_entry_t *entry;
+
+	if (! snd_card_proc_new(rme9652->card, "rme9652", &entry))
+		snd_info_set_text_ops(entry, rme9652, 1024, snd_rme9652_proc_read);
+}
+
+static void snd_rme9652_free_buffers(rme9652_t *rme9652)
+{
+	snd_hammerfall_free_buffer(&rme9652->capture_dma_buf, rme9652->pci);
+	snd_hammerfall_free_buffer(&rme9652->playback_dma_buf, rme9652->pci);
+}
+
+static int snd_rme9652_free(rme9652_t *rme9652)
+{
+	if (rme9652->irq >= 0)
+		rme9652_stop(rme9652);
+	snd_rme9652_free_buffers(rme9652);
+
+	if (rme9652->irq >= 0)
+		free_irq(rme9652->irq, (void *)rme9652);
+	if (rme9652->iobase)
+		iounmap(rme9652->iobase);
+	if (rme9652->port)
+		pci_release_regions(rme9652->pci);
+
+	pci_disable_device(rme9652->pci);
+	return 0;
+}
+
+static int __devinit snd_rme9652_initialize_memory(rme9652_t *rme9652)
+{
+	unsigned long pb_bus, cb_bus;
+
+	if (snd_hammerfall_get_buffer(rme9652->pci, &rme9652->capture_dma_buf, RME9652_DMA_AREA_BYTES) < 0 ||
+	    snd_hammerfall_get_buffer(rme9652->pci, &rme9652->playback_dma_buf, RME9652_DMA_AREA_BYTES) < 0) {
+		if (rme9652->capture_dma_buf.area)
+			snd_dma_free_pages(&rme9652->capture_dma_buf);
+		printk(KERN_ERR "%s: no buffers available\n", rme9652->card_name);
+		return -ENOMEM;
+	}
+
+	/* Align to bus-space 64K boundary */
+
+	cb_bus = (rme9652->capture_dma_buf.addr + 0xFFFF) & ~0xFFFFl;
+	pb_bus = (rme9652->playback_dma_buf.addr + 0xFFFF) & ~0xFFFFl;
+
+	/* Tell the card where it is */
+
+	rme9652_write(rme9652, RME9652_rec_buffer, cb_bus);
+	rme9652_write(rme9652, RME9652_play_buffer, pb_bus);
+
+	rme9652->capture_buffer = rme9652->capture_dma_buf.area + (cb_bus - rme9652->capture_dma_buf.addr);
+	rme9652->playback_buffer = rme9652->playback_dma_buf.area + (pb_bus - rme9652->playback_dma_buf.addr);
+
+	return 0;
+}
+
+static void snd_rme9652_set_defaults(rme9652_t *rme9652)
+{
+	unsigned int k;
+
+	/* ASSUMPTION: rme9652->lock is either held, or
+	   there is no need to hold it (e.g. during module
+	   initalization).
+	 */
+
+	/* set defaults:
+
+	   SPDIF Input via Coax 
+	   autosync clock mode
+	   maximum latency (7 = 8192 samples, 64Kbyte buffer,
+	   which implies 2 4096 sample, 32Kbyte periods).
+	   
+	   if rev 1.5, initialize the S/PDIF receiver.
+
+	 */
+
+	rme9652->control_register =
+	    RME9652_inp_0 | rme9652_encode_latency(7);
+
+	rme9652_write(rme9652, RME9652_control_register, rme9652->control_register);
+
+	rme9652_reset_hw_pointer(rme9652);
+	rme9652_compute_period_size(rme9652);
+
+	/* default: thru off for all channels */
+
+	for (k = 0; k < RME9652_NCHANNELS; ++k)
+		rme9652_write(rme9652, RME9652_thru_base + k * 4, 0);
+
+	rme9652->thru_bits = 0;
+	rme9652->passthru = 0;
+
+	/* set a default rate so that the channel map is set up */
+
+	rme9652_set_rate(rme9652, 48000);
+}
+
+static irqreturn_t snd_rme9652_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	rme9652_t *rme9652 = (rme9652_t *) dev_id;
+
+	if (!(rme9652_read(rme9652, RME9652_status_register) & RME9652_IRQ)) {
+		return IRQ_NONE;
+	}
+
+	rme9652_write(rme9652, RME9652_irq_clear, 0);
+
+	if (rme9652->capture_substream) {
+		snd_pcm_period_elapsed(rme9652->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);
+	}
+
+	if (rme9652->playback_substream) {
+		snd_pcm_period_elapsed(rme9652->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream);
+	}
+	return IRQ_HANDLED;
+}
+
+static snd_pcm_uframes_t snd_rme9652_hw_pointer(snd_pcm_substream_t *substream)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	return rme9652_hw_pointer(rme9652);
+}
+
+static char *rme9652_channel_buffer_location(rme9652_t *rme9652,
+					     int stream,
+					     int channel)
+
+{
+	int mapped_channel;
+
+        snd_assert(channel >= 0 || channel < RME9652_NCHANNELS, return NULL);
+        
+	if ((mapped_channel = rme9652->channel_map[channel]) < 0) {
+		return NULL;
+	}
+	
+	if (stream == SNDRV_PCM_STREAM_CAPTURE) {
+		return rme9652->capture_buffer +
+			(mapped_channel * RME9652_CHANNEL_BUFFER_BYTES);
+	} else {
+		return rme9652->playback_buffer +
+			(mapped_channel * RME9652_CHANNEL_BUFFER_BYTES);
+	}
+}
+
+static int snd_rme9652_playback_copy(snd_pcm_substream_t *substream, int channel,
+				     snd_pcm_uframes_t pos, void __user *src, snd_pcm_uframes_t count)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	snd_assert(pos + count <= RME9652_CHANNEL_BUFFER_BYTES / 4, return -EINVAL);
+
+	channel_buf = rme9652_channel_buffer_location (rme9652,
+						       substream->pstr->stream,
+						       channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	if (copy_from_user(channel_buf + pos * 4, src, count * 4))
+		return -EFAULT;
+	return count;
+}
+
+static int snd_rme9652_capture_copy(snd_pcm_substream_t *substream, int channel,
+				    snd_pcm_uframes_t pos, void __user *dst, snd_pcm_uframes_t count)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	snd_assert(pos + count <= RME9652_CHANNEL_BUFFER_BYTES / 4, return -EINVAL);
+
+	channel_buf = rme9652_channel_buffer_location (rme9652,
+						       substream->pstr->stream,
+						       channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	if (copy_to_user(dst, channel_buf + pos * 4, count * 4))
+		return -EFAULT;
+	return count;
+}
+
+static int snd_rme9652_hw_silence(snd_pcm_substream_t *substream, int channel,
+				  snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	channel_buf = rme9652_channel_buffer_location (rme9652,
+						       substream->pstr->stream,
+						       channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	memset(channel_buf + pos * 4, 0, count * 4);
+	return count;
+}
+
+static int snd_rme9652_reset(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	snd_pcm_substream_t *other;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		other = rme9652->capture_substream;
+	else
+		other = rme9652->playback_substream;
+	if (rme9652->running)
+		runtime->status->hw_ptr = rme9652_hw_pointer(rme9652);
+	else
+		runtime->status->hw_ptr = 0;
+	if (other) {
+		struct list_head *pos;
+		snd_pcm_substream_t *s;
+		snd_pcm_runtime_t *oruntime = other->runtime;
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == other) {
+				oruntime->status->hw_ptr = runtime->status->hw_ptr;
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+static int snd_rme9652_hw_params(snd_pcm_substream_t *substream,
+				 snd_pcm_hw_params_t *params)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	int err;
+	pid_t this_pid;
+	pid_t other_pid;
+
+	spin_lock_irq(&rme9652->lock);
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		rme9652->control_register &= ~(RME9652_PRO | RME9652_Dolby | RME9652_EMP);
+		rme9652_write(rme9652, RME9652_control_register, rme9652->control_register |= rme9652->creg_spdif_stream);
+		this_pid = rme9652->playback_pid;
+		other_pid = rme9652->capture_pid;
+	} else {
+		this_pid = rme9652->capture_pid;
+		other_pid = rme9652->playback_pid;
+	}
+
+	if ((other_pid > 0) && (this_pid != other_pid)) {
+
+		/* The other stream is open, and not by the same
+		   task as this one. Make sure that the parameters
+		   that matter are the same.
+		 */
+
+		if ((int)params_rate(params) !=
+		    rme9652_adat_sample_rate(rme9652)) {
+			spin_unlock_irq(&rme9652->lock);
+			_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);
+			return -EBUSY;
+		}
+
+		if (params_period_size(params) != rme9652->period_bytes / 4) {
+			spin_unlock_irq(&rme9652->lock);
+			_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+			return -EBUSY;
+		}
+
+		/* We're fine. */
+
+		spin_unlock_irq(&rme9652->lock);
+ 		return 0;
+
+	} else {
+		spin_unlock_irq(&rme9652->lock);
+	}
+
+	/* how to make sure that the rate matches an externally-set one ?
+	 */
+
+	if ((err = rme9652_set_rate(rme9652, params_rate(params))) < 0) {
+		_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);
+		return err;
+	}
+
+	if ((err = rme9652_set_interrupt_interval(rme9652, params_period_size(params))) < 0) {
+		_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+		return err;
+	}
+
+	return 0;
+}
+
+static int snd_rme9652_channel_info(snd_pcm_substream_t *substream,
+				    snd_pcm_channel_info_t *info)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	int chn;
+
+	snd_assert(info->channel < RME9652_NCHANNELS, return -EINVAL);
+
+	if ((chn = rme9652->channel_map[info->channel]) < 0) {
+		return -EINVAL;
+	}
+
+	info->offset = chn * RME9652_CHANNEL_BUFFER_BYTES;
+	info->first = 0;
+	info->step = 32;
+	return 0;
+}
+
+static int snd_rme9652_ioctl(snd_pcm_substream_t *substream,
+			     unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case SNDRV_PCM_IOCTL1_RESET:
+	{
+		return snd_rme9652_reset(substream);
+	}
+	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
+	{
+		snd_pcm_channel_info_t *info = arg;
+		return snd_rme9652_channel_info(substream, info);
+	}
+	default:
+		break;
+	}
+
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+static void rme9652_silence_playback(rme9652_t *rme9652)
+{
+	memset(rme9652->playback_buffer, 0, RME9652_DMA_AREA_BYTES);
+}
+
+static int snd_rme9652_trigger(snd_pcm_substream_t *substream,
+			       int cmd)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	snd_pcm_substream_t *other;
+	int running;
+	spin_lock(&rme9652->lock);
+	running = rme9652->running;
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		running |= 1 << substream->stream;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		running &= ~(1 << substream->stream);
+		break;
+	default:
+		snd_BUG();
+		spin_unlock(&rme9652->lock);
+		return -EINVAL;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		other = rme9652->capture_substream;
+	else
+		other = rme9652->playback_substream;
+
+	if (other) {
+		struct list_head *pos;
+		snd_pcm_substream_t *s;
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == other) {
+				snd_pcm_trigger_done(s, substream);
+				if (cmd == SNDRV_PCM_TRIGGER_START)
+					running |= 1 << s->stream;
+				else
+					running &= ~(1 << s->stream);
+				goto _ok;
+			}
+		}
+		if (cmd == SNDRV_PCM_TRIGGER_START) {
+			if (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) &&
+			    substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+				rme9652_silence_playback(rme9652);
+		} else {
+			if (running &&
+			    substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				rme9652_silence_playback(rme9652);
+		}
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) 
+			rme9652_silence_playback(rme9652);
+	}
+ _ok:
+	snd_pcm_trigger_done(substream, substream);
+	if (!rme9652->running && running)
+		rme9652_start(rme9652);
+	else if (rme9652->running && !running)
+		rme9652_stop(rme9652);
+	rme9652->running = running;
+	spin_unlock(&rme9652->lock);
+
+	return 0;
+}
+
+static int snd_rme9652_prepare(snd_pcm_substream_t *substream)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	unsigned long flags;
+	int result = 0;
+
+	spin_lock_irqsave(&rme9652->lock, flags);
+	if (!rme9652->running)
+		rme9652_reset_hw_pointer(rme9652);
+	spin_unlock_irqrestore(&rme9652->lock, flags);
+	return result;
+}
+
+static snd_pcm_hardware_t snd_rme9652_playback_subinfo =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_NONINTERLEAVED |
+				 SNDRV_PCM_INFO_SYNC_START |
+				 SNDRV_PCM_INFO_DOUBLE),
+	.formats =		SNDRV_PCM_FMTBIT_S32_LE,
+	.rates =		(SNDRV_PCM_RATE_44100 | 
+				 SNDRV_PCM_RATE_48000 | 
+				 SNDRV_PCM_RATE_88200 | 
+				 SNDRV_PCM_RATE_96000),
+	.rate_min =		44100,
+	.rate_max =		96000,
+	.channels_min =		10,
+	.channels_max =		26,
+	.buffer_bytes_max =	RME9652_CHANNEL_BUFFER_BYTES * 26,
+	.period_bytes_min =	(64 * 4) * 10,
+	.period_bytes_max =	(8192 * 4) * 26,
+	.periods_min =		2,
+	.periods_max =		2,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_rme9652_capture_subinfo =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_NONINTERLEAVED |
+				 SNDRV_PCM_INFO_SYNC_START),
+	.formats =		SNDRV_PCM_FMTBIT_S32_LE,
+	.rates =		(SNDRV_PCM_RATE_44100 | 
+				 SNDRV_PCM_RATE_48000 | 
+				 SNDRV_PCM_RATE_88200 | 
+				 SNDRV_PCM_RATE_96000),
+	.rate_min =		44100,
+	.rate_max =		96000,
+	.channels_min =		10,
+	.channels_max =		26,
+	.buffer_bytes_max =	RME9652_CHANNEL_BUFFER_BYTES *26,
+	.period_bytes_min =	(64 * 4) * 10,
+	.period_bytes_max =	(8192 * 4) * 26,
+	.periods_min =		2,
+	.periods_max =		2,
+	.fifo_size =		0,
+};
+
+static unsigned int period_sizes[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static snd_pcm_hw_constraint_list_t hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+static int snd_rme9652_hw_rule_channels(snd_pcm_hw_params_t *params,
+					snd_pcm_hw_rule_t *rule)
+{
+	rme9652_t *rme9652 = rule->private;
+	snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	unsigned int list[2] = { rme9652->ds_channels, rme9652->ss_channels };
+	return snd_interval_list(c, 2, list, 0);
+}
+
+static int snd_rme9652_hw_rule_channels_rate(snd_pcm_hw_params_t *params,
+					     snd_pcm_hw_rule_t *rule)
+{
+	rme9652_t *rme9652 = rule->private;
+	snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	snd_interval_t *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	if (r->min > 48000) {
+		snd_interval_t t = {
+			.min = rme9652->ds_channels,
+			.max = rme9652->ds_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	} else if (r->max < 88200) {
+		snd_interval_t t = {
+			.min = rme9652->ss_channels,
+			.max = rme9652->ss_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	}
+	return 0;
+}
+
+static int snd_rme9652_hw_rule_rate_channels(snd_pcm_hw_params_t *params,
+					     snd_pcm_hw_rule_t *rule)
+{
+	rme9652_t *rme9652 = rule->private;
+	snd_interval_t *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	snd_interval_t *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	if (c->min >= rme9652->ss_channels) {
+		snd_interval_t t = {
+			.min = 44100,
+			.max = 48000,
+			.integer = 1,
+		};
+		return snd_interval_refine(r, &t);
+	} else if (c->max <= rme9652->ds_channels) {
+		snd_interval_t t = {
+			.min = 88200,
+			.max = 96000,
+			.integer = 1,
+		};
+		return snd_interval_refine(r, &t);
+	}
+	return 0;
+}
+
+static int snd_rme9652_playback_open(snd_pcm_substream_t *substream)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	spin_lock_irq(&rme9652->lock);
+
+	snd_pcm_set_sync(substream);
+
+        runtime->hw = snd_rme9652_playback_subinfo;
+	runtime->dma_area = rme9652->playback_buffer;
+	runtime->dma_bytes = RME9652_DMA_AREA_BYTES;
+
+	if (rme9652->capture_substream == NULL) {
+		rme9652_stop(rme9652);
+		rme9652_set_thru(rme9652, -1, 0);
+	}
+
+	rme9652->playback_pid = current->pid;
+	rme9652->playback_substream = substream;
+
+	spin_unlock_irq(&rme9652->lock);
+
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_period_sizes);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			     snd_rme9652_hw_rule_channels, rme9652,
+			     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			     snd_rme9652_hw_rule_channels_rate, rme9652,
+			     SNDRV_PCM_HW_PARAM_RATE, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			     snd_rme9652_hw_rule_rate_channels, rme9652,
+			     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+
+	rme9652->creg_spdif_stream = rme9652->creg_spdif;
+	rme9652->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(rme9652->card, SNDRV_CTL_EVENT_MASK_VALUE |
+		       SNDRV_CTL_EVENT_MASK_INFO, &rme9652->spdif_ctl->id);
+	return 0;
+}
+
+static int snd_rme9652_playback_release(snd_pcm_substream_t *substream)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&rme9652->lock);
+
+	rme9652->playback_pid = -1;
+	rme9652->playback_substream = NULL;
+
+	spin_unlock_irq(&rme9652->lock);
+
+	rme9652->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(rme9652->card, SNDRV_CTL_EVENT_MASK_VALUE |
+		       SNDRV_CTL_EVENT_MASK_INFO, &rme9652->spdif_ctl->id);
+	return 0;
+}
+
+
+static int snd_rme9652_capture_open(snd_pcm_substream_t *substream)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	spin_lock_irq(&rme9652->lock);
+
+	snd_pcm_set_sync(substream);
+
+	runtime->hw = snd_rme9652_capture_subinfo;
+	runtime->dma_area = rme9652->capture_buffer;
+	runtime->dma_bytes = RME9652_DMA_AREA_BYTES;
+
+	if (rme9652->playback_substream == NULL) {
+		rme9652_stop(rme9652);
+		rme9652_set_thru(rme9652, -1, 0);
+	}
+
+	rme9652->capture_pid = current->pid;
+	rme9652->capture_substream = substream;
+
+	spin_unlock_irq(&rme9652->lock);
+
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_period_sizes);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			     snd_rme9652_hw_rule_channels, rme9652,
+			     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			     snd_rme9652_hw_rule_channels_rate, rme9652,
+			     SNDRV_PCM_HW_PARAM_RATE, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			     snd_rme9652_hw_rule_rate_channels, rme9652,
+			     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	return 0;
+}
+
+static int snd_rme9652_capture_release(snd_pcm_substream_t *substream)
+{
+	rme9652_t *rme9652 = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&rme9652->lock);
+
+	rme9652->capture_pid = -1;
+	rme9652->capture_substream = NULL;
+
+	spin_unlock_irq(&rme9652->lock);
+	return 0;
+}
+
+static snd_pcm_ops_t snd_rme9652_playback_ops = {
+	.open =		snd_rme9652_playback_open,
+	.close =	snd_rme9652_playback_release,
+	.ioctl =	snd_rme9652_ioctl,
+	.hw_params =	snd_rme9652_hw_params,
+	.prepare =	snd_rme9652_prepare,
+	.trigger =	snd_rme9652_trigger,
+	.pointer =	snd_rme9652_hw_pointer,
+	.copy =		snd_rme9652_playback_copy,
+	.silence =	snd_rme9652_hw_silence,
+};
+
+static snd_pcm_ops_t snd_rme9652_capture_ops = {
+	.open =		snd_rme9652_capture_open,
+	.close =	snd_rme9652_capture_release,
+	.ioctl =	snd_rme9652_ioctl,
+	.hw_params =	snd_rme9652_hw_params,
+	.prepare =	snd_rme9652_prepare,
+	.trigger =	snd_rme9652_trigger,
+	.pointer =	snd_rme9652_hw_pointer,
+	.copy =		snd_rme9652_capture_copy,
+};
+
+static int __devinit snd_rme9652_create_pcm(snd_card_t *card,
+					 rme9652_t *rme9652)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if ((err = snd_pcm_new(card,
+			       rme9652->card_name,
+			       0, 1, 1, &pcm)) < 0) {
+		return err;
+	}
+
+	rme9652->pcm = pcm;
+	pcm->private_data = rme9652;
+	strcpy(pcm->name, rme9652->card_name);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_rme9652_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_rme9652_capture_ops);
+
+	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
+
+	return 0;
+}
+
+static int __devinit snd_rme9652_create(snd_card_t *card,
+				     rme9652_t *rme9652,
+				     int precise_ptr)
+{
+	struct pci_dev *pci = rme9652->pci;
+	int err;
+	int status;
+	unsigned short rev;
+
+	rme9652->irq = -1;
+	rme9652->card = card;
+
+	pci_read_config_word(rme9652->pci, PCI_CLASS_REVISION, &rev);
+
+	switch (rev & 0xff) {
+	case 3:
+	case 4:
+	case 8:
+	case 9:
+		break;
+
+	default:
+		/* who knows? */
+		return -ENODEV;
+	}
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	spin_lock_init(&rme9652->lock);
+
+	if ((err = pci_request_regions(pci, "rme9652")) < 0)
+		return err;
+	rme9652->port = pci_resource_start(pci, 0);
+	rme9652->iobase = ioremap_nocache(rme9652->port, RME9652_IO_EXTENT);
+	if (rme9652->iobase == NULL) {
+		snd_printk("unable to remap region 0x%lx-0x%lx\n", rme9652->port, rme9652->port + RME9652_IO_EXTENT - 1);
+		return -EBUSY;
+	}
+	
+	if (request_irq(pci->irq, snd_rme9652_interrupt, SA_INTERRUPT|SA_SHIRQ, "rme9652", (void *)rme9652)) {
+		snd_printk("unable to request IRQ %d\n", pci->irq);
+		return -EBUSY;
+	}
+	rme9652->irq = pci->irq;
+	rme9652->precise_ptr = precise_ptr;
+
+	/* Determine the h/w rev level of the card. This seems like
+	   a particularly kludgy way to encode it, but its what RME
+	   chose to do, so we follow them ...
+	*/
+
+	status = rme9652_read(rme9652, RME9652_status_register);
+	if (rme9652_decode_spdif_rate(status&RME9652_F) == 1) {
+		rme9652->hw_rev = 15;
+	} else {
+		rme9652->hw_rev = 11;
+	}
+
+	/* Differentiate between the standard Hammerfall, and the
+	   "Light", which does not have the expansion board. This
+	   method comes from information received from Mathhias
+	   Clausen at RME. Display the EEPROM and h/w revID where
+	   relevant.  
+	*/
+
+	switch (rev) {
+	case 8: /* original eprom */
+		strcpy(card->driver, "RME9636");
+		if (rme9652->hw_rev == 15) {
+			rme9652->card_name = "RME Digi9636 (Rev 1.5)";
+		} else {
+			rme9652->card_name = "RME Digi9636";
+		}
+		rme9652->ss_channels = RME9636_NCHANNELS;
+		break;
+	case 9: /* W36_G EPROM */
+		strcpy(card->driver, "RME9636");
+		rme9652->card_name = "RME Digi9636 (Rev G)";
+		rme9652->ss_channels = RME9636_NCHANNELS;
+		break;
+	case 4: /* W52_G EPROM */
+		strcpy(card->driver, "RME9652");
+		rme9652->card_name = "RME Digi9652 (Rev G)";
+		rme9652->ss_channels = RME9652_NCHANNELS;
+		break;
+	case 3: /* original eprom */
+		strcpy(card->driver, "RME9652");
+		if (rme9652->hw_rev == 15) {
+			rme9652->card_name = "RME Digi9652 (Rev 1.5)";
+		} else {
+			rme9652->card_name = "RME Digi9652";
+		}
+		rme9652->ss_channels = RME9652_NCHANNELS;
+		break;
+	}
+
+	rme9652->ds_channels = (rme9652->ss_channels - 2) / 2 + 2;
+
+	pci_set_master(rme9652->pci);
+
+	if ((err = snd_rme9652_initialize_memory(rme9652)) < 0) {
+		return err;
+	}
+
+	if ((err = snd_rme9652_create_pcm(card, rme9652)) < 0) {
+		return err;
+	}
+
+	if ((err = snd_rme9652_create_controls(card, rme9652)) < 0) {
+		return err;
+	}
+
+	snd_rme9652_proc_init(rme9652);
+
+	rme9652->last_spdif_sample_rate = -1;
+	rme9652->last_adat_sample_rate = -1;
+	rme9652->playback_pid = -1;
+	rme9652->capture_pid = -1;
+	rme9652->capture_substream = NULL;
+	rme9652->playback_substream = NULL;
+
+	snd_rme9652_set_defaults(rme9652);
+
+	if (rme9652->hw_rev == 15) {
+		rme9652_initialize_spdif_receiver (rme9652);
+	}
+
+	return 0;
+}
+
+static void snd_rme9652_card_free(snd_card_t *card)
+{
+	rme9652_t *rme9652 = (rme9652_t *) card->private_data;
+
+	if (rme9652)
+		snd_rme9652_free(rme9652);
+}
+
+static int __devinit snd_rme9652_probe(struct pci_dev *pci,
+				       const struct pci_device_id *pci_id)
+{
+	static int dev;
+	rme9652_t *rme9652;
+	snd_card_t *card;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+			    sizeof(rme9652_t));
+
+	if (!card)
+		return -ENOMEM;
+
+	rme9652 = (rme9652_t *) card->private_data;
+	card->private_free = snd_rme9652_card_free;
+	rme9652->dev = dev;
+	rme9652->pci = pci;
+	snd_card_set_dev(card, &pci->dev);
+
+	if ((err = snd_rme9652_create(card, rme9652, precise_ptr[dev])) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->shortname, rme9652->card_name);
+
+	sprintf(card->longname, "%s at 0x%lx, irq %d",
+		card->shortname, rme9652->port, rme9652->irq);
+
+	
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_rme9652_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name	  = "RME Digi9652 (Hammerfall)",
+	.id_table = snd_rme9652_ids,
+	.probe	  = snd_rme9652_probe,
+	.remove	  = __devexit_p(snd_rme9652_remove),
+};
+
+static int __init alsa_card_hammerfall_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_hammerfall_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_hammerfall_init)
+module_exit(alsa_card_hammerfall_exit)
