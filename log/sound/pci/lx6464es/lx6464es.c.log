commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 7f6b1c6c2afe..b92ea074ff2a 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -938,7 +938,7 @@ static int snd_lx6464es_create(struct snd_card *card,
 	struct lx6464es *chip;
 	int err;
 
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = snd_lx6464es_dev_free,
 	};
 

commit 41094b243e621fb67b81a49bab53f5f7e699f429
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:48 2019 +0100

    ALSA: lx6464es: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the threaded
    interrupt handler.  Set card->sync_irq for enabling the missing
    sync_stop PCM operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-50-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 0ac078d1b27a..7f6b1c6c2afe 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1002,6 +1002,7 @@ static int snd_lx6464es_create(struct snd_card *card,
 		goto request_irq_failed;
 	}
 	chip->irq = pci->irq;
+	card->sync_irq = chip->irq;
 
 	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
 	if (err < 0)

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index a74d8eade3e2..0ac078d1b27a 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -791,7 +791,6 @@ static int lx_init_dsp(struct lx6464es *chip)
 static const struct snd_pcm_ops lx_ops_playback = {
 	.open      = lx_pcm_open,
 	.close     = lx_pcm_close,
-	.ioctl     = snd_pcm_lib_ioctl,
 	.prepare   = lx_pcm_prepare,
 	.hw_params = lx_pcm_hw_params_playback,
 	.hw_free   = lx_pcm_hw_free,
@@ -802,7 +801,6 @@ static const struct snd_pcm_ops lx_ops_playback = {
 static const struct snd_pcm_ops lx_ops_capture = {
 	.open      = lx_pcm_open,
 	.close     = lx_pcm_close,
-	.ioctl     = snd_pcm_lib_ioctl,
 	.prepare   = lx_pcm_prepare,
 	.hw_params = lx_pcm_hw_params_capture,
 	.hw_free   = lx_pcm_hw_free,

commit a747db239010bcabe48e3429556b782988a11797
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:17 2019 +0100

    ALSA: lx6464es: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The superfluous snd_pcm_lib_malloc_pages() and
    snd_pcm_lib_free_pages() calls are dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-46-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index d0f63fa54121..a74d8eade3e2 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -342,23 +342,18 @@ static int lx_pcm_hw_params(struct snd_pcm_substream *substream,
 			    struct snd_pcm_hw_params *hw_params, int is_capture)
 {
 	struct lx6464es *chip = snd_pcm_substream_chip(substream);
-	int err = 0;
 
 	dev_dbg(chip->card->dev, "->lx_pcm_hw_params\n");
 
 	mutex_lock(&chip->setup_mutex);
 
-	/* set dma buffer */
-	err = snd_pcm_lib_malloc_pages(substream,
-				       params_buffer_bytes(hw_params));
-
 	if (is_capture)
 		chip->capture_stream.stream = substream;
 	else
 		chip->playback_stream.stream = substream;
 
 	mutex_unlock(&chip->setup_mutex);
-	return err;
+	return 0;
 }
 
 static int lx_pcm_hw_params_playback(struct snd_pcm_substream *substream,
@@ -400,8 +395,6 @@ static int lx_pcm_hw_free(struct snd_pcm_substream *substream)
 		chip->hardware_running[is_capture] = 0;
 	}
 
-	err = snd_pcm_lib_free_pages(substream);
-
 	if (is_capture)
 		chip->capture_stream.stream = NULL;
 	else
@@ -845,9 +838,8 @@ static int lx_pcm_create(struct lx6464es *chip)
 	pcm->nonatomic = true;
 	strcpy(pcm->name, card_name);
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &chip->pci->dev,
-					      size, size);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &chip->pci->dev, size, size);
 
 	chip->pcm = pcm;
 	chip->capture_stream.is_capture = 1;

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index fe10714380f2..d0f63fa54121 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -846,7 +846,7 @@ static int lx_pcm_create(struct lx6464es *chip)
 	strcpy(pcm->name, card_name);
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(chip->pci),
+					      &chip->pci->dev,
 					      size, size);
 
 	chip->pcm = pcm;

commit 789492f0c86505e63369907bcb1afdf52dec9366
Author: Tim Blechmann <tim@klingt.org>
Date:   Fri Sep 6 16:21:19 2019 +0800

    ALSA: lx6464es - add support for LX6464ESe pci express variant
    
    The pci express variant of the digigram lx6464es card has a different
    device ID, but works without changes to the driver.
    Thanks to Nikolas Slottke for reporting and testing.
    
    Signed-off-by: Tim Blechmann <tim@klingt.org>
    Link: https://lore.kernel.org/r/20190906082119.40971-1-tim@klingt.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 583ca7384d83..fe10714380f2 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -49,6 +49,14 @@ static const struct pci_device_id snd_lx6464es_ids[] = {
 			 PCI_VENDOR_ID_DIGIGRAM,
 			 PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_CAE_SERIAL_SUBSYSTEM),
 	},			/* LX6464ES-CAE */
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES,
+			 PCI_VENDOR_ID_DIGIGRAM,
+			 PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ESE_SERIAL_SUBSYSTEM),
+	},			/* LX6464ESe */
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES,
+			 PCI_VENDOR_ID_DIGIGRAM,
+			 PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ESE_CAE_SERIAL_SUBSYSTEM),
+	},			/* LX6464ESe-CAE */
 	{ 0, },
 };
 

commit 7a3c2b69386102de9e78fa9ea679898f5502f77d
Author: Hariprasad Kelam <hariprasad.kelam@gmail.com>
Date:   Wed Jul 10 08:00:59 2019 +0530

    ALSA: lx6464es: Remove unneeded variable err
    
    This patch fixes below issue reported by coccicheck
    sound/pci/lx6464es/lx6464es.c:256:5-8: Unneeded variable: "err". Return
    "0" on line 258
    
    Signed-off-by: Hariprasad Kelam <hariprasad.kelam@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 1771a6dcbe18..583ca7384d83 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -253,9 +253,8 @@ static int lx_pcm_open(struct snd_pcm_substream *substream)
 
 static int lx_pcm_close(struct snd_pcm_substream *substream)
 {
-	int err = 0;
 	dev_dbg(substream->pcm->card->dev, "->lx_pcm_close\n");
-	return err;
+	return 0;
 }
 
 static snd_pcm_uframes_t lx_pcm_stream_pointer(struct snd_pcm_substream

commit 77f5075a43fb0395b03220d0a97a00129002da2c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:07:54 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 29
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program see the file copying if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 5 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170856.913346514@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index ae23a2dfbdea..1771a6dcbe18 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1,25 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* -*- linux-c -*- *
  *
  * ALSA driver for the digigram lx6464es interface
  *
  * Copyright (c) 2008, 2009 Tim Blechmann <tim@klingt.org>
- *
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- *
  */
 
 #include <linux/module.h>

commit 36e4617c01153757cde9e5fcd375a75a8f8425c3
Merge: 0b2338a9bf36 62e94da3e9d8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 8 14:12:15 2019 +0100

    Merge branch 'topic/memory-device-fixes-2' into for-next
    
    Pull further device memory allocation cleanups (but no API change yet).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 54f6252faca6..198ccf9b5eb3 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -948,13 +948,7 @@ static void lx_proc_levels_read(struct snd_info_entry *entry,
 
 static int lx_proc_create(struct snd_card *card, struct lx6464es *chip)
 {
-	struct snd_info_entry *entry;
-	int err = snd_card_proc_new(card, "levels", &entry);
-	if (err < 0)
-		return err;
-
-	snd_info_set_text_ops(entry, chip, lx_proc_levels_read);
-	return 0;
+	return snd_card_ro_proc_new(card, "levels", chip, lx_proc_levels_read);
 }
 
 

commit 5116b94af07a9775ed694562f354e931b2cc04d4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:32:09 2019 +0100

    ALSA: pci: Drop superfluous PCM preallocation error checks
    
    snd_pcm_lib_preallocate_pages() and co always succeed, so the error
    check is simply redundant.  Drop it.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 54f6252faca6..52ea0da1fe73 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -854,11 +854,9 @@ static int lx_pcm_create(struct lx6464es *chip)
 	pcm->nonatomic = true;
 	strcpy(pcm->name, card_name);
 
-	err = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-						    snd_dma_pci_data(chip->pci),
-						    size, size);
-	if (err < 0)
-		return err;
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(chip->pci),
+					      size, size);
 
 	chip->pcm = pcm;
 	chip->capture_stream.is_capture = 1;

commit f04684b4d85d6371126f476d3268ebf6a0bd57cf
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jun 21 11:07:21 2018 +0300

    ALSA: lx6464es: Missing error code in snd_lx6464es_create()
    
    We forgot to set the error code on this error path.
    
    Fixes: 4a23fc8cc068 ("ALSA: lx6464es: add error handling for pci_ioremap_bar")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 6c85f13ab23f..54f6252faca6 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1018,6 +1018,7 @@ static int snd_lx6464es_create(struct snd_card *card,
 	chip->port_dsp_bar = pci_ioremap_bar(pci, 2);
 	if (!chip->port_dsp_bar) {
 		dev_err(card->dev, "cannot remap PCI memory region\n");
+		err = -ENOMEM;
 		goto remap_pci_failed;
 	}
 

commit 4a23fc8cc068ee5adfb9939d86baaf0f3e180df6
Author: Zhouyang Jia <jiazhouyang09@gmail.com>
Date:   Thu Jun 14 21:51:46 2018 +0800

    ALSA: lx6464es: add error handling for pci_ioremap_bar
    
    When pci_ioremap_bar fails, the lack of error-handling code may
    cause unexpected results.
    
    This patch adds error-handling code after calling pci_ioremap_bar.
    
    Signed-off-by: Zhouyang Jia <jiazhouyang09@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 9655b08a1c52..6c85f13ab23f 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1016,6 +1016,10 @@ static int snd_lx6464es_create(struct snd_card *card,
 
 	/* dsp port */
 	chip->port_dsp_bar = pci_ioremap_bar(pci, 2);
+	if (!chip->port_dsp_bar) {
+		dev_err(card->dev, "cannot remap PCI memory region\n");
+		goto remap_pci_failed;
+	}
 
 	err = request_threaded_irq(pci->irq, lx_interrupt, lx_threaded_irq,
 				   IRQF_SHARED, KBUILD_MODNAME, chip);
@@ -1055,6 +1059,9 @@ static int snd_lx6464es_create(struct snd_card *card,
 	free_irq(pci->irq, chip);
 
 request_irq_failed:
+	iounmap(chip->port_dsp_bar);
+
+remap_pci_failed:
 	pci_release_regions(pci);
 
 request_regions_failed:

commit 033bb5676d5961371b8ec130ee9f9f9202ebd263
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:20 2017 +0530

    ALSA: lx6464es: make snd_pcm_hardware const
    
    Make this const as it is only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index f9c3e86d55d5..9655b08a1c52 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -77,7 +77,7 @@ MODULE_DEVICE_TABLE(pci, snd_lx6464es_ids);
 
 
 /* alsa callbacks */
-static struct snd_pcm_hardware lx_caps = {
+static const struct snd_pcm_hardware lx_caps = {
 	.info             = (SNDRV_PCM_INFO_MMAP |
 			     SNDRV_PCM_INFO_INTERLEAVED |
 			     SNDRV_PCM_INFO_MMAP_VALID |

commit f3b827e0b1841f4cfc18436e09f4f269f3be908e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Feb 20 00:18:09 2017 +0530

    ALSA: pci: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new structures as const as they are only passed as
    an argument to the function snd_ctl_new1. This argument is of type
    const, so snd_kcontrol_new structures having the same property can be
    made const too.
    Done using Coccinelle:
    
    @r1 disable optional_qualifier @
    identifier i;
    position p;
    @@
    static struct snd_kcontrol_new i@p = {...};
    
    @ok1@
    identifier r1.i;
    position p;
    expression e1;
    @@
    snd_ctl_new1(&i@p,e1)
    
    @bad@
    position p!={r1.p,ok1.p};
    identifier r1.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    +const
    struct snd_kcontrol_new i;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index c0f0c349c3ec..f9c3e86d55d5 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -899,7 +899,7 @@ static int lx_control_playback_put(struct snd_kcontrol *kcontrol,
 	return changed;
 }
 
-static struct snd_kcontrol_new lx_control_playback_switch = {
+static const struct snd_kcontrol_new lx_control_playback_switch = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PCM Playback Switch",
 	.index = 0,

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 8b8e2e54fba3..c0f0c349c3ec 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -804,7 +804,7 @@ static int lx_init_dsp(struct lx6464es *chip)
 	return err;
 }
 
-static struct snd_pcm_ops lx_ops_playback = {
+static const struct snd_pcm_ops lx_ops_playback = {
 	.open      = lx_pcm_open,
 	.close     = lx_pcm_close,
 	.ioctl     = snd_pcm_lib_ioctl,
@@ -815,7 +815,7 @@ static struct snd_pcm_ops lx_ops_playback = {
 	.pointer   = lx_pcm_stream_pointer,
 };
 
-static struct snd_pcm_ops lx_ops_capture = {
+static const struct snd_pcm_ops lx_ops_capture = {
 	.open      = lx_pcm_open,
 	.close     = lx_pcm_close,
 	.ioctl     = snd_pcm_lib_ioctl,

commit dfcdb0280b410e4f132c8e4ef2c3e5c9c4797965
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Oct 18 15:39:18 2015 +0200

    ALSA: lx6464es: Use snd_pcm_hw_constraint_single()
    
    Use the new snd_pcm_hw_constraint_single() helper function instead of
    calling snd_pcm_hw_constraint_minmax() with the same value for min and max
    to install a constraint that limits the possible configuration values to a
    single value. Using snd_pcm_hw_constraint_single() makes the indented
    result clearer.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index cba89beb2b38..8b8e2e54fba3 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -234,8 +234,8 @@ static int lx_pcm_open(struct snd_pcm_substream *substream)
 
 	/* the clock rate cannot be changed */
 	board_rate = chip->board_sample_rate;
-	err = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_RATE,
-					   board_rate, board_rate);
+	err = snd_pcm_hw_constraint_single(runtime, SNDRV_PCM_HW_PARAM_RATE,
+					   board_rate);
 
 	if (err < 0) {
 		dev_warn(chip->card->dev, "could not constrain periods\n");

commit e42e748efdb06568d78fb1a47ec66a6c2587412f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 26 12:56:21 2015 +0200

    ALSA: lx6464es: Use NULL for pointers
    
    Spotted by sparse:
      sound/pci/lx6464es/lx6464es.c:415:47: warning: Using plain integer as NULL pointer
      sound/pci/lx6464es/lx6464es.c:417:48: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 611b9a88784e..cba89beb2b38 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -412,9 +412,9 @@ static int lx_pcm_hw_free(struct snd_pcm_substream *substream)
 	err = snd_pcm_lib_free_pages(substream);
 
 	if (is_capture)
-		chip->capture_stream.stream = 0;
+		chip->capture_stream.stream = NULL;
 	else
-		chip->playback_stream.stream = 0;
+		chip->playback_stream.stream = NULL;
 
 exit:
 	mutex_unlock(&chip->setup_mutex);

commit 1983126f971cf5f58a4bfe393dc131b2191d4024
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 26 12:52:54 2015 +0200

    ALSA: lx6464es: Fix duplicated SSID entries
    
    PCI_DEVICE() macro itself defines SSID entries while we override them
    after that.  Replace with a more appropriate macro, PCI_DEVICE_SUB()
    to define all ID values properly.
    
    Spotted by sparse:
      sound/pci/lx6464es/lx6464es.c:60:11: warning: Initializer entry defined twice
      sound/pci/lx6464es/lx6464es.c:61:12:   also defined here
      sound/pci/lx6464es/lx6464es.c:64:11: warning: Initializer entry defined twice
      sound/pci/lx6464es/lx6464es.c:65:12:   also defined here
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 32c6f6ba1442..611b9a88784e 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -57,13 +57,13 @@ static const char card_name[] = "LX6464ES";
 #define PCI_DEVICE_ID_PLX_LX6464ES		PCI_DEVICE_ID_PLX_9056
 
 static const struct pci_device_id snd_lx6464es_ids[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES),
-	  .subvendor = PCI_VENDOR_ID_DIGIGRAM,
-	  .subdevice = PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_SERIAL_SUBSYSTEM
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES,
+			 PCI_VENDOR_ID_DIGIGRAM,
+			 PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_SERIAL_SUBSYSTEM),
 	},			/* LX6464ES */
-	{ PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES),
-	  .subvendor = PCI_VENDOR_ID_DIGIGRAM,
-	  .subdevice = PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_CAE_SERIAL_SUBSYSTEM
+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES,
+			 PCI_VENDOR_ID_DIGIGRAM,
+			 PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_CAE_SERIAL_SUBSYSTEM),
 	},			/* LX6464ES-CAE */
 	{ 0, },
 };

commit 412b979ccceff448dccea54bdb616c85781bc0ba
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Wed Apr 15 16:10:17 2015 +0200

    ALSA: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 601315a1f58f..32c6f6ba1442 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -981,7 +981,7 @@ static int snd_lx6464es_create(struct snd_card *card,
 	pci_set_master(pci);
 
 	/* check if we can restrict PCI DMA transfers to 32 bits */
-	err = pci_set_dma_mask(pci, DMA_BIT_MASK(32));
+	err = dma_set_mask(&pci->dev, DMA_BIT_MASK(32));
 	if (err < 0) {
 		dev_err(card->dev,
 			"architecture does not support 32bit PCI busmaster DMA\n");

commit 6336c20cdaee1dd13d01dfa8c07ce3b18bbc846f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 10 14:01:05 2014 +0200

    ALSA: lx6464es: Use nonatomic PCM ops
    
    Like the other previous changes, this patch for lx6464es takes the
    same strategy for converting to nonatomic PCM ops: replacing spinlock
    with mutex, converting the irq tasklet to the threaded irq, and
    merging the trigger tasklets back to the trigger callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index a671f0865f71..601315a1f58f 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -279,7 +279,6 @@ static snd_pcm_uframes_t lx_pcm_stream_pointer(struct snd_pcm_substream
 {
 	struct lx6464es *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_uframes_t pos;
-	unsigned long flags;
 	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
 
 	struct lx_stream *lx_stream = is_capture ? &chip->capture_stream :
@@ -287,9 +286,9 @@ static snd_pcm_uframes_t lx_pcm_stream_pointer(struct snd_pcm_substream
 
 	dev_dbg(chip->card->dev, "->lx_pcm_stream_pointer\n");
 
-	spin_lock_irqsave(&chip->lock, flags);
+	mutex_lock(&chip->lock);
 	pos = lx_stream->frame_pos * substream->runtime->period_size;
-	spin_unlock_irqrestore(&chip->lock, flags);
+	mutex_unlock(&chip->lock);
 
 	dev_dbg(chip->card->dev, "stream_pointer at %ld\n", pos);
 	return pos;
@@ -485,8 +484,8 @@ static void lx_trigger_stop(struct lx6464es *chip, struct lx_stream *lx_stream)
 
 }
 
-static void lx_trigger_tasklet_dispatch_stream(struct lx6464es *chip,
-					       struct lx_stream *lx_stream)
+static void lx_trigger_dispatch_stream(struct lx6464es *chip,
+				       struct lx_stream *lx_stream)
 {
 	switch (lx_stream->status) {
 	case LX_STREAM_STATUS_SCHEDULE_RUN:
@@ -502,24 +501,12 @@ static void lx_trigger_tasklet_dispatch_stream(struct lx6464es *chip,
 	}
 }
 
-static void lx_trigger_tasklet(unsigned long data)
-{
-	struct lx6464es *chip = (struct lx6464es *)data;
-	unsigned long flags;
-
-	dev_dbg(chip->card->dev, "->lx_trigger_tasklet\n");
-
-	spin_lock_irqsave(&chip->lock, flags);
-	lx_trigger_tasklet_dispatch_stream(chip, &chip->capture_stream);
-	lx_trigger_tasklet_dispatch_stream(chip, &chip->playback_stream);
-	spin_unlock_irqrestore(&chip->lock, flags);
-}
-
 static int lx_pcm_trigger_dispatch(struct lx6464es *chip,
 				   struct lx_stream *lx_stream, int cmd)
 {
 	int err = 0;
 
+	mutex_lock(&chip->lock);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		lx_stream->status = LX_STREAM_STATUS_SCHEDULE_RUN;
@@ -533,9 +520,12 @@ static int lx_pcm_trigger_dispatch(struct lx6464es *chip,
 		err = -EINVAL;
 		goto exit;
 	}
-	tasklet_schedule(&chip->trigger_tasklet);
+
+	lx_trigger_dispatch_stream(chip, &chip->capture_stream);
+	lx_trigger_dispatch_stream(chip, &chip->playback_stream);
 
 exit:
+	mutex_unlock(&chip->lock);
 	return err;
 }
 
@@ -861,6 +851,7 @@ static int lx_pcm_create(struct lx6464es *chip)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &lx_ops_capture);
 
 	pcm->info_flags = 0;
+	pcm->nonatomic = true;
 	strcpy(pcm->name, card_name);
 
 	err = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
@@ -1009,15 +1000,9 @@ static int snd_lx6464es_create(struct snd_card *card,
 	chip->irq = -1;
 
 	/* initialize synchronization structs */
-	spin_lock_init(&chip->lock);
-	spin_lock_init(&chip->msg_lock);
+	mutex_init(&chip->lock);
+	mutex_init(&chip->msg_lock);
 	mutex_init(&chip->setup_mutex);
-	tasklet_init(&chip->trigger_tasklet, lx_trigger_tasklet,
-		     (unsigned long)chip);
-	tasklet_init(&chip->tasklet_capture, lx_tasklet_capture,
-		     (unsigned long)chip);
-	tasklet_init(&chip->tasklet_playback, lx_tasklet_playback,
-		     (unsigned long)chip);
 
 	/* request resources */
 	err = pci_request_regions(pci, card_name);
@@ -1032,8 +1017,8 @@ static int snd_lx6464es_create(struct snd_card *card,
 	/* dsp port */
 	chip->port_dsp_bar = pci_ioremap_bar(pci, 2);
 
-	err = request_irq(pci->irq, lx_interrupt, IRQF_SHARED,
-			  KBUILD_MODNAME, chip);
+	err = request_threaded_irq(pci->irq, lx_interrupt, lx_threaded_irq,
+				   IRQF_SHARED, KBUILD_MODNAME, chip);
 	if (err) {
 		dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 		goto request_irq_failed;

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 27f60ce8a55c..a671f0865f71 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -56,7 +56,7 @@ static const char card_name[] = "LX6464ES";
 
 #define PCI_DEVICE_ID_PLX_LX6464ES		PCI_DEVICE_ID_PLX_9056
 
-static DEFINE_PCI_DEVICE_TABLE(snd_lx6464es_ids) = {
+static const struct pci_device_id snd_lx6464es_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES),
 	  .subvendor = PCI_VENDOR_ID_DIGIGRAM,
 	  .subdevice = PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_SERIAL_SUBSYSTEM

commit be4e6d3c0fa03d3978234feb6a2eefd95b93fa87
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 17:32:49 2014 +0100

    ALSA: lx6464es: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index b9743d4fa1cc..27f60ce8a55c 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -112,16 +112,16 @@ static int lx_hardware_open(struct lx6464es *chip,
 
 	snd_pcm_uframes_t period_size = runtime->period_size;
 
-	snd_printd(LXP "allocating pipe for %d channels\n", channels);
+	dev_dbg(chip->card->dev, "allocating pipe for %d channels\n", channels);
 	err = lx_pipe_allocate(chip, 0, is_capture, channels);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "allocating pipe failed\n");
+		dev_err(chip->card->dev, LXP "allocating pipe failed\n");
 		return err;
 	}
 
 	err = lx_set_granularity(chip, period_size);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "setting granularity to %ld failed\n",
+		dev_err(chip->card->dev, "setting granularity to %ld failed\n",
 			   period_size);
 		return err;
 	}
@@ -136,24 +136,24 @@ static int lx_hardware_start(struct lx6464es *chip,
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
 
-	snd_printd(LXP "setting stream format\n");
+	dev_dbg(chip->card->dev, "setting stream format\n");
 	err = lx_stream_set_format(chip, runtime, 0, is_capture);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "setting stream format failed\n");
+		dev_err(chip->card->dev, "setting stream format failed\n");
 		return err;
 	}
 
-	snd_printd(LXP "starting pipe\n");
+	dev_dbg(chip->card->dev, "starting pipe\n");
 	err = lx_pipe_start(chip, 0, is_capture);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "starting pipe failed\n");
+		dev_err(chip->card->dev, "starting pipe failed\n");
 		return err;
 	}
 
-	snd_printd(LXP "waiting for pipe to start\n");
+	dev_dbg(chip->card->dev, "waiting for pipe to start\n");
 	err = lx_pipe_wait_for_start(chip, 0, is_capture);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "waiting for pipe failed\n");
+		dev_err(chip->card->dev, "waiting for pipe failed\n");
 		return err;
 	}
 
@@ -167,24 +167,24 @@ static int lx_hardware_stop(struct lx6464es *chip,
 	int err = 0;
 	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
 
-	snd_printd(LXP "pausing pipe\n");
+	dev_dbg(chip->card->dev, "pausing pipe\n");
 	err = lx_pipe_pause(chip, 0, is_capture);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "pausing pipe failed\n");
+		dev_err(chip->card->dev, "pausing pipe failed\n");
 		return err;
 	}
 
-	snd_printd(LXP "waiting for pipe to become idle\n");
+	dev_dbg(chip->card->dev, "waiting for pipe to become idle\n");
 	err = lx_pipe_wait_for_idle(chip, 0, is_capture);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "waiting for pipe failed\n");
+		dev_err(chip->card->dev, "waiting for pipe failed\n");
 		return err;
 	}
 
-	snd_printd(LXP "stopping pipe\n");
+	dev_dbg(chip->card->dev, "stopping pipe\n");
 	err = lx_pipe_stop(chip, 0, is_capture);
 	if (err < 0) {
-		snd_printk(LXP "stopping pipe failed\n");
+		dev_err(chip->card->dev, "stopping pipe failed\n");
 		return err;
 	}
 
@@ -198,10 +198,10 @@ static int lx_hardware_close(struct lx6464es *chip,
 	int err = 0;
 	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
 
-	snd_printd(LXP "releasing pipe\n");
+	dev_dbg(chip->card->dev, "releasing pipe\n");
 	err = lx_pipe_release(chip, 0, is_capture);
 	if (err < 0) {
-		snd_printk(LXP "releasing pipe failed\n");
+		dev_err(chip->card->dev, "releasing pipe failed\n");
 		return err;
 	}
 
@@ -216,7 +216,7 @@ static int lx_pcm_open(struct snd_pcm_substream *substream)
 	int err = 0;
 	int board_rate;
 
-	snd_printdd("->lx_pcm_open\n");
+	dev_dbg(chip->card->dev, "->lx_pcm_open\n");
 	mutex_lock(&chip->setup_mutex);
 
 	/* copy the struct snd_pcm_hardware struct */
@@ -227,7 +227,7 @@ static int lx_pcm_open(struct snd_pcm_substream *substream)
 	err = snd_pcm_hw_constraint_integer(runtime,
 					    SNDRV_PCM_HW_PARAM_PERIODS);
 	if (err < 0) {
-		snd_printk(KERN_WARNING LXP "could not constrain periods\n");
+		dev_warn(chip->card->dev, "could not constrain periods\n");
 		goto exit;
 	}
 #endif
@@ -238,7 +238,7 @@ static int lx_pcm_open(struct snd_pcm_substream *substream)
 					   board_rate, board_rate);
 
 	if (err < 0) {
-		snd_printk(KERN_WARNING LXP "could not constrain periods\n");
+		dev_warn(chip->card->dev, "could not constrain periods\n");
 		goto exit;
 	}
 
@@ -248,7 +248,7 @@ static int lx_pcm_open(struct snd_pcm_substream *substream)
 					   MICROBLAZE_IBL_MIN,
 					   MICROBLAZE_IBL_MAX);
 	if (err < 0) {
-		snd_printk(KERN_WARNING LXP
+		dev_warn(chip->card->dev,
 			   "could not constrain period size\n");
 		goto exit;
 	}
@@ -263,14 +263,14 @@ static int lx_pcm_open(struct snd_pcm_substream *substream)
 	runtime->private_data = chip;
 
 	mutex_unlock(&chip->setup_mutex);
-	snd_printdd("<-lx_pcm_open, %d\n", err);
+	dev_dbg(chip->card->dev, "<-lx_pcm_open, %d\n", err);
 	return err;
 }
 
 static int lx_pcm_close(struct snd_pcm_substream *substream)
 {
 	int err = 0;
-	snd_printdd("->lx_pcm_close\n");
+	dev_dbg(substream->pcm->card->dev, "->lx_pcm_close\n");
 	return err;
 }
 
@@ -285,13 +285,13 @@ static snd_pcm_uframes_t lx_pcm_stream_pointer(struct snd_pcm_substream
 	struct lx_stream *lx_stream = is_capture ? &chip->capture_stream :
 		&chip->playback_stream;
 
-	snd_printdd("->lx_pcm_stream_pointer\n");
+	dev_dbg(chip->card->dev, "->lx_pcm_stream_pointer\n");
 
 	spin_lock_irqsave(&chip->lock, flags);
 	pos = lx_stream->frame_pos * substream->runtime->period_size;
 	spin_unlock_irqrestore(&chip->lock, flags);
 
-	snd_printdd(LXP "stream_pointer at %ld\n", pos);
+	dev_dbg(chip->card->dev, "stream_pointer at %ld\n", pos);
 	return pos;
 }
 
@@ -301,37 +301,37 @@ static int lx_pcm_prepare(struct snd_pcm_substream *substream)
 	int err = 0;
 	const int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
 
-	snd_printdd("->lx_pcm_prepare\n");
+	dev_dbg(chip->card->dev, "->lx_pcm_prepare\n");
 
 	mutex_lock(&chip->setup_mutex);
 
 	if (chip->hardware_running[is_capture]) {
 		err = lx_hardware_stop(chip, substream);
 		if (err < 0) {
-			snd_printk(KERN_ERR LXP "failed to stop hardware. "
+			dev_err(chip->card->dev, "failed to stop hardware. "
 				   "Error code %d\n", err);
 			goto exit;
 		}
 
 		err = lx_hardware_close(chip, substream);
 		if (err < 0) {
-			snd_printk(KERN_ERR LXP "failed to close hardware. "
+			dev_err(chip->card->dev, "failed to close hardware. "
 				   "Error code %d\n", err);
 			goto exit;
 		}
 	}
 
-	snd_printd(LXP "opening hardware\n");
+	dev_dbg(chip->card->dev, "opening hardware\n");
 	err = lx_hardware_open(chip, substream);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "failed to open hardware. "
+		dev_err(chip->card->dev, "failed to open hardware. "
 			   "Error code %d\n", err);
 		goto exit;
 	}
 
 	err = lx_hardware_start(chip, substream);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "failed to start hardware. "
+		dev_err(chip->card->dev, "failed to start hardware. "
 			   "Error code %d\n", err);
 		goto exit;
 	}
@@ -354,7 +354,7 @@ static int lx_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct lx6464es *chip = snd_pcm_substream_chip(substream);
 	int err = 0;
 
-	snd_printdd("->lx_pcm_hw_params\n");
+	dev_dbg(chip->card->dev, "->lx_pcm_hw_params\n");
 
 	mutex_lock(&chip->setup_mutex);
 
@@ -389,20 +389,20 @@ static int lx_pcm_hw_free(struct snd_pcm_substream *substream)
 	int err = 0;
 	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
 
-	snd_printdd("->lx_pcm_hw_free\n");
+	dev_dbg(chip->card->dev, "->lx_pcm_hw_free\n");
 	mutex_lock(&chip->setup_mutex);
 
 	if (chip->hardware_running[is_capture]) {
 		err = lx_hardware_stop(chip, substream);
 		if (err < 0) {
-			snd_printk(KERN_ERR LXP "failed to stop hardware. "
+			dev_err(chip->card->dev, "failed to stop hardware. "
 				   "Error code %d\n", err);
 			goto exit;
 		}
 
 		err = lx_hardware_close(chip, substream);
 		if (err < 0) {
-			snd_printk(KERN_ERR LXP "failed to close hardware. "
+			dev_err(chip->card->dev, "failed to close hardware. "
 				   "Error code %d\n", err);
 			goto exit;
 		}
@@ -446,25 +446,25 @@ static void lx_trigger_start(struct lx6464es *chip, struct lx_stream *lx_stream)
 
 		err = lx_buffer_ask(chip, 0, is_capture, &needed, &freed,
 				    size_array);
-		snd_printdd(LXP "starting: needed %d, freed %d\n",
+		dev_dbg(chip->card->dev, "starting: needed %d, freed %d\n",
 			    needed, freed);
 
 		err = lx_buffer_give(chip, 0, is_capture, period_bytes,
 				     lower_32_bits(buf), upper_32_bits(buf),
 				     &buffer_index);
 
-		snd_printdd(LXP "starting: buffer index %x on 0x%lx (%d bytes)\n",
+		dev_dbg(chip->card->dev, "starting: buffer index %x on 0x%lx (%d bytes)\n",
 			    buffer_index, (unsigned long)buf, period_bytes);
 		buf += period_bytes;
 	}
 
 	err = lx_buffer_ask(chip, 0, is_capture, &needed, &freed, size_array);
-	snd_printdd(LXP "starting: needed %d, freed %d\n", needed, freed);
+	dev_dbg(chip->card->dev, "starting: needed %d, freed %d\n", needed, freed);
 
-	snd_printd(LXP "starting: starting stream\n");
+	dev_dbg(chip->card->dev, "starting: starting stream\n");
 	err = lx_stream_start(chip, 0, is_capture);
 	if (err < 0)
-		snd_printk(KERN_ERR LXP "couldn't start stream\n");
+		dev_err(chip->card->dev, "couldn't start stream\n");
 	else
 		lx_stream->status = LX_STREAM_STATUS_RUNNING;
 
@@ -476,10 +476,10 @@ static void lx_trigger_stop(struct lx6464es *chip, struct lx_stream *lx_stream)
 	const unsigned int is_capture = lx_stream->is_capture;
 	int err;
 
-	snd_printd(LXP "stopping: stopping stream\n");
+	dev_dbg(chip->card->dev, "stopping: stopping stream\n");
 	err = lx_stream_stop(chip, 0, is_capture);
 	if (err < 0)
-		snd_printk(KERN_ERR LXP "couldn't stop stream\n");
+		dev_err(chip->card->dev, "couldn't stop stream\n");
 	else
 		lx_stream->status = LX_STREAM_STATUS_FREE;
 
@@ -507,7 +507,7 @@ static void lx_trigger_tasklet(unsigned long data)
 	struct lx6464es *chip = (struct lx6464es *)data;
 	unsigned long flags;
 
-	snd_printdd("->lx_trigger_tasklet\n");
+	dev_dbg(chip->card->dev, "->lx_trigger_tasklet\n");
 
 	spin_lock_irqsave(&chip->lock, flags);
 	lx_trigger_tasklet_dispatch_stream(chip, &chip->capture_stream);
@@ -547,14 +547,14 @@ static int lx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct lx_stream *stream = is_capture ? &chip->capture_stream :
 		&chip->playback_stream;
 
-	snd_printdd("->lx_pcm_trigger\n");
+	dev_dbg(chip->card->dev, "->lx_pcm_trigger\n");
 
 	return lx_pcm_trigger_dispatch(chip, stream, cmd);
 }
 
 static int snd_lx6464es_free(struct lx6464es *chip)
 {
-	snd_printdd("->snd_lx6464es_free\n");
+	dev_dbg(chip->card->dev, "->snd_lx6464es_free\n");
 
 	lx_irq_disable(chip);
 
@@ -583,7 +583,7 @@ static int lx_init_xilinx_reset(struct lx6464es *chip)
 	int i;
 	u32 plx_reg = lx_plx_reg_read(chip, ePLX_CHIPSC);
 
-	snd_printdd("->lx_init_xilinx_reset\n");
+	dev_dbg(chip->card->dev, "->lx_init_xilinx_reset\n");
 
 	/* activate reset of xilinx */
 	plx_reg &= ~CHIPSC_RESET_XILINX;
@@ -603,8 +603,8 @@ static int lx_init_xilinx_reset(struct lx6464es *chip)
 		msleep(10);
 		reg_mbox3 = lx_plx_reg_read(chip, ePLX_MBOX3);
 		if (reg_mbox3) {
-			snd_printd(LXP "xilinx reset done\n");
-			snd_printdd(LXP "xilinx took %d loops\n", i);
+			dev_dbg(chip->card->dev, "xilinx reset done\n");
+			dev_dbg(chip->card->dev, "xilinx took %d loops\n", i);
 			break;
 		}
 	}
@@ -624,7 +624,7 @@ static int lx_init_xilinx_test(struct lx6464es *chip)
 {
 	u32 reg;
 
-	snd_printdd("->lx_init_xilinx_test\n");
+	dev_dbg(chip->card->dev, "->lx_init_xilinx_test\n");
 
 	/* TEST if we have access to Xilinx/MicroBlaze */
 	lx_dsp_reg_write(chip, eReg_CSM, 0);
@@ -632,19 +632,19 @@ static int lx_init_xilinx_test(struct lx6464es *chip)
 	reg = lx_dsp_reg_read(chip, eReg_CSM);
 
 	if (reg) {
-		snd_printk(KERN_ERR LXP "Problem: Reg_CSM %x.\n", reg);
+		dev_err(chip->card->dev, "Problem: Reg_CSM %x.\n", reg);
 
 		/* PCI9056_SPACE0_REMAP */
 		lx_plx_reg_write(chip, ePLX_PCICR, 1);
 
 		reg = lx_dsp_reg_read(chip, eReg_CSM);
 		if (reg) {
-			snd_printk(KERN_ERR LXP "Error: Reg_CSM %x.\n", reg);
+			dev_err(chip->card->dev, "Error: Reg_CSM %x.\n", reg);
 			return -EAGAIN; /* seems to be appropriate */
 		}
 	}
 
-	snd_printd(LXP "Xilinx/MicroBlaze access test successful\n");
+	dev_dbg(chip->card->dev, "Xilinx/MicroBlaze access test successful\n");
 
 	return 0;
 }
@@ -661,7 +661,7 @@ static int lx_init_ethersound_config(struct lx6464es *chip)
 		(64 << IOCR_OUTPUTS_OFFSET) |
 		(FREQ_RATIO_SINGLE_MODE << FREQ_RATIO_OFFSET);
 
-	snd_printdd("->lx_init_ethersound\n");
+	dev_dbg(chip->card->dev, "->lx_init_ethersound\n");
 
 	chip->freq_ratio = FREQ_RATIO_SINGLE_MODE;
 
@@ -675,18 +675,18 @@ static int lx_init_ethersound_config(struct lx6464es *chip)
 
 	for (i = 0; i != 1000; ++i) {
 		if (lx_dsp_reg_read(chip, eReg_CSES) & 4) {
-			snd_printd(LXP "ethersound initialized after %dms\n",
+			dev_dbg(chip->card->dev, "ethersound initialized after %dms\n",
 				   i);
 			goto ethersound_initialized;
 		}
 		msleep(1);
 	}
-	snd_printk(KERN_WARNING LXP
+	dev_warn(chip->card->dev,
 		   "ethersound could not be initialized after %dms\n", i);
 	return -ETIMEDOUT;
 
  ethersound_initialized:
-	snd_printd(LXP "ethersound initialized\n");
+	dev_dbg(chip->card->dev, "ethersound initialized\n");
 	return 0;
 }
 
@@ -696,14 +696,14 @@ static int lx_init_get_version_features(struct lx6464es *chip)
 
 	int err;
 
-	snd_printdd("->lx_init_get_version_features\n");
+	dev_dbg(chip->card->dev, "->lx_init_get_version_features\n");
 
 	err = lx_dsp_get_version(chip, &dsp_version);
 
 	if (err == 0) {
 		u32 freq;
 
-		snd_printk(LXP "DSP version: V%02d.%02d #%d\n",
+		dev_info(chip->card->dev, "DSP version: V%02d.%02d #%d\n",
 			   (dsp_version>>16) & 0xff, (dsp_version>>8) & 0xff,
 			   dsp_version & 0xff);
 
@@ -718,9 +718,9 @@ static int lx_init_get_version_features(struct lx6464es *chip)
 		err = lx_dsp_get_clock_frequency(chip, &freq);
 		if (err == 0)
 			chip->board_sample_rate = freq;
-		snd_printd(LXP "actual clock frequency %d\n", freq);
+		dev_dbg(chip->card->dev, "actual clock frequency %d\n", freq);
 	} else {
-		snd_printk(KERN_ERR LXP "DSP corrupted \n");
+		dev_err(chip->card->dev, "DSP corrupted \n");
 		err = -EAGAIN;
 	}
 
@@ -732,7 +732,7 @@ static int lx_set_granularity(struct lx6464es *chip, u32 gran)
 	int err = 0;
 	u32 snapped_gran = MICROBLAZE_IBL_MIN;
 
-	snd_printdd("->lx_set_granularity\n");
+	dev_dbg(chip->card->dev, "->lx_set_granularity\n");
 
 	/* blocksize is a power of 2 */
 	while ((snapped_gran < gran) &&
@@ -745,14 +745,14 @@ static int lx_set_granularity(struct lx6464es *chip, u32 gran)
 
 	err = lx_dsp_set_granularity(chip, snapped_gran);
 	if (err < 0) {
-		snd_printk(KERN_WARNING LXP "could not set granularity\n");
+		dev_warn(chip->card->dev, "could not set granularity\n");
 		err = -EAGAIN;
 	}
 
 	if (snapped_gran != gran)
-		snd_printk(LXP "snapped blocksize to %d\n", snapped_gran);
+		dev_err(chip->card->dev, "snapped blocksize to %d\n", snapped_gran);
 
-	snd_printd(LXP "set blocksize on board %d\n", snapped_gran);
+	dev_dbg(chip->card->dev, "set blocksize on board %d\n", snapped_gran);
 	chip->pcm_granularity = snapped_gran;
 
 	return err;
@@ -764,19 +764,19 @@ static int lx_init_dsp(struct lx6464es *chip)
 	int err;
 	int i;
 
-	snd_printdd("->lx_init_dsp\n");
+	dev_dbg(chip->card->dev, "->lx_init_dsp\n");
 
-	snd_printd(LXP "initialize board\n");
+	dev_dbg(chip->card->dev, "initialize board\n");
 	err = lx_init_xilinx_reset(chip);
 	if (err)
 		return err;
 
-	snd_printd(LXP "testing board\n");
+	dev_dbg(chip->card->dev, "testing board\n");
 	err = lx_init_xilinx_test(chip);
 	if (err)
 		return err;
 
-	snd_printd(LXP "initialize ethersound configuration\n");
+	dev_dbg(chip->card->dev, "initialize ethersound configuration\n");
 	err = lx_init_ethersound_config(chip);
 	if (err)
 		return err;
@@ -797,8 +797,9 @@ static int lx_init_dsp(struct lx6464es *chip)
 	return -ETIMEDOUT;
 
 mac_ready:
-	snd_printd(LXP "mac address ready read after: %dms\n", i);
-	snd_printk(LXP "mac address: %02X.%02X.%02X.%02X.%02X.%02X\n",
+	dev_dbg(chip->card->dev, "mac address ready read after: %dms\n", i);
+	dev_info(chip->card->dev,
+		 "mac address: %02X.%02X.%02X.%02X.%02X.%02X\n",
 		   chip->mac_address[0], chip->mac_address[1], chip->mac_address[2],
 		   chip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);
 
@@ -977,7 +978,7 @@ static int snd_lx6464es_create(struct snd_card *card,
 		.dev_free = snd_lx6464es_dev_free,
 	};
 
-	snd_printdd("->snd_lx6464es_create\n");
+	dev_dbg(card->dev, "->snd_lx6464es_create\n");
 
 	*rchip = NULL;
 
@@ -991,8 +992,8 @@ static int snd_lx6464es_create(struct snd_card *card,
 	/* check if we can restrict PCI DMA transfers to 32 bits */
 	err = pci_set_dma_mask(pci, DMA_BIT_MASK(32));
 	if (err < 0) {
-		snd_printk(KERN_ERR "architecture does not support "
-			   "32bit PCI busmaster DMA\n");
+		dev_err(card->dev,
+			"architecture does not support 32bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}
@@ -1034,7 +1035,7 @@ static int snd_lx6464es_create(struct snd_card *card,
 	err = request_irq(pci->irq, lx_interrupt, IRQF_SHARED,
 			  KBUILD_MODNAME, chip);
 	if (err) {
-		snd_printk(KERN_ERR LXP "unable to grab IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 		goto request_irq_failed;
 	}
 	chip->irq = pci->irq;
@@ -1045,7 +1046,7 @@ static int snd_lx6464es_create(struct snd_card *card,
 
 	err = lx_init_dsp(chip);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "error during DSP initialization\n");
+		dev_err(card->dev, "error during DSP initialization\n");
 		return err;
 	}
 
@@ -1088,7 +1089,7 @@ static int snd_lx6464es_probe(struct pci_dev *pci,
 	struct lx6464es *chip;
 	int err;
 
-	snd_printdd("->snd_lx6464es_probe\n");
+	dev_dbg(&pci->dev, "->snd_lx6464es_probe\n");
 
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
@@ -1104,7 +1105,7 @@ static int snd_lx6464es_probe(struct pci_dev *pci,
 
 	err = snd_lx6464es_create(card, pci, &chip);
 	if (err < 0) {
-		snd_printk(KERN_ERR LXP "error during snd_lx6464es_create\n");
+		dev_err(card->dev, "error during snd_lx6464es_create\n");
 		goto out_free;
 	}
 
@@ -1124,7 +1125,7 @@ static int snd_lx6464es_probe(struct pci_dev *pci,
 	if (err < 0)
 		goto out_free;
 
-	snd_printdd(LXP "initialization successful\n");
+	dev_dbg(chip->card->dev, "initialization successful\n");
 	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 5fcaaa6da4a8..b9743d4fa1cc 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1062,8 +1062,6 @@ static int snd_lx6464es_create(struct snd_card *card,
 	if (err < 0)
 		return err;
 
-	snd_card_set_dev(card, &pci->dev);
-
 	*rchip = chip;
 	return 0;
 
@@ -1099,7 +1097,8 @@ static int snd_lx6464es_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 	if (err < 0)
 		return err;
 

commit 293db84270c2fc37f56030d09c43c7eb7939a7c3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 6 17:54:55 2013 +0100

    ALSA: lx6464es: Fix pointer cast compile warnings
    
    The warnings are really harmless but annoying.  Since they are only
    about debug prints, and it's at most 32bit DMA, let's just cast to
    unsigned long.
    
      sound/pci/lx6464es/lx6464es.c:457:22: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]
      sound/pci/lx6464es/lx_core.c:1195:21: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 3230e57f246c..5fcaaa6da4a8 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -453,8 +453,8 @@ static void lx_trigger_start(struct lx6464es *chip, struct lx_stream *lx_stream)
 				     lower_32_bits(buf), upper_32_bits(buf),
 				     &buffer_index);
 
-		snd_printdd(LXP "starting: buffer index %x on %p (%d bytes)\n",
-			    buffer_index, (void *)buf, period_bytes);
+		snd_printdd(LXP "starting: buffer index %x on 0x%lx (%d bytes)\n",
+			    buffer_index, (unsigned long)buf, period_bytes);
 		buf += period_bytes;
 	}
 

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 298bc9b72991..3230e57f246c 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1139,7 +1139,6 @@ static int snd_lx6464es_probe(struct pci_dev *pci,
 static void snd_lx6464es_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 5579b08bb35b..298bc9b72991 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -578,7 +578,7 @@ static int snd_lx6464es_dev_free(struct snd_device *device)
 }
 
 /* reset the dsp during initialization */
-static int __devinit lx_init_xilinx_reset(struct lx6464es *chip)
+static int lx_init_xilinx_reset(struct lx6464es *chip)
 {
 	int i;
 	u32 plx_reg = lx_plx_reg_read(chip, ePLX_CHIPSC);
@@ -620,7 +620,7 @@ static int __devinit lx_init_xilinx_reset(struct lx6464es *chip)
 	return 0;
 }
 
-static int __devinit lx_init_xilinx_test(struct lx6464es *chip)
+static int lx_init_xilinx_test(struct lx6464es *chip)
 {
 	u32 reg;
 
@@ -650,7 +650,7 @@ static int __devinit lx_init_xilinx_test(struct lx6464es *chip)
 }
 
 /* initialize ethersound */
-static int __devinit lx_init_ethersound_config(struct lx6464es *chip)
+static int lx_init_ethersound_config(struct lx6464es *chip)
 {
 	int i;
 	u32 orig_conf_es = lx_dsp_reg_read(chip, eReg_CONFES);
@@ -690,7 +690,7 @@ static int __devinit lx_init_ethersound_config(struct lx6464es *chip)
 	return 0;
 }
 
-static int __devinit lx_init_get_version_features(struct lx6464es *chip)
+static int lx_init_get_version_features(struct lx6464es *chip)
 {
 	u32 dsp_version;
 
@@ -759,7 +759,7 @@ static int lx_set_granularity(struct lx6464es *chip, u32 gran)
 }
 
 /* initialize and test the xilinx dsp chip */
-static int __devinit lx_init_dsp(struct lx6464es *chip)
+static int lx_init_dsp(struct lx6464es *chip)
 {
 	int err;
 	int i;
@@ -835,7 +835,7 @@ static struct snd_pcm_ops lx_ops_capture = {
 	.pointer   = lx_pcm_stream_pointer,
 };
 
-static int __devinit lx_pcm_create(struct lx6464es *chip)
+static int lx_pcm_create(struct lx6464es *chip)
 {
 	int err;
 	struct snd_pcm *pcm;
@@ -907,7 +907,7 @@ static int lx_control_playback_put(struct snd_kcontrol *kcontrol,
 	return changed;
 }
 
-static struct snd_kcontrol_new lx_control_playback_switch __devinitdata = {
+static struct snd_kcontrol_new lx_control_playback_switch = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PCM Playback Switch",
 	.index = 0,
@@ -954,7 +954,7 @@ static void lx_proc_levels_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "\n");
 }
 
-static int __devinit lx_proc_create(struct snd_card *card, struct lx6464es *chip)
+static int lx_proc_create(struct snd_card *card, struct lx6464es *chip)
 {
 	struct snd_info_entry *entry;
 	int err = snd_card_proc_new(card, "levels", &entry);
@@ -966,9 +966,9 @@ static int __devinit lx_proc_create(struct snd_card *card, struct lx6464es *chip
 }
 
 
-static int __devinit snd_lx6464es_create(struct snd_card *card,
-					 struct pci_dev *pci,
-					 struct lx6464es **rchip)
+static int snd_lx6464es_create(struct snd_card *card,
+			       struct pci_dev *pci,
+			       struct lx6464es **rchip)
 {
 	struct lx6464es *chip;
 	int err;
@@ -1082,8 +1082,8 @@ static int __devinit snd_lx6464es_create(struct snd_card *card,
 	return err;
 }
 
-static int __devinit snd_lx6464es_probe(struct pci_dev *pci,
-					const struct pci_device_id *pci_id)
+static int snd_lx6464es_probe(struct pci_dev *pci,
+			      const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_card *card;
@@ -1136,7 +1136,7 @@ static int __devinit snd_lx6464es_probe(struct pci_dev *pci,
 
 }
 
-static void __devexit snd_lx6464es_remove(struct pci_dev *pci)
+static void snd_lx6464es_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -1147,7 +1147,7 @@ static struct pci_driver lx6464es_driver = {
 	.name =     KBUILD_MODNAME,
 	.id_table = snd_lx6464es_ids,
 	.probe =    snd_lx6464es_probe,
-	.remove = __devexit_p(snd_lx6464es_remove),
+	.remove = snd_lx6464es_remove,
 };
 
 module_pci_driver(lx6464es_driver);

commit 3bdcff70b6cd049e6f4437b955850f5db83653cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 17:42:11 2012 +0200

    ALSA: lx6464es: Add a missing error check
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=44541
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index d1ab43706735..5579b08bb35b 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -851,6 +851,8 @@ static int __devinit lx_pcm_create(struct lx6464es *chip)
 	/* hardcoded device name & channel count */
 	err = snd_pcm_new(chip->card, (char *)card_name, 0,
 			  1, 1, &pcm);
+	if (err < 0)
+		return err;
 
 	pcm->private_data = chip;
 

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index d94c0c292bd0..d1ab43706735 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1141,24 +1141,11 @@ static void __devexit snd_lx6464es_remove(struct pci_dev *pci)
 }
 
 
-static struct pci_driver driver = {
+static struct pci_driver lx6464es_driver = {
 	.name =     KBUILD_MODNAME,
 	.id_table = snd_lx6464es_ids,
 	.probe =    snd_lx6464es_probe,
 	.remove = __devexit_p(snd_lx6464es_remove),
 };
 
-
-/* module initialization */
-static int __init mod_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit mod_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(mod_init);
-module_exit(mod_exit);
+module_pci_driver(lx6464es_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 04ae84b2a107..d94c0c292bd0 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -42,7 +42,7 @@ MODULE_SUPPORTED_DEVICE("{digigram lx6464es{}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for Digigram LX6464ES interface.");

commit 80b52490cdbfec7ea93d1158f13f0e49a1557423
Author: Tim Blechmann <tim@klingt.org>
Date:   Fri Jun 24 17:36:20 2011 +0200

    ALSA: lx6464es - include mac address in device name
    
    each device has a unique mac address, which can be used to distinguish
    multiple devices in the same machine. we therefore include the full mac
    address in the device shortname and the last 6 bytes in the device id.
    
    Signed-off-by: Tim Blechmann <tim@klingt.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 38ae83951de0..04ae84b2a107 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -762,7 +762,6 @@ static int lx_set_granularity(struct lx6464es *chip, u32 gran)
 static int __devinit lx_init_dsp(struct lx6464es *chip)
 {
 	int err;
-	u8 mac_address[6];
 	int i;
 
 	snd_printdd("->lx_init_dsp\n");
@@ -787,11 +786,11 @@ static int __devinit lx_init_dsp(struct lx6464es *chip)
 	/** \todo the mac address should be ready by not, but it isn't,
 	 *  so we wait for it */
 	for (i = 0; i != 1000; ++i) {
-		err = lx_dsp_get_mac(chip, mac_address);
+		err = lx_dsp_get_mac(chip);
 		if (err)
 			return err;
-		if (mac_address[0] || mac_address[1] || mac_address[2] ||
-		    mac_address[3] || mac_address[4] || mac_address[5])
+		if (chip->mac_address[0] || chip->mac_address[1] || chip->mac_address[2] ||
+		    chip->mac_address[3] || chip->mac_address[4] || chip->mac_address[5])
 			goto mac_ready;
 		msleep(1);
 	}
@@ -800,8 +799,8 @@ static int __devinit lx_init_dsp(struct lx6464es *chip)
 mac_ready:
 	snd_printd(LXP "mac address ready read after: %dms\n", i);
 	snd_printk(LXP "mac address: %02X.%02X.%02X.%02X.%02X.%02X\n",
-		   mac_address[0], mac_address[1], mac_address[2],
-		   mac_address[3], mac_address[4], mac_address[5]);
+		   chip->mac_address[0], chip->mac_address[1], chip->mac_address[2],
+		   chip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);
 
 	err = lx_init_get_version_features(chip);
 	if (err)
@@ -1108,8 +1107,14 @@ static int __devinit snd_lx6464es_probe(struct pci_dev *pci,
 		goto out_free;
 	}
 
-	strcpy(card->driver, "lx6464es");
-	strcpy(card->shortname, "Digigram LX6464ES");
+	strcpy(card->driver, "LX6464ES");
+	sprintf(card->id, "LX6464ES_%02X%02X%02X",
+		chip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);
+
+	sprintf(card->shortname, "LX6464ES %02X.%02X.%02X.%02X.%02X.%02X",
+		chip->mac_address[0], chip->mac_address[1], chip->mac_address[2],
+		chip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);
+
 	sprintf(card->longname, "%s at 0x%lx, 0x%p, irq %i",
 		card->shortname, chip->port_plx,
 		chip->port_dsp_bar, chip->irq);

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index b0bd3c53e876..38ae83951de0 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1031,7 +1031,7 @@ static int __devinit snd_lx6464es_create(struct snd_card *card,
 	chip->port_dsp_bar = pci_ioremap_bar(pci, 2);
 
 	err = request_irq(pci->irq, lx_interrupt, IRQF_SHARED,
-			  card_name, chip);
+			  KBUILD_MODNAME, chip);
 	if (err) {
 		snd_printk(KERN_ERR LXP "unable to grab IRQ %d\n", pci->irq);
 		goto request_irq_failed;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 1bd7a540fd49..b0bd3c53e876 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1137,7 +1137,7 @@ static void __devexit snd_lx6464es_remove(struct pci_dev *pci)
 
 
 static struct pci_driver driver = {
-	.name =     "Digigram LX6464ES",
+	.name =     KBUILD_MODNAME,
 	.id_table = snd_lx6464es_ids,
 	.probe =    snd_lx6464es_probe,
 	.remove = __devexit_p(snd_lx6464es_remove),

commit f7467452291f7c9e5e1271e8c8e45b77f34b1257
Author: Tim Blechmann <tim@klingt.org>
Date:   Sun Oct 31 19:46:19 2010 +0100

    ALSA: lx6464es - make 1 bit signed bitfield unsigned
    
    converts a 1 bit signed bitfield to an unsigned.
    
    Reported-by: Dr. David Alan Gilbert <linux@treblig.org>
    Signed-off-by: Tim Blechmann <tim@klingt.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index ef9af3f4ace2..1bd7a540fd49 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -425,7 +425,7 @@ static int lx_pcm_hw_free(struct snd_pcm_substream *substream)
 static void lx_trigger_start(struct lx6464es *chip, struct lx_stream *lx_stream)
 {
 	struct snd_pcm_substream *substream = lx_stream->stream;
-	const int is_capture = lx_stream->is_capture;
+	const unsigned int is_capture = lx_stream->is_capture;
 
 	int err;
 
@@ -473,7 +473,7 @@ static void lx_trigger_start(struct lx6464es *chip, struct lx_stream *lx_stream)
 
 static void lx_trigger_stop(struct lx6464es *chip, struct lx_stream *lx_stream)
 {
-	const int is_capture = lx_stream->is_capture;
+	const unsigned int is_capture = lx_stream->is_capture;
 	int err;
 
 	snd_printd(LXP "stopping: stopping stream\n");

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 0cca56038cd9..ef9af3f4ace2 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -26,6 +26,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
+#include <linux/slab.h>
 
 #include <sound/initval.h>
 #include <sound/control.h>

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 11b8c6514b3d..0cca56038cd9 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -55,7 +55,7 @@ static const char card_name[] = "LX6464ES";
 
 #define PCI_DEVICE_ID_PLX_LX6464ES		PCI_DEVICE_ID_PLX_9056
 
-static struct pci_device_id snd_lx6464es_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_lx6464es_ids) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES),
 	  .subvendor = PCI_VENDOR_ID_DIGIGRAM,
 	  .subdevice = PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_SERIAL_SUBSYSTEM

commit 7e895cfaad51c862932ea7db0c428761076412e5
Author: Tim Blechmann <tim@klingt.org>
Date:   Thu Jun 25 09:41:46 2009 +0200

    ALSA: lx6464es - configure ethersound io channels
    
    as long as the io channel number is not set by the driver, the card
    is not visible from the ethersound network
    
    Signed-off-by: Tim Blechmann <tim@klingt.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 18da2ef04d09..11b8c6514b3d 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -654,13 +654,12 @@ static int __devinit lx_init_ethersound_config(struct lx6464es *chip)
 	int i;
 	u32 orig_conf_es = lx_dsp_reg_read(chip, eReg_CONFES);
 
-	u32 default_conf_es = (64 << IOCR_OUTPUTS_OFFSET) |
+	/* configure 64 io channels */
+	u32 conf_es = (orig_conf_es & CONFES_READ_PART_MASK) |
 		(64 << IOCR_INPUTS_OFFSET) |
+		(64 << IOCR_OUTPUTS_OFFSET) |
 		(FREQ_RATIO_SINGLE_MODE << FREQ_RATIO_OFFSET);
 
-	u32 conf_es = (orig_conf_es & CONFES_READ_PART_MASK)
-		| (default_conf_es & CONFES_WRITE_PART_MASK);
-
 	snd_printdd("->lx_init_ethersound\n");
 
 	chip->freq_ratio = FREQ_RATIO_SINGLE_MODE;

commit 8e20ce94ce378334dea83a83ab26253b851100a2
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Jun 18 16:49:17 2009 -0700

    convert some DMA_nnBIT_MASK() callers
    
    We're about to make DMA_nnBIT_MASK() emit `deprecated' warnings.  Convert the
    remaining stragglers which are visible to the x86_64 build.
    
    Cc: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Eric Moore <Eric.Moore@lsil.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Alexander Duyck <alexander.h.duyck@intel.com>
    Cc: Yi Zou <yi.zou@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index ccf1b38c88ea..18da2ef04d09 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -988,7 +988,7 @@ static int __devinit snd_lx6464es_create(struct snd_card *card,
 	pci_set_master(pci);
 
 	/* check if we can restrict PCI DMA transfers to 32 bits */
-	err = pci_set_dma_mask(pci, DMA_32BIT_MASK);
+	err = pci_set_dma_mask(pci, DMA_BIT_MASK(32));
 	if (err < 0) {
 		snd_printk(KERN_ERR "architecture does not support "
 			   "32bit PCI busmaster DMA\n");

commit de0525ca34aa7a65faf6902e3e00956ab80d2ede
Author: Tim Blechmann <tim@klingt.org>
Date:   Thu Jun 11 16:03:34 2009 +0200

    ALSA: lx6464es - support standard alsa module parameters
    
    trivial patch to support the alsa module parameters `index', `id'
    and `enable'
    
    Signed-off-by: Tim Blechmann <tim@klingt.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 870bfc58c697..ccf1b38c88ea 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -43,6 +43,13 @@ static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
 
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for Digigram LX6464ES interface.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for  Digigram LX6464ES interface.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable/disable specific Digigram LX6464ES soundcards.");
+
 static const char card_name[] = "LX6464ES";
 
 

commit 7852fd08fdc78bf43150137bdbfdfdccdefffe0f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 14 12:25:52 2009 +0200

    ALSA: lx6464es - Use snd_card_create()
    
    Use snd_card_create() instead of the obsoleted snd_card_new().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index 7bc8b8caa992..870bfc58c697 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1091,9 +1091,9 @@ static int __devinit snd_lx6464es_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 
 	err = snd_lx6464es_create(card, pci, &chip);
 	if (err < 0) {

commit 02bec490450836ebbd628e97ec03f10b57def8ce
Author: Tim Blechmann <tim@klingt.org>
Date:   Tue Mar 24 12:24:35 2009 +0100

    ALSA: lx6464es - driver for the digigram lx6464es interface
    
    prototype of a driver for the digigram lx6464es 64 channel ethersound
    interface.
    
    Signed-off-by: Tim Blechmann <tim@klingt.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
new file mode 100644
index 000000000000..7bc8b8caa992
--- /dev/null
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -0,0 +1,1152 @@
+/* -*- linux-c -*- *
+ *
+ * ALSA driver for the digigram lx6464es interface
+ *
+ * Copyright (c) 2008, 2009 Tim Blechmann <tim@klingt.org>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <sound/initval.h>
+#include <sound/control.h>
+#include <sound/info.h>
+
+#include "lx6464es.h"
+
+MODULE_AUTHOR("Tim Blechmann");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("digigram lx6464es");
+MODULE_SUPPORTED_DEVICE("{digigram lx6464es{}}");
+
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+static const char card_name[] = "LX6464ES";
+
+
+#define PCI_DEVICE_ID_PLX_LX6464ES		PCI_DEVICE_ID_PLX_9056
+
+static struct pci_device_id snd_lx6464es_ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES),
+	  .subvendor = PCI_VENDOR_ID_DIGIGRAM,
+	  .subdevice = PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_SERIAL_SUBSYSTEM
+	},			/* LX6464ES */
+	{ PCI_DEVICE(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_LX6464ES),
+	  .subvendor = PCI_VENDOR_ID_DIGIGRAM,
+	  .subdevice = PCI_SUBDEVICE_ID_DIGIGRAM_LX6464ES_CAE_SERIAL_SUBSYSTEM
+	},			/* LX6464ES-CAE */
+	{ 0, },
+};
+
+MODULE_DEVICE_TABLE(pci, snd_lx6464es_ids);
+
+
+
+/* PGO pour USERo dans le registre pci_0x06/loc_0xEC */
+#define CHIPSC_RESET_XILINX (1L<<16)
+
+
+/* alsa callbacks */
+static struct snd_pcm_hardware lx_caps = {
+	.info             = (SNDRV_PCM_INFO_MMAP |
+			     SNDRV_PCM_INFO_INTERLEAVED |
+			     SNDRV_PCM_INFO_MMAP_VALID |
+			     SNDRV_PCM_INFO_SYNC_START),
+	.formats	  = (SNDRV_PCM_FMTBIT_S16_LE |
+			     SNDRV_PCM_FMTBIT_S16_BE |
+			     SNDRV_PCM_FMTBIT_S24_3LE |
+			     SNDRV_PCM_FMTBIT_S24_3BE),
+	.rates            = (SNDRV_PCM_RATE_CONTINUOUS |
+			     SNDRV_PCM_RATE_8000_192000),
+	.rate_min         = 8000,
+	.rate_max         = 192000,
+	.channels_min     = 2,
+	.channels_max     = 64,
+	.buffer_bytes_max = 64*2*3*MICROBLAZE_IBL_MAX*MAX_STREAM_BUFFER,
+	.period_bytes_min = (2*2*MICROBLAZE_IBL_MIN*2),
+	.period_bytes_max = (4*64*MICROBLAZE_IBL_MAX*MAX_STREAM_BUFFER),
+	.periods_min      = 2,
+	.periods_max      = MAX_STREAM_BUFFER,
+};
+
+static int lx_set_granularity(struct lx6464es *chip, u32 gran);
+
+
+static int lx_hardware_open(struct lx6464es *chip,
+			    struct snd_pcm_substream *substream)
+{
+	int err = 0;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int channels = runtime->channels;
+	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
+
+	snd_pcm_uframes_t period_size = runtime->period_size;
+
+	snd_printd(LXP "allocating pipe for %d channels\n", channels);
+	err = lx_pipe_allocate(chip, 0, is_capture, channels);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "allocating pipe failed\n");
+		return err;
+	}
+
+	err = lx_set_granularity(chip, period_size);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "setting granularity to %ld failed\n",
+			   period_size);
+		return err;
+	}
+
+	return 0;
+}
+
+static int lx_hardware_start(struct lx6464es *chip,
+			     struct snd_pcm_substream *substream)
+{
+	int err = 0;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
+
+	snd_printd(LXP "setting stream format\n");
+	err = lx_stream_set_format(chip, runtime, 0, is_capture);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "setting stream format failed\n");
+		return err;
+	}
+
+	snd_printd(LXP "starting pipe\n");
+	err = lx_pipe_start(chip, 0, is_capture);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "starting pipe failed\n");
+		return err;
+	}
+
+	snd_printd(LXP "waiting for pipe to start\n");
+	err = lx_pipe_wait_for_start(chip, 0, is_capture);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "waiting for pipe failed\n");
+		return err;
+	}
+
+	return err;
+}
+
+
+static int lx_hardware_stop(struct lx6464es *chip,
+			    struct snd_pcm_substream *substream)
+{
+	int err = 0;
+	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
+
+	snd_printd(LXP "pausing pipe\n");
+	err = lx_pipe_pause(chip, 0, is_capture);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "pausing pipe failed\n");
+		return err;
+	}
+
+	snd_printd(LXP "waiting for pipe to become idle\n");
+	err = lx_pipe_wait_for_idle(chip, 0, is_capture);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "waiting for pipe failed\n");
+		return err;
+	}
+
+	snd_printd(LXP "stopping pipe\n");
+	err = lx_pipe_stop(chip, 0, is_capture);
+	if (err < 0) {
+		snd_printk(LXP "stopping pipe failed\n");
+		return err;
+	}
+
+	return err;
+}
+
+
+static int lx_hardware_close(struct lx6464es *chip,
+			     struct snd_pcm_substream *substream)
+{
+	int err = 0;
+	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
+
+	snd_printd(LXP "releasing pipe\n");
+	err = lx_pipe_release(chip, 0, is_capture);
+	if (err < 0) {
+		snd_printk(LXP "releasing pipe failed\n");
+		return err;
+	}
+
+	return err;
+}
+
+
+static int lx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct lx6464es *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err = 0;
+	int board_rate;
+
+	snd_printdd("->lx_pcm_open\n");
+	mutex_lock(&chip->setup_mutex);
+
+	/* copy the struct snd_pcm_hardware struct */
+	runtime->hw = lx_caps;
+
+#if 0
+	/* buffer-size should better be multiple of period-size */
+	err = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (err < 0) {
+		snd_printk(KERN_WARNING LXP "could not constrain periods\n");
+		goto exit;
+	}
+#endif
+
+	/* the clock rate cannot be changed */
+	board_rate = chip->board_sample_rate;
+	err = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_RATE,
+					   board_rate, board_rate);
+
+	if (err < 0) {
+		snd_printk(KERN_WARNING LXP "could not constrain periods\n");
+		goto exit;
+	}
+
+	/* constrain period size */
+	err = snd_pcm_hw_constraint_minmax(runtime,
+					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+					   MICROBLAZE_IBL_MIN,
+					   MICROBLAZE_IBL_MAX);
+	if (err < 0) {
+		snd_printk(KERN_WARNING LXP
+			   "could not constrain period size\n");
+		goto exit;
+	}
+
+	snd_pcm_hw_constraint_step(runtime, 0,
+				   SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 32);
+
+	snd_pcm_set_sync(substream);
+	err = 0;
+
+exit:
+	runtime->private_data = chip;
+
+	mutex_unlock(&chip->setup_mutex);
+	snd_printdd("<-lx_pcm_open, %d\n", err);
+	return err;
+}
+
+static int lx_pcm_close(struct snd_pcm_substream *substream)
+{
+	int err = 0;
+	snd_printdd("->lx_pcm_close\n");
+	return err;
+}
+
+static snd_pcm_uframes_t lx_pcm_stream_pointer(struct snd_pcm_substream
+					       *substream)
+{
+	struct lx6464es *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_uframes_t pos;
+	unsigned long flags;
+	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
+
+	struct lx_stream *lx_stream = is_capture ? &chip->capture_stream :
+		&chip->playback_stream;
+
+	snd_printdd("->lx_pcm_stream_pointer\n");
+
+	spin_lock_irqsave(&chip->lock, flags);
+	pos = lx_stream->frame_pos * substream->runtime->period_size;
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	snd_printdd(LXP "stream_pointer at %ld\n", pos);
+	return pos;
+}
+
+static int lx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct lx6464es *chip = snd_pcm_substream_chip(substream);
+	int err = 0;
+	const int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
+
+	snd_printdd("->lx_pcm_prepare\n");
+
+	mutex_lock(&chip->setup_mutex);
+
+	if (chip->hardware_running[is_capture]) {
+		err = lx_hardware_stop(chip, substream);
+		if (err < 0) {
+			snd_printk(KERN_ERR LXP "failed to stop hardware. "
+				   "Error code %d\n", err);
+			goto exit;
+		}
+
+		err = lx_hardware_close(chip, substream);
+		if (err < 0) {
+			snd_printk(KERN_ERR LXP "failed to close hardware. "
+				   "Error code %d\n", err);
+			goto exit;
+		}
+	}
+
+	snd_printd(LXP "opening hardware\n");
+	err = lx_hardware_open(chip, substream);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "failed to open hardware. "
+			   "Error code %d\n", err);
+		goto exit;
+	}
+
+	err = lx_hardware_start(chip, substream);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "failed to start hardware. "
+			   "Error code %d\n", err);
+		goto exit;
+	}
+
+	chip->hardware_running[is_capture] = 1;
+
+	if (chip->board_sample_rate != substream->runtime->rate) {
+		if (!err)
+			chip->board_sample_rate = substream->runtime->rate;
+	}
+
+exit:
+	mutex_unlock(&chip->setup_mutex);
+	return err;
+}
+
+static int lx_pcm_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *hw_params, int is_capture)
+{
+	struct lx6464es *chip = snd_pcm_substream_chip(substream);
+	int err = 0;
+
+	snd_printdd("->lx_pcm_hw_params\n");
+
+	mutex_lock(&chip->setup_mutex);
+
+	/* set dma buffer */
+	err = snd_pcm_lib_malloc_pages(substream,
+				       params_buffer_bytes(hw_params));
+
+	if (is_capture)
+		chip->capture_stream.stream = substream;
+	else
+		chip->playback_stream.stream = substream;
+
+	mutex_unlock(&chip->setup_mutex);
+	return err;
+}
+
+static int lx_pcm_hw_params_playback(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *hw_params)
+{
+	return lx_pcm_hw_params(substream, hw_params, 0);
+}
+
+static int lx_pcm_hw_params_capture(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *hw_params)
+{
+	return lx_pcm_hw_params(substream, hw_params, 1);
+}
+
+static int lx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct lx6464es *chip = snd_pcm_substream_chip(substream);
+	int err = 0;
+	int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
+
+	snd_printdd("->lx_pcm_hw_free\n");
+	mutex_lock(&chip->setup_mutex);
+
+	if (chip->hardware_running[is_capture]) {
+		err = lx_hardware_stop(chip, substream);
+		if (err < 0) {
+			snd_printk(KERN_ERR LXP "failed to stop hardware. "
+				   "Error code %d\n", err);
+			goto exit;
+		}
+
+		err = lx_hardware_close(chip, substream);
+		if (err < 0) {
+			snd_printk(KERN_ERR LXP "failed to close hardware. "
+				   "Error code %d\n", err);
+			goto exit;
+		}
+
+		chip->hardware_running[is_capture] = 0;
+	}
+
+	err = snd_pcm_lib_free_pages(substream);
+
+	if (is_capture)
+		chip->capture_stream.stream = 0;
+	else
+		chip->playback_stream.stream = 0;
+
+exit:
+	mutex_unlock(&chip->setup_mutex);
+	return err;
+}
+
+static void lx_trigger_start(struct lx6464es *chip, struct lx_stream *lx_stream)
+{
+	struct snd_pcm_substream *substream = lx_stream->stream;
+	const int is_capture = lx_stream->is_capture;
+
+	int err;
+
+	const u32 channels = substream->runtime->channels;
+	const u32 bytes_per_frame = channels * 3;
+	const u32 period_size = substream->runtime->period_size;
+	const u32 periods = substream->runtime->periods;
+	const u32 period_bytes = period_size * bytes_per_frame;
+
+	dma_addr_t buf = substream->dma_buffer.addr;
+	int i;
+
+	u32 needed, freed;
+	u32 size_array[5];
+
+	for (i = 0; i != periods; ++i) {
+		u32 buffer_index = 0;
+
+		err = lx_buffer_ask(chip, 0, is_capture, &needed, &freed,
+				    size_array);
+		snd_printdd(LXP "starting: needed %d, freed %d\n",
+			    needed, freed);
+
+		err = lx_buffer_give(chip, 0, is_capture, period_bytes,
+				     lower_32_bits(buf), upper_32_bits(buf),
+				     &buffer_index);
+
+		snd_printdd(LXP "starting: buffer index %x on %p (%d bytes)\n",
+			    buffer_index, (void *)buf, period_bytes);
+		buf += period_bytes;
+	}
+
+	err = lx_buffer_ask(chip, 0, is_capture, &needed, &freed, size_array);
+	snd_printdd(LXP "starting: needed %d, freed %d\n", needed, freed);
+
+	snd_printd(LXP "starting: starting stream\n");
+	err = lx_stream_start(chip, 0, is_capture);
+	if (err < 0)
+		snd_printk(KERN_ERR LXP "couldn't start stream\n");
+	else
+		lx_stream->status = LX_STREAM_STATUS_RUNNING;
+
+	lx_stream->frame_pos = 0;
+}
+
+static void lx_trigger_stop(struct lx6464es *chip, struct lx_stream *lx_stream)
+{
+	const int is_capture = lx_stream->is_capture;
+	int err;
+
+	snd_printd(LXP "stopping: stopping stream\n");
+	err = lx_stream_stop(chip, 0, is_capture);
+	if (err < 0)
+		snd_printk(KERN_ERR LXP "couldn't stop stream\n");
+	else
+		lx_stream->status = LX_STREAM_STATUS_FREE;
+
+}
+
+static void lx_trigger_tasklet_dispatch_stream(struct lx6464es *chip,
+					       struct lx_stream *lx_stream)
+{
+	switch (lx_stream->status) {
+	case LX_STREAM_STATUS_SCHEDULE_RUN:
+		lx_trigger_start(chip, lx_stream);
+		break;
+
+	case LX_STREAM_STATUS_SCHEDULE_STOP:
+		lx_trigger_stop(chip, lx_stream);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void lx_trigger_tasklet(unsigned long data)
+{
+	struct lx6464es *chip = (struct lx6464es *)data;
+	unsigned long flags;
+
+	snd_printdd("->lx_trigger_tasklet\n");
+
+	spin_lock_irqsave(&chip->lock, flags);
+	lx_trigger_tasklet_dispatch_stream(chip, &chip->capture_stream);
+	lx_trigger_tasklet_dispatch_stream(chip, &chip->playback_stream);
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static int lx_pcm_trigger_dispatch(struct lx6464es *chip,
+				   struct lx_stream *lx_stream, int cmd)
+{
+	int err = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		lx_stream->status = LX_STREAM_STATUS_SCHEDULE_RUN;
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		lx_stream->status = LX_STREAM_STATUS_SCHEDULE_STOP;
+		break;
+
+	default:
+		err = -EINVAL;
+		goto exit;
+	}
+	tasklet_schedule(&chip->trigger_tasklet);
+
+exit:
+	return err;
+}
+
+
+static int lx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct lx6464es *chip = snd_pcm_substream_chip(substream);
+	const int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
+	struct lx_stream *stream = is_capture ? &chip->capture_stream :
+		&chip->playback_stream;
+
+	snd_printdd("->lx_pcm_trigger\n");
+
+	return lx_pcm_trigger_dispatch(chip, stream, cmd);
+}
+
+static int snd_lx6464es_free(struct lx6464es *chip)
+{
+	snd_printdd("->snd_lx6464es_free\n");
+
+	lx_irq_disable(chip);
+
+	if (chip->irq >= 0)
+		free_irq(chip->irq, chip);
+
+	iounmap(chip->port_dsp_bar);
+	ioport_unmap(chip->port_plx_remapped);
+
+	pci_release_regions(chip->pci);
+	pci_disable_device(chip->pci);
+
+	kfree(chip);
+
+	return 0;
+}
+
+static int snd_lx6464es_dev_free(struct snd_device *device)
+{
+	return snd_lx6464es_free(device->device_data);
+}
+
+/* reset the dsp during initialization */
+static int __devinit lx_init_xilinx_reset(struct lx6464es *chip)
+{
+	int i;
+	u32 plx_reg = lx_plx_reg_read(chip, ePLX_CHIPSC);
+
+	snd_printdd("->lx_init_xilinx_reset\n");
+
+	/* activate reset of xilinx */
+	plx_reg &= ~CHIPSC_RESET_XILINX;
+
+	lx_plx_reg_write(chip, ePLX_CHIPSC, plx_reg);
+	msleep(1);
+
+	lx_plx_reg_write(chip, ePLX_MBOX3, 0);
+	msleep(1);
+
+	plx_reg |= CHIPSC_RESET_XILINX;
+	lx_plx_reg_write(chip, ePLX_CHIPSC, plx_reg);
+
+	/* deactivate reset of xilinx */
+	for (i = 0; i != 100; ++i) {
+		u32 reg_mbox3;
+		msleep(10);
+		reg_mbox3 = lx_plx_reg_read(chip, ePLX_MBOX3);
+		if (reg_mbox3) {
+			snd_printd(LXP "xilinx reset done\n");
+			snd_printdd(LXP "xilinx took %d loops\n", i);
+			break;
+		}
+	}
+
+	/* todo: add some error handling? */
+
+	/* clear mr */
+	lx_dsp_reg_write(chip, eReg_CSM, 0);
+
+	/* le xilinx ES peut ne pas etre encore pret, on attend. */
+	msleep(600);
+
+	return 0;
+}
+
+static int __devinit lx_init_xilinx_test(struct lx6464es *chip)
+{
+	u32 reg;
+
+	snd_printdd("->lx_init_xilinx_test\n");
+
+	/* TEST if we have access to Xilinx/MicroBlaze */
+	lx_dsp_reg_write(chip, eReg_CSM, 0);
+
+	reg = lx_dsp_reg_read(chip, eReg_CSM);
+
+	if (reg) {
+		snd_printk(KERN_ERR LXP "Problem: Reg_CSM %x.\n", reg);
+
+		/* PCI9056_SPACE0_REMAP */
+		lx_plx_reg_write(chip, ePLX_PCICR, 1);
+
+		reg = lx_dsp_reg_read(chip, eReg_CSM);
+		if (reg) {
+			snd_printk(KERN_ERR LXP "Error: Reg_CSM %x.\n", reg);
+			return -EAGAIN; /* seems to be appropriate */
+		}
+	}
+
+	snd_printd(LXP "Xilinx/MicroBlaze access test successful\n");
+
+	return 0;
+}
+
+/* initialize ethersound */
+static int __devinit lx_init_ethersound_config(struct lx6464es *chip)
+{
+	int i;
+	u32 orig_conf_es = lx_dsp_reg_read(chip, eReg_CONFES);
+
+	u32 default_conf_es = (64 << IOCR_OUTPUTS_OFFSET) |
+		(64 << IOCR_INPUTS_OFFSET) |
+		(FREQ_RATIO_SINGLE_MODE << FREQ_RATIO_OFFSET);
+
+	u32 conf_es = (orig_conf_es & CONFES_READ_PART_MASK)
+		| (default_conf_es & CONFES_WRITE_PART_MASK);
+
+	snd_printdd("->lx_init_ethersound\n");
+
+	chip->freq_ratio = FREQ_RATIO_SINGLE_MODE;
+
+	/*
+	 * write it to the card !
+	 * this actually kicks the ES xilinx, the first time since poweron.
+	 * the MAC address in the Reg_ADMACESMSB Reg_ADMACESLSB registers
+	 * is not ready before this is done, and the bit 2 in Reg_CSES is set.
+	 * */
+	lx_dsp_reg_write(chip, eReg_CONFES, conf_es);
+
+	for (i = 0; i != 1000; ++i) {
+		if (lx_dsp_reg_read(chip, eReg_CSES) & 4) {
+			snd_printd(LXP "ethersound initialized after %dms\n",
+				   i);
+			goto ethersound_initialized;
+		}
+		msleep(1);
+	}
+	snd_printk(KERN_WARNING LXP
+		   "ethersound could not be initialized after %dms\n", i);
+	return -ETIMEDOUT;
+
+ ethersound_initialized:
+	snd_printd(LXP "ethersound initialized\n");
+	return 0;
+}
+
+static int __devinit lx_init_get_version_features(struct lx6464es *chip)
+{
+	u32 dsp_version;
+
+	int err;
+
+	snd_printdd("->lx_init_get_version_features\n");
+
+	err = lx_dsp_get_version(chip, &dsp_version);
+
+	if (err == 0) {
+		u32 freq;
+
+		snd_printk(LXP "DSP version: V%02d.%02d #%d\n",
+			   (dsp_version>>16) & 0xff, (dsp_version>>8) & 0xff,
+			   dsp_version & 0xff);
+
+		/* later: what firmware version do we expect? */
+
+		/* retrieve Play/Rec features */
+		/* done here because we may have to handle alternate
+		 * DSP files. */
+		/* later */
+
+		/* init the EtherSound sample rate */
+		err = lx_dsp_get_clock_frequency(chip, &freq);
+		if (err == 0)
+			chip->board_sample_rate = freq;
+		snd_printd(LXP "actual clock frequency %d\n", freq);
+	} else {
+		snd_printk(KERN_ERR LXP "DSP corrupted \n");
+		err = -EAGAIN;
+	}
+
+	return err;
+}
+
+static int lx_set_granularity(struct lx6464es *chip, u32 gran)
+{
+	int err = 0;
+	u32 snapped_gran = MICROBLAZE_IBL_MIN;
+
+	snd_printdd("->lx_set_granularity\n");
+
+	/* blocksize is a power of 2 */
+	while ((snapped_gran < gran) &&
+	       (snapped_gran < MICROBLAZE_IBL_MAX)) {
+		snapped_gran *= 2;
+	}
+
+	if (snapped_gran == chip->pcm_granularity)
+		return 0;
+
+	err = lx_dsp_set_granularity(chip, snapped_gran);
+	if (err < 0) {
+		snd_printk(KERN_WARNING LXP "could not set granularity\n");
+		err = -EAGAIN;
+	}
+
+	if (snapped_gran != gran)
+		snd_printk(LXP "snapped blocksize to %d\n", snapped_gran);
+
+	snd_printd(LXP "set blocksize on board %d\n", snapped_gran);
+	chip->pcm_granularity = snapped_gran;
+
+	return err;
+}
+
+/* initialize and test the xilinx dsp chip */
+static int __devinit lx_init_dsp(struct lx6464es *chip)
+{
+	int err;
+	u8 mac_address[6];
+	int i;
+
+	snd_printdd("->lx_init_dsp\n");
+
+	snd_printd(LXP "initialize board\n");
+	err = lx_init_xilinx_reset(chip);
+	if (err)
+		return err;
+
+	snd_printd(LXP "testing board\n");
+	err = lx_init_xilinx_test(chip);
+	if (err)
+		return err;
+
+	snd_printd(LXP "initialize ethersound configuration\n");
+	err = lx_init_ethersound_config(chip);
+	if (err)
+		return err;
+
+	lx_irq_enable(chip);
+
+	/** \todo the mac address should be ready by not, but it isn't,
+	 *  so we wait for it */
+	for (i = 0; i != 1000; ++i) {
+		err = lx_dsp_get_mac(chip, mac_address);
+		if (err)
+			return err;
+		if (mac_address[0] || mac_address[1] || mac_address[2] ||
+		    mac_address[3] || mac_address[4] || mac_address[5])
+			goto mac_ready;
+		msleep(1);
+	}
+	return -ETIMEDOUT;
+
+mac_ready:
+	snd_printd(LXP "mac address ready read after: %dms\n", i);
+	snd_printk(LXP "mac address: %02X.%02X.%02X.%02X.%02X.%02X\n",
+		   mac_address[0], mac_address[1], mac_address[2],
+		   mac_address[3], mac_address[4], mac_address[5]);
+
+	err = lx_init_get_version_features(chip);
+	if (err)
+		return err;
+
+	lx_set_granularity(chip, MICROBLAZE_IBL_DEFAULT);
+
+	chip->playback_mute = 0;
+
+	return err;
+}
+
+static struct snd_pcm_ops lx_ops_playback = {
+	.open      = lx_pcm_open,
+	.close     = lx_pcm_close,
+	.ioctl     = snd_pcm_lib_ioctl,
+	.prepare   = lx_pcm_prepare,
+	.hw_params = lx_pcm_hw_params_playback,
+	.hw_free   = lx_pcm_hw_free,
+	.trigger   = lx_pcm_trigger,
+	.pointer   = lx_pcm_stream_pointer,
+};
+
+static struct snd_pcm_ops lx_ops_capture = {
+	.open      = lx_pcm_open,
+	.close     = lx_pcm_close,
+	.ioctl     = snd_pcm_lib_ioctl,
+	.prepare   = lx_pcm_prepare,
+	.hw_params = lx_pcm_hw_params_capture,
+	.hw_free   = lx_pcm_hw_free,
+	.trigger   = lx_pcm_trigger,
+	.pointer   = lx_pcm_stream_pointer,
+};
+
+static int __devinit lx_pcm_create(struct lx6464es *chip)
+{
+	int err;
+	struct snd_pcm *pcm;
+
+	u32 size = 64 *		     /* channels */
+		3 *		     /* 24 bit samples */
+		MAX_STREAM_BUFFER *  /* periods */
+		MICROBLAZE_IBL_MAX * /* frames per period */
+		2;		     /* duplex */
+
+	size = PAGE_ALIGN(size);
+
+	/* hardcoded device name & channel count */
+	err = snd_pcm_new(chip->card, (char *)card_name, 0,
+			  1, 1, &pcm);
+
+	pcm->private_data = chip;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &lx_ops_playback);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &lx_ops_capture);
+
+	pcm->info_flags = 0;
+	strcpy(pcm->name, card_name);
+
+	err = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+						    snd_dma_pci_data(chip->pci),
+						    size, size);
+	if (err < 0)
+		return err;
+
+	chip->pcm = pcm;
+	chip->capture_stream.is_capture = 1;
+
+	return 0;
+}
+
+static int lx_control_playback_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int lx_control_playback_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct lx6464es *chip = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer.value[0] = chip->playback_mute;
+	return 0;
+}
+
+static int lx_control_playback_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct lx6464es *chip = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+	int current_value = chip->playback_mute;
+
+	if (current_value != ucontrol->value.integer.value[0]) {
+		lx_level_unmute(chip, 0, !current_value);
+		chip->playback_mute = !current_value;
+		changed = 1;
+	}
+	return changed;
+}
+
+static struct snd_kcontrol_new lx_control_playback_switch __devinitdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "PCM Playback Switch",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value = 0,
+	.info = lx_control_playback_info,
+	.get = lx_control_playback_get,
+	.put = lx_control_playback_put
+};
+
+
+
+static void lx_proc_levels_read(struct snd_info_entry *entry,
+				struct snd_info_buffer *buffer)
+{
+	u32 levels[64];
+	int err;
+	int i, j;
+	struct lx6464es *chip = entry->private_data;
+
+	snd_iprintf(buffer, "capture levels:\n");
+	err = lx_level_peaks(chip, 1, 64, levels);
+	if (err < 0)
+		return;
+
+	for (i = 0; i != 8; ++i) {
+		for (j = 0; j != 8; ++j)
+			snd_iprintf(buffer, "%08x ", levels[i*8+j]);
+		snd_iprintf(buffer, "\n");
+	}
+
+	snd_iprintf(buffer, "\nplayback levels:\n");
+
+	err = lx_level_peaks(chip, 0, 64, levels);
+	if (err < 0)
+		return;
+
+	for (i = 0; i != 8; ++i) {
+		for (j = 0; j != 8; ++j)
+			snd_iprintf(buffer, "%08x ", levels[i*8+j]);
+		snd_iprintf(buffer, "\n");
+	}
+
+	snd_iprintf(buffer, "\n");
+}
+
+static int __devinit lx_proc_create(struct snd_card *card, struct lx6464es *chip)
+{
+	struct snd_info_entry *entry;
+	int err = snd_card_proc_new(card, "levels", &entry);
+	if (err < 0)
+		return err;
+
+	snd_info_set_text_ops(entry, chip, lx_proc_levels_read);
+	return 0;
+}
+
+
+static int __devinit snd_lx6464es_create(struct snd_card *card,
+					 struct pci_dev *pci,
+					 struct lx6464es **rchip)
+{
+	struct lx6464es *chip;
+	int err;
+
+	static struct snd_device_ops ops = {
+		.dev_free = snd_lx6464es_dev_free,
+	};
+
+	snd_printdd("->snd_lx6464es_create\n");
+
+	*rchip = NULL;
+
+	/* enable PCI device */
+	err = pci_enable_device(pci);
+	if (err < 0)
+		return err;
+
+	pci_set_master(pci);
+
+	/* check if we can restrict PCI DMA transfers to 32 bits */
+	err = pci_set_dma_mask(pci, DMA_32BIT_MASK);
+	if (err < 0) {
+		snd_printk(KERN_ERR "architecture does not support "
+			   "32bit PCI busmaster DMA\n");
+		pci_disable_device(pci);
+		return -ENXIO;
+	}
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		err = -ENOMEM;
+		goto alloc_failed;
+	}
+
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+
+	/* initialize synchronization structs */
+	spin_lock_init(&chip->lock);
+	spin_lock_init(&chip->msg_lock);
+	mutex_init(&chip->setup_mutex);
+	tasklet_init(&chip->trigger_tasklet, lx_trigger_tasklet,
+		     (unsigned long)chip);
+	tasklet_init(&chip->tasklet_capture, lx_tasklet_capture,
+		     (unsigned long)chip);
+	tasklet_init(&chip->tasklet_playback, lx_tasklet_playback,
+		     (unsigned long)chip);
+
+	/* request resources */
+	err = pci_request_regions(pci, card_name);
+	if (err < 0)
+		goto request_regions_failed;
+
+	/* plx port */
+	chip->port_plx = pci_resource_start(pci, 1);
+	chip->port_plx_remapped = ioport_map(chip->port_plx,
+					     pci_resource_len(pci, 1));
+
+	/* dsp port */
+	chip->port_dsp_bar = pci_ioremap_bar(pci, 2);
+
+	err = request_irq(pci->irq, lx_interrupt, IRQF_SHARED,
+			  card_name, chip);
+	if (err) {
+		snd_printk(KERN_ERR LXP "unable to grab IRQ %d\n", pci->irq);
+		goto request_irq_failed;
+	}
+	chip->irq = pci->irq;
+
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
+	if (err < 0)
+		goto device_new_failed;
+
+	err = lx_init_dsp(chip);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "error during DSP initialization\n");
+		return err;
+	}
+
+	err = lx_pcm_create(chip);
+	if (err < 0)
+		return err;
+
+	err = lx_proc_create(card, chip);
+	if (err < 0)
+		return err;
+
+	err = snd_ctl_add(card, snd_ctl_new1(&lx_control_playback_switch,
+					     chip));
+	if (err < 0)
+		return err;
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*rchip = chip;
+	return 0;
+
+device_new_failed:
+	free_irq(pci->irq, chip);
+
+request_irq_failed:
+	pci_release_regions(pci);
+
+request_regions_failed:
+	kfree(chip);
+
+alloc_failed:
+	pci_disable_device(pci);
+
+	return err;
+}
+
+static int __devinit snd_lx6464es_probe(struct pci_dev *pci,
+					const struct pci_device_id *pci_id)
+{
+	static int dev;
+	struct snd_card *card;
+	struct lx6464es *chip;
+	int err;
+
+	snd_printdd("->snd_lx6464es_probe\n");
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	err = snd_lx6464es_create(card, pci, &chip);
+	if (err < 0) {
+		snd_printk(KERN_ERR LXP "error during snd_lx6464es_create\n");
+		goto out_free;
+	}
+
+	strcpy(card->driver, "lx6464es");
+	strcpy(card->shortname, "Digigram LX6464ES");
+	sprintf(card->longname, "%s at 0x%lx, 0x%p, irq %i",
+		card->shortname, chip->port_plx,
+		chip->port_dsp_bar, chip->irq);
+
+	err = snd_card_register(card);
+	if (err < 0)
+		goto out_free;
+
+	snd_printdd(LXP "initialization successful\n");
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+
+out_free:
+	snd_card_free(card);
+	return err;
+
+}
+
+static void __devexit snd_lx6464es_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+
+static struct pci_driver driver = {
+	.name =     "Digigram LX6464ES",
+	.id_table = snd_lx6464es_ids,
+	.probe =    snd_lx6464es_probe,
+	.remove = __devexit_p(snd_lx6464es_remove),
+};
+
+
+/* module initialization */
+static int __init mod_init(void)
+{
+	return pci_register_driver(&driver);
+}
+
+static void __exit mod_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(mod_init);
+module_exit(mod_exit);
