commit fb95aae6e67c4e319a24b3eea32032d4246a5335
Merge: bd2463ac7d7e 90fb04f890bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 16:26:57 2020 -0800

    Merge tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "As the diffstat shows we've had again a lot of works done for this
      cycle: the majority of changes are the continued componentization and
      code refactoring in ASoC, the tree-wide PCM API updates and cleanups
      and SOF updates while a few ASoC driver updates are seen, too.
    
      Here we go, some highlights:
    
      Core:
       - Finally y2038 support landed to ALSA ABI; some ioctls have been
         extended and lots of tricks were applied
       - Applying the new managed PCM buffer API to all drivers; the API
         itself was already merged in 5.5
       - The already deprecated dimension support in ALSA control API is
         dropped completely now
       - Verification of ALSA control elements to catch API misuses
    
      ASoC:
       - Further code refactorings and moving things to the component level
       - Lots of updates and improvements on SOF / Intel drivers; now
         including common HDMI driver and SoundWire support
       - New driver support for Ingenic JZ4770, Mediatek MT6660, Qualcomm
         WCD934x and WSA881x, and Realtek RT700, RT711, RT715, RT1011,
         RT1015 and RT1308
    
      HD-audio:
       - Improved ring-buffer communications using waitqueue
       - Drop the superfluous buffer preallocation on x86
    
      Others:
       - Many code cleanups, mostly constifications over the whole tree
       - USB-audio: quirks for MOTU, Corsair Virtuoso, Line6 Helix
       - FireWire: code refactoring for oxfw and dice drivers"
    
    * tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (638 commits)
      ALSA: usb-audio: add quirks for Line6 Helix devices fw>=2.82
      ALSA: hda: Add Clevo W65_67SB the power_save blacklist
      ASoC: soc-core: remove null_snd_soc_ops
      ASoC: soc-pcm: add soc_rtd_trigger()
      ASoC: soc-pcm: add soc_rtd_hw_free()
      ASoC: soc-pcm: add soc_rtd_hw_params()
      ASoC: soc-pcm: add soc_rtd_prepare()
      ASoC: soc-pcm: add soc_rtd_shutdown()
      ASoC: soc-pcm: add soc_rtd_startup()
      ASoC: rt1015: add rt1015 amplifier driver
      ASoC: madera: Correct some kernel doc
      ASoC: topology: fix soc_tplg_fe_link_create() - link->dobj initialization order
      ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
      ASoC: madera: Correct DMIC only input hook ups
      ALSA: cs46xx: fix spelling mistake "to" -> "too"
      ALSA: hda - Add docking station support for Lenovo Thinkpad T420s
      ASoC: Add MediaTek MT6660 Speaker Amp Driver
      ASoC: dt-bindings: rt5645: add suppliers
      ASoC: max98090: fix deadlock in max98090_dapm_put_enum_double()
      ASoC: dapm: add snd_soc_dapm_put_enum_double_locked
      ...

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 58a4b8df25d4..4a238de5a77e 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1344,7 +1344,7 @@ static int snd_rme32_create(struct rme32 *rme32)
 		return err;
 	rme32->port = pci_resource_start(rme32->pci, 0);
 
-	rme32->iobase = ioremap_nocache(rme32->port, RME32_IO_SIZE);
+	rme32->iobase = ioremap(rme32->port, RME32_IO_SIZE);
 	if (!rme32->iobase) {
 		dev_err(rme32->card->dev,
 			"unable to remap memory region 0x%lx-0x%lx\n",

commit b4e5e70775546480035e156b40040e5d0d4264d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:53 2020 +0100

    ALSA: pci: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-38-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 15029b2be233..16d726da74bf 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1796,7 +1796,7 @@ static int snd_rme32_control_spdif_mask_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_rme32_controls[] = {
+static const struct snd_kcontrol_new snd_rme32_controls[] = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),

commit 1dad75b9823c77aa7e1020f011c72fcc15a90144
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:30 2019 +0100

    ALSA: rme32: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-32-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 849eede15f8e..15029b2be233 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1330,6 +1330,7 @@ static int snd_rme32_create(struct rme32 *rme32)
 		return -EBUSY;
 	}
 	rme32->irq = pci->irq;
+	rme32->card->sync_irq = rme32->irq;
 
 	/* read the card's revision number */
 	pci_read_config_byte(pci, 8, &rme32->rev);

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index aab47e5d96dc..849eede15f8e 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1177,7 +1177,6 @@ snd_rme32_capture_fd_pointer(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_rme32_playback_spdif_ops = {
 	.open =		snd_rme32_playback_spdif_open,
 	.close =	snd_rme32_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_playback_hw_params,
 	.prepare =	snd_rme32_playback_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
@@ -1191,7 +1190,6 @@ static const struct snd_pcm_ops snd_rme32_playback_spdif_ops = {
 static const struct snd_pcm_ops snd_rme32_capture_spdif_ops = {
 	.open =		snd_rme32_capture_spdif_open,
 	.close =	snd_rme32_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_capture_hw_params,
 	.prepare =	snd_rme32_capture_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
@@ -1204,7 +1202,6 @@ static const struct snd_pcm_ops snd_rme32_capture_spdif_ops = {
 static const struct snd_pcm_ops snd_rme32_playback_adat_ops = {
 	.open =		snd_rme32_playback_adat_open,
 	.close =	snd_rme32_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_playback_hw_params,
 	.prepare =	snd_rme32_playback_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
@@ -1218,7 +1215,6 @@ static const struct snd_pcm_ops snd_rme32_playback_adat_ops = {
 static const struct snd_pcm_ops snd_rme32_capture_adat_ops = {
 	.open =		snd_rme32_capture_adat_open,
 	.close =	snd_rme32_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_capture_hw_params,
 	.prepare =	snd_rme32_capture_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
@@ -1232,7 +1228,6 @@ static const struct snd_pcm_ops snd_rme32_capture_adat_ops = {
 static const struct snd_pcm_ops snd_rme32_playback_spdif_fd_ops = {
 	.open =		snd_rme32_playback_spdif_open,
 	.close =	snd_rme32_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_playback_hw_params,
 	.prepare =	snd_rme32_playback_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
@@ -1243,7 +1238,6 @@ static const struct snd_pcm_ops snd_rme32_playback_spdif_fd_ops = {
 static const struct snd_pcm_ops snd_rme32_capture_spdif_fd_ops = {
 	.open =		snd_rme32_capture_spdif_open,
 	.close =	snd_rme32_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_capture_hw_params,
 	.prepare =	snd_rme32_capture_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
@@ -1254,7 +1248,6 @@ static const struct snd_pcm_ops snd_rme32_capture_spdif_fd_ops = {
 static const struct snd_pcm_ops snd_rme32_playback_adat_fd_ops = {
 	.open =		snd_rme32_playback_adat_open,
 	.close =	snd_rme32_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_playback_hw_params,
 	.prepare =	snd_rme32_playback_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
@@ -1265,7 +1258,6 @@ static const struct snd_pcm_ops snd_rme32_playback_adat_fd_ops = {
 static const struct snd_pcm_ops snd_rme32_capture_adat_fd_ops = {
 	.open =		snd_rme32_capture_adat_open,
 	.close =	snd_rme32_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_capture_hw_params,
 	.prepare =	snd_rme32_capture_prepare,
 	.trigger =	snd_rme32_pcm_trigger,

commit 7ceebdc87c63cfdbbdd38b58a16d7597e1b3c9f6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:23 2019 +0100

    ALSA: rme32: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_free callback became superfluous and got dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-52-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 58a4b8df25d4..aab47e5d96dc 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -662,11 +662,7 @@ snd_rme32_playback_hw_params(struct snd_pcm_substream *substream,
 	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	if (rme32->fullduplex_mode) {
-		err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
-		if (err < 0)
-			return err;
-	} else {
+	if (!rme32->fullduplex_mode) {
 		runtime->dma_area = (void __force *)(rme32->iobase +
 						     RME32_IO_DATA_BUFFER);
 		runtime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;
@@ -717,11 +713,7 @@ snd_rme32_capture_hw_params(struct snd_pcm_substream *substream,
 	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	if (rme32->fullduplex_mode) {
-		err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
-		if (err < 0)
-			return err;
-	} else {
+	if (!rme32->fullduplex_mode) {
 		runtime->dma_area = (void __force *)rme32->iobase +
 					RME32_IO_DATA_BUFFER;
 		runtime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;
@@ -771,14 +763,6 @@ snd_rme32_capture_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static int snd_rme32_pcm_hw_free(struct snd_pcm_substream *substream)
-{
-	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
-	if (! rme32->fullduplex_mode)
-		return 0;
-	return snd_pcm_lib_free_pages(substream);
-}
-
 static void snd_rme32_pcm_start(struct rme32 * rme32, int from_pause)
 {
 	if (!from_pause) {
@@ -1195,7 +1179,6 @@ static const struct snd_pcm_ops snd_rme32_playback_spdif_ops = {
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_playback_hw_params,
-	.hw_free =	snd_rme32_pcm_hw_free,
 	.prepare =	snd_rme32_playback_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
 	.pointer =	snd_rme32_playback_pointer,
@@ -1210,7 +1193,6 @@ static const struct snd_pcm_ops snd_rme32_capture_spdif_ops = {
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_capture_hw_params,
-	.hw_free =	snd_rme32_pcm_hw_free,
 	.prepare =	snd_rme32_capture_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
 	.pointer =	snd_rme32_capture_pointer,
@@ -1252,7 +1234,6 @@ static const struct snd_pcm_ops snd_rme32_playback_spdif_fd_ops = {
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_playback_hw_params,
-	.hw_free =	snd_rme32_pcm_hw_free,
 	.prepare =	snd_rme32_playback_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
 	.pointer =	snd_rme32_playback_fd_pointer,
@@ -1264,7 +1245,6 @@ static const struct snd_pcm_ops snd_rme32_capture_spdif_fd_ops = {
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme32_capture_hw_params,
-	.hw_free =	snd_rme32_pcm_hw_free,
 	.prepare =	snd_rme32_capture_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
 	.pointer =	snd_rme32_capture_fd_pointer,
@@ -1374,9 +1354,8 @@ static int snd_rme32_create(struct rme32 *rme32)
 				&snd_rme32_playback_spdif_fd_ops);
 		snd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE,
 				&snd_rme32_capture_spdif_fd_ops);
-		snd_pcm_lib_preallocate_pages_for_all(rme32->spdif_pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-						      NULL,
-						      0, RME32_MID_BUFFER_SIZE);
+		snd_pcm_set_managed_buffer_all(rme32->spdif_pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+					       NULL, 0, RME32_MID_BUFFER_SIZE);
 		rme32->spdif_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
 	} else {
 		snd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK,
@@ -1406,9 +1385,9 @@ static int snd_rme32_create(struct rme32 *rme32)
 					&snd_rme32_playback_adat_fd_ops);
 			snd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_CAPTURE, 
 					&snd_rme32_capture_adat_fd_ops);
-			snd_pcm_lib_preallocate_pages_for_all(rme32->adat_pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-							      NULL,
-							      0, RME32_MID_BUFFER_SIZE);
+			snd_pcm_set_managed_buffer_all(rme32->adat_pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+						       NULL,
+						       0, RME32_MID_BUFFER_SIZE);
 			rme32->adat_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
 		} else {
 			snd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK, 

commit 1422bc5001a98f5be618a4abc62325f8a9310941
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:35 2019 +0100

    ALSA: rme32: Remove superfluous snd_dma_continuous_data()
    
    The recent change (commit 08422d2c559d: "ALSA: memalloc: Allow NULL
    device for SNDRV_DMA_TYPE_CONTINUOUS type") made the PCM preallocation
    helper accepting NULL as the device pointer for the default usage.
    Drop the snd_dma_continuous_data() usage that became superfluous from
    the callers.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-4-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 40cc6ca88f7b..58a4b8df25d4 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1375,7 +1375,7 @@ static int snd_rme32_create(struct rme32 *rme32)
 		snd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE,
 				&snd_rme32_capture_spdif_fd_ops);
 		snd_pcm_lib_preallocate_pages_for_all(rme32->spdif_pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-						      snd_dma_continuous_data(GFP_KERNEL),
+						      NULL,
 						      0, RME32_MID_BUFFER_SIZE);
 		rme32->spdif_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
 	} else {
@@ -1407,7 +1407,7 @@ static int snd_rme32_create(struct rme32 *rme32)
 			snd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_CAPTURE, 
 					&snd_rme32_capture_adat_fd_ops);
 			snd_pcm_lib_preallocate_pages_for_all(rme32->adat_pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-							      snd_dma_continuous_data(GFP_KERNEL),
+							      NULL,
 							      0, RME32_MID_BUFFER_SIZE);
 			rme32->adat_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
 		} else {

commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index c6bcc0715716..40cc6ca88f7b 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   ALSA driver for RME Digi32, Digi32/8 and Digi32 PRO audio interfaces
  *
@@ -8,21 +9,6 @@
  *                         Henk Hesselink <henk@anda.nl>
  *                         for writing the digi96-driver 
  *                         and RME for all informations.
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- * 
  * 
  * ****************************************************************************
  * 

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 3ac8c71d567c..c6bcc0715716 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1568,10 +1568,7 @@ snd_rme32_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffe
 
 static void snd_rme32_proc_init(struct rme32 *rme32)
 {
-	struct snd_info_entry *entry;
-
-	if (! snd_card_proc_new(rme32->card, "rme32", &entry))
-		snd_info_set_text_ops(entry, rme32, snd_rme32_proc_read);
+	snd_card_ro_proc_new(rme32->card, "rme32", rme32, snd_rme32_proc_read);
 }
 
 /*

commit 38ce57ad164816b432b80feb67d46d53137ff82a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Sep 2 10:22:13 2018 +0200

    ALSA: rme32: Use SNDRV_PCM_INFO_SYNC_APPLPTR info flag
    
    The recently introduced PCM info flag assures the call of ack ops at
    each applptr change, and this is mandatory for the indirect PCM
    helpers.
    
    Also, with the proper ack callback, we need no longer prefill at
    trigger start.  The relevant code can be killed.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index f0906ba416d4..3ac8c71d567c 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -319,7 +319,8 @@ static const struct snd_pcm_hardware snd_rme32_spdif_info = {
 			 SNDRV_PCM_INFO_MMAP_VALID |
 			 SNDRV_PCM_INFO_INTERLEAVED | 
 			 SNDRV_PCM_INFO_PAUSE |
-			 SNDRV_PCM_INFO_SYNC_START),
+			 SNDRV_PCM_INFO_SYNC_START |
+			 SNDRV_PCM_INFO_SYNC_APPLPTR),
 	.formats =	(SNDRV_PCM_FMTBIT_S16_LE | 
 			 SNDRV_PCM_FMTBIT_S32_LE),
 	.rates =	(SNDRV_PCM_RATE_32000 |
@@ -346,7 +347,8 @@ static const struct snd_pcm_hardware snd_rme32_adat_info =
 			      SNDRV_PCM_INFO_MMAP_VALID |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE |
-			      SNDRV_PCM_INFO_SYNC_START),
+			      SNDRV_PCM_INFO_SYNC_START |
+			      SNDRV_PCM_INFO_SYNC_APPLPTR),
 	.formats=            SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =             (SNDRV_PCM_RATE_44100 | 
 			      SNDRV_PCM_RATE_48000),
@@ -370,7 +372,8 @@ static const struct snd_pcm_hardware snd_rme32_spdif_fd_info = {
 			 SNDRV_PCM_INFO_MMAP_VALID |
 			 SNDRV_PCM_INFO_INTERLEAVED | 
 			 SNDRV_PCM_INFO_PAUSE |
-			 SNDRV_PCM_INFO_SYNC_START),
+			 SNDRV_PCM_INFO_SYNC_START |
+			 SNDRV_PCM_INFO_SYNC_APPLPTR),
 	.formats =	(SNDRV_PCM_FMTBIT_S16_LE | 
 			 SNDRV_PCM_FMTBIT_S32_LE),
 	.rates =	(SNDRV_PCM_RATE_32000 |
@@ -397,7 +400,8 @@ static const struct snd_pcm_hardware snd_rme32_adat_fd_info =
 			      SNDRV_PCM_INFO_MMAP_VALID |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE |
-			      SNDRV_PCM_INFO_SYNC_START),
+			      SNDRV_PCM_INFO_SYNC_START |
+			      SNDRV_PCM_INFO_SYNC_APPLPTR),
 	.formats=            SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =             (SNDRV_PCM_RATE_44100 | 
 			      SNDRV_PCM_RATE_48000),
@@ -1104,16 +1108,6 @@ snd_rme32_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		snd_pcm_trigger_done(s, substream);
 	}
 	
-	/* prefill playback buffer */
-	if (cmd == SNDRV_PCM_TRIGGER_START && rme32->fullduplex_mode) {
-		snd_pcm_group_for_each_entry(s, substream) {
-			if (s == rme32->playback_substream) {
-				s->ops->ack(s);
-				break;
-			}
-		}
-	}
-
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		if (rme32->running && ! RME32_ISWORKING(rme32))

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index e4cdef94e4a2..f0906ba416d4 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -314,7 +314,7 @@ static int snd_rme32_capture_copy_kernel(struct snd_pcm_substream *substream,
 /*
  * SPDIF I/O capabilities (half-duplex mode)
  */
-static struct snd_pcm_hardware snd_rme32_spdif_info = {
+static const struct snd_pcm_hardware snd_rme32_spdif_info = {
 	.info =		(SNDRV_PCM_INFO_MMAP_IOMEM |
 			 SNDRV_PCM_INFO_MMAP_VALID |
 			 SNDRV_PCM_INFO_INTERLEAVED | 
@@ -340,7 +340,7 @@ static struct snd_pcm_hardware snd_rme32_spdif_info = {
 /*
  * ADAT I/O capabilities (half-duplex mode)
  */
-static struct snd_pcm_hardware snd_rme32_adat_info =
+static const struct snd_pcm_hardware snd_rme32_adat_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -365,7 +365,7 @@ static struct snd_pcm_hardware snd_rme32_adat_info =
 /*
  * SPDIF I/O capabilities (full-duplex mode)
  */
-static struct snd_pcm_hardware snd_rme32_spdif_fd_info = {
+static const struct snd_pcm_hardware snd_rme32_spdif_fd_info = {
 	.info =		(SNDRV_PCM_INFO_MMAP |
 			 SNDRV_PCM_INFO_MMAP_VALID |
 			 SNDRV_PCM_INFO_INTERLEAVED | 
@@ -391,7 +391,7 @@ static struct snd_pcm_hardware snd_rme32_spdif_fd_info = {
 /*
  * ADAT I/O capabilities (full-duplex mode)
  */
-static struct snd_pcm_hardware snd_rme32_adat_fd_info =
+static const struct snd_pcm_hardware snd_rme32_adat_fd_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP |
 			      SNDRV_PCM_INFO_MMAP_VALID |

commit a7f8009df4078fa28eb26f6caac89da60fd94a16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:22:02 2017 +0200

    ALSA: rme32: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 67d48c8869e9..e4cdef94e4a2 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -836,10 +836,9 @@ static irqreturn_t snd_rme32_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static unsigned int period_bytes[] = { RME32_BLOCK_SIZE };
+static const unsigned int period_bytes[] = { RME32_BLOCK_SIZE };
 
-
-static struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {
+static const struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {
 	.count = ARRAY_SIZE(period_bytes),
 	.list = period_bytes,
 	.mask = 0

commit 032db751efa7d3eb80a3f4b3fde51eb4f6c24308
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 20:29:25 2017 +0200

    ALSA: rme32: Convert to the new PCM copy ops
    
    Replace the copy and the silence ops with the new ops.
    The conversion is straightforward with standard helper functions, and
    now we can drop the bytes <-> frames conversions in callbacks.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index f9b424056d0f..67d48c8869e9 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -254,39 +254,46 @@ static inline unsigned int snd_rme32_pcm_byteptr(struct rme32 * rme32)
 }
 
 /* silence callback for halfduplex mode */
-static int snd_rme32_playback_silence(struct snd_pcm_substream *substream, int channel,	/* not used (interleaved data) */
-				      snd_pcm_uframes_t pos,
-				      snd_pcm_uframes_t count)
+static int snd_rme32_playback_silence(struct snd_pcm_substream *substream,
+				      int channel, unsigned long pos,
+				      unsigned long count)
 {
 	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
-	count <<= rme32->playback_frlog;
-	pos <<= rme32->playback_frlog;
+
 	memset_io(rme32->iobase + RME32_IO_DATA_BUFFER + pos, 0, count);
 	return 0;
 }
 
 /* copy callback for halfduplex mode */
-static int snd_rme32_playback_copy(struct snd_pcm_substream *substream, int channel,	/* not used (interleaved data) */
-				   snd_pcm_uframes_t pos,
-				   void __user *src, snd_pcm_uframes_t count)
+static int snd_rme32_playback_copy(struct snd_pcm_substream *substream,
+				   int channel, unsigned long pos,
+				   void __user *src, unsigned long count)
 {
 	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
-	count <<= rme32->playback_frlog;
-	pos <<= rme32->playback_frlog;
+
 	if (copy_from_user_toio(rme32->iobase + RME32_IO_DATA_BUFFER + pos,
-			    src, count))
+				src, count))
 		return -EFAULT;
 	return 0;
 }
 
+static int snd_rme32_playback_copy_kernel(struct snd_pcm_substream *substream,
+					  int channel, unsigned long pos,
+					  void *src, unsigned long count)
+{
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
+
+	memcpy_toio(rme32->iobase + RME32_IO_DATA_BUFFER + pos, src, count);
+	return 0;
+}
+
 /* copy callback for halfduplex mode */
-static int snd_rme32_capture_copy(struct snd_pcm_substream *substream, int channel,	/* not used (interleaved data) */
-				  snd_pcm_uframes_t pos,
-				  void __user *dst, snd_pcm_uframes_t count)
+static int snd_rme32_capture_copy(struct snd_pcm_substream *substream,
+				  int channel, unsigned long pos,
+				  void __user *dst, unsigned long count)
 {
 	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
-	count <<= rme32->capture_frlog;
-	pos <<= rme32->capture_frlog;
+
 	if (copy_to_user_fromio(dst,
 			    rme32->iobase + RME32_IO_DATA_BUFFER + pos,
 			    count))
@@ -294,6 +301,16 @@ static int snd_rme32_capture_copy(struct snd_pcm_substream *substream, int chann
 	return 0;
 }
 
+static int snd_rme32_capture_copy_kernel(struct snd_pcm_substream *substream,
+					 int channel, unsigned long pos,
+					 void *dst, unsigned long count)
+{
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
+
+	memcpy_fromio(dst, rme32->iobase + RME32_IO_DATA_BUFFER + pos, count);
+	return 0;
+}
+
 /*
  * SPDIF I/O capabilities (half-duplex mode)
  */
@@ -1203,8 +1220,9 @@ static const struct snd_pcm_ops snd_rme32_playback_spdif_ops = {
 	.prepare =	snd_rme32_playback_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
 	.pointer =	snd_rme32_playback_pointer,
-	.copy =		snd_rme32_playback_copy,
-	.silence =	snd_rme32_playback_silence,
+	.copy_user =	snd_rme32_playback_copy,
+	.copy_kernel =	snd_rme32_playback_copy_kernel,
+	.fill_silence =	snd_rme32_playback_silence,
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
@@ -1217,7 +1235,8 @@ static const struct snd_pcm_ops snd_rme32_capture_spdif_ops = {
 	.prepare =	snd_rme32_capture_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
 	.pointer =	snd_rme32_capture_pointer,
-	.copy =		snd_rme32_capture_copy,
+	.copy_user =	snd_rme32_capture_copy,
+	.copy_kernel =	snd_rme32_capture_copy_kernel,
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
@@ -1229,8 +1248,9 @@ static const struct snd_pcm_ops snd_rme32_playback_adat_ops = {
 	.prepare =	snd_rme32_playback_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
 	.pointer =	snd_rme32_playback_pointer,
-	.copy =		snd_rme32_playback_copy,
-	.silence =	snd_rme32_playback_silence,
+	.copy_user =	snd_rme32_playback_copy,
+	.copy_kernel =	snd_rme32_playback_copy_kernel,
+	.fill_silence =	snd_rme32_playback_silence,
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
@@ -1242,7 +1262,8 @@ static const struct snd_pcm_ops snd_rme32_capture_adat_ops = {
 	.prepare =	snd_rme32_capture_prepare,
 	.trigger =	snd_rme32_pcm_trigger,
 	.pointer =	snd_rme32_capture_pointer,
-	.copy =		snd_rme32_capture_copy,
+	.copy_user =	snd_rme32_capture_copy,
+	.copy_kernel =	snd_rme32_capture_copy_kernel,
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 

commit 3e02c5a60e182708005973e34a439d1e25ace9b5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 19 18:49:45 2017 +0200

    ALSA: rme32: Deliver indirect-PCM transfer error
    
    Now that the indirect-PCM transfer helper gives back an error, we
    should return the error from ack callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 96d15db65dfd..f9b424056d0f 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1157,9 +1157,8 @@ static int snd_rme32_playback_fd_ack(struct snd_pcm_substream *substream)
 	if (rme32->running & (1 << SNDRV_PCM_STREAM_CAPTURE))
 		rec->hw_queue_size -= cprec->hw_ready;
 	spin_unlock(&rme32->lock);
-	snd_pcm_indirect_playback_transfer(substream, rec,
-					   snd_rme32_pb_trans_copy);
-	return 0;
+	return snd_pcm_indirect_playback_transfer(substream, rec,
+						  snd_rme32_pb_trans_copy);
 }
 
 static void snd_rme32_cp_trans_copy(struct snd_pcm_substream *substream,
@@ -1174,9 +1173,8 @@ static void snd_rme32_cp_trans_copy(struct snd_pcm_substream *substream,
 static int snd_rme32_capture_fd_ack(struct snd_pcm_substream *substream)
 {
 	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
-	snd_pcm_indirect_capture_transfer(substream, &rme32->capture_pcm,
-					  snd_rme32_cp_trans_copy);
-	return 0;
+	return snd_pcm_indirect_capture_transfer(substream, &rme32->capture_pcm,
+						 snd_rme32_cp_trans_copy);
 }
 
 static snd_pcm_uframes_t

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index cd94ac548ba3..96d15db65dfd 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1196,7 +1196,7 @@ snd_rme32_capture_fd_pointer(struct snd_pcm_substream *substream)
 }
 
 /* for halfduplex mode */
-static struct snd_pcm_ops snd_rme32_playback_spdif_ops = {
+static const struct snd_pcm_ops snd_rme32_playback_spdif_ops = {
 	.open =		snd_rme32_playback_spdif_open,
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1210,7 +1210,7 @@ static struct snd_pcm_ops snd_rme32_playback_spdif_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static struct snd_pcm_ops snd_rme32_capture_spdif_ops = {
+static const struct snd_pcm_ops snd_rme32_capture_spdif_ops = {
 	.open =		snd_rme32_capture_spdif_open,
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1223,7 +1223,7 @@ static struct snd_pcm_ops snd_rme32_capture_spdif_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static struct snd_pcm_ops snd_rme32_playback_adat_ops = {
+static const struct snd_pcm_ops snd_rme32_playback_adat_ops = {
 	.open =		snd_rme32_playback_adat_open,
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1236,7 +1236,7 @@ static struct snd_pcm_ops snd_rme32_playback_adat_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static struct snd_pcm_ops snd_rme32_capture_adat_ops = {
+static const struct snd_pcm_ops snd_rme32_capture_adat_ops = {
 	.open =		snd_rme32_capture_adat_open,
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1249,7 +1249,7 @@ static struct snd_pcm_ops snd_rme32_capture_adat_ops = {
 };
 
 /* for fullduplex mode */
-static struct snd_pcm_ops snd_rme32_playback_spdif_fd_ops = {
+static const struct snd_pcm_ops snd_rme32_playback_spdif_fd_ops = {
 	.open =		snd_rme32_playback_spdif_open,
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1261,7 +1261,7 @@ static struct snd_pcm_ops snd_rme32_playback_spdif_fd_ops = {
 	.ack =		snd_rme32_playback_fd_ack,
 };
 
-static struct snd_pcm_ops snd_rme32_capture_spdif_fd_ops = {
+static const struct snd_pcm_ops snd_rme32_capture_spdif_fd_ops = {
 	.open =		snd_rme32_capture_spdif_open,
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1273,7 +1273,7 @@ static struct snd_pcm_ops snd_rme32_capture_spdif_fd_ops = {
 	.ack =		snd_rme32_capture_fd_ack,
 };
 
-static struct snd_pcm_ops snd_rme32_playback_adat_fd_ops = {
+static const struct snd_pcm_ops snd_rme32_playback_adat_fd_ops = {
 	.open =		snd_rme32_playback_adat_open,
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1284,7 +1284,7 @@ static struct snd_pcm_ops snd_rme32_playback_adat_fd_ops = {
 	.ack =		snd_rme32_playback_fd_ack,
 };
 
-static struct snd_pcm_ops snd_rme32_capture_adat_fd_ops = {
+static const struct snd_pcm_ops snd_rme32_capture_adat_fd_ops = {
 	.open =		snd_rme32_capture_adat_open,
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 80ec88938a2bbdd1f9d84e13b4e730abaf24f5f9
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Oct 18 15:39:19 2015 +0200

    ALSA: rme32: Use snd_pcm_hw_constraint_single()
    
    Use the new snd_pcm_hw_constraint_single() helper function instead of
    calling snd_pcm_hw_constraint_minmax() with the same value for min and max
    to install a constraint that limits the possible configuration values to a
    single value. Using snd_pcm_hw_constraint_single() makes the indented
    result clearer.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 23d7f5d30c41..cd94ac548ba3 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -831,9 +831,9 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {
 static void snd_rme32_set_buffer_constraint(struct rme32 *rme32, struct snd_pcm_runtime *runtime)
 {
 	if (! rme32->fullduplex_mode) {
-		snd_pcm_hw_constraint_minmax(runtime,
+		snd_pcm_hw_constraint_single(runtime,
 					     SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
-					     RME32_BUFFER_SIZE, RME32_BUFFER_SIZE);
+					     RME32_BUFFER_SIZE);
 		snd_pcm_hw_constraint_list(runtime, 0,
 					   SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
 					   &hw_constraints_period_bytes);

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 1a7affad7164..23d7f5d30c41 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -75,6 +75,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/module.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/info.h>
@@ -85,8 +86,6 @@
 #include <sound/asoundef.h>
 #include <sound/initval.h>
 
-#include <asm/io.h>
-
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */

commit 6c869d301bda3f672f001e2c9fcb01685000fc83
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 12 16:56:51 2015 +0100

    ALSA: rme*: Use snd_pcm_format_t
    
    Fix sparse warnings below by using snd_pcm_format_t properly:
       sound/pci/rme32.c:682:60: sparse: incorrect type in argument 2 (different base types)
      sound/pci/rme96.c:1006:69: sparse: incorrect type in argument 2 (different base types)
       .....
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 6c60dcd2e5a1..1a7affad7164 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -632,7 +632,7 @@ snd_rme32_setframelog(struct rme32 * rme32, int n_channels, int is_playback)
 	}
 }
 
-static int snd_rme32_setformat(struct rme32 * rme32, int format)
+static int snd_rme32_setformat(struct rme32 *rme32, snd_pcm_format_t format)
 {
 	switch (format) {
 	case SNDRV_PCM_FORMAT_S16_LE:

commit 11c6ef7c8d439ef2bc3c95e5a4dcea449ab1f90f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 20 18:19:12 2014 +0200

    ALSA: rme32: Use snd_ctl_enum_info()
    
    ... and reduce the open codes.  Also add missing const to text arrays.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 4afd3cab775b..6c60dcd2e5a1 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1608,30 +1608,24 @@ snd_rme32_info_inputtype_control(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_info *uinfo)
 {
 	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
-	static char *texts[4] = { "Optical", "Coaxial", "Internal", "XLR" };
+	static const char * const texts[4] = {
+		"Optical", "Coaxial", "Internal", "XLR"
+	};
+	int num_items;
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
 	switch (rme32->pci->device) {
 	case PCI_DEVICE_ID_RME_DIGI32:
 	case PCI_DEVICE_ID_RME_DIGI32_8:
-		uinfo->value.enumerated.items = 3;
+		num_items = 3;
 		break;
 	case PCI_DEVICE_ID_RME_DIGI32_PRO:
-		uinfo->value.enumerated.items = 4;
+		num_items = 4;
 		break;
 	default:
 		snd_BUG();
-		break;
-	}
-	if (uinfo->value.enumerated.item >
-	    uinfo->value.enumerated.items - 1) {
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
+		return -EINVAL;
 	}
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, num_items, texts);
 }
 static int
 snd_rme32_get_inputtype_control(struct snd_kcontrol *kcontrol,
@@ -1695,20 +1689,12 @@ static int
 snd_rme32_info_clockmode_control(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[4] = { "AutoSync", 
+	static const char * const texts[4] = { "AutoSync",
 				  "Internal 32.0kHz", 
 				  "Internal 44.1kHz", 
 				  "Internal 48.0kHz" };
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 4;
-	if (uinfo->value.enumerated.item > 3) {
-		uinfo->value.enumerated.item = 3;
-	}
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 4, texts);
 }
 static int
 snd_rme32_get_clockmode_control(struct snd_kcontrol *kcontrol,

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index cc2f0c1b6484..4afd3cab775b 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -226,7 +226,7 @@ struct rme32 {
 	struct snd_kcontrol *spdif_ctl;
 };
 
-static DEFINE_PCI_DEVICE_TABLE(snd_rme32_ids) = {
+static const struct pci_device_id snd_rme32_ids[] = {
 	{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32), 0,},
 	{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_8), 0,},
 	{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_PRO), 0,},

commit 03952a3e2d98757a848a0d299d3e7c8ad0f08ffc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 14:57:03 2014 +0100

    ALSA: rme32: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 77465cc03e95..cc2f0c1b6484 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1349,14 +1349,15 @@ static int snd_rme32_create(struct rme32 *rme32)
 
 	rme32->iobase = ioremap_nocache(rme32->port, RME32_IO_SIZE);
 	if (!rme32->iobase) {
-		snd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n",
+		dev_err(rme32->card->dev,
+			"unable to remap memory region 0x%lx-0x%lx\n",
 			   rme32->port, rme32->port + RME32_IO_SIZE - 1);
 		return -ENOMEM;
 	}
 
 	if (request_irq(pci->irq, snd_rme32_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, rme32)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(rme32->card->dev, "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}
 	rme32->irq = pci->irq;

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index cc26346ae66b..77465cc03e95 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1938,15 +1938,14 @@ snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE,
-			      sizeof(struct rme32), &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   sizeof(struct rme32), &card);
 	if (err < 0)
 		return err;
 	card->private_free = snd_rme32_card_free;
 	rme32 = (struct rme32 *) card->private_data;
 	rme32->card = card;
 	rme32->pci = pci;
-	snd_card_set_dev(card, &pci->dev);
         if (fullduplex[dev])
 		rme32->fullduplex_mode = 1;
 	if ((err = snd_rme32_create(rme32)) < 0) {

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 0ecd4100713e..cc26346ae66b 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1981,7 +1981,6 @@ snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 static void snd_rme32_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver rme32_driver = {

commit f49a59c4471d81a233e09dda45187cc44fda009d
Author: Denis Efremov <yefremov.denis@gmail.com>
Date:   Mon Feb 11 19:04:06 2013 +0400

    ALSA: rme32.c irq enabling after spin_lock_irq
    
    According to the other code in this driver and similar
    code in rme96 it seems, that spin_lock_irq in
    snd_rme32_capture_close function should be paired
    with spin_unlock_irq.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Denis Efremov <yefremov.denis@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 2450663e1a18..0ecd4100713e 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1017,7 +1017,7 @@ static int snd_rme32_capture_close(struct snd_pcm_substream *substream)
 	spin_lock_irq(&rme32->lock);
 	rme32->capture_substream = NULL;
 	rme32->capture_periodsize = 0;
-	spin_unlock(&rme32->lock);
+	spin_unlock_irq(&rme32->lock);
 	return 0;
 }
 

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 46b3629dda22..2450663e1a18 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1332,7 +1332,7 @@ snd_rme32_free_adat_pcm(struct snd_pcm *pcm)
 	rme32->adat_pcm = NULL;
 }
 
-static int __devinit snd_rme32_create(struct rme32 * rme32)
+static int snd_rme32_create(struct rme32 *rme32)
 {
 	struct pci_dev *pci = rme32->pci;
 	int err;
@@ -1554,7 +1554,7 @@ snd_rme32_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffe
 	}
 }
 
-static void __devinit snd_rme32_proc_init(struct rme32 * rme32)
+static void snd_rme32_proc_init(struct rme32 *rme32)
 {
 	struct snd_info_entry *entry;
 
@@ -1922,7 +1922,7 @@ static void snd_rme32_card_free(struct snd_card *card)
 	snd_rme32_free(card->private_data);
 }
 
-static int __devinit
+static int
 snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 {
 	static int dev;
@@ -1978,7 +1978,7 @@ snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 	return 0;
 }
 
-static void __devexit snd_rme32_remove(struct pci_dev *pci)
+static void snd_rme32_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -1988,7 +1988,7 @@ static struct pci_driver rme32_driver = {
 	.name =		KBUILD_MODNAME,
 	.id_table =	snd_rme32_ids,
 	.probe =	snd_rme32_probe,
-	.remove =	__devexit_p(snd_rme32_remove),
+	.remove =	snd_rme32_remove,
 };
 
 module_pci_driver(rme32_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index b4819d5e41db..46b3629dda22 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1984,22 +1984,11 @@ static void __devexit snd_rme32_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-static struct pci_driver driver = {
+static struct pci_driver rme32_driver = {
 	.name =		KBUILD_MODNAME,
 	.id_table =	snd_rme32_ids,
 	.probe =	snd_rme32_probe,
 	.remove =	__devexit_p(snd_rme32_remove),
 };
 
-static int __init alsa_card_rme32_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_rme32_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_rme32_init)
-module_exit(alsa_card_rme32_exit)
+module_pci_driver(rme32_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 21bcb47fab50..b4819d5e41db 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -89,8 +89,8 @@
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
-static int fullduplex[SNDRV_CARDS]; // = {[0 ... (SNDRV_CARDS - 1)] = 1};
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static bool fullduplex[SNDRV_CARDS]; // = {[0 ... (SNDRV_CARDS - 1)] = 1};
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for RME Digi32 soundcard.");

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 6be77a264d47..21bcb47fab50 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -74,7 +74,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 
 #include <sound/core.h>
 #include <sound/info.h>

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index c7bcc63097f4..6be77a264d47 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1355,7 +1355,7 @@ static int __devinit snd_rme32_create(struct rme32 * rme32)
 	}
 
 	if (request_irq(pci->irq, snd_rme32_interrupt, IRQF_SHARED,
-			"RME32", rme32)) {
+			KBUILD_MODNAME, rme32)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 3c04524de37c..c7bcc63097f4 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1985,7 +1985,7 @@ static void __devexit snd_rme32_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver driver = {
-	.name =		"RME Digi32",
+	.name =		KBUILD_MODNAME,
 	.id_table =	snd_rme32_ids,
 	.probe =	snd_rme32_probe,
 	.remove =	__devexit_p(snd_rme32_remove),

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index d5e1c6eb7b7b..3c04524de37c 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -70,10 +70,10 @@
 
 
 #include <linux/delay.h>
+#include <linux/gfp.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
-#include <linux/slab.h>
 #include <linux/moduleparam.h>
 
 #include <sound/core.h>

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index f977dba7cbd0..d5e1c6eb7b7b 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -226,7 +226,7 @@ struct rme32 {
 	struct snd_kcontrol *spdif_ctl;
 };
 
-static struct pci_device_id snd_rme32_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_rme32_ids) = {
 	{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32), 0,},
 	{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_8), 0,},
 	{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_PRO), 0,},

commit 28d27aae9432c300857722a917be4065c6d7abff
Author: Joe Perches <joe@perches.com>
Date:   Wed Jun 24 22:13:35 2009 -0700

    sound: Use PCI_VDEVICE
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index d7b966e7c4cf..f977dba7cbd0 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -227,12 +227,9 @@ struct rme32 {
 };
 
 static struct pci_device_id snd_rme32_ids[] = {
-	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32,
-	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
-	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_8,
-	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
-	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_PRO,
-	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
+	{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32), 0,},
+	{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_8), 0,},
+	{PCI_VDEVICE(XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_PRO), 0,},
 	{0,}
 };
 

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index e7ef3a1a25a8..d7b966e7c4cf 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1941,9 +1941,10 @@ snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		return -ENOENT;
 	}
 
-	if ((card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-				 sizeof(struct rme32))) == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE,
+			      sizeof(struct rme32), &card);
+	if (err < 0)
+		return err;
 	card->private_free = snd_rme32_card_free;
 	rme32 = (struct rme32 *) card->private_data;
 	rme32->card = card;

commit 4db9e4f2b5278338ff9487eefdc8e32109aa0552
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Feb 28 11:57:23 2008 +0100

    [ALSA] sound: rme32.c fix integer as NULL pointer warning
    
    kernel style does assignment outside of if() statements.
    sound/pci/rme32.c:1353:71: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index df184aabce84..e7ef3a1a25a8 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1350,7 +1350,8 @@ static int __devinit snd_rme32_create(struct rme32 * rme32)
 		return err;
 	rme32->port = pci_resource_start(rme32->pci, 0);
 
-	if ((rme32->iobase = ioremap_nocache(rme32->port, RME32_IO_SIZE)) == 0) {
+	rme32->iobase = ioremap_nocache(rme32->port, RME32_IO_SIZE);
+	if (!rme32->iobase) {
 		snd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n",
 			   rme32->port, rme32->port + RME32_IO_SIZE - 1);
 		return -ENOMEM;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 1475912588e9..df184aabce84 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -69,7 +69,6 @@
  */
 
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit 918f3a0e8cf67b5db966516f255eaf24d814fac0
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:40:54 2007 +0200

    [ALSA] pcm: add snd_pcm_rate_to_rate_bit() helper
    
    Add a snd_pcm_rate_to_rate_bit() function to factor out common code used
    by several drivers.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index ee0189b756d1..1475912588e9 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -258,19 +258,6 @@ static inline unsigned int snd_rme32_pcm_byteptr(struct rme32 * rme32)
 		& RME32_RCR_AUDIO_ADDR_MASK);
 }
 
-static int snd_rme32_ratecode(int rate)
-{
-	switch (rate) {
-	case 32000: return SNDRV_PCM_RATE_32000;
-	case 44100: return SNDRV_PCM_RATE_44100;
-	case 48000: return SNDRV_PCM_RATE_48000;
-	case 64000: return SNDRV_PCM_RATE_64000;
-	case 88200: return SNDRV_PCM_RATE_88200;
-	case 96000: return SNDRV_PCM_RATE_96000;
-	}
-	return 0;
-}
-
 /* silence callback for halfduplex mode */
 static int snd_rme32_playback_silence(struct snd_pcm_substream *substream, int channel,	/* not used (interleaved data) */
 				      snd_pcm_uframes_t pos,
@@ -887,7 +874,7 @@ static int snd_rme32_playback_spdif_open(struct snd_pcm_substream *substream)
 	if ((rme32->rcreg & RME32_RCR_KMODE) &&
 	    (rate = snd_rme32_capture_getrate(rme32, &dummy)) > 0) {
 		/* AutoSync */
-		runtime->hw.rates = snd_rme32_ratecode(rate);
+		runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);
 		runtime->hw.rate_min = rate;
 		runtime->hw.rate_max = rate;
 	}       
@@ -929,7 +916,7 @@ static int snd_rme32_capture_spdif_open(struct snd_pcm_substream *substream)
 		if (isadat) {
 			return -EIO;
 		}
-		runtime->hw.rates = snd_rme32_ratecode(rate);
+		runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);
 		runtime->hw.rate_min = rate;
 		runtime->hw.rate_max = rate;
 	}
@@ -965,7 +952,7 @@ snd_rme32_playback_adat_open(struct snd_pcm_substream *substream)
 	if ((rme32->rcreg & RME32_RCR_KMODE) &&
 	    (rate = snd_rme32_capture_getrate(rme32, &dummy)) > 0) {
                 /* AutoSync */
-                runtime->hw.rates = snd_rme32_ratecode(rate);
+                runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);
                 runtime->hw.rate_min = rate;
                 runtime->hw.rate_max = rate;
 	}        
@@ -989,7 +976,7 @@ snd_rme32_capture_adat_open(struct snd_pcm_substream *substream)
 		if (!isadat) {
 			return -EIO;
 		}
-                runtime->hw.rates = snd_rme32_ratecode(rate);
+                runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);
                 runtime->hw.rate_min = rate;
                 runtime->hw.rate_max = rate;
         }

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 618653e22561..ee0189b756d1 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1582,16 +1582,8 @@ static void __devinit snd_rme32_proc_init(struct rme32 * rme32)
  * control interface
  */
 
-static int
-snd_rme32_info_loopback_control(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_rme32_info_loopback_control		snd_ctl_boolean_mono_info
+
 static int
 snd_rme32_get_loopback_control(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)

commit ef991b95aa1351a5782cfaccb9aefba76ca8b990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:52:53 2007 +0100

    [ALSA] Add snd_pcm_group_for_each_entry() for code cleanup
    
    Added a new macro snd_pcm_group_for_each_entry() just for code cleanup.
    Old macros, snd_pcm_group_for_each() and snd_pcm_group_substream_entry(),
    are removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 6bb7ac650ec4..618653e22561 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1078,12 +1078,10 @@ static int
 snd_rme32_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
-	struct list_head *pos;
 	struct snd_pcm_substream *s;
 
 	spin_lock(&rme32->lock);
-	snd_pcm_group_for_each(pos, substream) {
-		s = snd_pcm_group_substream_entry(pos);
+	snd_pcm_group_for_each_entry(s, substream) {
 		if (s != rme32->playback_substream &&
 		    s != rme32->capture_substream)
 			continue;
@@ -1110,8 +1108,7 @@ snd_rme32_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	
 	/* prefill playback buffer */
 	if (cmd == SNDRV_PCM_TRIGGER_START && rme32->fullduplex_mode) {
-		snd_pcm_group_for_each(pos, substream) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, substream) {
 			if (s == rme32->playback_substream) {
 				s->ops->ack(s);
 				break;

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index dc8d1302e22d..6bb7ac650ec4 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1373,7 +1373,8 @@ static int __devinit snd_rme32_create(struct rme32 * rme32)
 		return -ENOMEM;
 	}
 
-	if (request_irq(pci->irq, snd_rme32_interrupt, IRQF_DISABLED | IRQF_SHARED, "RME32", (void *) rme32)) {
+	if (request_irq(pci->irq, snd_rme32_interrupt, IRQF_SHARED,
+			"RME32", rme32)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 2a71499242fa..dc8d1302e22d 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -818,8 +818,7 @@ static void snd_rme32_pcm_stop(struct rme32 * rme32, int to_pause)
 		writel(0, rme32->iobase + RME32_IO_RESET_POS);
 }
 
-static irqreturn_t
-snd_rme32_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_rme32_interrupt(int irq, void *dev_id)
 {
 	struct rme32 *rme32 = (struct rme32 *) dev_id;
 

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 2e24b68d07aa..2a71499242fa 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -227,7 +227,7 @@ struct rme32 {
 	struct snd_kcontrol *spdif_ctl;
 };
 
-static struct pci_device_id snd_rme32_ids[] __devinitdata = {
+static struct pci_device_id snd_rme32_ids[] = {
 	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32,
 	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
 	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_8,

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 2cb9fe98db2f..2e24b68d07aa 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1374,7 +1374,7 @@ static int __devinit snd_rme32_create(struct rme32 * rme32)
 		return -ENOMEM;
 	}
 
-	if (request_irq(pci->irq, snd_rme32_interrupt, SA_INTERRUPT | SA_SHIRQ, "RME32", (void *) rme32)) {
+	if (request_irq(pci->irq, snd_rme32_interrupt, IRQF_DISABLED | IRQF_SHARED, "RME32", (void *) rme32)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 688956f23bdbfb1c3551bfafc819f989b36bb8ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 6 15:44:34 2006 +0200

    [ALSA] Fix races in irq handler and ioremap
    
    Call ioremap before request_irq for avoiding possible races
    in the irq handler.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 4dd53bfe0308..2cb9fe98db2f 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1368,18 +1368,18 @@ static int __devinit snd_rme32_create(struct rme32 * rme32)
 		return err;
 	rme32->port = pci_resource_start(rme32->pci, 0);
 
-	if (request_irq(pci->irq, snd_rme32_interrupt, SA_INTERRUPT | SA_SHIRQ, "RME32", (void *) rme32)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
-		return -EBUSY;
-	}
-	rme32->irq = pci->irq;
-
 	if ((rme32->iobase = ioremap_nocache(rme32->port, RME32_IO_SIZE)) == 0) {
 		snd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n",
 			   rme32->port, rme32->port + RME32_IO_SIZE - 1);
 		return -ENOMEM;
 	}
 
+	if (request_irq(pci->irq, snd_rme32_interrupt, SA_INTERRUPT | SA_SHIRQ, "RME32", (void *) rme32)) {
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		return -EBUSY;
+	}
+	rme32->irq = pci->irq;
+
 	/* read the card's revision number */
 	pci_read_config_byte(pci, 8, &rme32->rev);
 

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 55b1d4838d97..4dd53bfe0308 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1578,7 +1578,7 @@ static void __devinit snd_rme32_proc_init(struct rme32 * rme32)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(rme32->card, "rme32", &entry))
-		snd_info_set_text_ops(entry, rme32, 1024, snd_rme32_proc_read);
+		snd_info_set_text_ops(entry, rme32, snd_rme32_proc_read);
 }
 
 /*

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index ab78544bf042..55b1d4838d97 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -227,7 +227,7 @@ struct rme32 {
 	struct snd_kcontrol *spdif_ctl;
 };
 
-static struct pci_device_id snd_rme32_ids[] = {
+static struct pci_device_id snd_rme32_ids[] __devinitdata = {
 	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32,
 	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
 	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_8,

commit 7f927fcc2fd1575d01efb4b76665975007945690
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Mar 28 01:56:53 2006 -0800

    [PATCH] Typo fixes
    
    Fix a lot of typos.  Eyeballed by jmc@ in OpenBSD.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 0cbef5fe6c63..ab78544bf042 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -313,7 +313,7 @@ static int snd_rme32_capture_copy(struct snd_pcm_substream *substream, int chann
 }
 
 /*
- * SPDIF I/O capabilites (half-duplex mode)
+ * SPDIF I/O capabilities (half-duplex mode)
  */
 static struct snd_pcm_hardware snd_rme32_spdif_info = {
 	.info =		(SNDRV_PCM_INFO_MMAP_IOMEM |
@@ -339,7 +339,7 @@ static struct snd_pcm_hardware snd_rme32_spdif_info = {
 };
 
 /*
- * ADAT I/O capabilites (half-duplex mode)
+ * ADAT I/O capabilities (half-duplex mode)
  */
 static struct snd_pcm_hardware snd_rme32_adat_info =
 {
@@ -364,7 +364,7 @@ static struct snd_pcm_hardware snd_rme32_adat_info =
 };
 
 /*
- * SPDIF I/O capabilites (full-duplex mode)
+ * SPDIF I/O capabilities (full-duplex mode)
  */
 static struct snd_pcm_hardware snd_rme32_spdif_fd_info = {
 	.info =		(SNDRV_PCM_INFO_MMAP |
@@ -390,7 +390,7 @@ static struct snd_pcm_hardware snd_rme32_spdif_fd_info = {
 };
 
 /*
- * ADAT I/O capabilites (full-duplex mode)
+ * ADAT I/O capabilities (full-duplex mode)
  */
 static struct snd_pcm_hardware snd_rme32_adat_fd_info =
 {

commit 017ce80236c28bae9c2573307f1e76724232f287
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:05:25 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI RME32
    
    Modules: RME32 driver
    
    Remove xxx_t typedefs from the PCI RME32 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 783df7625c1c..0cbef5fe6c63 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -192,7 +192,7 @@ MODULE_SUPPORTED_DEVICE("{{RME,Digi32}," "{RME,Digi32/8}," "{RME,Digi32 PRO}}");
 #define RME32_PRO_REVISION_WITH_8414 150
 
 
-typedef struct snd_rme32 {
+struct rme32 {
 	spinlock_t lock;
 	int irq;
 	unsigned long port;
@@ -205,8 +205,8 @@ typedef struct snd_rme32 {
 
 	u8 rev;			/* card revision number */
 
-	snd_pcm_substream_t *playback_substream;
-	snd_pcm_substream_t *capture_substream;
+	struct snd_pcm_substream *playback_substream;
+	struct snd_pcm_substream *capture_substream;
 
 	int playback_frlog;	/* log2 of framesize */
 	int capture_frlog;
@@ -217,15 +217,15 @@ typedef struct snd_rme32 {
 	unsigned int fullduplex_mode;
 	int running;
 
-	snd_pcm_indirect_t playback_pcm;
-	snd_pcm_indirect_t capture_pcm;
+	struct snd_pcm_indirect playback_pcm;
+	struct snd_pcm_indirect capture_pcm;
 
-	snd_card_t *card;
-	snd_pcm_t *spdif_pcm;
-	snd_pcm_t *adat_pcm;
+	struct snd_card *card;
+	struct snd_pcm *spdif_pcm;
+	struct snd_pcm *adat_pcm;
 	struct pci_dev *pci;
-	snd_kcontrol_t *spdif_ctl;
-} rme32_t;
+	struct snd_kcontrol *spdif_ctl;
+};
 
 static struct pci_device_id snd_rme32_ids[] = {
 	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32,
@@ -242,17 +242,17 @@ MODULE_DEVICE_TABLE(pci, snd_rme32_ids);
 #define RME32_ISWORKING(rme32) ((rme32)->wcreg & RME32_WCR_START)
 #define RME32_PRO_WITH_8414(rme32) ((rme32)->pci->device == PCI_DEVICE_ID_RME_DIGI32_PRO && (rme32)->rev == RME32_PRO_REVISION_WITH_8414)
 
-static int snd_rme32_playback_prepare(snd_pcm_substream_t * substream);
+static int snd_rme32_playback_prepare(struct snd_pcm_substream *substream);
 
-static int snd_rme32_capture_prepare(snd_pcm_substream_t * substream);
+static int snd_rme32_capture_prepare(struct snd_pcm_substream *substream);
 
-static int snd_rme32_pcm_trigger(snd_pcm_substream_t * substream, int cmd);
+static int snd_rme32_pcm_trigger(struct snd_pcm_substream *substream, int cmd);
 
-static void snd_rme32_proc_init(rme32_t * rme32);
+static void snd_rme32_proc_init(struct rme32 * rme32);
 
-static int snd_rme32_create_switches(snd_card_t * card, rme32_t * rme32);
+static int snd_rme32_create_switches(struct snd_card *card, struct rme32 * rme32);
 
-static inline unsigned int snd_rme32_pcm_byteptr(rme32_t * rme32)
+static inline unsigned int snd_rme32_pcm_byteptr(struct rme32 * rme32)
 {
 	return (readl(rme32->iobase + RME32_IO_GET_POS)
 		& RME32_RCR_AUDIO_ADDR_MASK);
@@ -272,11 +272,11 @@ static int snd_rme32_ratecode(int rate)
 }
 
 /* silence callback for halfduplex mode */
-static int snd_rme32_playback_silence(snd_pcm_substream_t * substream, int channel,	/* not used (interleaved data) */
+static int snd_rme32_playback_silence(struct snd_pcm_substream *substream, int channel,	/* not used (interleaved data) */
 				      snd_pcm_uframes_t pos,
 				      snd_pcm_uframes_t count)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	count <<= rme32->playback_frlog;
 	pos <<= rme32->playback_frlog;
 	memset_io(rme32->iobase + RME32_IO_DATA_BUFFER + pos, 0, count);
@@ -284,11 +284,11 @@ static int snd_rme32_playback_silence(snd_pcm_substream_t * substream, int chann
 }
 
 /* copy callback for halfduplex mode */
-static int snd_rme32_playback_copy(snd_pcm_substream_t * substream, int channel,	/* not used (interleaved data) */
+static int snd_rme32_playback_copy(struct snd_pcm_substream *substream, int channel,	/* not used (interleaved data) */
 				   snd_pcm_uframes_t pos,
 				   void __user *src, snd_pcm_uframes_t count)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	count <<= rme32->playback_frlog;
 	pos <<= rme32->playback_frlog;
 	if (copy_from_user_toio(rme32->iobase + RME32_IO_DATA_BUFFER + pos,
@@ -298,11 +298,11 @@ static int snd_rme32_playback_copy(snd_pcm_substream_t * substream, int channel,
 }
 
 /* copy callback for halfduplex mode */
-static int snd_rme32_capture_copy(snd_pcm_substream_t * substream, int channel,	/* not used (interleaved data) */
+static int snd_rme32_capture_copy(struct snd_pcm_substream *substream, int channel,	/* not used (interleaved data) */
 				  snd_pcm_uframes_t pos,
 				  void __user *dst, snd_pcm_uframes_t count)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	count <<= rme32->capture_frlog;
 	pos <<= rme32->capture_frlog;
 	if (copy_to_user_fromio(dst,
@@ -315,7 +315,7 @@ static int snd_rme32_capture_copy(snd_pcm_substream_t * substream, int channel,
 /*
  * SPDIF I/O capabilites (half-duplex mode)
  */
-static snd_pcm_hardware_t snd_rme32_spdif_info = {
+static struct snd_pcm_hardware snd_rme32_spdif_info = {
 	.info =		(SNDRV_PCM_INFO_MMAP_IOMEM |
 			 SNDRV_PCM_INFO_MMAP_VALID |
 			 SNDRV_PCM_INFO_INTERLEAVED | 
@@ -341,7 +341,7 @@ static snd_pcm_hardware_t snd_rme32_spdif_info = {
 /*
  * ADAT I/O capabilites (half-duplex mode)
  */
-static snd_pcm_hardware_t snd_rme32_adat_info =
+static struct snd_pcm_hardware snd_rme32_adat_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -366,7 +366,7 @@ static snd_pcm_hardware_t snd_rme32_adat_info =
 /*
  * SPDIF I/O capabilites (full-duplex mode)
  */
-static snd_pcm_hardware_t snd_rme32_spdif_fd_info = {
+static struct snd_pcm_hardware snd_rme32_spdif_fd_info = {
 	.info =		(SNDRV_PCM_INFO_MMAP |
 			 SNDRV_PCM_INFO_MMAP_VALID |
 			 SNDRV_PCM_INFO_INTERLEAVED | 
@@ -392,7 +392,7 @@ static snd_pcm_hardware_t snd_rme32_spdif_fd_info = {
 /*
  * ADAT I/O capabilites (full-duplex mode)
  */
-static snd_pcm_hardware_t snd_rme32_adat_fd_info =
+static struct snd_pcm_hardware snd_rme32_adat_fd_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -414,14 +414,14 @@ static snd_pcm_hardware_t snd_rme32_adat_fd_info =
 	.fifo_size =	    0,
 };
 
-static void snd_rme32_reset_dac(rme32_t *rme32)
+static void snd_rme32_reset_dac(struct rme32 *rme32)
 {
         writel(rme32->wcreg | RME32_WCR_PD,
                rme32->iobase + RME32_IO_CONTROL_REGISTER);
         writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
 }
 
-static int snd_rme32_playback_getrate(rme32_t * rme32)
+static int snd_rme32_playback_getrate(struct rme32 * rme32)
 {
 	int rate;
 
@@ -443,7 +443,7 @@ static int snd_rme32_playback_getrate(rme32_t * rme32)
 	return (rme32->wcreg & RME32_WCR_DS_BM) ? rate << 1 : rate;
 }
 
-static int snd_rme32_capture_getrate(rme32_t * rme32, int *is_adat)
+static int snd_rme32_capture_getrate(struct rme32 * rme32, int *is_adat)
 {
 	int n;
 
@@ -505,7 +505,7 @@ static int snd_rme32_capture_getrate(rme32_t * rme32, int *is_adat)
 	return -1;
 }
 
-static int snd_rme32_playback_setrate(rme32_t * rme32, int rate)
+static int snd_rme32_playback_setrate(struct rme32 * rme32, int rate)
 {
         int ds;
 
@@ -561,7 +561,7 @@ static int snd_rme32_playback_setrate(rme32_t * rme32, int rate)
 	return 0;
 }
 
-static int snd_rme32_setclockmode(rme32_t * rme32, int mode)
+static int snd_rme32_setclockmode(struct rme32 * rme32, int mode)
 {
 	switch (mode) {
 	case RME32_CLOCKMODE_SLAVE:
@@ -591,13 +591,13 @@ static int snd_rme32_setclockmode(rme32_t * rme32, int mode)
 	return 0;
 }
 
-static int snd_rme32_getclockmode(rme32_t * rme32)
+static int snd_rme32_getclockmode(struct rme32 * rme32)
 {
 	return ((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_0) & 1) +
 	    (((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_1) & 1) << 1);
 }
 
-static int snd_rme32_setinputtype(rme32_t * rme32, int type)
+static int snd_rme32_setinputtype(struct rme32 * rme32, int type)
 {
 	switch (type) {
 	case RME32_INPUT_OPTICAL:
@@ -623,14 +623,14 @@ static int snd_rme32_setinputtype(rme32_t * rme32, int type)
 	return 0;
 }
 
-static int snd_rme32_getinputtype(rme32_t * rme32)
+static int snd_rme32_getinputtype(struct rme32 * rme32)
 {
 	return ((rme32->wcreg >> RME32_WCR_BITPOS_INP_0) & 1) +
 	    (((rme32->wcreg >> RME32_WCR_BITPOS_INP_1) & 1) << 1);
 }
 
 static void
-snd_rme32_setframelog(rme32_t * rme32, int n_channels, int is_playback)
+snd_rme32_setframelog(struct rme32 * rme32, int n_channels, int is_playback)
 {
 	int frlog;
 
@@ -649,7 +649,7 @@ snd_rme32_setframelog(rme32_t * rme32, int n_channels, int is_playback)
 	}
 }
 
-static int snd_rme32_setformat(rme32_t * rme32, int format)
+static int snd_rme32_setformat(struct rme32 * rme32, int format)
 {
 	switch (format) {
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -666,12 +666,12 @@ static int snd_rme32_setformat(rme32_t * rme32, int format)
 }
 
 static int
-snd_rme32_playback_hw_params(snd_pcm_substream_t * substream,
-			     snd_pcm_hw_params_t * params)
+snd_rme32_playback_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params)
 {
 	int err, rate, dummy;
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	if (rme32->fullduplex_mode) {
 		err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
@@ -721,12 +721,12 @@ snd_rme32_playback_hw_params(snd_pcm_substream_t * substream,
 }
 
 static int
-snd_rme32_capture_hw_params(snd_pcm_substream_t * substream,
-			    snd_pcm_hw_params_t * params)
+snd_rme32_capture_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params)
 {
 	int err, isadat, rate;
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	if (rme32->fullduplex_mode) {
 		err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
@@ -782,15 +782,15 @@ snd_rme32_capture_hw_params(snd_pcm_substream_t * substream,
 	return 0;
 }
 
-static int snd_rme32_pcm_hw_free(snd_pcm_substream_t * substream)
+static int snd_rme32_pcm_hw_free(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	if (! rme32->fullduplex_mode)
 		return 0;
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static void snd_rme32_pcm_start(rme32_t * rme32, int from_pause)
+static void snd_rme32_pcm_start(struct rme32 * rme32, int from_pause)
 {
 	if (!from_pause) {
 		writel(0, rme32->iobase + RME32_IO_RESET_POS);
@@ -800,7 +800,7 @@ static void snd_rme32_pcm_start(rme32_t * rme32, int from_pause)
 	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
 }
 
-static void snd_rme32_pcm_stop(rme32_t * rme32, int to_pause)
+static void snd_rme32_pcm_stop(struct rme32 * rme32, int to_pause)
 {
 	/*
 	 * Check if there is an unconfirmed IRQ, if so confirm it, or else
@@ -821,7 +821,7 @@ static void snd_rme32_pcm_stop(rme32_t * rme32, int to_pause)
 static irqreturn_t
 snd_rme32_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	rme32_t *rme32 = (rme32_t *) dev_id;
+	struct rme32 *rme32 = (struct rme32 *) dev_id;
 
 	rme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);
 	if (!(rme32->rcreg & RME32_RCR_IRQ)) {
@@ -841,13 +841,13 @@ snd_rme32_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 static unsigned int period_bytes[] = { RME32_BLOCK_SIZE };
 
 
-static snd_pcm_hw_constraint_list_t hw_constraints_period_bytes = {
+static struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {
 	.count = ARRAY_SIZE(period_bytes),
 	.list = period_bytes,
 	.mask = 0
 };
 
-static void snd_rme32_set_buffer_constraint(rme32_t *rme32, snd_pcm_runtime_t *runtime)
+static void snd_rme32_set_buffer_constraint(struct rme32 *rme32, struct snd_pcm_runtime *runtime)
 {
 	if (! rme32->fullduplex_mode) {
 		snd_pcm_hw_constraint_minmax(runtime,
@@ -859,11 +859,11 @@ static void snd_rme32_set_buffer_constraint(rme32_t *rme32, snd_pcm_runtime_t *r
 	}
 }
 
-static int snd_rme32_playback_spdif_open(snd_pcm_substream_t * substream)
+static int snd_rme32_playback_spdif_open(struct snd_pcm_substream *substream)
 {
 	int rate, dummy;
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	snd_pcm_set_sync(substream);
 
@@ -902,11 +902,11 @@ static int snd_rme32_playback_spdif_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_rme32_capture_spdif_open(snd_pcm_substream_t * substream)
+static int snd_rme32_capture_spdif_open(struct snd_pcm_substream *substream)
 {
 	int isadat, rate;
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	snd_pcm_set_sync(substream);
 
@@ -941,11 +941,11 @@ static int snd_rme32_capture_spdif_open(snd_pcm_substream_t * substream)
 }
 
 static int
-snd_rme32_playback_adat_open(snd_pcm_substream_t *substream)
+snd_rme32_playback_adat_open(struct snd_pcm_substream *substream)
 {
 	int rate, dummy;
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	
 	snd_pcm_set_sync(substream);
 
@@ -976,11 +976,11 @@ snd_rme32_playback_adat_open(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_rme32_capture_adat_open(snd_pcm_substream_t *substream)
+snd_rme32_capture_adat_open(struct snd_pcm_substream *substream)
 {
 	int isadat, rate;
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	if (rme32->fullduplex_mode)
 		runtime->hw = snd_rme32_adat_fd_info;
@@ -1009,9 +1009,9 @@ snd_rme32_capture_adat_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_rme32_playback_close(snd_pcm_substream_t * substream)
+static int snd_rme32_playback_close(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	int spdif = 0;
 
 	spin_lock_irq(&rme32->lock);
@@ -1028,9 +1028,9 @@ static int snd_rme32_playback_close(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_rme32_capture_close(snd_pcm_substream_t * substream)
+static int snd_rme32_capture_close(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&rme32->lock);
 	rme32->capture_substream = NULL;
@@ -1039,9 +1039,9 @@ static int snd_rme32_capture_close(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_rme32_playback_prepare(snd_pcm_substream_t * substream)
+static int snd_rme32_playback_prepare(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&rme32->lock);
 	if (rme32->fullduplex_mode) {
@@ -1058,9 +1058,9 @@ static int snd_rme32_playback_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_rme32_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_rme32_capture_prepare(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&rme32->lock);
 	if (rme32->fullduplex_mode) {
@@ -1076,11 +1076,11 @@ static int snd_rme32_capture_prepare(snd_pcm_substream_t * substream)
 }
 
 static int
-snd_rme32_pcm_trigger(snd_pcm_substream_t * substream, int cmd)
+snd_rme32_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	struct list_head *pos;
-	snd_pcm_substream_t *s;
+	struct snd_pcm_substream *s;
 
 	spin_lock(&rme32->lock);
 	snd_pcm_group_for_each(pos, substream) {
@@ -1144,33 +1144,33 @@ snd_rme32_pcm_trigger(snd_pcm_substream_t * substream, int cmd)
 
 /* pointer callback for halfduplex mode */
 static snd_pcm_uframes_t
-snd_rme32_playback_pointer(snd_pcm_substream_t * substream)
+snd_rme32_playback_pointer(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	return snd_rme32_pcm_byteptr(rme32) >> rme32->playback_frlog;
 }
 
 static snd_pcm_uframes_t
-snd_rme32_capture_pointer(snd_pcm_substream_t * substream)
+snd_rme32_capture_pointer(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	return snd_rme32_pcm_byteptr(rme32) >> rme32->capture_frlog;
 }
 
 
 /* ack and pointer callbacks for fullduplex mode */
-static void snd_rme32_pb_trans_copy(snd_pcm_substream_t *substream,
-				    snd_pcm_indirect_t *rec, size_t bytes)
+static void snd_rme32_pb_trans_copy(struct snd_pcm_substream *substream,
+				    struct snd_pcm_indirect *rec, size_t bytes)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	memcpy_toio(rme32->iobase + RME32_IO_DATA_BUFFER + rec->hw_data,
 		    substream->runtime->dma_area + rec->sw_data, bytes);
 }
 
-static int snd_rme32_playback_fd_ack(snd_pcm_substream_t *substream)
+static int snd_rme32_playback_fd_ack(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
-	snd_pcm_indirect_t *rec, *cprec;
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_indirect *rec, *cprec;
 
 	rec = &rme32->playback_pcm;
 	cprec = &rme32->capture_pcm;
@@ -1184,41 +1184,41 @@ static int snd_rme32_playback_fd_ack(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static void snd_rme32_cp_trans_copy(snd_pcm_substream_t *substream,
-				    snd_pcm_indirect_t *rec, size_t bytes)
+static void snd_rme32_cp_trans_copy(struct snd_pcm_substream *substream,
+				    struct snd_pcm_indirect *rec, size_t bytes)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	memcpy_fromio(substream->runtime->dma_area + rec->sw_data,
 		      rme32->iobase + RME32_IO_DATA_BUFFER + rec->hw_data,
 		      bytes);
 }
 
-static int snd_rme32_capture_fd_ack(snd_pcm_substream_t *substream)
+static int snd_rme32_capture_fd_ack(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	snd_pcm_indirect_capture_transfer(substream, &rme32->capture_pcm,
 					  snd_rme32_cp_trans_copy);
 	return 0;
 }
 
 static snd_pcm_uframes_t
-snd_rme32_playback_fd_pointer(snd_pcm_substream_t * substream)
+snd_rme32_playback_fd_pointer(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	return snd_pcm_indirect_playback_pointer(substream, &rme32->playback_pcm,
 						 snd_rme32_pcm_byteptr(rme32));
 }
 
 static snd_pcm_uframes_t
-snd_rme32_capture_fd_pointer(snd_pcm_substream_t * substream)
+snd_rme32_capture_fd_pointer(struct snd_pcm_substream *substream)
 {
-	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct rme32 *rme32 = snd_pcm_substream_chip(substream);
 	return snd_pcm_indirect_capture_pointer(substream, &rme32->capture_pcm,
 						snd_rme32_pcm_byteptr(rme32));
 }
 
 /* for halfduplex mode */
-static snd_pcm_ops_t snd_rme32_playback_spdif_ops = {
+static struct snd_pcm_ops snd_rme32_playback_spdif_ops = {
 	.open =		snd_rme32_playback_spdif_open,
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1232,7 +1232,7 @@ static snd_pcm_ops_t snd_rme32_playback_spdif_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static snd_pcm_ops_t snd_rme32_capture_spdif_ops = {
+static struct snd_pcm_ops snd_rme32_capture_spdif_ops = {
 	.open =		snd_rme32_capture_spdif_open,
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1245,7 +1245,7 @@ static snd_pcm_ops_t snd_rme32_capture_spdif_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static snd_pcm_ops_t snd_rme32_playback_adat_ops = {
+static struct snd_pcm_ops snd_rme32_playback_adat_ops = {
 	.open =		snd_rme32_playback_adat_open,
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1258,7 +1258,7 @@ static snd_pcm_ops_t snd_rme32_playback_adat_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static snd_pcm_ops_t snd_rme32_capture_adat_ops = {
+static struct snd_pcm_ops snd_rme32_capture_adat_ops = {
 	.open =		snd_rme32_capture_adat_open,
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1271,7 +1271,7 @@ static snd_pcm_ops_t snd_rme32_capture_adat_ops = {
 };
 
 /* for fullduplex mode */
-static snd_pcm_ops_t snd_rme32_playback_spdif_fd_ops = {
+static struct snd_pcm_ops snd_rme32_playback_spdif_fd_ops = {
 	.open =		snd_rme32_playback_spdif_open,
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1283,7 +1283,7 @@ static snd_pcm_ops_t snd_rme32_playback_spdif_fd_ops = {
 	.ack =		snd_rme32_playback_fd_ack,
 };
 
-static snd_pcm_ops_t snd_rme32_capture_spdif_fd_ops = {
+static struct snd_pcm_ops snd_rme32_capture_spdif_fd_ops = {
 	.open =		snd_rme32_capture_spdif_open,
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1295,7 +1295,7 @@ static snd_pcm_ops_t snd_rme32_capture_spdif_fd_ops = {
 	.ack =		snd_rme32_capture_fd_ack,
 };
 
-static snd_pcm_ops_t snd_rme32_playback_adat_fd_ops = {
+static struct snd_pcm_ops snd_rme32_playback_adat_fd_ops = {
 	.open =		snd_rme32_playback_adat_open,
 	.close =	snd_rme32_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1306,7 +1306,7 @@ static snd_pcm_ops_t snd_rme32_playback_adat_fd_ops = {
 	.ack =		snd_rme32_playback_fd_ack,
 };
 
-static snd_pcm_ops_t snd_rme32_capture_adat_fd_ops = {
+static struct snd_pcm_ops snd_rme32_capture_adat_fd_ops = {
 	.open =		snd_rme32_capture_adat_open,
 	.close =	snd_rme32_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1319,7 +1319,7 @@ static snd_pcm_ops_t snd_rme32_capture_adat_fd_ops = {
 
 static void snd_rme32_free(void *private_data)
 {
-	rme32_t *rme32 = (rme32_t *) private_data;
+	struct rme32 *rme32 = (struct rme32 *) private_data;
 
 	if (rme32 == NULL) {
 		return;
@@ -1340,20 +1340,20 @@ static void snd_rme32_free(void *private_data)
 	pci_disable_device(rme32->pci);
 }
 
-static void snd_rme32_free_spdif_pcm(snd_pcm_t * pcm)
+static void snd_rme32_free_spdif_pcm(struct snd_pcm *pcm)
 {
-	rme32_t *rme32 = (rme32_t *) pcm->private_data;
+	struct rme32 *rme32 = (struct rme32 *) pcm->private_data;
 	rme32->spdif_pcm = NULL;
 }
 
 static void
-snd_rme32_free_adat_pcm(snd_pcm_t *pcm)
+snd_rme32_free_adat_pcm(struct snd_pcm *pcm)
 {
-	rme32_t *rme32 = (rme32_t *) pcm->private_data;
+	struct rme32 *rme32 = (struct rme32 *) pcm->private_data;
 	rme32->adat_pcm = NULL;
 }
 
-static int __devinit snd_rme32_create(rme32_t * rme32)
+static int __devinit snd_rme32_create(struct rme32 * rme32)
 {
 	struct pci_dev *pci = rme32->pci;
 	int err;
@@ -1479,10 +1479,10 @@ static int __devinit snd_rme32_create(rme32_t * rme32)
  */
 
 static void
-snd_rme32_proc_read(snd_info_entry_t * entry, snd_info_buffer_t * buffer)
+snd_rme32_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffer)
 {
 	int n;
-	rme32_t *rme32 = (rme32_t *) entry->private_data;
+	struct rme32 *rme32 = (struct rme32 *) entry->private_data;
 
 	rme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);
 
@@ -1573,9 +1573,9 @@ snd_rme32_proc_read(snd_info_entry_t * entry, snd_info_buffer_t * buffer)
 	}
 }
 
-static void __devinit snd_rme32_proc_init(rme32_t * rme32)
+static void __devinit snd_rme32_proc_init(struct rme32 * rme32)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(rme32->card, "rme32", &entry))
 		snd_info_set_text_ops(entry, rme32, 1024, snd_rme32_proc_read);
@@ -1586,8 +1586,8 @@ static void __devinit snd_rme32_proc_init(rme32_t * rme32)
  */
 
 static int
-snd_rme32_info_loopback_control(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_info_t * uinfo)
+snd_rme32_info_loopback_control(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1596,10 +1596,10 @@ snd_rme32_info_loopback_control(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 static int
-snd_rme32_get_loopback_control(snd_kcontrol_t * kcontrol,
-			       snd_ctl_elem_value_t * ucontrol)
+snd_rme32_get_loopback_control(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&rme32->lock);
 	ucontrol->value.integer.value[0] =
@@ -1608,10 +1608,10 @@ snd_rme32_get_loopback_control(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 static int
-snd_rme32_put_loopback_control(snd_kcontrol_t * kcontrol,
-			       snd_ctl_elem_value_t * ucontrol)
+snd_rme32_put_loopback_control(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 
@@ -1630,10 +1630,10 @@ snd_rme32_put_loopback_control(snd_kcontrol_t * kcontrol,
 }
 
 static int
-snd_rme32_info_inputtype_control(snd_kcontrol_t * kcontrol,
-				 snd_ctl_elem_info_t * uinfo)
+snd_rme32_info_inputtype_control(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 	static char *texts[4] = { "Optical", "Coaxial", "Internal", "XLR" };
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
@@ -1660,10 +1660,10 @@ snd_rme32_info_inputtype_control(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 static int
-snd_rme32_get_inputtype_control(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_value_t * ucontrol)
+snd_rme32_get_inputtype_control(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 	unsigned int items = 3;
 
 	spin_lock_irq(&rme32->lock);
@@ -1689,10 +1689,10 @@ snd_rme32_get_inputtype_control(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 static int
-snd_rme32_put_inputtype_control(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_value_t * ucontrol)
+snd_rme32_put_inputtype_control(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change, items = 3;
 
@@ -1718,8 +1718,8 @@ snd_rme32_put_inputtype_control(snd_kcontrol_t * kcontrol,
 }
 
 static int
-snd_rme32_info_clockmode_control(snd_kcontrol_t * kcontrol,
-				 snd_ctl_elem_info_t * uinfo)
+snd_rme32_info_clockmode_control(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[4] = { "AutoSync", 
 				  "Internal 32.0kHz", 
@@ -1737,10 +1737,10 @@ snd_rme32_info_clockmode_control(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 static int
-snd_rme32_get_clockmode_control(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_value_t * ucontrol)
+snd_rme32_get_clockmode_control(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&rme32->lock);
 	ucontrol->value.enumerated.item[0] = snd_rme32_getclockmode(rme32);
@@ -1748,10 +1748,10 @@ snd_rme32_get_clockmode_control(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 static int
-snd_rme32_put_clockmode_control(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_value_t * ucontrol)
+snd_rme32_put_clockmode_control(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 
@@ -1763,7 +1763,7 @@ snd_rme32_put_clockmode_control(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static u32 snd_rme32_convert_from_aes(snd_aes_iec958_t * aes)
+static u32 snd_rme32_convert_from_aes(struct snd_aes_iec958 * aes)
 {
 	u32 val = 0;
 	val |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME32_WCR_PRO : 0;
@@ -1774,7 +1774,7 @@ static u32 snd_rme32_convert_from_aes(snd_aes_iec958_t * aes)
 	return val;
 }
 
-static void snd_rme32_convert_to_aes(snd_aes_iec958_t * aes, u32 val)
+static void snd_rme32_convert_to_aes(struct snd_aes_iec958 * aes, u32 val)
 {
 	aes->status[0] = ((val & RME32_WCR_PRO) ? IEC958_AES0_PROFESSIONAL : 0);
 	if (val & RME32_WCR_PRO)
@@ -1783,28 +1783,28 @@ static void snd_rme32_convert_to_aes(snd_aes_iec958_t * aes, u32 val)
 		aes->status[0] |= (val & RME32_WCR_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;
 }
 
-static int snd_rme32_control_spdif_info(snd_kcontrol_t * kcontrol,
-					snd_ctl_elem_info_t * uinfo)
+static int snd_rme32_control_spdif_info(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_rme32_control_spdif_get(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_value_t * ucontrol)
+static int snd_rme32_control_spdif_get(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 
 	snd_rme32_convert_to_aes(&ucontrol->value.iec958,
 				 rme32->wcreg_spdif);
 	return 0;
 }
 
-static int snd_rme32_control_spdif_put(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_value_t * ucontrol)
+static int snd_rme32_control_spdif_put(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 	int change;
 	u32 val;
 
@@ -1816,30 +1816,30 @@ static int snd_rme32_control_spdif_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static int snd_rme32_control_spdif_stream_info(snd_kcontrol_t * kcontrol,
-					       snd_ctl_elem_info_t * uinfo)
+static int snd_rme32_control_spdif_stream_info(struct snd_kcontrol *kcontrol,
+					       struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_rme32_control_spdif_stream_get(snd_kcontrol_t * kcontrol,
-					      snd_ctl_elem_value_t *
+static int snd_rme32_control_spdif_stream_get(struct snd_kcontrol *kcontrol,
+					      struct snd_ctl_elem_value *
 					      ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 
 	snd_rme32_convert_to_aes(&ucontrol->value.iec958,
 				 rme32->wcreg_spdif_stream);
 	return 0;
 }
 
-static int snd_rme32_control_spdif_stream_put(snd_kcontrol_t * kcontrol,
-					      snd_ctl_elem_value_t *
+static int snd_rme32_control_spdif_stream_put(struct snd_kcontrol *kcontrol,
+					      struct snd_ctl_elem_value *
 					      ucontrol)
 {
-	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	struct rme32 *rme32 = snd_kcontrol_chip(kcontrol);
 	int change;
 	u32 val;
 
@@ -1854,23 +1854,23 @@ static int snd_rme32_control_spdif_stream_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static int snd_rme32_control_spdif_mask_info(snd_kcontrol_t * kcontrol,
-					     snd_ctl_elem_info_t * uinfo)
+static int snd_rme32_control_spdif_mask_info(struct snd_kcontrol *kcontrol,
+					     struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_rme32_control_spdif_mask_get(snd_kcontrol_t * kcontrol,
-					    snd_ctl_elem_value_t *
+static int snd_rme32_control_spdif_mask_get(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_value *
 					    ucontrol)
 {
 	ucontrol->value.iec958.status[0] = kcontrol->private_value;
 	return 0;
 }
 
-static snd_kcontrol_new_t snd_rme32_controls[] = {
+static struct snd_kcontrol_new snd_rme32_controls[] = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
@@ -1925,10 +1925,10 @@ static snd_kcontrol_new_t snd_rme32_controls[] = {
 	}
 };
 
-static int snd_rme32_create_switches(snd_card_t * card, rme32_t * rme32)
+static int snd_rme32_create_switches(struct snd_card *card, struct rme32 * rme32)
 {
 	int idx, err;
-	snd_kcontrol_t *kctl;
+	struct snd_kcontrol *kctl;
 
 	for (idx = 0; idx < (int)ARRAY_SIZE(snd_rme32_controls); idx++) {
 		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme32_controls[idx], rme32))) < 0)
@@ -1944,7 +1944,7 @@ static int snd_rme32_create_switches(snd_card_t * card, rme32_t * rme32)
  * Card initialisation
  */
 
-static void snd_rme32_card_free(snd_card_t * card)
+static void snd_rme32_card_free(struct snd_card *card)
 {
 	snd_rme32_free(card->private_data);
 }
@@ -1953,8 +1953,8 @@ static int __devinit
 snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 {
 	static int dev;
-	rme32_t *rme32;
-	snd_card_t *card;
+	struct rme32 *rme32;
+	struct snd_card *card;
 	int err;
 
 	if (dev >= SNDRV_CARDS) {
@@ -1966,10 +1966,10 @@ snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 	}
 
 	if ((card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-				 sizeof(rme32_t))) == NULL)
+				 sizeof(struct rme32))) == NULL)
 		return -ENOMEM;
 	card->private_free = snd_rme32_card_free;
-	rme32 = (rme32_t *) card->private_data;
+	rme32 = (struct rme32 *) card->private_data;
 	rme32->card = card;
 	rme32->pci = pci;
 	snd_card_set_dev(card, &pci->dev);

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index e6627b0e38e4..783df7625c1c 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -2012,7 +2012,6 @@ static void __devexit snd_rme32_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name =		"RME Digi32",
-	.owner =	THIS_MODULE,
 	.id_table =	snd_rme32_ids,
 	.probe =	snd_rme32_probe,
 	.remove =	__devexit_p(snd_rme32_remove),

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index cd313af6ebcf..e6627b0e38e4 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1369,13 +1369,13 @@ static int __devinit snd_rme32_create(rme32_t * rme32)
 	rme32->port = pci_resource_start(rme32->pci, 0);
 
 	if (request_irq(pci->irq, snd_rme32_interrupt, SA_INTERRUPT | SA_SHIRQ, "RME32", (void *) rme32)) {
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}
 	rme32->irq = pci->irq;
 
 	if ((rme32->iobase = ioremap_nocache(rme32->port, RME32_IO_SIZE)) == 0) {
-		snd_printk("unable to remap memory region 0x%lx-0x%lx\n",
+		snd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n",
 			   rme32->port, rme32->port + RME32_IO_SIZE - 1);
 		return -ENOMEM;
 	}

commit 8b7fc4214b550fafe595330e28d7c2c72b8b62f6
Author: Roland Dreier <rolandd@cisco.com>
Date:   Wed Sep 14 14:19:17 2005 -0700

    [PATCH] add PCI IDs so RME32 and RME96 drivers build
    
    While doing an allyesconfig build, I noticed that the commit
    
        commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
        Author: Takashi Iwai <tiwai@suse.de>
        Date:   Wed Sep 7 14:08:11 2005 +0200
    
            [ALSA] Remove superfluous PCI ID definitions
    
    broke the RME32 and RME96 drivers, since the PCI IDs they use seem to have
    changed names.  Here's a patch to fix this -- compile tested only, since I
    have no idea what the hardware even is.
    
    Fix the build of the RME32 and RME96 drivers by having them use the
    PCI_DEVICE_ID_RME_xxx names defined in <linux/pci_ids.h> instead of the
    PCI_DEVICE_ID_xxx names that they used to define themselves.
    
    Also fix the typo in the id PCI_DEVICE_IDRME__DIGI96_8_PAD_OR_PST so the
    name is PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST.
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 3daeecb9eb0e..cd313af6ebcf 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -228,11 +228,11 @@ typedef struct snd_rme32 {
 } rme32_t;
 
 static struct pci_device_id snd_rme32_ids[] = {
-	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_DIGI32,
+	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32,
 	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
-	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_DIGI32_8,
+	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_8,
 	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
-	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_DIGI32_PRO,
+	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_RME_DIGI32_PRO,
 	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
 	{0,}
 };
@@ -240,7 +240,7 @@ static struct pci_device_id snd_rme32_ids[] = {
 MODULE_DEVICE_TABLE(pci, snd_rme32_ids);
 
 #define RME32_ISWORKING(rme32) ((rme32)->wcreg & RME32_WCR_START)
-#define RME32_PRO_WITH_8414(rme32) ((rme32)->pci->device == PCI_DEVICE_ID_DIGI32_PRO && (rme32)->rev == RME32_PRO_REVISION_WITH_8414)
+#define RME32_PRO_WITH_8414(rme32) ((rme32)->pci->device == PCI_DEVICE_ID_RME_DIGI32_PRO && (rme32)->rev == RME32_PRO_REVISION_WITH_8414)
 
 static int snd_rme32_playback_prepare(snd_pcm_substream_t * substream);
 
@@ -527,21 +527,21 @@ static int snd_rme32_playback_setrate(rme32_t * rme32, int rate)
 			RME32_WCR_FREQ_1;
 		break;
 	case 64000:
-		if (rme32->pci->device != PCI_DEVICE_ID_DIGI32_PRO)
+		if (rme32->pci->device != PCI_DEVICE_ID_RME_DIGI32_PRO)
 			return -EINVAL;
 		rme32->wcreg |= RME32_WCR_DS_BM;
 		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & 
 			~RME32_WCR_FREQ_1;
 		break;
 	case 88200:
-		if (rme32->pci->device != PCI_DEVICE_ID_DIGI32_PRO)
+		if (rme32->pci->device != PCI_DEVICE_ID_RME_DIGI32_PRO)
 			return -EINVAL;
 		rme32->wcreg |= RME32_WCR_DS_BM;
 		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) & 
 			~RME32_WCR_FREQ_0;
 		break;
 	case 96000:
-		if (rme32->pci->device != PCI_DEVICE_ID_DIGI32_PRO)
+		if (rme32->pci->device != PCI_DEVICE_ID_RME_DIGI32_PRO)
 			return -EINVAL;
 		rme32->wcreg |= RME32_WCR_DS_BM;
 		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | 
@@ -881,7 +881,7 @@ static int snd_rme32_playback_spdif_open(snd_pcm_substream_t * substream)
 		runtime->hw = snd_rme32_spdif_fd_info;
 	else
 		runtime->hw = snd_rme32_spdif_info;
-	if (rme32->pci->device == PCI_DEVICE_ID_DIGI32_PRO) {
+	if (rme32->pci->device == PCI_DEVICE_ID_RME_DIGI32_PRO) {
 		runtime->hw.rates |= SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000;
 		runtime->hw.rate_max = 96000;
 	}
@@ -1408,8 +1408,8 @@ static int __devinit snd_rme32_create(rme32_t * rme32)
 	}
 
 	/* set up ALSA pcm device for ADAT */
-	if ((pci->device == PCI_DEVICE_ID_DIGI32) ||
-	    (pci->device == PCI_DEVICE_ID_DIGI32_PRO)) {
+	if ((pci->device == PCI_DEVICE_ID_RME_DIGI32) ||
+	    (pci->device == PCI_DEVICE_ID_RME_DIGI32_PRO)) {
 		/* ADAT is not available on DIGI32 and DIGI32 Pro */
 		rme32->adat_pcm = NULL;
 	}
@@ -1639,11 +1639,11 @@ snd_rme32_info_inputtype_control(snd_kcontrol_t * kcontrol,
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
 	switch (rme32->pci->device) {
-	case PCI_DEVICE_ID_DIGI32:
-	case PCI_DEVICE_ID_DIGI32_8:
+	case PCI_DEVICE_ID_RME_DIGI32:
+	case PCI_DEVICE_ID_RME_DIGI32_8:
 		uinfo->value.enumerated.items = 3;
 		break;
-	case PCI_DEVICE_ID_DIGI32_PRO:
+	case PCI_DEVICE_ID_RME_DIGI32_PRO:
 		uinfo->value.enumerated.items = 4;
 		break;
 	default:
@@ -1670,11 +1670,11 @@ snd_rme32_get_inputtype_control(snd_kcontrol_t * kcontrol,
 	ucontrol->value.enumerated.item[0] = snd_rme32_getinputtype(rme32);
 
 	switch (rme32->pci->device) {
-	case PCI_DEVICE_ID_DIGI32:
-	case PCI_DEVICE_ID_DIGI32_8:
+	case PCI_DEVICE_ID_RME_DIGI32:
+	case PCI_DEVICE_ID_RME_DIGI32_8:
 		items = 3;
 		break;
-	case PCI_DEVICE_ID_DIGI32_PRO:
+	case PCI_DEVICE_ID_RME_DIGI32_PRO:
 		items = 4;
 		break;
 	default:
@@ -1697,11 +1697,11 @@ snd_rme32_put_inputtype_control(snd_kcontrol_t * kcontrol,
 	int change, items = 3;
 
 	switch (rme32->pci->device) {
-	case PCI_DEVICE_ID_DIGI32:
-	case PCI_DEVICE_ID_DIGI32_8:
+	case PCI_DEVICE_ID_RME_DIGI32:
+	case PCI_DEVICE_ID_RME_DIGI32_8:
 		items = 3;
 		break;
-	case PCI_DEVICE_ID_DIGI32_PRO:
+	case PCI_DEVICE_ID_RME_DIGI32_PRO:
 		items = 4;
 		break;
 	default:
@@ -1982,13 +1982,13 @@ snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 
 	strcpy(card->driver, "Digi32");
 	switch (rme32->pci->device) {
-	case PCI_DEVICE_ID_DIGI32:
+	case PCI_DEVICE_ID_RME_DIGI32:
 		strcpy(card->shortname, "RME Digi32");
 		break;
-	case PCI_DEVICE_ID_DIGI32_8:
+	case PCI_DEVICE_ID_RME_DIGI32_8:
 		strcpy(card->shortname, "RME Digi32/8");
 		break;
-	case PCI_DEVICE_ID_DIGI32_PRO:
+	case PCI_DEVICE_ID_RME_DIGI32_PRO:
 		strcpy(card->shortname, "RME Digi32 PRO");
 		break;
 	}

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index a511de5a3858..3daeecb9eb0e 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -2012,6 +2012,7 @@ static void __devexit snd_rme32_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name =		"RME Digi32",
+	.owner =	THIS_MODULE,
 	.id_table =	snd_rme32_ids,
 	.probe =	snd_rme32_probe,
 	.remove =	__devexit_p(snd_rme32_remove),

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index cfb5f44b2d43..a511de5a3858 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -192,20 +192,6 @@ MODULE_SUPPORTED_DEVICE("{{RME,Digi32}," "{RME,Digi32/8}," "{RME,Digi32 PRO}}");
 #define RME32_PRO_REVISION_WITH_8414 150
 
 
-/* PCI vendor/device ID's */
-#ifndef PCI_VENDOR_ID_XILINX_RME
-# define PCI_VENDOR_ID_XILINX_RME 0xea60
-#endif
-#ifndef PCI_DEVICE_ID_DIGI32
-# define PCI_DEVICE_ID_DIGI32 0x9896
-#endif
-#ifndef PCI_DEVICE_ID_DIGI32_PRO
-# define PCI_DEVICE_ID_DIGI32_PRO 0x9897
-#endif
-#ifndef PCI_DEVICE_ID_DIGI32_8
-# define PCI_DEVICE_ID_DIGI32_8 0x9898
-#endif
-
 typedef struct snd_rme32 {
 	spinlock_t lock;
 	int irq;

commit 4d23359b7ec8b03da2154df935af7d625075f6cf
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 5 10:35:20 2005 +0200

    [ALSA] sparse address space annotations
    
    ALSA Core,RawMidi Midlevel,ALSA<-OSS emulation,ALSA sequencer
    RME32 driver,RME96 driver,EMU10K1/EMU10K2 driver,NM256 driver
    Add sparse annotations where we do strange this with __iomem/__user
    pointers.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 456be39e8e4a..cfb5f44b2d43 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -692,7 +692,8 @@ snd_rme32_playback_hw_params(snd_pcm_substream_t * substream,
 		if (err < 0)
 			return err;
 	} else {
-		runtime->dma_area = (void *)(rme32->iobase + RME32_IO_DATA_BUFFER);
+		runtime->dma_area = (void __force *)(rme32->iobase +
+						     RME32_IO_DATA_BUFFER);
 		runtime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;
 		runtime->dma_bytes = RME32_BUFFER_SIZE;
 	}
@@ -746,7 +747,8 @@ snd_rme32_capture_hw_params(snd_pcm_substream_t * substream,
 		if (err < 0)
 			return err;
 	} else {
-		runtime->dma_area = (void *)rme32->iobase + RME32_IO_DATA_BUFFER;
+		runtime->dma_area = (void __force *)rme32->iobase +
+					RME32_IO_DATA_BUFFER;
 		runtime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;
 		runtime->dma_bytes = RME32_BUFFER_SIZE;
 	}

commit 67ed4161f60d76b3b27efc085b36357a6a90768c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Jul 29 15:32:58 2005 +0200

    [ALSA] sound - fix .iface field of mixer control elements
    
    Documentation,CS46xx driver,EMU10K1/EMU10K2 driver,AD1848 driver
    SB16/AWE driver,CMIPCI driver,ENS1370/1+ driver,RME32 driver
    RME96 driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    RME HDSP driver,RME9652 driver
    This patch changes .iface to SNDRV_CTL_ELEM_IFACE_MIXER whre _PCM or
    _HWDEP was used in controls that are not associated with a specific PCM
    (sub)stream or hwdep device, and changes some controls that got
    inconsitent .iface values due to copy+paste errors.  Furthermore, it
    makes sure that all control that do use _PCM or _HWDEP use the correct
    number in the .device field.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index b7b554df6705..456be39e8e4a 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1900,7 +1900,7 @@ static snd_kcontrol_new_t snd_rme32_controls[] = {
 	},
 	{
 		.access = SNDRV_CTL_ELEM_ACCESS_READ,
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, CON_MASK),
 		.info =	snd_rme32_control_spdif_mask_info,
 		.get =	snd_rme32_control_spdif_mask_get,
@@ -1908,7 +1908,7 @@ static snd_kcontrol_new_t snd_rme32_controls[] = {
 	},
 	{
 		.access = SNDRV_CTL_ELEM_ACCESS_READ,
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, PRO_MASK),
 		.info =	snd_rme32_control_spdif_mask_info,
 		.get =	snd_rme32_control_spdif_mask_get,

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index b96acd5a57db..b7b554df6705 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -2031,7 +2031,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_rme32_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_rme32_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
new file mode 100644
index 000000000000..b96acd5a57db
--- /dev/null
+++ b/sound/pci/rme32.c
@@ -0,0 +1,2043 @@
+/*
+ *   ALSA driver for RME Digi32, Digi32/8 and Digi32 PRO audio interfaces
+ *
+ *      Copyright (c) 2002-2004 Martin Langer <martin-langer@gmx.de>,
+ *                              Pilo Chambert <pilo.c@wanadoo.fr>
+ *
+ *      Thanks to :        Anders Torger <torger@ludd.luth.se>,
+ *                         Henk Hesselink <henk@anda.nl>
+ *                         for writing the digi96-driver 
+ *                         and RME for all informations.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * 
+ * 
+ * ****************************************************************************
+ * 
+ * Note #1 "Sek'd models" ................................... martin 2002-12-07
+ * 
+ * Identical soundcards by Sek'd were labeled:
+ * RME Digi 32     = Sek'd Prodif 32
+ * RME Digi 32 Pro = Sek'd Prodif 96
+ * RME Digi 32/8   = Sek'd Prodif Gold
+ * 
+ * ****************************************************************************
+ * 
+ * Note #2 "full duplex mode" ............................... martin 2002-12-07
+ * 
+ * Full duplex doesn't work. All cards (32, 32/8, 32Pro) are working identical
+ * in this mode. Rec data and play data are using the same buffer therefore. At
+ * first you have got the playing bits in the buffer and then (after playing
+ * them) they were overwitten by the captured sound of the CS8412/14. Both 
+ * modes (play/record) are running harmonically hand in hand in the same buffer
+ * and you have only one start bit plus one interrupt bit to control this 
+ * paired action.
+ * This is opposite to the latter rme96 where playing and capturing is totally
+ * separated and so their full duplex mode is supported by alsa (using two 
+ * start bits and two interrupts for two different buffers). 
+ * But due to the wrong sequence of playing and capturing ALSA shows no solved
+ * full duplex support for the rme32 at the moment. That's bad, but I'm not
+ * able to solve it. Are you motivated enough to solve this problem now? Your
+ * patch would be welcome!
+ * 
+ * ****************************************************************************
+ *
+ * "The story after the long seeking" -- tiwai
+ *
+ * Ok, the situation regarding the full duplex is now improved a bit.
+ * In the fullduplex mode (given by the module parameter), the hardware buffer
+ * is split to halves for read and write directions at the DMA pointer.
+ * That is, the half above the current DMA pointer is used for write, and
+ * the half below is used for read.  To mangle this strange behavior, an
+ * software intermediate buffer is introduced.  This is, of course, not good
+ * from the viewpoint of the data transfer efficiency.  However, this allows
+ * you to use arbitrary buffer sizes, instead of the fixed I/O buffer size.
+ *
+ * ****************************************************************************
+ */
+
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/pcm-indirect.h>
+#include <sound/asoundef.h>
+#include <sound/initval.h>
+
+#include <asm/io.h>
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int fullduplex[SNDRV_CARDS]; // = {[0 ... (SNDRV_CARDS - 1)] = 1};
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for RME Digi32 soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for RME Digi32 soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable RME Digi32 soundcard.");
+module_param_array(fullduplex, bool, NULL, 0444);
+MODULE_PARM_DESC(fullduplex, "Support full-duplex mode.");
+MODULE_AUTHOR("Martin Langer <martin-langer@gmx.de>, Pilo Chambert <pilo.c@wanadoo.fr>");
+MODULE_DESCRIPTION("RME Digi32, Digi32/8, Digi32 PRO");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{RME,Digi32}," "{RME,Digi32/8}," "{RME,Digi32 PRO}}");
+
+/* Defines for RME Digi32 series */
+#define RME32_SPDIF_NCHANNELS 2
+
+/* Playback and capture buffer size */
+#define RME32_BUFFER_SIZE 0x20000
+
+/* IO area size */
+#define RME32_IO_SIZE 0x30000
+
+/* IO area offsets */
+#define RME32_IO_DATA_BUFFER        0x0
+#define RME32_IO_CONTROL_REGISTER   0x20000
+#define RME32_IO_GET_POS            0x20000
+#define RME32_IO_CONFIRM_ACTION_IRQ 0x20004
+#define RME32_IO_RESET_POS          0x20100
+
+/* Write control register bits */
+#define RME32_WCR_START     (1 << 0)    /* startbit */
+#define RME32_WCR_MONO      (1 << 1)    /* 0=stereo, 1=mono
+                                           Setting the whole card to mono
+                                           doesn't seem to be very useful.
+                                           A software-solution can handle 
+                                           full-duplex with one direction in
+                                           stereo and the other way in mono. 
+                                           So, the hardware should work all 
+                                           the time in stereo! */
+#define RME32_WCR_MODE24    (1 << 2)    /* 0=16bit, 1=32bit */
+#define RME32_WCR_SEL       (1 << 3)    /* 0=input on output, 1=normal playback/capture */
+#define RME32_WCR_FREQ_0    (1 << 4)    /* frequency (play) */
+#define RME32_WCR_FREQ_1    (1 << 5)
+#define RME32_WCR_INP_0     (1 << 6)    /* input switch */
+#define RME32_WCR_INP_1     (1 << 7)
+#define RME32_WCR_RESET     (1 << 8)    /* Reset address */
+#define RME32_WCR_MUTE      (1 << 9)    /* digital mute for output */
+#define RME32_WCR_PRO       (1 << 10)   /* 1=professional, 0=consumer */
+#define RME32_WCR_DS_BM     (1 << 11)	/* 1=DoubleSpeed (only PRO-Version); 1=BlockMode (only Adat-Version) */
+#define RME32_WCR_ADAT      (1 << 12)	/* Adat Mode (only Adat-Version) */
+#define RME32_WCR_AUTOSYNC  (1 << 13)   /* AutoSync */
+#define RME32_WCR_PD        (1 << 14)	/* DAC Reset (only PRO-Version) */
+#define RME32_WCR_EMP       (1 << 15)	/* 1=Emphasis on (only PRO-Version) */
+
+#define RME32_WCR_BITPOS_FREQ_0 4
+#define RME32_WCR_BITPOS_FREQ_1 5
+#define RME32_WCR_BITPOS_INP_0 6
+#define RME32_WCR_BITPOS_INP_1 7
+
+/* Read control register bits */
+#define RME32_RCR_AUDIO_ADDR_MASK 0x1ffff
+#define RME32_RCR_LOCK      (1 << 23)   /* 1=locked, 0=not locked */
+#define RME32_RCR_ERF       (1 << 26)   /* 1=Error, 0=no Error */
+#define RME32_RCR_FREQ_0    (1 << 27)   /* CS841x frequency (record) */
+#define RME32_RCR_FREQ_1    (1 << 28)
+#define RME32_RCR_FREQ_2    (1 << 29)
+#define RME32_RCR_KMODE     (1 << 30)   /* card mode: 1=PLL, 0=quartz */
+#define RME32_RCR_IRQ       (1 << 31)   /* interrupt */
+
+#define RME32_RCR_BITPOS_F0 27
+#define RME32_RCR_BITPOS_F1 28
+#define RME32_RCR_BITPOS_F2 29
+
+/* Input types */
+#define RME32_INPUT_OPTICAL 0
+#define RME32_INPUT_COAXIAL 1
+#define RME32_INPUT_INTERNAL 2
+#define RME32_INPUT_XLR 3
+
+/* Clock modes */
+#define RME32_CLOCKMODE_SLAVE 0
+#define RME32_CLOCKMODE_MASTER_32 1
+#define RME32_CLOCKMODE_MASTER_44 2
+#define RME32_CLOCKMODE_MASTER_48 3
+
+/* Block sizes in bytes */
+#define RME32_BLOCK_SIZE 8192
+
+/* Software intermediate buffer (max) size */
+#define RME32_MID_BUFFER_SIZE (1024*1024)
+
+/* Hardware revisions */
+#define RME32_32_REVISION 192
+#define RME32_328_REVISION_OLD 100
+#define RME32_328_REVISION_NEW 101
+#define RME32_PRO_REVISION_WITH_8412 192
+#define RME32_PRO_REVISION_WITH_8414 150
+
+
+/* PCI vendor/device ID's */
+#ifndef PCI_VENDOR_ID_XILINX_RME
+# define PCI_VENDOR_ID_XILINX_RME 0xea60
+#endif
+#ifndef PCI_DEVICE_ID_DIGI32
+# define PCI_DEVICE_ID_DIGI32 0x9896
+#endif
+#ifndef PCI_DEVICE_ID_DIGI32_PRO
+# define PCI_DEVICE_ID_DIGI32_PRO 0x9897
+#endif
+#ifndef PCI_DEVICE_ID_DIGI32_8
+# define PCI_DEVICE_ID_DIGI32_8 0x9898
+#endif
+
+typedef struct snd_rme32 {
+	spinlock_t lock;
+	int irq;
+	unsigned long port;
+	void __iomem *iobase;
+
+	u32 wcreg;		/* cached write control register value */
+	u32 wcreg_spdif;	/* S/PDIF setup */
+	u32 wcreg_spdif_stream;	/* S/PDIF setup (temporary) */
+	u32 rcreg;		/* cached read control register value */
+
+	u8 rev;			/* card revision number */
+
+	snd_pcm_substream_t *playback_substream;
+	snd_pcm_substream_t *capture_substream;
+
+	int playback_frlog;	/* log2 of framesize */
+	int capture_frlog;
+
+	size_t playback_periodsize;	/* in bytes, zero if not used */
+	size_t capture_periodsize;	/* in bytes, zero if not used */
+
+	unsigned int fullduplex_mode;
+	int running;
+
+	snd_pcm_indirect_t playback_pcm;
+	snd_pcm_indirect_t capture_pcm;
+
+	snd_card_t *card;
+	snd_pcm_t *spdif_pcm;
+	snd_pcm_t *adat_pcm;
+	struct pci_dev *pci;
+	snd_kcontrol_t *spdif_ctl;
+} rme32_t;
+
+static struct pci_device_id snd_rme32_ids[] = {
+	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_DIGI32,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
+	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_DIGI32_8,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
+	{PCI_VENDOR_ID_XILINX_RME, PCI_DEVICE_ID_DIGI32_PRO,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, snd_rme32_ids);
+
+#define RME32_ISWORKING(rme32) ((rme32)->wcreg & RME32_WCR_START)
+#define RME32_PRO_WITH_8414(rme32) ((rme32)->pci->device == PCI_DEVICE_ID_DIGI32_PRO && (rme32)->rev == RME32_PRO_REVISION_WITH_8414)
+
+static int snd_rme32_playback_prepare(snd_pcm_substream_t * substream);
+
+static int snd_rme32_capture_prepare(snd_pcm_substream_t * substream);
+
+static int snd_rme32_pcm_trigger(snd_pcm_substream_t * substream, int cmd);
+
+static void snd_rme32_proc_init(rme32_t * rme32);
+
+static int snd_rme32_create_switches(snd_card_t * card, rme32_t * rme32);
+
+static inline unsigned int snd_rme32_pcm_byteptr(rme32_t * rme32)
+{
+	return (readl(rme32->iobase + RME32_IO_GET_POS)
+		& RME32_RCR_AUDIO_ADDR_MASK);
+}
+
+static int snd_rme32_ratecode(int rate)
+{
+	switch (rate) {
+	case 32000: return SNDRV_PCM_RATE_32000;
+	case 44100: return SNDRV_PCM_RATE_44100;
+	case 48000: return SNDRV_PCM_RATE_48000;
+	case 64000: return SNDRV_PCM_RATE_64000;
+	case 88200: return SNDRV_PCM_RATE_88200;
+	case 96000: return SNDRV_PCM_RATE_96000;
+	}
+	return 0;
+}
+
+/* silence callback for halfduplex mode */
+static int snd_rme32_playback_silence(snd_pcm_substream_t * substream, int channel,	/* not used (interleaved data) */
+				      snd_pcm_uframes_t pos,
+				      snd_pcm_uframes_t count)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	count <<= rme32->playback_frlog;
+	pos <<= rme32->playback_frlog;
+	memset_io(rme32->iobase + RME32_IO_DATA_BUFFER + pos, 0, count);
+	return 0;
+}
+
+/* copy callback for halfduplex mode */
+static int snd_rme32_playback_copy(snd_pcm_substream_t * substream, int channel,	/* not used (interleaved data) */
+				   snd_pcm_uframes_t pos,
+				   void __user *src, snd_pcm_uframes_t count)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	count <<= rme32->playback_frlog;
+	pos <<= rme32->playback_frlog;
+	if (copy_from_user_toio(rme32->iobase + RME32_IO_DATA_BUFFER + pos,
+			    src, count))
+		return -EFAULT;
+	return 0;
+}
+
+/* copy callback for halfduplex mode */
+static int snd_rme32_capture_copy(snd_pcm_substream_t * substream, int channel,	/* not used (interleaved data) */
+				  snd_pcm_uframes_t pos,
+				  void __user *dst, snd_pcm_uframes_t count)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	count <<= rme32->capture_frlog;
+	pos <<= rme32->capture_frlog;
+	if (copy_to_user_fromio(dst,
+			    rme32->iobase + RME32_IO_DATA_BUFFER + pos,
+			    count))
+		return -EFAULT;
+	return 0;
+}
+
+/*
+ * SPDIF I/O capabilites (half-duplex mode)
+ */
+static snd_pcm_hardware_t snd_rme32_spdif_info = {
+	.info =		(SNDRV_PCM_INFO_MMAP_IOMEM |
+			 SNDRV_PCM_INFO_MMAP_VALID |
+			 SNDRV_PCM_INFO_INTERLEAVED | 
+			 SNDRV_PCM_INFO_PAUSE |
+			 SNDRV_PCM_INFO_SYNC_START),
+	.formats =	(SNDRV_PCM_FMTBIT_S16_LE | 
+			 SNDRV_PCM_FMTBIT_S32_LE),
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 | 
+			 SNDRV_PCM_RATE_48000),
+	.rate_min =	32000,
+	.rate_max =	48000,
+	.channels_min =	2,
+	.channels_max =	2,
+	.buffer_bytes_max = RME32_BUFFER_SIZE,
+	.period_bytes_min = RME32_BLOCK_SIZE,
+	.period_bytes_max = RME32_BLOCK_SIZE,
+	.periods_min =	RME32_BUFFER_SIZE / RME32_BLOCK_SIZE,
+	.periods_max =	RME32_BUFFER_SIZE / RME32_BLOCK_SIZE,
+	.fifo_size =	0,
+};
+
+/*
+ * ADAT I/O capabilites (half-duplex mode)
+ */
+static snd_pcm_hardware_t snd_rme32_adat_info =
+{
+	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
+			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_INTERLEAVED |
+			      SNDRV_PCM_INFO_PAUSE |
+			      SNDRV_PCM_INFO_SYNC_START),
+	.formats=            SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =             (SNDRV_PCM_RATE_44100 | 
+			      SNDRV_PCM_RATE_48000),
+	.rate_min =          44100,
+	.rate_max =          48000,
+	.channels_min =      8,
+	.channels_max =	     8,
+	.buffer_bytes_max =  RME32_BUFFER_SIZE,
+	.period_bytes_min =  RME32_BLOCK_SIZE,
+	.period_bytes_max =  RME32_BLOCK_SIZE,
+	.periods_min =	    RME32_BUFFER_SIZE / RME32_BLOCK_SIZE,
+	.periods_max =	    RME32_BUFFER_SIZE / RME32_BLOCK_SIZE,
+	.fifo_size =	    0,
+};
+
+/*
+ * SPDIF I/O capabilites (full-duplex mode)
+ */
+static snd_pcm_hardware_t snd_rme32_spdif_fd_info = {
+	.info =		(SNDRV_PCM_INFO_MMAP |
+			 SNDRV_PCM_INFO_MMAP_VALID |
+			 SNDRV_PCM_INFO_INTERLEAVED | 
+			 SNDRV_PCM_INFO_PAUSE |
+			 SNDRV_PCM_INFO_SYNC_START),
+	.formats =	(SNDRV_PCM_FMTBIT_S16_LE | 
+			 SNDRV_PCM_FMTBIT_S32_LE),
+	.rates =	(SNDRV_PCM_RATE_32000 |
+			 SNDRV_PCM_RATE_44100 | 
+			 SNDRV_PCM_RATE_48000),
+	.rate_min =	32000,
+	.rate_max =	48000,
+	.channels_min =	2,
+	.channels_max =	2,
+	.buffer_bytes_max = RME32_MID_BUFFER_SIZE,
+	.period_bytes_min = RME32_BLOCK_SIZE,
+	.period_bytes_max = RME32_BLOCK_SIZE,
+	.periods_min =	2,
+	.periods_max =	RME32_MID_BUFFER_SIZE / RME32_BLOCK_SIZE,
+	.fifo_size =	0,
+};
+
+/*
+ * ADAT I/O capabilites (full-duplex mode)
+ */
+static snd_pcm_hardware_t snd_rme32_adat_fd_info =
+{
+	.info =		     (SNDRV_PCM_INFO_MMAP |
+			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_INTERLEAVED |
+			      SNDRV_PCM_INFO_PAUSE |
+			      SNDRV_PCM_INFO_SYNC_START),
+	.formats=            SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =             (SNDRV_PCM_RATE_44100 | 
+			      SNDRV_PCM_RATE_48000),
+	.rate_min =          44100,
+	.rate_max =          48000,
+	.channels_min =      8,
+	.channels_max =	     8,
+	.buffer_bytes_max =  RME32_MID_BUFFER_SIZE,
+	.period_bytes_min =  RME32_BLOCK_SIZE,
+	.period_bytes_max =  RME32_BLOCK_SIZE,
+	.periods_min =	    2,
+	.periods_max =	    RME32_MID_BUFFER_SIZE / RME32_BLOCK_SIZE,
+	.fifo_size =	    0,
+};
+
+static void snd_rme32_reset_dac(rme32_t *rme32)
+{
+        writel(rme32->wcreg | RME32_WCR_PD,
+               rme32->iobase + RME32_IO_CONTROL_REGISTER);
+        writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+}
+
+static int snd_rme32_playback_getrate(rme32_t * rme32)
+{
+	int rate;
+
+	rate = ((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_0) & 1) +
+	       (((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_1) & 1) << 1);
+	switch (rate) {
+	case 1:
+		rate = 32000;
+		break;
+	case 2:
+		rate = 44100;
+		break;
+	case 3:
+		rate = 48000;
+		break;
+	default:
+		return -1;
+	}
+	return (rme32->wcreg & RME32_WCR_DS_BM) ? rate << 1 : rate;
+}
+
+static int snd_rme32_capture_getrate(rme32_t * rme32, int *is_adat)
+{
+	int n;
+
+	*is_adat = 0;
+	if (rme32->rcreg & RME32_RCR_LOCK) { 
+                /* ADAT rate */
+                *is_adat = 1;
+	}
+	if (rme32->rcreg & RME32_RCR_ERF) {
+		return -1;
+	}
+
+        /* S/PDIF rate */
+	n = ((rme32->rcreg >> RME32_RCR_BITPOS_F0) & 1) +
+		(((rme32->rcreg >> RME32_RCR_BITPOS_F1) & 1) << 1) +
+		(((rme32->rcreg >> RME32_RCR_BITPOS_F2) & 1) << 2);
+
+	if (RME32_PRO_WITH_8414(rme32))
+		switch (n) {	/* supporting the CS8414 */
+		case 0:
+		case 1:
+		case 2:
+			return -1;
+		case 3:
+			return 96000;
+		case 4:
+			return 88200;
+		case 5:
+			return 48000;
+		case 6:
+			return 44100;
+		case 7:
+			return 32000;
+		default:
+			return -1;
+			break;
+		} 
+	else
+		switch (n) {	/* supporting the CS8412 */
+		case 0:
+			return -1;
+		case 1:
+			return 48000;
+		case 2:
+			return 44100;
+		case 3:
+			return 32000;
+		case 4:
+			return 48000;
+		case 5:
+			return 44100;
+		case 6:
+			return 44056;
+		case 7:
+			return 32000;
+		default:
+			break;
+		}
+	return -1;
+}
+
+static int snd_rme32_playback_setrate(rme32_t * rme32, int rate)
+{
+        int ds;
+
+        ds = rme32->wcreg & RME32_WCR_DS_BM;
+	switch (rate) {
+	case 32000:
+		rme32->wcreg &= ~RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & 
+			~RME32_WCR_FREQ_1;
+		break;
+	case 44100:
+		rme32->wcreg &= ~RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) & 
+			~RME32_WCR_FREQ_0;
+		break;
+	case 48000:
+		rme32->wcreg &= ~RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | 
+			RME32_WCR_FREQ_1;
+		break;
+	case 64000:
+		if (rme32->pci->device != PCI_DEVICE_ID_DIGI32_PRO)
+			return -EINVAL;
+		rme32->wcreg |= RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & 
+			~RME32_WCR_FREQ_1;
+		break;
+	case 88200:
+		if (rme32->pci->device != PCI_DEVICE_ID_DIGI32_PRO)
+			return -EINVAL;
+		rme32->wcreg |= RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) & 
+			~RME32_WCR_FREQ_0;
+		break;
+	case 96000:
+		if (rme32->pci->device != PCI_DEVICE_ID_DIGI32_PRO)
+			return -EINVAL;
+		rme32->wcreg |= RME32_WCR_DS_BM;
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | 
+			RME32_WCR_FREQ_1;
+		break;
+	default:
+		return -EINVAL;
+	}
+        if ((!ds && rme32->wcreg & RME32_WCR_DS_BM) ||
+            (ds && !(rme32->wcreg & RME32_WCR_DS_BM)))
+        {
+                /* change to/from double-speed: reset the DAC (if available) */
+                snd_rme32_reset_dac(rme32);
+        } else {
+                writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	}
+	return 0;
+}
+
+static int snd_rme32_setclockmode(rme32_t * rme32, int mode)
+{
+	switch (mode) {
+	case RME32_CLOCKMODE_SLAVE:
+		/* AutoSync */
+		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) & 
+			~RME32_WCR_FREQ_1;
+		break;
+	case RME32_CLOCKMODE_MASTER_32:
+		/* Internal 32.0kHz */
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) & 
+			~RME32_WCR_FREQ_1;
+		break;
+	case RME32_CLOCKMODE_MASTER_44:
+		/* Internal 44.1kHz */
+		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) | 
+			RME32_WCR_FREQ_1;
+		break;
+	case RME32_CLOCKMODE_MASTER_48:
+		/* Internal 48.0kHz */
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) | 
+			RME32_WCR_FREQ_1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	return 0;
+}
+
+static int snd_rme32_getclockmode(rme32_t * rme32)
+{
+	return ((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_0) & 1) +
+	    (((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_1) & 1) << 1);
+}
+
+static int snd_rme32_setinputtype(rme32_t * rme32, int type)
+{
+	switch (type) {
+	case RME32_INPUT_OPTICAL:
+		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) & 
+			~RME32_WCR_INP_1;
+		break;
+	case RME32_INPUT_COAXIAL:
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) & 
+			~RME32_WCR_INP_1;
+		break;
+	case RME32_INPUT_INTERNAL:
+		rme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) | 
+			RME32_WCR_INP_1;
+		break;
+	case RME32_INPUT_XLR:
+		rme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) | 
+			RME32_WCR_INP_1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	return 0;
+}
+
+static int snd_rme32_getinputtype(rme32_t * rme32)
+{
+	return ((rme32->wcreg >> RME32_WCR_BITPOS_INP_0) & 1) +
+	    (((rme32->wcreg >> RME32_WCR_BITPOS_INP_1) & 1) << 1);
+}
+
+static void
+snd_rme32_setframelog(rme32_t * rme32, int n_channels, int is_playback)
+{
+	int frlog;
+
+	if (n_channels == 2) {
+		frlog = 1;
+	} else {
+		/* assume 8 channels */
+		frlog = 3;
+	}
+	if (is_playback) {
+		frlog += (rme32->wcreg & RME32_WCR_MODE24) ? 2 : 1;
+		rme32->playback_frlog = frlog;
+	} else {
+		frlog += (rme32->wcreg & RME32_WCR_MODE24) ? 2 : 1;
+		rme32->capture_frlog = frlog;
+	}
+}
+
+static int snd_rme32_setformat(rme32_t * rme32, int format)
+{
+	switch (format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		rme32->wcreg &= ~RME32_WCR_MODE24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		rme32->wcreg |= RME32_WCR_MODE24;
+		break;
+	default:
+		return -EINVAL;
+	}
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	return 0;
+}
+
+static int
+snd_rme32_playback_hw_params(snd_pcm_substream_t * substream,
+			     snd_pcm_hw_params_t * params)
+{
+	int err, rate, dummy;
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if (rme32->fullduplex_mode) {
+		err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if (err < 0)
+			return err;
+	} else {
+		runtime->dma_area = (void *)(rme32->iobase + RME32_IO_DATA_BUFFER);
+		runtime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;
+		runtime->dma_bytes = RME32_BUFFER_SIZE;
+	}
+
+	spin_lock_irq(&rme32->lock);
+	if ((rme32->rcreg & RME32_RCR_KMODE) &&
+	    (rate = snd_rme32_capture_getrate(rme32, &dummy)) > 0) {
+		/* AutoSync */
+		if ((int)params_rate(params) != rate) {
+			spin_unlock_irq(&rme32->lock);
+			return -EIO;
+		}
+	} else if ((err = snd_rme32_playback_setrate(rme32, params_rate(params))) < 0) {
+		spin_unlock_irq(&rme32->lock);
+		return err;
+	}
+	if ((err = snd_rme32_setformat(rme32, params_format(params))) < 0) {
+		spin_unlock_irq(&rme32->lock);
+		return err;
+	}
+
+	snd_rme32_setframelog(rme32, params_channels(params), 1);
+	if (rme32->capture_periodsize != 0) {
+		if (params_period_size(params) << rme32->playback_frlog != rme32->capture_periodsize) {
+			spin_unlock_irq(&rme32->lock);
+			return -EBUSY;
+		}
+	}
+	rme32->playback_periodsize = params_period_size(params) << rme32->playback_frlog;
+	/* S/PDIF setup */
+	if ((rme32->wcreg & RME32_WCR_ADAT) == 0) {
+		rme32->wcreg &= ~(RME32_WCR_PRO | RME32_WCR_EMP);
+		rme32->wcreg |= rme32->wcreg_spdif_stream;
+		writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	}
+	spin_unlock_irq(&rme32->lock);
+
+	return 0;
+}
+
+static int
+snd_rme32_capture_hw_params(snd_pcm_substream_t * substream,
+			    snd_pcm_hw_params_t * params)
+{
+	int err, isadat, rate;
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if (rme32->fullduplex_mode) {
+		err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if (err < 0)
+			return err;
+	} else {
+		runtime->dma_area = (void *)rme32->iobase + RME32_IO_DATA_BUFFER;
+		runtime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;
+		runtime->dma_bytes = RME32_BUFFER_SIZE;
+	}
+
+	spin_lock_irq(&rme32->lock);
+	/* enable AutoSync for record-preparing */
+	rme32->wcreg |= RME32_WCR_AUTOSYNC;
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+
+	if ((err = snd_rme32_setformat(rme32, params_format(params))) < 0) {
+		spin_unlock_irq(&rme32->lock);
+		return err;
+	}
+	if ((err = snd_rme32_playback_setrate(rme32, params_rate(params))) < 0) {
+		spin_unlock_irq(&rme32->lock);
+		return err;
+	}
+	if ((rate = snd_rme32_capture_getrate(rme32, &isadat)) > 0) {
+                if ((int)params_rate(params) != rate) {
+			spin_unlock_irq(&rme32->lock);
+                        return -EIO;                    
+                }
+                if ((isadat && runtime->hw.channels_min == 2) ||
+                    (!isadat && runtime->hw.channels_min == 8)) {
+			spin_unlock_irq(&rme32->lock);
+                        return -EIO;
+                }
+	}
+	/* AutoSync off for recording */
+	rme32->wcreg &= ~RME32_WCR_AUTOSYNC;
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+
+	snd_rme32_setframelog(rme32, params_channels(params), 0);
+	if (rme32->playback_periodsize != 0) {
+		if (params_period_size(params) << rme32->capture_frlog !=
+		    rme32->playback_periodsize) {
+			spin_unlock_irq(&rme32->lock);
+			return -EBUSY;
+		}
+	}
+	rme32->capture_periodsize =
+	    params_period_size(params) << rme32->capture_frlog;
+	spin_unlock_irq(&rme32->lock);
+
+	return 0;
+}
+
+static int snd_rme32_pcm_hw_free(snd_pcm_substream_t * substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	if (! rme32->fullduplex_mode)
+		return 0;
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static void snd_rme32_pcm_start(rme32_t * rme32, int from_pause)
+{
+	if (!from_pause) {
+		writel(0, rme32->iobase + RME32_IO_RESET_POS);
+	}
+
+	rme32->wcreg |= RME32_WCR_START;
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+}
+
+static void snd_rme32_pcm_stop(rme32_t * rme32, int to_pause)
+{
+	/*
+	 * Check if there is an unconfirmed IRQ, if so confirm it, or else
+	 * the hardware will not stop generating interrupts
+	 */
+	rme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	if (rme32->rcreg & RME32_RCR_IRQ) {
+		writel(0, rme32->iobase + RME32_IO_CONFIRM_ACTION_IRQ);
+	}
+	rme32->wcreg &= ~RME32_WCR_START;
+	if (rme32->wcreg & RME32_WCR_SEL)
+		rme32->wcreg |= RME32_WCR_MUTE;
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	if (! to_pause)
+		writel(0, rme32->iobase + RME32_IO_RESET_POS);
+}
+
+static irqreturn_t
+snd_rme32_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	rme32_t *rme32 = (rme32_t *) dev_id;
+
+	rme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	if (!(rme32->rcreg & RME32_RCR_IRQ)) {
+		return IRQ_NONE;
+	} else {
+		if (rme32->capture_substream) {
+			snd_pcm_period_elapsed(rme32->capture_substream);
+		}
+		if (rme32->playback_substream) {
+			snd_pcm_period_elapsed(rme32->playback_substream);
+		}
+		writel(0, rme32->iobase + RME32_IO_CONFIRM_ACTION_IRQ);
+	}
+	return IRQ_HANDLED;
+}
+
+static unsigned int period_bytes[] = { RME32_BLOCK_SIZE };
+
+
+static snd_pcm_hw_constraint_list_t hw_constraints_period_bytes = {
+	.count = ARRAY_SIZE(period_bytes),
+	.list = period_bytes,
+	.mask = 0
+};
+
+static void snd_rme32_set_buffer_constraint(rme32_t *rme32, snd_pcm_runtime_t *runtime)
+{
+	if (! rme32->fullduplex_mode) {
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+					     RME32_BUFFER_SIZE, RME32_BUFFER_SIZE);
+		snd_pcm_hw_constraint_list(runtime, 0,
+					   SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+					   &hw_constraints_period_bytes);
+	}
+}
+
+static int snd_rme32_playback_spdif_open(snd_pcm_substream_t * substream)
+{
+	int rate, dummy;
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	snd_pcm_set_sync(substream);
+
+	spin_lock_irq(&rme32->lock);
+	if (rme32->playback_substream != NULL) {
+		spin_unlock_irq(&rme32->lock);
+		return -EBUSY;
+	}
+	rme32->wcreg &= ~RME32_WCR_ADAT;
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	rme32->playback_substream = substream;
+	spin_unlock_irq(&rme32->lock);
+
+	if (rme32->fullduplex_mode)
+		runtime->hw = snd_rme32_spdif_fd_info;
+	else
+		runtime->hw = snd_rme32_spdif_info;
+	if (rme32->pci->device == PCI_DEVICE_ID_DIGI32_PRO) {
+		runtime->hw.rates |= SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000;
+		runtime->hw.rate_max = 96000;
+	}
+	if ((rme32->rcreg & RME32_RCR_KMODE) &&
+	    (rate = snd_rme32_capture_getrate(rme32, &dummy)) > 0) {
+		/* AutoSync */
+		runtime->hw.rates = snd_rme32_ratecode(rate);
+		runtime->hw.rate_min = rate;
+		runtime->hw.rate_max = rate;
+	}       
+
+	snd_rme32_set_buffer_constraint(rme32, runtime);
+
+	rme32->wcreg_spdif_stream = rme32->wcreg_spdif;
+	rme32->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(rme32->card, SNDRV_CTL_EVENT_MASK_VALUE |
+		       SNDRV_CTL_EVENT_MASK_INFO, &rme32->spdif_ctl->id);
+	return 0;
+}
+
+static int snd_rme32_capture_spdif_open(snd_pcm_substream_t * substream)
+{
+	int isadat, rate;
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	snd_pcm_set_sync(substream);
+
+	spin_lock_irq(&rme32->lock);
+        if (rme32->capture_substream != NULL) {
+		spin_unlock_irq(&rme32->lock);
+                return -EBUSY;
+        }
+	rme32->capture_substream = substream;
+	spin_unlock_irq(&rme32->lock);
+
+	if (rme32->fullduplex_mode)
+		runtime->hw = snd_rme32_spdif_fd_info;
+	else
+		runtime->hw = snd_rme32_spdif_info;
+	if (RME32_PRO_WITH_8414(rme32)) {
+		runtime->hw.rates |= SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000;
+		runtime->hw.rate_max = 96000;
+	}
+	if ((rate = snd_rme32_capture_getrate(rme32, &isadat)) > 0) {
+		if (isadat) {
+			return -EIO;
+		}
+		runtime->hw.rates = snd_rme32_ratecode(rate);
+		runtime->hw.rate_min = rate;
+		runtime->hw.rate_max = rate;
+	}
+
+	snd_rme32_set_buffer_constraint(rme32, runtime);
+
+	return 0;
+}
+
+static int
+snd_rme32_playback_adat_open(snd_pcm_substream_t *substream)
+{
+	int rate, dummy;
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	
+	snd_pcm_set_sync(substream);
+
+	spin_lock_irq(&rme32->lock);	
+        if (rme32->playback_substream != NULL) {
+		spin_unlock_irq(&rme32->lock);
+                return -EBUSY;
+        }
+	rme32->wcreg |= RME32_WCR_ADAT;
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	rme32->playback_substream = substream;
+	spin_unlock_irq(&rme32->lock);
+	
+	if (rme32->fullduplex_mode)
+		runtime->hw = snd_rme32_adat_fd_info;
+	else
+		runtime->hw = snd_rme32_adat_info;
+	if ((rme32->rcreg & RME32_RCR_KMODE) &&
+	    (rate = snd_rme32_capture_getrate(rme32, &dummy)) > 0) {
+                /* AutoSync */
+                runtime->hw.rates = snd_rme32_ratecode(rate);
+                runtime->hw.rate_min = rate;
+                runtime->hw.rate_max = rate;
+	}        
+
+	snd_rme32_set_buffer_constraint(rme32, runtime);
+	return 0;
+}
+
+static int
+snd_rme32_capture_adat_open(snd_pcm_substream_t *substream)
+{
+	int isadat, rate;
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if (rme32->fullduplex_mode)
+		runtime->hw = snd_rme32_adat_fd_info;
+	else
+		runtime->hw = snd_rme32_adat_info;
+	if ((rate = snd_rme32_capture_getrate(rme32, &isadat)) > 0) {
+		if (!isadat) {
+			return -EIO;
+		}
+                runtime->hw.rates = snd_rme32_ratecode(rate);
+                runtime->hw.rate_min = rate;
+                runtime->hw.rate_max = rate;
+        }
+
+	snd_pcm_set_sync(substream);
+        
+	spin_lock_irq(&rme32->lock);	
+	if (rme32->capture_substream != NULL) {
+		spin_unlock_irq(&rme32->lock);
+		return -EBUSY;
+        }
+	rme32->capture_substream = substream;
+	spin_unlock_irq(&rme32->lock);
+
+	snd_rme32_set_buffer_constraint(rme32, runtime);
+	return 0;
+}
+
+static int snd_rme32_playback_close(snd_pcm_substream_t * substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	int spdif = 0;
+
+	spin_lock_irq(&rme32->lock);
+	rme32->playback_substream = NULL;
+	rme32->playback_periodsize = 0;
+	spdif = (rme32->wcreg & RME32_WCR_ADAT) == 0;
+	spin_unlock_irq(&rme32->lock);
+	if (spdif) {
+		rme32->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+		snd_ctl_notify(rme32->card, SNDRV_CTL_EVENT_MASK_VALUE |
+			       SNDRV_CTL_EVENT_MASK_INFO,
+			       &rme32->spdif_ctl->id);
+	}
+	return 0;
+}
+
+static int snd_rme32_capture_close(snd_pcm_substream_t * substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&rme32->lock);
+	rme32->capture_substream = NULL;
+	rme32->capture_periodsize = 0;
+	spin_unlock(&rme32->lock);
+	return 0;
+}
+
+static int snd_rme32_playback_prepare(snd_pcm_substream_t * substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&rme32->lock);
+	if (rme32->fullduplex_mode) {
+		memset(&rme32->playback_pcm, 0, sizeof(rme32->playback_pcm));
+		rme32->playback_pcm.hw_buffer_size = RME32_BUFFER_SIZE;
+		rme32->playback_pcm.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	} else {
+		writel(0, rme32->iobase + RME32_IO_RESET_POS);
+	}
+	if (rme32->wcreg & RME32_WCR_SEL)
+		rme32->wcreg &= ~RME32_WCR_MUTE;
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	spin_unlock_irq(&rme32->lock);
+	return 0;
+}
+
+static int snd_rme32_capture_prepare(snd_pcm_substream_t * substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&rme32->lock);
+	if (rme32->fullduplex_mode) {
+		memset(&rme32->capture_pcm, 0, sizeof(rme32->capture_pcm));
+		rme32->capture_pcm.hw_buffer_size = RME32_BUFFER_SIZE;
+		rme32->capture_pcm.hw_queue_size = RME32_BUFFER_SIZE / 2;
+		rme32->capture_pcm.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	} else {
+		writel(0, rme32->iobase + RME32_IO_RESET_POS);
+	}
+	spin_unlock_irq(&rme32->lock);
+	return 0;
+}
+
+static int
+snd_rme32_pcm_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	struct list_head *pos;
+	snd_pcm_substream_t *s;
+
+	spin_lock(&rme32->lock);
+	snd_pcm_group_for_each(pos, substream) {
+		s = snd_pcm_group_substream_entry(pos);
+		if (s != rme32->playback_substream &&
+		    s != rme32->capture_substream)
+			continue;
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+			rme32->running |= (1 << s->stream);
+			if (rme32->fullduplex_mode) {
+				/* remember the current DMA position */
+				if (s == rme32->playback_substream) {
+					rme32->playback_pcm.hw_io =
+					rme32->playback_pcm.hw_data = snd_rme32_pcm_byteptr(rme32);
+				} else {
+					rme32->capture_pcm.hw_io =
+					rme32->capture_pcm.hw_data = snd_rme32_pcm_byteptr(rme32);
+				}
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			rme32->running &= ~(1 << s->stream);
+			break;
+		}
+		snd_pcm_trigger_done(s, substream);
+	}
+	
+	/* prefill playback buffer */
+	if (cmd == SNDRV_PCM_TRIGGER_START && rme32->fullduplex_mode) {
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == rme32->playback_substream) {
+				s->ops->ack(s);
+				break;
+			}
+		}
+	}
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (rme32->running && ! RME32_ISWORKING(rme32))
+			snd_rme32_pcm_start(rme32, 0);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		if (! rme32->running && RME32_ISWORKING(rme32))
+			snd_rme32_pcm_stop(rme32, 0);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (rme32->running && RME32_ISWORKING(rme32))
+			snd_rme32_pcm_stop(rme32, 1);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (rme32->running && ! RME32_ISWORKING(rme32))
+			snd_rme32_pcm_start(rme32, 1);
+		break;
+	}
+	spin_unlock(&rme32->lock);
+	return 0;
+}
+
+/* pointer callback for halfduplex mode */
+static snd_pcm_uframes_t
+snd_rme32_playback_pointer(snd_pcm_substream_t * substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	return snd_rme32_pcm_byteptr(rme32) >> rme32->playback_frlog;
+}
+
+static snd_pcm_uframes_t
+snd_rme32_capture_pointer(snd_pcm_substream_t * substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	return snd_rme32_pcm_byteptr(rme32) >> rme32->capture_frlog;
+}
+
+
+/* ack and pointer callbacks for fullduplex mode */
+static void snd_rme32_pb_trans_copy(snd_pcm_substream_t *substream,
+				    snd_pcm_indirect_t *rec, size_t bytes)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	memcpy_toio(rme32->iobase + RME32_IO_DATA_BUFFER + rec->hw_data,
+		    substream->runtime->dma_area + rec->sw_data, bytes);
+}
+
+static int snd_rme32_playback_fd_ack(snd_pcm_substream_t *substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	snd_pcm_indirect_t *rec, *cprec;
+
+	rec = &rme32->playback_pcm;
+	cprec = &rme32->capture_pcm;
+	spin_lock(&rme32->lock);
+	rec->hw_queue_size = RME32_BUFFER_SIZE;
+	if (rme32->running & (1 << SNDRV_PCM_STREAM_CAPTURE))
+		rec->hw_queue_size -= cprec->hw_ready;
+	spin_unlock(&rme32->lock);
+	snd_pcm_indirect_playback_transfer(substream, rec,
+					   snd_rme32_pb_trans_copy);
+	return 0;
+}
+
+static void snd_rme32_cp_trans_copy(snd_pcm_substream_t *substream,
+				    snd_pcm_indirect_t *rec, size_t bytes)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	memcpy_fromio(substream->runtime->dma_area + rec->sw_data,
+		      rme32->iobase + RME32_IO_DATA_BUFFER + rec->hw_data,
+		      bytes);
+}
+
+static int snd_rme32_capture_fd_ack(snd_pcm_substream_t *substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	snd_pcm_indirect_capture_transfer(substream, &rme32->capture_pcm,
+					  snd_rme32_cp_trans_copy);
+	return 0;
+}
+
+static snd_pcm_uframes_t
+snd_rme32_playback_fd_pointer(snd_pcm_substream_t * substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	return snd_pcm_indirect_playback_pointer(substream, &rme32->playback_pcm,
+						 snd_rme32_pcm_byteptr(rme32));
+}
+
+static snd_pcm_uframes_t
+snd_rme32_capture_fd_pointer(snd_pcm_substream_t * substream)
+{
+	rme32_t *rme32 = snd_pcm_substream_chip(substream);
+	return snd_pcm_indirect_capture_pointer(substream, &rme32->capture_pcm,
+						snd_rme32_pcm_byteptr(rme32));
+}
+
+/* for halfduplex mode */
+static snd_pcm_ops_t snd_rme32_playback_spdif_ops = {
+	.open =		snd_rme32_playback_spdif_open,
+	.close =	snd_rme32_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme32_playback_hw_params,
+	.hw_free =	snd_rme32_pcm_hw_free,
+	.prepare =	snd_rme32_playback_prepare,
+	.trigger =	snd_rme32_pcm_trigger,
+	.pointer =	snd_rme32_playback_pointer,
+	.copy =		snd_rme32_playback_copy,
+	.silence =	snd_rme32_playback_silence,
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+static snd_pcm_ops_t snd_rme32_capture_spdif_ops = {
+	.open =		snd_rme32_capture_spdif_open,
+	.close =	snd_rme32_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme32_capture_hw_params,
+	.hw_free =	snd_rme32_pcm_hw_free,
+	.prepare =	snd_rme32_capture_prepare,
+	.trigger =	snd_rme32_pcm_trigger,
+	.pointer =	snd_rme32_capture_pointer,
+	.copy =		snd_rme32_capture_copy,
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+static snd_pcm_ops_t snd_rme32_playback_adat_ops = {
+	.open =		snd_rme32_playback_adat_open,
+	.close =	snd_rme32_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme32_playback_hw_params,
+	.prepare =	snd_rme32_playback_prepare,
+	.trigger =	snd_rme32_pcm_trigger,
+	.pointer =	snd_rme32_playback_pointer,
+	.copy =		snd_rme32_playback_copy,
+	.silence =	snd_rme32_playback_silence,
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+static snd_pcm_ops_t snd_rme32_capture_adat_ops = {
+	.open =		snd_rme32_capture_adat_open,
+	.close =	snd_rme32_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme32_capture_hw_params,
+	.prepare =	snd_rme32_capture_prepare,
+	.trigger =	snd_rme32_pcm_trigger,
+	.pointer =	snd_rme32_capture_pointer,
+	.copy =		snd_rme32_capture_copy,
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+/* for fullduplex mode */
+static snd_pcm_ops_t snd_rme32_playback_spdif_fd_ops = {
+	.open =		snd_rme32_playback_spdif_open,
+	.close =	snd_rme32_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme32_playback_hw_params,
+	.hw_free =	snd_rme32_pcm_hw_free,
+	.prepare =	snd_rme32_playback_prepare,
+	.trigger =	snd_rme32_pcm_trigger,
+	.pointer =	snd_rme32_playback_fd_pointer,
+	.ack =		snd_rme32_playback_fd_ack,
+};
+
+static snd_pcm_ops_t snd_rme32_capture_spdif_fd_ops = {
+	.open =		snd_rme32_capture_spdif_open,
+	.close =	snd_rme32_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme32_capture_hw_params,
+	.hw_free =	snd_rme32_pcm_hw_free,
+	.prepare =	snd_rme32_capture_prepare,
+	.trigger =	snd_rme32_pcm_trigger,
+	.pointer =	snd_rme32_capture_fd_pointer,
+	.ack =		snd_rme32_capture_fd_ack,
+};
+
+static snd_pcm_ops_t snd_rme32_playback_adat_fd_ops = {
+	.open =		snd_rme32_playback_adat_open,
+	.close =	snd_rme32_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme32_playback_hw_params,
+	.prepare =	snd_rme32_playback_prepare,
+	.trigger =	snd_rme32_pcm_trigger,
+	.pointer =	snd_rme32_playback_fd_pointer,
+	.ack =		snd_rme32_playback_fd_ack,
+};
+
+static snd_pcm_ops_t snd_rme32_capture_adat_fd_ops = {
+	.open =		snd_rme32_capture_adat_open,
+	.close =	snd_rme32_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme32_capture_hw_params,
+	.prepare =	snd_rme32_capture_prepare,
+	.trigger =	snd_rme32_pcm_trigger,
+	.pointer =	snd_rme32_capture_fd_pointer,
+	.ack =		snd_rme32_capture_fd_ack,
+};
+
+static void snd_rme32_free(void *private_data)
+{
+	rme32_t *rme32 = (rme32_t *) private_data;
+
+	if (rme32 == NULL) {
+		return;
+	}
+	if (rme32->irq >= 0) {
+		snd_rme32_pcm_stop(rme32, 0);
+		free_irq(rme32->irq, (void *) rme32);
+		rme32->irq = -1;
+	}
+	if (rme32->iobase) {
+		iounmap(rme32->iobase);
+		rme32->iobase = NULL;
+	}
+	if (rme32->port) {
+		pci_release_regions(rme32->pci);
+		rme32->port = 0;
+	}
+	pci_disable_device(rme32->pci);
+}
+
+static void snd_rme32_free_spdif_pcm(snd_pcm_t * pcm)
+{
+	rme32_t *rme32 = (rme32_t *) pcm->private_data;
+	rme32->spdif_pcm = NULL;
+}
+
+static void
+snd_rme32_free_adat_pcm(snd_pcm_t *pcm)
+{
+	rme32_t *rme32 = (rme32_t *) pcm->private_data;
+	rme32->adat_pcm = NULL;
+}
+
+static int __devinit snd_rme32_create(rme32_t * rme32)
+{
+	struct pci_dev *pci = rme32->pci;
+	int err;
+
+	rme32->irq = -1;
+	spin_lock_init(&rme32->lock);
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	if ((err = pci_request_regions(pci, "RME32")) < 0)
+		return err;
+	rme32->port = pci_resource_start(rme32->pci, 0);
+
+	if (request_irq(pci->irq, snd_rme32_interrupt, SA_INTERRUPT | SA_SHIRQ, "RME32", (void *) rme32)) {
+		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		return -EBUSY;
+	}
+	rme32->irq = pci->irq;
+
+	if ((rme32->iobase = ioremap_nocache(rme32->port, RME32_IO_SIZE)) == 0) {
+		snd_printk("unable to remap memory region 0x%lx-0x%lx\n",
+			   rme32->port, rme32->port + RME32_IO_SIZE - 1);
+		return -ENOMEM;
+	}
+
+	/* read the card's revision number */
+	pci_read_config_byte(pci, 8, &rme32->rev);
+
+	/* set up ALSA pcm device for S/PDIF */
+	if ((err = snd_pcm_new(rme32->card, "Digi32 IEC958", 0, 1, 1, &rme32->spdif_pcm)) < 0) {
+		return err;
+	}
+	rme32->spdif_pcm->private_data = rme32;
+	rme32->spdif_pcm->private_free = snd_rme32_free_spdif_pcm;
+	strcpy(rme32->spdif_pcm->name, "Digi32 IEC958");
+	if (rme32->fullduplex_mode) {
+		snd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				&snd_rme32_playback_spdif_fd_ops);
+		snd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE,
+				&snd_rme32_capture_spdif_fd_ops);
+		snd_pcm_lib_preallocate_pages_for_all(rme32->spdif_pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+						      snd_dma_continuous_data(GFP_KERNEL),
+						      0, RME32_MID_BUFFER_SIZE);
+		rme32->spdif_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
+	} else {
+		snd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				&snd_rme32_playback_spdif_ops);
+		snd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE,
+				&snd_rme32_capture_spdif_ops);
+		rme32->spdif_pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;
+	}
+
+	/* set up ALSA pcm device for ADAT */
+	if ((pci->device == PCI_DEVICE_ID_DIGI32) ||
+	    (pci->device == PCI_DEVICE_ID_DIGI32_PRO)) {
+		/* ADAT is not available on DIGI32 and DIGI32 Pro */
+		rme32->adat_pcm = NULL;
+	}
+	else {
+		if ((err = snd_pcm_new(rme32->card, "Digi32 ADAT", 1,
+				       1, 1, &rme32->adat_pcm)) < 0)
+		{
+			return err;
+		}		
+		rme32->adat_pcm->private_data = rme32;
+		rme32->adat_pcm->private_free = snd_rme32_free_adat_pcm;
+		strcpy(rme32->adat_pcm->name, "Digi32 ADAT");
+		if (rme32->fullduplex_mode) {
+			snd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK, 
+					&snd_rme32_playback_adat_fd_ops);
+			snd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_CAPTURE, 
+					&snd_rme32_capture_adat_fd_ops);
+			snd_pcm_lib_preallocate_pages_for_all(rme32->adat_pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+							      snd_dma_continuous_data(GFP_KERNEL),
+							      0, RME32_MID_BUFFER_SIZE);
+			rme32->adat_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
+		} else {
+			snd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK, 
+					&snd_rme32_playback_adat_ops);
+			snd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_CAPTURE, 
+					&snd_rme32_capture_adat_ops);
+			rme32->adat_pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;
+		}
+	}
+
+
+	rme32->playback_periodsize = 0;
+	rme32->capture_periodsize = 0;
+
+	/* make sure playback/capture is stopped, if by some reason active */
+	snd_rme32_pcm_stop(rme32, 0);
+
+        /* reset DAC */
+        snd_rme32_reset_dac(rme32);
+
+	/* reset buffer pointer */
+	writel(0, rme32->iobase + RME32_IO_RESET_POS);
+
+	/* set default values in registers */
+	rme32->wcreg = RME32_WCR_SEL |	 /* normal playback */
+		RME32_WCR_INP_0 | /* input select */
+		RME32_WCR_MUTE;	 /* muting on */
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+
+
+	/* init switch interface */
+	if ((err = snd_rme32_create_switches(rme32->card, rme32)) < 0) {
+		return err;
+	}
+
+	/* init proc interface */
+	snd_rme32_proc_init(rme32);
+
+	rme32->capture_substream = NULL;
+	rme32->playback_substream = NULL;
+
+	return 0;
+}
+
+/*
+ * proc interface
+ */
+
+static void
+snd_rme32_proc_read(snd_info_entry_t * entry, snd_info_buffer_t * buffer)
+{
+	int n;
+	rme32_t *rme32 = (rme32_t *) entry->private_data;
+
+	rme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);
+
+	snd_iprintf(buffer, rme32->card->longname);
+	snd_iprintf(buffer, " (index #%d)\n", rme32->card->number + 1);
+
+	snd_iprintf(buffer, "\nGeneral settings\n");
+	if (rme32->fullduplex_mode)
+		snd_iprintf(buffer, "  Full-duplex mode\n");
+	else
+		snd_iprintf(buffer, "  Half-duplex mode\n");
+	if (RME32_PRO_WITH_8414(rme32)) {
+		snd_iprintf(buffer, "  receiver: CS8414\n");
+	} else {
+		snd_iprintf(buffer, "  receiver: CS8412\n");
+	}
+	if (rme32->wcreg & RME32_WCR_MODE24) {
+		snd_iprintf(buffer, "  format: 24 bit");
+	} else {
+		snd_iprintf(buffer, "  format: 16 bit");
+	}
+	if (rme32->wcreg & RME32_WCR_MONO) {
+		snd_iprintf(buffer, ", Mono\n");
+	} else {
+		snd_iprintf(buffer, ", Stereo\n");
+	}
+
+	snd_iprintf(buffer, "\nInput settings\n");
+	switch (snd_rme32_getinputtype(rme32)) {
+	case RME32_INPUT_OPTICAL:
+		snd_iprintf(buffer, "  input: optical");
+		break;
+	case RME32_INPUT_COAXIAL:
+		snd_iprintf(buffer, "  input: coaxial");
+		break;
+	case RME32_INPUT_INTERNAL:
+		snd_iprintf(buffer, "  input: internal");
+		break;
+	case RME32_INPUT_XLR:
+		snd_iprintf(buffer, "  input: XLR");
+		break;
+	}
+	if (snd_rme32_capture_getrate(rme32, &n) < 0) {
+		snd_iprintf(buffer, "\n  sample rate: no valid signal\n");
+	} else {
+		if (n) {
+			snd_iprintf(buffer, " (8 channels)\n");
+		} else {
+			snd_iprintf(buffer, " (2 channels)\n");
+		}
+		snd_iprintf(buffer, "  sample rate: %d Hz\n",
+			    snd_rme32_capture_getrate(rme32, &n));
+	}
+
+	snd_iprintf(buffer, "\nOutput settings\n");
+	if (rme32->wcreg & RME32_WCR_SEL) {
+		snd_iprintf(buffer, "  output signal: normal playback");
+	} else {
+		snd_iprintf(buffer, "  output signal: same as input");
+	}
+	if (rme32->wcreg & RME32_WCR_MUTE) {
+		snd_iprintf(buffer, " (muted)\n");
+	} else {
+		snd_iprintf(buffer, "\n");
+	}
+
+	/* master output frequency */
+	if (!
+	    ((!(rme32->wcreg & RME32_WCR_FREQ_0))
+	     && (!(rme32->wcreg & RME32_WCR_FREQ_1)))) {
+		snd_iprintf(buffer, "  sample rate: %d Hz\n",
+			    snd_rme32_playback_getrate(rme32));
+	}
+	if (rme32->rcreg & RME32_RCR_KMODE) {
+		snd_iprintf(buffer, "  sample clock source: AutoSync\n");
+	} else {
+		snd_iprintf(buffer, "  sample clock source: Internal\n");
+	}
+	if (rme32->wcreg & RME32_WCR_PRO) {
+		snd_iprintf(buffer, "  format: AES/EBU (professional)\n");
+	} else {
+		snd_iprintf(buffer, "  format: IEC958 (consumer)\n");
+	}
+	if (rme32->wcreg & RME32_WCR_EMP) {
+		snd_iprintf(buffer, "  emphasis: on\n");
+	} else {
+		snd_iprintf(buffer, "  emphasis: off\n");
+	}
+}
+
+static void __devinit snd_rme32_proc_init(rme32_t * rme32)
+{
+	snd_info_entry_t *entry;
+
+	if (! snd_card_proc_new(rme32->card, "rme32", &entry))
+		snd_info_set_text_ops(entry, rme32, 1024, snd_rme32_proc_read);
+}
+
+/*
+ * control interface
+ */
+
+static int
+snd_rme32_info_loopback_control(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+static int
+snd_rme32_get_loopback_control(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&rme32->lock);
+	ucontrol->value.integer.value[0] =
+	    rme32->wcreg & RME32_WCR_SEL ? 0 : 1;
+	spin_unlock_irq(&rme32->lock);
+	return 0;
+}
+static int
+snd_rme32_put_loopback_control(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+
+	val = ucontrol->value.integer.value[0] ? 0 : RME32_WCR_SEL;
+	spin_lock_irq(&rme32->lock);
+	val = (rme32->wcreg & ~RME32_WCR_SEL) | val;
+	change = val != rme32->wcreg;
+	if (ucontrol->value.integer.value[0])
+		val &= ~RME32_WCR_MUTE;
+	else
+		val |= RME32_WCR_MUTE;
+	rme32->wcreg = val;
+	writel(val, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	spin_unlock_irq(&rme32->lock);
+	return change;
+}
+
+static int
+snd_rme32_info_inputtype_control(snd_kcontrol_t * kcontrol,
+				 snd_ctl_elem_info_t * uinfo)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	static char *texts[4] = { "Optical", "Coaxial", "Internal", "XLR" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	switch (rme32->pci->device) {
+	case PCI_DEVICE_ID_DIGI32:
+	case PCI_DEVICE_ID_DIGI32_8:
+		uinfo->value.enumerated.items = 3;
+		break;
+	case PCI_DEVICE_ID_DIGI32_PRO:
+		uinfo->value.enumerated.items = 4;
+		break;
+	default:
+		snd_BUG();
+		break;
+	}
+	if (uinfo->value.enumerated.item >
+	    uinfo->value.enumerated.items - 1) {
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	}
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+static int
+snd_rme32_get_inputtype_control(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_value_t * ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	unsigned int items = 3;
+
+	spin_lock_irq(&rme32->lock);
+	ucontrol->value.enumerated.item[0] = snd_rme32_getinputtype(rme32);
+
+	switch (rme32->pci->device) {
+	case PCI_DEVICE_ID_DIGI32:
+	case PCI_DEVICE_ID_DIGI32_8:
+		items = 3;
+		break;
+	case PCI_DEVICE_ID_DIGI32_PRO:
+		items = 4;
+		break;
+	default:
+		snd_BUG();
+		break;
+	}
+	if (ucontrol->value.enumerated.item[0] >= items) {
+		ucontrol->value.enumerated.item[0] = items - 1;
+	}
+
+	spin_unlock_irq(&rme32->lock);
+	return 0;
+}
+static int
+snd_rme32_put_inputtype_control(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_value_t * ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change, items = 3;
+
+	switch (rme32->pci->device) {
+	case PCI_DEVICE_ID_DIGI32:
+	case PCI_DEVICE_ID_DIGI32_8:
+		items = 3;
+		break;
+	case PCI_DEVICE_ID_DIGI32_PRO:
+		items = 4;
+		break;
+	default:
+		snd_BUG();
+		break;
+	}
+	val = ucontrol->value.enumerated.item[0] % items;
+
+	spin_lock_irq(&rme32->lock);
+	change = val != (unsigned int)snd_rme32_getinputtype(rme32);
+	snd_rme32_setinputtype(rme32, val);
+	spin_unlock_irq(&rme32->lock);
+	return change;
+}
+
+static int
+snd_rme32_info_clockmode_control(snd_kcontrol_t * kcontrol,
+				 snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[4] = { "AutoSync", 
+				  "Internal 32.0kHz", 
+				  "Internal 44.1kHz", 
+				  "Internal 48.0kHz" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 4;
+	if (uinfo->value.enumerated.item > 3) {
+		uinfo->value.enumerated.item = 3;
+	}
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+static int
+snd_rme32_get_clockmode_control(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_value_t * ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&rme32->lock);
+	ucontrol->value.enumerated.item[0] = snd_rme32_getclockmode(rme32);
+	spin_unlock_irq(&rme32->lock);
+	return 0;
+}
+static int
+snd_rme32_put_clockmode_control(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_value_t * ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+
+	val = ucontrol->value.enumerated.item[0] % 3;
+	spin_lock_irq(&rme32->lock);
+	change = val != (unsigned int)snd_rme32_getclockmode(rme32);
+	snd_rme32_setclockmode(rme32, val);
+	spin_unlock_irq(&rme32->lock);
+	return change;
+}
+
+static u32 snd_rme32_convert_from_aes(snd_aes_iec958_t * aes)
+{
+	u32 val = 0;
+	val |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME32_WCR_PRO : 0;
+	if (val & RME32_WCR_PRO)
+		val |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? RME32_WCR_EMP : 0;
+	else
+		val |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? RME32_WCR_EMP : 0;
+	return val;
+}
+
+static void snd_rme32_convert_to_aes(snd_aes_iec958_t * aes, u32 val)
+{
+	aes->status[0] = ((val & RME32_WCR_PRO) ? IEC958_AES0_PROFESSIONAL : 0);
+	if (val & RME32_WCR_PRO)
+		aes->status[0] |= (val & RME32_WCR_EMP) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;
+	else
+		aes->status[0] |= (val & RME32_WCR_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;
+}
+
+static int snd_rme32_control_spdif_info(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_rme32_control_spdif_get(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+
+	snd_rme32_convert_to_aes(&ucontrol->value.iec958,
+				 rme32->wcreg_spdif);
+	return 0;
+}
+
+static int snd_rme32_control_spdif_put(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	int change;
+	u32 val;
+
+	val = snd_rme32_convert_from_aes(&ucontrol->value.iec958);
+	spin_lock_irq(&rme32->lock);
+	change = val != rme32->wcreg_spdif;
+	rme32->wcreg_spdif = val;
+	spin_unlock_irq(&rme32->lock);
+	return change;
+}
+
+static int snd_rme32_control_spdif_stream_info(snd_kcontrol_t * kcontrol,
+					       snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_rme32_control_spdif_stream_get(snd_kcontrol_t * kcontrol,
+					      snd_ctl_elem_value_t *
+					      ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+
+	snd_rme32_convert_to_aes(&ucontrol->value.iec958,
+				 rme32->wcreg_spdif_stream);
+	return 0;
+}
+
+static int snd_rme32_control_spdif_stream_put(snd_kcontrol_t * kcontrol,
+					      snd_ctl_elem_value_t *
+					      ucontrol)
+{
+	rme32_t *rme32 = snd_kcontrol_chip(kcontrol);
+	int change;
+	u32 val;
+
+	val = snd_rme32_convert_from_aes(&ucontrol->value.iec958);
+	spin_lock_irq(&rme32->lock);
+	change = val != rme32->wcreg_spdif_stream;
+	rme32->wcreg_spdif_stream = val;
+	rme32->wcreg &= ~(RME32_WCR_PRO | RME32_WCR_EMP);
+	rme32->wcreg |= val;
+	writel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);
+	spin_unlock_irq(&rme32->lock);
+	return change;
+}
+
+static int snd_rme32_control_spdif_mask_info(snd_kcontrol_t * kcontrol,
+					     snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_rme32_control_spdif_mask_get(snd_kcontrol_t * kcontrol,
+					    snd_ctl_elem_value_t *
+					    ucontrol)
+{
+	ucontrol->value.iec958.status[0] = kcontrol->private_value;
+	return 0;
+}
+
+static snd_kcontrol_new_t snd_rme32_controls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+		.info =	snd_rme32_control_spdif_info,
+		.get =	snd_rme32_control_spdif_get,
+		.put =	snd_rme32_control_spdif_put
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, PCM_STREAM),
+		.info =	snd_rme32_control_spdif_stream_info,
+		.get =	snd_rme32_control_spdif_stream_get,
+		.put =	snd_rme32_control_spdif_stream_put
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, CON_MASK),
+		.info =	snd_rme32_control_spdif_mask_info,
+		.get =	snd_rme32_control_spdif_mask_get,
+		.private_value = IEC958_AES0_PROFESSIONAL | IEC958_AES0_CON_EMPHASIS
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	SNDRV_CTL_NAME_IEC958("", PLAYBACK, PRO_MASK),
+		.info =	snd_rme32_control_spdif_mask_info,
+		.get =	snd_rme32_control_spdif_mask_get,
+		.private_value = IEC958_AES0_PROFESSIONAL | IEC958_AES0_PRO_EMPHASIS
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	"Input Connector",
+		.info =	snd_rme32_info_inputtype_control,
+		.get =	snd_rme32_get_inputtype_control,
+		.put =	snd_rme32_put_inputtype_control
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	"Loopback Input",
+		.info =	snd_rme32_info_loopback_control,
+		.get =	snd_rme32_get_loopback_control,
+		.put =	snd_rme32_put_loopback_control
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name =	"Sample Clock Source",
+		.info =	snd_rme32_info_clockmode_control,
+		.get =	snd_rme32_get_clockmode_control,
+		.put =	snd_rme32_put_clockmode_control
+	}
+};
+
+static int snd_rme32_create_switches(snd_card_t * card, rme32_t * rme32)
+{
+	int idx, err;
+	snd_kcontrol_t *kctl;
+
+	for (idx = 0; idx < (int)ARRAY_SIZE(snd_rme32_controls); idx++) {
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme32_controls[idx], rme32))) < 0)
+			return err;
+		if (idx == 1)	/* IEC958 (S/PDIF) Stream */
+			rme32->spdif_ctl = kctl;
+	}
+
+	return 0;
+}
+
+/*
+ * Card initialisation
+ */
+
+static void snd_rme32_card_free(snd_card_t * card)
+{
+	snd_rme32_free(card->private_data);
+}
+
+static int __devinit
+snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
+{
+	static int dev;
+	rme32_t *rme32;
+	snd_card_t *card;
+	int err;
+
+	if (dev >= SNDRV_CARDS) {
+		return -ENODEV;
+	}
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	if ((card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+				 sizeof(rme32_t))) == NULL)
+		return -ENOMEM;
+	card->private_free = snd_rme32_card_free;
+	rme32 = (rme32_t *) card->private_data;
+	rme32->card = card;
+	rme32->pci = pci;
+	snd_card_set_dev(card, &pci->dev);
+        if (fullduplex[dev])
+		rme32->fullduplex_mode = 1;
+	if ((err = snd_rme32_create(rme32)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->driver, "Digi32");
+	switch (rme32->pci->device) {
+	case PCI_DEVICE_ID_DIGI32:
+		strcpy(card->shortname, "RME Digi32");
+		break;
+	case PCI_DEVICE_ID_DIGI32_8:
+		strcpy(card->shortname, "RME Digi32/8");
+		break;
+	case PCI_DEVICE_ID_DIGI32_PRO:
+		strcpy(card->shortname, "RME Digi32 PRO");
+		break;
+	}
+	sprintf(card->longname, "%s (Rev. %d) at 0x%lx, irq %d",
+		card->shortname, rme32->rev, rme32->port, rme32->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_rme32_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name =		"RME Digi32",
+	.id_table =	snd_rme32_ids,
+	.probe =	snd_rme32_probe,
+	.remove =	__devexit_p(snd_rme32_remove),
+};
+
+static int __init alsa_card_rme32_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_rme32_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_rme32_init)
+module_exit(alsa_card_rme32_exit)
