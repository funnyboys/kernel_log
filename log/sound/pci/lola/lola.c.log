commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index e7c620caa935..cdd8db79bcfa 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -559,7 +559,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 	struct lola *chip;
 	int err;
 	unsigned int dever;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = lola_dev_free,
 	};
 

commit aec9f0cc057ece110be244fc5d2f10ba3176a8db
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:25 2019 +0100

    ALSA: lola: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation, as well as removing the superfluous synchronize_irq()
    call.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-27-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 21ac9d003e8e..e7c620caa935 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -638,7 +638,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 		goto errout;
 	}
 	chip->irq = pci->irq;
-	synchronize_irq(chip->irq);
+	card->sync_irq = chip->irq;
 
 	dever = lola_readl(chip, BAR1, DEVER);
 	chip->pcm[CAPT].num_streams = (dever >> 0) & 0x3ff;

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 5cda3488ceab..21ac9d003e8e 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -350,7 +350,7 @@ static int setup_corb_rirb(struct lola *chip)
 	unsigned long end_time;
 
 	err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
-				  snd_dma_pci_data(chip->pci),
+				  &chip->pci->dev,
 				  PAGE_SIZE, &chip->rb);
 	if (err < 0)
 		return err;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 254f24366892..5cda3488ceab 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Support for Digigram Lola PCI-e boards
  *
  *  Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the Free
- *  Software Foundation; either version 2 of the License, or (at your option)
- *  any later version.
- *
- *  This program is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- *  more details.
- *
- *  You should have received a copy of the GNU General Public License along with
- *  this program; if not, write to the Free Software Foundation, Inc., 59
- *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 
 #include <linux/kernel.h>

commit 0d9a26fc74578289e0edeac36c6d562596f8a72e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:24:06 2018 +0200

    ALSA: lola: Proper endian notations
    
    The BDL entries in lola driver are little-endian while we code them as
    u32.  This leads to sparse warnings like:
      sound/pci/lola/lola.c:105:40: warning: incorrect type in assignment (different base types)
      sound/pci/lola/lola.c:105:40:    expected unsigned int [unsigned] [usertype] <noident>
      sound/pci/lola/lola.c:105:40:    got restricted __le32 [usertype] <noident>
    
    This patch fixes the declarations to the proper __le32 type.
    
    Also, there was a typo in the original code, where __user was used
    that was intended as __iomem.  This was caused also by sparse:
      sound/pci/lola/lola_mixer.c:132:27: warning: incorrect type in assignment (different address spaces)
    Fixed in this patch as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 9ff600084973..254f24366892 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -369,9 +369,9 @@ static int setup_corb_rirb(struct lola *chip)
 		return err;
 
 	chip->corb.addr = chip->rb.addr;
-	chip->corb.buf = (u32 *)chip->rb.area;
+	chip->corb.buf = (__le32 *)chip->rb.area;
 	chip->rirb.addr = chip->rb.addr + 2048;
-	chip->rirb.buf = (u32 *)(chip->rb.area + 2048);
+	chip->rirb.buf = (__le32 *)(chip->rb.area + 2048);
 
 	/* disable ringbuffer DMAs */
 	lola_writeb(chip, BAR0, RIRBCTL, 0);

commit ff6defa6a8fae12205d64f55db395b1fcf35af8e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 3 22:55:54 2015 +0100

    ALSA: Deletion of checks before the function call "iounmap"
    
    The iounmap() function performs also input parameter validation.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 4cf4be5ef82a..9ff600084973 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -551,10 +551,8 @@ static void lola_free(struct lola *chip)
 	lola_free_mixer(chip);
 	if (chip->irq >= 0)
 		free_irq(chip->irq, (void *)chip);
-	if (chip->bar[0].remap_addr)
-		iounmap(chip->bar[0].remap_addr);
-	if (chip->bar[1].remap_addr)
-		iounmap(chip->bar[1].remap_addr);
+	iounmap(chip->bar[0].remap_addr);
+	iounmap(chip->bar[1].remap_addr);
 	if (chip->rb.area)
 		snd_dma_free_pages(&chip->rb);
 	pci_release_regions(chip->pci);

commit feabb67e0eb0f509b530a56756ea44364843faea
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Dec 10 16:06:46 2014 +0300

    ALSA: lola: NULL dereference on probe failure
    
    "card" is NULL if snd_card_new() fails.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index a75c8dc66dec..4cf4be5ef82a 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -719,7 +719,7 @@ static int lola_probe(struct pci_dev *pci,
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
 			   0, &card);
 	if (err < 0) {
-		dev_err(card->dev, "Error creating card!\n");
+		dev_err(&pci->dev, "Error creating card!\n");
 		return err;
 	}
 

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 68824cdd137d..a75c8dc66dec 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -760,7 +760,7 @@ static void lola_remove(struct pci_dev *pci)
 }
 
 /* PCI IDs */
-static DEFINE_PCI_DEVICE_TABLE(lola_ids) = {
+static const struct pci_device_id lola_ids[] = {
 	{ PCI_VDEVICE(DIGIGRAM, 0x0001) },
 	{ 0, }
 };

commit 7cf9bb21ee6df76a3a1eaa512a350cb1af00d544
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Mar 5 13:55:09 2014 +0300

    ALSA: lola: NULL deref on allocation error
    
    "chip" is NULL here.  We don't need a printk here because kmalloc() has
    it built in.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index d63434d8c3fb..68824cdd137d 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -586,7 +586,6 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 
 	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (!chip) {
-		dev_err(chip->card->dev, "cannot allocate chip\n");
 		pci_disable_device(pci);
 		return -ENOMEM;
 	}

commit f58e2fcedb44b917cdd4da94f85a81c0bc3d3ef2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 17:23:57 2014 +0100

    ALSA: lola: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 56d4f94daea2..d63434d8c3fb 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -75,7 +75,7 @@ MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
 static int debug;
 module_param(debug, int, 0644);
 #define verbose_debug(fmt, args...)			\
-	do { if (debug > 1) printk(KERN_DEBUG SFX fmt, ##args); } while (0)
+	do { if (debug > 1) pr_debug(SFX fmt, ##args); } while (0)
 #else
 #define verbose_debug(fmt, args...)
 #endif
@@ -168,7 +168,7 @@ static int rirb_get_response(struct lola *chip, unsigned int *val,
 			verbose_debug("get_response: %x, %x\n",
 				      chip->res, chip->res_ex);
 			if (chip->res_ex & LOLA_RIRB_EX_ERROR) {
-				printk(KERN_WARNING SFX "RIRB ERROR: "
+				dev_warn(chip->card->dev, "RIRB ERROR: "
 				       "NID=%x, verb=%x, data=%x, ext=%x\n",
 				       chip->last_cmd_nid,
 				       chip->last_verb, chip->last_data,
@@ -182,9 +182,9 @@ static int rirb_get_response(struct lola *chip, unsigned int *val,
 		udelay(20);
 		cond_resched();
 	}
-	printk(KERN_WARNING SFX "RIRB response error\n");
+	dev_warn(chip->card->dev, "RIRB response error\n");
 	if (!chip->polling_mode) {
-		printk(KERN_WARNING SFX "switching to polling mode\n");
+		dev_warn(chip->card->dev, "switching to polling mode\n");
 		chip->polling_mode = 1;
 		goto again;
 	}
@@ -327,7 +327,7 @@ static int reset_controller(struct lola *chip)
 			break;
 	} while (time_before(jiffies, end_time));
 	if (!gctl) {
-		printk(KERN_ERR SFX "cannot reset controller\n");
+		dev_err(chip->card->dev, "cannot reset controller\n");
 		return -EIO;
 	}
 	return 0;
@@ -452,40 +452,40 @@ static int lola_parse_tree(struct lola *chip)
 
 	err = lola_read_param(chip, 0, LOLA_PAR_VENDOR_ID, &val);
 	if (err < 0) {
-		printk(KERN_ERR SFX "Can't read VENDOR_ID\n");
+		dev_err(chip->card->dev, "Can't read VENDOR_ID\n");
 		return err;
 	}
 	val >>= 16;
 	if (val != 0x1369) {
-		printk(KERN_ERR SFX "Unknown codec vendor 0x%x\n", val);
+		dev_err(chip->card->dev, "Unknown codec vendor 0x%x\n", val);
 		return -EINVAL;
 	}
 
 	err = lola_read_param(chip, 1, LOLA_PAR_FUNCTION_TYPE, &val);
 	if (err < 0) {
-		printk(KERN_ERR SFX "Can't read FUNCTION_TYPE\n");
+		dev_err(chip->card->dev, "Can't read FUNCTION_TYPE\n");
 		return err;
 	}
 	if (val != 1) {
-		printk(KERN_ERR SFX "Unknown function type %d\n", val);
+		dev_err(chip->card->dev, "Unknown function type %d\n", val);
 		return -EINVAL;
 	}
 
 	err = lola_read_param(chip, 1, LOLA_PAR_SPECIFIC_CAPS, &val);
 	if (err < 0) {
-		printk(KERN_ERR SFX "Can't read SPECCAPS\n");
+		dev_err(chip->card->dev, "Can't read SPECCAPS\n");
 		return err;
 	}
 	chip->lola_caps = val;
 	chip->pin[CAPT].num_pins = LOLA_AFG_INPUT_PIN_COUNT(chip->lola_caps);
 	chip->pin[PLAY].num_pins = LOLA_AFG_OUTPUT_PIN_COUNT(chip->lola_caps);
-	snd_printdd(SFX "speccaps=0x%x, pins in=%d, out=%d\n",
+	dev_dbg(chip->card->dev, "speccaps=0x%x, pins in=%d, out=%d\n",
 		    chip->lola_caps,
 		    chip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);
 
 	if (chip->pin[CAPT].num_pins > MAX_AUDIO_INOUT_COUNT ||
 	    chip->pin[PLAY].num_pins > MAX_AUDIO_INOUT_COUNT) {
-		printk(KERN_ERR SFX "Invalid Lola-spec caps 0x%x\n", val);
+		dev_err(chip->card->dev, "Invalid Lola-spec caps 0x%x\n", val);
 		return -EINVAL;
 	}
 
@@ -586,7 +586,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 
 	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (!chip) {
-		snd_printk(KERN_ERR SFX "cannot allocate chip\n");
+		dev_err(chip->card->dev, "cannot allocate chip\n");
 		pci_disable_device(pci);
 		return -ENOMEM;
 	}
@@ -609,7 +609,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 		chip->sample_rate_max = 192000;
 		break;
 	default:
-		snd_printk(KERN_WARNING SFX
+		dev_warn(chip->card->dev,
 			   "Invalid granularity %d, reset to %d\n",
 			   chip->granularity, LOLA_GRANULARITY_MAX);
 		chip->granularity = LOLA_GRANULARITY_MAX;
@@ -618,7 +618,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 	}
 	chip->sample_rate_min = sample_rate_min[dev];
 	if (chip->sample_rate_min > chip->sample_rate_max) {
-		snd_printk(KERN_WARNING SFX
+		dev_warn(chip->card->dev,
 			   "Invalid sample_rate_min %d, reset to 16000\n",
 			   chip->sample_rate_min);
 		chip->sample_rate_min = 16000;
@@ -636,7 +636,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 	chip->bar[1].addr = pci_resource_start(pci, 2);
 	chip->bar[1].remap_addr = pci_ioremap_bar(pci, 2);
 	if (!chip->bar[0].remap_addr || !chip->bar[1].remap_addr) {
-		snd_printk(KERN_ERR SFX "ioremap error\n");
+		dev_err(chip->card->dev, "ioremap error\n");
 		err = -ENXIO;
 		goto errout;
 	}
@@ -649,7 +649,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 
 	if (request_irq(pci->irq, lola_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, chip)) {
-		printk(KERN_ERR SFX "unable to grab IRQ %d\n", pci->irq);
+		dev_err(chip->card->dev, "unable to grab IRQ %d\n", pci->irq);
 		err = -EBUSY;
 		goto errout;
 	}
@@ -660,7 +660,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 	chip->pcm[CAPT].num_streams = (dever >> 0) & 0x3ff;
 	chip->pcm[PLAY].num_streams = (dever >> 10) & 0x3ff;
 	chip->version = (dever >> 24) & 0xff;
-	snd_printdd(SFX "streams in=%d, out=%d, version=0x%x\n",
+	dev_dbg(chip->card->dev, "streams in=%d, out=%d, version=0x%x\n",
 		    chip->pcm[CAPT].num_streams, chip->pcm[PLAY].num_streams,
 		    chip->version);
 
@@ -669,7 +669,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 	    chip->pcm[PLAY].num_streams > MAX_STREAM_OUT_COUNT ||
 	    (!chip->pcm[CAPT].num_streams &&
 	     !chip->pcm[PLAY].num_streams)) {
-		printk(KERN_ERR SFX "invalid DEVER = %x\n", dever);
+		dev_err(chip->card->dev, "invalid DEVER = %x\n", dever);
 		err = -EINVAL;
 		goto errout;
 	}
@@ -680,7 +680,7 @@ static int lola_create(struct snd_card *card, struct pci_dev *pci,
 
 	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
 	if (err < 0) {
-		snd_printk(KERN_ERR SFX "Error creating device [card]!\n");
+		dev_err(chip->card->dev, "Error creating device [card]!\n");
 		goto errout;
 	}
 
@@ -720,7 +720,7 @@ static int lola_probe(struct pci_dev *pci,
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
 			   0, &card);
 	if (err < 0) {
-		snd_printk(KERN_ERR SFX "Error creating card!\n");
+		dev_err(card->dev, "Error creating card!\n");
 		return err;
 	}
 

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 0568540dc8d3..56d4f94daea2 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -717,14 +717,13 @@ static int lola_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 	if (err < 0) {
 		snd_printk(KERN_ERR SFX "Error creating card!\n");
 		return err;
 	}
 
-	snd_card_set_dev(card, &pci->dev);
-
 	err = lola_create(card, pci, dev, &chip);
 	if (err < 0)
 		goto out_free;

commit 9cd5ab9c3c32767e5c5e76bed9b0e2b84512f936
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 29 16:51:36 2013 +0100

    ALSA: lola: Fix uninitialized variable access in error message
    
    The FUNCTION_TYPE parameter isn't associated with any NID, thus
    showing the uninitialized nid in the error message is simply
    nonsense.
    
    Spotted by coverity CID 145068.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 7307d97186cb..0568540dc8d3 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -463,7 +463,7 @@ static int lola_parse_tree(struct lola *chip)
 
 	err = lola_read_param(chip, 1, LOLA_PAR_FUNCTION_TYPE, &val);
 	if (err < 0) {
-		printk(KERN_ERR SFX "Can't read FUNCTION_TYPE for 0x%x\n", nid);
+		printk(KERN_ERR SFX "Can't read FUNCTION_TYPE\n");
 		return err;
 	}
 	if (val != 1) {

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 322b638e8ec4..7307d97186cb 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -759,7 +759,6 @@ static int lola_probe(struct pci_dev *pci,
 static void lola_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 /* PCI IDs */

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index ac15166bee68..322b638e8ec4 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -445,7 +445,7 @@ static void lola_reset_setups(struct lola *chip)
 	lola_setup_all_analog_gains(chip, PLAY, false); /* output, update */
 }
 
-static int __devinit lola_parse_tree(struct lola *chip)
+static int lola_parse_tree(struct lola *chip)
 {
 	unsigned int val;
 	int nid, err;
@@ -568,8 +568,8 @@ static int lola_dev_free(struct snd_device *device)
 	return 0;
 }
 
-static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
-				 int dev, struct lola **rchip)
+static int lola_create(struct snd_card *card, struct pci_dev *pci,
+		       int dev, struct lola **rchip)
 {
 	struct lola *chip;
 	int err;
@@ -702,8 +702,8 @@ static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
 	return err;
 }
 
-static int __devinit lola_probe(struct pci_dev *pci,
-				const struct pci_device_id *pci_id)
+static int lola_probe(struct pci_dev *pci,
+		      const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_card *card;
@@ -756,7 +756,7 @@ static int __devinit lola_probe(struct pci_dev *pci,
 	return err;
 }
 
-static void __devexit lola_remove(struct pci_dev *pci)
+static void lola_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -774,7 +774,7 @@ static struct pci_driver lola_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = lola_ids,
 	.probe = lola_probe,
-	.remove = __devexit_p(lola_remove),
+	.remove = lola_remove,
 };
 
 module_pci_driver(lola_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 375982736858..ac15166bee68 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -770,22 +770,11 @@ static DEFINE_PCI_DEVICE_TABLE(lola_ids) = {
 MODULE_DEVICE_TABLE(pci, lola_ids);
 
 /* pci_driver definition */
-static struct pci_driver driver = {
+static struct pci_driver lola_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = lola_ids,
 	.probe = lola_probe,
 	.remove = __devexit_p(lola_remove),
 };
 
-static int __init alsa_card_lola_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_lola_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_lola_init)
-module_exit(alsa_card_lola_exit)
+module_pci_driver(lola_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 924168ef1ed6..375982736858 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -35,7 +35,7 @@
 /* Standard options */
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for Digigram Lola driver.");

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 3e92e5b5ec3d..924168ef1ed6 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -20,7 +20,7 @@
 
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/dma-mapping.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit 3409fcd1f71d02025e3f179127a8ba243c525d78
Merge: f4b1e98aa93d ad2409413d09
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 17 14:54:47 2011 +0200

    Merge branch 'fix/hda' into topic/misc

commit e72888e91cc902ccdc089f237b6eed7587e2b4df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 15 15:14:49 2011 +0200

    ALSA: lola - Fix section mismatch
    
    Add missing __devinit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 34b24286d279..2692e5ae5f2d 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -445,7 +445,7 @@ static void lola_reset_setups(struct lola *chip)
 	lola_setup_all_analog_gains(chip, PLAY, false); /* output, update */
 }
 
-static int lola_parse_tree(struct lola *chip)
+static int __devinit lola_parse_tree(struct lola *chip)
 {
 	unsigned int val;
 	int nid, err;

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 77c5e8675419..1dc6f5b1d668 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -648,7 +648,7 @@ static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
 		goto errout;
 
 	if (request_irq(pci->irq, lola_interrupt, IRQF_SHARED,
-			DRVNAME, chip)) {
+			KBUILD_MODNAME, chip)) {
 		printk(KERN_ERR SFX "unable to grab IRQ %d\n", pci->irq);
 		err = -EBUSY;
 		goto errout;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 34b24286d279..77c5e8675419 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -771,7 +771,7 @@ MODULE_DEVICE_TABLE(pci, lola_ids);
 
 /* pci_driver definition */
 static struct pci_driver driver = {
-	.name = DRVNAME,
+	.name = KBUILD_MODNAME,
 	.id_table = lola_ids,
 	.probe = lola_probe,
 	.remove = __devexit_p(lola_remove),

commit fe4af1b55ed76e3051bbd8abce7d6b3c504272a5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 17:06:53 2011 +0200

    ALSA: lola - Implement polling_mode like hd-audio
    
    Also protect the call of lola_update_rirb() with spinlock.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 8ee22bee10c9..34b24286d279 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -153,8 +153,14 @@ static int rirb_get_response(struct lola *chip, unsigned int *val,
 {
 	unsigned long timeout;
 
+ again:
 	timeout = jiffies + msecs_to_jiffies(1000);
 	for (;;) {
+		if (chip->polling_mode) {
+			spin_lock_irq(&chip->reg_lock);
+			lola_update_rirb(chip);
+			spin_unlock_irq(&chip->reg_lock);
+		}
 		if (!chip->rirb.cmds) {
 			*val = chip->res;
 			if (extval)
@@ -175,9 +181,13 @@ static int rirb_get_response(struct lola *chip, unsigned int *val,
 			break;
 		udelay(20);
 		cond_resched();
-		lola_update_rirb(chip);
 	}
 	printk(KERN_WARNING SFX "RIRB response error\n");
+	if (!chip->polling_mode) {
+		printk(KERN_WARNING SFX "switching to polling mode\n");
+		chip->polling_mode = 1;
+		goto again;
+	}
 	return -EIO;
 }
 

commit 8bd172dc96fba8ba5a7560afdc1ff7461c278e86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:51:56 2011 +0200

    ALSA: lola - Allow granularity changes
    
    Add some sanity checks.
    Change PCM parameters appropriately per granularity.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 3d2516b11f22..8ee22bee10c9 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -587,14 +587,31 @@ static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
 	chip->pci = pci;
 	chip->irq = -1;
 
-	chip->sample_rate_min = sample_rate_min[dev];
 	chip->granularity = granularity[dev];
-	/* FIXME */
-	if (chip->granularity != LOLA_GRANULARITY_MAX) {
+	switch (chip->granularity) {
+	case 8:
+		chip->sample_rate_max = 48000;
+		break;
+	case 16:
+		chip->sample_rate_max = 96000;
+		break;
+	case 32:
+		chip->sample_rate_max = 192000;
+		break;
+	default:
 		snd_printk(KERN_WARNING SFX
-			   "Only %d granularity is supported for now\n",
-			   LOLA_GRANULARITY_MAX);
+			   "Invalid granularity %d, reset to %d\n",
+			   chip->granularity, LOLA_GRANULARITY_MAX);
 		chip->granularity = LOLA_GRANULARITY_MAX;
+		chip->sample_rate_max = 192000;
+		break;
+	}
+	chip->sample_rate_min = sample_rate_min[dev];
+	if (chip->sample_rate_min > chip->sample_rate_max) {
+		snd_printk(KERN_WARNING SFX
+			   "Invalid sample_rate_min %d, reset to 16000\n",
+			   chip->sample_rate_min);
+		chip->sample_rate_min = 16000;
 	}
 
 	err = pci_request_regions(pci, DRVNAME);

commit 972505ccde9a3bdc8455f4cf3d3f37d17f8f10a3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:50:51 2011 +0200

    ALSA: lola - Use SG-buffer
    
    Completely switch to SG-buffer now, as it's working stably.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 7c13ace3c33b..3d2516b11f22 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -588,7 +588,6 @@ static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
 	chip->irq = -1;
 
 	chip->sample_rate_min = sample_rate_min[dev];
-
 	chip->granularity = granularity[dev];
 	/* FIXME */
 	if (chip->granularity != LOLA_GRANULARITY_MAX) {

commit fe3d393eda2a716c2ea7fcd63e105657911ed245
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:48:59 2011 +0200

    ALSA: lola - Add Lola-specific module options
    
    Added granularity and sample_rate_min module options.
    
    The former controls the h/w access granularity.  As default, it's set
    to the max value 32.
    
    The latter controls the minimum sample rate in Hz, as default 16000.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 4d8221505b9e..7c13ace3c33b 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -32,6 +32,7 @@
 #include <sound/initval.h>
 #include "lola.h"
 
+/* Standard options */
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
@@ -43,6 +44,28 @@ MODULE_PARM_DESC(id, "ID string for Digigram Lola driver.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable Digigram Lola driver.");
 
+/* Lola-specific options */
+
+/* for instance use always max granularity which is compatible
+ * with all sample rates
+ */
+static int granularity[SNDRV_CARDS] = {
+	[0 ... (SNDRV_CARDS - 1)] = LOLA_GRANULARITY_MAX
+};
+
+/* below a sample_rate of 16kHz the analogue audio quality is NOT excellent */
+static int sample_rate_min[SNDRV_CARDS] = {
+	[0 ... (SNDRV_CARDS - 1) ] = 16000
+};
+
+module_param_array(granularity, int, NULL, 0444);
+MODULE_PARM_DESC(granularity, "Granularity value");
+module_param_array(sample_rate_min, int, NULL, 0444);
+MODULE_PARM_DESC(sample_rate_min, "Minimal sample rate");
+
+/*
+ */
+
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Digigram, Lola}}");
 MODULE_DESCRIPTION("Digigram Lola driver");
@@ -536,7 +559,7 @@ static int lola_dev_free(struct snd_device *device)
 }
 
 static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
-				 struct lola **rchip)
+				 int dev, struct lola **rchip)
 {
 	struct lola *chip;
 	int err;
@@ -564,14 +587,16 @@ static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
 	chip->pci = pci;
 	chip->irq = -1;
 
-	/* below a sample_rate of 16kHz the analogue audio quality
-	 * is NOT excellent
-	 */
-	chip->sample_rate_min = 16000;
-	/* for instance use always max granularity which is compatible
-	 * with all sample rates
-	 */
-	chip->granularity = LOLA_GRANULARITY_MAX;
+	chip->sample_rate_min = sample_rate_min[dev];
+
+	chip->granularity = granularity[dev];
+	/* FIXME */
+	if (chip->granularity != LOLA_GRANULARITY_MAX) {
+		snd_printk(KERN_WARNING SFX
+			   "Only %d granularity is supported for now\n",
+			   LOLA_GRANULARITY_MAX);
+		chip->granularity = LOLA_GRANULARITY_MAX;
+	}
 
 	err = pci_request_regions(pci, DRVNAME);
 	if (err < 0) {
@@ -674,7 +699,7 @@ static int __devinit lola_probe(struct pci_dev *pci,
 
 	snd_card_set_dev(card, &pci->dev);
 
-	err = lola_create(card, pci, &chip);
+	err = lola_create(card, pci, dev, &chip);
 	if (err < 0)
 		goto out_free;
 	card->private_data = chip;

commit 0f8f56c959c9c4a65a5ad13f1b49d97db30b5c2f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:47:03 2011 +0200

    ALSA: lola - Fix PCM stalls
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index 16c6cad2e7cd..4d8221505b9e 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -73,6 +73,7 @@ static int corb_send_verb(struct lola *chip, unsigned int nid,
 	chip->last_data = data;
 	chip->last_extdata = extdata;
 	data |= (nid << 20) | (verb << 8);
+
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	if (chip->rirb.cmds < LOLA_CORB_ENTRIES - 1) {
 		unsigned int wp = chip->corb.wp + 1;
@@ -338,8 +339,6 @@ static int setup_corb_rirb(struct lola *chip)
 	chip->corb.buf = (u32 *)chip->rb.area;
 	chip->rirb.addr = chip->rb.addr + 2048;
 	chip->rirb.buf = (u32 *)(chip->rb.area + 2048);
-	lola_writel(chip, BAR0, CORBLBASE, (u32)chip->corb.addr);
-	lola_writel(chip, BAR0, CORBUBASE, upper_32_bits(chip->corb.addr));
 
 	/* disable ringbuffer DMAs */
 	lola_writeb(chip, BAR0, RIRBCTL, 0);
@@ -496,6 +495,10 @@ static int lola_parse_tree(struct lola *chip)
 	if (!chip->cold_reset) {
 		lola_reset_setups(chip);
 		chip->cold_reset = 1;
+	} else {
+		/* set the granularity if it is not the default */
+		if (chip->granularity != LOLA_GRANULARITY_MIN)
+			lola_set_granularity(chip, chip->granularity, true);
 	}
 
 	return 0;
@@ -561,8 +564,14 @@ static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
 	chip->pci = pci;
 	chip->irq = -1;
 
-	chip->sample_rate_min = 48000;
-	chip->granularity = LOLA_GRANULARITY_MIN;
+	/* below a sample_rate of 16kHz the analogue audio quality
+	 * is NOT excellent
+	 */
+	chip->sample_rate_min = 16000;
+	/* for instance use always max granularity which is compatible
+	 * with all sample rates
+	 */
+	chip->granularity = LOLA_GRANULARITY_MAX;
 
 	err = pci_request_regions(pci, DRVNAME);
 	if (err < 0) {

commit a426c787233c87587b6cac797ac840162bdb09c2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:36:09 2011 +0200

    ALSA: lola - Suppress the debug print
    
    Use snd_printdd() for less important debug messages.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index f59ce085a1a4..16c6cad2e7cd 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -447,9 +447,9 @@ static int lola_parse_tree(struct lola *chip)
 	chip->lola_caps = val;
 	chip->pin[CAPT].num_pins = LOLA_AFG_INPUT_PIN_COUNT(chip->lola_caps);
 	chip->pin[PLAY].num_pins = LOLA_AFG_OUTPUT_PIN_COUNT(chip->lola_caps);
-	snd_printd(SFX "speccaps=0x%x, pins in=%d, out=%d\n",
-		   chip->lola_caps,
-		   chip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);
+	snd_printdd(SFX "speccaps=0x%x, pins in=%d, out=%d\n",
+		    chip->lola_caps,
+		    chip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);
 
 	if (chip->pin[CAPT].num_pins > MAX_AUDIO_INOUT_COUNT ||
 	    chip->pin[PLAY].num_pins > MAX_AUDIO_INOUT_COUNT) {
@@ -600,7 +600,7 @@ static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
 	chip->pcm[CAPT].num_streams = (dever >> 0) & 0x3ff;
 	chip->pcm[PLAY].num_streams = (dever >> 10) & 0x3ff;
 	chip->version = (dever >> 24) & 0xff;
-	snd_printd(SFX "streams in=%d, out=%d, version=0x%x\n",
+	snd_printdd(SFX "streams in=%d, out=%d, version=0x%x\n",
 		    chip->pcm[CAPT].num_streams, chip->pcm[PLAY].num_streams,
 		    chip->version);
 

commit d43f3010b8fa7530c3780c087fad9b0a8a437ba1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:14:46 2011 +0200

    ALSA: Add the driver for Digigram Lola PCI-e boards
    
    Added a new driver for supporting Digigram Lola PCI-e boards.
    
    Lola has a similar h/w design like HD-audio but with extended verbs.
    Thus the driver is written similarly like HD-audio driver in the bus
    part.  The codec part is rather written in a fixed way specific to the
    Lola board because of the verb incompatibility.
    
    The driver provides basic PCM, supporting multi-streams and mixing.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
new file mode 100644
index 000000000000..f59ce085a1a4
--- /dev/null
+++ b/sound/pci/lola/lola.c
@@ -0,0 +1,731 @@
+/*
+ *  Support for Digigram Lola PCI-e boards
+ *
+ *  Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with
+ *  this program; if not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include "lola.h"
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for Digigram Lola driver.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for Digigram Lola driver.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable Digigram Lola driver.");
+
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Digigram, Lola}}");
+MODULE_DESCRIPTION("Digigram Lola driver");
+MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
+
+#ifdef CONFIG_SND_DEBUG_VERBOSE
+static int debug;
+module_param(debug, int, 0644);
+#define verbose_debug(fmt, args...)			\
+	do { if (debug > 1) printk(KERN_DEBUG SFX fmt, ##args); } while (0)
+#else
+#define verbose_debug(fmt, args...)
+#endif
+
+/*
+ * pseudo-codec read/write via CORB/RIRB
+ */
+
+static int corb_send_verb(struct lola *chip, unsigned int nid,
+			  unsigned int verb, unsigned int data,
+			  unsigned int extdata)
+{
+	unsigned long flags;
+	int ret = -EIO;
+
+	chip->last_cmd_nid = nid;
+	chip->last_verb = verb;
+	chip->last_data = data;
+	chip->last_extdata = extdata;
+	data |= (nid << 20) | (verb << 8);
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	if (chip->rirb.cmds < LOLA_CORB_ENTRIES - 1) {
+		unsigned int wp = chip->corb.wp + 1;
+		wp %= LOLA_CORB_ENTRIES;
+		chip->corb.wp = wp;
+		chip->corb.buf[wp * 2] = cpu_to_le32(data);
+		chip->corb.buf[wp * 2 + 1] = cpu_to_le32(extdata);
+		lola_writew(chip, BAR0, CORBWP, wp);
+		chip->rirb.cmds++;
+		smp_wmb();
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return ret;
+}
+
+static void lola_queue_unsol_event(struct lola *chip, unsigned int res,
+				   unsigned int res_ex)
+{
+	lola_update_ext_clock_freq(chip, res);
+}
+
+/* retrieve RIRB entry - called from interrupt handler */
+static void lola_update_rirb(struct lola *chip)
+{
+	unsigned int rp, wp;
+	u32 res, res_ex;
+
+	wp = lola_readw(chip, BAR0, RIRBWP);
+	if (wp == chip->rirb.wp)
+		return;
+	chip->rirb.wp = wp;
+
+	while (chip->rirb.rp != wp) {
+		chip->rirb.rp++;
+		chip->rirb.rp %= LOLA_CORB_ENTRIES;
+
+		rp = chip->rirb.rp << 1; /* an RIRB entry is 8-bytes */
+		res_ex = le32_to_cpu(chip->rirb.buf[rp + 1]);
+		res = le32_to_cpu(chip->rirb.buf[rp]);
+		if (res_ex & LOLA_RIRB_EX_UNSOL_EV)
+			lola_queue_unsol_event(chip, res, res_ex);
+		else if (chip->rirb.cmds) {
+			chip->res = res;
+			chip->res_ex = res_ex;
+			smp_wmb();
+			chip->rirb.cmds--;
+		}
+	}
+}
+
+static int rirb_get_response(struct lola *chip, unsigned int *val,
+			     unsigned int *extval)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(1000);
+	for (;;) {
+		if (!chip->rirb.cmds) {
+			*val = chip->res;
+			if (extval)
+				*extval = chip->res_ex;
+			verbose_debug("get_response: %x, %x\n",
+				      chip->res, chip->res_ex);
+			if (chip->res_ex & LOLA_RIRB_EX_ERROR) {
+				printk(KERN_WARNING SFX "RIRB ERROR: "
+				       "NID=%x, verb=%x, data=%x, ext=%x\n",
+				       chip->last_cmd_nid,
+				       chip->last_verb, chip->last_data,
+				       chip->last_extdata);
+				return -EIO;
+			}
+			return 0;
+		}
+		if (time_after(jiffies, timeout))
+			break;
+		udelay(20);
+		cond_resched();
+		lola_update_rirb(chip);
+	}
+	printk(KERN_WARNING SFX "RIRB response error\n");
+	return -EIO;
+}
+
+/* aynchronous write of a codec verb with data */
+int lola_codec_write(struct lola *chip, unsigned int nid, unsigned int verb,
+		     unsigned int data, unsigned int extdata)
+{
+	verbose_debug("codec_write NID=%x, verb=%x, data=%x, ext=%x\n",
+		      nid, verb, data, extdata);
+	return corb_send_verb(chip, nid, verb, data, extdata);
+}
+
+/* write a codec verb with data and read the returned status */
+int lola_codec_read(struct lola *chip, unsigned int nid, unsigned int verb,
+		    unsigned int data, unsigned int extdata,
+		    unsigned int *val, unsigned int *extval)
+{
+	int err;
+
+	verbose_debug("codec_read NID=%x, verb=%x, data=%x, ext=%x\n",
+		      nid, verb, data, extdata);
+	err = corb_send_verb(chip, nid, verb, data, extdata);
+	if (err < 0)
+		return err;
+	err = rirb_get_response(chip, val, extval);
+	return err;
+}
+
+/* flush all pending codec writes */
+int lola_codec_flush(struct lola *chip)
+{
+	unsigned int tmp;
+	return rirb_get_response(chip, &tmp, NULL);
+}
+
+/*
+ * interrupt handler
+ */
+static irqreturn_t lola_interrupt(int irq, void *dev_id)
+{
+	struct lola *chip = dev_id;
+	unsigned int notify_ins, notify_outs, error_ins, error_outs;
+	int handled = 0;
+	int i;
+
+	notify_ins = notify_outs = error_ins = error_outs = 0;
+	spin_lock(&chip->reg_lock);
+	for (;;) {
+		unsigned int status, in_sts, out_sts;
+		unsigned int reg;
+
+		status = lola_readl(chip, BAR1, DINTSTS);
+		if (!status || status == -1)
+			break;
+
+		in_sts = lola_readl(chip, BAR1, DIINTSTS);
+		out_sts = lola_readl(chip, BAR1, DOINTSTS);
+
+		/* clear Input Interrupts */
+		for (i = 0; in_sts && i < chip->pcm[CAPT].num_streams; i++) {
+			if (!(in_sts & (1 << i)))
+				continue;
+			in_sts &= ~(1 << i);
+			reg = lola_dsd_read(chip, i, STS);
+			if (reg & LOLA_DSD_STS_DESE) /* error */
+				error_ins |= (1 << i);
+			if (reg & LOLA_DSD_STS_BCIS) /* notify */
+				notify_ins |= (1 << i);
+			/* clear */
+			lola_dsd_write(chip, i, STS, reg);
+		}
+
+		/* clear Output Interrupts */
+		for (i = 0; out_sts && i < chip->pcm[PLAY].num_streams; i++) {
+			if (!(out_sts & (1 << i)))
+				continue;
+			out_sts &= ~(1 << i);
+			reg = lola_dsd_read(chip, i + MAX_STREAM_IN_COUNT, STS);
+			if (reg & LOLA_DSD_STS_DESE) /* error */
+				error_outs |= (1 << i);
+			if (reg & LOLA_DSD_STS_BCIS) /* notify */
+				notify_outs |= (1 << i);
+			lola_dsd_write(chip, i + MAX_STREAM_IN_COUNT, STS, reg);
+		}
+
+		if (status & LOLA_DINT_CTRL) {
+			unsigned char rbsts; /* ring status is byte access */
+			rbsts = lola_readb(chip, BAR0, RIRBSTS);
+			rbsts &= LOLA_RIRB_INT_MASK;
+			if (rbsts)
+				lola_writeb(chip, BAR0, RIRBSTS, rbsts);
+			rbsts = lola_readb(chip, BAR0, CORBSTS);
+			rbsts &= LOLA_CORB_INT_MASK;
+			if (rbsts)
+				lola_writeb(chip, BAR0, CORBSTS, rbsts);
+
+			lola_update_rirb(chip);
+		}
+
+		if (status & (LOLA_DINT_FIFOERR | LOLA_DINT_MUERR)) {
+			/* clear global fifo error interrupt */
+			lola_writel(chip, BAR1, DINTSTS,
+				    (status & (LOLA_DINT_FIFOERR | LOLA_DINT_MUERR)));
+		}
+		handled = 1;
+	}
+	spin_unlock(&chip->reg_lock);
+
+	lola_pcm_update(chip, &chip->pcm[CAPT], notify_ins);
+	lola_pcm_update(chip, &chip->pcm[PLAY], notify_outs);
+
+	return IRQ_RETVAL(handled);
+}
+
+
+/*
+ * controller
+ */
+static int reset_controller(struct lola *chip)
+{
+	unsigned int gctl = lola_readl(chip, BAR0, GCTL);
+	unsigned long end_time;
+
+	if (gctl) {
+		/* to be sure */
+		lola_writel(chip, BAR1, BOARD_MODE, 0);
+		return 0;
+	}
+
+	chip->cold_reset = 1;
+	lola_writel(chip, BAR0, GCTL, LOLA_GCTL_RESET);
+	end_time = jiffies + msecs_to_jiffies(200);
+	do {
+		msleep(1);
+		gctl = lola_readl(chip, BAR0, GCTL);
+		if (gctl)
+			break;
+	} while (time_before(jiffies, end_time));
+	if (!gctl) {
+		printk(KERN_ERR SFX "cannot reset controller\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static void lola_irq_enable(struct lola *chip)
+{
+	unsigned int val;
+
+	/* enalbe all I/O streams */
+	val = (1 << chip->pcm[PLAY].num_streams) - 1;
+	lola_writel(chip, BAR1, DOINTCTL, val);
+	val = (1 << chip->pcm[CAPT].num_streams) - 1;
+	lola_writel(chip, BAR1, DIINTCTL, val);
+
+	/* enable global irqs */
+	val = LOLA_DINT_GLOBAL | LOLA_DINT_CTRL | LOLA_DINT_FIFOERR |
+		LOLA_DINT_MUERR;
+	lola_writel(chip, BAR1, DINTCTL, val);
+}
+
+static void lola_irq_disable(struct lola *chip)
+{
+	lola_writel(chip, BAR1, DINTCTL, 0);
+	lola_writel(chip, BAR1, DIINTCTL, 0);
+	lola_writel(chip, BAR1, DOINTCTL, 0);
+}
+
+static int setup_corb_rirb(struct lola *chip)
+{
+	int err;
+	unsigned char tmp;
+	unsigned long end_time;
+
+	err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+				  snd_dma_pci_data(chip->pci),
+				  PAGE_SIZE, &chip->rb);
+	if (err < 0)
+		return err;
+
+	chip->corb.addr = chip->rb.addr;
+	chip->corb.buf = (u32 *)chip->rb.area;
+	chip->rirb.addr = chip->rb.addr + 2048;
+	chip->rirb.buf = (u32 *)(chip->rb.area + 2048);
+	lola_writel(chip, BAR0, CORBLBASE, (u32)chip->corb.addr);
+	lola_writel(chip, BAR0, CORBUBASE, upper_32_bits(chip->corb.addr));
+
+	/* disable ringbuffer DMAs */
+	lola_writeb(chip, BAR0, RIRBCTL, 0);
+	lola_writeb(chip, BAR0, CORBCTL, 0);
+
+	end_time = jiffies + msecs_to_jiffies(200);
+	do {
+		if (!lola_readb(chip, BAR0, RIRBCTL) &&
+		    !lola_readb(chip, BAR0, CORBCTL))
+			break;
+		msleep(1);
+	} while (time_before(jiffies, end_time));
+
+	/* CORB set up */
+	lola_writel(chip, BAR0, CORBLBASE, (u32)chip->corb.addr);
+	lola_writel(chip, BAR0, CORBUBASE, upper_32_bits(chip->corb.addr));
+	/* set the corb size to 256 entries */
+	lola_writeb(chip, BAR0, CORBSIZE, 0x02);
+	/* set the corb write pointer to 0 */
+	lola_writew(chip, BAR0, CORBWP, 0);
+	/* reset the corb hw read pointer */
+	lola_writew(chip, BAR0, CORBRP, LOLA_RBRWP_CLR);
+	/* enable corb dma */
+	lola_writeb(chip, BAR0, CORBCTL, LOLA_RBCTL_DMA_EN);
+	/* clear flags if set */
+	tmp = lola_readb(chip, BAR0, CORBSTS) & LOLA_CORB_INT_MASK;
+	if (tmp)
+		lola_writeb(chip, BAR0, CORBSTS, tmp);
+	chip->corb.wp = 0;
+
+	/* RIRB set up */
+	lola_writel(chip, BAR0, RIRBLBASE, (u32)chip->rirb.addr);
+	lola_writel(chip, BAR0, RIRBUBASE, upper_32_bits(chip->rirb.addr));
+	/* set the rirb size to 256 entries */
+	lola_writeb(chip, BAR0, RIRBSIZE, 0x02);
+	/* reset the rirb hw write pointer */
+	lola_writew(chip, BAR0, RIRBWP, LOLA_RBRWP_CLR);
+	/* set N=1, get RIRB response interrupt for new entry */
+	lola_writew(chip, BAR0, RINTCNT, 1);
+	/* enable rirb dma and response irq */
+	lola_writeb(chip, BAR0, RIRBCTL, LOLA_RBCTL_DMA_EN | LOLA_RBCTL_IRQ_EN);
+	/* clear flags if set */
+	tmp =  lola_readb(chip, BAR0, RIRBSTS) & LOLA_RIRB_INT_MASK;
+	if (tmp)
+		lola_writeb(chip, BAR0, RIRBSTS, tmp);
+	chip->rirb.rp = chip->rirb.cmds = 0;
+
+	return 0;
+}
+
+static void stop_corb_rirb(struct lola *chip)
+{
+	/* disable ringbuffer DMAs */
+	lola_writeb(chip, BAR0, RIRBCTL, 0);
+	lola_writeb(chip, BAR0, CORBCTL, 0);
+}
+
+static void lola_reset_setups(struct lola *chip)
+{
+	/* update the granularity */
+	lola_set_granularity(chip, chip->granularity, true);
+	/* update the sample clock */
+	lola_set_clock_index(chip, chip->clock.cur_index);
+	/* enable unsolicited events of the clock widget */
+	lola_enable_clock_events(chip);
+	/* update the analog gains */
+	lola_setup_all_analog_gains(chip, CAPT, false); /* input, update */
+	/* update SRC configuration if applicable */
+	lola_set_src_config(chip, chip->input_src_mask, false);
+	/* update the analog outputs */
+	lola_setup_all_analog_gains(chip, PLAY, false); /* output, update */
+}
+
+static int lola_parse_tree(struct lola *chip)
+{
+	unsigned int val;
+	int nid, err;
+
+	err = lola_read_param(chip, 0, LOLA_PAR_VENDOR_ID, &val);
+	if (err < 0) {
+		printk(KERN_ERR SFX "Can't read VENDOR_ID\n");
+		return err;
+	}
+	val >>= 16;
+	if (val != 0x1369) {
+		printk(KERN_ERR SFX "Unknown codec vendor 0x%x\n", val);
+		return -EINVAL;
+	}
+
+	err = lola_read_param(chip, 1, LOLA_PAR_FUNCTION_TYPE, &val);
+	if (err < 0) {
+		printk(KERN_ERR SFX "Can't read FUNCTION_TYPE for 0x%x\n", nid);
+		return err;
+	}
+	if (val != 1) {
+		printk(KERN_ERR SFX "Unknown function type %d\n", val);
+		return -EINVAL;
+	}
+
+	err = lola_read_param(chip, 1, LOLA_PAR_SPECIFIC_CAPS, &val);
+	if (err < 0) {
+		printk(KERN_ERR SFX "Can't read SPECCAPS\n");
+		return err;
+	}
+	chip->lola_caps = val;
+	chip->pin[CAPT].num_pins = LOLA_AFG_INPUT_PIN_COUNT(chip->lola_caps);
+	chip->pin[PLAY].num_pins = LOLA_AFG_OUTPUT_PIN_COUNT(chip->lola_caps);
+	snd_printd(SFX "speccaps=0x%x, pins in=%d, out=%d\n",
+		   chip->lola_caps,
+		   chip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);
+
+	if (chip->pin[CAPT].num_pins > MAX_AUDIO_INOUT_COUNT ||
+	    chip->pin[PLAY].num_pins > MAX_AUDIO_INOUT_COUNT) {
+		printk(KERN_ERR SFX "Invalid Lola-spec caps 0x%x\n", val);
+		return -EINVAL;
+	}
+
+	nid = 0x02;
+	err = lola_init_pcm(chip, CAPT, &nid);
+	if (err < 0)
+		return err;
+	err = lola_init_pcm(chip, PLAY, &nid);
+	if (err < 0)
+		return err;
+
+	err = lola_init_pins(chip, CAPT, &nid);
+	if (err < 0)
+		return err;
+	err = lola_init_pins(chip, PLAY, &nid);
+	if (err < 0)
+		return err;
+
+	if (LOLA_AFG_CLOCK_WIDGET_PRESENT(chip->lola_caps)) {
+		err = lola_init_clock_widget(chip, nid);
+		if (err < 0)
+			return err;
+		nid++;
+	}
+	if (LOLA_AFG_MIXER_WIDGET_PRESENT(chip->lola_caps)) {
+		err = lola_init_mixer_widget(chip, nid);
+		if (err < 0)
+			return err;
+		nid++;
+	}
+
+	/* enable unsolicited events of the clock widget */
+	err = lola_enable_clock_events(chip);
+	if (err < 0)
+		return err;
+
+	/* if last ResetController was not a ColdReset, we don't know
+	 * the state of the card; initialize here again
+	 */
+	if (!chip->cold_reset) {
+		lola_reset_setups(chip);
+		chip->cold_reset = 1;
+	}
+
+	return 0;
+}
+
+static void lola_stop_hw(struct lola *chip)
+{
+	stop_corb_rirb(chip);
+	lola_irq_disable(chip);
+}
+
+static void lola_free(struct lola *chip)
+{
+	if (chip->initialized)
+		lola_stop_hw(chip);
+	lola_free_pcm(chip);
+	lola_free_mixer(chip);
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void *)chip);
+	if (chip->bar[0].remap_addr)
+		iounmap(chip->bar[0].remap_addr);
+	if (chip->bar[1].remap_addr)
+		iounmap(chip->bar[1].remap_addr);
+	if (chip->rb.area)
+		snd_dma_free_pages(&chip->rb);
+	pci_release_regions(chip->pci);
+	pci_disable_device(chip->pci);
+	kfree(chip);
+}
+
+static int lola_dev_free(struct snd_device *device)
+{
+	lola_free(device->device_data);
+	return 0;
+}
+
+static int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,
+				 struct lola **rchip)
+{
+	struct lola *chip;
+	int err;
+	unsigned int dever;
+	static struct snd_device_ops ops = {
+		.dev_free = lola_dev_free,
+	};
+
+	*rchip = NULL;
+
+	err = pci_enable_device(pci);
+	if (err < 0)
+		return err;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip) {
+		snd_printk(KERN_ERR SFX "cannot allocate chip\n");
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&chip->reg_lock);
+	mutex_init(&chip->open_mutex);
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+
+	chip->sample_rate_min = 48000;
+	chip->granularity = LOLA_GRANULARITY_MIN;
+
+	err = pci_request_regions(pci, DRVNAME);
+	if (err < 0) {
+		kfree(chip);
+		pci_disable_device(pci);
+		return err;
+	}
+
+	chip->bar[0].addr = pci_resource_start(pci, 0);
+	chip->bar[0].remap_addr = pci_ioremap_bar(pci, 0);
+	chip->bar[1].addr = pci_resource_start(pci, 2);
+	chip->bar[1].remap_addr = pci_ioremap_bar(pci, 2);
+	if (!chip->bar[0].remap_addr || !chip->bar[1].remap_addr) {
+		snd_printk(KERN_ERR SFX "ioremap error\n");
+		err = -ENXIO;
+		goto errout;
+	}
+
+	pci_set_master(pci);
+
+	err = reset_controller(chip);
+	if (err < 0)
+		goto errout;
+
+	if (request_irq(pci->irq, lola_interrupt, IRQF_SHARED,
+			DRVNAME, chip)) {
+		printk(KERN_ERR SFX "unable to grab IRQ %d\n", pci->irq);
+		err = -EBUSY;
+		goto errout;
+	}
+	chip->irq = pci->irq;
+	synchronize_irq(chip->irq);
+
+	dever = lola_readl(chip, BAR1, DEVER);
+	chip->pcm[CAPT].num_streams = (dever >> 0) & 0x3ff;
+	chip->pcm[PLAY].num_streams = (dever >> 10) & 0x3ff;
+	chip->version = (dever >> 24) & 0xff;
+	snd_printd(SFX "streams in=%d, out=%d, version=0x%x\n",
+		    chip->pcm[CAPT].num_streams, chip->pcm[PLAY].num_streams,
+		    chip->version);
+
+	/* Test LOLA_BAR1_DEVER */
+	if (chip->pcm[CAPT].num_streams > MAX_STREAM_IN_COUNT ||
+	    chip->pcm[PLAY].num_streams > MAX_STREAM_OUT_COUNT ||
+	    (!chip->pcm[CAPT].num_streams &&
+	     !chip->pcm[PLAY].num_streams)) {
+		printk(KERN_ERR SFX "invalid DEVER = %x\n", dever);
+		err = -EINVAL;
+		goto errout;
+	}
+
+	err = setup_corb_rirb(chip);
+	if (err < 0)
+		goto errout;
+
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
+	if (err < 0) {
+		snd_printk(KERN_ERR SFX "Error creating device [card]!\n");
+		goto errout;
+	}
+
+	strcpy(card->driver, "Lola");
+	strlcpy(card->shortname, "Digigram Lola", sizeof(card->shortname));
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s at 0x%lx irq %i",
+		 card->shortname, chip->bar[0].addr, chip->irq);
+	strcpy(card->mixername, card->shortname);
+
+	lola_irq_enable(chip);
+
+	chip->initialized = 1;
+	*rchip = chip;
+	return 0;
+
+ errout:
+	lola_free(chip);
+	return err;
+}
+
+static int __devinit lola_probe(struct pci_dev *pci,
+				const struct pci_device_id *pci_id)
+{
+	static int dev;
+	struct snd_card *card;
+	struct lola *chip;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0) {
+		snd_printk(KERN_ERR SFX "Error creating card!\n");
+		return err;
+	}
+
+	snd_card_set_dev(card, &pci->dev);
+
+	err = lola_create(card, pci, &chip);
+	if (err < 0)
+		goto out_free;
+	card->private_data = chip;
+
+	err = lola_parse_tree(chip);
+	if (err < 0)
+		goto out_free;
+
+	err = lola_create_pcm(chip);
+	if (err < 0)
+		goto out_free;
+
+	err = lola_create_mixer(chip);
+	if (err < 0)
+		goto out_free;
+
+	lola_proc_debug_new(chip);
+
+	err = snd_card_register(card);
+	if (err < 0)
+		goto out_free;
+
+	pci_set_drvdata(pci, card);
+	dev++;
+	return err;
+out_free:
+	snd_card_free(card);
+	return err;
+}
+
+static void __devexit lola_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+/* PCI IDs */
+static DEFINE_PCI_DEVICE_TABLE(lola_ids) = {
+	{ PCI_VDEVICE(DIGIGRAM, 0x0001) },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, lola_ids);
+
+/* pci_driver definition */
+static struct pci_driver driver = {
+	.name = DRVNAME,
+	.id_table = lola_ids,
+	.probe = lola_probe,
+	.remove = __devexit_p(lola_remove),
+};
+
+static int __init alsa_card_lola_init(void)
+{
+	return pci_register_driver(&driver);
+}
+
+static void __exit alsa_card_lola_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_lola_init)
+module_exit(alsa_card_lola_exit)
