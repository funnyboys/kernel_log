commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/lola/lola_proc.c b/sound/pci/lola/lola_proc.c
index 1603f9c81897..a166672e22cb 100644
--- a/sound/pci/lola/lola_proc.c
+++ b/sound/pci/lola/lola_proc.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Support for Digigram Lola PCI-e boards
  *
  *  Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the Free
- *  Software Foundation; either version 2 of the License, or (at your option)
- *  any later version.
- *
- *  This program is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- *  more details.
- *
- *  You should have received a copy of the GNU General Public License along with
- *  this program; if not, write to the Free Software Foundation, Inc., 59
- *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 
 #include <linux/kernel.h>

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_proc.c b/sound/pci/lola/lola_proc.c
index 904e3c4f4dfe..1603f9c81897 100644
--- a/sound/pci/lola/lola_proc.c
+++ b/sound/pci/lola/lola_proc.c
@@ -208,15 +208,9 @@ static void lola_proc_regs_read(struct snd_info_entry *entry,
 
 void lola_proc_debug_new(struct lola *chip)
 {
-	struct snd_info_entry *entry;
-
-	if (!snd_card_proc_new(chip->card, "codec", &entry))
-		snd_info_set_text_ops(entry, chip, lola_proc_codec_read);
-	if (!snd_card_proc_new(chip->card, "codec_rw", &entry)) {
-		snd_info_set_text_ops(entry, chip, lola_proc_codec_rw_read);
-		entry->mode |= 0200;
-		entry->c.text.write = lola_proc_codec_rw_write;
-	}
-	if (!snd_card_proc_new(chip->card, "regs", &entry))
-		snd_info_set_text_ops(entry, chip, lola_proc_regs_read);
+	snd_card_ro_proc_new(chip->card, "codec", chip, lola_proc_codec_read);
+	snd_card_rw_proc_new(chip->card, "codec_rw", chip,
+			     lola_proc_codec_rw_read,
+			     lola_proc_codec_rw_write);
+	snd_card_ro_proc_new(chip->card, "regs", chip, lola_proc_regs_read);
 }

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_proc.c b/sound/pci/lola/lola_proc.c
index c241dc06dd92..904e3c4f4dfe 100644
--- a/sound/pci/lola/lola_proc.c
+++ b/sound/pci/lola/lola_proc.c
@@ -214,7 +214,7 @@ void lola_proc_debug_new(struct lola *chip)
 		snd_info_set_text_ops(entry, chip, lola_proc_codec_read);
 	if (!snd_card_proc_new(chip->card, "codec_rw", &entry)) {
 		snd_info_set_text_ops(entry, chip, lola_proc_codec_rw_read);
-		entry->mode |= S_IWUSR;
+		entry->mode |= 0200;
 		entry->c.text.write = lola_proc_codec_rw_write;
 	}
 	if (!snd_card_proc_new(chip->card, "regs", &entry))

commit 2d3a27782259de867fd2c0b7e3428acaf2b00123
Author: Toralf Förster <toralf.foerster@gmx.de>
Date:   Tue May 20 19:22:17 2014 +0200

    ALSA: lola: fix format type mismatch in sound/pci/lola/lola_proc.c
    
    Signed-off-by: Toralf Förster <toralf.foerster@gmx.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_proc.c b/sound/pci/lola/lola_proc.c
index 04df83defc09..c241dc06dd92 100644
--- a/sound/pci/lola/lola_proc.c
+++ b/sound/pci/lola/lola_proc.c
@@ -151,7 +151,7 @@ static void lola_proc_codec_rw_write(struct snd_info_entry *entry,
 	char line[64];
 	unsigned int id, verb, data, extdata;
 	while (!snd_info_get_line(buffer, line, sizeof(line))) {
-		if (sscanf(line, "%i %i %i %i", &id, &verb, &data, &extdata) != 4)
+		if (sscanf(line, "%u %u %u %u", &id, &verb, &data, &extdata) != 4)
 			continue;
 		lola_codec_read(chip, id, verb, data, extdata,
 				&chip->debug_res,

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_proc.c b/sound/pci/lola/lola_proc.c
index 9d7daf897c9d..04df83defc09 100644
--- a/sound/pci/lola/lola_proc.c
+++ b/sound/pci/lola/lola_proc.c
@@ -206,7 +206,7 @@ static void lola_proc_regs_read(struct snd_info_entry *entry,
 	}
 }
 
-void __devinit lola_proc_debug_new(struct lola *chip)
+void lola_proc_debug_new(struct lola *chip)
 {
 	struct snd_info_entry *entry;
 

commit c772bbe69a0171f12ad2adde5c150b4e211365ec
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:32:48 2011 +0200

    ALSA: lola - Changes in proc file
    
    The codec proc file becomes a read only that shows the codec widgets
    in a text form.  A new proc file, codec_rw, is introduced instead for
    accessing the Lola verb directly by reading and writing to it.
    
    Also, regs proc file shows the contents of DSD, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_proc.c b/sound/pci/lola/lola_proc.c
index 247fa2477171..9d7daf897c9d 100644
--- a/sound/pci/lola/lola_proc.c
+++ b/sound/pci/lola/lola_proc.c
@@ -26,9 +26,126 @@
 #include <sound/pcm.h>
 #include "lola.h"
 
+static void print_audio_widget(struct snd_info_buffer *buffer,
+			       struct lola *chip, int nid, const char *name)
+{
+	unsigned int val;
+
+	lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);
+	snd_iprintf(buffer, "Node 0x%02x %s wcaps 0x%x\n", nid, name, val);
+	lola_read_param(chip, nid, LOLA_PAR_STREAM_FORMATS, &val);
+	snd_iprintf(buffer, "  Formats: 0x%x\n", val);
+}
+
+static void print_pin_widget(struct snd_info_buffer *buffer,
+			     struct lola *chip, int nid, unsigned int ampcap,
+			     const char *name)
+{
+	unsigned int val;
+
+	lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);
+	snd_iprintf(buffer, "Node 0x%02x %s wcaps 0x%x\n", nid, name, val);
+	if (val == 0x00400200)
+		return;
+	lola_read_param(chip, nid, ampcap, &val);
+	snd_iprintf(buffer, "  Amp-Caps: 0x%x\n", val);
+	snd_iprintf(buffer, "    mute=%d, step-size=%d, steps=%d, ofs=%d\n",
+		    LOLA_AMP_MUTE_CAPABLE(val),
+		    LOLA_AMP_STEP_SIZE(val),
+		    LOLA_AMP_NUM_STEPS(val),
+		    LOLA_AMP_OFFSET(val));
+	lola_codec_read(chip, nid, LOLA_VERB_GET_MAX_LEVEL, 0, 0, &val, NULL);
+	snd_iprintf(buffer, "  Max-level: 0x%x\n", val);
+}
+
+static void print_clock_widget(struct snd_info_buffer *buffer,
+			       struct lola *chip, int nid)
+{
+	int i, j, num_clocks;
+	unsigned int val;
+
+	lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);
+	snd_iprintf(buffer, "Node 0x%02x [Clock] wcaps 0x%x\n", nid, val);
+	num_clocks = val & 0xff;
+	for (i = 0; i < num_clocks; i += 4) {
+		unsigned int res_ex;
+		unsigned short items[4];
+		const char *name;
+
+		lola_codec_read(chip, nid, LOLA_VERB_GET_CLOCK_LIST,
+				i, 0, &val, &res_ex);
+		items[0] = val & 0xfff;
+		items[1] = (val >> 16) & 0xfff;
+		items[2] = res_ex & 0xfff;
+		items[3] = (res_ex >> 16) & 0xfff;
+		for (j = 0; j < 4; j++) {
+			unsigned char type = items[j] >> 8;
+			unsigned int freq = items[j] & 0xff;
+			if (i + j >= num_clocks)
+				break;
+			if (type == LOLA_CLOCK_TYPE_INTERNAL) {
+				name = "Internal";
+				freq = lola_sample_rate_convert(freq);
+			} else if (type == LOLA_CLOCK_TYPE_VIDEO) {
+				name = "Video";
+				freq = lola_sample_rate_convert(freq);
+			} else {
+				name = "Other";
+			}
+			snd_iprintf(buffer, "  Clock %d: Type %d:%s, freq=%d\n",
+				    i + j, type, name, freq);
+		}
+	}
+}
+
+static void print_mixer_widget(struct snd_info_buffer *buffer,
+			       struct lola *chip, int nid)
+{
+	unsigned int val;
+
+	lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);
+	snd_iprintf(buffer, "Node 0x%02x [Mixer] wcaps 0x%x\n", nid, val);
+}
+
+static void lola_proc_codec_read(struct snd_info_entry *entry,
+				 struct snd_info_buffer *buffer)
+{
+	struct lola *chip = entry->private_data;
+	unsigned int val;
+	int i, nid;
+
+	lola_read_param(chip, 0, LOLA_PAR_VENDOR_ID, &val);
+	snd_iprintf(buffer, "Vendor: 0x%08x\n", val);
+	lola_read_param(chip, 1, LOLA_PAR_FUNCTION_TYPE, &val);
+	snd_iprintf(buffer, "Function Type: %d\n", val);
+	lola_read_param(chip, 1, LOLA_PAR_SPECIFIC_CAPS, &val);
+	snd_iprintf(buffer, "Specific-Caps: 0x%08x\n", val);
+	snd_iprintf(buffer, "  Pins-In %d, Pins-Out %d\n",
+		    chip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);
+	nid = 2;
+	for (i = 0; i < chip->pcm[CAPT].num_streams; i++, nid++)
+		print_audio_widget(buffer, chip, nid, "[Audio-In]");
+	for (i = 0; i < chip->pcm[PLAY].num_streams; i++, nid++)
+		print_audio_widget(buffer, chip, nid, "[Audio-Out]");
+	for (i = 0; i < chip->pin[CAPT].num_pins; i++, nid++)
+		print_pin_widget(buffer, chip, nid, LOLA_PAR_AMP_IN_CAP,
+				 "[Pin-In]");
+	for (i = 0; i < chip->pin[PLAY].num_pins; i++, nid++)
+		print_pin_widget(buffer, chip, nid, LOLA_PAR_AMP_OUT_CAP,
+				 "[Pin-Out]");
+	if (LOLA_AFG_CLOCK_WIDGET_PRESENT(chip->lola_caps)) {
+		print_clock_widget(buffer, chip, nid);
+		nid++;
+	}
+	if (LOLA_AFG_MIXER_WIDGET_PRESENT(chip->lola_caps)) {
+		print_mixer_widget(buffer, chip, nid);
+		nid++;
+	}
+}
+
 /* direct codec access for debugging */
-static void lola_proc_codec_write(struct snd_info_entry *entry,
-				  struct snd_info_buffer *buffer)
+static void lola_proc_codec_rw_write(struct snd_info_entry *entry,
+				     struct snd_info_buffer *buffer)
 {
 	struct lola *chip = entry->private_data;
 	char line[64];
@@ -42,8 +159,8 @@ static void lola_proc_codec_write(struct snd_info_entry *entry,
 	}
 }
 
-static void lola_proc_codec_read(struct snd_info_entry *entry,
-				 struct snd_info_buffer *buffer)
+static void lola_proc_codec_rw_read(struct snd_info_entry *entry,
+				    struct snd_info_buffer *buffer)
 {
 	struct lola *chip = entry->private_data;
 	snd_iprintf(buffer, "0x%x 0x%x\n", chip->debug_res, chip->debug_res_ex);
@@ -62,24 +179,43 @@ static void lola_proc_regs_read(struct snd_info_entry *entry,
 		snd_iprintf(buffer, "BAR0 %02x: %08x\n", i,
 			    readl(chip->bar[BAR0].remap_addr + i));
 	}
+	snd_iprintf(buffer, "\n");
 	for (i = 0; i < 0x30; i += 4) {
 		snd_iprintf(buffer, "BAR1 %02x: %08x\n", i,
 			    readl(chip->bar[BAR1].remap_addr + i));
 	}
+	snd_iprintf(buffer, "\n");
 	for (i = 0x80; i < 0xa0; i += 4) {
 		snd_iprintf(buffer, "BAR1 %02x: %08x\n", i,
 			    readl(chip->bar[BAR1].remap_addr + i));
 	}
+	snd_iprintf(buffer, "\n");
+	for (i = 0; i < 32; i++) {
+		snd_iprintf(buffer, "DSD %02x STS  %08x\n", i,
+			    lola_dsd_read(chip, i, STS));
+		snd_iprintf(buffer, "DSD %02x LPIB %08x\n", i,
+			    lola_dsd_read(chip, i, LPIB));
+		snd_iprintf(buffer, "DSD %02x CTL  %08x\n", i,
+			    lola_dsd_read(chip, i, CTL));
+		snd_iprintf(buffer, "DSD %02x LVIL %08x\n", i,
+			    lola_dsd_read(chip, i, LVI));
+		snd_iprintf(buffer, "DSD %02x BDPL %08x\n", i,
+			    lola_dsd_read(chip, i, BDPL));
+		snd_iprintf(buffer, "DSD %02x BDPU %08x\n", i,
+			    lola_dsd_read(chip, i, BDPU));
+	}
 }
 
 void __devinit lola_proc_debug_new(struct lola *chip)
 {
 	struct snd_info_entry *entry;
 
-	if (!snd_card_proc_new(chip->card, "codec", &entry)) {
+	if (!snd_card_proc_new(chip->card, "codec", &entry))
 		snd_info_set_text_ops(entry, chip, lola_proc_codec_read);
+	if (!snd_card_proc_new(chip->card, "codec_rw", &entry)) {
+		snd_info_set_text_ops(entry, chip, lola_proc_codec_rw_read);
 		entry->mode |= S_IWUSR;
-		entry->c.text.write = lola_proc_codec_write;
+		entry->c.text.write = lola_proc_codec_rw_write;
 	}
 	if (!snd_card_proc_new(chip->card, "regs", &entry))
 		snd_info_set_text_ops(entry, chip, lola_proc_regs_read);

commit d43f3010b8fa7530c3780c087fad9b0a8a437ba1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:14:46 2011 +0200

    ALSA: Add the driver for Digigram Lola PCI-e boards
    
    Added a new driver for supporting Digigram Lola PCI-e boards.
    
    Lola has a similar h/w design like HD-audio but with extended verbs.
    Thus the driver is written similarly like HD-audio driver in the bus
    part.  The codec part is rather written in a fixed way specific to the
    Lola board because of the verb incompatibility.
    
    The driver provides basic PCM, supporting multi-streams and mixing.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_proc.c b/sound/pci/lola/lola_proc.c
new file mode 100644
index 000000000000..247fa2477171
--- /dev/null
+++ b/sound/pci/lola/lola_proc.c
@@ -0,0 +1,86 @@
+/*
+ *  Support for Digigram Lola PCI-e boards
+ *
+ *  Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with
+ *  this program; if not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/pcm.h>
+#include "lola.h"
+
+/* direct codec access for debugging */
+static void lola_proc_codec_write(struct snd_info_entry *entry,
+				  struct snd_info_buffer *buffer)
+{
+	struct lola *chip = entry->private_data;
+	char line[64];
+	unsigned int id, verb, data, extdata;
+	while (!snd_info_get_line(buffer, line, sizeof(line))) {
+		if (sscanf(line, "%i %i %i %i", &id, &verb, &data, &extdata) != 4)
+			continue;
+		lola_codec_read(chip, id, verb, data, extdata,
+				&chip->debug_res,
+				&chip->debug_res_ex);
+	}
+}
+
+static void lola_proc_codec_read(struct snd_info_entry *entry,
+				 struct snd_info_buffer *buffer)
+{
+	struct lola *chip = entry->private_data;
+	snd_iprintf(buffer, "0x%x 0x%x\n", chip->debug_res, chip->debug_res_ex);
+}
+
+/*
+ * dump some registers
+ */
+static void lola_proc_regs_read(struct snd_info_entry *entry,
+				struct snd_info_buffer *buffer)
+{
+	struct lola *chip = entry->private_data;
+	int i;
+
+	for (i = 0; i < 0x40; i += 4) {
+		snd_iprintf(buffer, "BAR0 %02x: %08x\n", i,
+			    readl(chip->bar[BAR0].remap_addr + i));
+	}
+	for (i = 0; i < 0x30; i += 4) {
+		snd_iprintf(buffer, "BAR1 %02x: %08x\n", i,
+			    readl(chip->bar[BAR1].remap_addr + i));
+	}
+	for (i = 0x80; i < 0xa0; i += 4) {
+		snd_iprintf(buffer, "BAR1 %02x: %08x\n", i,
+			    readl(chip->bar[BAR1].remap_addr + i));
+	}
+}
+
+void __devinit lola_proc_debug_new(struct lola *chip)
+{
+	struct snd_info_entry *entry;
+
+	if (!snd_card_proc_new(chip->card, "codec", &entry)) {
+		snd_info_set_text_ops(entry, chip, lola_proc_codec_read);
+		entry->mode |= S_IWUSR;
+		entry->c.text.write = lola_proc_codec_write;
+	}
+	if (!snd_card_proc_new(chip->card, "regs", &entry))
+		snd_info_set_text_ops(entry, chip, lola_proc_regs_read);
+}
