commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index a01a06896084..f647c7ed00c4 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -575,7 +575,6 @@ void lola_pcm_update(struct lola *chip, struct lola_pcm *pcm, unsigned int bits)
 static const struct snd_pcm_ops lola_pcm_ops = {
 	.open = lola_pcm_open,
 	.close = lola_pcm_close,
-	.ioctl = snd_pcm_lib_ioctl,
 	.hw_params = lola_pcm_hw_params,
 	.hw_free = lola_pcm_hw_free,
 	.prepare = lola_pcm_prepare,

commit 224a40c7511f1095d2b6cfd261cd84510b7cbe43
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:16 2019 +0100

    ALSA: lola: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The superfluous snd_pcm_lib_malloc_pages() and
    snd_pcm_lib_free_pages() calls are dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-45-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index 856bcca60128..a01a06896084 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -282,8 +282,7 @@ static int lola_pcm_hw_params(struct snd_pcm_substream *substream,
 	str->bufsize = 0;
 	str->period_bytes = 0;
 	str->format_verb = 0;
-	return snd_pcm_lib_malloc_pages(substream,
-					params_buffer_bytes(hw_params));
+	return 0;
 }
 
 static int lola_pcm_hw_free(struct snd_pcm_substream *substream)
@@ -296,7 +295,7 @@ static int lola_pcm_hw_free(struct snd_pcm_substream *substream)
 	lola_stream_reset(chip, str);
 	lola_cleanup_slave_streams(pcm, str);
 	mutex_unlock(&chip->open_mutex);
-	return snd_pcm_lib_free_pages(substream);
+	return 0;
 }
 
 /*
@@ -610,9 +609,9 @@ int lola_create_pcm(struct lola *chip)
 			snd_pcm_set_ops(pcm, i, &lola_pcm_ops);
 	}
 	/* buffer pre-allocation */
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
-					      &chip->pci->dev,
-					      1024 * 64, 32 * 1024 * 1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
+				       &chip->pci->dev,
+				       1024 * 64, 32 * 1024 * 1024);
 	return 0;
 }
 

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index f032d7ceb6e5..856bcca60128 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -591,7 +591,7 @@ int lola_create_pcm(struct lola *chip)
 
 	for (i = 0; i < 2; i++) {
 		err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
-					  snd_dma_pci_data(chip->pci),
+					  &chip->pci->dev,
 					  PAGE_SIZE, &chip->pcm[i].bdl);
 		if (err < 0)
 			return err;
@@ -611,7 +611,7 @@ int lola_create_pcm(struct lola *chip)
 	}
 	/* buffer pre-allocation */
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
-					      snd_dma_pci_data(chip->pci),
+					      &chip->pci->dev,
 					      1024 * 64, 32 * 1024 * 1024);
 	return 0;
 }

commit 16ccca11088c1bdd9311a2c630b453541305c48a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:50 2019 +0100

    ALSA: pci: Drop superfluous snd_pcm_sgbuf_ops_page
    
    snd_pcm_sgbuf_ops_page is no longer needed to be set explicitly to PCM
    page ops since the recent change in the PCM core (*).  Leaving it NULL
    should work as long as the preallocation has been done properly.
    
    This patch drops the redundant lines.
    
    (*) 7e8edae39fd1: ALSA: pcm: Handle special page mapping in the
                      default mmap handler
    
    Link: https://lore.kernel.org/r/20191105151856.10785-19-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index 151f7cf5ce0e..f032d7ceb6e5 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -582,7 +582,6 @@ static const struct snd_pcm_ops lola_pcm_ops = {
 	.prepare = lola_pcm_prepare,
 	.trigger = lola_pcm_trigger,
 	.pointer = lola_pcm_pointer,
-	.page = snd_pcm_sgbuf_ops_page,
 };
 
 int lola_create_pcm(struct lola *chip)

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index e70276c3ea20..151f7cf5ce0e 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Support for Digigram Lola PCI-e boards
  *
  *  Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the Free
- *  Software Foundation; either version 2 of the License, or (at your option)
- *  any later version.
- *
- *  This program is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- *  more details.
- *
- *  You should have received a copy of the GNU General Public License along with
- *  this program; if not, write to the Free Software Foundation, Inc., 59
- *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 
 #include <linux/kernel.h>

commit 0d9a26fc74578289e0edeac36c6d562596f8a72e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:24:06 2018 +0200

    ALSA: lola: Proper endian notations
    
    The BDL entries in lola driver are little-endian while we code them as
    u32.  This leads to sparse warnings like:
      sound/pci/lola/lola.c:105:40: warning: incorrect type in assignment (different base types)
      sound/pci/lola/lola.c:105:40:    expected unsigned int [unsigned] [usertype] <noident>
      sound/pci/lola/lola.c:105:40:    got restricted __le32 [usertype] <noident>
    
    This patch fixes the declarations to the proper __le32 type.
    
    Also, there was a typo in the original code, where __user was used
    that was intended as __iomem.  This was caused also by sparse:
      sound/pci/lola/lola_mixer.c:132:27: warning: incorrect type in assignment (different address spaces)
    Fixed in this patch as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index 310b26a756c9..e70276c3ea20 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -316,10 +316,10 @@ static int lola_pcm_hw_free(struct snd_pcm_substream *substream)
  * set up a BDL entry
  */
 static int setup_bdle(struct snd_pcm_substream *substream,
-		      struct lola_stream *str, u32 **bdlp,
+		      struct lola_stream *str, __le32 **bdlp,
 		      int ofs, int size)
 {
-	u32 *bdl = *bdlp;
+	__le32 *bdl = *bdlp;
 
 	while (size > 0) {
 		dma_addr_t addr;
@@ -355,14 +355,14 @@ static int lola_setup_periods(struct lola *chip, struct lola_pcm *pcm,
 			      struct snd_pcm_substream *substream,
 			      struct lola_stream *str)
 {
-	u32 *bdl;
+	__le32 *bdl;
 	int i, ofs, periods, period_bytes;
 
 	period_bytes = str->period_bytes;
 	periods = str->bufsize / period_bytes;
 
 	/* program the initial BDL entries */
-	bdl = (u32 *)(pcm->bdl.area + LOLA_BDL_ENTRY_SIZE * str->index);
+	bdl = (__le32 *)(pcm->bdl.area + LOLA_BDL_ENTRY_SIZE * str->index);
 	ofs = 0;
 	str->frags = 0;
 	for (i = 0; i < periods; i++) {

commit 5cf84795d3e1b6795a717e7c858a12486ccf760f
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:19 2017 +0530

    ALSA: lola: make snd_pcm_hardware const
    
    Make this const as it is only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index 1268ba329016..310b26a756c9 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -197,7 +197,7 @@ static void lola_stream_reset(struct lola *chip, struct lola_stream *str)
 	}
 }
 
-static struct snd_pcm_hardware lola_pcm_hw = {
+static const struct snd_pcm_hardware lola_pcm_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index 3bd6985430e8..1268ba329016 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -586,7 +586,7 @@ void lola_pcm_update(struct lola *chip, struct lola_pcm *pcm, unsigned int bits)
 	}
 }
 
-static struct snd_pcm_ops lola_pcm_ops = {
+static const struct snd_pcm_ops lola_pcm_ops = {
 	.open = lola_pcm_open,
 	.close = lola_pcm_close,
 	.ioctl = snd_pcm_lib_ioctl,

commit f58e2fcedb44b917cdd4da94f85a81c0bc3d3ef2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 17:23:57 2014 +0100

    ALSA: lola: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index 5ea85e8b83ab..3bd6985430e8 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -103,7 +103,7 @@ static void wait_for_srst_clear(struct lola *chip, struct lola_stream *str)
 			return;
 		msleep(1);
 	}
-	printk(KERN_WARNING SFX "SRST not clear (stream %d)\n", str->dsd);
+	dev_warn(chip->card->dev, "SRST not clear (stream %d)\n", str->dsd);
 }
 
 static int lola_stream_wait_for_fifo(struct lola *chip,
@@ -118,7 +118,7 @@ static int lola_stream_wait_for_fifo(struct lola *chip,
 			return 0;
 		msleep(1);
 	}
-	printk(KERN_WARNING SFX "FIFO not ready (stream %d)\n", str->dsd);
+	dev_warn(chip->card->dev, "FIFO not ready (stream %d)\n", str->dsd);
 	return -EIO;
 }
 
@@ -156,7 +156,7 @@ static int lola_sync_wait_for_fifo(struct lola *chip,
 			return 0;
 		msleep(1);
 	}
-	printk(KERN_WARNING SFX "FIFO not ready (pending %d)\n", pending - 1);
+	dev_warn(chip->card->dev, "FIFO not ready (pending %d)\n", pending - 1);
 	return -EIO;
 }
 
@@ -373,7 +373,7 @@ static int lola_setup_periods(struct lola *chip, struct lola_pcm *pcm,
 	return 0;
 
  error:
-	snd_printk(KERN_ERR SFX "Too many BDL entries: buffer=%d, period=%d\n",
+	dev_err(chip->card->dev, "Too many BDL entries: buffer=%d, period=%d\n",
 		   str->bufsize, period_bytes);
 	return -EINVAL;
 }
@@ -415,7 +415,7 @@ static int lola_set_stream_config(struct lola *chip,
 	err = lola_codec_read(chip, str->nid, LOLA_VERB_SET_STREAM_FORMAT,
 			      str->format_verb, 0, &val, NULL);
 	if (err < 0) {
-		printk(KERN_ERR SFX "Cannot set stream format 0x%x\n",
+		dev_err(chip->card->dev, "Cannot set stream format 0x%x\n",
 		       str->format_verb);
 		return err;
 	}
@@ -427,7 +427,8 @@ static int lola_set_stream_config(struct lola *chip,
 				      LOLA_VERB_SET_CHANNEL_STREAMID, 0, verb,
 				      &val, NULL);
 		if (err < 0) {
-			printk(KERN_ERR SFX "Cannot set stream channel %d\n", i);
+			dev_err(chip->card->dev,
+				"Cannot set stream channel %d\n", i);
 			return err;
 		}
 	}
@@ -651,13 +652,14 @@ static int lola_init_stream(struct lola *chip, struct lola_stream *str,
 		str->dsd += MAX_STREAM_IN_COUNT;
 	err = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);
 	if (err < 0) {
-		printk(KERN_ERR SFX "Can't read wcaps for 0x%x\n", nid);
+		dev_err(chip->card->dev, "Can't read wcaps for 0x%x\n", nid);
 		return err;
 	}
 	if (dir == PLAY) {
 		/* test TYPE and bits 0..11 (no test bit9 : Digital = 0/1) */
 		if ((val & 0x00f00dff) != 0x00000010) {
-			printk(KERN_ERR SFX "Invalid wcaps 0x%x for 0x%x\n",
+			dev_err(chip->card->dev,
+				"Invalid wcaps 0x%x for 0x%x\n",
 			       val, nid);
 			return -EINVAL;
 		}
@@ -666,7 +668,8 @@ static int lola_init_stream(struct lola *chip, struct lola_stream *str,
 		 * (bug : ignore bit8: Conn list = 0/1)
 		 */
 		if ((val & 0x00f00cff) != 0x00100010) {
-			printk(KERN_ERR SFX "Invalid wcaps 0x%x for 0x%x\n",
+			dev_err(chip->card->dev,
+				"Invalid wcaps 0x%x for 0x%x\n",
 			       val, nid);
 			return -EINVAL;
 		}
@@ -677,14 +680,15 @@ static int lola_init_stream(struct lola *chip, struct lola_stream *str,
 
 	err = lola_read_param(chip, nid, LOLA_PAR_STREAM_FORMATS, &val);
 	if (err < 0) {
-		printk(KERN_ERR SFX "Can't read FORMATS 0x%x\n", nid);
+		dev_err(chip->card->dev, "Can't read FORMATS 0x%x\n", nid);
 		return err;
 	}
 	val &= 3;
 	if (val == 3)
 		str->can_float = true;
 	if (!(val & 1)) {
-		printk(KERN_ERR SFX "Invalid formats 0x%x for 0x%x", val, nid);
+		dev_err(chip->card->dev,
+			"Invalid formats 0x%x for 0x%x", val, nid);
 		return -EINVAL;
 	}
 	return 0;

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index c44db68eecb5..5ea85e8b83ab 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -597,7 +597,7 @@ static struct snd_pcm_ops lola_pcm_ops = {
 	.page = snd_pcm_sgbuf_ops_page,
 };
 
-int __devinit lola_create_pcm(struct lola *chip)
+int lola_create_pcm(struct lola *chip)
 {
 	struct snd_pcm *pcm;
 	int i, err;
@@ -690,7 +690,7 @@ static int lola_init_stream(struct lola *chip, struct lola_stream *str,
 	return 0;
 }
 
-int __devinit lola_init_pcm(struct lola *chip, int dir, int *nidp)
+int lola_init_pcm(struct lola *chip, int dir, int *nidp)
 {
 	struct lola_pcm *pcm = &chip->pcm[dir];
 	int i, nid, err;

commit f044785d0afc6c173ca7298c1a1cb4559423112f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 18:21:01 2011 +0200

    ALSA: lola - Add missing inclusion of linux/delay.h
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index aa21750202fc..c44db68eecb5 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
 #include <linux/pci.h>
+#include <linux/delay.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include "lola.h"

commit 2db3002029d6c8fbd8ad4ab21f501475cd8c96f9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 17:05:08 2011 +0200

    ALSA: lola - Rename to Digital SRC Capture Switch
    
    Renamed to Digial SRC Capture Switch for more correct representation.
    Also fixed analog volume control on Lola161611 and lola881.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index 5c0014cbff07..aa21750202fc 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -472,7 +472,7 @@ static int lola_pcm_prepare(struct snd_pcm_substream *substream)
 	mutex_lock(&chip->open_mutex);
 	lola_stream_reset(chip, str);
 	lola_cleanup_slave_streams(pcm, str);
-	if (str->index + runtime->channels >= pcm->num_streams) {
+	if (str->index + runtime->channels > pcm->num_streams) {
 		mutex_unlock(&chip->open_mutex);
 		return -EINVAL;
 	}
@@ -538,7 +538,7 @@ static int lola_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 
 	/*
 	 * sample correct synchronization is only needed starting several
-	 * streams on stop or if only one stream do as quick as possible
+	 * streams. On stop or if only one stream do as quick as possible
 	 */
 	sync_streams = (start && snd_pcm_stream_linked(substream));
 	tstamp = lola_get_tstamp(chip, !sync_streams);

commit c7aad3c317afc05418414c95e877173799145d0b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 17:02:35 2011 +0200

    ALSA: lola - Add sync in loop implementation
    
    For assuring the synchronized state with the pause operation,
    loop over the all linked streams and waits until all get ready
    in a loop.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index 6be6b7e8f567..5c0014cbff07 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -121,27 +121,69 @@ static int lola_stream_wait_for_fifo(struct lola *chip,
 	return -EIO;
 }
 
-static void lola_stream_reset(struct lola *chip, struct lola_stream *str)
+/* sync for FIFO ready/empty for all linked streams;
+ * clear paused flag when FIFO gets ready again
+ */
+static int lola_sync_wait_for_fifo(struct lola *chip,
+				   struct snd_pcm_substream *substream,
+				   bool ready)
 {
-	if (str->prepared) {
-		str->prepared = 0;
+	unsigned int val = ready ? LOLA_DSD_STS_FIFORDY : 0;
+	unsigned long end_time = jiffies + msecs_to_jiffies(200);
+	struct snd_pcm_substream *s;
+	int pending = 0;
+
+	while (time_before(jiffies, end_time)) {
+		pending = 0;
+		snd_pcm_group_for_each_entry(s, substream) {
+			struct lola_stream *str;
+			if (s->pcm->card != substream->pcm->card)
+				continue;
+			str = lola_get_stream(s);
+			if (str->prepared && str->paused) {
+				unsigned int reg;
+				reg = lola_dsd_read(chip, str->dsd, STS);
+				if ((reg & LOLA_DSD_STS_FIFORDY) != val) {
+					pending = str->dsd + 1;
+					break;
+				}
+				if (ready)
+					str->paused = 0;
+			}
+		}
+		if (!pending)
+			return 0;
+		msleep(1);
+	}
+	printk(KERN_WARNING SFX "FIFO not ready (pending %d)\n", pending - 1);
+	return -EIO;
+}
 
-		if (str->paused) {
-			/* finish pause - prepare for a new resume
-			 * move this code later to trigger function,
-			 * as this is also needed when resuming from pause
-			 */
-			str->paused = 0;
-			/* implement later loop for all streams */
-			lola_stream_wait_for_fifo(chip, str, false);
+/* finish pause - prepare for a new resume */
+static void lola_sync_pause(struct lola *chip,
+			    struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_substream *s;
+
+	lola_sync_wait_for_fifo(chip, substream, false);
+	snd_pcm_group_for_each_entry(s, substream) {
+		struct lola_stream *str;
+		if (s->pcm->card != substream->pcm->card)
+			continue;
+		str = lola_get_stream(s);
+		if (str->paused && str->prepared)
 			lola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRUN |
 				       LOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE);
-			/* end loop */
-			/* implement later once more loop for all streams */
-			lola_stream_wait_for_fifo(chip, str, true);
-			/* end loop */
-			/* end finish pause */
-		}
+	}
+	lola_sync_wait_for_fifo(chip, substream, true);
+}
+
+static void lola_stream_reset(struct lola *chip, struct lola_stream *str)
+{
+	if (str->prepared) {
+		if (str->paused)
+			lola_sync_pause(chip, str->substream);
+		str->prepared = 0;
 		lola_dsd_write(chip, str->dsd, CTL,
 			       LOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE);
 		lola_stream_wait_for_fifo(chip, str, false);

commit 7e79f2267605e59492fef92b966dddc3c6a68b41
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:59:27 2011 +0200

    ALSA: lola - Add SRC refcounting
    
    Added the refcounting for the exclusive SRC control.
    Also, fixed the possible stall after PCM pause operations.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index 4bb5b5bd6371..6be6b7e8f567 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -126,6 +126,22 @@ static void lola_stream_reset(struct lola *chip, struct lola_stream *str)
 	if (str->prepared) {
 		str->prepared = 0;
 
+		if (str->paused) {
+			/* finish pause - prepare for a new resume
+			 * move this code later to trigger function,
+			 * as this is also needed when resuming from pause
+			 */
+			str->paused = 0;
+			/* implement later loop for all streams */
+			lola_stream_wait_for_fifo(chip, str, false);
+			lola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRUN |
+				       LOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE);
+			/* end loop */
+			/* implement later once more loop for all streams */
+			lola_stream_wait_for_fifo(chip, str, true);
+			/* end loop */
+			/* end finish pause */
+		}
 		lola_dsd_write(chip, str->dsd, CTL,
 			       LOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE);
 		lola_stream_wait_for_fifo(chip, str, false);
@@ -178,12 +194,17 @@ static int lola_pcm_open(struct snd_pcm_substream *substream)
 	str->opened = 1;
 	runtime->hw = lola_pcm_hw;
 	runtime->hw.channels_max = pcm->num_streams - str->index;
-	runtime->hw.rate_min = chip->sample_rate_min;
-	runtime->hw.rate_max = chip->sample_rate_max;
+	if (chip->sample_rate) {
+		/* sample rate is locked */
+		runtime->hw.rate_min = chip->sample_rate;
+		runtime->hw.rate_max = chip->sample_rate;
+	} else {
+		runtime->hw.rate_min = chip->sample_rate_min;
+		runtime->hw.rate_max = chip->sample_rate_max;
+	}
+	chip->ref_count_rate++;
 	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
-	/* period size = multiple of chip->granularity (8, 16 or 32 frames)
-	 * use LOLA_GRANULARITY_MAX = 32 for instance
-	 */
+	/* period size = multiple of chip->granularity (8, 16 or 32 frames)*/
 	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
 				   chip->granularity);
 	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
@@ -215,6 +236,10 @@ static int lola_pcm_close(struct snd_pcm_substream *substream)
 		str->substream = NULL;
 		str->opened = 0;
 	}
+	if (--chip->ref_count_rate == 0) {
+		/* release sample rate */
+		chip->sample_rate = 0;
+	}
 	mutex_unlock(&chip->open_mutex);
 	return 0;
 }
@@ -427,6 +452,11 @@ static int lola_pcm_prepare(struct snd_pcm_substream *substream)
 	if (err < 0)
 		return err;
 
+	err = lola_set_sample_rate(chip, runtime->rate);
+	if (err < 0)
+		return err;
+	chip->sample_rate = runtime->rate;	/* sample rate gets locked */
+
 	err = lola_set_stream_config(chip, str, runtime->channels);
 	if (err < 0)
 		return err;
@@ -447,6 +477,7 @@ static int lola_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_pcm_substream *s;
 	unsigned int start;
 	unsigned int tstamp;
+	bool sync_streams;
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -463,7 +494,12 @@ static int lola_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		return -EINVAL;
 	}
 
-	tstamp = lola_get_tstamp(chip, false);
+	/*
+	 * sample correct synchronization is only needed starting several
+	 * streams on stop or if only one stream do as quick as possible
+	 */
+	sync_streams = (start && snd_pcm_stream_linked(substream));
+	tstamp = lola_get_tstamp(chip, !sync_streams);
 	spin_lock(&chip->reg_lock);
 	snd_pcm_group_for_each_entry(s, substream) {
 		if (s->pcm->card != substream->pcm->card)
@@ -474,6 +510,7 @@ static int lola_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		else
 			lola_stream_stop(chip, str, tstamp);
 		str->running = start;
+		str->paused = !start;
 		snd_pcm_trigger_done(s, substream);
 	}
 	spin_unlock(&chip->reg_lock);

commit 8bd172dc96fba8ba5a7560afdc1ff7461c278e86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:51:56 2011 +0200

    ALSA: lola - Allow granularity changes
    
    Add some sanity checks.
    Change PCM parameters appropriately per granularity.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index dc2e811dcb3c..4bb5b5bd6371 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -178,14 +178,16 @@ static int lola_pcm_open(struct snd_pcm_substream *substream)
 	str->opened = 1;
 	runtime->hw = lola_pcm_hw;
 	runtime->hw.channels_max = pcm->num_streams - str->index;
+	runtime->hw.rate_min = chip->sample_rate_min;
+	runtime->hw.rate_max = chip->sample_rate_max;
 	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
 	/* period size = multiple of chip->granularity (8, 16 or 32 frames)
 	 * use LOLA_GRANULARITY_MAX = 32 for instance
 	 */
 	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
-				   LOLA_GRANULARITY_MAX);
+				   chip->granularity);
 	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-				   LOLA_GRANULARITY_MAX);
+				   chip->granularity);
 	mutex_unlock(&chip->open_mutex);
 	return 0;
 }

commit 972505ccde9a3bdc8455f4cf3d3f37d17f8f10a3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:50:51 2011 +0200

    ALSA: lola - Use SG-buffer
    
    Completely switch to SG-buffer now, as it's working stably.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index ef738e6c9919..dc2e811dcb3c 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -26,28 +26,10 @@
 #include <sound/pcm.h>
 #include "lola.h"
 
-/* #define USE_SG_BUFFER */
-
 #define LOLA_MAX_BDL_ENTRIES	8
 #define LOLA_MAX_BUF_SIZE	(1024*1024*1024)
 #define LOLA_BDL_ENTRY_SIZE	(16 * 16)
 
-#ifdef USE_SG_BUFFER
-#define get_addr(substream, ofs) \
-	snd_pcm_sgbuf_get_addr(substream, ofs)
-#define get_size(substream, ofs, size) \
-	snd_pcm_sgbuf_get_chunk_size(substream, ofs, size)
-#define ops_page	snd_pcm_sgbuf_ops_page
-#define PREALLOC_TYPE	SNDRV_DMA_TYPE_DEV_SG
-#else
-#define get_addr(substream, ofs) \
-	((substream)->runtime->dma_addr + ofs)
-#define get_size(substream, ofs, size) \
-	(size)
-#define ops_page	NULL
-#define PREALLOC_TYPE	SNDRV_DMA_TYPE_DEV
-#endif
-
 static struct lola_pcm *lola_get_pcm(struct snd_pcm_substream *substream)
 {
 	struct lola *chip = snd_pcm_substream_chip(substream);
@@ -276,12 +258,12 @@ static int setup_bdle(struct snd_pcm_substream *substream,
 		if (str->frags >= LOLA_MAX_BDL_ENTRIES)
 			return -EINVAL;
 
-		addr = get_addr(substream, ofs);
+		addr = snd_pcm_sgbuf_get_addr(substream, ofs);
 		/* program the address field of the BDL entry */
 		bdl[0] = cpu_to_le32((u32)addr);
 		bdl[1] = cpu_to_le32(upper_32_bits(addr));
 		/* program the size field of the BDL entry */
-		chunk = get_size(substream, ofs, size);
+		chunk = snd_pcm_sgbuf_get_chunk_size(substream, ofs, size);
 		bdl[2] = cpu_to_le32(chunk);
 		/* program the IOC to enable interrupt
 		 * only when the whole fragment is processed
@@ -530,7 +512,7 @@ static struct snd_pcm_ops lola_pcm_ops = {
 	.prepare = lola_pcm_prepare,
 	.trigger = lola_pcm_trigger,
 	.pointer = lola_pcm_pointer,
-	.page = ops_page,
+	.page = snd_pcm_sgbuf_ops_page,
 };
 
 int __devinit lola_create_pcm(struct lola *chip)
@@ -559,7 +541,7 @@ int __devinit lola_create_pcm(struct lola *chip)
 			snd_pcm_set_ops(pcm, i, &lola_pcm_ops);
 	}
 	/* buffer pre-allocation */
-	snd_pcm_lib_preallocate_pages_for_all(pcm, PREALLOC_TYPE,
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
 					      snd_dma_pci_data(chip->pci),
 					      1024 * 64, 32 * 1024 * 1024);
 	return 0;

commit 0f8f56c959c9c4a65a5ad13f1b49d97db30b5c2f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:47:03 2011 +0200

    ALSA: lola - Fix PCM stalls
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index a656439915c8..ef738e6c9919 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -29,7 +29,6 @@
 /* #define USE_SG_BUFFER */
 
 #define LOLA_MAX_BDL_ENTRIES	8
-#define LOLA_MAX_FRAG		8
 #define LOLA_MAX_BUF_SIZE	(1024*1024*1024)
 #define LOLA_BDL_ENTRY_SIZE	(16 * 16)
 
@@ -111,12 +110,6 @@ static void lola_stream_stop(struct lola *chip, struct lola_stream *str,
 	lola_stream_clear_pending_irq(chip, str);
 }
 
-static void lola_stream_clear(struct lola *chip, struct lola_stream *str)
-{
-	lola_dsd_write(chip, str->dsd, CTL, 0);
-	lola_stream_clear_pending_irq(chip, str);
-}
-
 static void wait_for_srst_clear(struct lola *chip, struct lola_stream *str)
 {
 	unsigned long end_time = jiffies + msecs_to_jiffies(200);
@@ -130,22 +123,15 @@ static void wait_for_srst_clear(struct lola *chip, struct lola_stream *str)
 	printk(KERN_WARNING SFX "SRST not clear (stream %d)\n", str->dsd);
 }
 
-static void lola_stream_reset(struct lola *chip, struct lola_stream *str)
+static int lola_stream_wait_for_fifo(struct lola *chip,
+				     struct lola_stream *str,
+				     bool ready)
 {
-	lola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRST);
-	wait_for_srst_clear(chip, str);
-	lola_dsd_write(chip, str->dsd, LVI, 0);
-	lola_dsd_write(chip, str->dsd, BDPU, 0);
-	lola_dsd_write(chip, str->dsd, BDPL, 0);
-}
-
-static int lola_stream_wait_for_fifo_ready(struct lola *chip,
-					   struct lola_stream *str)
-{
-	unsigned long end_time = jiffies + msecs_to_jiffies(1000);
+	unsigned int val = ready ? LOLA_DSD_STS_FIFORDY : 0;
+	unsigned long end_time = jiffies + msecs_to_jiffies(200);
 	while (time_before(jiffies, end_time)) {
-		unsigned int val = lola_dsd_read(chip, str->dsd, STS);
-		if (val & LOLA_DSD_STS_FIFORDY)
+		unsigned int reg = lola_dsd_read(chip, str->dsd, STS);
+		if ((reg & LOLA_DSD_STS_FIFORDY) == val)
 			return 0;
 		msleep(1);
 	}
@@ -153,6 +139,23 @@ static int lola_stream_wait_for_fifo_ready(struct lola *chip,
 	return -EIO;
 }
 
+static void lola_stream_reset(struct lola *chip, struct lola_stream *str)
+{
+	if (str->prepared) {
+		str->prepared = 0;
+
+		lola_dsd_write(chip, str->dsd, CTL,
+			       LOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE);
+		lola_stream_wait_for_fifo(chip, str, false);
+		lola_stream_clear_pending_irq(chip, str);
+		lola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRST);
+		lola_dsd_write(chip, str->dsd, LVI, 0);
+		lola_dsd_write(chip, str->dsd, BDPU, 0);
+		lola_dsd_write(chip, str->dsd, BDPL, 0);
+		wait_for_srst_clear(chip, str);
+	}
+}
+
 static struct snd_pcm_hardware lola_pcm_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_INTERLEAVED |
@@ -163,16 +166,16 @@ static struct snd_pcm_hardware lola_pcm_hw = {
 				 SNDRV_PCM_FMTBIT_S24_LE |
 				 SNDRV_PCM_FMTBIT_S32_LE |
 				 SNDRV_PCM_FMTBIT_FLOAT_LE),
-	.rates =		SNDRV_PCM_RATE_48000,
-	.rate_min =		48000,
-	.rate_max =		48000,
+	.rates =		SNDRV_PCM_RATE_8000_192000,
+	.rate_min =		8000,
+	.rate_max =		192000,
 	.channels_min =		1,
 	.channels_max =		2,
 	.buffer_bytes_max =	LOLA_MAX_BUF_SIZE,
 	.period_bytes_min =	128,
 	.period_bytes_max =	LOLA_MAX_BUF_SIZE / 2,
 	.periods_min =		2,
-	.periods_max =		LOLA_MAX_FRAG,
+	.periods_max =		LOLA_MAX_BDL_ENTRIES,
 	.fifo_size =		0,
 };
 
@@ -194,10 +197,13 @@ static int lola_pcm_open(struct snd_pcm_substream *substream)
 	runtime->hw = lola_pcm_hw;
 	runtime->hw.channels_max = pcm->num_streams - str->index;
 	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
-	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
-				   128);
-	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
-				   128);
+	/* period size = multiple of chip->granularity (8, 16 or 32 frames)
+	 * use LOLA_GRANULARITY_MAX = 32 for instance
+	 */
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+				   LOLA_GRANULARITY_MAX);
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+				   LOLA_GRANULARITY_MAX);
 	mutex_unlock(&chip->open_mutex);
 	return 0;
 }
@@ -383,16 +389,24 @@ static int lola_setup_controller(struct lola *chip, struct lola_pcm *pcm,
 				 struct lola_stream *str)
 {
 	dma_addr_t bdl;
+
+	if (str->prepared)
+		return -EINVAL;
+
 	/* set up BDL */
 	bdl = pcm->bdl.addr + LOLA_BDL_ENTRY_SIZE * str->index;
 	lola_dsd_write(chip, str->dsd, BDPL, (u32)bdl);
 	lola_dsd_write(chip, str->dsd, BDPU, upper_32_bits(bdl));
 	/* program the stream LVI (last valid index) of the BDL */
 	lola_dsd_write(chip, str->dsd, LVI, str->frags - 1);
-	lola_stream_stop(chip, str, lola_get_tstamp(chip, false));
-	lola_stream_wait_for_fifo_ready(chip, str);
+	lola_stream_clear_pending_irq(chip, str);
 
-	return 0;
+ 	lola_dsd_write(chip, str->dsd, CTL,
+		       LOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE | LOLA_DSD_CTL_SRUN);
+
+	str->prepared = 1;
+
+	return lola_stream_wait_for_fifo(chip, str, true);
 }
 
 static int lola_pcm_prepare(struct snd_pcm_substream *substream)
@@ -421,22 +435,25 @@ static int lola_pcm_prepare(struct snd_pcm_substream *substream)
 	period_bytes = snd_pcm_lib_period_bytes(substream);
 	format_verb = lola_get_format_verb(substream);
 
-	if (bufsize != str->bufsize ||
-	    period_bytes != str->period_bytes ||
-	    format_verb != str->format_verb) {
-		str->bufsize = bufsize;
-		str->period_bytes = period_bytes;
-		str->format_verb = format_verb;
-		err = lola_setup_periods(chip, pcm, substream, str);
-		if (err < 0)
-			return err;
-	}
+	str->bufsize = bufsize;
+	str->period_bytes = period_bytes;
+	str->format_verb = format_verb;
+
+	err = lola_setup_periods(chip, pcm, substream, str);
+	if (err < 0)
+		return err;
 
 	err = lola_set_stream_config(chip, str, runtime->channels);
 	if (err < 0)
 		return err;
 
-	return lola_setup_controller(chip, pcm, str);
+	err = lola_setup_controller(chip, pcm, str);
+	if (err < 0) {
+		lola_stream_reset(chip, str);
+		return err;
+	}
+
+	return 0;
 }
 
 static int lola_pcm_trigger(struct snd_pcm_substream *substream, int cmd)

commit 333ff3971f374d9a057fd6d1492a2ef78989974d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:41:02 2011 +0200

    ALSA: lola - Use a single BDL
    
    Use a single BDL for both buffers instead of allocating for each.
    
    Also a few tune-up to avoid the stream stalls in the PCM code and
    the prelimianry work for SG-buffer support are added, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
index bf17f921d45f..a656439915c8 100644
--- a/sound/pci/lola/lola_pcm.c
+++ b/sound/pci/lola/lola_pcm.c
@@ -26,10 +26,28 @@
 #include <sound/pcm.h>
 #include "lola.h"
 
-#define BDL_SIZE		4096
-#define LOLA_MAX_BDL_ENTRIES	(BDL_SIZE / 16)
-#define LOLA_MAX_FRAG		32
+/* #define USE_SG_BUFFER */
+
+#define LOLA_MAX_BDL_ENTRIES	8
+#define LOLA_MAX_FRAG		8
 #define LOLA_MAX_BUF_SIZE	(1024*1024*1024)
+#define LOLA_BDL_ENTRY_SIZE	(16 * 16)
+
+#ifdef USE_SG_BUFFER
+#define get_addr(substream, ofs) \
+	snd_pcm_sgbuf_get_addr(substream, ofs)
+#define get_size(substream, ofs, size) \
+	snd_pcm_sgbuf_get_chunk_size(substream, ofs, size)
+#define ops_page	snd_pcm_sgbuf_ops_page
+#define PREALLOC_TYPE	SNDRV_DMA_TYPE_DEV_SG
+#else
+#define get_addr(substream, ofs) \
+	((substream)->runtime->dma_addr + ofs)
+#define get_size(substream, ofs, size) \
+	(size)
+#define ops_page	NULL
+#define PREALLOC_TYPE	SNDRV_DMA_TYPE_DEV
+#endif
 
 static struct lola_pcm *lola_get_pcm(struct snd_pcm_substream *substream)
 {
@@ -101,7 +119,7 @@ static void lola_stream_clear(struct lola *chip, struct lola_stream *str)
 
 static void wait_for_srst_clear(struct lola *chip, struct lola_stream *str)
 {
-	unsigned long end_time = jiffies + msecs_to_jiffies(50);
+	unsigned long end_time = jiffies + msecs_to_jiffies(200);
 	while (time_before(jiffies, end_time)) {
 		unsigned int val;
 		val = lola_dsd_read(chip, str->dsd, CTL);
@@ -115,16 +133,16 @@ static void wait_for_srst_clear(struct lola *chip, struct lola_stream *str)
 static void lola_stream_reset(struct lola *chip, struct lola_stream *str)
 {
 	lola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRST);
+	wait_for_srst_clear(chip, str);
 	lola_dsd_write(chip, str->dsd, LVI, 0);
 	lola_dsd_write(chip, str->dsd, BDPU, 0);
 	lola_dsd_write(chip, str->dsd, BDPL, 0);
-	wait_for_srst_clear(chip, str);
 }
 
 static int lola_stream_wait_for_fifo_ready(struct lola *chip,
 					   struct lola_stream *str)
 {
-	unsigned long end_time = jiffies + msecs_to_jiffies(50);
+	unsigned long end_time = jiffies + msecs_to_jiffies(1000);
 	while (time_before(jiffies, end_time)) {
 		unsigned int val = lola_dsd_read(chip, str->dsd, STS);
 		if (val & LOLA_DSD_STS_FIFORDY)
@@ -164,21 +182,12 @@ static int lola_pcm_open(struct snd_pcm_substream *substream)
 	struct lola_pcm *pcm = lola_get_pcm(substream);
 	struct lola_stream *str = lola_get_stream(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	int err;
 
 	mutex_lock(&chip->open_mutex);
 	if (str->opened) {
 		mutex_unlock(&chip->open_mutex);
 		return -EBUSY;
 	}
-	err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
-				  snd_dma_pci_data(chip->pci),
-				  PAGE_SIZE, &str->bdl);
-	if (err < 0) {
-		mutex_unlock(&chip->open_mutex);
-		printk(KERN_ERR SFX "Can't allocate BDL\n");
-		return err;
-	}
 	str->substream = substream;
 	str->master = NULL;
 	str->opened = 1;
@@ -216,7 +225,6 @@ static int lola_pcm_close(struct snd_pcm_substream *substream)
 		str->substream = NULL;
 		str->opened = 0;
 	}
-	snd_dma_free_pages(&str->bdl);
 	mutex_unlock(&chip->open_mutex);
 	return 0;
 }
@@ -262,12 +270,12 @@ static int setup_bdle(struct snd_pcm_substream *substream,
 		if (str->frags >= LOLA_MAX_BDL_ENTRIES)
 			return -EINVAL;
 
-		addr = snd_pcm_sgbuf_get_addr(substream, ofs);
+		addr = get_addr(substream, ofs);
 		/* program the address field of the BDL entry */
 		bdl[0] = cpu_to_le32((u32)addr);
 		bdl[1] = cpu_to_le32(upper_32_bits(addr));
 		/* program the size field of the BDL entry */
-		chunk = snd_pcm_sgbuf_get_chunk_size(substream, ofs, size);
+		chunk = get_size(substream, ofs, size);
 		bdl[2] = cpu_to_le32(chunk);
 		/* program the IOC to enable interrupt
 		 * only when the whole fragment is processed
@@ -285,7 +293,7 @@ static int setup_bdle(struct snd_pcm_substream *substream,
 /*
  * set up BDL entries
  */
-static int lola_setup_periods(struct lola *chip,
+static int lola_setup_periods(struct lola *chip, struct lola_pcm *pcm,
 			      struct snd_pcm_substream *substream,
 			      struct lola_stream *str)
 {
@@ -296,7 +304,7 @@ static int lola_setup_periods(struct lola *chip,
 	periods = str->bufsize / period_bytes;
 
 	/* program the initial BDL entries */
-	bdl = (u32 *)str->bdl.area;
+	bdl = (u32 *)(pcm->bdl.area + LOLA_BDL_ENTRY_SIZE * str->index);
 	ofs = 0;
 	str->frags = 0;
 	for (i = 0; i < periods; i++) {
@@ -371,13 +379,14 @@ static int lola_set_stream_config(struct lola *chip,
 /*
  * set up the SD for streaming
  */
-static int lola_setup_controller(struct lola *chip, struct lola_stream *str)
+static int lola_setup_controller(struct lola *chip, struct lola_pcm *pcm,
+				 struct lola_stream *str)
 {
-	/* make sure the run bit is zero for SD */
-	lola_stream_clear(chip, str);
+	dma_addr_t bdl;
 	/* set up BDL */
-	lola_dsd_write(chip, str->dsd, BDPL, (u32)str->bdl.addr);
-	lola_dsd_write(chip, str->dsd, BDPU, upper_32_bits(str->bdl.addr));
+	bdl = pcm->bdl.addr + LOLA_BDL_ENTRY_SIZE * str->index;
+	lola_dsd_write(chip, str->dsd, BDPL, (u32)bdl);
+	lola_dsd_write(chip, str->dsd, BDPU, upper_32_bits(bdl));
 	/* program the stream LVI (last valid index) of the BDL */
 	lola_dsd_write(chip, str->dsd, LVI, str->frags - 1);
 	lola_stream_stop(chip, str, lola_get_tstamp(chip, false));
@@ -418,7 +427,7 @@ static int lola_pcm_prepare(struct snd_pcm_substream *substream)
 		str->bufsize = bufsize;
 		str->period_bytes = period_bytes;
 		str->format_verb = format_verb;
-		err = lola_setup_periods(chip, substream, str);
+		err = lola_setup_periods(chip, pcm, substream, str);
 		if (err < 0)
 			return err;
 	}
@@ -427,7 +436,7 @@ static int lola_pcm_prepare(struct snd_pcm_substream *substream)
 	if (err < 0)
 		return err;
 
-	return lola_setup_controller(chip, str);
+	return lola_setup_controller(chip, pcm, str);
 }
 
 static int lola_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
@@ -504,7 +513,7 @@ static struct snd_pcm_ops lola_pcm_ops = {
 	.prepare = lola_pcm_prepare,
 	.trigger = lola_pcm_trigger,
 	.pointer = lola_pcm_pointer,
-	.page = snd_pcm_sgbuf_ops_page,
+	.page = ops_page,
 };
 
 int __devinit lola_create_pcm(struct lola *chip)
@@ -512,6 +521,14 @@ int __devinit lola_create_pcm(struct lola *chip)
 	struct snd_pcm *pcm;
 	int i, err;
 
+	for (i = 0; i < 2; i++) {
+		err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+					  snd_dma_pci_data(chip->pci),
+					  PAGE_SIZE, &chip->pcm[i].bdl);
+		if (err < 0)
+			return err;
+	}
+
 	err = snd_pcm_new(chip->card, "Digigram Lola", 0,
 			  chip->pcm[SNDRV_PCM_STREAM_PLAYBACK].num_streams,
 			  chip->pcm[SNDRV_PCM_STREAM_CAPTURE].num_streams,
@@ -525,7 +542,7 @@ int __devinit lola_create_pcm(struct lola *chip)
 			snd_pcm_set_ops(pcm, i, &lola_pcm_ops);
 	}
 	/* buffer pre-allocation */
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
+	snd_pcm_lib_preallocate_pages_for_all(pcm, PREALLOC_TYPE,
 					      snd_dma_pci_data(chip->pci),
 					      1024 * 64, 32 * 1024 * 1024);
 	return 0;
@@ -533,7 +550,8 @@ int __devinit lola_create_pcm(struct lola *chip)
 
 void lola_free_pcm(struct lola *chip)
 {
-	/* nothing to do */
+	snd_dma_free_pages(&chip->pcm[0].bdl);
+	snd_dma_free_pages(&chip->pcm[1].bdl);
 }
 
 /*

commit d43f3010b8fa7530c3780c087fad9b0a8a437ba1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 3 16:14:46 2011 +0200

    ALSA: Add the driver for Digigram Lola PCI-e boards
    
    Added a new driver for supporting Digigram Lola PCI-e boards.
    
    Lola has a similar h/w design like HD-audio but with extended verbs.
    Thus the driver is written similarly like HD-audio driver in the bus
    part.  The codec part is rather written in a fixed way specific to the
    Lola board because of the verb incompatibility.
    
    The driver provides basic PCM, supporting multi-streams and mixing.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/lola/lola_pcm.c b/sound/pci/lola/lola_pcm.c
new file mode 100644
index 000000000000..bf17f921d45f
--- /dev/null
+++ b/sound/pci/lola/lola_pcm.c
@@ -0,0 +1,607 @@
+/*
+ *  Support for Digigram Lola PCI-e boards
+ *
+ *  Copyright (c) 2011 Takashi Iwai <tiwai@suse.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with
+ *  this program; if not, write to the Free Software Foundation, Inc., 59
+ *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/pci.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include "lola.h"
+
+#define BDL_SIZE		4096
+#define LOLA_MAX_BDL_ENTRIES	(BDL_SIZE / 16)
+#define LOLA_MAX_FRAG		32
+#define LOLA_MAX_BUF_SIZE	(1024*1024*1024)
+
+static struct lola_pcm *lola_get_pcm(struct snd_pcm_substream *substream)
+{
+	struct lola *chip = snd_pcm_substream_chip(substream);
+	return &chip->pcm[substream->stream];
+}
+
+static struct lola_stream *lola_get_stream(struct snd_pcm_substream *substream)
+{
+	struct lola_pcm *pcm = lola_get_pcm(substream);
+	unsigned int idx = substream->number;
+	return &pcm->streams[idx];
+}
+
+static unsigned int lola_get_lrc(struct lola *chip)
+{
+	return lola_readl(chip, BAR1, LRC);
+}
+
+static unsigned int lola_get_tstamp(struct lola *chip, bool quick_no_sync)
+{
+	unsigned int tstamp = lola_get_lrc(chip) >> 8;
+	if (chip->granularity) {
+		unsigned int wait_banks = quick_no_sync ? 0 : 8;
+		tstamp += (wait_banks + 1) * chip->granularity - 1;
+		tstamp -= tstamp % chip->granularity;
+	}
+	return tstamp << 8;
+}
+
+/* clear any pending interrupt status */
+static void lola_stream_clear_pending_irq(struct lola *chip,
+					  struct lola_stream *str)
+{
+	unsigned int val = lola_dsd_read(chip, str->dsd, STS);
+	val &= LOLA_DSD_STS_DESE | LOLA_DSD_STS_BCIS;
+	if (val)
+		lola_dsd_write(chip, str->dsd, STS, val);
+}
+
+static void lola_stream_start(struct lola *chip, struct lola_stream *str,
+			      unsigned int tstamp)
+{
+	lola_stream_clear_pending_irq(chip, str);
+	lola_dsd_write(chip, str->dsd, CTL,
+		       LOLA_DSD_CTL_SRUN |
+		       LOLA_DSD_CTL_IOCE |
+		       LOLA_DSD_CTL_DEIE |
+		       LOLA_DSD_CTL_VLRCV |
+		       tstamp);
+}
+
+static void lola_stream_stop(struct lola *chip, struct lola_stream *str,
+			     unsigned int tstamp)
+{
+	lola_dsd_write(chip, str->dsd, CTL,
+		       LOLA_DSD_CTL_IOCE |
+		       LOLA_DSD_CTL_DEIE |
+		       LOLA_DSD_CTL_VLRCV |
+		       tstamp);
+	lola_stream_clear_pending_irq(chip, str);
+}
+
+static void lola_stream_clear(struct lola *chip, struct lola_stream *str)
+{
+	lola_dsd_write(chip, str->dsd, CTL, 0);
+	lola_stream_clear_pending_irq(chip, str);
+}
+
+static void wait_for_srst_clear(struct lola *chip, struct lola_stream *str)
+{
+	unsigned long end_time = jiffies + msecs_to_jiffies(50);
+	while (time_before(jiffies, end_time)) {
+		unsigned int val;
+		val = lola_dsd_read(chip, str->dsd, CTL);
+		if (!(val & LOLA_DSD_CTL_SRST))
+			return;
+		msleep(1);
+	}
+	printk(KERN_WARNING SFX "SRST not clear (stream %d)\n", str->dsd);
+}
+
+static void lola_stream_reset(struct lola *chip, struct lola_stream *str)
+{
+	lola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRST);
+	lola_dsd_write(chip, str->dsd, LVI, 0);
+	lola_dsd_write(chip, str->dsd, BDPU, 0);
+	lola_dsd_write(chip, str->dsd, BDPL, 0);
+	wait_for_srst_clear(chip, str);
+}
+
+static int lola_stream_wait_for_fifo_ready(struct lola *chip,
+					   struct lola_stream *str)
+{
+	unsigned long end_time = jiffies + msecs_to_jiffies(50);
+	while (time_before(jiffies, end_time)) {
+		unsigned int val = lola_dsd_read(chip, str->dsd, STS);
+		if (val & LOLA_DSD_STS_FIFORDY)
+			return 0;
+		msleep(1);
+	}
+	printk(KERN_WARNING SFX "FIFO not ready (stream %d)\n", str->dsd);
+	return -EIO;
+}
+
+static struct snd_pcm_hardware lola_pcm_hw = {
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_PAUSE),
+	.formats =		(SNDRV_PCM_FMTBIT_S16_LE |
+				 SNDRV_PCM_FMTBIT_S24_LE |
+				 SNDRV_PCM_FMTBIT_S32_LE |
+				 SNDRV_PCM_FMTBIT_FLOAT_LE),
+	.rates =		SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	LOLA_MAX_BUF_SIZE,
+	.period_bytes_min =	128,
+	.period_bytes_max =	LOLA_MAX_BUF_SIZE / 2,
+	.periods_min =		2,
+	.periods_max =		LOLA_MAX_FRAG,
+	.fifo_size =		0,
+};
+
+static int lola_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct lola *chip = snd_pcm_substream_chip(substream);
+	struct lola_pcm *pcm = lola_get_pcm(substream);
+	struct lola_stream *str = lola_get_stream(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+
+	mutex_lock(&chip->open_mutex);
+	if (str->opened) {
+		mutex_unlock(&chip->open_mutex);
+		return -EBUSY;
+	}
+	err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+				  snd_dma_pci_data(chip->pci),
+				  PAGE_SIZE, &str->bdl);
+	if (err < 0) {
+		mutex_unlock(&chip->open_mutex);
+		printk(KERN_ERR SFX "Can't allocate BDL\n");
+		return err;
+	}
+	str->substream = substream;
+	str->master = NULL;
+	str->opened = 1;
+	runtime->hw = lola_pcm_hw;
+	runtime->hw.channels_max = pcm->num_streams - str->index;
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				   128);
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+				   128);
+	mutex_unlock(&chip->open_mutex);
+	return 0;
+}
+
+static void lola_cleanup_slave_streams(struct lola_pcm *pcm,
+				       struct lola_stream *str)
+{
+	int i;
+	for (i = str->index + 1; i < pcm->num_streams; i++) {
+		struct lola_stream *s = &pcm->streams[i];
+		if (s->master != str)
+			break;
+		s->master = NULL;
+		s->opened = 0;
+	}
+}
+
+static int lola_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct lola *chip = snd_pcm_substream_chip(substream);
+	struct lola_stream *str = lola_get_stream(substream);
+
+	mutex_lock(&chip->open_mutex);
+	if (str->substream == substream) {
+		str->substream = NULL;
+		str->opened = 0;
+	}
+	snd_dma_free_pages(&str->bdl);
+	mutex_unlock(&chip->open_mutex);
+	return 0;
+}
+
+static int lola_pcm_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *hw_params)
+{
+	struct lola_stream *str = lola_get_stream(substream);
+
+	str->bufsize = 0;
+	str->period_bytes = 0;
+	str->format_verb = 0;
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+static int lola_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct lola *chip = snd_pcm_substream_chip(substream);
+	struct lola_pcm *pcm = lola_get_pcm(substream);
+	struct lola_stream *str = lola_get_stream(substream);
+
+	mutex_lock(&chip->open_mutex);
+	lola_stream_reset(chip, str);
+	lola_cleanup_slave_streams(pcm, str);
+	mutex_unlock(&chip->open_mutex);
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/*
+ * set up a BDL entry
+ */
+static int setup_bdle(struct snd_pcm_substream *substream,
+		      struct lola_stream *str, u32 **bdlp,
+		      int ofs, int size)
+{
+	u32 *bdl = *bdlp;
+
+	while (size > 0) {
+		dma_addr_t addr;
+		int chunk;
+
+		if (str->frags >= LOLA_MAX_BDL_ENTRIES)
+			return -EINVAL;
+
+		addr = snd_pcm_sgbuf_get_addr(substream, ofs);
+		/* program the address field of the BDL entry */
+		bdl[0] = cpu_to_le32((u32)addr);
+		bdl[1] = cpu_to_le32(upper_32_bits(addr));
+		/* program the size field of the BDL entry */
+		chunk = snd_pcm_sgbuf_get_chunk_size(substream, ofs, size);
+		bdl[2] = cpu_to_le32(chunk);
+		/* program the IOC to enable interrupt
+		 * only when the whole fragment is processed
+		 */
+		size -= chunk;
+		bdl[3] = size ? 0 : cpu_to_le32(0x01);
+		bdl += 4;
+		str->frags++;
+		ofs += chunk;
+	}
+	*bdlp = bdl;
+	return ofs;
+}
+
+/*
+ * set up BDL entries
+ */
+static int lola_setup_periods(struct lola *chip,
+			      struct snd_pcm_substream *substream,
+			      struct lola_stream *str)
+{
+	u32 *bdl;
+	int i, ofs, periods, period_bytes;
+
+	period_bytes = str->period_bytes;
+	periods = str->bufsize / period_bytes;
+
+	/* program the initial BDL entries */
+	bdl = (u32 *)str->bdl.area;
+	ofs = 0;
+	str->frags = 0;
+	for (i = 0; i < periods; i++) {
+		ofs = setup_bdle(substream, str, &bdl, ofs, period_bytes);
+		if (ofs < 0)
+			goto error;
+	}
+	return 0;
+
+ error:
+	snd_printk(KERN_ERR SFX "Too many BDL entries: buffer=%d, period=%d\n",
+		   str->bufsize, period_bytes);
+	return -EINVAL;
+}
+
+static unsigned int lola_get_format_verb(struct snd_pcm_substream *substream)
+{
+	unsigned int verb;
+
+	switch (substream->runtime->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		verb = 0x00000000;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		verb = 0x00000200;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		verb = 0x00000300;
+		break;
+	case SNDRV_PCM_FORMAT_FLOAT_LE:
+		verb = 0x00001300;
+		break;
+	default:
+		return 0;
+	}
+	verb |= substream->runtime->channels;
+	return verb;
+}
+
+static int lola_set_stream_config(struct lola *chip,
+				  struct lola_stream *str,
+				  int channels)
+{
+	int i, err;
+	unsigned int verb, val;
+
+	/* set format info for all channels
+	 * (with only one command for the first channel)
+	 */
+	err = lola_codec_read(chip, str->nid, LOLA_VERB_SET_STREAM_FORMAT,
+			      str->format_verb, 0, &val, NULL);
+	if (err < 0) {
+		printk(KERN_ERR SFX "Cannot set stream format 0x%x\n",
+		       str->format_verb);
+		return err;
+	}
+
+	/* update stream - channel config */
+	for (i = 0; i < channels; i++) {
+		verb = (str->index << 6) | i;
+		err = lola_codec_read(chip, str[i].nid,
+				      LOLA_VERB_SET_CHANNEL_STREAMID, 0, verb,
+				      &val, NULL);
+		if (err < 0) {
+			printk(KERN_ERR SFX "Cannot set stream channel %d\n", i);
+			return err;
+		}
+	}
+	return 0;
+}
+
+/*
+ * set up the SD for streaming
+ */
+static int lola_setup_controller(struct lola *chip, struct lola_stream *str)
+{
+	/* make sure the run bit is zero for SD */
+	lola_stream_clear(chip, str);
+	/* set up BDL */
+	lola_dsd_write(chip, str->dsd, BDPL, (u32)str->bdl.addr);
+	lola_dsd_write(chip, str->dsd, BDPU, upper_32_bits(str->bdl.addr));
+	/* program the stream LVI (last valid index) of the BDL */
+	lola_dsd_write(chip, str->dsd, LVI, str->frags - 1);
+	lola_stream_stop(chip, str, lola_get_tstamp(chip, false));
+	lola_stream_wait_for_fifo_ready(chip, str);
+
+	return 0;
+}
+
+static int lola_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct lola *chip = snd_pcm_substream_chip(substream);
+	struct lola_pcm *pcm = lola_get_pcm(substream);
+	struct lola_stream *str = lola_get_stream(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int bufsize, period_bytes, format_verb;
+	int i, err;
+
+	mutex_lock(&chip->open_mutex);
+	lola_stream_reset(chip, str);
+	lola_cleanup_slave_streams(pcm, str);
+	if (str->index + runtime->channels >= pcm->num_streams) {
+		mutex_unlock(&chip->open_mutex);
+		return -EINVAL;
+	}
+	for (i = 1; i < runtime->channels; i++) {
+		str[i].master = str;
+		str[i].opened = 1;
+	}
+	mutex_unlock(&chip->open_mutex);
+
+	bufsize = snd_pcm_lib_buffer_bytes(substream);
+	period_bytes = snd_pcm_lib_period_bytes(substream);
+	format_verb = lola_get_format_verb(substream);
+
+	if (bufsize != str->bufsize ||
+	    period_bytes != str->period_bytes ||
+	    format_verb != str->format_verb) {
+		str->bufsize = bufsize;
+		str->period_bytes = period_bytes;
+		str->format_verb = format_verb;
+		err = lola_setup_periods(chip, substream, str);
+		if (err < 0)
+			return err;
+	}
+
+	err = lola_set_stream_config(chip, str, runtime->channels);
+	if (err < 0)
+		return err;
+
+	return lola_setup_controller(chip, str);
+}
+
+static int lola_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct lola *chip = snd_pcm_substream_chip(substream);
+	struct lola_stream *str;
+	struct snd_pcm_substream *s;
+	unsigned int start;
+	unsigned int tstamp;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		start = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+		start = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tstamp = lola_get_tstamp(chip, false);
+	spin_lock(&chip->reg_lock);
+	snd_pcm_group_for_each_entry(s, substream) {
+		if (s->pcm->card != substream->pcm->card)
+			continue;
+		str = lola_get_stream(s);
+		if (start)
+			lola_stream_start(chip, str, tstamp);
+		else
+			lola_stream_stop(chip, str, tstamp);
+		str->running = start;
+		snd_pcm_trigger_done(s, substream);
+	}
+	spin_unlock(&chip->reg_lock);
+	return 0;
+}
+
+static snd_pcm_uframes_t lola_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct lola *chip = snd_pcm_substream_chip(substream);
+	struct lola_stream *str = lola_get_stream(substream);
+	unsigned int pos = lola_dsd_read(chip, str->dsd, LPIB);
+
+	if (pos >= str->bufsize)
+		pos = 0;
+	return bytes_to_frames(substream->runtime, pos);
+}
+
+void lola_pcm_update(struct lola *chip, struct lola_pcm *pcm, unsigned int bits)
+{
+	int i;
+
+	for (i = 0; bits && i < pcm->num_streams; i++) {
+		if (bits & (1 << i)) {
+			struct lola_stream *str = &pcm->streams[i];
+			if (str->substream && str->running)
+				snd_pcm_period_elapsed(str->substream);
+			bits &= ~(1 << i);
+		}
+	}
+}
+
+static struct snd_pcm_ops lola_pcm_ops = {
+	.open = lola_pcm_open,
+	.close = lola_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = lola_pcm_hw_params,
+	.hw_free = lola_pcm_hw_free,
+	.prepare = lola_pcm_prepare,
+	.trigger = lola_pcm_trigger,
+	.pointer = lola_pcm_pointer,
+	.page = snd_pcm_sgbuf_ops_page,
+};
+
+int __devinit lola_create_pcm(struct lola *chip)
+{
+	struct snd_pcm *pcm;
+	int i, err;
+
+	err = snd_pcm_new(chip->card, "Digigram Lola", 0,
+			  chip->pcm[SNDRV_PCM_STREAM_PLAYBACK].num_streams,
+			  chip->pcm[SNDRV_PCM_STREAM_CAPTURE].num_streams,
+			  &pcm);
+	if (err < 0)
+		return err;
+	strlcpy(pcm->name, "Digigram Lola", sizeof(pcm->name));
+	pcm->private_data = chip;
+	for (i = 0; i < 2; i++) {
+		if (chip->pcm[i].num_streams)
+			snd_pcm_set_ops(pcm, i, &lola_pcm_ops);
+	}
+	/* buffer pre-allocation */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
+					      snd_dma_pci_data(chip->pci),
+					      1024 * 64, 32 * 1024 * 1024);
+	return 0;
+}
+
+void lola_free_pcm(struct lola *chip)
+{
+	/* nothing to do */
+}
+
+/*
+ */
+
+static int lola_init_stream(struct lola *chip, struct lola_stream *str,
+			    int idx, int nid, int dir)
+{
+	unsigned int val;
+	int err;
+
+	str->nid = nid;
+	str->index = idx;
+	str->dsd = idx;
+	if (dir == PLAY)
+		str->dsd += MAX_STREAM_IN_COUNT;
+	err = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);
+	if (err < 0) {
+		printk(KERN_ERR SFX "Can't read wcaps for 0x%x\n", nid);
+		return err;
+	}
+	if (dir == PLAY) {
+		/* test TYPE and bits 0..11 (no test bit9 : Digital = 0/1) */
+		if ((val & 0x00f00dff) != 0x00000010) {
+			printk(KERN_ERR SFX "Invalid wcaps 0x%x for 0x%x\n",
+			       val, nid);
+			return -EINVAL;
+		}
+	} else {
+		/* test TYPE and bits 0..11 (no test bit9 : Digital = 0/1)
+		 * (bug : ignore bit8: Conn list = 0/1)
+		 */
+		if ((val & 0x00f00cff) != 0x00100010) {
+			printk(KERN_ERR SFX "Invalid wcaps 0x%x for 0x%x\n",
+			       val, nid);
+			return -EINVAL;
+		}
+		/* test bit9:DIGITAL and bit12:SRC_PRESENT*/
+		if ((val & 0x00001200) == 0x00001200)
+			chip->input_src_caps_mask |= (1 << idx);
+	}
+
+	err = lola_read_param(chip, nid, LOLA_PAR_STREAM_FORMATS, &val);
+	if (err < 0) {
+		printk(KERN_ERR SFX "Can't read FORMATS 0x%x\n", nid);
+		return err;
+	}
+	val &= 3;
+	if (val == 3)
+		str->can_float = true;
+	if (!(val & 1)) {
+		printk(KERN_ERR SFX "Invalid formats 0x%x for 0x%x", val, nid);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int __devinit lola_init_pcm(struct lola *chip, int dir, int *nidp)
+{
+	struct lola_pcm *pcm = &chip->pcm[dir];
+	int i, nid, err;
+
+	nid = *nidp;
+	for (i = 0; i < pcm->num_streams; i++, nid++) {
+		err = lola_init_stream(chip, &pcm->streams[i], i, nid, dir);
+		if (err < 0)
+			return err;
+	}
+	*nidp = nid;
+	return 0;
+}
