commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index ea51913ea134..ba6390e9a694 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -647,7 +647,6 @@ static int snd_als4000_capture_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_als4000_playback_ops = {
 	.open =		snd_als4000_playback_open,
 	.close =	snd_als4000_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_als4000_playback_prepare,
 	.trigger =	snd_als4000_playback_trigger,
 	.pointer =	snd_als4000_playback_pointer
@@ -656,7 +655,6 @@ static const struct snd_pcm_ops snd_als4000_playback_ops = {
 static const struct snd_pcm_ops snd_als4000_capture_ops = {
 	.open =		snd_als4000_capture_open,
 	.close =	snd_als4000_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_als4000_capture_prepare,
 	.trigger =	snd_als4000_capture_trigger,
 	.pointer =	snd_als4000_capture_pointer

commit 96bcfde13a1cb8979c0e4fb35f99be2d072c21bd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:48:54 2019 +0100

    ALSA: als4000: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-23-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index d6f5487afe52..ea51913ea134 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -354,18 +354,6 @@ CMD_SIGNED|CMD_STEREO,			/* ALS4000_FORMAT_S16L_STEREO */
 };	
 #define capture_cmd(chip) (capture_cmd_vals[(chip)->capture_format])
 
-static int snd_als4000_hw_params(struct snd_pcm_substream *substream,
-				 struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-}
-
-static int snd_als4000_hw_free(struct snd_pcm_substream *substream)
-{
-	snd_pcm_lib_free_pages(substream);
-	return 0;
-}
-
 static int snd_als4000_capture_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_sb *chip = snd_pcm_substream_chip(substream);
@@ -633,7 +621,6 @@ static int snd_als4000_playback_close(struct snd_pcm_substream *substream)
 	struct snd_sb *chip = snd_pcm_substream_chip(substream);
 
 	chip->playback_substream = NULL;
-	snd_pcm_lib_free_pages(substream);
 	return 0;
 }
 
@@ -652,7 +639,6 @@ static int snd_als4000_capture_close(struct snd_pcm_substream *substream)
 	struct snd_sb *chip = snd_pcm_substream_chip(substream);
 
 	chip->capture_substream = NULL;
-	snd_pcm_lib_free_pages(substream);
 	return 0;
 }
 
@@ -662,8 +648,6 @@ static const struct snd_pcm_ops snd_als4000_playback_ops = {
 	.open =		snd_als4000_playback_open,
 	.close =	snd_als4000_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_als4000_hw_params,
-	.hw_free =	snd_als4000_hw_free,
 	.prepare =	snd_als4000_playback_prepare,
 	.trigger =	snd_als4000_playback_trigger,
 	.pointer =	snd_als4000_playback_pointer
@@ -673,8 +657,6 @@ static const struct snd_pcm_ops snd_als4000_capture_ops = {
 	.open =		snd_als4000_capture_open,
 	.close =	snd_als4000_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_als4000_hw_params,
-	.hw_free =	snd_als4000_hw_free,
 	.prepare =	snd_als4000_capture_prepare,
 	.trigger =	snd_als4000_capture_trigger,
 	.pointer =	snd_als4000_capture_pointer
@@ -693,9 +675,8 @@ static int snd_als4000_pcm(struct snd_sb *chip, int device)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_als4000_playback_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_als4000_capture_ops);
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &chip->pci->dev,
-					      64*1024, 64*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &chip->pci->dev, 64*1024, 64*1024);
 
 	chip->pcm = pcm;
 

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index b06c3dbb525d..d6f5487afe52 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -693,7 +693,8 @@ static int snd_als4000_pcm(struct snd_sb *chip, int device)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_als4000_playback_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_als4000_capture_ops);
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      &chip->pci->dev,
 					      64*1024, 64*1024);
 
 	chip->pcm = pcm;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 45fa38382e79..b06c3dbb525d 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  card-als4000.c - driver for Avance Logic ALS4000 based soundcards.
  *  Copyright (C) 2000 by Bart Hartgers <bart@etpmod.phys.tue.nl>,
@@ -6,21 +7,6 @@
  *
  *  Framework borrowed from Massimo Piccioni's card-als100.c.
  *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
-
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  * NOTES
  *
  *  Since Avance does not provide any meaningful documentation, and I

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 26b097edec8c..45fa38382e79 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -994,7 +994,6 @@ static int snd_als4000_suspend(struct device *dev)
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	
-	snd_pcm_suspend_all(chip->pcm);
 	snd_sbmixer_suspend(chip);
 	return 0;
 }

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 7844a75d8ed9..26b097edec8c 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -592,7 +592,7 @@ static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id)
 
 /*****************************************************************/
 
-static struct snd_pcm_hardware snd_als4000_playback =
+static const struct snd_pcm_hardware snd_als4000_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP_VALID),
@@ -611,7 +611,7 @@ static struct snd_pcm_hardware snd_als4000_playback =
 	.fifo_size =		0
 };
 
-static struct snd_pcm_hardware snd_als4000_capture =
+static const struct snd_pcm_hardware snd_als4000_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP_VALID),

commit 6192c41fc608b0a58d5540b015aa1672c266f3c5
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/pci/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/pci/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 92bc06d01288..7844a75d8ed9 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -102,7 +102,7 @@ MODULE_PARM_DESC(id, "ID string for ALS4000 soundcard.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable ALS4000 soundcard.");
 #ifdef SUPPORT_JOYSTICK
-module_param_array(joystick_port, int, NULL, 0444);
+module_param_hw_array(joystick_port, int, ioport, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address for ALS4000 soundcard. (0 = disabled)");
 #endif
 

commit b2fac0730347d591b528d8f0e4a9438c1bb6f558
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Nov 12 23:26:41 2016 +0100

    ALSA: pci: don't opencode IS_REACHABLE()
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index edabe1371660..92bc06d01288 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -84,7 +84,7 @@ MODULE_DESCRIPTION("Avance Logic ALS4000");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Avance Logic,ALS4000}}");
 
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#if IS_REACHABLE(CONFIG_GAMEPORT)
 #define SUPPORT_JOYSTICK 1
 #endif
 

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index ff39a0c7277b..edabe1371660 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -672,7 +672,7 @@ static int snd_als4000_capture_close(struct snd_pcm_substream *substream)
 
 /******************************************************************/
 
-static struct snd_pcm_ops snd_als4000_playback_ops = {
+static const struct snd_pcm_ops snd_als4000_playback_ops = {
 	.open =		snd_als4000_playback_open,
 	.close =	snd_als4000_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -683,7 +683,7 @@ static struct snd_pcm_ops snd_als4000_playback_ops = {
 	.pointer =	snd_als4000_playback_pointer
 };
 
-static struct snd_pcm_ops snd_als4000_capture_ops = {
+static const struct snd_pcm_ops snd_als4000_capture_ops = {
 	.open =		snd_als4000_capture_open,
 	.close =	snd_als4000_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 412b979ccceff448dccea54bdb616c85781bc0ba
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Wed Apr 15 16:10:17 2015 +0200

    ALSA: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index a3dea464134d..ff39a0c7277b 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -871,8 +871,8 @@ static int snd_card_als4000_probe(struct pci_dev *pci,
 		return err;
 	}
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
-	if (pci_set_dma_mask(pci, DMA_BIT_MASK(24)) < 0 ||
-	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(24)) < 0) {
+	if (dma_set_mask(&pci->dev, DMA_BIT_MASK(24)) < 0 ||
+	    dma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(24)) < 0) {
 		dev_err(&pci->dev, "architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 94608524f3cc..a3dea464134d 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -65,7 +65,7 @@
  * - power management? (card can do voice wakeup according to datasheet!!)
  */
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/gameport.h>

commit dc3b10eb64edd977fb5173f72fc66cc8687e61be
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:44:01 2015 +0100

    ALSA: als4000: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index d3e6424ee656..94608524f3cc 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -988,7 +988,6 @@ static void snd_card_als4000_remove(struct pci_dev *pci)
 #ifdef CONFIG_PM_SLEEP
 static int snd_als4000_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_card_als4000 *acard = card->private_data;
 	struct snd_sb *chip = acard->chip;
@@ -997,29 +996,15 @@ static int snd_als4000_suspend(struct device *dev)
 	
 	snd_pcm_suspend_all(chip->pcm);
 	snd_sbmixer_suspend(chip);
-
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int snd_als4000_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_card_als4000 *acard = card->private_data;
 	struct snd_sb *chip = acard->chip;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
-
 	snd_als4000_configure(chip);
 	snd_sbdsp_reset(chip);
 	snd_sbmixer_resume(chip);

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index b751c381d25e..d3e6424ee656 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -116,7 +116,7 @@ struct snd_card_als4000 {
 #endif
 };
 
-static DEFINE_PCI_DEVICE_TABLE(snd_als4000_ids) = {
+static const struct pci_device_id snd_als4000_ids[] = {
 	{ 0x4005, 0x4000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },   /* ALS4000 */
 	{ 0, }
 };

commit d85d878efb304779205beb951a5d87eb8018b6d8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 12:51:05 2014 +0100

    ALSA: als4000: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 2b2bb0fa3bc7..b751c381d25e 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -578,7 +578,7 @@ static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id)
 		snd_als4k_iobase_readb(chip->alt_port,
 					ALS4K_IOB_16_ACK_FOR_CR1E);
 
-	/* printk(KERN_INFO "als4000: irq 0x%04x 0x%04x\n",
+	/* dev_dbg(chip->card->dev, "als4000: irq 0x%04x 0x%04x\n",
 					 pci_irqstatus, sb_irqstatus); */
 
 	/* only ack the things we actually handled above */
@@ -791,13 +791,13 @@ static int snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev)
 	}
 
 	if (!r) {
-		printk(KERN_WARNING "als4000: cannot reserve joystick ports\n");
+		dev_warn(&acard->pci->dev, "cannot reserve joystick ports\n");
 		return -EBUSY;
 	}
 
 	acard->gameport = gp = gameport_allocate_port();
 	if (!gp) {
-		printk(KERN_ERR "als4000: cannot allocate memory for gameport\n");
+		dev_err(&acard->pci->dev, "cannot allocate memory for gameport\n");
 		release_and_free_resource(r);
 		return -ENOMEM;
 	}
@@ -873,7 +873,7 @@ static int snd_card_als4000_probe(struct pci_dev *pci,
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
 	if (pci_set_dma_mask(pci, DMA_BIT_MASK(24)) < 0 ||
 	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(24)) < 0) {
-		snd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");
+		dev_err(&pci->dev, "architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}
@@ -933,7 +933,7 @@ static int snd_card_als4000_probe(struct pci_dev *pci,
 					MPU401_INFO_INTEGRATED |
 					MPU401_INFO_IRQ_HOOK,
 					-1, &chip->rmidi)) < 0) {
-		printk(KERN_ERR "als4000: no MPU-401 device at 0x%lx?\n",
+		dev_err(&pci->dev, "no MPU-401 device at 0x%lx?\n",
 				iobase + ALS4K_IOB_30_MIDI_DATA);
 		goto out_err;
 	}
@@ -954,7 +954,7 @@ static int snd_card_als4000_probe(struct pci_dev *pci,
 				iobase + ALS4K_IOB_10_ADLIB_ADDR0,
 				iobase + ALS4K_IOB_12_ADLIB_ADDR2,
 			    OPL3_HW_AUTO, 1, &opl3) < 0) {
-		printk(KERN_ERR "als4000: no OPL device at 0x%lx-0x%lx?\n",
+		dev_err(&pci->dev, "no OPL device at 0x%lx-0x%lx?\n",
 			   iobase + ALS4K_IOB_10_ADLIB_ADDR0,
 			   iobase + ALS4K_IOB_12_ADLIB_ADDR2);
 	} else {
@@ -1014,8 +1014,7 @@ static int snd_als4000_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "als4000: pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index ffc821b0139e..2b2bb0fa3bc7 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -888,9 +888,9 @@ static int snd_card_als4000_probe(struct pci_dev *pci,
 	pci_write_config_word(pci, PCI_COMMAND, word | PCI_COMMAND_IO);
 	pci_set_master(pci);
 	
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 
-			      sizeof(*acard) /* private_data: acard */,
-			      &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   sizeof(*acard) /* private_data: acard */,
+			   &card);
 	if (err < 0) {
 		pci_release_regions(pci);
 		pci_disable_device(pci);
@@ -920,7 +920,6 @@ static int snd_card_als4000_probe(struct pci_dev *pci,
 
 	chip->pci = pci;
 	chip->alt_port = iobase;
-	snd_card_set_dev(card, &pci->dev);
 
 	snd_als4000_configure(chip);
 

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 61efda2a4d94..ffc821b0139e 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -984,7 +984,6 @@ static int snd_card_als4000_probe(struct pci_dev *pci,
 static void snd_card_als4000_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 #ifdef CONFIG_PM_SLEEP

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index feb2a1436830..61efda2a4d94 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -694,7 +694,7 @@ static struct snd_pcm_ops snd_als4000_capture_ops = {
 	.pointer =	snd_als4000_capture_pointer
 };
 
-static int __devinit snd_als4000_pcm(struct snd_sb *chip, int device)
+static int snd_als4000_pcm(struct snd_sb *chip, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -770,7 +770,7 @@ static void snd_als4000_configure(struct snd_sb *chip)
 }
 
 #ifdef SUPPORT_JOYSTICK
-static int __devinit snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev)
+static int snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev)
 {
 	struct gameport *gp;
 	struct resource *r;
@@ -847,8 +847,8 @@ static void snd_card_als4000_free( struct snd_card *card )
 	pci_disable_device(acard->pci);
 }
 
-static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
-					  const struct pci_device_id *pci_id)
+static int snd_card_als4000_probe(struct pci_dev *pci,
+				  const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_card *card;
@@ -981,7 +981,7 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 	return err;
 }
 
-static void __devexit snd_card_als4000_remove(struct pci_dev *pci)
+static void snd_card_als4000_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -1046,7 +1046,7 @@ static struct pci_driver als4000_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_als4000_ids,
 	.probe = snd_card_als4000_probe,
-	.remove = __devexit_p(snd_card_als4000_remove),
+	.remove = snd_card_als4000_remove,
 	.driver = {
 		.pm = SND_ALS4000_PM_OPS,
 	},

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 0eeca49c5754..feb2a1436830 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -987,7 +987,7 @@ static void __devexit snd_card_als4000_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int snd_als4000_suspend(struct device *dev)
 {
 	struct pci_dev *pci = to_pci_dev(dev);
@@ -1040,7 +1040,7 @@ static SIMPLE_DEV_PM_OPS(snd_als4000_pm, snd_als4000_suspend, snd_als4000_resume
 #define SND_ALS4000_PM_OPS	&snd_als4000_pm
 #else
 #define SND_ALS4000_PM_OPS	NULL
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 static struct pci_driver als4000_driver = {
 	.name = KBUILD_MODNAME,

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 7d7f2598c748..0eeca49c5754 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -988,9 +988,10 @@ static void __devexit snd_card_als4000_remove(struct pci_dev *pci)
 }
 
 #ifdef CONFIG_PM
-static int snd_als4000_suspend(struct pci_dev *pci, pm_message_t state)
+static int snd_als4000_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_card_als4000 *acard = card->private_data;
 	struct snd_sb *chip = acard->chip;
 
@@ -1001,13 +1002,14 @@ static int snd_als4000_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int snd_als4000_resume(struct pci_dev *pci)
+static int snd_als4000_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_card_als4000 *acard = card->private_data;
 	struct snd_sb *chip = acard->chip;
 
@@ -1033,18 +1035,21 @@ static int snd_als4000_resume(struct pci_dev *pci)
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
-#endif /* CONFIG_PM */
 
+static SIMPLE_DEV_PM_OPS(snd_als4000_pm, snd_als4000_suspend, snd_als4000_resume);
+#define SND_ALS4000_PM_OPS	&snd_als4000_pm
+#else
+#define SND_ALS4000_PM_OPS	NULL
+#endif /* CONFIG_PM */
 
 static struct pci_driver als4000_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_als4000_ids,
 	.probe = snd_card_als4000_probe,
 	.remove = __devexit_p(snd_card_als4000_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_als4000_suspend,
-	.resume = snd_als4000_resume,
-#endif
+	.driver = {
+		.pm = SND_ALS4000_PM_OPS,
+	},
 };
 
 module_pci_driver(als4000_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 3269b8011ea9..7d7f2598c748 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -1036,7 +1036,7 @@ static int snd_als4000_resume(struct pci_dev *pci)
 #endif /* CONFIG_PM */
 
 
-static struct pci_driver driver = {
+static struct pci_driver als4000_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_als4000_ids,
 	.probe = snd_card_als4000_probe,
@@ -1047,15 +1047,4 @@ static struct pci_driver driver = {
 #endif
 };
 
-static int __init alsa_card_als4000_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_als4000_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_als4000_init)
-module_exit(alsa_card_als4000_exit)
+module_pci_driver(als4000_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 28ef40e01cc2..3269b8011ea9 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -90,7 +90,7 @@ MODULE_SUPPORTED_DEVICE("{{Avance Logic,ALS4000}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 #ifdef SUPPORT_JOYSTICK
 static int joystick_port[SNDRV_CARDS];
 #endif

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 04628696eb08..28ef40e01cc2 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -69,7 +69,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/gameport.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/dma-mapping.h>
 #include <sound/core.h>
 #include <sound/pcm.h>

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index a9c1af33f276..04628696eb08 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -931,8 +931,9 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 
 	if ((err = snd_mpu401_uart_new( card, 0, MPU401_HW_ALS4000,
 					iobase + ALS4K_IOB_30_MIDI_DATA,
-					MPU401_INFO_INTEGRATED,
-					pci->irq, 0, &chip->rmidi)) < 0) {
+					MPU401_INFO_INTEGRATED |
+					MPU401_INFO_IRQ_HOOK,
+					-1, &chip->rmidi)) < 0) {
 		printk(KERN_ERR "als4000: no MPU-401 device at 0x%lx?\n",
 				iobase + ALS4K_IOB_30_MIDI_DATA);
 		goto out_err;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 0e247cb90ecc..a9c1af33f276 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -1036,7 +1036,7 @@ static int snd_als4000_resume(struct pci_dev *pci)
 
 
 static struct pci_driver driver = {
-	.name = "ALS4000",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_als4000_ids,
 	.probe = snd_card_als4000_probe,
 	.remove = __devexit_p(snd_card_als4000_remove),

commit c4685849b4d725ab80cd29f5e09f5f128b4724b5
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Wed Aug 4 21:56:44 2010 +0200

    ALSA: als4000: Fix potentially invalid DMA mode setup
    
    My previous patch assumed that the DMA mode (represented by 3 lowest bits of
    ALS4K_GCR99_DMA_EMULATION_CTRL register) is set to the default value 0. If
    that's not the case, it might result in invalid mode to be set.
    This patch fixes this potential problem.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 036a9ba8e1a5..0e247cb90ecc 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -765,7 +765,7 @@ static void snd_als4000_configure(struct snd_sb *chip)
 		snd_als4k_gcr_write(chip, i, 0);
 	/* enable burst mode to prevent dropouts during high PCI bus usage */
 	snd_als4k_gcr_write(chip, ALS4K_GCR99_DMA_EMULATION_CTRL,
-		snd_als4k_gcr_read(chip, ALS4K_GCR99_DMA_EMULATION_CTRL) | 0x04);
+		(snd_als4k_gcr_read(chip, ALS4K_GCR99_DMA_EMULATION_CTRL) & ~0x07) | 0x04);
 	spin_unlock_irq(&chip->reg_lock);
 }
 

commit b9619230e1f55a763bc41848c1cd971a394c878c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Aug 3 23:57:05 2010 +0200

    ALSA: als4000: enable burst mode
    
    Enable burst mode to prevent dropouts during high PCI bus usage.
    The card is useless in X without this because of dropouts when anything moves
    on the screen (at least with PCI VGA card). Enabling this is also recommended
    by the datasheet (page 48).
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 6cf1de8042e8..036a9ba8e1a5 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -763,9 +763,9 @@ static void snd_als4000_configure(struct snd_sb *chip)
 	/* SPECS_PAGE: 39 */
 	for (i = ALS4K_GCR91_DMA0_ADDR; i <= ALS4K_GCR96_DMA3_MODE_COUNT; ++i)
 		snd_als4k_gcr_write(chip, i, 0);
-	
+	/* enable burst mode to prevent dropouts during high PCI bus usage */
 	snd_als4k_gcr_write(chip, ALS4K_GCR99_DMA_EMULATION_CTRL,
-		snd_als4k_gcr_read(chip, ALS4K_GCR99_DMA_EMULATION_CTRL));
+		snd_als4k_gcr_read(chip, ALS4K_GCR99_DMA_EMULATION_CTRL) | 0x04);
 	spin_unlock_irq(&chip->reg_lock);
 }
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index d75cf7b06426..6cf1de8042e8 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -68,7 +68,6 @@
 #include <asm/io.h>
 #include <linux/init.h>
 #include <linux/pci.h>
-#include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
 #include <linux/dma-mapping.h>

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 3dbacde1a5af..d75cf7b06426 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -117,7 +117,7 @@ struct snd_card_als4000 {
 #endif
 };
 
-static struct pci_device_id snd_als4000_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_als4000_ids) = {
 	{ 0x4005, 0x4000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },   /* ALS4000 */
 	{ 0, }
 };

commit 2f4f27d42a301ed147e50c2edbcd27bb8990bc8e
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:18 2009 -0700

    dma-mapping: replace all DMA_24BIT_MASK macro with DMA_BIT_MASK(24)
    
    Replace all DMA_24BIT_MASK macro with DMA_BIT_MASK(24)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 542a0c65a92c..3dbacde1a5af 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -872,8 +872,8 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 		return err;
 	}
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
-	if (pci_set_dma_mask(pci, DMA_24BIT_MASK) < 0 ||
-	    pci_set_consistent_dma_mask(pci, DMA_24BIT_MASK) < 0) {
+	if (pci_set_dma_mask(pci, DMA_BIT_MASK(24)) < 0 ||
+	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(24)) < 0) {
 		snd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index ba570053d4d5..542a0c65a92c 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -889,12 +889,13 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 	pci_write_config_word(pci, PCI_COMMAND, word | PCI_COMMAND_IO);
 	pci_set_master(pci);
 	
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 
-			    sizeof(*acard) /* private_data: acard */);
-	if (card == NULL) {
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 
+			      sizeof(*acard) /* private_data: acard */,
+			      &card);
+	if (err < 0) {
 		pci_release_regions(pci);
 		pci_disable_device(pci);
-		return -ENOMEM;
+		return err;
 	}
 
 	acard = card->private_data;

commit cb780cdd85b8ae408245883ae44172ed1ed34439
Author: Andreas Mohr <andi@lisas.de>
Date:   Thu Aug 21 21:55:57 2008 +0200

    ALSA: ALS4000 driver work, step 2
    
    - more register naming work
    - finally figured out that weird CR register stuff
      (and did I mention that I hate _really_ undecipherable open-coded values?)
    - fix handling of IRQ sharing in interrupt handler
      (hopefully properly, otherwise I'd be grateful to hear your
      pedantic comments ;)
    - add handy SPECS_PAGE references wherever useful
    - comments, cleanup
    - add me as module author
    
    Signed-off-by: Andreas Mohr <andi@lisas.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 92d8c47cd3b2..ba570053d4d5 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -2,7 +2,7 @@
  *  card-als4000.c - driver for Avance Logic ALS4000 based soundcards.
  *  Copyright (C) 2000 by Bart Hartgers <bart@etpmod.phys.tue.nl>,
  *			  Jaroslav Kysela <perex@perex.cz>
- *  Copyright (C) 2002 by Andreas Mohr <hw7oshyuv3001@sneakemail.com>
+ *  Copyright (C) 2002, 2008 by Andreas Mohr <hw7oshyuv3001@sneakemail.com>
  *
  *  Framework borrowed from Massimo Piccioni's card-als100.c.
  *
@@ -27,8 +27,10 @@
  *  bought an ALS4000 based soundcard, I was forced to base this driver
  *  on reverse engineering.
  *
- *  Note: this is no longer true. Pretty verbose chip docu (ALS4000a.PDF)
- *  can be found on the ALSA web site.
+ *  Note: this is no longer true (thank you!):
+ *  pretty verbose chip docu (ALS4000a.PDF) can be found on the ALSA web site.
+ *  Page numbers stated anywhere below with the "SPECS_PAGE:" tag
+ *  refer to: ALS4000a.PDF specs Ver 1.0, May 28th, 1998.
  *
  *  The ALS4000 seems to be the PCI-cousin of the ALS100. It contains an
  *  ALS100-like SB DSP/mixer, an OPL3 synth, a MPU401 and a gameport 
@@ -59,7 +61,6 @@
  * - value -> some port 0x0c0d
  *
  * ToDo:
- * - Proper shared IRQ handling?
  * - by default, don't enable legacy game and use PCI game I/O
  * - power management? (card can do voice wakeup according to datasheet!!)
  */
@@ -79,7 +80,7 @@
 #include <sound/sb.h>
 #include <sound/initval.h>
 
-MODULE_AUTHOR("Bart Hartgers <bart@etpmod.phys.tue.nl>");
+MODULE_AUTHOR("Bart Hartgers <bart@etpmod.phys.tue.nl>, Andreas Mohr");
 MODULE_DESCRIPTION("Avance Logic ALS4000");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Avance Logic,ALS4000}}");
@@ -124,22 +125,22 @@ static struct pci_device_id snd_als4000_ids[] = {
 MODULE_DEVICE_TABLE(pci, snd_als4000_ids);
 
 enum als4k_iobase_t {
-	/* IOx: B == Byte, W = Word, D = DWord */
+	/* IOx: B == Byte, W = Word, D = DWord; SPECS_PAGE: 37 */
 	ALS4K_IOD_00_AC97_ACCESS = 0x00,
 	ALS4K_IOW_04_AC97_READ = 0x04,
 	ALS4K_IOB_06_AC97_STATUS = 0x06,
 	ALS4K_IOB_07_IRQSTATUS = 0x07,
 	ALS4K_IOD_08_GCR_DATA = 0x08,
 	ALS4K_IOB_0C_GCR_INDEX = 0x0c,
-	ALS4K_IOB_0E_SB_MPU_IRQ = 0x0e,
+	ALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU = 0x0e,
 	ALS4K_IOB_10_ADLIB_ADDR0 = 0x10,
 	ALS4K_IOB_11_ADLIB_ADDR1 = 0x11,
 	ALS4K_IOB_12_ADLIB_ADDR2 = 0x12,
 	ALS4K_IOB_13_ADLIB_ADDR3 = 0x13,
 	ALS4K_IOB_14_MIXER_INDEX = 0x14,
 	ALS4K_IOB_15_MIXER_DATA = 0x15,
-	ALS4K_IOB_16_ESP_RST_PORT = 0x16,
-	ALS4K_IOB_16_CR1E_ACK_PORT = 0x16, /* 2nd function */
+	ALS4K_IOB_16_ESP_RESET = 0x16,
+	ALS4K_IOB_16_ACK_FOR_CR1E = 0x16, /* 2nd function */
 	ALS4K_IOB_18_OPL_ADDR0 = 0x18,
 	ALS4K_IOB_19_OPL_ADDR1 = 0x19,
 	ALS4K_IOB_1A_ESP_RD_DATA = 0x1a,
@@ -154,62 +155,137 @@ enum als4k_iobase_t {
 	ALS4K_IOB_31_MIDI_COMMAND = 0x31, /* 2nd function */
 };
 
-enum als4k_gcr_t {
-	/* all registers 32bit wide */
-	ALS4K_GCR_8C_MISC_CTRL = 0x8c,
-	ALS4K_GCR_90_TEST_MODE_REG = 0x90,
-	ALS4K_GCR_91_DMA0_ADDR = 0x91,
-	ALS4K_GCR_92_DMA0_MODE_COUNT = 0x92,
-	ALS4K_GCR_93_DMA1_ADDR = 0x93,
-	ALS4K_GCR_94_DMA1_MODE_COUNT = 0x94,
-	ALS4K_GCR_95_DMA3_ADDR = 0x95,
-	ALS4K_GCR_96_DMA3_MODE_COUNT = 0x96,
-	ALS4K_GCR_99_DMA_EMULATION_CTRL = 0x99,
-	ALS4K_GCR_A0_FIFO1_CURRENT_ADDR = 0xa0,
-	ALS4K_GCR_A1_FIFO1_STATUS_BYTECOUNT = 0xa1,
-	ALS4K_GCR_A2_FIFO2_PCIADDR = 0xa2,
-	ALS4K_GCR_A3_FIFO2_COUNT = 0xa3,
-	ALS4K_GCR_A4_FIFO2_CURRENT_ADDR = 0xa4,
-	ALS4K_GCR_A5_FIFO1_STATUS_BYTECOUNT = 0xa5,
-	ALS4K_GCR_A6_PM_CTRL = 0xa6,
-	ALS4K_GCR_A7_PCI_ACCESS_STORAGE = 0xa7,
-	ALS4K_GCR_A8_LEGACY_CFG1 = 0xa8,
-	ALS4K_GCR_A9_LEGACY_CFG2 = 0xa9,
-	ALS4K_GCR_FF_DUMMY_SCRATCH = 0xff,
+enum als4k_iobase_0e_t {
+	ALS4K_IOB_0E_MPU_IRQ = 0x10,
+	ALS4K_IOB_0E_CR1E_IRQ = 0x40,
+	ALS4K_IOB_0E_SB_DMA_IRQ = 0x80,
 };
 
-enum als4k_gcr_8c_t {
-	ALS4K_GCR_8C_IRQ_MASK_CTRL_ENABLE = 0x8000,
-	ALS4K_GCR_8C_CHIP_REV_MASK = 0xf0000
+enum als4k_gcr_t { /* all registers 32bit wide; SPECS_PAGE: 38 to 42 */
+	ALS4K_GCR8C_MISC_CTRL = 0x8c,
+	ALS4K_GCR90_TEST_MODE_REG = 0x90,
+	ALS4K_GCR91_DMA0_ADDR = 0x91,
+	ALS4K_GCR92_DMA0_MODE_COUNT = 0x92,
+	ALS4K_GCR93_DMA1_ADDR = 0x93,
+	ALS4K_GCR94_DMA1_MODE_COUNT = 0x94,
+	ALS4K_GCR95_DMA3_ADDR = 0x95,
+	ALS4K_GCR96_DMA3_MODE_COUNT = 0x96,
+	ALS4K_GCR99_DMA_EMULATION_CTRL = 0x99,
+	ALS4K_GCRA0_FIFO1_CURRENT_ADDR = 0xa0,
+	ALS4K_GCRA1_FIFO1_STATUS_BYTECOUNT = 0xa1,
+	ALS4K_GCRA2_FIFO2_PCIADDR = 0xa2,
+	ALS4K_GCRA3_FIFO2_COUNT = 0xa3,
+	ALS4K_GCRA4_FIFO2_CURRENT_ADDR = 0xa4,
+	ALS4K_GCRA5_FIFO1_STATUS_BYTECOUNT = 0xa5,
+	ALS4K_GCRA6_PM_CTRL = 0xa6,
+	ALS4K_GCRA7_PCI_ACCESS_STORAGE = 0xa7,
+	ALS4K_GCRA8_LEGACY_CFG1 = 0xa8,
+	ALS4K_GCRA9_LEGACY_CFG2 = 0xa9,
+	ALS4K_GCRFF_DUMMY_SCRATCH = 0xff,
 };
 
-static inline void snd_als4000_gcr_write_addr(unsigned long iobase,
-						 enum als4k_gcr_t reg,
-						 u32 val)
+enum als4k_gcr8c_t {
+	ALS4K_GCR8C_IRQ_MASK_CTRL_ENABLE = 0x8000,
+	ALS4K_GCR8C_CHIP_REV_MASK = 0xf0000
+};
+
+static inline void snd_als4k_iobase_writeb(unsigned long iobase,
+						enum als4k_iobase_t reg,
+						u8 val)
 {
-	outb(reg, iobase + ALS4K_IOB_0C_GCR_INDEX);
-	outl(val, iobase + ALS4K_IOD_08_GCR_DATA);
+	outb(val, iobase + reg);
 }
 
-static inline void snd_als4000_gcr_write(struct snd_sb *sb,
+static inline void snd_als4k_iobase_writel(unsigned long iobase,
+						enum als4k_iobase_t reg,
+						u32 val)
+{
+	outl(val, iobase + reg);
+}
+
+static inline u8 snd_als4k_iobase_readb(unsigned long iobase,
+						enum als4k_iobase_t reg)
+{
+	return inb(iobase + reg);
+}
+
+static inline u32 snd_als4k_iobase_readl(unsigned long iobase,
+						enum als4k_iobase_t reg)
+{
+	return inl(iobase + reg);
+}
+
+static inline void snd_als4k_gcr_write_addr(unsigned long iobase,
 						 enum als4k_gcr_t reg,
 						 u32 val)
 {
-	snd_als4000_gcr_write_addr(sb->alt_port, reg, val);
+	snd_als4k_iobase_writeb(iobase, ALS4K_IOB_0C_GCR_INDEX, reg);
+	snd_als4k_iobase_writel(iobase, ALS4K_IOD_08_GCR_DATA, val);
+}
+
+static inline void snd_als4k_gcr_write(struct snd_sb *sb,
+					 enum als4k_gcr_t reg,
+					 u32 val)
+{
+	snd_als4k_gcr_write_addr(sb->alt_port, reg, val);
 }	
 
-static inline u32 snd_als4000_gcr_read_addr(unsigned long iobase,
+static inline u32 snd_als4k_gcr_read_addr(unsigned long iobase,
 						 enum als4k_gcr_t reg)
 {
-	outb(reg, iobase + ALS4K_IOB_0C_GCR_INDEX);
-	return inl(iobase + ALS4K_IOD_08_GCR_DATA);
+	/* SPECS_PAGE: 37/38 */
+	snd_als4k_iobase_writeb(iobase, ALS4K_IOB_0C_GCR_INDEX, reg);
+	return snd_als4k_iobase_readl(iobase, ALS4K_IOD_08_GCR_DATA);
+}
+
+static inline u32 snd_als4k_gcr_read(struct snd_sb *sb, enum als4k_gcr_t reg)
+{
+	return snd_als4k_gcr_read_addr(sb->alt_port, reg);
+}
+
+enum als4k_cr_t { /* all registers 8bit wide; SPECS_PAGE: 20 to 23 */
+	ALS4K_CR0_SB_CONFIG = 0x00,
+	ALS4K_CR2_MISC_CONTROL = 0x02,
+	ALS4K_CR3_CONFIGURATION = 0x03,
+	ALS4K_CR17_FIFO_STATUS = 0x17,
+	ALS4K_CR18_ESP_MAJOR_VERSION = 0x18,
+	ALS4K_CR19_ESP_MINOR_VERSION = 0x19,
+	ALS4K_CR1A_MPU401_UART_MODE_CONTROL = 0x1a,
+	ALS4K_CR1C_FIFO2_BLOCK_LENGTH_LO = 0x1c,
+	ALS4K_CR1D_FIFO2_BLOCK_LENGTH_HI = 0x1d,
+	ALS4K_CR1E_FIFO2_CONTROL = 0x1e, /* secondary PCM FIFO (recording) */
+	ALS4K_CR3A_MISC_CONTROL = 0x3a,
+	ALS4K_CR3B_CRC32_BYTE0 = 0x3b, /* for testing, activate via CR3A */
+	ALS4K_CR3C_CRC32_BYTE1 = 0x3c,
+	ALS4K_CR3D_CRC32_BYTE2 = 0x3d,
+	ALS4K_CR3E_CRC32_BYTE3 = 0x3e,
+};
+
+enum als4k_cr0_t {
+	ALS4K_CR0_DMA_CONTIN_MODE_CTRL = 0x02, /* IRQ/FIFO controlled for 0/1 */
+	ALS4K_CR0_DMA_90H_MODE_CTRL = 0x04, /* IRQ/FIFO controlled for 0/1 */
+	ALS4K_CR0_MX80_81_REG_WRITE_ENABLE = 0x80,
+};
+
+static inline void snd_als4_cr_write(struct snd_sb *chip,
+					enum als4k_cr_t reg,
+					u8 data)
+{
+	/* Control Register is reg | 0xc0 (bit 7, 6 set) on sbmixer_index
+	 * NOTE: assumes chip->mixer_lock to be locked externally already!
+	 * SPECS_PAGE: 6 */
+	snd_sbmixer_write(chip, reg | 0xc0, data);
 }
 
-static inline u32 snd_als4000_gcr_read(struct snd_sb *sb, enum als4k_gcr_t reg)
+static inline u8 snd_als4_cr_read(struct snd_sb *chip,
+					enum als4k_cr_t reg)
 {
-	return snd_als4000_gcr_read_addr(sb->alt_port, reg);
+	/* NOTE: assumes chip->mixer_lock to be locked externally already! */
+	return snd_sbmixer_read(chip, reg | 0xc0);
 }
 
+
+
 static void snd_als4000_set_rate(struct snd_sb *chip, unsigned int rate)
 {
 	if (!(chip->mode & SB_RATE_LOCK)) {
@@ -222,16 +298,18 @@ static void snd_als4000_set_rate(struct snd_sb *chip, unsigned int rate)
 static inline void snd_als4000_set_capture_dma(struct snd_sb *chip,
 					       dma_addr_t addr, unsigned size)
 {
-	snd_als4000_gcr_write(chip, ALS4K_GCR_A2_FIFO2_PCIADDR, addr);
-	snd_als4000_gcr_write(chip, ALS4K_GCR_A3_FIFO2_COUNT, (size-1));
+	/* SPECS_PAGE: 40 */
+	snd_als4k_gcr_write(chip, ALS4K_GCRA2_FIFO2_PCIADDR, addr);
+	snd_als4k_gcr_write(chip, ALS4K_GCRA3_FIFO2_COUNT, (size-1));
 }
 
 static inline void snd_als4000_set_playback_dma(struct snd_sb *chip,
 						dma_addr_t addr,
 						unsigned size)
 {
-	snd_als4000_gcr_write(chip, ALS4K_GCR_91_DMA0_ADDR, addr);
-	snd_als4000_gcr_write(chip, ALS4K_GCR_92_DMA0_MODE_COUNT,
+	/* SPECS_PAGE: 38 */
+	snd_als4k_gcr_write(chip, ALS4K_GCR91_DMA0_ADDR, addr);
+	snd_als4k_gcr_write(chip, ALS4K_GCR92_DMA0_MODE_COUNT,
 							(size-1)|0x180000);
 }
 
@@ -316,7 +394,7 @@ static int snd_als4000_capture_prepare(struct snd_pcm_substream *substream)
 	count = snd_pcm_lib_period_bytes(substream);
 	
 	if (chip->capture_format & ALS4000_FORMAT_16BIT)
-		count >>=1;
+		count >>= 1;
 	count--;
 
 	spin_lock_irq(&chip->reg_lock);
@@ -324,8 +402,8 @@ static int snd_als4000_capture_prepare(struct snd_pcm_substream *substream)
 	snd_als4000_set_capture_dma(chip, runtime->dma_addr, size);
 	spin_unlock_irq(&chip->reg_lock);
 	spin_lock_irq(&chip->mixer_lock);
-	snd_sbmixer_write(chip, 0xdc, count);
-	snd_sbmixer_write(chip, 0xdd, count>>8);
+	snd_als4_cr_write(chip, ALS4K_CR1C_FIFO2_BLOCK_LENGTH_LO, count & 0xff);
+	snd_als4_cr_write(chip, ALS4K_CR1D_FIFO2_BLOCK_LENGTH_HI, count >> 8);
 	spin_unlock_irq(&chip->mixer_lock);
 	return 0;
 }
@@ -343,7 +421,7 @@ static int snd_als4000_playback_prepare(struct snd_pcm_substream *substream)
 	count = snd_pcm_lib_period_bytes(substream);
 	
 	if (chip->playback_format & ALS4000_FORMAT_16BIT)
-		count >>=1;
+		count >>= 1;
 	count--;
 	
 	/* FIXME: from second playback on, there's a lot more clicks and pops
@@ -360,8 +438,8 @@ static int snd_als4000_playback_prepare(struct snd_pcm_substream *substream)
 	/* snd_sbdsp_command(chip, SB_DSP_SPEAKER_ON); */
 	snd_sbdsp_command(chip, playback_cmd(chip).dsp_cmd);
 	snd_sbdsp_command(chip, playback_cmd(chip).format);
-	snd_sbdsp_command(chip, count);
-	snd_sbdsp_command(chip, count>>8);
+	snd_sbdsp_command(chip, count & 0xff);
+	snd_sbdsp_command(chip, count >> 8);
 	snd_sbdsp_command(chip, playback_cmd(chip).dma_off);	
 	spin_unlock_irq(&chip->reg_lock);
 	
@@ -384,12 +462,14 @@ static int snd_als4000_capture_trigger(struct snd_pcm_substream *substream, int
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 		chip->mode |= SB_RATE_LOCK_CAPTURE;
-		snd_sbmixer_write(chip, 0xde, capture_cmd(chip));
+		snd_als4_cr_write(chip, ALS4K_CR1E_FIFO2_CONTROL,
+							 capture_cmd(chip));
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 		chip->mode &= ~SB_RATE_LOCK_CAPTURE;
-		snd_sbmixer_write(chip, 0xde, 0);
+		snd_als4_cr_write(chip, ALS4K_CR1E_FIFO2_CONTROL,
+							 capture_cmd(chip));
 		break;
 	default:
 		result = -EINVAL;
@@ -430,9 +510,9 @@ static snd_pcm_uframes_t snd_als4000_capture_pointer(struct snd_pcm_substream *s
 	unsigned int result;
 
 	spin_lock(&chip->reg_lock);	
-	result = snd_als4000_gcr_read(chip, ALS4K_GCR_A4_FIFO2_CURRENT_ADDR);
-	result &= 0xffff;
+	result = snd_als4k_gcr_read(chip, ALS4K_GCRA4_FIFO2_CURRENT_ADDR);
 	spin_unlock(&chip->reg_lock);
+	result &= 0xffff;
 	return bytes_to_frames( substream->runtime, result );
 }
 
@@ -442,9 +522,9 @@ static snd_pcm_uframes_t snd_als4000_playback_pointer(struct snd_pcm_substream *
 	unsigned result;
 
 	spin_lock(&chip->reg_lock);	
-	result = snd_als4000_gcr_read(chip, ALS4K_GCR_A0_FIFO1_CURRENT_ADDR);
-	result &= 0xffff;
+	result = snd_als4k_gcr_read(chip, ALS4K_GCRA0_FIFO1_CURRENT_ADDR);
 	spin_unlock(&chip->reg_lock);
+	result &= 0xffff;
 	return bytes_to_frames( substream->runtime, result );
 }
 
@@ -452,46 +532,63 @@ static snd_pcm_uframes_t snd_als4000_playback_pointer(struct snd_pcm_substream *
  * return IRQ_HANDLED no matter whether we actually had an IRQ flag or not).
  * ALS4000a.PDF writes that while ACKing IRQ in PCI block will *not* ACK
  * the IRQ in the SB core, ACKing IRQ in SB block *will* ACK the PCI IRQ
- * register (alt_port + ALS4K_IOB_0E_SB_MPU_IRQ). Probably something
+ * register (alt_port + ALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU). Probably something
  * could be optimized here to query/write one register only...
  * And even if both registers need to be queried, then there's still the
  * question of whether it's actually correct to ACK PCI IRQ before reading
  * SB IRQ like we do now, since ALS4000a.PDF mentions that PCI IRQ will *clear*
  * SB IRQ status.
- * (hmm, page 38 mentions it the other way around!)
+ * (hmm, SPECS_PAGE: 38 mentions it the other way around!)
  * And do we *really* need the lock here for *reading* SB_DSP4_IRQSTATUS??
  * */
 static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id)
 {
 	struct snd_sb *chip = dev_id;
-	unsigned gcr_status;
-	unsigned sb_status;
-
-	/* find out which bit of the ALS4000 produced the interrupt */
-	gcr_status = inb(chip->alt_port + ALS4K_IOB_0E_SB_MPU_IRQ);
-
-	if ((gcr_status & 0x80) && (chip->playback_substream)) /* playback */
+	unsigned pci_irqstatus;
+	unsigned sb_irqstatus;
+
+	/* find out which bit of the ALS4000 PCI block produced the interrupt,
+	   SPECS_PAGE: 38, 5 */
+	pci_irqstatus = snd_als4k_iobase_readb(chip->alt_port,
+				 ALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU);
+	if ((pci_irqstatus & ALS4K_IOB_0E_SB_DMA_IRQ)
+	 && (chip->playback_substream)) /* playback */
 		snd_pcm_period_elapsed(chip->playback_substream);
-	if ((gcr_status & 0x40) && (chip->capture_substream)) /* capturing */
+	if ((pci_irqstatus & ALS4K_IOB_0E_CR1E_IRQ)
+	 && (chip->capture_substream)) /* capturing */
 		snd_pcm_period_elapsed(chip->capture_substream);
-	if ((gcr_status & 0x10) && (chip->rmidi)) /* MPU401 interrupt */
+	if ((pci_irqstatus & ALS4K_IOB_0E_MPU_IRQ)
+	 && (chip->rmidi)) /* MPU401 interrupt */
 		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
-	/* release the gcr */
-	outb(gcr_status, chip->alt_port + ALS4K_IOB_0E_SB_MPU_IRQ);
+	/* ACK the PCI block IRQ */
+	snd_als4k_iobase_writeb(chip->alt_port,
+			 ALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU, pci_irqstatus);
 	
 	spin_lock(&chip->mixer_lock);
-	sb_status = snd_sbmixer_read(chip, SB_DSP4_IRQSTATUS);
+	/* SPECS_PAGE: 20 */
+	sb_irqstatus = snd_sbmixer_read(chip, SB_DSP4_IRQSTATUS);
 	spin_unlock(&chip->mixer_lock);
 	
-	if (sb_status & SB_IRQTYPE_8BIT) 
+	if (sb_irqstatus & SB_IRQTYPE_8BIT)
 		snd_sb_ack_8bit(chip);
-	if (sb_status & SB_IRQTYPE_16BIT) 
+	if (sb_irqstatus & SB_IRQTYPE_16BIT)
 		snd_sb_ack_16bit(chip);
-	if (sb_status & SB_IRQTYPE_MPUIN)
+	if (sb_irqstatus & SB_IRQTYPE_MPUIN)
 		inb(chip->mpu_port);
-	if (sb_status & 0x20)
-		inb(SBP(chip, RESET));
-	return IRQ_HANDLED;
+	if (sb_irqstatus & ALS4K_IRQTYPE_CR1E_DMA)
+		snd_als4k_iobase_readb(chip->alt_port,
+					ALS4K_IOB_16_ACK_FOR_CR1E);
+
+	/* printk(KERN_INFO "als4000: irq 0x%04x 0x%04x\n",
+					 pci_irqstatus, sb_irqstatus); */
+
+	/* only ack the things we actually handled above */
+	return IRQ_RETVAL(
+	     (pci_irqstatus & (ALS4K_IOB_0E_SB_DMA_IRQ|ALS4K_IOB_0E_CR1E_IRQ|
+				ALS4K_IOB_0E_MPU_IRQ))
+	  || (sb_irqstatus & (SB_IRQTYPE_8BIT|SB_IRQTYPE_16BIT|
+				SB_IRQTYPE_MPUIN|ALS4K_IRQTYPE_CR1E_DMA))
+	);
 }
 
 /*****************************************************************/
@@ -603,7 +700,8 @@ static int __devinit snd_als4000_pcm(struct snd_sb *chip, int device)
 	struct snd_pcm *pcm;
 	int err;
 
-	if ((err = snd_pcm_new(chip->card, "ALS4000 DSP", device, 1, 1, &pcm)) < 0)
+	err = snd_pcm_new(chip->card, "ALS4000 DSP", device, 1, 1, &pcm);
+	if (err < 0)
 		return err;
 	pcm->private_data = chip;
 	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
@@ -637,34 +735,38 @@ static void snd_als4000_set_addr(unsigned long iobase,
 		cfg1 |= (game_io | 1) << 16;
 	if (opl_io > 0)
 		cfg1 |= (opl_io | 1);
-	snd_als4000_gcr_write_addr(iobase, ALS4K_GCR_A8_LEGACY_CFG1, cfg1);
-	snd_als4000_gcr_write_addr(iobase, ALS4K_GCR_A9_LEGACY_CFG2, cfg2);
+	snd_als4k_gcr_write_addr(iobase, ALS4K_GCRA8_LEGACY_CFG1, cfg1);
+	snd_als4k_gcr_write_addr(iobase, ALS4K_GCRA9_LEGACY_CFG2, cfg2);
 }
 
 static void snd_als4000_configure(struct snd_sb *chip)
 {
-	unsigned tmp;
+	u8 tmp;
 	int i;
 
 	/* do some more configuration */
 	spin_lock_irq(&chip->mixer_lock);
-	tmp = snd_sbmixer_read(chip, 0xc0);
-	snd_sbmixer_write(chip, 0xc0, tmp|0x80);
-	/* always select DMA channel 0, since we do not actually use DMA */
+	tmp = snd_als4_cr_read(chip, ALS4K_CR0_SB_CONFIG);
+	snd_als4_cr_write(chip, ALS4K_CR0_SB_CONFIG,
+				tmp|ALS4K_CR0_MX80_81_REG_WRITE_ENABLE);
+	/* always select DMA channel 0, since we do not actually use DMA
+	 * SPECS_PAGE: 19/20 */
 	snd_sbmixer_write(chip, SB_DSP4_DMASETUP, SB_DMASETUP_DMA0);
-	snd_sbmixer_write(chip, 0xc0, tmp&0x7f);
+	snd_als4_cr_write(chip, ALS4K_CR0_SB_CONFIG,
+				 tmp & ~ALS4K_CR0_MX80_81_REG_WRITE_ENABLE);
 	spin_unlock_irq(&chip->mixer_lock);
 	
 	spin_lock_irq(&chip->reg_lock);
 	/* enable interrupts */
-	snd_als4000_gcr_write(chip, ALS4K_GCR_8C_MISC_CTRL,
-					 ALS4K_GCR_8C_IRQ_MASK_CTRL_ENABLE);
+	snd_als4k_gcr_write(chip, ALS4K_GCR8C_MISC_CTRL,
+					ALS4K_GCR8C_IRQ_MASK_CTRL_ENABLE);
 
-	for (i = ALS4K_GCR_91_DMA0_ADDR; i <= ALS4K_GCR_96_DMA3_MODE_COUNT; ++i)
-		snd_als4000_gcr_write(chip, i, 0);
+	/* SPECS_PAGE: 39 */
+	for (i = ALS4K_GCR91_DMA0_ADDR; i <= ALS4K_GCR96_DMA3_MODE_COUNT; ++i)
+		snd_als4k_gcr_write(chip, i, 0);
 	
-	snd_als4000_gcr_write(chip, ALS4K_GCR_99_DMA_EMULATION_CTRL,
-		snd_als4000_gcr_read(chip, ALS4K_GCR_99_DMA_EMULATION_CTRL));
+	snd_als4k_gcr_write(chip, ALS4K_GCR99_DMA_EMULATION_CTRL,
+		snd_als4k_gcr_read(chip, ALS4K_GCR99_DMA_EMULATION_CTRL));
 	spin_unlock_irq(&chip->reg_lock);
 }
 
@@ -739,7 +841,7 @@ static void snd_card_als4000_free( struct snd_card *card )
 	struct snd_card_als4000 *acard = card->private_data;
 
 	/* make sure that interrupts are disabled */
-	snd_als4000_gcr_write_addr(acard->iobase, ALS4K_GCR_8C_MISC_CTRL, 0);
+	snd_als4k_gcr_write_addr(acard->iobase, ALS4K_GCR8C_MISC_CTRL, 0);
 	/* free resources */
 	snd_als4000_free_gameport(acard);
 	pci_release_regions(acard->pci);
@@ -788,7 +890,7 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 	pci_set_master(pci);
 	
 	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 
-			    sizeof( struct snd_card_als4000 ) );
+			    sizeof(*acard) /* private_data: acard */);
 	if (card == NULL) {
 		pci_release_regions(pci);
 		pci_disable_device(pci);
@@ -806,6 +908,7 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 	if ((err = snd_sbdsp_create(card,
 				    iobase + ALS4K_IOB_10_ADLIB_ADDR0,
 				    pci->irq,
+		/* internally registered as IRQF_SHARED in case of ALS4000 SB */
 				    snd_als4000_interrupt,
 				    -1,
 				    -1,
@@ -835,8 +938,10 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 		goto out_err;
 	}
 	/* FIXME: ALS4000 has interesting MPU401 configuration features
-	 * at CR 0x1A (pass-thru / UART switching, fast MIDI clock, etc.),
-	 * however there doesn't seem to be an ALSA API for this... */
+	 * at ALS4K_CR1A_MPU401_UART_MODE_CONTROL
+	 * (pass-thru / UART switching, fast MIDI clock, etc.),
+	 * however there doesn't seem to be an ALSA API for this...
+	 * SPECS_PAGE: 21 */
 
 	if ((err = snd_als4000_pcm(chip, 0)) < 0) {
 		goto out_err;

commit c08744498491759168119255fae2a1bd9532a268
Author: Andreas Mohr <andi@lisas.de>
Date:   Wed Aug 20 10:04:56 2008 +0200

    ALSA: als4000 - Code clean up
    
    - use specs-derived register name enums instead of open-coded numeric
    values, for better understanding of things
    - fix naming confusion ("gcr" was _NOT_ the GCR register stuff, but
      instead the io _base_ which has multiplexed _access_ to GCR config
      space, at _sub_ registers 0x08 and 0x0c)
    - add FIXME comments about a race condition and MPU401 features
    
    Signed-off-by: Andreas Mohr <andi@lisas.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 27ce6136ab00..92d8c47cd3b2 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -60,6 +60,7 @@
  *
  * ToDo:
  * - Proper shared IRQ handling?
+ * - by default, don't enable legacy game and use PCI game I/O
  * - power management? (card can do voice wakeup according to datasheet!!)
  */
 
@@ -107,7 +108,7 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address for ALS4000 soundcard. (0
 
 struct snd_card_als4000 {
 	/* most frequent access first */
-	unsigned long gcr;
+	unsigned long iobase;
 	struct pci_dev *pci;
 	struct snd_sb *chip;
 #ifdef SUPPORT_JOYSTICK
@@ -122,24 +123,89 @@ static struct pci_device_id snd_als4000_ids[] = {
 
 MODULE_DEVICE_TABLE(pci, snd_als4000_ids);
 
-static inline void snd_als4000_gcr_write_addr(unsigned long port, u32 reg, u32 val)
+enum als4k_iobase_t {
+	/* IOx: B == Byte, W = Word, D = DWord */
+	ALS4K_IOD_00_AC97_ACCESS = 0x00,
+	ALS4K_IOW_04_AC97_READ = 0x04,
+	ALS4K_IOB_06_AC97_STATUS = 0x06,
+	ALS4K_IOB_07_IRQSTATUS = 0x07,
+	ALS4K_IOD_08_GCR_DATA = 0x08,
+	ALS4K_IOB_0C_GCR_INDEX = 0x0c,
+	ALS4K_IOB_0E_SB_MPU_IRQ = 0x0e,
+	ALS4K_IOB_10_ADLIB_ADDR0 = 0x10,
+	ALS4K_IOB_11_ADLIB_ADDR1 = 0x11,
+	ALS4K_IOB_12_ADLIB_ADDR2 = 0x12,
+	ALS4K_IOB_13_ADLIB_ADDR3 = 0x13,
+	ALS4K_IOB_14_MIXER_INDEX = 0x14,
+	ALS4K_IOB_15_MIXER_DATA = 0x15,
+	ALS4K_IOB_16_ESP_RST_PORT = 0x16,
+	ALS4K_IOB_16_CR1E_ACK_PORT = 0x16, /* 2nd function */
+	ALS4K_IOB_18_OPL_ADDR0 = 0x18,
+	ALS4K_IOB_19_OPL_ADDR1 = 0x19,
+	ALS4K_IOB_1A_ESP_RD_DATA = 0x1a,
+	ALS4K_IOB_1C_ESP_CMD_DATA = 0x1c,
+	ALS4K_IOB_1C_ESP_WR_STATUS = 0x1c, /* 2nd function */
+	ALS4K_IOB_1E_ESP_RD_STATUS8 = 0x1e,
+	ALS4K_IOB_1F_ESP_RD_STATUS16 = 0x1f,
+	ALS4K_IOB_20_ESP_GAMEPORT_200 = 0x20,
+	ALS4K_IOB_21_ESP_GAMEPORT_201 = 0x21,
+	ALS4K_IOB_30_MIDI_DATA = 0x30,
+	ALS4K_IOB_31_MIDI_STATUS = 0x31,
+	ALS4K_IOB_31_MIDI_COMMAND = 0x31, /* 2nd function */
+};
+
+enum als4k_gcr_t {
+	/* all registers 32bit wide */
+	ALS4K_GCR_8C_MISC_CTRL = 0x8c,
+	ALS4K_GCR_90_TEST_MODE_REG = 0x90,
+	ALS4K_GCR_91_DMA0_ADDR = 0x91,
+	ALS4K_GCR_92_DMA0_MODE_COUNT = 0x92,
+	ALS4K_GCR_93_DMA1_ADDR = 0x93,
+	ALS4K_GCR_94_DMA1_MODE_COUNT = 0x94,
+	ALS4K_GCR_95_DMA3_ADDR = 0x95,
+	ALS4K_GCR_96_DMA3_MODE_COUNT = 0x96,
+	ALS4K_GCR_99_DMA_EMULATION_CTRL = 0x99,
+	ALS4K_GCR_A0_FIFO1_CURRENT_ADDR = 0xa0,
+	ALS4K_GCR_A1_FIFO1_STATUS_BYTECOUNT = 0xa1,
+	ALS4K_GCR_A2_FIFO2_PCIADDR = 0xa2,
+	ALS4K_GCR_A3_FIFO2_COUNT = 0xa3,
+	ALS4K_GCR_A4_FIFO2_CURRENT_ADDR = 0xa4,
+	ALS4K_GCR_A5_FIFO1_STATUS_BYTECOUNT = 0xa5,
+	ALS4K_GCR_A6_PM_CTRL = 0xa6,
+	ALS4K_GCR_A7_PCI_ACCESS_STORAGE = 0xa7,
+	ALS4K_GCR_A8_LEGACY_CFG1 = 0xa8,
+	ALS4K_GCR_A9_LEGACY_CFG2 = 0xa9,
+	ALS4K_GCR_FF_DUMMY_SCRATCH = 0xff,
+};
+
+enum als4k_gcr_8c_t {
+	ALS4K_GCR_8C_IRQ_MASK_CTRL_ENABLE = 0x8000,
+	ALS4K_GCR_8C_CHIP_REV_MASK = 0xf0000
+};
+
+static inline void snd_als4000_gcr_write_addr(unsigned long iobase,
+						 enum als4k_gcr_t reg,
+						 u32 val)
 {
-	outb(reg, port+0x0c);
-	outl(val, port+0x08);
+	outb(reg, iobase + ALS4K_IOB_0C_GCR_INDEX);
+	outl(val, iobase + ALS4K_IOD_08_GCR_DATA);
 }
 
-static inline void snd_als4000_gcr_write(struct snd_sb *sb, u32 reg, u32 val)
+static inline void snd_als4000_gcr_write(struct snd_sb *sb,
+						 enum als4k_gcr_t reg,
+						 u32 val)
 {
 	snd_als4000_gcr_write_addr(sb->alt_port, reg, val);
 }	
 
-static inline u32 snd_als4000_gcr_read_addr(unsigned long port, u32 reg)
+static inline u32 snd_als4000_gcr_read_addr(unsigned long iobase,
+						 enum als4k_gcr_t reg)
 {
-	outb(reg, port+0x0c);
-	return inl(port+0x08);
+	outb(reg, iobase + ALS4K_IOB_0C_GCR_INDEX);
+	return inl(iobase + ALS4K_IOD_08_GCR_DATA);
 }
 
-static inline u32 snd_als4000_gcr_read(struct snd_sb *sb, u32 reg)
+static inline u32 snd_als4000_gcr_read(struct snd_sb *sb, enum als4k_gcr_t reg)
 {
 	return snd_als4000_gcr_read_addr(sb->alt_port, reg);
 }
@@ -156,15 +222,17 @@ static void snd_als4000_set_rate(struct snd_sb *chip, unsigned int rate)
 static inline void snd_als4000_set_capture_dma(struct snd_sb *chip,
 					       dma_addr_t addr, unsigned size)
 {
-	snd_als4000_gcr_write(chip, 0xa2, addr);
-	snd_als4000_gcr_write(chip, 0xa3, (size-1));
+	snd_als4000_gcr_write(chip, ALS4K_GCR_A2_FIFO2_PCIADDR, addr);
+	snd_als4000_gcr_write(chip, ALS4K_GCR_A3_FIFO2_COUNT, (size-1));
 }
 
 static inline void snd_als4000_set_playback_dma(struct snd_sb *chip,
-						dma_addr_t addr, unsigned size)
+						dma_addr_t addr,
+						unsigned size)
 {
-	snd_als4000_gcr_write(chip, 0x91, addr);
-	snd_als4000_gcr_write(chip, 0x92, (size-1)|0x180000);
+	snd_als4000_gcr_write(chip, ALS4K_GCR_91_DMA0_ADDR, addr);
+	snd_als4000_gcr_write(chip, ALS4K_GCR_92_DMA0_MODE_COUNT,
+							(size-1)|0x180000);
 }
 
 #define ALS4000_FORMAT_SIGNED	(1<<0)
@@ -305,6 +373,12 @@ static int snd_als4000_capture_trigger(struct snd_pcm_substream *substream, int
 	struct snd_sb *chip = snd_pcm_substream_chip(substream);
 	int result = 0;
 	
+	/* FIXME race condition in here!!!
+	   chip->mode non-atomic update gets consistently protected
+	   by reg_lock always, _except_ for this place!!
+	   Probably need to take reg_lock as outer (or inner??) lock, too.
+	   (or serialize both lock operations? probably not, though... - racy?)
+	*/
 	spin_lock(&chip->mixer_lock);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -356,7 +430,8 @@ static snd_pcm_uframes_t snd_als4000_capture_pointer(struct snd_pcm_substream *s
 	unsigned int result;
 
 	spin_lock(&chip->reg_lock);	
-	result = snd_als4000_gcr_read(chip, 0xa4) & 0xffff;
+	result = snd_als4000_gcr_read(chip, ALS4K_GCR_A4_FIFO2_CURRENT_ADDR);
+	result &= 0xffff;
 	spin_unlock(&chip->reg_lock);
 	return bytes_to_frames( substream->runtime, result );
 }
@@ -367,7 +442,8 @@ static snd_pcm_uframes_t snd_als4000_playback_pointer(struct snd_pcm_substream *
 	unsigned result;
 
 	spin_lock(&chip->reg_lock);	
-	result = snd_als4000_gcr_read(chip, 0xa0) & 0xffff;
+	result = snd_als4000_gcr_read(chip, ALS4K_GCR_A0_FIFO1_CURRENT_ADDR);
+	result &= 0xffff;
 	spin_unlock(&chip->reg_lock);
 	return bytes_to_frames( substream->runtime, result );
 }
@@ -376,12 +452,13 @@ static snd_pcm_uframes_t snd_als4000_playback_pointer(struct snd_pcm_substream *
  * return IRQ_HANDLED no matter whether we actually had an IRQ flag or not).
  * ALS4000a.PDF writes that while ACKing IRQ in PCI block will *not* ACK
  * the IRQ in the SB core, ACKing IRQ in SB block *will* ACK the PCI IRQ
- * register (alt_port + 0x0e). Probably something could be optimized here to
- * query/write one register only...
+ * register (alt_port + ALS4K_IOB_0E_SB_MPU_IRQ). Probably something
+ * could be optimized here to query/write one register only...
  * And even if both registers need to be queried, then there's still the
  * question of whether it's actually correct to ACK PCI IRQ before reading
  * SB IRQ like we do now, since ALS4000a.PDF mentions that PCI IRQ will *clear*
  * SB IRQ status.
+ * (hmm, page 38 mentions it the other way around!)
  * And do we *really* need the lock here for *reading* SB_DSP4_IRQSTATUS??
  * */
 static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id)
@@ -391,7 +468,7 @@ static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id)
 	unsigned sb_status;
 
 	/* find out which bit of the ALS4000 produced the interrupt */
-	gcr_status = inb(chip->alt_port + 0xe);
+	gcr_status = inb(chip->alt_port + ALS4K_IOB_0E_SB_MPU_IRQ);
 
 	if ((gcr_status & 0x80) && (chip->playback_substream)) /* playback */
 		snd_pcm_period_elapsed(chip->playback_substream);
@@ -400,7 +477,7 @@ static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id)
 	if ((gcr_status & 0x10) && (chip->rmidi)) /* MPU401 interrupt */
 		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
 	/* release the gcr */
-	outb(gcr_status, chip->alt_port + 0xe);
+	outb(gcr_status, chip->alt_port + ALS4K_IOB_0E_SB_MPU_IRQ);
 	
 	spin_lock(&chip->mixer_lock);
 	sb_status = snd_sbmixer_read(chip, SB_DSP4_IRQSTATUS);
@@ -543,25 +620,25 @@ static int __devinit snd_als4000_pcm(struct snd_sb *chip, int device)
 
 /******************************************************************/
 
-static void snd_als4000_set_addr(unsigned long gcr,
-					unsigned int sb,
-					unsigned int mpu,
-					unsigned int opl,
-					unsigned int game)
+static void snd_als4000_set_addr(unsigned long iobase,
+					unsigned int sb_io,
+					unsigned int mpu_io,
+					unsigned int opl_io,
+					unsigned int game_io)
 {
-	u32 confA = 0;
-	u32 confB = 0;
+	u32 cfg1 = 0;
+	u32 cfg2 = 0;
 
-	if (mpu > 0)
-		confB |= (mpu | 1) << 16;
-	if (sb > 0)
-		confB |= (sb | 1);
-	if (game > 0)
-		confA |= (game | 1) << 16;
-	if (opl > 0)	
-		confA |= (opl | 1);
-	snd_als4000_gcr_write_addr(gcr, 0xa8, confA);
-	snd_als4000_gcr_write_addr(gcr, 0xa9, confB);
+	if (mpu_io > 0)
+		cfg2 |= (mpu_io | 1) << 16;
+	if (sb_io > 0)
+		cfg2 |= (sb_io | 1);
+	if (game_io > 0)
+		cfg1 |= (game_io | 1) << 16;
+	if (opl_io > 0)
+		cfg1 |= (opl_io | 1);
+	snd_als4000_gcr_write_addr(iobase, ALS4K_GCR_A8_LEGACY_CFG1, cfg1);
+	snd_als4000_gcr_write_addr(iobase, ALS4K_GCR_A9_LEGACY_CFG2, cfg2);
 }
 
 static void snd_als4000_configure(struct snd_sb *chip)
@@ -579,12 +656,15 @@ static void snd_als4000_configure(struct snd_sb *chip)
 	spin_unlock_irq(&chip->mixer_lock);
 	
 	spin_lock_irq(&chip->reg_lock);
-	/* magic number. Enables interrupts(?) */
-	snd_als4000_gcr_write(chip, 0x8c, 0x28000);
-	for(i = 0x91; i <= 0x96; ++i)
+	/* enable interrupts */
+	snd_als4000_gcr_write(chip, ALS4K_GCR_8C_MISC_CTRL,
+					 ALS4K_GCR_8C_IRQ_MASK_CTRL_ENABLE);
+
+	for (i = ALS4K_GCR_91_DMA0_ADDR; i <= ALS4K_GCR_96_DMA3_MODE_COUNT; ++i)
 		snd_als4000_gcr_write(chip, i, 0);
 	
-	snd_als4000_gcr_write(chip, 0x99, snd_als4000_gcr_read(chip, 0x99));
+	snd_als4000_gcr_write(chip, ALS4K_GCR_99_DMA_EMULATION_CTRL,
+		snd_als4000_gcr_read(chip, ALS4K_GCR_99_DMA_EMULATION_CTRL));
 	spin_unlock_irq(&chip->reg_lock);
 }
 
@@ -628,7 +708,7 @@ static int __devinit snd_als4000_create_gameport(struct snd_card_als4000 *acard,
 	gameport_set_port_data(gp, r);
 
 	/* Enable legacy joystick port */
-	snd_als4000_set_addr(acard->gcr, 0, 0, 0, 1);
+	snd_als4000_set_addr(acard->iobase, 0, 0, 0, 1);
 
 	gameport_register_port(acard->gameport);
 
@@ -643,7 +723,9 @@ static void snd_als4000_free_gameport(struct snd_card_als4000 *acard)
 		gameport_unregister_port(acard->gameport);
 		acard->gameport = NULL;
 
-		snd_als4000_set_addr(acard->gcr, 0, 0, 0, 0); /* disable joystick */
+		/* disable joystick */
+		snd_als4000_set_addr(acard->iobase, 0, 0, 0, 0);
+
 		release_and_free_resource(r);
 	}
 }
@@ -654,10 +736,10 @@ static inline void snd_als4000_free_gameport(struct snd_card_als4000 *acard) { }
 
 static void snd_card_als4000_free( struct snd_card *card )
 {
-	struct snd_card_als4000 * acard = (struct snd_card_als4000 *)card->private_data;
+	struct snd_card_als4000 *acard = card->private_data;
 
 	/* make sure that interrupts are disabled */
-	snd_als4000_gcr_write_addr( acard->gcr, 0x8c, 0);
+	snd_als4000_gcr_write_addr(acard->iobase, ALS4K_GCR_8C_MISC_CTRL, 0);
 	/* free resources */
 	snd_als4000_free_gameport(acard);
 	pci_release_regions(acard->pci);
@@ -670,7 +752,7 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 	static int dev;
 	struct snd_card *card;
 	struct snd_card_als4000 *acard;
-	unsigned long gcr;
+	unsigned long iobase;
 	struct snd_sb *chip;
 	struct snd_opl3 *opl3;
 	unsigned short word;
@@ -699,7 +781,7 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 		pci_disable_device(pci);
 		return err;
 	}
-	gcr = pci_resource_start(pci, 0);
+	iobase = pci_resource_start(pci, 0);
 
 	pci_read_config_word(pci, PCI_COMMAND, &word);
 	pci_write_config_word(pci, PCI_COMMAND, word | PCI_COMMAND_IO);
@@ -713,16 +795,16 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 		return -ENOMEM;
 	}
 
-	acard = (struct snd_card_als4000 *)card->private_data;
+	acard = card->private_data;
 	acard->pci = pci;
-	acard->gcr = gcr;
+	acard->iobase = iobase;
 	card->private_free = snd_card_als4000_free;
 
 	/* disable all legacy ISA stuff */
-	snd_als4000_set_addr(acard->gcr, 0, 0, 0, 0);
+	snd_als4000_set_addr(acard->iobase, 0, 0, 0, 0);
 
 	if ((err = snd_sbdsp_create(card,
-				    gcr + 0x10,
+				    iobase + ALS4K_IOB_10_ADLIB_ADDR0,
 				    pci->irq,
 				    snd_als4000_interrupt,
 				    -1,
@@ -734,7 +816,7 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 	acard->chip = chip;
 
 	chip->pci = pci;
-	chip->alt_port = gcr;
+	chip->alt_port = iobase;
 	snd_card_set_dev(card, &pci->dev);
 
 	snd_als4000_configure(chip);
@@ -745,11 +827,16 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 		card->shortname, chip->alt_port, chip->irq);
 
 	if ((err = snd_mpu401_uart_new( card, 0, MPU401_HW_ALS4000,
-				        gcr+0x30, MPU401_INFO_INTEGRATED,
+					iobase + ALS4K_IOB_30_MIDI_DATA,
+					MPU401_INFO_INTEGRATED,
 					pci->irq, 0, &chip->rmidi)) < 0) {
-		printk(KERN_ERR "als4000: no MPU-401 device at 0x%lx?\n", gcr+0x30);
+		printk(KERN_ERR "als4000: no MPU-401 device at 0x%lx?\n",
+				iobase + ALS4K_IOB_30_MIDI_DATA);
 		goto out_err;
 	}
+	/* FIXME: ALS4000 has interesting MPU401 configuration features
+	 * at CR 0x1A (pass-thru / UART switching, fast MIDI clock, etc.),
+	 * however there doesn't seem to be an ALSA API for this... */
 
 	if ((err = snd_als4000_pcm(chip, 0)) < 0) {
 		goto out_err;
@@ -758,10 +845,13 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 		goto out_err;
 	}	    
 
-	if (snd_opl3_create(card, gcr+0x10, gcr+0x12,
+	if (snd_opl3_create(card,
+				iobase + ALS4K_IOB_10_ADLIB_ADDR0,
+				iobase + ALS4K_IOB_12_ADLIB_ADDR2,
 			    OPL3_HW_AUTO, 1, &opl3) < 0) {
 		printk(KERN_ERR "als4000: no OPL device at 0x%lx-0x%lx?\n",
-			   gcr+0x10, gcr+0x12 );
+			   iobase + ALS4K_IOB_10_ADLIB_ADDR0,
+			   iobase + ALS4K_IOB_12_ADLIB_ADDR2);
 	} else {
 		if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
 			goto out_err;
@@ -831,13 +921,13 @@ static int snd_als4000_resume(struct pci_dev *pci)
 
 #ifdef SUPPORT_JOYSTICK
 	if (acard->gameport)
-		snd_als4000_set_addr(acard->gcr, 0, 0, 0, 1);
+		snd_als4000_set_addr(acard->iobase, 0, 0, 0, 1);
 #endif
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
-#endif
+#endif /* CONFIG_PM */
 
 
 static struct pci_driver driver = {

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 1190ef366a41..27ce6136ab00 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -63,7 +63,6 @@
  * - power management? (card can do voice wakeup according to datasheet!!)
  */
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/init.h>
 #include <linux/pci.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 8fb55d3b454b..1190ef366a41 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -1,7 +1,7 @@
 /*
  *  card-als4000.c - driver for Avance Logic ALS4000 based soundcards.
  *  Copyright (C) 2000 by Bart Hartgers <bart@etpmod.phys.tue.nl>,
- *			  Jaroslav Kysela <perex@suse.cz>
+ *			  Jaroslav Kysela <perex@perex.cz>
  *  Copyright (C) 2002 by Andreas Mohr <hw7oshyuv3001@sneakemail.com>
  *
  *  Framework borrowed from Massimo Piccioni's card-als100.c.

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 15fc3929b5f7..8fb55d3b454b 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -804,9 +804,9 @@ static int snd_als4000_suspend(struct pci_dev *pci, pm_message_t state)
 	snd_pcm_suspend_all(chip->pcm);
 	snd_sbmixer_suspend(chip);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -816,9 +816,14 @@ static int snd_als4000_resume(struct pci_dev *pci)
 	struct snd_card_als4000 *acard = card->private_data;
 	struct snd_sb *chip = acard->chip;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "als4000: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_als4000_configure(chip);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 9e596f750cbd..15fc3929b5f7 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -385,7 +385,7 @@ static snd_pcm_uframes_t snd_als4000_playback_pointer(struct snd_pcm_substream *
  * SB IRQ status.
  * And do we *really* need the lock here for *reading* SB_DSP4_IRQSTATUS??
  * */
-static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id)
 {
 	struct snd_sb *chip = dev_id;
 	unsigned gcr_status;
@@ -399,7 +399,7 @@ static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id, struct pt_regs *
 	if ((gcr_status & 0x40) && (chip->capture_substream)) /* capturing */
 		snd_pcm_period_elapsed(chip->capture_substream);
 	if ((gcr_status & 0x10) && (chip->rmidi)) /* MPU401 interrupt */
-		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
+		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
 	/* release the gcr */
 	outb(gcr_status, chip->alt_port + 0xe);
 	

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index a9f08066459a..9e596f750cbd 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -116,7 +116,7 @@ struct snd_card_als4000 {
 #endif
 };
 
-static struct pci_device_id snd_als4000_ids[] __devinitdata = {
+static struct pci_device_id snd_als4000_ids[] = {
 	{ 0x4005, 0x4000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },   /* ALS4000 */
 	{ 0, }
 };

commit 302e4c2f9e2b9f07c69649782330a61c60001ac4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 23 13:24:30 2006 +0200

    [ALSA] Change an arugment of snd_mpu401_uart_new() to bit flags
    
    Change the 5th argument of snd_mpu401_uart_new() to bit flags
    instead of a boolean.  The argument takes bits that consist of
    MPU401_INFO_XXX flags.
    The callers that used the value 1 there are replaced with
    MPU401_INFO_INTEGRATED.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 60423b1c678b..a9f08066459a 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -746,8 +746,8 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 		card->shortname, chip->alt_port, chip->irq);
 
 	if ((err = snd_mpu401_uart_new( card, 0, MPU401_HW_ALS4000,
-				        gcr+0x30, 1, pci->irq, 0,
-				        &chip->rmidi)) < 0) {
+				        gcr+0x30, MPU401_INFO_INTEGRATED,
+					pci->irq, 0, &chip->rmidi)) < 0) {
 		printk(KERN_ERR "als4000: no MPU-401 device at 0x%lx?\n", gcr+0x30);
 		goto out_err;
 	}

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 100d8127a411..60423b1c678b 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -116,7 +116,7 @@ struct snd_card_als4000 {
 #endif
 };
 
-static struct pci_device_id snd_als4000_ids[] = {
+static struct pci_device_id snd_als4000_ids[] __devinitdata = {
 	{ 0x4005, 0x4000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },   /* ALS4000 */
 	{ 0, }
 };

commit 910638ae7ed4be27d6af55f6c9b5bf54b838e78b
Author: Matthias Gehre <M.Gehre@gmx.de>
Date:   Tue Mar 28 01:56:48 2006 -0800

    [PATCH] Replace 0xff.. with correct DMA_xBIT_MASK
    
    Replace all occurences of 0xff..  in calls to function pci_set_dma_mask()
    and pci_set_consistant_dma_mask() with the corresponding DMA_xBIT_MASK from
    linux/dma-mapping.h.
    
    Signed-off-by: Matthias Gehre <M.Gehre@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 7b2ff5f4672e..100d8127a411 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -70,6 +70,7 @@
 #include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
+#include <linux/dma-mapping.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
@@ -688,8 +689,8 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 		return err;
 	}
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
-	if (pci_set_dma_mask(pci, 0x00ffffff) < 0 ||
-	    pci_set_consistent_dma_mask(pci, 0x00ffffff) < 0) {
+	if (pci_set_dma_mask(pci, DMA_24BIT_MASK) < 0 ||
+	    pci_set_consistent_dma_mask(pci, DMA_24BIT_MASK) < 0) {
 		snd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit 703529140cfb774366b839f38f027f283cb948b4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:16:36 2005 +0100

    [ALSA] als4000 - Add PM support
    
    Modules: ALS4000 driver
    
    Add PM support to PCI ALS4000 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 8d0d9c0222c1..7b2ff5f4672e 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -109,6 +109,7 @@ struct snd_card_als4000 {
 	/* most frequent access first */
 	unsigned long gcr;
 	struct pci_dev *pci;
+	struct snd_sb *chip;
 #ifdef SUPPORT_JOYSTICK
 	struct gameport *gameport;
 #endif
@@ -305,14 +306,20 @@ static int snd_als4000_capture_trigger(struct snd_pcm_substream *substream, int
 	int result = 0;
 	
 	spin_lock(&chip->mixer_lock);
-	if (cmd == SNDRV_PCM_TRIGGER_START) {
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
 		chip->mode |= SB_RATE_LOCK_CAPTURE;
 		snd_sbmixer_write(chip, 0xde, capture_cmd(chip));
-	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		chip->mode &= ~SB_RATE_LOCK_CAPTURE;
 		snd_sbmixer_write(chip, 0xde, 0);
-	} else {
+		break;
+	default:
 		result = -EINVAL;
+		break;
 	}
 	spin_unlock(&chip->mixer_lock);
 	return result;
@@ -324,14 +331,20 @@ static int snd_als4000_playback_trigger(struct snd_pcm_substream *substream, int
 	int result = 0;
 
 	spin_lock(&chip->reg_lock);
-	if (cmd == SNDRV_PCM_TRIGGER_START) {
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
 		chip->mode |= SB_RATE_LOCK_PLAYBACK;
 		snd_sbdsp_command(chip, playback_cmd(chip).dma_on);
-	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		snd_sbdsp_command(chip, playback_cmd(chip).dma_off);
 		chip->mode &= ~SB_RATE_LOCK_PLAYBACK;
-	} else {
+		break;
+	default:
 		result = -EINVAL;
+		break;
 	}
 	spin_unlock(&chip->reg_lock);
 	return result;
@@ -551,7 +564,7 @@ static void snd_als4000_set_addr(unsigned long gcr,
 	snd_als4000_gcr_write_addr(gcr, 0xa9, confB);
 }
 
-static void __devinit snd_als4000_configure(struct snd_sb *chip)
+static void snd_als4000_configure(struct snd_sb *chip)
 {
 	unsigned tmp;
 	int i;
@@ -718,6 +731,7 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 				    &chip)) < 0) {
 		goto out_err;
 	}
+	acard->chip = chip;
 
 	chip->pci = pci;
 	chip->alt_port = gcr;
@@ -777,11 +791,59 @@ static void __devexit snd_card_als4000_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
+#ifdef CONFIG_PM
+static int snd_als4000_suspend(struct pci_dev *pci, pm_message_t state)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct snd_card_als4000 *acard = card->private_data;
+	struct snd_sb *chip = acard->chip;
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	
+	snd_pcm_suspend_all(chip->pcm);
+	snd_sbmixer_suspend(chip);
+
+	pci_set_power_state(pci, PCI_D3hot);
+	pci_disable_device(pci);
+	pci_save_state(pci);
+	return 0;
+}
+
+static int snd_als4000_resume(struct pci_dev *pci)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct snd_card_als4000 *acard = card->private_data;
+	struct snd_sb *chip = acard->chip;
+
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+	pci_set_power_state(pci, PCI_D0);
+	pci_set_master(pci);
+
+	snd_als4000_configure(chip);
+	snd_sbdsp_reset(chip);
+	snd_sbmixer_resume(chip);
+
+#ifdef SUPPORT_JOYSTICK
+	if (acard->gameport)
+		snd_als4000_set_addr(acard->gcr, 0, 0, 0, 1);
+#endif
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+}
+#endif
+
+
 static struct pci_driver driver = {
 	.name = "ALS4000",
 	.id_table = snd_als4000_ids,
 	.probe = snd_card_als4000_probe,
 	.remove = __devexit_p(snd_card_als4000_remove),
+#ifdef CONFIG_PM
+	.suspend = snd_als4000_suspend,
+	.resume = snd_als4000_resume,
+#endif
 };
 
 static int __init alsa_card_als4000_init(void)

commit 17c39d9a59cbf4b3a51a2694134754fc1d3668e7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:02:01 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI ALS4000
    
    Modules: ALS4000 driver
    
    Remove xxx_t typedefs from the PCI ALS4000 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 48b5175c59c0..8d0d9c0222c1 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -105,14 +105,14 @@ module_param_array(joystick_port, int, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address for ALS4000 soundcard. (0 = disabled)");
 #endif
 
-typedef struct {
+struct snd_card_als4000 {
 	/* most frequent access first */
 	unsigned long gcr;
 	struct pci_dev *pci;
 #ifdef SUPPORT_JOYSTICK
 	struct gameport *gameport;
 #endif
-} snd_card_als4000_t;
+};
 
 static struct pci_device_id snd_als4000_ids[] = {
 	{ 0x4005, 0x4000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },   /* ALS4000 */
@@ -127,7 +127,7 @@ static inline void snd_als4000_gcr_write_addr(unsigned long port, u32 reg, u32 v
 	outl(val, port+0x08);
 }
 
-static inline void snd_als4000_gcr_write(sb_t *sb, u32 reg, u32 val)
+static inline void snd_als4000_gcr_write(struct snd_sb *sb, u32 reg, u32 val)
 {
 	snd_als4000_gcr_write_addr(sb->alt_port, reg, val);
 }	
@@ -138,12 +138,12 @@ static inline u32 snd_als4000_gcr_read_addr(unsigned long port, u32 reg)
 	return inl(port+0x08);
 }
 
-static inline u32 snd_als4000_gcr_read(sb_t *sb, u32 reg)
+static inline u32 snd_als4000_gcr_read(struct snd_sb *sb, u32 reg)
 {
 	return snd_als4000_gcr_read_addr(sb->alt_port, reg);
 }
 
-static void snd_als4000_set_rate(sb_t *chip, unsigned int rate)
+static void snd_als4000_set_rate(struct snd_sb *chip, unsigned int rate)
 {
 	if (!(chip->mode & SB_RATE_LOCK)) {
 		snd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE_OUT);
@@ -152,13 +152,15 @@ static void snd_als4000_set_rate(sb_t *chip, unsigned int rate)
 	}
 }
 
-static inline void snd_als4000_set_capture_dma(sb_t *chip, dma_addr_t addr, unsigned size)
+static inline void snd_als4000_set_capture_dma(struct snd_sb *chip,
+					       dma_addr_t addr, unsigned size)
 {
 	snd_als4000_gcr_write(chip, 0xa2, addr);
 	snd_als4000_gcr_write(chip, 0xa3, (size-1));
 }
 
-static inline void snd_als4000_set_playback_dma(sb_t *chip, dma_addr_t addr, unsigned size)
+static inline void snd_als4000_set_playback_dma(struct snd_sb *chip,
+						dma_addr_t addr, unsigned size)
 {
 	snd_als4000_gcr_write(chip, 0x91, addr);
 	snd_als4000_gcr_write(chip, 0x92, (size-1)|0x180000);
@@ -168,7 +170,7 @@ static inline void snd_als4000_set_playback_dma(sb_t *chip, dma_addr_t addr, uns
 #define ALS4000_FORMAT_16BIT	(1<<1)
 #define ALS4000_FORMAT_STEREO	(1<<2)
 
-static int snd_als4000_get_format(snd_pcm_runtime_t *runtime)
+static int snd_als4000_get_format(struct snd_pcm_runtime *runtime)
 {
 	int result;
 
@@ -220,23 +222,22 @@ CMD_SIGNED|CMD_STEREO,			/* ALS4000_FORMAT_S16L_STEREO */
 };	
 #define capture_cmd(chip) (capture_cmd_vals[(chip)->capture_format])
 
-static int snd_als4000_hw_params(snd_pcm_substream_t * substream,
-				 snd_pcm_hw_params_t * hw_params)
+static int snd_als4000_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static int snd_als4000_hw_free(snd_pcm_substream_t * substream)
+static int snd_als4000_hw_free(struct snd_pcm_substream *substream)
 {
 	snd_pcm_lib_free_pages(substream);
 	return 0;
 }
 
-static int snd_als4000_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_als4000_capture_prepare(struct snd_pcm_substream *substream)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	unsigned long flags;
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned long size;
 	unsigned count;
 
@@ -249,22 +250,21 @@ static int snd_als4000_capture_prepare(snd_pcm_substream_t * substream)
 		count >>=1;
 	count--;
 
-	spin_lock_irqsave(&chip->reg_lock, flags);
+	spin_lock_irq(&chip->reg_lock);
 	snd_als4000_set_rate(chip, runtime->rate);
 	snd_als4000_set_capture_dma(chip, runtime->dma_addr, size);
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
-	spin_lock_irqsave(&chip->mixer_lock, flags );
+	spin_unlock_irq(&chip->reg_lock);
+	spin_lock_irq(&chip->mixer_lock);
 	snd_sbmixer_write(chip, 0xdc, count);
 	snd_sbmixer_write(chip, 0xdd, count>>8);
-	spin_unlock_irqrestore(&chip->mixer_lock, flags );
+	spin_unlock_irq(&chip->mixer_lock);
 	return 0;
 }
 
-static int snd_als4000_playback_prepare(snd_pcm_substream_t *substream)
+static int snd_als4000_playback_prepare(struct snd_pcm_substream *substream)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	unsigned long flags;
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned long size;
 	unsigned count;
 
@@ -283,7 +283,7 @@ static int snd_als4000_playback_prepare(snd_pcm_substream_t *substream)
 	 * reordering, ...). Something seems to get enabled on playback
 	 * that I haven't found out how to disable again, which then causes
 	 * the switching pops to reach the speakers the next time here. */
-	spin_lock_irqsave(&chip->reg_lock, flags);
+	spin_lock_irq(&chip->reg_lock);
 	snd_als4000_set_rate(chip, runtime->rate);
 	snd_als4000_set_playback_dma(chip, runtime->dma_addr, size);
 	
@@ -294,14 +294,14 @@ static int snd_als4000_playback_prepare(snd_pcm_substream_t *substream)
 	snd_sbdsp_command(chip, count);
 	snd_sbdsp_command(chip, count>>8);
 	snd_sbdsp_command(chip, playback_cmd(chip).dma_off);	
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	spin_unlock_irq(&chip->reg_lock);
 	
 	return 0;
 }
 
-static int snd_als4000_capture_trigger(snd_pcm_substream_t * substream, int cmd)
+static int snd_als4000_capture_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
 	int result = 0;
 	
 	spin_lock(&chip->mixer_lock);
@@ -318,9 +318,9 @@ static int snd_als4000_capture_trigger(snd_pcm_substream_t * substream, int cmd)
 	return result;
 }
 
-static int snd_als4000_playback_trigger(snd_pcm_substream_t * substream, int cmd)
+static int snd_als4000_playback_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
 	int result = 0;
 
 	spin_lock(&chip->reg_lock);
@@ -337,9 +337,9 @@ static int snd_als4000_playback_trigger(snd_pcm_substream_t * substream, int cmd
 	return result;
 }
 
-static snd_pcm_uframes_t snd_als4000_capture_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_als4000_capture_pointer(struct snd_pcm_substream *substream)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
 	unsigned int result;
 
 	spin_lock(&chip->reg_lock);	
@@ -348,9 +348,9 @@ static snd_pcm_uframes_t snd_als4000_capture_pointer(snd_pcm_substream_t * subst
 	return bytes_to_frames( substream->runtime, result );
 }
 
-static snd_pcm_uframes_t snd_als4000_playback_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_als4000_playback_pointer(struct snd_pcm_substream *substream)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
 	unsigned result;
 
 	spin_lock(&chip->reg_lock);	
@@ -373,7 +373,7 @@ static snd_pcm_uframes_t snd_als4000_playback_pointer(snd_pcm_substream_t * subs
  * */
 static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	sb_t *chip = dev_id;
+	struct snd_sb *chip = dev_id;
 	unsigned gcr_status;
 	unsigned sb_status;
 
@@ -406,7 +406,7 @@ static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id, struct pt_regs *
 
 /*****************************************************************/
 
-static snd_pcm_hardware_t snd_als4000_playback =
+static struct snd_pcm_hardware snd_als4000_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP_VALID),
@@ -425,7 +425,7 @@ static snd_pcm_hardware_t snd_als4000_playback =
 	.fifo_size =		0
 };
 
-static snd_pcm_hardware_t snd_als4000_capture =
+static struct snd_pcm_hardware snd_als4000_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP_VALID),
@@ -446,38 +446,38 @@ static snd_pcm_hardware_t snd_als4000_capture =
 
 /*****************************************************************/
 
-static int snd_als4000_playback_open(snd_pcm_substream_t * substream)
+static int snd_als4000_playback_open(struct snd_pcm_substream *substream)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	chip->playback_substream = substream;
 	runtime->hw = snd_als4000_playback;
 	return 0;
 }
 
-static int snd_als4000_playback_close(snd_pcm_substream_t * substream)
+static int snd_als4000_playback_close(struct snd_pcm_substream *substream)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
 
 	chip->playback_substream = NULL;
 	snd_pcm_lib_free_pages(substream);
 	return 0;
 }
 
-static int snd_als4000_capture_open(snd_pcm_substream_t * substream)
+static int snd_als4000_capture_open(struct snd_pcm_substream *substream)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	chip->capture_substream = substream;
 	runtime->hw = snd_als4000_capture;
 	return 0;
 }
 
-static int snd_als4000_capture_close(snd_pcm_substream_t * substream)
+static int snd_als4000_capture_close(struct snd_pcm_substream *substream)
 {
-	sb_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_sb *chip = snd_pcm_substream_chip(substream);
 
 	chip->capture_substream = NULL;
 	snd_pcm_lib_free_pages(substream);
@@ -486,7 +486,7 @@ static int snd_als4000_capture_close(snd_pcm_substream_t * substream)
 
 /******************************************************************/
 
-static snd_pcm_ops_t snd_als4000_playback_ops = {
+static struct snd_pcm_ops snd_als4000_playback_ops = {
 	.open =		snd_als4000_playback_open,
 	.close =	snd_als4000_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -497,7 +497,7 @@ static snd_pcm_ops_t snd_als4000_playback_ops = {
 	.pointer =	snd_als4000_playback_pointer
 };
 
-static snd_pcm_ops_t snd_als4000_capture_ops = {
+static struct snd_pcm_ops snd_als4000_capture_ops = {
 	.open =		snd_als4000_capture_open,
 	.close =	snd_als4000_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -508,9 +508,9 @@ static snd_pcm_ops_t snd_als4000_capture_ops = {
 	.pointer =	snd_als4000_capture_pointer
 };
 
-static int __devinit snd_als4000_pcm(sb_t *chip, int device)
+static int __devinit snd_als4000_pcm(struct snd_sb *chip, int device)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if ((err = snd_pcm_new(chip->card, "ALS4000 DSP", device, 1, 1, &pcm)) < 0)
@@ -551,7 +551,7 @@ static void snd_als4000_set_addr(unsigned long gcr,
 	snd_als4000_gcr_write_addr(gcr, 0xa9, confB);
 }
 
-static void __devinit snd_als4000_configure(sb_t *chip)
+static void __devinit snd_als4000_configure(struct snd_sb *chip)
 {
 	unsigned tmp;
 	int i;
@@ -576,7 +576,7 @@ static void __devinit snd_als4000_configure(sb_t *chip)
 }
 
 #ifdef SUPPORT_JOYSTICK
-static int __devinit snd_als4000_create_gameport(snd_card_als4000_t *acard, int dev)
+static int __devinit snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev)
 {
 	struct gameport *gp;
 	struct resource *r;
@@ -622,7 +622,7 @@ static int __devinit snd_als4000_create_gameport(snd_card_als4000_t *acard, int
 	return 0;
 }
 
-static void snd_als4000_free_gameport(snd_card_als4000_t *acard)
+static void snd_als4000_free_gameport(struct snd_card_als4000 *acard)
 {
 	if (acard->gameport) {
 		struct resource *r = gameport_get_port_data(acard->gameport);
@@ -635,13 +635,13 @@ static void snd_als4000_free_gameport(snd_card_als4000_t *acard)
 	}
 }
 #else
-static inline int snd_als4000_create_gameport(snd_card_als4000_t *acard, int dev) { return -ENOSYS; }
-static inline void snd_als4000_free_gameport(snd_card_als4000_t *acard) { }
+static inline int snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev) { return -ENOSYS; }
+static inline void snd_als4000_free_gameport(struct snd_card_als4000 *acard) { }
 #endif
 
-static void snd_card_als4000_free( snd_card_t *card )
+static void snd_card_als4000_free( struct snd_card *card )
 {
-	snd_card_als4000_t * acard = (snd_card_als4000_t *)card->private_data;
+	struct snd_card_als4000 * acard = (struct snd_card_als4000 *)card->private_data;
 
 	/* make sure that interrupts are disabled */
 	snd_als4000_gcr_write_addr( acard->gcr, 0x8c, 0);
@@ -655,11 +655,11 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 					  const struct pci_device_id *pci_id)
 {
 	static int dev;
-	snd_card_t *card;
-	snd_card_als4000_t *acard;
+	struct snd_card *card;
+	struct snd_card_als4000 *acard;
 	unsigned long gcr;
-	sb_t *chip;
-	opl3_t *opl3;
+	struct snd_sb *chip;
+	struct snd_opl3 *opl3;
 	unsigned short word;
 	int err;
 
@@ -693,14 +693,14 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 	pci_set_master(pci);
 	
 	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 
-			    sizeof( snd_card_als4000_t ) );
+			    sizeof( struct snd_card_als4000 ) );
 	if (card == NULL) {
 		pci_release_regions(pci);
 		pci_disable_device(pci);
 		return -ENOMEM;
 	}
 
-	acard = (snd_card_als4000_t *)card->private_data;
+	acard = (struct snd_card_als4000 *)card->private_data;
 	acard->pci = pci;
 	acard->gcr = gcr;
 	card->private_free = snd_card_als4000_free;

commit ba7301c7d985d206a5688c69d0a74de3988f6d6c
Author: Andreas Mohr <andi@lisas.de>
Date:   Thu Nov 17 11:03:31 2005 +0100

    [ALSA] ALS4000 update
    
    Modules: SB drivers,ALS4000 driver
    
    some update for the ALS4000 driver (tested with hardware in my PC):
    
    - use common control names according to ControlNames.txt
    - add some controls (Master Mono, 3D control)
    - optimize struct snd_card_als4000_t layout (performance/size)
    - save some bytes via unified error path
    - constify some read-only data
    - add ToDo list
    - move GPL license text to top
    - add comments
    
    Signed-off-by: Andreas Mohr <andi@lisas.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index d496cc5ab35e..48b5175c59c0 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -6,6 +6,21 @@
  *
  *  Framework borrowed from Massimo Piccioni's card-als100.c.
  *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
  * NOTES
  *
  *  Since Avance does not provide any meaningful documentation, and I
@@ -43,19 +58,9 @@
  * Set KSound:
  * - value -> some port 0x0c0d
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
-
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ * ToDo:
+ * - Proper shared IRQ handling?
+ * - power management? (card can do voice wakeup according to datasheet!!)
  */
 
 #include <sound/driver.h>
@@ -101,8 +106,9 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address for ALS4000 soundcard. (0
 #endif
 
 typedef struct {
-	struct pci_dev *pci;
+	/* most frequent access first */
 	unsigned long gcr;
+	struct pci_dev *pci;
 #ifdef SUPPORT_JOYSTICK
 	struct gameport *gameport;
 #endif
@@ -146,13 +152,13 @@ static void snd_als4000_set_rate(sb_t *chip, unsigned int rate)
 	}
 }
 
-static void snd_als4000_set_capture_dma(sb_t *chip, dma_addr_t addr, unsigned size)
+static inline void snd_als4000_set_capture_dma(sb_t *chip, dma_addr_t addr, unsigned size)
 {
 	snd_als4000_gcr_write(chip, 0xa2, addr);
 	snd_als4000_gcr_write(chip, 0xa3, (size-1));
 }
 
-static void snd_als4000_set_playback_dma(sb_t *chip, dma_addr_t addr, unsigned size)
+static inline void snd_als4000_set_playback_dma(sb_t *chip, dma_addr_t addr, unsigned size)
 {
 	snd_als4000_gcr_write(chip, 0x91, addr);
 	snd_als4000_gcr_write(chip, 0x92, (size-1)|0x180000);
@@ -177,7 +183,7 @@ static int snd_als4000_get_format(snd_pcm_runtime_t *runtime)
 }
 
 /* structure for setting up playback */
-static struct {
+static const struct {
 	unsigned char dsp_cmd, dma_on, dma_off, format;
 } playback_cmd_vals[]={
 /* ALS4000_FORMAT_U8_MONO */
@@ -201,7 +207,7 @@ static struct {
 
 /* structure for setting up capture */
 enum { CMD_WIDTH8=0x04, CMD_SIGNED=0x10, CMD_MONO=0x80, CMD_STEREO=0xA0 };
-static unsigned char capture_cmd_vals[]=
+static const unsigned char capture_cmd_vals[]=
 {
 CMD_WIDTH8|CMD_MONO,			/* ALS4000_FORMAT_U8_MONO */
 CMD_WIDTH8|CMD_SIGNED|CMD_MONO,		/* ALS4000_FORMAT_S8_MONO */	
@@ -228,9 +234,9 @@ static int snd_als4000_hw_free(snd_pcm_substream_t * substream)
 
 static int snd_als4000_capture_prepare(snd_pcm_substream_t * substream)
 {
-	unsigned long flags;
 	sb_t *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long flags;
 	unsigned long size;
 	unsigned count;
 
@@ -256,9 +262,9 @@ static int snd_als4000_capture_prepare(snd_pcm_substream_t * substream)
 
 static int snd_als4000_playback_prepare(snd_pcm_substream_t *substream)
 {
-	unsigned long flags;
 	sb_t *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long flags;
 	unsigned long size;
 	unsigned count;
 
@@ -353,6 +359,18 @@ static snd_pcm_uframes_t snd_als4000_playback_pointer(snd_pcm_substream_t * subs
 	return bytes_to_frames( substream->runtime, result );
 }
 
+/* FIXME: this IRQ routine doesn't really support IRQ sharing (we always
+ * return IRQ_HANDLED no matter whether we actually had an IRQ flag or not).
+ * ALS4000a.PDF writes that while ACKing IRQ in PCI block will *not* ACK
+ * the IRQ in the SB core, ACKing IRQ in SB block *will* ACK the PCI IRQ
+ * register (alt_port + 0x0e). Probably something could be optimized here to
+ * query/write one register only...
+ * And even if both registers need to be queried, then there's still the
+ * question of whether it's actually correct to ACK PCI IRQ before reading
+ * SB IRQ like we do now, since ALS4000a.PDF mentions that PCI IRQ will *clear*
+ * SB IRQ status.
+ * And do we *really* need the lock here for *reading* SB_DSP4_IRQSTATUS??
+ * */
 static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	sb_t *chip = dev_id;
@@ -698,8 +716,7 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 				    -1,
 				    SB_HW_ALS4000,
 				    &chip)) < 0) {
-		snd_card_free(card);
-		return err;
+		goto out_err;
 	}
 
 	chip->pci = pci;
@@ -716,40 +733,42 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 	if ((err = snd_mpu401_uart_new( card, 0, MPU401_HW_ALS4000,
 				        gcr+0x30, 1, pci->irq, 0,
 				        &chip->rmidi)) < 0) {
-		snd_card_free(card);
-		printk(KERN_ERR "als4000: no MPU-401device at 0x%lx ?\n", gcr+0x30);
-		return err;
+		printk(KERN_ERR "als4000: no MPU-401 device at 0x%lx?\n", gcr+0x30);
+		goto out_err;
 	}
 
 	if ((err = snd_als4000_pcm(chip, 0)) < 0) {
-		snd_card_free(card);
-		return err;
+		goto out_err;
 	}
 	if ((err = snd_sbmixer_new(chip)) < 0) {
-		snd_card_free(card);
-		return err;
+		goto out_err;
 	}	    
 
 	if (snd_opl3_create(card, gcr+0x10, gcr+0x12,
 			    OPL3_HW_AUTO, 1, &opl3) < 0) {
-		printk(KERN_ERR "als4000: no OPL device at 0x%lx-0x%lx ?\n",
+		printk(KERN_ERR "als4000: no OPL device at 0x%lx-0x%lx?\n",
 			   gcr+0x10, gcr+0x12 );
 	} else {
 		if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
-			snd_card_free(card);
-			return err;
+			goto out_err;
 		}
 	}
 
 	snd_als4000_create_gameport(acard, dev);
 
 	if ((err = snd_card_register(card)) < 0) {
-		snd_card_free(card);
-		return err;
+		goto out_err;
 	}
 	pci_set_drvdata(pci, card);
 	dev++;
-	return 0;
+	err = 0;
+	goto out;
+
+out_err:
+	snd_card_free(card);
+	
+out:
+	return err;
 }
 
 static void __devexit snd_card_als4000_remove(struct pci_dev *pci)

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 1904df650265..d496cc5ab35e 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -490,13 +490,6 @@ static snd_pcm_ops_t snd_als4000_capture_ops = {
 	.pointer =	snd_als4000_capture_pointer
 };
 
-static void snd_als4000_pcm_free(snd_pcm_t *pcm)
-{
-	sb_t *chip = pcm->private_data;
-	chip->pcm = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static int __devinit snd_als4000_pcm(sb_t *chip, int device)
 {
 	snd_pcm_t *pcm;
@@ -504,7 +497,6 @@ static int __devinit snd_als4000_pcm(sb_t *chip, int device)
 
 	if ((err = snd_pcm_new(chip->card, "ALS4000 DSP", device, 1, 1, &pcm)) < 0)
 		return err;
-	pcm->private_free = snd_als4000_pcm_free;
 	pcm->private_data = chip;
 	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_als4000_playback_ops);

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 7c61561f297f..1904df650265 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -768,7 +768,6 @@ static void __devexit snd_card_als4000_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "ALS4000",
-	.owner = THIS_MODULE,
 	.id_table = snd_als4000_ids,
 	.probe = snd_card_als4000_probe,
 	.remove = __devexit_p(snd_card_als4000_remove),

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 8a32cd92f62a..7c61561f297f 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -667,7 +667,7 @@ static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
 	if (pci_set_dma_mask(pci, 0x00ffffff) < 0 ||
 	    pci_set_consistent_dma_mask(pci, 0x00ffffff) < 0) {
-		snd_printk("architecture does not support 24bit PCI busmaster DMA\n");
+		snd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index 196ec1c61bb4..8a32cd92f62a 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -594,8 +594,7 @@ static int __devinit snd_als4000_create_gameport(snd_card_als4000_t *acard, int
 	acard->gameport = gp = gameport_allocate_port();
 	if (!gp) {
 		printk(KERN_ERR "als4000: cannot allocate memory for gameport\n");
-		release_resource(r);
-		kfree_nocheck(r);
+		release_and_free_resource(r);
 		return -ENOMEM;
 	}
 
@@ -622,8 +621,7 @@ static void snd_als4000_free_gameport(snd_card_als4000_t *acard)
 		acard->gameport = NULL;
 
 		snd_als4000_set_addr(acard->gcr, 0, 0, 0, 0); /* disable joystick */
-		release_resource(r);
-		kfree_nocheck(r);
+		release_and_free_resource(r);
 	}
 }
 #else

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index ca28b229c704..196ec1c61bb4 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -770,6 +770,7 @@ static void __devexit snd_card_als4000_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "ALS4000",
+	.owner = THIS_MODULE,
 	.id_table = snd_als4000_ids,
 	.probe = snd_card_als4000_probe,
 	.remove = __devexit_p(snd_card_als4000_remove),

commit 11ca9afcfee3e6667a498b702642b09ac7312a8a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 27 11:34:34 2005 +0200

    [ALSA] als4000 - Fix kernel panic with MPU401
    
    ALS4000 driver
    Fix kernel panic with als4000 when MPU401 is accessed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index cdc1134cdedd..ca28b229c704 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -367,7 +367,7 @@ static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id, struct pt_regs *
 	if ((gcr_status & 0x40) && (chip->capture_substream)) /* capturing */
 		snd_pcm_period_elapsed(chip->capture_substream);
 	if ((gcr_status & 0x10) && (chip->rmidi)) /* MPU401 interrupt */
-		snd_mpu401_uart_interrupt(irq, chip->rmidi, regs);
+		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
 	/* release the gcr */
 	outb(gcr_status, chip->alt_port + 0xe);
 	

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index f1a5f5723ee6..cdc1134cdedd 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -777,7 +777,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_als4000_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_als4000_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
new file mode 100644
index 000000000000..f1a5f5723ee6
--- /dev/null
+++ b/sound/pci/als4000.c
@@ -0,0 +1,789 @@
+/*
+ *  card-als4000.c - driver for Avance Logic ALS4000 based soundcards.
+ *  Copyright (C) 2000 by Bart Hartgers <bart@etpmod.phys.tue.nl>,
+ *			  Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (C) 2002 by Andreas Mohr <hw7oshyuv3001@sneakemail.com>
+ *
+ *  Framework borrowed from Massimo Piccioni's card-als100.c.
+ *
+ * NOTES
+ *
+ *  Since Avance does not provide any meaningful documentation, and I
+ *  bought an ALS4000 based soundcard, I was forced to base this driver
+ *  on reverse engineering.
+ *
+ *  Note: this is no longer true. Pretty verbose chip docu (ALS4000a.PDF)
+ *  can be found on the ALSA web site.
+ *
+ *  The ALS4000 seems to be the PCI-cousin of the ALS100. It contains an
+ *  ALS100-like SB DSP/mixer, an OPL3 synth, a MPU401 and a gameport 
+ *  interface. These subsystems can be mapped into ISA io-port space, 
+ *  using the PCI-interface. In addition, the PCI-bit provides DMA and IRQ 
+ *  services to the subsystems.
+ * 
+ * While ALS4000 is very similar to a SoundBlaster, the differences in
+ * DMA and capturing require more changes to the SoundBlaster than
+ * desirable, so I made this separate driver.
+ * 
+ * The ALS4000 can do real full duplex playback/capture.
+ *
+ * FMDAC:
+ * - 0x4f -> port 0x14
+ * - port 0x15 |= 1
+ *
+ * Enable/disable 3D sound:
+ * - 0x50 -> port 0x14
+ * - change bit 6 (0x40) of port 0x15
+ *
+ * Set QSound:
+ * - 0xdb -> port 0x14
+ * - set port 0x15:
+ *   0x3e (mode 3), 0x3c (mode 2), 0x3a (mode 1), 0x38 (mode 0)
+ *
+ * Set KSound:
+ * - value -> some port 0x0c0d
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/rawmidi.h>
+#include <sound/mpu401.h>
+#include <sound/opl3.h>
+#include <sound/sb.h>
+#include <sound/initval.h>
+
+MODULE_AUTHOR("Bart Hartgers <bart@etpmod.phys.tue.nl>");
+MODULE_DESCRIPTION("Avance Logic ALS4000");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Avance Logic,ALS4000}}");
+
+#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#define SUPPORT_JOYSTICK 1
+#endif
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+#ifdef SUPPORT_JOYSTICK
+static int joystick_port[SNDRV_CARDS];
+#endif
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for ALS4000 soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for ALS4000 soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable ALS4000 soundcard.");
+#ifdef SUPPORT_JOYSTICK
+module_param_array(joystick_port, int, NULL, 0444);
+MODULE_PARM_DESC(joystick_port, "Joystick port address for ALS4000 soundcard. (0 = disabled)");
+#endif
+
+typedef struct {
+	struct pci_dev *pci;
+	unsigned long gcr;
+#ifdef SUPPORT_JOYSTICK
+	struct gameport *gameport;
+#endif
+} snd_card_als4000_t;
+
+static struct pci_device_id snd_als4000_ids[] = {
+	{ 0x4005, 0x4000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },   /* ALS4000 */
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_als4000_ids);
+
+static inline void snd_als4000_gcr_write_addr(unsigned long port, u32 reg, u32 val)
+{
+	outb(reg, port+0x0c);
+	outl(val, port+0x08);
+}
+
+static inline void snd_als4000_gcr_write(sb_t *sb, u32 reg, u32 val)
+{
+	snd_als4000_gcr_write_addr(sb->alt_port, reg, val);
+}	
+
+static inline u32 snd_als4000_gcr_read_addr(unsigned long port, u32 reg)
+{
+	outb(reg, port+0x0c);
+	return inl(port+0x08);
+}
+
+static inline u32 snd_als4000_gcr_read(sb_t *sb, u32 reg)
+{
+	return snd_als4000_gcr_read_addr(sb->alt_port, reg);
+}
+
+static void snd_als4000_set_rate(sb_t *chip, unsigned int rate)
+{
+	if (!(chip->mode & SB_RATE_LOCK)) {
+		snd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE_OUT);
+		snd_sbdsp_command(chip, rate>>8);
+		snd_sbdsp_command(chip, rate);
+	}
+}
+
+static void snd_als4000_set_capture_dma(sb_t *chip, dma_addr_t addr, unsigned size)
+{
+	snd_als4000_gcr_write(chip, 0xa2, addr);
+	snd_als4000_gcr_write(chip, 0xa3, (size-1));
+}
+
+static void snd_als4000_set_playback_dma(sb_t *chip, dma_addr_t addr, unsigned size)
+{
+	snd_als4000_gcr_write(chip, 0x91, addr);
+	snd_als4000_gcr_write(chip, 0x92, (size-1)|0x180000);
+}
+
+#define ALS4000_FORMAT_SIGNED	(1<<0)
+#define ALS4000_FORMAT_16BIT	(1<<1)
+#define ALS4000_FORMAT_STEREO	(1<<2)
+
+static int snd_als4000_get_format(snd_pcm_runtime_t *runtime)
+{
+	int result;
+
+	result = 0;
+	if (snd_pcm_format_signed(runtime->format))
+		result |= ALS4000_FORMAT_SIGNED;
+	if (snd_pcm_format_physical_width(runtime->format) == 16)
+		result |= ALS4000_FORMAT_16BIT;
+	if (runtime->channels > 1)
+		result |= ALS4000_FORMAT_STEREO;
+	return result;
+}
+
+/* structure for setting up playback */
+static struct {
+	unsigned char dsp_cmd, dma_on, dma_off, format;
+} playback_cmd_vals[]={
+/* ALS4000_FORMAT_U8_MONO */
+{ SB_DSP4_OUT8_AI, SB_DSP_DMA8_ON, SB_DSP_DMA8_OFF, SB_DSP4_MODE_UNS_MONO },
+/* ALS4000_FORMAT_S8_MONO */	
+{ SB_DSP4_OUT8_AI, SB_DSP_DMA8_ON, SB_DSP_DMA8_OFF, SB_DSP4_MODE_SIGN_MONO },
+/* ALS4000_FORMAT_U16L_MONO */
+{ SB_DSP4_OUT16_AI, SB_DSP_DMA16_ON, SB_DSP_DMA16_OFF, SB_DSP4_MODE_UNS_MONO },
+/* ALS4000_FORMAT_S16L_MONO */
+{ SB_DSP4_OUT16_AI, SB_DSP_DMA16_ON, SB_DSP_DMA16_OFF, SB_DSP4_MODE_SIGN_MONO },
+/* ALS4000_FORMAT_U8_STEREO */
+{ SB_DSP4_OUT8_AI, SB_DSP_DMA8_ON, SB_DSP_DMA8_OFF, SB_DSP4_MODE_UNS_STEREO },
+/* ALS4000_FORMAT_S8_STEREO */	
+{ SB_DSP4_OUT8_AI, SB_DSP_DMA8_ON, SB_DSP_DMA8_OFF, SB_DSP4_MODE_SIGN_STEREO },
+/* ALS4000_FORMAT_U16L_STEREO */
+{ SB_DSP4_OUT16_AI, SB_DSP_DMA16_ON, SB_DSP_DMA16_OFF, SB_DSP4_MODE_UNS_STEREO },
+/* ALS4000_FORMAT_S16L_STEREO */
+{ SB_DSP4_OUT16_AI, SB_DSP_DMA16_ON, SB_DSP_DMA16_OFF, SB_DSP4_MODE_SIGN_STEREO },
+};
+#define playback_cmd(chip) (playback_cmd_vals[(chip)->playback_format])
+
+/* structure for setting up capture */
+enum { CMD_WIDTH8=0x04, CMD_SIGNED=0x10, CMD_MONO=0x80, CMD_STEREO=0xA0 };
+static unsigned char capture_cmd_vals[]=
+{
+CMD_WIDTH8|CMD_MONO,			/* ALS4000_FORMAT_U8_MONO */
+CMD_WIDTH8|CMD_SIGNED|CMD_MONO,		/* ALS4000_FORMAT_S8_MONO */	
+CMD_MONO,				/* ALS4000_FORMAT_U16L_MONO */
+CMD_SIGNED|CMD_MONO,			/* ALS4000_FORMAT_S16L_MONO */
+CMD_WIDTH8|CMD_STEREO,			/* ALS4000_FORMAT_U8_STEREO */
+CMD_WIDTH8|CMD_SIGNED|CMD_STEREO,	/* ALS4000_FORMAT_S8_STEREO */	
+CMD_STEREO,				/* ALS4000_FORMAT_U16L_STEREO */
+CMD_SIGNED|CMD_STEREO,			/* ALS4000_FORMAT_S16L_STEREO */
+};	
+#define capture_cmd(chip) (capture_cmd_vals[(chip)->capture_format])
+
+static int snd_als4000_hw_params(snd_pcm_substream_t * substream,
+				 snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int snd_als4000_hw_free(snd_pcm_substream_t * substream)
+{
+	snd_pcm_lib_free_pages(substream);
+	return 0;
+}
+
+static int snd_als4000_capture_prepare(snd_pcm_substream_t * substream)
+{
+	unsigned long flags;
+	sb_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long size;
+	unsigned count;
+
+	chip->capture_format = snd_als4000_get_format(runtime);
+		
+	size = snd_pcm_lib_buffer_bytes(substream);
+	count = snd_pcm_lib_period_bytes(substream);
+	
+	if (chip->capture_format & ALS4000_FORMAT_16BIT)
+		count >>=1;
+	count--;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	snd_als4000_set_rate(chip, runtime->rate);
+	snd_als4000_set_capture_dma(chip, runtime->dma_addr, size);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	spin_lock_irqsave(&chip->mixer_lock, flags );
+	snd_sbmixer_write(chip, 0xdc, count);
+	snd_sbmixer_write(chip, 0xdd, count>>8);
+	spin_unlock_irqrestore(&chip->mixer_lock, flags );
+	return 0;
+}
+
+static int snd_als4000_playback_prepare(snd_pcm_substream_t *substream)
+{
+	unsigned long flags;
+	sb_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long size;
+	unsigned count;
+
+	chip->playback_format = snd_als4000_get_format(runtime);
+	
+	size = snd_pcm_lib_buffer_bytes(substream);
+	count = snd_pcm_lib_period_bytes(substream);
+	
+	if (chip->playback_format & ALS4000_FORMAT_16BIT)
+		count >>=1;
+	count--;
+	
+	/* FIXME: from second playback on, there's a lot more clicks and pops
+	 * involved here than on first playback. Fiddling with
+	 * tons of different settings didn't help (DMA, speaker on/off,
+	 * reordering, ...). Something seems to get enabled on playback
+	 * that I haven't found out how to disable again, which then causes
+	 * the switching pops to reach the speakers the next time here. */
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	snd_als4000_set_rate(chip, runtime->rate);
+	snd_als4000_set_playback_dma(chip, runtime->dma_addr, size);
+	
+	/* SPEAKER_ON not needed, since dma_on seems to also enable speaker */
+	/* snd_sbdsp_command(chip, SB_DSP_SPEAKER_ON); */
+	snd_sbdsp_command(chip, playback_cmd(chip).dsp_cmd);
+	snd_sbdsp_command(chip, playback_cmd(chip).format);
+	snd_sbdsp_command(chip, count);
+	snd_sbdsp_command(chip, count>>8);
+	snd_sbdsp_command(chip, playback_cmd(chip).dma_off);	
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	
+	return 0;
+}
+
+static int snd_als4000_capture_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	sb_t *chip = snd_pcm_substream_chip(substream);
+	int result = 0;
+	
+	spin_lock(&chip->mixer_lock);
+	if (cmd == SNDRV_PCM_TRIGGER_START) {
+		chip->mode |= SB_RATE_LOCK_CAPTURE;
+		snd_sbmixer_write(chip, 0xde, capture_cmd(chip));
+	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+		chip->mode &= ~SB_RATE_LOCK_CAPTURE;
+		snd_sbmixer_write(chip, 0xde, 0);
+	} else {
+		result = -EINVAL;
+	}
+	spin_unlock(&chip->mixer_lock);
+	return result;
+}
+
+static int snd_als4000_playback_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	sb_t *chip = snd_pcm_substream_chip(substream);
+	int result = 0;
+
+	spin_lock(&chip->reg_lock);
+	if (cmd == SNDRV_PCM_TRIGGER_START) {
+		chip->mode |= SB_RATE_LOCK_PLAYBACK;
+		snd_sbdsp_command(chip, playback_cmd(chip).dma_on);
+	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+		snd_sbdsp_command(chip, playback_cmd(chip).dma_off);
+		chip->mode &= ~SB_RATE_LOCK_PLAYBACK;
+	} else {
+		result = -EINVAL;
+	}
+	spin_unlock(&chip->reg_lock);
+	return result;
+}
+
+static snd_pcm_uframes_t snd_als4000_capture_pointer(snd_pcm_substream_t * substream)
+{
+	sb_t *chip = snd_pcm_substream_chip(substream);
+	unsigned int result;
+
+	spin_lock(&chip->reg_lock);	
+	result = snd_als4000_gcr_read(chip, 0xa4) & 0xffff;
+	spin_unlock(&chip->reg_lock);
+	return bytes_to_frames( substream->runtime, result );
+}
+
+static snd_pcm_uframes_t snd_als4000_playback_pointer(snd_pcm_substream_t * substream)
+{
+	sb_t *chip = snd_pcm_substream_chip(substream);
+	unsigned result;
+
+	spin_lock(&chip->reg_lock);	
+	result = snd_als4000_gcr_read(chip, 0xa0) & 0xffff;
+	spin_unlock(&chip->reg_lock);
+	return bytes_to_frames( substream->runtime, result );
+}
+
+static irqreturn_t snd_als4000_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	sb_t *chip = dev_id;
+	unsigned gcr_status;
+	unsigned sb_status;
+
+	/* find out which bit of the ALS4000 produced the interrupt */
+	gcr_status = inb(chip->alt_port + 0xe);
+
+	if ((gcr_status & 0x80) && (chip->playback_substream)) /* playback */
+		snd_pcm_period_elapsed(chip->playback_substream);
+	if ((gcr_status & 0x40) && (chip->capture_substream)) /* capturing */
+		snd_pcm_period_elapsed(chip->capture_substream);
+	if ((gcr_status & 0x10) && (chip->rmidi)) /* MPU401 interrupt */
+		snd_mpu401_uart_interrupt(irq, chip->rmidi, regs);
+	/* release the gcr */
+	outb(gcr_status, chip->alt_port + 0xe);
+	
+	spin_lock(&chip->mixer_lock);
+	sb_status = snd_sbmixer_read(chip, SB_DSP4_IRQSTATUS);
+	spin_unlock(&chip->mixer_lock);
+	
+	if (sb_status & SB_IRQTYPE_8BIT) 
+		snd_sb_ack_8bit(chip);
+	if (sb_status & SB_IRQTYPE_16BIT) 
+		snd_sb_ack_16bit(chip);
+	if (sb_status & SB_IRQTYPE_MPUIN)
+		inb(chip->mpu_port);
+	if (sb_status & 0x20)
+		inb(SBP(chip, RESET));
+	return IRQ_HANDLED;
+}
+
+/*****************************************************************/
+
+static snd_pcm_hardware_t snd_als4000_playback =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |
+				SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE,	/* formats */
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	65536,
+	.period_bytes_min =	64,
+	.period_bytes_max =	65536,
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0
+};
+
+static snd_pcm_hardware_t snd_als4000_capture =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |
+				SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE,	/* formats */
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	65536,
+	.period_bytes_min =	64,
+	.period_bytes_max =	65536,
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0
+};
+
+/*****************************************************************/
+
+static int snd_als4000_playback_open(snd_pcm_substream_t * substream)
+{
+	sb_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	chip->playback_substream = substream;
+	runtime->hw = snd_als4000_playback;
+	return 0;
+}
+
+static int snd_als4000_playback_close(snd_pcm_substream_t * substream)
+{
+	sb_t *chip = snd_pcm_substream_chip(substream);
+
+	chip->playback_substream = NULL;
+	snd_pcm_lib_free_pages(substream);
+	return 0;
+}
+
+static int snd_als4000_capture_open(snd_pcm_substream_t * substream)
+{
+	sb_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	chip->capture_substream = substream;
+	runtime->hw = snd_als4000_capture;
+	return 0;
+}
+
+static int snd_als4000_capture_close(snd_pcm_substream_t * substream)
+{
+	sb_t *chip = snd_pcm_substream_chip(substream);
+
+	chip->capture_substream = NULL;
+	snd_pcm_lib_free_pages(substream);
+	return 0;
+}
+
+/******************************************************************/
+
+static snd_pcm_ops_t snd_als4000_playback_ops = {
+	.open =		snd_als4000_playback_open,
+	.close =	snd_als4000_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_als4000_hw_params,
+	.hw_free =	snd_als4000_hw_free,
+	.prepare =	snd_als4000_playback_prepare,
+	.trigger =	snd_als4000_playback_trigger,
+	.pointer =	snd_als4000_playback_pointer
+};
+
+static snd_pcm_ops_t snd_als4000_capture_ops = {
+	.open =		snd_als4000_capture_open,
+	.close =	snd_als4000_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_als4000_hw_params,
+	.hw_free =	snd_als4000_hw_free,
+	.prepare =	snd_als4000_capture_prepare,
+	.trigger =	snd_als4000_capture_trigger,
+	.pointer =	snd_als4000_capture_pointer
+};
+
+static void snd_als4000_pcm_free(snd_pcm_t *pcm)
+{
+	sb_t *chip = pcm->private_data;
+	chip->pcm = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __devinit snd_als4000_pcm(sb_t *chip, int device)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if ((err = snd_pcm_new(chip->card, "ALS4000 DSP", device, 1, 1, &pcm)) < 0)
+		return err;
+	pcm->private_free = snd_als4000_pcm_free;
+	pcm->private_data = chip;
+	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_als4000_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_als4000_capture_ops);
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
+					      64*1024, 64*1024);
+
+	chip->pcm = pcm;
+
+	return 0;
+}
+
+/******************************************************************/
+
+static void snd_als4000_set_addr(unsigned long gcr,
+					unsigned int sb,
+					unsigned int mpu,
+					unsigned int opl,
+					unsigned int game)
+{
+	u32 confA = 0;
+	u32 confB = 0;
+
+	if (mpu > 0)
+		confB |= (mpu | 1) << 16;
+	if (sb > 0)
+		confB |= (sb | 1);
+	if (game > 0)
+		confA |= (game | 1) << 16;
+	if (opl > 0)	
+		confA |= (opl | 1);
+	snd_als4000_gcr_write_addr(gcr, 0xa8, confA);
+	snd_als4000_gcr_write_addr(gcr, 0xa9, confB);
+}
+
+static void __devinit snd_als4000_configure(sb_t *chip)
+{
+	unsigned tmp;
+	int i;
+
+	/* do some more configuration */
+	spin_lock_irq(&chip->mixer_lock);
+	tmp = snd_sbmixer_read(chip, 0xc0);
+	snd_sbmixer_write(chip, 0xc0, tmp|0x80);
+	/* always select DMA channel 0, since we do not actually use DMA */
+	snd_sbmixer_write(chip, SB_DSP4_DMASETUP, SB_DMASETUP_DMA0);
+	snd_sbmixer_write(chip, 0xc0, tmp&0x7f);
+	spin_unlock_irq(&chip->mixer_lock);
+	
+	spin_lock_irq(&chip->reg_lock);
+	/* magic number. Enables interrupts(?) */
+	snd_als4000_gcr_write(chip, 0x8c, 0x28000);
+	for(i = 0x91; i <= 0x96; ++i)
+		snd_als4000_gcr_write(chip, i, 0);
+	
+	snd_als4000_gcr_write(chip, 0x99, snd_als4000_gcr_read(chip, 0x99));
+	spin_unlock_irq(&chip->reg_lock);
+}
+
+#ifdef SUPPORT_JOYSTICK
+static int __devinit snd_als4000_create_gameport(snd_card_als4000_t *acard, int dev)
+{
+	struct gameport *gp;
+	struct resource *r;
+	int io_port;
+
+	if (joystick_port[dev] == 0)
+		return -ENODEV;
+
+	if (joystick_port[dev] == 1) { /* auto-detect */
+		for (io_port = 0x200; io_port <= 0x218; io_port += 8) {
+			r = request_region(io_port, 8, "ALS4000 gameport");
+			if (r)
+				break;
+		}
+	} else {
+		io_port = joystick_port[dev];
+		r = request_region(io_port, 8, "ALS4000 gameport");
+	}
+
+	if (!r) {
+		printk(KERN_WARNING "als4000: cannot reserve joystick ports\n");
+		return -EBUSY;
+	}
+
+	acard->gameport = gp = gameport_allocate_port();
+	if (!gp) {
+		printk(KERN_ERR "als4000: cannot allocate memory for gameport\n");
+		release_resource(r);
+		kfree_nocheck(r);
+		return -ENOMEM;
+	}
+
+	gameport_set_name(gp, "ALS4000 Gameport");
+	gameport_set_phys(gp, "pci%s/gameport0", pci_name(acard->pci));
+	gameport_set_dev_parent(gp, &acard->pci->dev);
+	gp->io = io_port;
+	gameport_set_port_data(gp, r);
+
+	/* Enable legacy joystick port */
+	snd_als4000_set_addr(acard->gcr, 0, 0, 0, 1);
+
+	gameport_register_port(acard->gameport);
+
+	return 0;
+}
+
+static void snd_als4000_free_gameport(snd_card_als4000_t *acard)
+{
+	if (acard->gameport) {
+		struct resource *r = gameport_get_port_data(acard->gameport);
+
+		gameport_unregister_port(acard->gameport);
+		acard->gameport = NULL;
+
+		snd_als4000_set_addr(acard->gcr, 0, 0, 0, 0); /* disable joystick */
+		release_resource(r);
+		kfree_nocheck(r);
+	}
+}
+#else
+static inline int snd_als4000_create_gameport(snd_card_als4000_t *acard, int dev) { return -ENOSYS; }
+static inline void snd_als4000_free_gameport(snd_card_als4000_t *acard) { }
+#endif
+
+static void snd_card_als4000_free( snd_card_t *card )
+{
+	snd_card_als4000_t * acard = (snd_card_als4000_t *)card->private_data;
+
+	/* make sure that interrupts are disabled */
+	snd_als4000_gcr_write_addr( acard->gcr, 0x8c, 0);
+	/* free resources */
+	snd_als4000_free_gameport(acard);
+	pci_release_regions(acard->pci);
+	pci_disable_device(acard->pci);
+}
+
+static int __devinit snd_card_als4000_probe(struct pci_dev *pci,
+					  const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	snd_card_als4000_t *acard;
+	unsigned long gcr;
+	sb_t *chip;
+	opl3_t *opl3;
+	unsigned short word;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	/* enable PCI device */
+	if ((err = pci_enable_device(pci)) < 0) {
+		return err;
+	}
+	/* check, if we can restrict PCI DMA transfers to 24 bits */
+	if (pci_set_dma_mask(pci, 0x00ffffff) < 0 ||
+	    pci_set_consistent_dma_mask(pci, 0x00ffffff) < 0) {
+		snd_printk("architecture does not support 24bit PCI busmaster DMA\n");
+		pci_disable_device(pci);
+		return -ENXIO;
+	}
+
+	if ((err = pci_request_regions(pci, "ALS4000")) < 0) {
+		pci_disable_device(pci);
+		return err;
+	}
+	gcr = pci_resource_start(pci, 0);
+
+	pci_read_config_word(pci, PCI_COMMAND, &word);
+	pci_write_config_word(pci, PCI_COMMAND, word | PCI_COMMAND_IO);
+	pci_set_master(pci);
+	
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 
+			    sizeof( snd_card_als4000_t ) );
+	if (card == NULL) {
+		pci_release_regions(pci);
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	acard = (snd_card_als4000_t *)card->private_data;
+	acard->pci = pci;
+	acard->gcr = gcr;
+	card->private_free = snd_card_als4000_free;
+
+	/* disable all legacy ISA stuff */
+	snd_als4000_set_addr(acard->gcr, 0, 0, 0, 0);
+
+	if ((err = snd_sbdsp_create(card,
+				    gcr + 0x10,
+				    pci->irq,
+				    snd_als4000_interrupt,
+				    -1,
+				    -1,
+				    SB_HW_ALS4000,
+				    &chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	chip->pci = pci;
+	chip->alt_port = gcr;
+	snd_card_set_dev(card, &pci->dev);
+
+	snd_als4000_configure(chip);
+
+	strcpy(card->driver, "ALS4000");
+	strcpy(card->shortname, "Avance Logic ALS4000");
+	sprintf(card->longname, "%s at 0x%lx, irq %i",
+		card->shortname, chip->alt_port, chip->irq);
+
+	if ((err = snd_mpu401_uart_new( card, 0, MPU401_HW_ALS4000,
+				        gcr+0x30, 1, pci->irq, 0,
+				        &chip->rmidi)) < 0) {
+		snd_card_free(card);
+		printk(KERN_ERR "als4000: no MPU-401device at 0x%lx ?\n", gcr+0x30);
+		return err;
+	}
+
+	if ((err = snd_als4000_pcm(chip, 0)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_sbmixer_new(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}	    
+
+	if (snd_opl3_create(card, gcr+0x10, gcr+0x12,
+			    OPL3_HW_AUTO, 1, &opl3) < 0) {
+		printk(KERN_ERR "als4000: no OPL device at 0x%lx-0x%lx ?\n",
+			   gcr+0x10, gcr+0x12 );
+	} else {
+		if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
+			snd_card_free(card);
+			return err;
+		}
+	}
+
+	snd_als4000_create_gameport(acard, dev);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_card_als4000_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "ALS4000",
+	.id_table = snd_als4000_ids,
+	.probe = snd_card_als4000_probe,
+	.remove = __devexit_p(snd_card_als4000_remove),
+};
+
+static int __init alsa_card_als4000_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_als4000_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_als4000_init)
+module_exit(alsa_card_als4000_exit)
