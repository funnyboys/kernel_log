commit 60019d8c650d20a7363285f88f4177dd48d029a7
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Mon May 4 13:46:16 2020 +0530

    ALSA: hda/tegra: workaround playback failure on Tegra194
    
    Tegra194 has 4 SDO lines and with this configuration playback fails
    for 44.1K/48K, 2-channel and 16-bps. It results in below print,
      "aplay: pcm_write:2011: write error: Input/output error"
    
    Below relation is used to derive stripe control and is referenced
    from HD Audio Specification: Revision 1.0a.
      { ((num_channels * bits_per_sample) / number of SDOs) >= 8 }
    
    Due to a legacy HW design problem, playback issue is hit while using
    a stripe value resulting from above formula when ratio is '8'. Thus
    it is recommended that the ratio must be greater than '8'. Since the
    number of SDO lines is in powers of 2, next available ratio '16' is
    used as a limiting factor on Tegra194 to workaround the problem.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Link: https://lore.kernel.org/r/1588580176-2801-4-git-send-email-spujar@nvidia.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 45dc54485f24..0cc5fad1af8a 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -364,6 +364,23 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 	/* initialize chip */
 	azx_init_chip(chip, 1);
 
+	/*
+	 * Playback (for 44.1K/48K, 2-channel, 16-bps) fails with
+	 * 4 SDO lines due to legacy design limitation. Following
+	 * is, from HD Audio Specification (Revision 1.0a), used to
+	 * control striping of the stream across multiple SDO lines
+	 * for sample rates <= 48K.
+	 *
+	 * { ((num_channels * bits_per_sample) / number of SDOs) >= 8 }
+	 *
+	 * Due to legacy design issue it is recommended that above
+	 * ratio must be greater than 8. Since number of SDO lines is
+	 * in powers of 2, next available ratio is 16 which can be
+	 * used as a limiting factor here.
+	 */
+	if (of_device_is_compatible(np, "nvidia,tegra194-hda"))
+		chip->bus.core.sdo_limit = 16;
+
 	/* codec detection */
 	if (!bus->codec_mask) {
 		dev_err(card->dev, "no codecs found!\n");

commit bb9b02a4589cee66cdb92eb9b7191d6557afdd6f
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Mon May 4 13:46:14 2020 +0530

    ALSA: hda/tegra: correct number of SDO lines for Tegra194
    
    Tegra194 supports 4 SDO lines but GCAP register indicates 2 lines. Thus it
    does not reflect the true capability of the HW. This patch presents a
    workaround by updating NSDO value accordingly in T_AZA_DBG_CFG_2 register.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Link: https://lore.kernel.org/r/1588580176-2801-2-git-send-email-spujar@nvidia.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 773992a07efa..45dc54485f24 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -52,10 +52,21 @@
 #define HDA_IPFS_INTR_MASK        0x188
 #define HDA_IPFS_EN_INTR          (1 << 16)
 
+/* FPCI */
+#define FPCI_DBG_CFG_2		  0x10F4
+#define FPCI_GCAP_NSDO_SHIFT	  18
+#define FPCI_GCAP_NSDO_MASK	  (0x3 << FPCI_GCAP_NSDO_SHIFT)
+
 /* max number of SDs */
 #define NUM_CAPTURE_SD 1
 #define NUM_PLAYBACK_SD 1
 
+/*
+ * Tegra194 does not reflect correct number of SDO lines. Below macro
+ * is used to update the GCAP register to workaround the issue.
+ */
+#define TEGRA194_NUM_SDO_LINES	  4
+
 struct hda_tegra {
 	struct azx chip;
 	struct device *dev;
@@ -275,6 +286,7 @@ static int hda_tegra_init_clk(struct hda_tegra *hda)
 
 static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 {
+	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
 	struct hdac_bus *bus = azx_bus(chip);
 	struct snd_card *card = chip->card;
 	int err;
@@ -298,6 +310,26 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 	bus->irq = irq_id;
 	card->sync_irq = bus->irq;
 
+	/*
+	 * Tegra194 has 4 SDO lines and the STRIPE can be used to
+	 * indicate how many of the SDO lines the stream should be
+	 * striped. But GCAP register does not reflect the true
+	 * capability of HW. Below workaround helps to fix this.
+	 *
+	 * GCAP_NSDO is bits 19:18 in T_AZA_DBG_CFG_2,
+	 * 0 for 1 SDO, 1 for 2 SDO, 2 for 4 SDO lines.
+	 */
+	if (of_device_is_compatible(np, "nvidia,tegra194-hda")) {
+		u32 val;
+
+		dev_info(card->dev, "Override SDO lines to %u\n",
+			 TEGRA194_NUM_SDO_LINES);
+
+		val = readl(hda->regs + FPCI_DBG_CFG_2) & ~FPCI_GCAP_NSDO_MASK;
+		val |= (TEGRA194_NUM_SDO_LINES >> 1) << FPCI_GCAP_NSDO_SHIFT;
+		writel(val, hda->regs + FPCI_DBG_CFG_2);
+	}
+
 	gcap = azx_readw(chip, GCAP);
 	dev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);
 
@@ -408,6 +440,7 @@ static int hda_tegra_create(struct snd_card *card,
 
 static const struct of_device_id hda_tegra_match[] = {
 	{ .compatible = "nvidia,tegra30-hda" },
+	{ .compatible = "nvidia,tegra194-hda" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, hda_tegra_match);

commit 9d0af44c2ed036c663832f3b764ffd1109c8b79e
Merge: 5af29028fd6d 4d024fe8f806
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 20 11:44:35 2020 +0100

    Merge branch 'for-linus' into for-next
    
    Resolved the merge conflict in HD-audio Tegra driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 4d024fe8f806e20e577cc934204c5784c7063293
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 20 11:41:27 2020 +0100

    ALSA: hda: Apply aligned MMIO access only conditionally
    
    It turned out that the recent simplification of HD-audio bus access
    helpers caused a regression on the virtual HD-audio device on QEMU
    with ARM platforms.  The driver got a CORB/RIRB timeout and couldn't
    probe any codecs.
    
    The essential difference that caused a problem was the enforced
    aligned MMIO accesses by simplification.  Since snd-hda-tegra driver
    is enabled on ARM, it enables CONFIG_SND_HDA_ALIGNED_MMIO, which makes
    the all HD-audio drivers using the aligned MMIO accesses.  While this
    is mandatory for snd-hda-tegra, it seems that snd-hda-intel on ARM
    gets broken by this access pattern.
    
    For addressing the regression, this patch introduces a new flag,
    aligned_mmio, to hdac_bus object, and applies the aligned MMIO only
    when this flag is set.  This change affects only platforms with
    CONFIG_SND_HDA_ALIGNED_MMIO set, i.e. mostly only for ARM platforms.
    
    Unfortunately the patch became a big bigger than it should be, just
    because the former calls didn't take hdac_bus object in the argument,
    hence we had to extend the call patterns.
    
    Fixes: 19abfefd4c76 ("ALSA: hda: Direct MMIO accesses")
    BugLink: https://bugzilla.opensuse.org/show_bug.cgi?id=1161152
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200120104127.28985-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 8350954b7986..e5191584638a 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -398,6 +398,7 @@ static int hda_tegra_create(struct snd_card *card,
 		return err;
 
 	chip->bus.needs_damn_long_delay = 1;
+	chip->bus.core.aligned_mmio = 1;
 
 	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
 	if (err < 0) {

commit 41f394a8d80766a0d8d2cc8879c3a295be951f6c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:24 2020 +0100

    ALSA: hda: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-9-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 9d0784aed9e4..567c9ebddb2e 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -366,7 +366,7 @@ static int hda_tegra_create(struct snd_card *card,
 			    unsigned int driver_caps,
 			    struct hda_tegra *hda)
 {
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_disconnect = hda_tegra_dev_disconnect,
 		.dev_free = hda_tegra_dev_free,
 	};

commit 5f2cb361d798fb39adb79fab4e5235e307c70e9a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 12 20:11:01 2019 +0100

    ALSA: hda: Unify get_response handling
    
    Now most of the get_response handling became quite similar between
    HDA-core and legacy drivers, and the only differences are:
    
    - the handling of extra-long polling delay for some codecs
    - the debug message for the stalled communication
    
    and both are worth to share in the common code.
    
    This patch unifies the code into snd_hdac_bus_get_response(), and use
    this from the legacy get_response callback.  It results in a good
    amount of code reduction in the end.
    
    Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20191212191101.19517-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 269f242fcbfd..9d0784aed9e4 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -394,7 +394,7 @@ static int hda_tegra_create(struct snd_card *card,
 	if (err < 0)
 		return err;
 
-	chip->bus.needs_damn_long_delay = 1;
+	chip->bus.core.needs_damn_long_delay = 1;
 
 	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
 	if (err < 0) {

commit 341a79ee8b080ed41dccc13250fcffc2c2028ccd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 12 09:05:18 2019 +0100

    ALSA: hda: tegra: Fix unused variable compile warning
    
    Forgot to remove the variable declaration as well in the last commit.
      sound/pci/hda/hda_tegra.c: In function 'hda_tegra_runtime_suspend':
      sound/pci/hda/hda_tegra.c:169:19: warning: unused variable 'bus' [-Wunused-variable]
    
    Fixes: f36da9406e66 ("ALSA: hda: Support PCM sync_stop")
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Link: https://lore.kernel.org/r/20191212080518.6522-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index fc2e0a294bc1..269f242fcbfd 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -166,7 +166,6 @@ static int __maybe_unused hda_tegra_runtime_suspend(struct device *dev)
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct azx *chip = card->private_data;
 	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
-	struct hdac_bus *bus = azx_bus(chip);
 
 	if (chip && chip->running) {
 		azx_stop_chip(chip);

commit f36da9406e6698a97ea643aeeab6307863094967
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:20 2019 +0100

    ALSA: hda: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.  It's cleared and reset dynamically at IRQ re-acquiring for
    the PM resume, too.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-22-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 8350954b7986..fc2e0a294bc1 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -170,7 +170,6 @@ static int __maybe_unused hda_tegra_runtime_suspend(struct device *dev)
 
 	if (chip && chip->running) {
 		azx_stop_chip(chip);
-		synchronize_irq(bus->irq);
 		azx_enter_link_reset(chip);
 	}
 	hda_tegra_disable_clocks(hda);
@@ -298,8 +297,7 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 		return err;
 	}
 	bus->irq = irq_id;
-
-	synchronize_irq(bus->irq);
+	card->sync_irq = bus->irq;
 
 	gcap = azx_readw(chip, GCAP);
 	dev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);

commit 19abfefd4c7604993d1c31e098a3f48bdafe334d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 7 20:32:08 2019 +0200

    ALSA: hda: Direct MMIO accesses
    
    HD-audio drivers access to the mmio registers indirectly via the
    corresponding bus->io_ops callbacks.  This is because some platform
    (notably Tegra SoC) requires the word-aligned access.  But it's rather
    a rare case, and other platforms suffer from the penalties by indirect
    calls unnecessarily.
    
    This patch is an attempt to optimize and cleanup for this situation.
    Now the special aligned access is used only when a new kconfig
    CONFIG_SND_HDA_ALIGNED_MMIO is set.  And the HD-audio core itself
    provides the aligned MMIO access helpers instead of the driver side.
    If Kconfig isn't set (as default), the standard helpers like readl()
    or writel() are used directly.
    
    A couple of places in ASoC Intel drivers have the access via io_ops
    reg_writel(), and they are replaced with the direct writel() calls.
    
    And now with this patch, the whole bus->io_ops becomes empty, so it's
    dropped completely.  The bus initialization functions are changed
    accordingly as well to drop the whole bus->io_ops.
    
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index ba414cc639f1..8350954b7986 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -75,72 +75,6 @@ MODULE_PARM_DESC(power_save,
 #define power_save	0
 #endif
 
-/*
- * Register access ops. Tegra HDA register access is DWORD only.
- */
-static void hda_tegra_writel(u32 value, u32 __iomem *addr)
-{
-	writel(value, addr);
-}
-
-static u32 hda_tegra_readl(u32 __iomem *addr)
-{
-	return readl(addr);
-}
-
-static void hda_tegra_writew(u16 value, u16 __iomem  *addr)
-{
-	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
-	void __iomem *dword_addr = (void __iomem *)((unsigned long)(addr) & ~0x3);
-	u32 v;
-
-	v = readl(dword_addr);
-	v &= ~(0xffff << shift);
-	v |= value << shift;
-	writel(v, dword_addr);
-}
-
-static u16 hda_tegra_readw(u16 __iomem *addr)
-{
-	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
-	void __iomem *dword_addr = (void __iomem *)((unsigned long)(addr) & ~0x3);
-	u32 v;
-
-	v = readl(dword_addr);
-	return (v >> shift) & 0xffff;
-}
-
-static void hda_tegra_writeb(u8 value, u8 __iomem *addr)
-{
-	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
-	void __iomem *dword_addr = (void __iomem *)((unsigned long)(addr) & ~0x3);
-	u32 v;
-
-	v = readl(dword_addr);
-	v &= ~(0xff << shift);
-	v |= value << shift;
-	writel(v, dword_addr);
-}
-
-static u8 hda_tegra_readb(u8 __iomem *addr)
-{
-	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
-	void __iomem *dword_addr = (void __iomem *)((unsigned long)(addr) & ~0x3);
-	u32 v;
-
-	v = readl(dword_addr);
-	return (v >> shift) & 0xff;
-}
-
-static const struct hdac_io_ops hda_tegra_io_ops = {
-	.reg_writel = hda_tegra_writel,
-	.reg_readl = hda_tegra_readl,
-	.reg_writew = hda_tegra_writew,
-	.reg_readw = hda_tegra_readw,
-	.reg_writeb = hda_tegra_writeb,
-	.reg_readb = hda_tegra_readb,
-};
-
 static const struct hda_controller_ops hda_tegra_ops; /* nothing special */
 
 static void hda_tegra_init(struct hda_tegra *hda)
@@ -459,7 +393,7 @@ static int hda_tegra_create(struct snd_card *card,
 
 	INIT_WORK(&hda->probe_work, hda_tegra_probe_work);
 
-	err = azx_bus_init(chip, NULL, &hda_tegra_io_ops);
+	err = azx_bus_init(chip, NULL);
 	if (err < 0)
 		return err;
 

commit 619a1f195f93276dc8c6e33fe057e007adc9c288
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 7 20:02:31 2019 +0200

    ALSA: hda: Remove page allocation redirection
    
    The HD-audio core allocates and releases pages via driver's specific
    dma_alloc_pages and dma_free_pages ops defined in bus->io_ops.  This
    was because some platforms require the uncached pages and the handling
    of page flags had to be done locally in the driver code.
    
    Since the recent change in ALSA core memory allocator, we can simply
    pass SNDRV_DMA_TYPE_DEV_UC for the uncached pages, and the only
    difference became about this type to be passed to the core allocator.
    That is, it's good time for cleaning up the mess.
    
    This patch changes the allocation code in HD-audio core to call the
    core allocator directly so that we get rid of dma_alloc_pages and
    dma_free_pages io_ops.  If a driver needs the uncached pages, it has
    to set bus->dma_type right after the bus initialization.
    
    This is merely a code refactoring and shouldn't bring any behavior
    changes.
    
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 7dbe9f39fc79..ba414cc639f1 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -75,20 +75,6 @@ MODULE_PARM_DESC(power_save,
 #define power_save	0
 #endif
 
-/*
- * DMA page allocation ops.
- */
-static int dma_alloc_pages(struct hdac_bus *bus, int type, size_t size,
-			   struct snd_dma_buffer *buf)
-{
-	return snd_dma_alloc_pages(type, bus->dev, size, buf);
-}
-
-static void dma_free_pages(struct hdac_bus *bus, struct snd_dma_buffer *buf)
-{
-	snd_dma_free_pages(buf);
-}
-
 /*
  * Register access ops. Tegra HDA register access is DWORD only.
  */
@@ -153,8 +139,6 @@ static const struct hdac_io_ops hda_tegra_io_ops = {
 	.reg_readw = hda_tegra_readw,
 	.reg_writeb = hda_tegra_writeb,
 	.reg_readb = hda_tegra_readb,
-	.dma_alloc_pages = dma_alloc_pages,
-	.dma_free_pages = dma_free_pages,
 };
 
 static const struct hda_controller_ops hda_tegra_ops; /* nothing special */

commit 9952f6918daa4ab5fc81307a9f90e31a4df3b200
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:04 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 201
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 228 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.107155473@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 3d68f9ef7694..7dbe9f39fc79 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -1,19 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *
  * Implementation of primary ALSA driver code base for NVIDIA Tegra HDA.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
  */
 
 #include <linux/clk.h>

commit 7472946915aad1cc751cce3edfd8c1fd5c845834
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Mar 4 21:33:25 2019 +0100

    ALSA: hda/tegra: avoid build error without CONFIG_PM
    
    The #ifdef protection around the PM functions is wrong, leading to
    a failed reference in some configurations:
    
    sound/pci/hda/hda_tegra.c: In function 'hda_tegra_runtime_suspend':
    sound/pci/hda/hda_tegra.c:273:2: error: implicit declaration of function 'hda_tegra_disable_clocks'; did you mean 'hda_tegra_enable_clocks'? [-Werror=implicit-function-declaration]
    
    Better remove the #ifdefs entirely and rely on the compiler silently
    dropping unused functions marked __maybe_unused.
    
    Fixes: 707e0759f2f4 ("ALSA: hda/tegra: implement runtime suspend/resume")
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index dbd8da5685cb..3d68f9ef7694 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -219,7 +219,6 @@ static int hda_tegra_enable_clocks(struct hda_tegra *data)
 	return rc;
 }
 
-#ifdef CONFIG_PM_SLEEP
 static void hda_tegra_disable_clocks(struct hda_tegra *data)
 {
 	clk_disable_unprepare(data->hda2hdmi_clk);
@@ -230,7 +229,7 @@ static void hda_tegra_disable_clocks(struct hda_tegra *data)
 /*
  * power management
  */
-static int hda_tegra_suspend(struct device *dev)
+static int __maybe_unused hda_tegra_suspend(struct device *dev)
 {
 	struct snd_card *card = dev_get_drvdata(dev);
 	int rc;
@@ -243,7 +242,7 @@ static int hda_tegra_suspend(struct device *dev)
 	return 0;
 }
 
-static int hda_tegra_resume(struct device *dev)
+static int __maybe_unused hda_tegra_resume(struct device *dev)
 {
 	struct snd_card *card = dev_get_drvdata(dev);
 	int rc;
@@ -255,10 +254,8 @@ static int hda_tegra_resume(struct device *dev)
 
 	return 0;
 }
-#endif /* CONFIG_PM_SLEEP */
 
-#ifdef CONFIG_PM
-static int hda_tegra_runtime_suspend(struct device *dev)
+static int __maybe_unused hda_tegra_runtime_suspend(struct device *dev)
 {
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct azx *chip = card->private_data;
@@ -275,7 +272,7 @@ static int hda_tegra_runtime_suspend(struct device *dev)
 	return 0;
 }
 
-static int hda_tegra_runtime_resume(struct device *dev)
+static int __maybe_unused hda_tegra_runtime_resume(struct device *dev)
 {
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct azx *chip = card->private_data;
@@ -292,7 +289,6 @@ static int hda_tegra_runtime_resume(struct device *dev)
 
 	return 0;
 }
-#endif /* CONFIG_PM */
 
 static const struct dev_pm_ops hda_tegra_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(hda_tegra_suspend, hda_tegra_resume)

commit c0bde003a01384b599b7600a4b16ee706163ac53
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Wed Feb 20 20:43:24 2019 +0530

    ALSA: hda/tegra: sound card name from device tree
    
    A platform can have multiple sound cards for different audio paths.
    Following is the print seen duirng device boot for jetson-xavier,
      ALSA device list:
        #0: nvidia,p2972-0000 at 0x3518000 irq 17
    By looking at above, it is not very clear if the sound card is for
    HDA. It becomes confusing when platform has registered multiple cards,
    and platform model name is used for card.
    
    This patch uses "nvidia,model" property mentioned in hda device tree
    to get the card name. Since property is optional, legacy boards will
    continue to use "tegra-hda". Custom name can be passed wherever needed.
    This naming convention is conistent with the way sound cards are named
    in general.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Reviewed-by: Jonathan Hunter <jonathanh@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index c8d18dc4da2a..dbd8da5685cb 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -380,8 +380,8 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 	int err;
 	unsigned short gcap;
 	int irq_id = platform_get_irq(pdev, 0);
-	const char *sname;
-	struct device_node *root;
+	const char *sname, *drv_name = "tegra-hda";
+	struct device_node *np = pdev->dev.of_node;
 
 	err = hda_tegra_init_chip(chip, pdev);
 	if (err)
@@ -440,17 +440,11 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 	}
 
 	/* driver name */
-	strcpy(card->driver, "tegra-hda");
-
-	root = of_find_node_by_path("/");
-	sname = of_get_property(root, "compatible", NULL);
-	of_node_put(root);
-	if (!sname) {
-		dev_err(card->dev,
-			"failed to get compatible property from root node\n");
-		return -ENODEV;
-	}
+	strncpy(card->driver, drv_name, sizeof(card->driver));
 	/* shortname for card */
+	sname = of_get_property(np, "nvidia,model", NULL);
+	if (!sname)
+		sname = drv_name;
 	if (strlen(sname) > sizeof(card->shortname))
 		dev_info(card->dev, "truncating shortname for card\n");
 	strncpy(card->shortname, sname, sizeof(card->shortname));

commit 9935d55b02906dec1b0795873cc4a1a7bb55b8f1
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Tue Jan 22 13:03:21 2019 +0530

    ALSA: hda/tegra: add driver flag for runtime PM
    
    AZX_DCAPS_PM_RUNTIME flag is added to indicate support for runtime PM.
    azx_has_pm_runtime() is used to check if above is enabled and thus
    forbid runtime PM calls if needed.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Reviewed-by: Ravindra Lokhande <rlokhande@nvidia.com>
    Reviewed-by: Mohan Kumar D <mkumard@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index a7fd4c67ab8e..c8d18dc4da2a 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -520,7 +520,8 @@ MODULE_DEVICE_TABLE(of, hda_tegra_match);
 
 static int hda_tegra_probe(struct platform_device *pdev)
 {
-	const unsigned int driver_flags = AZX_DCAPS_CORBRP_SELF_CLEAR;
+	const unsigned int driver_flags = AZX_DCAPS_CORBRP_SELF_CLEAR |
+					  AZX_DCAPS_PM_RUNTIME;
 	struct snd_card *card;
 	struct azx *chip;
 	struct hda_tegra *hda;

commit 707e0759f2f4aefcc5c3f08ce5fb9e98495fdc93
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Tue Jan 22 13:03:20 2019 +0530

    ALSA: hda/tegra: implement runtime suspend/resume
    
    This patch moves clock enable/disable from system resume/suspend to
    runtime resume/suspend respectively. Along with this hda controller
    chip init or stop is also moved. System resume/suspend can invoke
    runtime callbacks and do necessary setup.
    
    chip->running can be used to check for probe completion and device
    access during runtime_resume or runtime_suspend can be avoided if
    probe is not yet finished. This helps to avoid kernel panic during
    boot where runtime PM callbacks can happen from system PM.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Reviewed-by: Ravindra Lokhande <rlokhande@nvidia.com>
    Reviewed-by: Mohan Kumar D <mkumard@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index f068b1e7719b..a7fd4c67ab8e 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -233,32 +233,24 @@ static void hda_tegra_disable_clocks(struct hda_tegra *data)
 static int hda_tegra_suspend(struct device *dev)
 {
 	struct snd_card *card = dev_get_drvdata(dev);
-	struct azx *chip = card->private_data;
-	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
-	struct hdac_bus *bus = azx_bus(chip);
+	int rc;
 
+	rc = pm_runtime_force_suspend(dev);
+	if (rc < 0)
+		return rc;
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 
-	azx_stop_chip(chip);
-	synchronize_irq(bus->irq);
-	azx_enter_link_reset(chip);
-	hda_tegra_disable_clocks(hda);
-
 	return 0;
 }
 
 static int hda_tegra_resume(struct device *dev)
 {
 	struct snd_card *card = dev_get_drvdata(dev);
-	struct azx *chip = card->private_data;
-	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
-
-	hda_tegra_enable_clocks(hda);
-
-	hda_tegra_init(hda);
-
-	azx_init_chip(chip, 1);
+	int rc;
 
+	rc = pm_runtime_force_resume(dev);
+	if (rc < 0)
+		return rc;
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 
 	return 0;
@@ -268,11 +260,36 @@ static int hda_tegra_resume(struct device *dev)
 #ifdef CONFIG_PM
 static int hda_tegra_runtime_suspend(struct device *dev)
 {
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
+	struct hdac_bus *bus = azx_bus(chip);
+
+	if (chip && chip->running) {
+		azx_stop_chip(chip);
+		synchronize_irq(bus->irq);
+		azx_enter_link_reset(chip);
+	}
+	hda_tegra_disable_clocks(hda);
+
 	return 0;
 }
 
 static int hda_tegra_runtime_resume(struct device *dev)
 {
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
+	int rc;
+
+	rc = hda_tegra_enable_clocks(hda);
+	if (rc != 0)
+		return rc;
+	if (chip && chip->running) {
+		hda_tegra_init(hda);
+		azx_init_chip(chip, 1);
+	}
+
 	return 0;
 }
 #endif /* CONFIG_PM */

commit 091aa420530c1f0c93745dc9e506bfa96f898702
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Tue Jan 22 13:03:19 2019 +0530

    ALSA: hda/tegra: remove redundant clock enable API
    
    Explicit clock enable is not required during probe, as this would be
    managed by runtime PM calls. Clock can be enabled/disabled in runtime
    resume/suspend. This way it is easier to balance clock enable/disable
    counts.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Reviewed-by: Ravindra Lokhande <rlokhande@nvidia.com>
    Reviewed-by: Mohan Kumar D <mkumard@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 1189f972cb83..f068b1e7719b 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -319,7 +319,6 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 	struct hdac_bus *bus = azx_bus(chip);
 	struct device *dev = hda->dev;
 	struct resource *res;
-	int err;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	hda->regs = devm_ioremap_resource(dev, res);
@@ -329,12 +328,6 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 	bus->remap_addr = hda->regs + HDA_BAR0;
 	bus->addr = res->start + HDA_BAR0;
 
-	err = hda_tegra_enable_clocks(hda);
-	if (err) {
-		dev_err(dev, "failed to get enable clocks\n");
-		return err;
-	}
-
 	hda_tegra_init(hda);
 
 	return 0;

commit f2974aa21a414f9a2421fc69d2e289d3c74b2d3d
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Tue Jan 22 13:03:18 2019 +0530

    ALSA: hda/tegra: add runtime PM callbacks
    
    This patch adds skeleton of runtime suspend and resume callbacks.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Reviewed-by: Ravindra Lokhande <rlokhande@nvidia.com>
    Reviewed-by: Mohan Kumar D <mkumard@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 28e165612189..1189f972cb83 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -265,8 +265,23 @@ static int hda_tegra_resume(struct device *dev)
 }
 #endif /* CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_PM
+static int hda_tegra_runtime_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int hda_tegra_runtime_resume(struct device *dev)
+{
+	return 0;
+}
+#endif /* CONFIG_PM */
+
 static const struct dev_pm_ops hda_tegra_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(hda_tegra_suspend, hda_tegra_resume)
+	SET_RUNTIME_PM_OPS(hda_tegra_runtime_suspend,
+			   hda_tegra_runtime_resume,
+			   NULL)
 };
 
 static int hda_tegra_dev_disconnect(struct snd_device *device)

commit 65af2122e8727a6bf4890a0d2a1d79ea1db323c1
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Tue Jan 22 13:03:17 2019 +0530

    ALSA: hda/tegra: get clock handles early in probe
    
    Moved devm_clk_get() API calls to a separate function and the same
    can be called early in the probe. This is done before runtime PM
    for the device is enabled. The runtime resume/suspend callbacks can
    later enable/disable clocks respectively(the support would be added
    in subsequent patches). Clock handles should be available by the
    time runtime suspend/resume calls can happen.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Reviewed-by: Ravindra Lokhande <rlokhande@nvidia.com>
    Reviewed-by: Mohan Kumar D <mkumard@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 2f9dd23981fe..28e165612189 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -306,22 +306,6 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 	struct resource *res;
 	int err;
 
-	hda->hda_clk = devm_clk_get(dev, "hda");
-	if (IS_ERR(hda->hda_clk)) {
-		dev_err(dev, "failed to get hda clock\n");
-		return PTR_ERR(hda->hda_clk);
-	}
-	hda->hda2codec_2x_clk = devm_clk_get(dev, "hda2codec_2x");
-	if (IS_ERR(hda->hda2codec_2x_clk)) {
-		dev_err(dev, "failed to get hda2codec_2x clock\n");
-		return PTR_ERR(hda->hda2codec_2x_clk);
-	}
-	hda->hda2hdmi_clk = devm_clk_get(dev, "hda2hdmi");
-	if (IS_ERR(hda->hda2hdmi_clk)) {
-		dev_err(dev, "failed to get hda2hdmi clock\n");
-		return PTR_ERR(hda->hda2hdmi_clk);
-	}
-
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	hda->regs = devm_ioremap_resource(dev, res);
 	if (IS_ERR(hda->regs))
@@ -341,6 +325,29 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 	return 0;
 }
 
+static int hda_tegra_init_clk(struct hda_tegra *hda)
+{
+	struct device *dev = hda->dev;
+
+	hda->hda_clk = devm_clk_get(dev, "hda");
+	if (IS_ERR(hda->hda_clk)) {
+		dev_err(dev, "failed to get hda clock\n");
+		return PTR_ERR(hda->hda_clk);
+	}
+	hda->hda2codec_2x_clk = devm_clk_get(dev, "hda2codec_2x");
+	if (IS_ERR(hda->hda2codec_2x_clk)) {
+		dev_err(dev, "failed to get hda2codec_2x clock\n");
+		return PTR_ERR(hda->hda2codec_2x_clk);
+	}
+	hda->hda2hdmi_clk = devm_clk_get(dev, "hda2hdmi");
+	if (IS_ERR(hda->hda2hdmi_clk)) {
+		dev_err(dev, "failed to get hda2hdmi clock\n");
+		return PTR_ERR(hda->hda2hdmi_clk);
+	}
+
+	return 0;
+}
+
 static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 {
 	struct hdac_bus *bus = azx_bus(chip);
@@ -507,6 +514,10 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		return err;
 	}
 
+	err = hda_tegra_init_clk(hda);
+	if (err < 0)
+		goto out_free;
+
 	err = hda_tegra_create(card, driver_flags, hda);
 	if (err < 0)
 		goto out_free;

commit 3f7e94e6d66b52bb6a86b7e06f5f2453491bf7c8
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Tue Jan 22 13:03:16 2019 +0530

    ALSA: hda/tegra: runtime power management support
    
    This patch enables runtime power management(runtime PM) support for
    hda. pm_runtime_enable() and pm_runtime_disable() are added during
    device probe and remove respectively. The runtime PM callbacks will
    be forbidden if hda controller does not have support for runtime PM.
    pm_runtime_get_sync() and pm_runtime_put() are added for hda register
    access. The callbacks for above will be added in subsequent patches.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Reviewed-by: Ravindra Lokhande <rlokhande@nvidia.com>
    Reviewed-by: Mohan Kumar D <mkumard@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 97a176d817a0..2f9dd23981fe 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -32,6 +32,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/string.h>
+#include <linux/pm_runtime.h>
 
 #include <sound/core.h>
 #include <sound/initval.h>
@@ -512,6 +513,11 @@ static int hda_tegra_probe(struct platform_device *pdev)
 	card->private_data = chip;
 
 	dev_set_drvdata(&pdev->dev, card);
+
+	pm_runtime_enable(hda->dev);
+	if (!azx_has_pm_runtime(chip))
+		pm_runtime_forbid(hda->dev);
+
 	schedule_work(&hda->probe_work);
 
 	return 0;
@@ -528,6 +534,7 @@ static void hda_tegra_probe_work(struct work_struct *work)
 	struct platform_device *pdev = to_platform_device(hda->dev);
 	int err;
 
+	pm_runtime_get_sync(hda->dev);
 	err = hda_tegra_first_init(chip, pdev);
 	if (err < 0)
 		goto out_free;
@@ -549,12 +556,18 @@ static void hda_tegra_probe_work(struct work_struct *work)
 	snd_hda_set_power_save(&chip->bus, power_save * 1000);
 
  out_free:
+	pm_runtime_put(hda->dev);
 	return; /* no error return from async probe */
 }
 
 static int hda_tegra_remove(struct platform_device *pdev)
 {
-	return snd_card_free(dev_get_drvdata(&pdev->dev));
+	int ret;
+
+	ret = snd_card_free(dev_get_drvdata(&pdev->dev));
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
 }
 
 static void hda_tegra_shutdown(struct platform_device *pdev)

commit 63d2a9ec310d8bcc955574220d4631aa55c1a80c
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Wed Dec 26 16:04:49 2018 +0530

    ALSA: hda/tegra: clear pending irq handlers
    
    Even after disabling interrupts on the module, it could be possible
    that irq handlers are still running. System hang is seen during
    suspend path. It was found that, there were pending writes on the
    HDA bus and clock was disabled by that time.
    
    Above mentioned issue is fixed by clearing any pending irq handlers
    before disabling clocks and returning from hda suspend.
    
    Suggested-by: Mohan Kumar <mkumard@nvidia.com>
    Suggested-by: Dara Ramesh <dramesh@nvidia.com>
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 83befd8d43e8..97a176d817a0 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -234,10 +234,12 @@ static int hda_tegra_suspend(struct device *dev)
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct azx *chip = card->private_data;
 	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
+	struct hdac_bus *bus = azx_bus(chip);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 
 	azx_stop_chip(chip);
+	synchronize_irq(bus->irq);
 	azx_enter_link_reset(chip);
 	hda_tegra_disable_clocks(hda);
 

commit 350355e339312d6ac048086a4c5f6d0ea0bf915f
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Dec 3 16:53:16 2018 +0100

    ALSA: hda/tegra - Probe up to 8 codecs
    
    Recent devices support more than the 4 codecs that the AZX core will
    probe by default. Probe up to 8 codecs to make sure all of them are
    enumerated.
    
    Suggested-by: Sameer Pujar <spujar@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 84ea6069d28b..83befd8d43e8 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -531,7 +531,7 @@ static void hda_tegra_probe_work(struct work_struct *work)
 		goto out_free;
 
 	/* create codec instances */
-	err = azx_probe_codecs(chip, 0);
+	err = azx_probe_codecs(chip, 8);
 	if (err < 0)
 		goto out_free;
 

commit c94800a3952c71191c3a8a7151695216da43d5eb
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Thu Nov 29 09:28:52 2018 +0530

    ALSA: hda/tegra: compatible string as shortname
    
    By default HDA sound card is registered with shortname "tegra-hda".
    Same driver is used across tegra platforms and it is necessary to
    distinguish between platforms to use platform specific settings from
    userspace. One such example is, hdmi port on different platforms use
    different alsa pcm device ID. For hdmi playback to work it should
    open correct pcm device depending on the platform.
    
    This patch applies shortname from first compatible string provided
    in root node of device tree. Userspace then can use this card name
    to apply specific settings.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index dd7d4242d6d2..84ea6069d28b 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -31,6 +31,7 @@
 #include <linux/of_device.h>
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/string.h>
 
 #include <sound/core.h>
 #include <sound/initval.h>
@@ -344,6 +345,8 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 	int err;
 	unsigned short gcap;
 	int irq_id = platform_get_irq(pdev, 0);
+	const char *sname;
+	struct device_node *root;
 
 	err = hda_tegra_init_chip(chip, pdev);
 	if (err)
@@ -401,8 +404,23 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+	/* driver name */
 	strcpy(card->driver, "tegra-hda");
-	strcpy(card->shortname, "tegra-hda");
+
+	root = of_find_node_by_path("/");
+	sname = of_get_property(root, "compatible", NULL);
+	of_node_put(root);
+	if (!sname) {
+		dev_err(card->dev,
+			"failed to get compatible property from root node\n");
+		return -ENODEV;
+	}
+	/* shortname for card */
+	if (strlen(sname) > sizeof(card->shortname))
+		dev_info(card->dev, "truncating shortname for card\n");
+	strncpy(card->shortname, sname, sizeof(card->shortname));
+
+	/* longname for card */
 	snprintf(card->longname, sizeof(card->longname),
 		 "%s at 0x%lx irq %i",
 		 card->shortname, bus->addr, bus->irq);

commit 56e91b12688648fc69aa5896dce3190a1a795ef9
Merge: 3a182c848946 be57bfffb7b5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 30 16:55:38 2018 +0200

    Merge tag 'hda-codec-h-move' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ALSA: Move hda_codec.h to include/sound
    
    For easier sharing with ASoC.

commit be57bfffb7b5ba72e1293643053f8861fcaa5163
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Wed Aug 22 15:24:57 2018 -0500

    ALSA: hda: move hda_codec.h to include/sound
    
    As suggested by Takashi, move this header file to make it easier
    to include from e.g. the Intel Skylake driver in follow-up patches
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 0621920f7617..4bc5232eac1c 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -35,7 +35,7 @@
 #include <sound/core.h>
 #include <sound/initval.h>
 
-#include "hda_codec.h"
+#include <sound/hda_codec.h>
 #include "hda_controller.h"
 
 /* Defines for Nvidia Tegra HDA support */

commit 193c7e14762a58003af7914183f9b963c0267788
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 8 17:12:58 2018 +0200

    ALSA: hda: Remove substream allocation/free ops
    
    Since we dropped the memory page fiddling in the own allocators in
    hda_intel.c, the substream allocation and free ops in both hda_intel.c
    and hda_tegra.c became nothing but the simple calls of the standard
    snd_pcm_lib helpers.  As both are identical, there is no longer need
    for indirect calls via ops; it's a good opportunity for removing ops
    and simplifying the codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 0621920f7617..8fd20e4dca17 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -99,19 +99,6 @@ static void dma_free_pages(struct hdac_bus *bus, struct snd_dma_buffer *buf)
 	snd_dma_free_pages(buf);
 }
 
-static int substream_alloc_pages(struct azx *chip,
-				 struct snd_pcm_substream *substream,
-				 size_t size)
-{
-	return snd_pcm_lib_malloc_pages(substream, size);
-}
-
-static int substream_free_pages(struct azx *chip,
-				struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 /*
  * Register access ops. Tegra HDA register access is DWORD only.
  */
@@ -180,10 +167,7 @@ static const struct hdac_io_ops hda_tegra_io_ops = {
 	.dma_free_pages = dma_free_pages,
 };
 
-static const struct hda_controller_ops hda_tegra_ops = {
-	.substream_alloc_pages = substream_alloc_pages,
-	.substream_free_pages = substream_free_pages,
-};
+static const struct hda_controller_ops hda_tegra_ops; /* nothing special */
 
 static void hda_tegra_init(struct hda_tegra *hda)
 {

commit c9058d43d99404986133112393be1d1a4daf1b69
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Jun 21 19:18:32 2016 +0100

    ALSA: hda/tegra: iomem fixups for sparse warnings
    
    The readl/writel are not being passed __iomem annotated
    variables, so fix the following sparse warnings by adding
    __iomem in:
    
    sound/pci/hda/hda_tegra.c:120:9: warning: incorrect type in argument 2 (different address spaces)
    sound/pci/hda/hda_tegra.c:120:9:    expected void volatile [noderef] <asn:2>*addr
    sound/pci/hda/hda_tegra.c:120:9:    got unsigned int [usertype] *addr
    sound/pci/hda/hda_tegra.c:125:16: warning: incorrect type in argument 1 (different address spaces)
    sound/pci/hda/hda_tegra.c:125:16:    expected void const volatile [noderef] <asn:2>*addr
    sound/pci/hda/hda_tegra.c:125:16:    got unsigned int [usertype] *addr
    sound/pci/hda/hda_tegra.c:134:13: warning: incorrect type in argument 1 (different address spaces)
    sound/pci/hda/hda_tegra.c:134:13:    expected void const volatile [noderef] <asn:2>*addr
    sound/pci/hda/hda_tegra.c:134:13:    got void *dword_addr
    sound/pci/hda/hda_tegra.c:137:9: warning: incorrect type in argument 2 (different address spaces)
    sound/pci/hda/hda_tegra.c:137:9:    expected void volatile [noderef] <asn:2>*addr
    sound/pci/hda/hda_tegra.c:137:9:    got void *dword_addr
    sound/pci/hda/hda_tegra.c:146:13: warning: incorrect type in argument 1 (different address spaces)
    sound/pci/hda/hda_tegra.c:146:13:    expected void const volatile [noderef] <asn:2>*addr
    sound/pci/hda/hda_tegra.c:146:13:    got void *dword_addr
    sound/pci/hda/hda_tegra.c:156:13: warning: incorrect type in argument 1 (different address spaces)
    sound/pci/hda/hda_tegra.c:156:13:    expected void const volatile [noderef] <asn:2>*addr
    sound/pci/hda/hda_tegra.c:156:13:    got void *dword_addr
    sound/pci/hda/hda_tegra.c:159:9: warning: incorrect type in argument 2 (different address spaces)
    sound/pci/hda/hda_tegra.c:159:9:    expected void volatile [noderef] <asn:2>*addr
    sound/pci/hda/hda_tegra.c:159:9:    got void *dword_addr
    sound/pci/hda/hda_tegra.c:168:13: warning: incorrect type in argument 1 (different address spaces)
    sound/pci/hda/hda_tegra.c:168:13:    expected void const volatile [noderef] <asn:2>*addr
    sound/pci/hda/hda_tegra.c:168:13:    got void *dword_addr
    sound/pci/hda/hda_tegra.c:173:23: warning: incorrect type in initializer (incompatible argument 2 (different address spaces))
    sound/pci/hda/hda_tegra.c:173:23:    expected void ( *reg_writel )( ... )
    sound/pci/hda/hda_tegra.c:173:23:    got void ( static [toplevel] *<noident> )( ... )
    sound/pci/hda/hda_tegra.c:174:22: warning: incorrect type in initializer (incompatible argument 1 (different address spaces))
    sound/pci/hda/hda_tegra.c:174:22:    expected unsigned int ( *reg_readl )( ... )
    sound/pci/hda/hda_tegra.c:174:22:    got unsigned int ( static [toplevel] *<noident> )( ... )
    sound/pci/hda/hda_tegra.c:175:23: warning: incorrect type in initializer (incompatible argument 2 (different address spaces))
    sound/pci/hda/hda_tegra.c:175:23:    expected void ( *reg_writew )( ... )
    sound/pci/hda/hda_tegra.c:175:23:    got void ( static [toplevel] *<noident> )( ... )
    sound/pci/hda/hda_tegra.c:176:22: warning: incorrect type in initializer (incompatible argument 1 (different address spaces))
    sound/pci/hda/hda_tegra.c:176:22:    expected unsigned short ( *reg_readw )( ... )
    sound/pci/hda/hda_tegra.c:176:22:    got unsigned short ( static [toplevel] *<noident> )( ... )
    sound/pci/hda/hda_tegra.c:177:23: warning: incorrect type in initializer (incompatible argument 2 (different address spaces))
    sound/pci/hda/hda_tegra.c:177:23:    expected void ( *reg_writeb )( ... )
    sound/pci/hda/hda_tegra.c:177:23:    got void ( static [toplevel] *<noident> )( ... )
    sound/pci/hda/hda_tegra.c:178:22: warning: incorrect type in initializer (incompatible argument 1 (different address spaces))
    sound/pci/hda/hda_tegra.c:178:22:    expected unsigned char ( *reg_readb )( ... )
    sound/pci/hda/hda_tegra.c:178:22:    got unsigned char ( static [toplevel] *<noident> )( ... )
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 17fd81736d3d..0621920f7617 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -115,20 +115,20 @@ static int substream_free_pages(struct azx *chip,
 /*
  * Register access ops. Tegra HDA register access is DWORD only.
  */
-static void hda_tegra_writel(u32 value, u32 *addr)
+static void hda_tegra_writel(u32 value, u32 __iomem *addr)
 {
 	writel(value, addr);
 }
 
-static u32 hda_tegra_readl(u32 *addr)
+static u32 hda_tegra_readl(u32 __iomem *addr)
 {
 	return readl(addr);
 }
 
-static void hda_tegra_writew(u16 value, u16 *addr)
+static void hda_tegra_writew(u16 value, u16 __iomem  *addr)
 {
 	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
-	void *dword_addr = (void *)((unsigned long)(addr) & ~0x3);
+	void __iomem *dword_addr = (void __iomem *)((unsigned long)(addr) & ~0x3);
 	u32 v;
 
 	v = readl(dword_addr);
@@ -137,20 +137,20 @@ static void hda_tegra_writew(u16 value, u16 *addr)
 	writel(v, dword_addr);
 }
 
-static u16 hda_tegra_readw(u16 *addr)
+static u16 hda_tegra_readw(u16 __iomem *addr)
 {
 	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
-	void *dword_addr = (void *)((unsigned long)(addr) & ~0x3);
+	void __iomem *dword_addr = (void __iomem *)((unsigned long)(addr) & ~0x3);
 	u32 v;
 
 	v = readl(dword_addr);
 	return (v >> shift) & 0xffff;
 }
 
-static void hda_tegra_writeb(u8 value, u8 *addr)
+static void hda_tegra_writeb(u8 value, u8 __iomem *addr)
 {
 	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
-	void *dword_addr = (void *)((unsigned long)(addr) & ~0x3);
+	void __iomem *dword_addr = (void __iomem *)((unsigned long)(addr) & ~0x3);
 	u32 v;
 
 	v = readl(dword_addr);
@@ -159,10 +159,10 @@ static void hda_tegra_writeb(u8 value, u8 *addr)
 	writel(v, dword_addr);
 }
 
-static u8 hda_tegra_readb(u8 *addr)
+static u8 hda_tegra_readb(u8 __iomem *addr)
 {
 	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
-	void *dword_addr = (void *)((unsigned long)(addr) & ~0x3);
+	void __iomem *dword_addr = (void __iomem *)((unsigned long)(addr) & ~0x3);
 	u32 v;
 
 	v = readl(dword_addr);

commit 7d9a180895ee8c301df7f9447429009795c56c21
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 17 08:23:39 2015 +0100

    ALSA: hda - Raise AZX_DCAPS_RIRB_DELAY handling into top drivers
    
    AZX_DCAPS_RIRB_DELAY is dedicated only for Nvidia and its purpose is
    just to set a flag in bus.  So it's better to be set in the toplevel
    driver, either hda_intel.c or hda_tegra.c, instead of the common
    hda_controller.c.  This also allows us to strip this flag from dcaps,
    so save one more bit there.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 58c0aad37284..17fd81736d3d 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -464,6 +464,8 @@ static int hda_tegra_create(struct snd_card *card,
 	if (err < 0)
 		return err;
 
+	chip->bus.needs_damn_long_delay = 1;
+
 	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
 	if (err < 0) {
 		dev_err(card->dev, "Error creating device\n");
@@ -481,8 +483,7 @@ MODULE_DEVICE_TABLE(of, hda_tegra_match);
 
 static int hda_tegra_probe(struct platform_device *pdev)
 {
-	const unsigned int driver_flags = AZX_DCAPS_RIRB_DELAY |
-					  AZX_DCAPS_CORBRP_SELF_CLEAR;
+	const unsigned int driver_flags = AZX_DCAPS_CORBRP_SELF_CLEAR;
 	struct snd_card *card;
 	struct azx *chip;
 	struct hda_tegra *hda;

commit 83510441bc08bee201c0ded9d81da6dfd008d69a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 24 11:00:18 2015 +0200

    ALSA: hda/tegra - async probe for avoiding module loading deadlock
    
    The Tegra HD-audio controller driver causes deadlocks when loaded as a
    module since the driver invokes request_module() at binding with the
    codec driver.  This patch works around it by deferring the probe in a
    work like Intel HD-audio controller driver does.  Although hovering
    the codec probe stuff into udev would be a better solution, it may
    cause other regressions, so let's try this band-aid fix until the more
    proper solution gets landed.
    
    Reported-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Thierry Reding <treding@nvidia.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 477742cb70a2..58c0aad37284 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -73,6 +73,7 @@ struct hda_tegra {
 	struct clk *hda2codec_2x_clk;
 	struct clk *hda2hdmi_clk;
 	void __iomem *regs;
+	struct work_struct probe_work;
 };
 
 #ifdef CONFIG_PM
@@ -294,7 +295,9 @@ static int hda_tegra_dev_disconnect(struct snd_device *device)
 static int hda_tegra_dev_free(struct snd_device *device)
 {
 	struct azx *chip = device->device_data;
+	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
 
+	cancel_work_sync(&hda->probe_work);
 	if (azx_bus(chip)->chip_init) {
 		azx_stop_all_streams(chip);
 		azx_stop_chip(chip);
@@ -426,6 +429,9 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 /*
  * constructor
  */
+
+static void hda_tegra_probe_work(struct work_struct *work);
+
 static int hda_tegra_create(struct snd_card *card,
 			    unsigned int driver_caps,
 			    struct hda_tegra *hda)
@@ -452,6 +458,8 @@ static int hda_tegra_create(struct snd_card *card,
 	chip->single_cmd = false;
 	chip->snoop = true;
 
+	INIT_WORK(&hda->probe_work, hda_tegra_probe_work);
+
 	err = azx_bus_init(chip, NULL, &hda_tegra_io_ops);
 	if (err < 0)
 		return err;
@@ -499,6 +507,21 @@ static int hda_tegra_probe(struct platform_device *pdev)
 	card->private_data = chip;
 
 	dev_set_drvdata(&pdev->dev, card);
+	schedule_work(&hda->probe_work);
+
+	return 0;
+
+out_free:
+	snd_card_free(card);
+	return err;
+}
+
+static void hda_tegra_probe_work(struct work_struct *work)
+{
+	struct hda_tegra *hda = container_of(work, struct hda_tegra, probe_work);
+	struct azx *chip = &hda->chip;
+	struct platform_device *pdev = to_platform_device(hda->dev);
+	int err;
 
 	err = hda_tegra_first_init(chip, pdev);
 	if (err < 0)
@@ -520,11 +543,8 @@ static int hda_tegra_probe(struct platform_device *pdev)
 	chip->running = 1;
 	snd_hda_set_power_save(&chip->bus, power_save * 1000);
 
-	return 0;
-
-out_free:
-	snd_card_free(card);
-	return err;
+ out_free:
+	return; /* no error return from async probe */
 }
 
 static int hda_tegra_remove(struct platform_device *pdev)

commit 6a464a4ccb674a61eeec296bcc9b999b9252247f
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue May 5 14:56:21 2015 +0200

    ALSA: hda/tegra - Improve error reporting
    
    When probing, provide accurate error messages to help with debugging
    failures.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 7003677f7473..477742cb70a2 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -316,14 +316,20 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 	int err;
 
 	hda->hda_clk = devm_clk_get(dev, "hda");
-	if (IS_ERR(hda->hda_clk))
+	if (IS_ERR(hda->hda_clk)) {
+		dev_err(dev, "failed to get hda clock\n");
 		return PTR_ERR(hda->hda_clk);
+	}
 	hda->hda2codec_2x_clk = devm_clk_get(dev, "hda2codec_2x");
-	if (IS_ERR(hda->hda2codec_2x_clk))
+	if (IS_ERR(hda->hda2codec_2x_clk)) {
+		dev_err(dev, "failed to get hda2codec_2x clock\n");
 		return PTR_ERR(hda->hda2codec_2x_clk);
+	}
 	hda->hda2hdmi_clk = devm_clk_get(dev, "hda2hdmi");
-	if (IS_ERR(hda->hda2hdmi_clk))
+	if (IS_ERR(hda->hda2hdmi_clk)) {
+		dev_err(dev, "failed to get hda2hdmi clock\n");
 		return PTR_ERR(hda->hda2hdmi_clk);
+	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	hda->regs = devm_ioremap_resource(dev, res);
@@ -334,8 +340,10 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 	bus->addr = res->start + HDA_BAR0;
 
 	err = hda_tegra_enable_clocks(hda);
-	if (err)
+	if (err) {
+		dev_err(dev, "failed to get enable clocks\n");
 		return err;
+	}
 
 	hda_tegra_init(hda);
 
@@ -385,12 +393,17 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 
 	/* initialize streams */
 	err = azx_init_streams(chip);
-	if (err < 0)
+	if (err < 0) {
+		dev_err(card->dev, "failed to initialize streams: %d\n", err);
 		return err;
+	}
 
 	err = azx_alloc_stream_pages(chip);
-	if (err < 0)
+	if (err < 0) {
+		dev_err(card->dev, "failed to allocate stream pages: %d\n",
+			err);
 		return err;
+	}
 
 	/* initialize chip */
 	azx_init_chip(chip, 1);

commit 88871dd25f64b9bf16222e829ad766fac201866a
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue May 5 14:56:19 2015 +0200

    ALSA: hda/tegra - Set CORBRP self-clear flag
    
    This is set for the MCP variants of the NVIDIA HDA controller, which the
    Tegra variant was derived from. This fixes the following warning at boot
    time:
    
            [    2.486610] tegra-hda 70030000.hda: CORB reset timeout#1, CORBRP = 0
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index db0bb50fa5b9..7003677f7473 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -460,11 +460,12 @@ MODULE_DEVICE_TABLE(of, hda_tegra_match);
 
 static int hda_tegra_probe(struct platform_device *pdev)
 {
+	const unsigned int driver_flags = AZX_DCAPS_RIRB_DELAY |
+					  AZX_DCAPS_CORBRP_SELF_CLEAR;
 	struct snd_card *card;
 	struct azx *chip;
 	struct hda_tegra *hda;
 	int err;
-	const unsigned int driver_flags = AZX_DCAPS_RIRB_DELAY;
 
 	hda = devm_kzalloc(&pdev->dev, sizeof(*hda), GFP_KERNEL);
 	if (!hda)

commit 3b90f4072730c619809a0cbf597bf1b3bf76a2ec
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue May 5 14:45:57 2015 +0200

    ALSA: hda/tegra - Fix oops
    
    Commit a41d122449be ("ALSA: hda - Embed bus into controller object")
    introduced a regression in the Tegra HDA driver that causes the
    following oops during boot:
    
            [    2.333458] Unable to handle kernel NULL pointer dereference at virtual address 000004c4
            [    2.341537] pgd = c0004000
            [    2.344312] [000004c4] *pgd=00000000
            [    2.347898] Internal error: Oops: 5 [#1] PREEMPT SMP ARM
            [    2.353200] Modules linked in:
            [    2.356264] CPU: 0 PID: 1 Comm: swapper/0 Tainted: G        W       4.1.0-rc2-next-20150505-00344-g8577890defbf #79
            [    2.366682] Hardware name: NVIDIA Tegra SoC (Flattened Device Tree)
            [    2.372939] task: ee0d8b40 ti: ee0da000 task.ti: ee0da000
            [    2.378336] PC is at azx_bus_init+0x18/0xf4
            [    2.382516] LR is at hda_tegra_probe+0x6c/0x478
            [    2.387043] pc : [<c06156c4>]    lr : [<c061cf00>]    psr: 60000113
            [    2.387043] sp : ee0dbe38  ip : 00000000  fp : 00000000
            [    2.398501] r10: ed874c00  r9 : 000000fd  r8 : 00000000
            [    2.403717] r7 : ed874c10  r6 : 00000000  r5 : 00000000  r4 : ed016810
            [    2.410232] r3 : c08a2ad4  r2 : c08a1ea0  r1 : 00000000  r0 : ed016810
            [    2.416750] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
            [    2.424046] Control: 10c5387d  Table: 8000406a  DAC: 00000015
            [    2.429783] Process swapper/0 (pid: 1, stack limit = 0xee0da210)
            [    2.435778] Stack: (0xee0dbe38 to 0xee0dc000)
            [    2.440129] be20:                                                       00000000 ed016810
            [    2.448297] be40: 00000000 c061cf00 00000000 ee0dbe5c ed8735d0 c0a7bc48 ed02fd50 ed016000
            [    2.456462] be60: c1250164 ed874c10 c0c66bf8 fffffdfb 00000000 000000fd c0b8dc98 c046664c
            [    2.464628] be80: c0466608 c1250164 ed874c10 00000000 c0c66bf8 c0464eb4 ed874c10 c0c66bf8
            [    2.472793] bea0: ed874c44 c0c43458 00000000 c04650d0 00000000 c0c66bf8 c046503c c04633b4
            [    2.480959] bec0: ee11bea4 ed85f390 c0c66bf8 ed017ac0 00000000 c0464634 c0ab2b7c c0c66bf8
            [    2.489125] bee0: c0bfde20 c0c66bf8 c0bfde20 ed01ce40 c0b7b414 c04656e8 c04665b0 c0bfde20
            [    2.497291] bf00: c0bfde20 c0009770 ee0d8b40 c0c02488 60000113 00000000 00000000 00000003
            [    2.505458] bf20: 00000000 c0c02488 60000113 00000000 c0b54598 c0b16a90 ef7fcc57 c0041228
            [    2.513624] bf40: c0a9150c ef7fcc5f 00000006 00000006 00000000 c0bf1fa8 c0bf2354 00000006
            [    2.521790] bf60: c0b8dc90 c0c7c000 c0c7c000 c0b8dc98 00000000 c0b54dd8 00000006 00000006
            [    2.529956] bf80: c0b54598 00000000 00000000 c07ff08c 00000000 00000000 00000000 00000000
            [    2.538122] bfa0: 00000000 c07ff094 00000000 c000f5a0 00000000 00000000 00000000 00000000
            [    2.546286] bfc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
            [    2.554451] bfe0: 00000000 00000000 00000000 00000000 00000013 00000000 fffff7ff c013f264
            [    2.562624] [<c06156c4>] (azx_bus_init) from [<c061cf00>] (hda_tegra_probe+0x6c/0x478)
            [    2.570535] [<c061cf00>] (hda_tegra_probe) from [<c046664c>] (platform_drv_probe+0x44/0xa4)
            [    2.578879] [<c046664c>] (platform_drv_probe) from [<c0464eb4>] (driver_probe_device+0x174/0x2b8)
            [    2.587739] [<c0464eb4>] (driver_probe_device) from [<c04650d0>] (__driver_attach+0x94/0x98)
            [    2.596172] [<c04650d0>] (__driver_attach) from [<c04633b4>] (bus_for_each_dev+0x6c/0xa0)
            [    2.604342] [<c04633b4>] (bus_for_each_dev) from [<c0464634>] (bus_add_driver+0x148/0x1f0)
            [    2.612597] [<c0464634>] (bus_add_driver) from [<c04656e8>] (driver_register+0x78/0xf8)
            [    2.620593] [<c04656e8>] (driver_register) from [<c0009770>] (do_one_initcall+0x8c/0x1d4)
            [    2.628765] [<c0009770>] (do_one_initcall) from [<c0b54dd8>] (kernel_init_freeable+0x144/0x1e4)
            [    2.637459] [<c0b54dd8>] (kernel_init_freeable) from [<c07ff094>] (kernel_init+0x8/0xe8)
            [    2.645543] [<c07ff094>] (kernel_init) from [<c000f5a0>] (ret_from_fork+0x14/0x34)
    
    This is caused by azx_bus_init() trying to dereference chip->card, which
    for the Tegra driver doesn't get initialized until sometime later during
    the call to hda_tegra_create().
    
    Fix this by mimicking the behaviour of the Intel driver and defer HDA
    bus initialization until right before the call to snd_device_new().
    
    Fixes: a41d122449be ('ALSA: hda - Embed bus into controller object')
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 801e9fb4a467..db0bb50fa5b9 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -439,6 +439,10 @@ static int hda_tegra_create(struct snd_card *card,
 	chip->single_cmd = false;
 	chip->snoop = true;
 
+	err = azx_bus_init(chip, NULL, &hda_tegra_io_ops);
+	if (err < 0)
+		return err;
+
 	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
 	if (err < 0) {
 		dev_err(card->dev, "Error creating device\n");
@@ -475,10 +479,6 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		return err;
 	}
 
-	err = azx_bus_init(chip, NULL, &hda_tegra_io_ops);
-	if (err < 0)
-		goto out_free;
-
 	err = hda_tegra_create(card, driver_flags, hda);
 	if (err < 0)
 		goto out_free;

commit 4cfe99c7f9592573e85a9768cfb2a8d7a7962618
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 16 12:02:30 2015 +0200

    ALSA: hda/tegra - Fix build error and warning
    
    I seem to have failed to run the build test properly...
       sound/pci/hda/hda_tegra.c: In function 'hda_tegra_dev_free':
       sound/pci/hda/hda_tegra.c:310:20: error: 'bus' undeclared (first use in this function)
             snd_hdac_bus_exit(bus);
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index d5349809f43d..801e9fb4a467 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -102,8 +102,6 @@ static int substream_alloc_pages(struct azx *chip,
 				 struct snd_pcm_substream *substream,
 				 size_t size)
 {
-	struct azx_dev *azx_dev = get_azx_dev(substream);
-
 	return snd_pcm_lib_malloc_pages(substream, size);
 }
 
@@ -304,7 +302,7 @@ static int hda_tegra_dev_free(struct snd_device *device)
 
 	azx_free_stream_pages(chip);
 	azx_free_streams(chip);
-	snd_hdac_bus_exit(bus);
+	snd_hdac_bus_exit(azx_bus(chip));
 
 	return 0;
 }

commit 602518a21b4c0673fee2146d46be4eb2464553b2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 16 07:53:08 2015 +0200

    ALSA: hda - Minor refactoring
    
    Move the small portion of the common sequence in hda_intel.c and
    hda_tegra.c into hda_controller.c.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 397e1821020f..d5349809f43d 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -104,9 +104,6 @@ static int substream_alloc_pages(struct azx *chip,
 {
 	struct azx_dev *azx_dev = get_azx_dev(substream);
 
-	azx_dev->core.bufsize = 0;
-	azx_dev->core.period_bytes = 0;
-	azx_dev->core.format_val = 0;
 	return snd_pcm_lib_malloc_pages(substream, size);
 }
 

commit a41d122449bea303ada415ef5fb2bf434f5481f9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 14 22:13:18 2015 +0200

    ALSA: hda - Embed bus into controller object
    
    ... and replace with the existing hda-core helper codes.
    This reduces lots of lines, finally.
    
    Since struct hda_bus is now embedded into struct azx,
    snd_hda_bus_new() is moved and expanded from hda_codec.c to
    hda_controller.c, accordingly.  Also private_free bus ops and
    private_data field are removed because we no longer need to point azx
    object from bus (we can use container_of())
    
    The spin locks are consolidated into the single one, bus->reg_lock.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index c6fc96afbdc1..397e1821020f 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -285,6 +285,14 @@ static const struct dev_pm_ops hda_tegra_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(hda_tegra_suspend, hda_tegra_resume)
 };
 
+static int hda_tegra_dev_disconnect(struct snd_device *device)
+{
+	struct azx *chip = device->device_data;
+
+	chip->bus.shutdown = 1;
+	return 0;
+}
+
 /*
  * destructor
  */
@@ -292,12 +300,14 @@ static int hda_tegra_dev_free(struct snd_device *device)
 {
 	struct azx *chip = device->device_data;
 
-	if (chip->initialized) {
+	if (azx_bus(chip)->chip_init) {
 		azx_stop_all_streams(chip);
 		azx_stop_chip(chip);
 	}
 
 	azx_free_stream_pages(chip);
+	azx_free_streams(chip);
+	snd_hdac_bus_exit(bus);
 
 	return 0;
 }
@@ -305,6 +315,7 @@ static int hda_tegra_dev_free(struct snd_device *device)
 static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 {
 	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
+	struct hdac_bus *bus = azx_bus(chip);
 	struct device *dev = hda->dev;
 	struct resource *res;
 	int err;
@@ -324,9 +335,8 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 	if (IS_ERR(hda->regs))
 		return PTR_ERR(hda->regs);
 
-	chip->remap_addr = hda->regs + HDA_BAR0;
-	azx_bus(chip)->remap_addr = chip->remap_addr; /* FIXME */
-	chip->addr = res->start + HDA_BAR0;
+	bus->remap_addr = hda->regs + HDA_BAR0;
+	bus->addr = res->start + HDA_BAR0;
 
 	err = hda_tegra_enable_clocks(hda);
 	if (err)
@@ -339,6 +349,7 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 
 static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 {
+	struct hdac_bus *bus = azx_bus(chip);
 	struct snd_card *card = chip->card;
 	int err;
 	unsigned short gcap;
@@ -356,9 +367,9 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 			irq_id);
 		return err;
 	}
-	chip->irq = irq_id;
+	bus->irq = irq_id;
 
-	synchronize_irq(chip->irq);
+	synchronize_irq(bus->irq);
 
 	gcap = azx_readw(chip, GCAP);
 	dev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);
@@ -377,18 +388,20 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 	chip->playback_index_offset = chip->capture_streams;
 	chip->num_streams = chip->playback_streams + chip->capture_streams;
 
-	err = azx_alloc_stream_pages(chip);
+	/* initialize streams */
+	err = azx_init_streams(chip);
 	if (err < 0)
 		return err;
 
-	/* initialize streams */
-	azx_init_stream(chip);
+	err = azx_alloc_stream_pages(chip);
+	if (err < 0)
+		return err;
 
 	/* initialize chip */
 	azx_init_chip(chip, 1);
 
 	/* codec detection */
-	if (!chip->codec_mask) {
+	if (!bus->codec_mask) {
 		dev_err(card->dev, "no codecs found!\n");
 		return -ENODEV;
 	}
@@ -397,7 +410,7 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 	strcpy(card->shortname, "tegra-hda");
 	snprintf(card->longname, sizeof(card->longname),
 		 "%s at 0x%lx irq %i",
-		 card->shortname, chip->addr, chip->irq);
+		 card->shortname, bus->addr, bus->irq);
 
 	return 0;
 }
@@ -410,6 +423,7 @@ static int hda_tegra_create(struct snd_card *card,
 			    struct hda_tegra *hda)
 {
 	static struct snd_device_ops ops = {
+		.dev_disconnect = hda_tegra_dev_disconnect,
 		.dev_free = hda_tegra_dev_free,
 	};
 	struct azx *chip;
@@ -417,12 +431,9 @@ static int hda_tegra_create(struct snd_card *card,
 
 	chip = &hda->chip;
 
-	spin_lock_init(&chip->reg_lock);
 	mutex_init(&chip->open_mutex);
 	chip->card = card;
 	chip->ops = &hda_tegra_ops;
-	chip->io_ops = &hda_tegra_io_ops;
-	chip->irq = -1;
 	chip->driver_caps = driver_caps;
 	chip->driver_type = driver_caps & 0xff;
 	chip->dev_index = 0;
@@ -469,7 +480,7 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		return err;
 	}
 
-	err = azx_bus_create(chip, NULL);
+	err = azx_bus_init(chip, NULL, &hda_tegra_io_ops);
 	if (err < 0)
 		goto out_free;
 
@@ -498,7 +509,7 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		goto out_free;
 
 	chip->running = 1;
-	snd_hda_set_power_save(chip->bus, power_save * 1000);
+	snd_hda_set_power_save(&chip->bus, power_save * 1000);
 
 	return 0;
 

commit ccc98865aa44184e34de8df96dc837726c978949
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 14 22:06:53 2015 +0200

    ALSA: hda - Migrate more hdac_stream codes
    
    ... including dsp loader helpers.  Lots of codes removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index e25e0df7f067..c6fc96afbdc1 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -325,6 +325,7 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 		return PTR_ERR(hda->regs);
 
 	chip->remap_addr = hda->regs + HDA_BAR0;
+	azx_bus(chip)->remap_addr = chip->remap_addr; /* FIXME */
 	chip->addr = res->start + HDA_BAR0;
 
 	err = hda_tegra_enable_clocks(hda);

commit 7833c3f85b88561c245a9cb1e42eafec9dca7154
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 14 18:13:13 2015 +0200

    ALSA: hda - Migrate hdac_stream into legacy driver
    
    Embed hdac_stream object into azx_dev, and use a few basic helper
    functions.  The most of helper codes for hdac_stream aren't still used
    yet.
    
    Also this commit disables the tracepoints temporarily due to build
    problems.  It'll be enabled again later.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index b150cb50961c..e25e0df7f067 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -104,9 +104,9 @@ static int substream_alloc_pages(struct azx *chip,
 {
 	struct azx_dev *azx_dev = get_azx_dev(substream);
 
-	azx_dev->bufsize = 0;
-	azx_dev->period_bytes = 0;
-	azx_dev->format_val = 0;
+	azx_dev->core.bufsize = 0;
+	azx_dev->core.period_bytes = 0;
+	azx_dev->core.format_val = 0;
 	return snd_pcm_lib_malloc_pages(substream, size);
 }
 
@@ -290,12 +290,10 @@ static const struct dev_pm_ops hda_tegra_pm = {
  */
 static int hda_tegra_dev_free(struct snd_device *device)
 {
-	int i;
 	struct azx *chip = device->device_data;
 
 	if (chip->initialized) {
-		for (i = 0; i < chip->num_streams; i++)
-			azx_stream_stop(chip, &chip->azx_dev[i]);
+		azx_stop_all_streams(chip);
 		azx_stop_chip(chip);
 	}
 
@@ -377,10 +375,6 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 	chip->capture_index_offset = 0;
 	chip->playback_index_offset = chip->capture_streams;
 	chip->num_streams = chip->playback_streams + chip->capture_streams;
-	chip->azx_dev = devm_kcalloc(card->dev, chip->num_streams,
-				     sizeof(*chip->azx_dev), GFP_KERNEL);
-	if (!chip->azx_dev)
-		return -ENOMEM;
 
 	err = azx_alloc_stream_pages(chip);
 	if (err < 0)

commit a43ff5baa55ff87268a67b45c6f6cb261c023db1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 14 17:26:00 2015 +0200

    ALSA: hda - Pass bus io_ops directly from the top-level driver
    
    One less redirection again.  This also requires the change of the call
    order in the toplevel divers.  Namely, the bus has to be created at
    first before other initializations since the memory allocation ops are
    called through bus object now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 2e4fd5c56d3b..b150cb50961c 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -87,13 +87,13 @@ MODULE_PARM_DESC(power_save,
 /*
  * DMA page allocation ops.
  */
-static int dma_alloc_pages(struct azx *chip, int type, size_t size,
+static int dma_alloc_pages(struct hdac_bus *bus, int type, size_t size,
 			   struct snd_dma_buffer *buf)
 {
-	return snd_dma_alloc_pages(type, chip->card->dev, size, buf);
+	return snd_dma_alloc_pages(type, bus->dev, size, buf);
 }
 
-static void dma_free_pages(struct azx *chip, struct snd_dma_buffer *buf)
+static void dma_free_pages(struct hdac_bus *bus, struct snd_dma_buffer *buf)
 {
 	snd_dma_free_pages(buf);
 }
@@ -173,7 +173,7 @@ static u8 hda_tegra_readb(u8 *addr)
 	return (v >> shift) & 0xff;
 }
 
-static const struct hda_controller_ops hda_tegra_ops = {
+static const struct hdac_io_ops hda_tegra_io_ops = {
 	.reg_writel = hda_tegra_writel,
 	.reg_readl = hda_tegra_readl,
 	.reg_writew = hda_tegra_writew,
@@ -182,6 +182,9 @@ static const struct hda_controller_ops hda_tegra_ops = {
 	.reg_readb = hda_tegra_readb,
 	.dma_alloc_pages = dma_alloc_pages,
 	.dma_free_pages = dma_free_pages,
+};
+
+static const struct hda_controller_ops hda_tegra_ops = {
 	.substream_alloc_pages = substream_alloc_pages,
 	.substream_free_pages = substream_free_pages,
 };
@@ -409,7 +412,6 @@ static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
  */
 static int hda_tegra_create(struct snd_card *card,
 			    unsigned int driver_caps,
-			    const struct hda_controller_ops *hda_ops,
 			    struct hda_tegra *hda)
 {
 	static struct snd_device_ops ops = {
@@ -423,7 +425,8 @@ static int hda_tegra_create(struct snd_card *card,
 	spin_lock_init(&chip->reg_lock);
 	mutex_init(&chip->open_mutex);
 	chip->card = card;
-	chip->ops = hda_ops;
+	chip->ops = &hda_tegra_ops;
+	chip->io_ops = &hda_tegra_io_ops;
 	chip->irq = -1;
 	chip->driver_caps = driver_caps;
 	chip->driver_type = driver_caps & 0xff;
@@ -471,7 +474,11 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		return err;
 	}
 
-	err = hda_tegra_create(card, driver_flags, &hda_tegra_ops, hda);
+	err = azx_bus_create(chip, NULL);
+	if (err < 0)
+		goto out_free;
+
+	err = hda_tegra_create(card, driver_flags, hda);
 	if (err < 0)
 		goto out_free;
 	card->private_data = chip;
@@ -483,10 +490,6 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		goto out_free;
 
 	/* create codec instances */
-	err = azx_bus_create(chip, NULL);
-	if (err < 0)
-		goto out_free;
-
 	err = azx_probe_codecs(chip, 0);
 	if (err < 0)
 		goto out_free;

commit b2a0bafa758256442e04d1f34d6d0746b846d23d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 5 17:21:32 2015 +0100

    ALSA: hda - Use shutdown driver ops instead of reboot notifier
    
    The driver shutdown ops is simpler than registering reboot notifier
    manually.  There should be no functional change by this -- the codec
    driver calls its own callback while the bus driver just calls
    azx_stop() like before.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 7586abe91dfb..2e4fd5c56d3b 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -290,8 +290,6 @@ static int hda_tegra_dev_free(struct snd_device *device)
 	int i;
 	struct azx *chip = device->device_data;
 
-	azx_notifier_unregister(chip);
-
 	if (chip->initialized) {
 		for (i = 0; i < chip->num_streams; i++)
 			azx_stream_stop(chip, &chip->azx_dev[i]);
@@ -502,7 +500,6 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		goto out_free;
 
 	chip->running = 1;
-	azx_notifier_register(chip);
 	snd_hda_set_power_save(chip->bus, power_save * 1000);
 
 	return 0;
@@ -517,6 +514,18 @@ static int hda_tegra_remove(struct platform_device *pdev)
 	return snd_card_free(dev_get_drvdata(&pdev->dev));
 }
 
+static void hda_tegra_shutdown(struct platform_device *pdev)
+{
+	struct snd_card *card = dev_get_drvdata(&pdev->dev);
+	struct azx *chip;
+
+	if (!card)
+		return;
+	chip = card->private_data;
+	if (chip && chip->running)
+		azx_stop_chip(chip);
+}
+
 static struct platform_driver tegra_platform_hda = {
 	.driver = {
 		.name = "tegra-hda",
@@ -525,6 +534,7 @@ static struct platform_driver tegra_platform_hda = {
 	},
 	.probe = hda_tegra_probe,
 	.remove = hda_tegra_remove,
+	.shutdown = hda_tegra_shutdown,
 };
 module_platform_driver(tegra_platform_hda);
 

commit bcd96557bd0ab1129fcdde073d5700aed8fcb942
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 27 20:44:54 2015 +0100

    ALSA: hda - Build PCMs and controls at codec driver probe
    
    This makes the code flow easier -- instead of the controller driver
    calling snd_hda_build_pcms() and snd_hda_build_controls() explicitly,
    the codec driver itself builds PCMs and controls at probe time.  Then
    the controller driver only needs to call snd_card_register().
    
    Also, this allows us the full bind/unbind control, too.  Even when a
    codec driver is bound later, it automatically registers the new PCM
    and controls by itself.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 1359fdd20f02..7586abe91dfb 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -497,16 +497,6 @@ static int hda_tegra_probe(struct platform_device *pdev)
 	if (err < 0)
 		goto out_free;
 
-	/* create PCM streams */
-	err = snd_hda_build_pcms(chip->bus);
-	if (err < 0)
-		goto out_free;
-
-	/* create mixer controls */
-	err = snd_hda_build_controls(chip->bus);
-	if (err < 0)
-		goto out_free;
-
 	err = snd_card_register(chip->card);
 	if (err < 0)
 		goto out_free;

commit 709949fbe9632941585dcacabc8a66010030ed10
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 20 09:58:14 2015 +0100

    ALSA: hda - Power down codec automatically at registration
    
    So far, we let the controller driver power down the all codecs at the
    end of probe.  But this can be done better in the codec's dev_register
    callback.  This results in the reduction of duplicated codes in each
    control driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 42bc17655df0..1359fdd20f02 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -337,17 +337,6 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 	return 0;
 }
 
-/*
- * The codecs were powered up in snd_hda_codec_new().
- * Now all initialization done, so turn them down if possible
- */
-static void power_down_all_codecs(struct azx *chip)
-{
-	struct hda_codec *codec;
-	list_for_each_entry(codec, &chip->bus->codec_list, list)
-		snd_hda_power_down(codec);
-}
-
 static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
 {
 	struct snd_card *card = chip->card;
@@ -523,7 +512,6 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		goto out_free;
 
 	chip->running = 1;
-	power_down_all_codecs(chip);
 	azx_notifier_register(chip);
 	snd_hda_set_power_save(chip->bus, power_save * 1000);
 

commit bb573928e187fc5b1f91c3a7684791d5dfcca640
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 20 09:26:04 2015 +0100

    ALSA: hda - Drop power_save value indirection in hda_bus
    
    We used to pass the power_save option value to hda_bus via a given
    pointer.  This was needed to refer to the value from the HD-audio core
    side.  However, after the transition to the runtime PM, this is no
    longer needed.
    
    This patch drops the power_save value indirection in hda_bus above,
    and let the controller driver reprograms the autosuspend value
    explicitly by a new helper, snd_hda_set_power_save().  Without this
    call, the HD-audio core doesn't set up the autosuspend and flip the
    runtime PM.  (User may still be able to set up via sysfs, though.)
    
    Along with this change, the pointer argument of azx_bus_create() is
    dropped as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index f6949e413a50..42bc17655df0 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -81,7 +81,7 @@ module_param(power_save, bint, 0644);
 MODULE_PARM_DESC(power_save,
 		 "Automatic power-saving timeout (in seconds, 0 = disable).");
 #else
-static int power_save = 0;
+#define power_save	0
 #endif
 
 /*
@@ -496,7 +496,7 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		goto out_free;
 
 	/* create codec instances */
-	err = azx_bus_create(chip, NULL, &power_save);
+	err = azx_bus_create(chip, NULL);
 	if (err < 0)
 		goto out_free;
 
@@ -525,6 +525,7 @@ static int hda_tegra_probe(struct platform_device *pdev)
 	chip->running = 1;
 	power_down_all_codecs(chip);
 	azx_notifier_register(chip);
+	snd_hda_set_power_save(chip->bus, power_save * 1000);
 
 	return 0;
 

commit 59ed1eade1d6ec24751baca99305f9713a5d779e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 18 15:39:59 2015 +0100

    ALSA: hda - Move codec suspend/resume to codec driver
    
    This patch moves the suspend/resume mechanisms down to each codec
    driver level, as we have a proper codec driver bound on the bus now.
    Then we get the asynchronous PM gratis without fiddling much in the
    driver level.
    
    As a soft-landing transition, implement the common suspend/resume pm
    ops for hda_codec_driver and keep the each codec driver intact.  Only
    the callers of suspend/resume in the controller side (azx_suspend()
    and azx_resume()) are removed.
    
    Another involved place is azx_bus_reset() calling the temporary
    suspend and resume as a hackish method of bus reset.  The HD-audio
    core provide a helper function snd_hda_bus_reset() instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 1bd7a9e04046..f6949e413a50 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -249,14 +249,9 @@ static int hda_tegra_suspend(struct device *dev)
 {
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct azx *chip = card->private_data;
-	struct azx_pcm *p;
 	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	list_for_each_entry(p, &chip->pcm_list, list)
-		snd_pcm_suspend_all(p->pcm);
-	if (chip->initialized)
-		snd_hda_suspend(chip->bus);
 
 	azx_stop_chip(chip);
 	azx_enter_link_reset(chip);
@@ -277,7 +272,6 @@ static int hda_tegra_resume(struct device *dev)
 
 	azx_init_chip(chip, 1);
 
-	snd_hda_resume(chip->bus);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 
 	return 0;

commit 96d2bd6e3cdf57926f80605d6e28051bb6b24eb3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 19 18:12:22 2015 +0100

    ALSA: hda - Split azx_codec_create() to two phases
    
    azx_create_codec() function does actually two things: create a bus and
    probe codecs.  For the future work, split this to two logical
    functions, azx_bus_create() and azx_probe_codecs().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index f305c2a99206..1bd7a9e04046 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -502,7 +502,11 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		goto out_free;
 
 	/* create codec instances */
-	err = azx_codec_create(chip, NULL, 0, &power_save);
+	err = azx_bus_create(chip, NULL, &power_save);
+	if (err < 0)
+		goto out_free;
+
+	err = azx_probe_codecs(chip, 0);
 	if (err < 0)
 		goto out_free;
 

commit b8f28d53641f13902790904ab15028ff8ecd0882
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 19 18:06:45 2015 +0100

    ALSA: hda - Drop azx_mixer_create()
    
    It's just an indirection, so let the caller directly calling
    snd_hda_build_controls().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 7d0d04480f48..f305c2a99206 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -516,7 +516,7 @@ static int hda_tegra_probe(struct platform_device *pdev)
 		goto out_free;
 
 	/* create mixer controls */
-	err = azx_mixer_create(chip);
+	err = snd_hda_build_controls(chip->bus);
 	if (err < 0)
 		goto out_free;
 

commit 89a93fea6182a71cedce9de1d901e4f379322cf3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 19 18:04:17 2015 +0100

    ALSA: hda - Fold hda_priv.h into hda_controller.h
    
    There is no big reason to keep them separately.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 375e94f4cf52..7d0d04480f48 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -37,7 +37,6 @@
 
 #include "hda_codec.h"
 #include "hda_controller.h"
-#include "hda_priv.h"
 
 /* Defines for Nvidia Tegra HDA support */
 #define HDA_BAR0           0x8000

commit 93ceaa303b2946453b925c55dc28a4273520dd18
Author: Eliot Blennerhassett <eliot@blennerhassett.gen.nz>
Date:   Sat Feb 14 15:32:24 2015 +1300

    ALSA: hda/tegra check correct return value from ioremap_resource
    
    Signed-off-by: Eliot Blennerhassett <eliot@blennerhassett.gen.nz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 227990bc02e3..375e94f4cf52 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -329,8 +329,8 @@ static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	hda->regs = devm_ioremap_resource(dev, res);
-	if (IS_ERR(chip->remap_addr))
-		return PTR_ERR(chip->remap_addr);
+	if (IS_ERR(hda->regs))
+		return PTR_ERR(hda->regs);
 
 	chip->remap_addr = hda->regs + HDA_BAR0;
 	chip->addr = res->start + HDA_BAR0;

commit 1618e84aa87af94b46921b265b68bb7994571c20
Merge: 03fe805a0984 4da63c6fc426
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 15 15:27:19 2014 +0200

    Merge branch 'for-linus' into for-next
    
    Since init_failed flag was moved to struct hda_intel, its access in
    the commit [4da63c6f: ALSA: hda - Fix broken PM due to incomplete
    i915 initialization] is also replaced with hda->init_failed
    appropriately.

commit 525549d7342fca7fca9fc11298b5ab3617b6f730
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jul 7 15:13:12 2014 +0200

    ALSA: hda: Fix build warning
    
    The hda_tegra_disable_clocks() function is only used by the suspend and
    resume code, so it needs to be included in the #ifdef CONFIG_PM_SLEEP
    block to prevent the following warning:
    
      CC      sound/pci/hda/hda_tegra.o
    sound/pci/hda/hda_tegra.c:238:13: warning: 'hda_tegra_disable_clocks' defined but not used [-Wunused-function]
     static void hda_tegra_disable_clocks(struct hda_tegra *data)
                 ^
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index a366ba9293a8..358414da6418 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -236,6 +236,7 @@ static int hda_tegra_enable_clocks(struct hda_tegra *data)
 	return rc;
 }
 
+#ifdef CONFIG_PM_SLEEP
 static void hda_tegra_disable_clocks(struct hda_tegra *data)
 {
 	clk_disable_unprepare(data->hda2hdmi_clk);
@@ -243,7 +244,6 @@ static void hda_tegra_disable_clocks(struct hda_tegra *data)
 	clk_disable_unprepare(data->hda_clk);
 }
 
-#ifdef CONFIG_PM_SLEEP
 /*
  * power management
  */

commit d5471e67229adb31a1e5f026955d006f06315f3d
Author: Sachin Kamat <sachin.kamat@samsung.com>
Date:   Tue Jul 1 17:02:54 2014 +0530

    ALSA: hda: Remove unused variable
    
    'status' is not used in the function. Remove it.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Tested-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index cc4a923f68e3..dc4bb21ed17b 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -271,13 +271,9 @@ static int hda_tegra_resume(struct device *dev)
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct azx *chip = card->private_data;
 	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
-	int status;
 
 	hda_tegra_enable_clocks(hda);
 
-	/* Read STATESTS before controller reset */
-	status = azx_readw(chip, STATESTS);
-
 	hda_tegra_init(hda);
 
 	azx_init_chip(chip, 1);

commit 178942b69f4eb695bfb92742b6082052d6730ca0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 1 13:59:40 2014 +0200

    ALSA: hda - Fix build error in hda_tegra.c
    
    The "list" field has been omitted from struct azx, but its
    initialization remained mistakenly in hda_tegra.c, which leads to a
    compile error:
       sound/pci/hda/hda_tegra.c: In function 'hda_tegra_create':
       sound/pci/hda/hda_tegra.c:481:22: error: 'struct azx' has no member
    named 'list'
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Fixes: 9a34af4a3327 ('ALSA: hda - Move more PCI-controller-specific stuff from generic code')
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index cf69dafa91c0..cc4a923f68e3 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -453,7 +453,6 @@ static int hda_tegra_create(struct snd_card *card,
 	chip->driver_type = driver_caps & 0xff;
 	chip->dev_index = 0;
 	INIT_LIST_HEAD(&chip->pcm_list);
-	INIT_LIST_HEAD(&chip->list);
 
 	chip->codec_probe_mask = -1;
 

commit 703c759f38cce7950ab460552236ca1d15adb916
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jun 26 17:24:45 2014 +0200

    ALSA: hda - Use common reboot notifier
    
    The very same notifier code is used in both hda_intel.c and
    hda_tegra.c.  Move it to the generic code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 12920b99d238..cf69dafa91c0 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -29,7 +29,6 @@
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
 #include <linux/of_device.h>
-#include <linux/reboot.h>
 #include <linux/slab.h>
 #include <linux/time.h>
 
@@ -294,30 +293,6 @@ static const struct dev_pm_ops hda_tegra_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(hda_tegra_suspend, hda_tegra_resume)
 };
 
-/*
- * reboot notifier for hang-up problem at power-down
- */
-static int hda_tegra_halt(struct notifier_block *nb, unsigned long event,
-			  void *buf)
-{
-	struct azx *chip = container_of(nb, struct azx, reboot_notifier);
-	snd_hda_bus_reboot_notify(chip->bus);
-	azx_stop_chip(chip);
-	return NOTIFY_OK;
-}
-
-static void hda_tegra_notifier_register(struct azx *chip)
-{
-	chip->reboot_notifier.notifier_call = hda_tegra_halt;
-	register_reboot_notifier(&chip->reboot_notifier);
-}
-
-static void hda_tegra_notifier_unregister(struct azx *chip)
-{
-	if (chip->reboot_notifier.notifier_call)
-		unregister_reboot_notifier(&chip->reboot_notifier);
-}
-
 /*
  * destructor
  */
@@ -326,7 +301,7 @@ static int hda_tegra_dev_free(struct snd_device *device)
 	int i;
 	struct azx *chip = device->device_data;
 
-	hda_tegra_notifier_unregister(chip);
+	azx_notifier_unregister(chip);
 
 	if (chip->initialized) {
 		for (i = 0; i < chip->num_streams; i++)
@@ -557,7 +532,7 @@ static int hda_tegra_probe(struct platform_device *pdev)
 
 	chip->running = 1;
 	power_down_all_codecs(chip);
-	hda_tegra_notifier_register(chip);
+	azx_notifier_register(chip);
 
 	return 0;
 

commit b6050ef664219a0bc97d0626759ef070ed77fcba
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jun 26 16:50:16 2014 +0200

    ALSA: hda - Make position_fix as generic callback
    
    ... and move most parts into hda_intel.c from the generic controller
    code.  This is a clean up, and there should be no functional change by
    this patch.
    
    Now, struct azx obtains the generic callbacks for getting the position
    and the delay.  As default NULL, posbuf is read.  These replace the
    old position_fix[], and each is implemented as a callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index a366ba9293a8..12920b99d238 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -480,8 +480,6 @@ static int hda_tegra_create(struct snd_card *card,
 	INIT_LIST_HEAD(&chip->pcm_list);
 	INIT_LIST_HEAD(&chip->list);
 
-	chip->position_fix[0] = POS_FIX_AUTO;
-	chip->position_fix[1] = POS_FIX_AUTO;
 	chip->codec_probe_mask = -1;
 
 	chip->single_cmd = false;

commit 16c2395203c30046cb9df43c2c28a7a968e449ac
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 26 21:15:20 2014 +0200

    ALSA: hda: fix tegra build
    
    When CONFIG_PM is disabled, the CONFIG_SND_HDA_POWER_SAVE_DEFAULT symbol
    does not get defined, which causes a build error for the hda-tegra driver:
    
    hda/hda_tegra.c:80:25: error: 'CONFIG_SND_HDA_POWER_SAVE_DEFAULT' undeclared here (not in a function)
     static int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;
                             ^
    /git/arm-soc/sound/pci/hda/hda_tegra.c:235:13: warning: 'hda_tegra_disable_clocks' defined but not used [-Wunused-function]
     static void hda_tegra_disable_clocks(struct hda_tegra *data)
                 ^
    
    This works around the problem by not referencing that macro
    when CONFIG_PM is disabled. Instead, we assume that it's disabled
    unconditionally and cannot be enabled at runtime.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Dylan Reid <dgreid@chromium.org>
    Cc: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index 086fd062257c..a366ba9293a8 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -77,10 +77,14 @@ struct hda_tegra {
 	void __iomem *regs;
 };
 
+#ifdef CONFIG_PM
 static int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;
 module_param(power_save, bint, 0644);
 MODULE_PARM_DESC(power_save,
 		 "Automatic power-saving timeout (in seconds, 0 = disable).");
+#else
+static int power_save = 0;
+#endif
 
 /*
  * DMA page allocation ops.

commit f73387cb6b1f1534e56669e6aecefae1be867f59
Author: Dylan Reid <dgreid@chromium.org>
Date:   Tue May 20 11:26:12 2014 -0700

    ALSA: hda/tegra - Fix MODULE_DEVICE_TABLE typo.
    
    I missed a rename during the review process.  Fix the
    MODULE_DEVICE_TABLE to match the structure.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
index e472bc882fc1..086fd062257c 100644
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@ -496,7 +496,7 @@ static const struct of_device_id hda_tegra_match[] = {
 	{ .compatible = "nvidia,tegra30-hda" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, tegra_platform_hda_match);
+MODULE_DEVICE_TABLE(of, hda_tegra_match);
 
 static int hda_tegra_probe(struct platform_device *pdev)
 {

commit 3c320f3f5649667874d754e59bdd84dab185fe04
Author: Dylan Reid <dgreid@chromium.org>
Date:   Mon May 19 19:18:27 2014 -0700

    ALSA: hda - Add driver for Tegra SoC HDA
    
    This adds a driver for the HDA block in Tegra SoCs.  The HDA bus is
    used to communicate with the HDMI codec on Tegra124.
    
    Most of the code is re-used from the Intel/PCI HDA driver.  It brings
    over only two of the module params, power_save and probe_mask.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_tegra.c b/sound/pci/hda/hda_tegra.c
new file mode 100644
index 000000000000..e472bc882fc1
--- /dev/null
+++ b/sound/pci/hda/hda_tegra.c
@@ -0,0 +1,584 @@
+/*
+ *
+ * Implementation of primary ALSA driver code base for NVIDIA Tegra HDA.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/clocksource.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/of_device.h>
+#include <linux/reboot.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+
+#include <sound/core.h>
+#include <sound/initval.h>
+
+#include "hda_codec.h"
+#include "hda_controller.h"
+#include "hda_priv.h"
+
+/* Defines for Nvidia Tegra HDA support */
+#define HDA_BAR0           0x8000
+
+#define HDA_CFG_CMD        0x1004
+#define HDA_CFG_BAR0       0x1010
+
+#define HDA_ENABLE_IO_SPACE       (1 << 0)
+#define HDA_ENABLE_MEM_SPACE      (1 << 1)
+#define HDA_ENABLE_BUS_MASTER     (1 << 2)
+#define HDA_ENABLE_SERR           (1 << 8)
+#define HDA_DISABLE_INTR          (1 << 10)
+#define HDA_BAR0_INIT_PROGRAM     0xFFFFFFFF
+#define HDA_BAR0_FINAL_PROGRAM    (1 << 14)
+
+/* IPFS */
+#define HDA_IPFS_CONFIG           0x180
+#define HDA_IPFS_EN_FPCI          0x1
+
+#define HDA_IPFS_FPCI_BAR0        0x80
+#define HDA_FPCI_BAR0_START       0x40
+
+#define HDA_IPFS_INTR_MASK        0x188
+#define HDA_IPFS_EN_INTR          (1 << 16)
+
+/* max number of SDs */
+#define NUM_CAPTURE_SD 1
+#define NUM_PLAYBACK_SD 1
+
+struct hda_tegra {
+	struct azx chip;
+	struct device *dev;
+	struct clk *hda_clk;
+	struct clk *hda2codec_2x_clk;
+	struct clk *hda2hdmi_clk;
+	void __iomem *regs;
+};
+
+static int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;
+module_param(power_save, bint, 0644);
+MODULE_PARM_DESC(power_save,
+		 "Automatic power-saving timeout (in seconds, 0 = disable).");
+
+/*
+ * DMA page allocation ops.
+ */
+static int dma_alloc_pages(struct azx *chip, int type, size_t size,
+			   struct snd_dma_buffer *buf)
+{
+	return snd_dma_alloc_pages(type, chip->card->dev, size, buf);
+}
+
+static void dma_free_pages(struct azx *chip, struct snd_dma_buffer *buf)
+{
+	snd_dma_free_pages(buf);
+}
+
+static int substream_alloc_pages(struct azx *chip,
+				 struct snd_pcm_substream *substream,
+				 size_t size)
+{
+	struct azx_dev *azx_dev = get_azx_dev(substream);
+
+	azx_dev->bufsize = 0;
+	azx_dev->period_bytes = 0;
+	azx_dev->format_val = 0;
+	return snd_pcm_lib_malloc_pages(substream, size);
+}
+
+static int substream_free_pages(struct azx *chip,
+				struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/*
+ * Register access ops. Tegra HDA register access is DWORD only.
+ */
+static void hda_tegra_writel(u32 value, u32 *addr)
+{
+	writel(value, addr);
+}
+
+static u32 hda_tegra_readl(u32 *addr)
+{
+	return readl(addr);
+}
+
+static void hda_tegra_writew(u16 value, u16 *addr)
+{
+	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
+	void *dword_addr = (void *)((unsigned long)(addr) & ~0x3);
+	u32 v;
+
+	v = readl(dword_addr);
+	v &= ~(0xffff << shift);
+	v |= value << shift;
+	writel(v, dword_addr);
+}
+
+static u16 hda_tegra_readw(u16 *addr)
+{
+	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
+	void *dword_addr = (void *)((unsigned long)(addr) & ~0x3);
+	u32 v;
+
+	v = readl(dword_addr);
+	return (v >> shift) & 0xffff;
+}
+
+static void hda_tegra_writeb(u8 value, u8 *addr)
+{
+	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
+	void *dword_addr = (void *)((unsigned long)(addr) & ~0x3);
+	u32 v;
+
+	v = readl(dword_addr);
+	v &= ~(0xff << shift);
+	v |= value << shift;
+	writel(v, dword_addr);
+}
+
+static u8 hda_tegra_readb(u8 *addr)
+{
+	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
+	void *dword_addr = (void *)((unsigned long)(addr) & ~0x3);
+	u32 v;
+
+	v = readl(dword_addr);
+	return (v >> shift) & 0xff;
+}
+
+static const struct hda_controller_ops hda_tegra_ops = {
+	.reg_writel = hda_tegra_writel,
+	.reg_readl = hda_tegra_readl,
+	.reg_writew = hda_tegra_writew,
+	.reg_readw = hda_tegra_readw,
+	.reg_writeb = hda_tegra_writeb,
+	.reg_readb = hda_tegra_readb,
+	.dma_alloc_pages = dma_alloc_pages,
+	.dma_free_pages = dma_free_pages,
+	.substream_alloc_pages = substream_alloc_pages,
+	.substream_free_pages = substream_free_pages,
+};
+
+static void hda_tegra_init(struct hda_tegra *hda)
+{
+	u32 v;
+
+	/* Enable PCI access */
+	v = readl(hda->regs + HDA_IPFS_CONFIG);
+	v |= HDA_IPFS_EN_FPCI;
+	writel(v, hda->regs + HDA_IPFS_CONFIG);
+
+	/* Enable MEM/IO space and bus master */
+	v = readl(hda->regs + HDA_CFG_CMD);
+	v &= ~HDA_DISABLE_INTR;
+	v |= HDA_ENABLE_MEM_SPACE | HDA_ENABLE_IO_SPACE |
+		HDA_ENABLE_BUS_MASTER | HDA_ENABLE_SERR;
+	writel(v, hda->regs + HDA_CFG_CMD);
+
+	writel(HDA_BAR0_INIT_PROGRAM, hda->regs + HDA_CFG_BAR0);
+	writel(HDA_BAR0_FINAL_PROGRAM, hda->regs + HDA_CFG_BAR0);
+	writel(HDA_FPCI_BAR0_START, hda->regs + HDA_IPFS_FPCI_BAR0);
+
+	v = readl(hda->regs + HDA_IPFS_INTR_MASK);
+	v |= HDA_IPFS_EN_INTR;
+	writel(v, hda->regs + HDA_IPFS_INTR_MASK);
+}
+
+static int hda_tegra_enable_clocks(struct hda_tegra *data)
+{
+	int rc;
+
+	rc = clk_prepare_enable(data->hda_clk);
+	if (rc)
+		return rc;
+	rc = clk_prepare_enable(data->hda2codec_2x_clk);
+	if (rc)
+		goto disable_hda;
+	rc = clk_prepare_enable(data->hda2hdmi_clk);
+	if (rc)
+		goto disable_codec_2x;
+
+	return 0;
+
+disable_codec_2x:
+	clk_disable_unprepare(data->hda2codec_2x_clk);
+disable_hda:
+	clk_disable_unprepare(data->hda_clk);
+	return rc;
+}
+
+static void hda_tegra_disable_clocks(struct hda_tegra *data)
+{
+	clk_disable_unprepare(data->hda2hdmi_clk);
+	clk_disable_unprepare(data->hda2codec_2x_clk);
+	clk_disable_unprepare(data->hda_clk);
+}
+
+#ifdef CONFIG_PM_SLEEP
+/*
+ * power management
+ */
+static int hda_tegra_suspend(struct device *dev)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+	struct azx_pcm *p;
+	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	list_for_each_entry(p, &chip->pcm_list, list)
+		snd_pcm_suspend_all(p->pcm);
+	if (chip->initialized)
+		snd_hda_suspend(chip->bus);
+
+	azx_stop_chip(chip);
+	azx_enter_link_reset(chip);
+	hda_tegra_disable_clocks(hda);
+
+	return 0;
+}
+
+static int hda_tegra_resume(struct device *dev)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
+	int status;
+
+	hda_tegra_enable_clocks(hda);
+
+	/* Read STATESTS before controller reset */
+	status = azx_readw(chip, STATESTS);
+
+	hda_tegra_init(hda);
+
+	azx_init_chip(chip, 1);
+
+	snd_hda_resume(chip->bus);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops hda_tegra_pm = {
+	SET_SYSTEM_SLEEP_PM_OPS(hda_tegra_suspend, hda_tegra_resume)
+};
+
+/*
+ * reboot notifier for hang-up problem at power-down
+ */
+static int hda_tegra_halt(struct notifier_block *nb, unsigned long event,
+			  void *buf)
+{
+	struct azx *chip = container_of(nb, struct azx, reboot_notifier);
+	snd_hda_bus_reboot_notify(chip->bus);
+	azx_stop_chip(chip);
+	return NOTIFY_OK;
+}
+
+static void hda_tegra_notifier_register(struct azx *chip)
+{
+	chip->reboot_notifier.notifier_call = hda_tegra_halt;
+	register_reboot_notifier(&chip->reboot_notifier);
+}
+
+static void hda_tegra_notifier_unregister(struct azx *chip)
+{
+	if (chip->reboot_notifier.notifier_call)
+		unregister_reboot_notifier(&chip->reboot_notifier);
+}
+
+/*
+ * destructor
+ */
+static int hda_tegra_dev_free(struct snd_device *device)
+{
+	int i;
+	struct azx *chip = device->device_data;
+
+	hda_tegra_notifier_unregister(chip);
+
+	if (chip->initialized) {
+		for (i = 0; i < chip->num_streams; i++)
+			azx_stream_stop(chip, &chip->azx_dev[i]);
+		azx_stop_chip(chip);
+	}
+
+	azx_free_stream_pages(chip);
+
+	return 0;
+}
+
+static int hda_tegra_init_chip(struct azx *chip, struct platform_device *pdev)
+{
+	struct hda_tegra *hda = container_of(chip, struct hda_tegra, chip);
+	struct device *dev = hda->dev;
+	struct resource *res;
+	int err;
+
+	hda->hda_clk = devm_clk_get(dev, "hda");
+	if (IS_ERR(hda->hda_clk))
+		return PTR_ERR(hda->hda_clk);
+	hda->hda2codec_2x_clk = devm_clk_get(dev, "hda2codec_2x");
+	if (IS_ERR(hda->hda2codec_2x_clk))
+		return PTR_ERR(hda->hda2codec_2x_clk);
+	hda->hda2hdmi_clk = devm_clk_get(dev, "hda2hdmi");
+	if (IS_ERR(hda->hda2hdmi_clk))
+		return PTR_ERR(hda->hda2hdmi_clk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hda->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(chip->remap_addr))
+		return PTR_ERR(chip->remap_addr);
+
+	chip->remap_addr = hda->regs + HDA_BAR0;
+	chip->addr = res->start + HDA_BAR0;
+
+	err = hda_tegra_enable_clocks(hda);
+	if (err)
+		return err;
+
+	hda_tegra_init(hda);
+
+	return 0;
+}
+
+/*
+ * The codecs were powered up in snd_hda_codec_new().
+ * Now all initialization done, so turn them down if possible
+ */
+static void power_down_all_codecs(struct azx *chip)
+{
+	struct hda_codec *codec;
+	list_for_each_entry(codec, &chip->bus->codec_list, list)
+		snd_hda_power_down(codec);
+}
+
+static int hda_tegra_first_init(struct azx *chip, struct platform_device *pdev)
+{
+	struct snd_card *card = chip->card;
+	int err;
+	unsigned short gcap;
+	int irq_id = platform_get_irq(pdev, 0);
+
+	err = hda_tegra_init_chip(chip, pdev);
+	if (err)
+		return err;
+
+	err = devm_request_irq(chip->card->dev, irq_id, azx_interrupt,
+			     IRQF_SHARED, KBUILD_MODNAME, chip);
+	if (err) {
+		dev_err(chip->card->dev,
+			"unable to request IRQ %d, disabling device\n",
+			irq_id);
+		return err;
+	}
+	chip->irq = irq_id;
+
+	synchronize_irq(chip->irq);
+
+	gcap = azx_readw(chip, GCAP);
+	dev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);
+
+	/* read number of streams from GCAP register instead of using
+	 * hardcoded value
+	 */
+	chip->capture_streams = (gcap >> 8) & 0x0f;
+	chip->playback_streams = (gcap >> 12) & 0x0f;
+	if (!chip->playback_streams && !chip->capture_streams) {
+		/* gcap didn't give any info, switching to old method */
+		chip->playback_streams = NUM_PLAYBACK_SD;
+		chip->capture_streams = NUM_CAPTURE_SD;
+	}
+	chip->capture_index_offset = 0;
+	chip->playback_index_offset = chip->capture_streams;
+	chip->num_streams = chip->playback_streams + chip->capture_streams;
+	chip->azx_dev = devm_kcalloc(card->dev, chip->num_streams,
+				     sizeof(*chip->azx_dev), GFP_KERNEL);
+	if (!chip->azx_dev)
+		return -ENOMEM;
+
+	err = azx_alloc_stream_pages(chip);
+	if (err < 0)
+		return err;
+
+	/* initialize streams */
+	azx_init_stream(chip);
+
+	/* initialize chip */
+	azx_init_chip(chip, 1);
+
+	/* codec detection */
+	if (!chip->codec_mask) {
+		dev_err(card->dev, "no codecs found!\n");
+		return -ENODEV;
+	}
+
+	strcpy(card->driver, "tegra-hda");
+	strcpy(card->shortname, "tegra-hda");
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s at 0x%lx irq %i",
+		 card->shortname, chip->addr, chip->irq);
+
+	return 0;
+}
+
+/*
+ * constructor
+ */
+static int hda_tegra_create(struct snd_card *card,
+			    unsigned int driver_caps,
+			    const struct hda_controller_ops *hda_ops,
+			    struct hda_tegra *hda)
+{
+	static struct snd_device_ops ops = {
+		.dev_free = hda_tegra_dev_free,
+	};
+	struct azx *chip;
+	int err;
+
+	chip = &hda->chip;
+
+	spin_lock_init(&chip->reg_lock);
+	mutex_init(&chip->open_mutex);
+	chip->card = card;
+	chip->ops = hda_ops;
+	chip->irq = -1;
+	chip->driver_caps = driver_caps;
+	chip->driver_type = driver_caps & 0xff;
+	chip->dev_index = 0;
+	INIT_LIST_HEAD(&chip->pcm_list);
+	INIT_LIST_HEAD(&chip->list);
+
+	chip->position_fix[0] = POS_FIX_AUTO;
+	chip->position_fix[1] = POS_FIX_AUTO;
+	chip->codec_probe_mask = -1;
+
+	chip->single_cmd = false;
+	chip->snoop = true;
+
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
+	if (err < 0) {
+		dev_err(card->dev, "Error creating device\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id hda_tegra_match[] = {
+	{ .compatible = "nvidia,tegra30-hda" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, tegra_platform_hda_match);
+
+static int hda_tegra_probe(struct platform_device *pdev)
+{
+	struct snd_card *card;
+	struct azx *chip;
+	struct hda_tegra *hda;
+	int err;
+	const unsigned int driver_flags = AZX_DCAPS_RIRB_DELAY;
+
+	hda = devm_kzalloc(&pdev->dev, sizeof(*hda), GFP_KERNEL);
+	if (!hda)
+		return -ENOMEM;
+	hda->dev = &pdev->dev;
+	chip = &hda->chip;
+
+	err = snd_card_new(&pdev->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			   THIS_MODULE, 0, &card);
+	if (err < 0) {
+		dev_err(&pdev->dev, "Error creating card!\n");
+		return err;
+	}
+
+	err = hda_tegra_create(card, driver_flags, &hda_tegra_ops, hda);
+	if (err < 0)
+		goto out_free;
+	card->private_data = chip;
+
+	dev_set_drvdata(&pdev->dev, card);
+
+	err = hda_tegra_first_init(chip, pdev);
+	if (err < 0)
+		goto out_free;
+
+	/* create codec instances */
+	err = azx_codec_create(chip, NULL, 0, &power_save);
+	if (err < 0)
+		goto out_free;
+
+	err = azx_codec_configure(chip);
+	if (err < 0)
+		goto out_free;
+
+	/* create PCM streams */
+	err = snd_hda_build_pcms(chip->bus);
+	if (err < 0)
+		goto out_free;
+
+	/* create mixer controls */
+	err = azx_mixer_create(chip);
+	if (err < 0)
+		goto out_free;
+
+	err = snd_card_register(chip->card);
+	if (err < 0)
+		goto out_free;
+
+	chip->running = 1;
+	power_down_all_codecs(chip);
+	hda_tegra_notifier_register(chip);
+
+	return 0;
+
+out_free:
+	snd_card_free(card);
+	return err;
+}
+
+static int hda_tegra_remove(struct platform_device *pdev)
+{
+	return snd_card_free(dev_get_drvdata(&pdev->dev));
+}
+
+static struct platform_driver tegra_platform_hda = {
+	.driver = {
+		.name = "tegra-hda",
+		.pm = &hda_tegra_pm,
+		.of_match_table = hda_tegra_match,
+	},
+	.probe = hda_tegra_probe,
+	.remove = hda_tegra_remove,
+};
+module_platform_driver(tegra_platform_hda);
+
+MODULE_DESCRIPTION("Tegra HDA bus driver");
+MODULE_LICENSE("GPL v2");
