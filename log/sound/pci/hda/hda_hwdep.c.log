commit d0fa1179e3fa54b184b42eb0c01a43851bda14aa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:07:57 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 32
    
    Based on 1 normalized pattern(s):
    
      this driver is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this driver is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 18 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.186505395@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 268bba6ec985..125e97fe0b1c 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * HWDEP Interface for HD-audio codec
  *
  * Copyright (c) 2007 Takashi Iwai <tiwai@suse.de>
- *
- *  This driver is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This driver is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/init.h>

commit be57bfffb7b5ba72e1293643053f8861fcaa5163
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Wed Aug 22 15:24:57 2018 -0500

    ALSA: hda: move hda_codec.h to include/sound
    
    As suggested by Takashi, move this header file to make it easier
    to include from e.g. the Intel Skylake driver in follow-up patches
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index cc009a4a3d1d..268bba6ec985 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -23,7 +23,7 @@
 #include <linux/compat.h>
 #include <linux/nospec.h>
 #include <sound/core.h>
-#include "hda_codec.h"
+#include <sound/hda_codec.h>
 #include "hda_local.h"
 #include <sound/hda_hwdep.h>
 #include <sound/minors.h>

commit 69fa6f19b95597618ab30438a27b67ad93daa7c7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 07:50:50 2018 +0200

    ALSA: hda: Hardening for potential Spectre v1
    
    As recently Smatch suggested, one place in HD-audio hwdep ioctl codes
    may expand the array directly from the user-space value with
    speculation:
      sound/pci/hda/hda_local.h:467 get_wcaps() warn: potential spectre issue 'codec->wcaps'
    
    As get_wcaps() itself is a fairly frequently called inline function,
    and there is only one single call with a user-space value, we replace
    only the latter one to open-code locally with array_index_nospec()
    hardening in this patch.
    
    BugLink: https://marc.info/?l=linux-kernel&m=152411496503418&w=2
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 57df06e76968..cc009a4a3d1d 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -21,6 +21,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/compat.h>
+#include <linux/nospec.h>
 #include <sound/core.h>
 #include "hda_codec.h"
 #include "hda_local.h"
@@ -51,7 +52,16 @@ static int get_wcap_ioctl(struct hda_codec *codec,
 	
 	if (get_user(verb, &arg->verb))
 		return -EFAULT;
-	res = get_wcaps(codec, verb >> 24);
+	/* open-code get_wcaps(verb>>24) with nospec */
+	verb >>= 24;
+	if (verb < codec->core.start_nid ||
+	    verb >= codec->core.start_nid + codec->core.num_nodes) {
+		res = 0;
+	} else {
+		verb -= codec->core.start_nid;
+		verb = array_index_nospec(verb, codec->core.num_nodes);
+		res = codec->wcaps[verb];
+	}
 	if (put_user(res, &arg->res))
 		return -EFAULT;
 	return 0;

commit 6efdd8513f182492c21fb7238592d4539d5c751a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 27 16:09:22 2015 +0100

    ALSA: hda - Add card field to hda_codec struct
    
    Allow the codec object to have an individual card pointer.  Not only
    this simplifies the redirections in many places, also this will allow
    us to make each codec assigned to a different card object.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 125f3420fa6a..57df06e76968 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -101,7 +101,7 @@ int snd_hda_create_hwdep(struct hda_codec *codec)
 	int err;
 
 	sprintf(hwname, "HDA Codec %d", codec->addr);
-	err = snd_hwdep_new(codec->bus->card, hwname, codec->addr, &hwdep);
+	err = snd_hwdep_new(codec->card, hwname, codec->addr, &hwdep);
 	if (err < 0)
 		return err;
 	codec->hwdep = hwdep;

commit 327ef4f02582d01f7eedb291794106823b44a0cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 17 17:15:04 2015 +0100

    ALSA: hda - Decouple PCM and hwdep devices from codec object
    
    This is a preliminary patch for the hda_bus implementation, removing
    the parent device setup to codec device.  Since the bus and the class
    devices can't be crossed over, leave the sound devices to the default
    parent device as is.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 11b5a42b4ec8..125f3420fa6a 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -116,9 +116,6 @@ int snd_hda_create_hwdep(struct hda_codec *codec)
 	hwdep->ops.ioctl_compat = hda_hwdep_ioctl_compat;
 #endif
 
-	/* link to codec */
-	hwdep->dev.parent = &codec->dev;
-
 	/* for sysfs */
 	hwdep->dev.groups = snd_hda_dev_attr_groups;
 	dev_set_drvdata(&hwdep->dev, codec);

commit 7b46160000197209f7ebca8b92bdbb75795c473f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 17:13:32 2015 +0100

    ALSA: hwdep: Embed struct device
    
    Like the previous patch, this one embeds the device object into hwdep
    object.  For a proper object lifecycle, it's freed in the release
    callback.
    
    This also allows us to create sysfs entries via passing to the groups
    field of the device without explicit function calls.  Since each
    driver can see the device and touch its groups field directly, we
    don't need to delegate in hwdep core any longer.  So, remove the
    groups field from snd_hwdep, and let the user (in this case only
    hda_hwdep.c) modify the device groups.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 014a7849e8fd..11b5a42b4ec8 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -109,7 +109,6 @@ int snd_hda_create_hwdep(struct hda_codec *codec)
 	hwdep->iface = SNDRV_HWDEP_IFACE_HDA;
 	hwdep->private_data = codec;
 	hwdep->exclusive = 1;
-	hwdep->groups = snd_hda_dev_attr_groups;
 
 	hwdep->ops.open = hda_hwdep_open;
 	hwdep->ops.ioctl = hda_hwdep_ioctl;
@@ -118,7 +117,11 @@ int snd_hda_create_hwdep(struct hda_codec *codec)
 #endif
 
 	/* link to codec */
-	hwdep->dev = &codec->dev;
+	hwdep->dev.parent = &codec->dev;
+
+	/* for sysfs */
+	hwdep->dev.groups = snd_hda_dev_attr_groups;
+	dev_set_drvdata(&hwdep->dev, codec);
 
 	return 0;
 }

commit 648a8d276ed10062addd4a4e18aaf9ff84f14543
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 10:38:13 2014 +0100

    ALSA: hda - Add sysfs to codec object, too
    
    We have currently sysfs attributes for each hwdep, but basically these
    should belong to the codec itself, per se.  Let's add them to the
    codec object while keeping them for hwdep as is for compatibility.
    
    While we are at it, split the sysfs-related stuff into a separate
    source file, hda_sysfs.c, and keep only the stuff necessary for hwdep
    in hda_hwdep.c.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 896d116ca951..014a7849e8fd 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -21,22 +21,12 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/compat.h>
-#include <linux/mutex.h>
-#include <linux/ctype.h>
-#include <linux/string.h>
-#include <linux/export.h>
 #include <sound/core.h>
 #include "hda_codec.h"
 #include "hda_local.h"
 #include <sound/hda_hwdep.h>
 #include <sound/minors.h>
 
-/* hint string pair */
-struct hda_hint {
-	const char *key;
-	const char *val;	/* contained in the same alloc as key */
-};
-
 /*
  * write/read an out-of-bound verb
  */
@@ -104,28 +94,6 @@ static int hda_hwdep_open(struct snd_hwdep *hw, struct file *file)
 	return 0;
 }
 
-static void clear_hwdep_elements(struct hda_codec *codec)
-{
-	int i;
-
-	/* clear init verbs */
-	snd_array_free(&codec->init_verbs);
-	/* clear hints */
-	for (i = 0; i < codec->hints.used; i++) {
-		struct hda_hint *hint = snd_array_elem(&codec->hints, i);
-		kfree(hint->key); /* we don't need to free hint->val */
-	}
-	snd_array_free(&codec->hints);
-	snd_array_free(&codec->user_pins);
-}
-
-static void hwdep_free(struct snd_hwdep *hwdep)
-{
-	clear_hwdep_elements(hwdep->private_data);
-}
-
-static const struct attribute_group *snd_hda_dev_attr_groups[];
-
 int snd_hda_create_hwdep(struct hda_codec *codec)
 {
 	char hwname[16];
@@ -140,7 +108,6 @@ int snd_hda_create_hwdep(struct hda_codec *codec)
 	sprintf(hwdep->name, "HDA Codec %d", codec->addr);
 	hwdep->iface = SNDRV_HWDEP_IFACE_HDA;
 	hwdep->private_data = codec;
-	hwdep->private_free = hwdep_free;
 	hwdep->exclusive = 1;
 	hwdep->groups = snd_hda_dev_attr_groups;
 
@@ -150,729 +117,8 @@ int snd_hda_create_hwdep(struct hda_codec *codec)
 	hwdep->ops.ioctl_compat = hda_hwdep_ioctl_compat;
 #endif
 
-	mutex_init(&codec->user_mutex);
-	snd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);
-	snd_array_init(&codec->hints, sizeof(struct hda_hint), 32);
-	snd_array_init(&codec->user_pins, sizeof(struct hda_pincfg), 16);
-
 	/* link to codec */
 	hwdep->dev = &codec->dev;
 
 	return 0;
 }
-
-#ifdef CONFIG_PM
-static ssize_t power_on_acct_show(struct device *dev,
-				  struct device_attribute *attr,
-				  char *buf)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	snd_hda_update_power_acct(codec);
-	return sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_on_acct));
-}
-
-static ssize_t power_off_acct_show(struct device *dev,
-				   struct device_attribute *attr,
-				   char *buf)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	snd_hda_update_power_acct(codec);
-	return sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_off_acct));
-}
-
-static DEVICE_ATTR_RO(power_on_acct);
-static DEVICE_ATTR_RO(power_off_acct);
-#endif /* CONFIG_PM */
-
-#ifdef CONFIG_SND_HDA_RECONFIG
-
-/*
- * sysfs interface
- */
-
-static int clear_codec(struct hda_codec *codec)
-{
-	int err;
-
-	err = snd_hda_codec_reset(codec);
-	if (err < 0) {
-		snd_printk(KERN_ERR "The codec is being used, can't free.\n");
-		return err;
-	}
-	clear_hwdep_elements(codec);
-	return 0;
-}
-
-static int reconfig_codec(struct hda_codec *codec)
-{
-	int err;
-
-	snd_hda_power_up(codec);
-	snd_printk(KERN_INFO "hda-codec: reconfiguring\n");
-	err = snd_hda_codec_reset(codec);
-	if (err < 0) {
-		snd_printk(KERN_ERR
-			   "The codec is being used, can't reconfigure.\n");
-		goto error;
-	}
-	err = snd_hda_codec_configure(codec);
-	if (err < 0)
-		goto error;
-	/* rebuild PCMs */
-	err = snd_hda_codec_build_pcms(codec);
-	if (err < 0)
-		goto error;
-	/* rebuild mixers */
-	err = snd_hda_codec_build_controls(codec);
-	if (err < 0)
-		goto error;
-	err = snd_card_register(codec->bus->card);
- error:
-	snd_hda_power_down(codec);
-	return err;
-}
-
-/*
- * allocate a string at most len chars, and remove the trailing EOL
- */
-static char *kstrndup_noeol(const char *src, size_t len)
-{
-	char *s = kstrndup(src, len, GFP_KERNEL);
-	char *p;
-	if (!s)
-		return NULL;
-	p = strchr(s, '\n');
-	if (p)
-		*p = 0;
-	return s;
-}
-
-#define CODEC_INFO_SHOW(type)					\
-static ssize_t type##_show(struct device *dev,			\
-			   struct device_attribute *attr,	\
-			   char *buf)				\
-{								\
-	struct hda_codec *codec = dev_get_drvdata(dev);		\
-	return sprintf(buf, "0x%x\n", codec->type);		\
-}
-
-#define CODEC_INFO_STR_SHOW(type)				\
-static ssize_t type##_show(struct device *dev,			\
-			     struct device_attribute *attr,	\
-					char *buf)		\
-{								\
-	struct hda_codec *codec = dev_get_drvdata(dev);		\
-	return sprintf(buf, "%s\n",				\
-		       codec->type ? codec->type : "");		\
-}
-
-CODEC_INFO_SHOW(vendor_id);
-CODEC_INFO_SHOW(subsystem_id);
-CODEC_INFO_SHOW(revision_id);
-CODEC_INFO_SHOW(afg);
-CODEC_INFO_SHOW(mfg);
-CODEC_INFO_STR_SHOW(vendor_name);
-CODEC_INFO_STR_SHOW(chip_name);
-CODEC_INFO_STR_SHOW(modelname);
-
-#define CODEC_INFO_STORE(type)					\
-static ssize_t type##_store(struct device *dev,			\
-			    struct device_attribute *attr,	\
-			    const char *buf, size_t count)	\
-{								\
-	struct hda_codec *codec = dev_get_drvdata(dev);		\
-	unsigned long val;					\
-	int err = kstrtoul(buf, 0, &val);			\
-	if (err < 0)						\
-		return err;					\
-	codec->type = val;					\
-	return count;						\
-}
-
-#define CODEC_INFO_STR_STORE(type)				\
-static ssize_t type##_store(struct device *dev,			\
-			    struct device_attribute *attr,	\
-			    const char *buf, size_t count)	\
-{								\
-	struct hda_codec *codec = dev_get_drvdata(dev);		\
-	char *s = kstrndup_noeol(buf, 64);			\
-	if (!s)							\
-		return -ENOMEM;					\
-	kfree(codec->type);					\
-	codec->type = s;					\
-	return count;						\
-}
-
-CODEC_INFO_STORE(vendor_id);
-CODEC_INFO_STORE(subsystem_id);
-CODEC_INFO_STORE(revision_id);
-CODEC_INFO_STR_STORE(vendor_name);
-CODEC_INFO_STR_STORE(chip_name);
-CODEC_INFO_STR_STORE(modelname);
-
-#define CODEC_ACTION_STORE(type)				\
-static ssize_t type##_store(struct device *dev,			\
-			    struct device_attribute *attr,	\
-			    const char *buf, size_t count)	\
-{								\
-	struct hda_codec *codec = dev_get_drvdata(dev);		\
-	int err = 0;						\
-	if (*buf)						\
-		err = type##_codec(codec);			\
-	return err < 0 ? err : count;				\
-}
-
-CODEC_ACTION_STORE(reconfig);
-CODEC_ACTION_STORE(clear);
-
-static ssize_t init_verbs_show(struct device *dev,
-			       struct device_attribute *attr,
-			       char *buf)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	int i, len = 0;
-	mutex_lock(&codec->user_mutex);
-	for (i = 0; i < codec->init_verbs.used; i++) {
-		struct hda_verb *v = snd_array_elem(&codec->init_verbs, i);
-		len += snprintf(buf + len, PAGE_SIZE - len,
-				"0x%02x 0x%03x 0x%04x\n",
-				v->nid, v->verb, v->param);
-	}
-	mutex_unlock(&codec->user_mutex);
-	return len;
-}
-
-static int parse_init_verbs(struct hda_codec *codec, const char *buf)
-{
-	struct hda_verb *v;
-	int nid, verb, param;
-
-	if (sscanf(buf, "%i %i %i", &nid, &verb, &param) != 3)
-		return -EINVAL;
-	if (!nid || !verb)
-		return -EINVAL;
-	mutex_lock(&codec->user_mutex);
-	v = snd_array_new(&codec->init_verbs);
-	if (!v) {
-		mutex_unlock(&codec->user_mutex);
-		return -ENOMEM;
-	}
-	v->nid = nid;
-	v->verb = verb;
-	v->param = param;
-	mutex_unlock(&codec->user_mutex);
-	return 0;
-}
-
-static ssize_t init_verbs_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t count)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	int err = parse_init_verbs(codec, buf);
-	if (err < 0)
-		return err;
-	return count;
-}
-
-static ssize_t hints_show(struct device *dev,
-			  struct device_attribute *attr,
-			  char *buf)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	int i, len = 0;
-	mutex_lock(&codec->user_mutex);
-	for (i = 0; i < codec->hints.used; i++) {
-		struct hda_hint *hint = snd_array_elem(&codec->hints, i);
-		len += snprintf(buf + len, PAGE_SIZE - len,
-				"%s = %s\n", hint->key, hint->val);
-	}
-	mutex_unlock(&codec->user_mutex);
-	return len;
-}
-
-static struct hda_hint *get_hint(struct hda_codec *codec, const char *key)
-{
-	int i;
-
-	for (i = 0; i < codec->hints.used; i++) {
-		struct hda_hint *hint = snd_array_elem(&codec->hints, i);
-		if (!strcmp(hint->key, key))
-			return hint;
-	}
-	return NULL;
-}
-
-static void remove_trail_spaces(char *str)
-{
-	char *p;
-	if (!*str)
-		return;
-	p = str + strlen(str) - 1;
-	for (; isspace(*p); p--) {
-		*p = 0;
-		if (p == str)
-			return;
-	}
-}
-
-#define MAX_HINTS	1024
-
-static int parse_hints(struct hda_codec *codec, const char *buf)
-{
-	char *key, *val;
-	struct hda_hint *hint;
-	int err = 0;
-
-	buf = skip_spaces(buf);
-	if (!*buf || *buf == '#' || *buf == '\n')
-		return 0;
-	if (*buf == '=')
-		return -EINVAL;
-	key = kstrndup_noeol(buf, 1024);
-	if (!key)
-		return -ENOMEM;
-	/* extract key and val */
-	val = strchr(key, '=');
-	if (!val) {
-		kfree(key);
-		return -EINVAL;
-	}
-	*val++ = 0;
-	val = skip_spaces(val);
-	remove_trail_spaces(key);
-	remove_trail_spaces(val);
-	mutex_lock(&codec->user_mutex);
-	hint = get_hint(codec, key);
-	if (hint) {
-		/* replace */
-		kfree(hint->key);
-		hint->key = key;
-		hint->val = val;
-		goto unlock;
-	}
-	/* allocate a new hint entry */
-	if (codec->hints.used >= MAX_HINTS)
-		hint = NULL;
-	else
-		hint = snd_array_new(&codec->hints);
-	if (hint) {
-		hint->key = key;
-		hint->val = val;
-	} else {
-		err = -ENOMEM;
-	}
- unlock:
-	mutex_unlock(&codec->user_mutex);
-	if (err)
-		kfree(key);
-	return err;
-}
-
-static ssize_t hints_store(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	int err = parse_hints(codec, buf);
-	if (err < 0)
-		return err;
-	return count;
-}
-
-static ssize_t pin_configs_show(struct hda_codec *codec,
-				struct snd_array *list,
-				char *buf)
-{
-	int i, len = 0;
-	mutex_lock(&codec->user_mutex);
-	for (i = 0; i < list->used; i++) {
-		struct hda_pincfg *pin = snd_array_elem(list, i);
-		len += sprintf(buf + len, "0x%02x 0x%08x\n",
-			       pin->nid, pin->cfg);
-	}
-	mutex_unlock(&codec->user_mutex);
-	return len;
-}
-
-static ssize_t init_pin_configs_show(struct device *dev,
-				     struct device_attribute *attr,
-				     char *buf)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	return pin_configs_show(codec, &codec->init_pins, buf);
-}
-
-static ssize_t user_pin_configs_show(struct device *dev,
-				     struct device_attribute *attr,
-				     char *buf)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	return pin_configs_show(codec, &codec->user_pins, buf);
-}
-
-static ssize_t driver_pin_configs_show(struct device *dev,
-				       struct device_attribute *attr,
-				       char *buf)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	return pin_configs_show(codec, &codec->driver_pins, buf);
-}
-
-#define MAX_PIN_CONFIGS		32
-
-static int parse_user_pin_configs(struct hda_codec *codec, const char *buf)
-{
-	int nid, cfg, err;
-
-	if (sscanf(buf, "%i %i", &nid, &cfg) != 2)
-		return -EINVAL;
-	if (!nid)
-		return -EINVAL;
-	mutex_lock(&codec->user_mutex);
-	err = snd_hda_add_pincfg(codec, &codec->user_pins, nid, cfg);
-	mutex_unlock(&codec->user_mutex);
-	return err;
-}
-
-static ssize_t user_pin_configs_store(struct device *dev,
-				      struct device_attribute *attr,
-				      const char *buf, size_t count)
-{
-	struct hda_codec *codec = dev_get_drvdata(dev);
-	int err = parse_user_pin_configs(codec, buf);
-	if (err < 0)
-		return err;
-	return count;
-}
-
-static DEVICE_ATTR_RW(vendor_id);
-static DEVICE_ATTR_RW(subsystem_id);
-static DEVICE_ATTR_RW(revision_id);
-static DEVICE_ATTR_RO(afg);
-static DEVICE_ATTR_RO(mfg);
-static DEVICE_ATTR_RW(vendor_name);
-static DEVICE_ATTR_RW(chip_name);
-static DEVICE_ATTR_RW(modelname);
-static DEVICE_ATTR_RW(init_verbs);
-static DEVICE_ATTR_RW(hints);
-static DEVICE_ATTR_RO(init_pin_configs);
-static DEVICE_ATTR_RW(user_pin_configs);
-static DEVICE_ATTR_RO(driver_pin_configs);
-static DEVICE_ATTR_WO(reconfig);
-static DEVICE_ATTR_WO(clear);
-
-/*
- * Look for hint string
- */
-const char *snd_hda_get_hint(struct hda_codec *codec, const char *key)
-{
-	struct hda_hint *hint = get_hint(codec, key);
-	return hint ? hint->val : NULL;
-}
-EXPORT_SYMBOL_GPL(snd_hda_get_hint);
-
-int snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)
-{
-	const char *p;
-	int ret;
-
-	mutex_lock(&codec->user_mutex);
-	p = snd_hda_get_hint(codec, key);
-	if (!p || !*p)
-		ret = -ENOENT;
-	else {
-		switch (toupper(*p)) {
-		case 'T': /* true */
-		case 'Y': /* yes */
-		case '1':
-			ret = 1;
-			break;
-		default:
-			ret = 0;
-			break;
-		}
-	}
-	mutex_unlock(&codec->user_mutex);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_hda_get_bool_hint);
-
-int snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp)
-{
-	const char *p;
-	unsigned long val;
-	int ret;
-
-	mutex_lock(&codec->user_mutex);
-	p = snd_hda_get_hint(codec, key);
-	if (!p)
-		ret = -ENOENT;
-	else if (kstrtoul(p, 0, &val))
-		ret = -EINVAL;
-	else {
-		*valp = val;
-		ret = 0;
-	}
-	mutex_unlock(&codec->user_mutex);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_hda_get_int_hint);
-#endif /* CONFIG_SND_HDA_RECONFIG */
-
-#ifdef CONFIG_SND_HDA_PATCH_LOADER
-
-/* parser mode */
-enum {
-	LINE_MODE_NONE,
-	LINE_MODE_CODEC,
-	LINE_MODE_MODEL,
-	LINE_MODE_PINCFG,
-	LINE_MODE_VERB,
-	LINE_MODE_HINT,
-	LINE_MODE_VENDOR_ID,
-	LINE_MODE_SUBSYSTEM_ID,
-	LINE_MODE_REVISION_ID,
-	LINE_MODE_CHIP_NAME,
-	NUM_LINE_MODES,
-};
-
-static inline int strmatch(const char *a, const char *b)
-{
-	return strnicmp(a, b, strlen(b)) == 0;
-}
-
-/* parse the contents after the line "[codec]"
- * accept only the line with three numbers, and assign the current codec
- */
-static void parse_codec_mode(char *buf, struct hda_bus *bus,
-			     struct hda_codec **codecp)
-{
-	int vendorid, subid, caddr;
-	struct hda_codec *codec;
-
-	*codecp = NULL;
-	if (sscanf(buf, "%i %i %i", &vendorid, &subid, &caddr) == 3) {
-		list_for_each_entry(codec, &bus->codec_list, list) {
-			if ((vendorid <= 0 || codec->vendor_id == vendorid) &&
-			    (subid <= 0 || codec->subsystem_id == subid) &&
-			    codec->addr == caddr) {
-				*codecp = codec;
-				break;
-			}
-		}
-	}
-}
-
-/* parse the contents after the other command tags, [pincfg], [verb],
- * [vendor_id], [subsystem_id], [revision_id], [chip_name], [hint] and [model]
- * just pass to the sysfs helper (only when any codec was specified)
- */
-static void parse_pincfg_mode(char *buf, struct hda_bus *bus,
-			      struct hda_codec **codecp)
-{
-	parse_user_pin_configs(*codecp, buf);
-}
-
-static void parse_verb_mode(char *buf, struct hda_bus *bus,
-			    struct hda_codec **codecp)
-{
-	parse_init_verbs(*codecp, buf);
-}
-
-static void parse_hint_mode(char *buf, struct hda_bus *bus,
-			    struct hda_codec **codecp)
-{
-	parse_hints(*codecp, buf);
-}
-
-static void parse_model_mode(char *buf, struct hda_bus *bus,
-			     struct hda_codec **codecp)
-{
-	kfree((*codecp)->modelname);
-	(*codecp)->modelname = kstrdup(buf, GFP_KERNEL);
-}
-
-static void parse_chip_name_mode(char *buf, struct hda_bus *bus,
-				 struct hda_codec **codecp)
-{
-	kfree((*codecp)->chip_name);
-	(*codecp)->chip_name = kstrdup(buf, GFP_KERNEL);
-}
-
-#define DEFINE_PARSE_ID_MODE(name) \
-static void parse_##name##_mode(char *buf, struct hda_bus *bus, \
-				 struct hda_codec **codecp) \
-{ \
-	unsigned long val; \
-	if (!kstrtoul(buf, 0, &val)) \
-		(*codecp)->name = val; \
-}
-
-DEFINE_PARSE_ID_MODE(vendor_id);
-DEFINE_PARSE_ID_MODE(subsystem_id);
-DEFINE_PARSE_ID_MODE(revision_id);
-
-
-struct hda_patch_item {
-	const char *tag;
-	const char *alias;
-	void (*parser)(char *buf, struct hda_bus *bus, struct hda_codec **retc);
-};
-
-static struct hda_patch_item patch_items[NUM_LINE_MODES] = {
-	[LINE_MODE_CODEC] = {
-		.tag = "[codec]",
-		.parser = parse_codec_mode,
-	},
-	[LINE_MODE_MODEL] = {
-		.tag = "[model]",
-		.parser = parse_model_mode,
-	},
-	[LINE_MODE_VERB] = {
-		.tag = "[verb]",
-		.alias = "[init_verbs]",
-		.parser = parse_verb_mode,
-	},
-	[LINE_MODE_PINCFG] = {
-		.tag = "[pincfg]",
-		.alias = "[user_pin_configs]",
-		.parser = parse_pincfg_mode,
-	},
-	[LINE_MODE_HINT] = {
-		.tag = "[hint]",
-		.alias = "[hints]",
-		.parser = parse_hint_mode
-	},
-	[LINE_MODE_VENDOR_ID] = {
-		.tag = "[vendor_id]",
-		.parser = parse_vendor_id_mode,
-	},
-	[LINE_MODE_SUBSYSTEM_ID] = {
-		.tag = "[subsystem_id]",
-		.parser = parse_subsystem_id_mode,
-	},
-	[LINE_MODE_REVISION_ID] = {
-		.tag = "[revision_id]",
-		.parser = parse_revision_id_mode,
-	},
-	[LINE_MODE_CHIP_NAME] = {
-		.tag = "[chip_name]",
-		.parser = parse_chip_name_mode,
-	},
-};
-
-/* check the line starting with '[' -- change the parser mode accodingly */
-static int parse_line_mode(char *buf, struct hda_bus *bus)
-{
-	int i;
-	for (i = 0; i < ARRAY_SIZE(patch_items); i++) {
-		if (!patch_items[i].tag)
-			continue;
-		if (strmatch(buf, patch_items[i].tag))
-			return i;
-		if (patch_items[i].alias && strmatch(buf, patch_items[i].alias))
-			return i;
-	}
-	return LINE_MODE_NONE;
-}
-
-/* copy one line from the buffer in fw, and update the fields in fw
- * return zero if it reaches to the end of the buffer, or non-zero
- * if successfully copied a line
- *
- * the spaces at the beginning and the end of the line are stripped
- */
-static int get_line_from_fw(char *buf, int size, size_t *fw_size_p,
-			    const void **fw_data_p)
-{
-	int len;
-	size_t fw_size = *fw_size_p;
-	const char *p = *fw_data_p;
-
-	while (isspace(*p) && fw_size) {
-		p++;
-		fw_size--;
-	}
-	if (!fw_size)
-		return 0;
-
-	for (len = 0; len < fw_size; len++) {
-		if (!*p)
-			break;
-		if (*p == '\n') {
-			p++;
-			len++;
-			break;
-		}
-		if (len < size)
-			*buf++ = *p++;
-	}
-	*buf = 0;
-	*fw_size_p = fw_size - len;
-	*fw_data_p = p;
-	remove_trail_spaces(buf);
-	return 1;
-}
-
-/*
- * load a "patch" firmware file and parse it
- */
-int snd_hda_load_patch(struct hda_bus *bus, size_t fw_size, const void *fw_buf)
-{
-	char buf[128];
-	struct hda_codec *codec;
-	int line_mode;
-
-	line_mode = LINE_MODE_NONE;
-	codec = NULL;
-	while (get_line_from_fw(buf, sizeof(buf) - 1, &fw_size, &fw_buf)) {
-		if (!*buf || *buf == '#' || *buf == '\n')
-			continue;
-		if (*buf == '[')
-			line_mode = parse_line_mode(buf, bus);
-		else if (patch_items[line_mode].parser &&
-			 (codec || line_mode <= LINE_MODE_CODEC))
-			patch_items[line_mode].parser(buf, bus, &codec);
-	}
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_hda_load_patch);
-#endif /* CONFIG_SND_HDA_PATCH_LOADER */
-
-/*
- * sysfs entries
- */
-static struct attribute *hda_dev_attrs[] = {
-#ifdef CONFIG_PM
-	&dev_attr_power_on_acct.attr,
-	&dev_attr_power_off_acct.attr,
-#endif
-#ifdef CONFIG_SND_HDA_RECONFIG
-	&dev_attr_vendor_id.attr,
-	&dev_attr_subsystem_id.attr,
-	&dev_attr_revision_id.attr,
-	&dev_attr_afg.attr,
-	&dev_attr_mfg.attr,
-	&dev_attr_vendor_name.attr,
-	&dev_attr_chip_name.attr,
-	&dev_attr_modelname.attr,
-	&dev_attr_init_verbs.attr,
-	&dev_attr_hints.attr,
-	&dev_attr_init_pin_configs.attr,
-	&dev_attr_user_pin_configs.attr,
-	&dev_attr_driver_pin_configs.attr,
-	&dev_attr_reconfig.attr,
-	&dev_attr_clear.attr,
-#endif
-	NULL
-};
-
-static struct attribute_group hda_dev_attr_group = {
-	.attrs	= hda_dev_attrs,
-};
-
-static const struct attribute_group *snd_hda_dev_attr_groups[] = {
-	&hda_dev_attr_group,
-	NULL
-};

commit 13aeaf68019d297be79c99f828c2a9d6affef06b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 07:53:47 2014 +0100

    ALSA: hda - Create own device struct for each codec
    
    As the HD-audio is treated individually in each codec driver, it's
    more convenient to assign an own struct device to each codec object.
    Then we'll be able to use dev_err() more easily for each codec, for
    example.
    
    For achieving it, this patch just creates an object "hdaudioCxDy".
    It belongs to sound class instead of creating a new bus, just for
    simplicity, at this stage.  No pm ops is implemented in the device
    struct level but currently it's merely a container.  The PCM and hwdep
    devices are now children of this codec device.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 0fada0f8cfe8..896d116ca951 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -155,6 +155,9 @@ int snd_hda_create_hwdep(struct hda_codec *codec)
 	snd_array_init(&codec->hints, sizeof(struct hda_hint), 32);
 	snd_array_init(&codec->user_pins, sizeof(struct hda_pincfg), 16);
 
+	/* link to codec */
+	hwdep->dev = &codec->dev;
+
 	return 0;
 }
 

commit f806bdb2f7235907fcd310e6d147b3bcd281fa97
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 10:00:58 2014 +0100

    ALSA: hwdep: Take private_data as drvdata for sysfs
    
    For referring to a different object from sysfs ops, take hwdep
    private_data as stored via dev_set_drvdata() at creating the device
    object.  In that way, the same sysfs ops can be used by different
    device types.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 53eef6a01589..0fada0f8cfe8 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -163,8 +163,7 @@ static ssize_t power_on_acct_show(struct device *dev,
 				  struct device_attribute *attr,
 				  char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	snd_hda_update_power_acct(codec);
 	return sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_on_acct));
 }
@@ -173,8 +172,7 @@ static ssize_t power_off_acct_show(struct device *dev,
 				   struct device_attribute *attr,
 				   char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	snd_hda_update_power_acct(codec);
 	return sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_off_acct));
 }
@@ -251,8 +249,7 @@ static ssize_t type##_show(struct device *dev,			\
 			   struct device_attribute *attr,	\
 			   char *buf)				\
 {								\
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
-	struct hda_codec *codec = hwdep->private_data;		\
+	struct hda_codec *codec = dev_get_drvdata(dev);		\
 	return sprintf(buf, "0x%x\n", codec->type);		\
 }
 
@@ -261,8 +258,7 @@ static ssize_t type##_show(struct device *dev,			\
 			     struct device_attribute *attr,	\
 					char *buf)		\
 {								\
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
-	struct hda_codec *codec = hwdep->private_data;		\
+	struct hda_codec *codec = dev_get_drvdata(dev);		\
 	return sprintf(buf, "%s\n",				\
 		       codec->type ? codec->type : "");		\
 }
@@ -281,8 +277,7 @@ static ssize_t type##_store(struct device *dev,			\
 			    struct device_attribute *attr,	\
 			    const char *buf, size_t count)	\
 {								\
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
-	struct hda_codec *codec = hwdep->private_data;		\
+	struct hda_codec *codec = dev_get_drvdata(dev);		\
 	unsigned long val;					\
 	int err = kstrtoul(buf, 0, &val);			\
 	if (err < 0)						\
@@ -296,8 +291,7 @@ static ssize_t type##_store(struct device *dev,			\
 			    struct device_attribute *attr,	\
 			    const char *buf, size_t count)	\
 {								\
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
-	struct hda_codec *codec = hwdep->private_data;		\
+	struct hda_codec *codec = dev_get_drvdata(dev);		\
 	char *s = kstrndup_noeol(buf, 64);			\
 	if (!s)							\
 		return -ENOMEM;					\
@@ -318,8 +312,7 @@ static ssize_t type##_store(struct device *dev,			\
 			    struct device_attribute *attr,	\
 			    const char *buf, size_t count)	\
 {								\
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
-	struct hda_codec *codec = hwdep->private_data;		\
+	struct hda_codec *codec = dev_get_drvdata(dev);		\
 	int err = 0;						\
 	if (*buf)						\
 		err = type##_codec(codec);			\
@@ -333,8 +326,7 @@ static ssize_t init_verbs_show(struct device *dev,
 			       struct device_attribute *attr,
 			       char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	int i, len = 0;
 	mutex_lock(&codec->user_mutex);
 	for (i = 0; i < codec->init_verbs.used; i++) {
@@ -373,8 +365,7 @@ static ssize_t init_verbs_store(struct device *dev,
 				struct device_attribute *attr,
 				const char *buf, size_t count)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	int err = parse_init_verbs(codec, buf);
 	if (err < 0)
 		return err;
@@ -385,8 +376,7 @@ static ssize_t hints_show(struct device *dev,
 			  struct device_attribute *attr,
 			  char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	int i, len = 0;
 	mutex_lock(&codec->user_mutex);
 	for (i = 0; i < codec->hints.used; i++) {
@@ -480,8 +470,7 @@ static ssize_t hints_store(struct device *dev,
 			   struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	int err = parse_hints(codec, buf);
 	if (err < 0)
 		return err;
@@ -507,8 +496,7 @@ static ssize_t init_pin_configs_show(struct device *dev,
 				     struct device_attribute *attr,
 				     char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	return pin_configs_show(codec, &codec->init_pins, buf);
 }
 
@@ -516,8 +504,7 @@ static ssize_t user_pin_configs_show(struct device *dev,
 				     struct device_attribute *attr,
 				     char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	return pin_configs_show(codec, &codec->user_pins, buf);
 }
 
@@ -525,8 +512,7 @@ static ssize_t driver_pin_configs_show(struct device *dev,
 				       struct device_attribute *attr,
 				       char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	return pin_configs_show(codec, &codec->driver_pins, buf);
 }
 
@@ -550,8 +536,7 @@ static ssize_t user_pin_configs_store(struct device *dev,
 				      struct device_attribute *attr,
 				      const char *buf, size_t count)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
+	struct hda_codec *codec = dev_get_drvdata(dev);
 	int err = parse_user_pin_configs(codec, buf);
 	if (err < 0)
 		return err;

commit caa751bad444268d756b48ca03d7cceda3430cc8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 08:30:50 2014 +0100

    ALSA: Create sysfs attribute files via groups
    
    Instead of calling each time device_create_file(), create the groups
    of sysfs attribute files at once in a normal way.  Add a new helper
    function, snd_get_device(), to return the associated device object,
    so that we can handle the sysfs addition locally.
    
    Since the sysfs file addition is done differently now,
    snd_add_device_sysfs_file() helper function is removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 53c961992d0c..53eef6a01589 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -124,6 +124,8 @@ static void hwdep_free(struct snd_hwdep *hwdep)
 	clear_hwdep_elements(hwdep->private_data);
 }
 
+static const struct attribute_group *snd_hda_dev_attr_groups[];
+
 int snd_hda_create_hwdep(struct hda_codec *codec)
 {
 	char hwname[16];
@@ -140,6 +142,7 @@ int snd_hda_create_hwdep(struct hda_codec *codec)
 	hwdep->private_data = codec;
 	hwdep->private_free = hwdep_free;
 	hwdep->exclusive = 1;
+	hwdep->groups = snd_hda_dev_attr_groups;
 
 	hwdep->ops.open = hda_hwdep_open;
 	hwdep->ops.ioctl = hda_hwdep_ioctl;
@@ -176,21 +179,8 @@ static ssize_t power_off_acct_show(struct device *dev,
 	return sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_off_acct));
 }
 
-static struct device_attribute power_attrs[] = {
-	__ATTR_RO(power_on_acct),
-	__ATTR_RO(power_off_acct),
-};
-
-int snd_hda_hwdep_add_power_sysfs(struct hda_codec *codec)
-{
-	struct snd_hwdep *hwdep = codec->hwdep;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(power_attrs); i++)
-		snd_add_device_sysfs_file(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card,
-					  hwdep->device, &power_attrs[i]);
-	return 0;
-}
+static DEVICE_ATTR_RO(power_on_acct);
+static DEVICE_ATTR_RO(power_off_acct);
 #endif /* CONFIG_PM */
 
 #ifdef CONFIG_SND_HDA_RECONFIG
@@ -568,44 +558,21 @@ static ssize_t user_pin_configs_store(struct device *dev,
 	return count;
 }
 
-#define CODEC_ATTR_RW(type) \
-	__ATTR(type, 0644, type##_show, type##_store)
-#define CODEC_ATTR_RO(type) \
-	__ATTR_RO(type)
-#define CODEC_ATTR_WO(type) \
-	__ATTR(type, 0200, NULL, type##_store)
-
-static struct device_attribute codec_attrs[] = {
-	CODEC_ATTR_RW(vendor_id),
-	CODEC_ATTR_RW(subsystem_id),
-	CODEC_ATTR_RW(revision_id),
-	CODEC_ATTR_RO(afg),
-	CODEC_ATTR_RO(mfg),
-	CODEC_ATTR_RW(vendor_name),
-	CODEC_ATTR_RW(chip_name),
-	CODEC_ATTR_RW(modelname),
-	CODEC_ATTR_RW(init_verbs),
-	CODEC_ATTR_RW(hints),
-	CODEC_ATTR_RO(init_pin_configs),
-	CODEC_ATTR_RW(user_pin_configs),
-	CODEC_ATTR_RO(driver_pin_configs),
-	CODEC_ATTR_WO(reconfig),
-	CODEC_ATTR_WO(clear),
-};
-
-/*
- * create sysfs files on hwdep directory
- */
-int snd_hda_hwdep_add_sysfs(struct hda_codec *codec)
-{
-	struct snd_hwdep *hwdep = codec->hwdep;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(codec_attrs); i++)
-		snd_add_device_sysfs_file(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card,
-					  hwdep->device, &codec_attrs[i]);
-	return 0;
-}
+static DEVICE_ATTR_RW(vendor_id);
+static DEVICE_ATTR_RW(subsystem_id);
+static DEVICE_ATTR_RW(revision_id);
+static DEVICE_ATTR_RO(afg);
+static DEVICE_ATTR_RO(mfg);
+static DEVICE_ATTR_RW(vendor_name);
+static DEVICE_ATTR_RW(chip_name);
+static DEVICE_ATTR_RW(modelname);
+static DEVICE_ATTR_RW(init_verbs);
+static DEVICE_ATTR_RW(hints);
+static DEVICE_ATTR_RO(init_pin_configs);
+static DEVICE_ATTR_RW(user_pin_configs);
+static DEVICE_ATTR_RO(driver_pin_configs);
+static DEVICE_ATTR_WO(reconfig);
+static DEVICE_ATTR_WO(clear);
 
 /*
  * Look for hint string
@@ -884,3 +851,40 @@ int snd_hda_load_patch(struct hda_bus *bus, size_t fw_size, const void *fw_buf)
 }
 EXPORT_SYMBOL_GPL(snd_hda_load_patch);
 #endif /* CONFIG_SND_HDA_PATCH_LOADER */
+
+/*
+ * sysfs entries
+ */
+static struct attribute *hda_dev_attrs[] = {
+#ifdef CONFIG_PM
+	&dev_attr_power_on_acct.attr,
+	&dev_attr_power_off_acct.attr,
+#endif
+#ifdef CONFIG_SND_HDA_RECONFIG
+	&dev_attr_vendor_id.attr,
+	&dev_attr_subsystem_id.attr,
+	&dev_attr_revision_id.attr,
+	&dev_attr_afg.attr,
+	&dev_attr_mfg.attr,
+	&dev_attr_vendor_name.attr,
+	&dev_attr_chip_name.attr,
+	&dev_attr_modelname.attr,
+	&dev_attr_init_verbs.attr,
+	&dev_attr_hints.attr,
+	&dev_attr_init_pin_configs.attr,
+	&dev_attr_user_pin_configs.attr,
+	&dev_attr_driver_pin_configs.attr,
+	&dev_attr_reconfig.attr,
+	&dev_attr_clear.attr,
+#endif
+	NULL
+};
+
+static struct attribute_group hda_dev_attr_group = {
+	.attrs	= hda_dev_attrs,
+};
+
+static const struct attribute_group *snd_hda_dev_attr_groups[] = {
+	&hda_dev_attr_group,
+	NULL
+};

commit 1f85a0f0cce583a8ac436bda8807ec8fd8e8ef16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Feb 15 10:12:12 2014 +0100

    ALSA: hda - Remove superfluous inclusion of linux/pci.h
    
    Some codec drivers still have it since using PCI_VENDOR_ID_*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 72d8389fb399..53c961992d0c 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -20,7 +20,6 @@
 
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/pci.h>
 #include <linux/compat.h>
 #include <linux/mutex.h>
 #include <linux/ctype.h>

commit 8e3ae6f7ad825129ce3691934bc7238f9b70029b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 7 15:28:51 2014 +0100

    ALSA: hda - Add consistent tag names for firmware patch
    
    Some tags used in the firmware patch file are inconsistent with hwdep
    sysfs file names, such as, the firmware patch takes [hint] tag while
    sysfs file is */hints.  This makes even me referring back to the
    document often.  Let's provide the same tag names as sysfs for
    reducing confusions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 79b3dd0d4dd8..72d8389fb399 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -762,19 +762,50 @@ DEFINE_PARSE_ID_MODE(revision_id);
 
 struct hda_patch_item {
 	const char *tag;
+	const char *alias;
 	void (*parser)(char *buf, struct hda_bus *bus, struct hda_codec **retc);
 };
 
 static struct hda_patch_item patch_items[NUM_LINE_MODES] = {
-	[LINE_MODE_CODEC] = { "[codec]", parse_codec_mode },
-	[LINE_MODE_MODEL] = { "[model]", parse_model_mode },
-	[LINE_MODE_VERB] = { "[verb]", parse_verb_mode },
-	[LINE_MODE_PINCFG] = { "[pincfg]", parse_pincfg_mode },
-	[LINE_MODE_HINT] = { "[hint]", parse_hint_mode },
-	[LINE_MODE_VENDOR_ID] = { "[vendor_id]", parse_vendor_id_mode },
-	[LINE_MODE_SUBSYSTEM_ID] = { "[subsystem_id]", parse_subsystem_id_mode },
-	[LINE_MODE_REVISION_ID] = { "[revision_id]", parse_revision_id_mode },
-	[LINE_MODE_CHIP_NAME] = { "[chip_name]", parse_chip_name_mode },
+	[LINE_MODE_CODEC] = {
+		.tag = "[codec]",
+		.parser = parse_codec_mode,
+	},
+	[LINE_MODE_MODEL] = {
+		.tag = "[model]",
+		.parser = parse_model_mode,
+	},
+	[LINE_MODE_VERB] = {
+		.tag = "[verb]",
+		.alias = "[init_verbs]",
+		.parser = parse_verb_mode,
+	},
+	[LINE_MODE_PINCFG] = {
+		.tag = "[pincfg]",
+		.alias = "[user_pin_configs]",
+		.parser = parse_pincfg_mode,
+	},
+	[LINE_MODE_HINT] = {
+		.tag = "[hint]",
+		.alias = "[hints]",
+		.parser = parse_hint_mode
+	},
+	[LINE_MODE_VENDOR_ID] = {
+		.tag = "[vendor_id]",
+		.parser = parse_vendor_id_mode,
+	},
+	[LINE_MODE_SUBSYSTEM_ID] = {
+		.tag = "[subsystem_id]",
+		.parser = parse_subsystem_id_mode,
+	},
+	[LINE_MODE_REVISION_ID] = {
+		.tag = "[revision_id]",
+		.parser = parse_revision_id_mode,
+	},
+	[LINE_MODE_CHIP_NAME] = {
+		.tag = "[chip_name]",
+		.parser = parse_chip_name_mode,
+	},
 };
 
 /* check the line starting with '[' -- change the parser mode accodingly */
@@ -786,6 +817,8 @@ static int parse_line_mode(char *buf, struct hda_bus *bus)
 			continue;
 		if (strmatch(buf, patch_items[i].tag))
 			return i;
+		if (patch_items[i].alias && strmatch(buf, patch_items[i].alias))
+			return i;
 	}
 	return LINE_MODE_NONE;
 }

commit d81e397c65279847e473a2284927ee5b4f712693
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 7 15:23:44 2014 +0100

    ALSA: hda - firmware patch code cleanup
    
    Just a code refactoring: the need_codec flag in hda_patch_item struct
    can be removed by checking the current mode instead.  No functional
    change.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 0ec6fb1e9846..79b3dd0d4dd8 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -763,19 +763,18 @@ DEFINE_PARSE_ID_MODE(revision_id);
 struct hda_patch_item {
 	const char *tag;
 	void (*parser)(char *buf, struct hda_bus *bus, struct hda_codec **retc);
-	int need_codec;
 };
 
 static struct hda_patch_item patch_items[NUM_LINE_MODES] = {
-	[LINE_MODE_CODEC] = { "[codec]", parse_codec_mode, 0 },
-	[LINE_MODE_MODEL] = { "[model]", parse_model_mode, 1 },
-	[LINE_MODE_VERB] = { "[verb]", parse_verb_mode, 1 },
-	[LINE_MODE_PINCFG] = { "[pincfg]", parse_pincfg_mode, 1 },
-	[LINE_MODE_HINT] = { "[hint]", parse_hint_mode, 1 },
-	[LINE_MODE_VENDOR_ID] = { "[vendor_id]", parse_vendor_id_mode, 1 },
-	[LINE_MODE_SUBSYSTEM_ID] = { "[subsystem_id]", parse_subsystem_id_mode, 1 },
-	[LINE_MODE_REVISION_ID] = { "[revision_id]", parse_revision_id_mode, 1 },
-	[LINE_MODE_CHIP_NAME] = { "[chip_name]", parse_chip_name_mode, 1 },
+	[LINE_MODE_CODEC] = { "[codec]", parse_codec_mode },
+	[LINE_MODE_MODEL] = { "[model]", parse_model_mode },
+	[LINE_MODE_VERB] = { "[verb]", parse_verb_mode },
+	[LINE_MODE_PINCFG] = { "[pincfg]", parse_pincfg_mode },
+	[LINE_MODE_HINT] = { "[hint]", parse_hint_mode },
+	[LINE_MODE_VENDOR_ID] = { "[vendor_id]", parse_vendor_id_mode },
+	[LINE_MODE_SUBSYSTEM_ID] = { "[subsystem_id]", parse_subsystem_id_mode },
+	[LINE_MODE_REVISION_ID] = { "[revision_id]", parse_revision_id_mode },
+	[LINE_MODE_CHIP_NAME] = { "[chip_name]", parse_chip_name_mode },
 };
 
 /* check the line starting with '[' -- change the parser mode accodingly */
@@ -846,7 +845,7 @@ int snd_hda_load_patch(struct hda_bus *bus, size_t fw_size, const void *fw_buf)
 		if (*buf == '[')
 			line_mode = parse_line_mode(buf, bus);
 		else if (patch_items[line_mode].parser &&
-			 (codec || !patch_items[line_mode].need_codec))
+			 (codec || line_mode <= LINE_MODE_CODEC))
 			patch_items[line_mode].parser(buf, bus, &codec);
 	}
 	return 0;

commit 2698ea98059bb01a9b5d9cfd20e23d55f68c0a17
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Dec 18 07:45:52 2013 +0100

    ALSA: hda - Kill EXPORT_SYMBOL_HDA()
    
    Replace all with the standard EXPORT_SYMBOL_GPL().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index fe0bda19de15..0ec6fb1e9846 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -616,7 +616,7 @@ const char *snd_hda_get_hint(struct hda_codec *codec, const char *key)
 	struct hda_hint *hint = get_hint(codec, key);
 	return hint ? hint->val : NULL;
 }
-EXPORT_SYMBOL_HDA(snd_hda_get_hint);
+EXPORT_SYMBOL_GPL(snd_hda_get_hint);
 
 int snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)
 {
@@ -642,7 +642,7 @@ int snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)
 	mutex_unlock(&codec->user_mutex);
 	return ret;
 }
-EXPORT_SYMBOL_HDA(snd_hda_get_bool_hint);
+EXPORT_SYMBOL_GPL(snd_hda_get_bool_hint);
 
 int snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp)
 {
@@ -663,7 +663,7 @@ int snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp)
 	mutex_unlock(&codec->user_mutex);
 	return ret;
 }
-EXPORT_SYMBOL_HDA(snd_hda_get_int_hint);
+EXPORT_SYMBOL_GPL(snd_hda_get_int_hint);
 #endif /* CONFIG_SND_HDA_RECONFIG */
 
 #ifdef CONFIG_SND_HDA_PATCH_LOADER
@@ -851,5 +851,5 @@ int snd_hda_load_patch(struct hda_bus *bus, size_t fw_size, const void *fw_buf)
 	}
 	return 0;
 }
-EXPORT_SYMBOL_HDA(snd_hda_load_patch);
+EXPORT_SYMBOL_GPL(snd_hda_load_patch);
 #endif /* CONFIG_SND_HDA_PATCH_LOADER */

commit b785a492c6eef578520594d5c4d6e9f2cb47cbeb
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Jul 19 16:24:59 2013 +0900

    ALSA: replace strict_strto*() with kstrto*()
    
    The usage of strict_strto*() is not preferred, because
    strict_strto*() is obsolete. Thus, kstrto*() should be
    used.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index ce67608734b5..fe0bda19de15 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -295,7 +295,7 @@ static ssize_t type##_store(struct device *dev,			\
 	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
 	struct hda_codec *codec = hwdep->private_data;		\
 	unsigned long val;					\
-	int err = strict_strtoul(buf, 0, &val);			\
+	int err = kstrtoul(buf, 0, &val);			\
 	if (err < 0)						\
 		return err;					\
 	codec->type = val;					\
@@ -654,7 +654,7 @@ int snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp)
 	p = snd_hda_get_hint(codec, key);
 	if (!p)
 		ret = -ENOENT;
-	else if (strict_strtoul(p, 0, &val))
+	else if (kstrtoul(p, 0, &val))
 		ret = -EINVAL;
 	else {
 		*valp = val;
@@ -751,7 +751,7 @@ static void parse_##name##_mode(char *buf, struct hda_bus *bus, \
 				 struct hda_codec **codecp) \
 { \
 	unsigned long val; \
-	if (!strict_strtoul(buf, 0, &val)) \
+	if (!kstrtoul(buf, 0, &val)) \
 		(*codecp)->name = val; \
 }
 

commit bc759721fb44bc07e4f82445cc378a9d2724651f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 17:40:31 2013 +0100

    ALSA: hda - Add snd_hda_get_int_hint() helper function
    
    It'll be used in hda_generic.c, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 2dddf7fbebcc..ce67608734b5 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -644,6 +644,26 @@ int snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)
 }
 EXPORT_SYMBOL_HDA(snd_hda_get_bool_hint);
 
+int snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp)
+{
+	const char *p;
+	unsigned long val;
+	int ret;
+
+	mutex_lock(&codec->user_mutex);
+	p = snd_hda_get_hint(codec, key);
+	if (!p)
+		ret = -ENOENT;
+	else if (strict_strtoul(p, 0, &val))
+		ret = -EINVAL;
+	else {
+		*valp = val;
+		ret = 0;
+	}
+	mutex_unlock(&codec->user_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_HDA(snd_hda_get_int_hint);
 #endif /* CONFIG_SND_HDA_RECONFIG */
 
 #ifdef CONFIG_SND_HDA_PATCH_LOADER

commit 09b70e8509862debff5a033052f8adbd7402fa4e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 10 18:21:56 2013 +0100

    ALSA: hda - Protect user-defined arrays via mutex
    
    The pincfgs, init_verbs and hints set by sysfs or patch might be
    changed dynamically on the fly, thus we need to protect it.
    Add a simple protection via a mutex.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index a5c9411bb367..2dddf7fbebcc 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -148,6 +148,7 @@ int snd_hda_create_hwdep(struct hda_codec *codec)
 	hwdep->ops.ioctl_compat = hda_hwdep_ioctl_compat;
 #endif
 
+	mutex_init(&codec->user_mutex);
 	snd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);
 	snd_array_init(&codec->hints, sizeof(struct hda_hint), 32);
 	snd_array_init(&codec->user_pins, sizeof(struct hda_pincfg), 16);
@@ -346,12 +347,14 @@ static ssize_t init_verbs_show(struct device *dev,
 	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
 	struct hda_codec *codec = hwdep->private_data;
 	int i, len = 0;
+	mutex_lock(&codec->user_mutex);
 	for (i = 0; i < codec->init_verbs.used; i++) {
 		struct hda_verb *v = snd_array_elem(&codec->init_verbs, i);
 		len += snprintf(buf + len, PAGE_SIZE - len,
 				"0x%02x 0x%03x 0x%04x\n",
 				v->nid, v->verb, v->param);
 	}
+	mutex_unlock(&codec->user_mutex);
 	return len;
 }
 
@@ -364,12 +367,16 @@ static int parse_init_verbs(struct hda_codec *codec, const char *buf)
 		return -EINVAL;
 	if (!nid || !verb)
 		return -EINVAL;
+	mutex_lock(&codec->user_mutex);
 	v = snd_array_new(&codec->init_verbs);
-	if (!v)
+	if (!v) {
+		mutex_unlock(&codec->user_mutex);
 		return -ENOMEM;
+	}
 	v->nid = nid;
 	v->verb = verb;
 	v->param = param;
+	mutex_unlock(&codec->user_mutex);
 	return 0;
 }
 
@@ -392,11 +399,13 @@ static ssize_t hints_show(struct device *dev,
 	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
 	struct hda_codec *codec = hwdep->private_data;
 	int i, len = 0;
+	mutex_lock(&codec->user_mutex);
 	for (i = 0; i < codec->hints.used; i++) {
 		struct hda_hint *hint = snd_array_elem(&codec->hints, i);
 		len += snprintf(buf + len, PAGE_SIZE - len,
 				"%s = %s\n", hint->key, hint->val);
 	}
+	mutex_unlock(&codec->user_mutex);
 	return len;
 }
 
@@ -431,6 +440,7 @@ static int parse_hints(struct hda_codec *codec, const char *buf)
 {
 	char *key, *val;
 	struct hda_hint *hint;
+	int err = 0;
 
 	buf = skip_spaces(buf);
 	if (!*buf || *buf == '#' || *buf == '\n')
@@ -450,26 +460,31 @@ static int parse_hints(struct hda_codec *codec, const char *buf)
 	val = skip_spaces(val);
 	remove_trail_spaces(key);
 	remove_trail_spaces(val);
+	mutex_lock(&codec->user_mutex);
 	hint = get_hint(codec, key);
 	if (hint) {
 		/* replace */
 		kfree(hint->key);
 		hint->key = key;
 		hint->val = val;
-		return 0;
+		goto unlock;
 	}
 	/* allocate a new hint entry */
 	if (codec->hints.used >= MAX_HINTS)
 		hint = NULL;
 	else
 		hint = snd_array_new(&codec->hints);
-	if (!hint) {
-		kfree(key);
-		return -ENOMEM;
+	if (hint) {
+		hint->key = key;
+		hint->val = val;
+	} else {
+		err = -ENOMEM;
 	}
-	hint->key = key;
-	hint->val = val;
-	return 0;
+ unlock:
+	mutex_unlock(&codec->user_mutex);
+	if (err)
+		kfree(key);
+	return err;
 }
 
 static ssize_t hints_store(struct device *dev,
@@ -489,11 +504,13 @@ static ssize_t pin_configs_show(struct hda_codec *codec,
 				char *buf)
 {
 	int i, len = 0;
+	mutex_lock(&codec->user_mutex);
 	for (i = 0; i < list->used; i++) {
 		struct hda_pincfg *pin = snd_array_elem(list, i);
 		len += sprintf(buf + len, "0x%02x 0x%08x\n",
 			       pin->nid, pin->cfg);
 	}
+	mutex_unlock(&codec->user_mutex);
 	return len;
 }
 
@@ -528,13 +545,16 @@ static ssize_t driver_pin_configs_show(struct device *dev,
 
 static int parse_user_pin_configs(struct hda_codec *codec, const char *buf)
 {
-	int nid, cfg;
+	int nid, cfg, err;
 
 	if (sscanf(buf, "%i %i", &nid, &cfg) != 2)
 		return -EINVAL;
 	if (!nid)
 		return -EINVAL;
-	return snd_hda_add_pincfg(codec, &codec->user_pins, nid, cfg);
+	mutex_lock(&codec->user_mutex);
+	err = snd_hda_add_pincfg(codec, &codec->user_pins, nid, cfg);
+	mutex_unlock(&codec->user_mutex);
+	return err;
 }
 
 static ssize_t user_pin_configs_store(struct device *dev,
@@ -600,16 +620,27 @@ EXPORT_SYMBOL_HDA(snd_hda_get_hint);
 
 int snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)
 {
-	const char *p = snd_hda_get_hint(codec, key);
+	const char *p;
+	int ret;
+
+	mutex_lock(&codec->user_mutex);
+	p = snd_hda_get_hint(codec, key);
 	if (!p || !*p)
-		return -ENOENT;
-	switch (toupper(*p)) {
-	case 'T': /* true */
-	case 'Y': /* yes */
-	case '1':
-		return 1;
+		ret = -ENOENT;
+	else {
+		switch (toupper(*p)) {
+		case 'T': /* true */
+		case 'Y': /* yes */
+		case '1':
+			ret = 1;
+			break;
+		default:
+			ret = 0;
+			break;
+		}
 	}
-	return 0;
+	mutex_unlock(&codec->user_mutex);
+	return ret;
 }
 EXPORT_SYMBOL_HDA(snd_hda_get_bool_hint);
 

commit 6a0f56a784cd8b08d5c438c11cfa659472b29113
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Dec 7 07:41:56 2012 +0100

    ALSA: Remove the rest of __devinit* in comments
    
    Remove the leftover __devinit* in comments.
    They have been commented out because they couldn't fit with __dev*
    although they should have matched.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 1af86d40eb23..a5c9411bb367 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -125,7 +125,7 @@ static void hwdep_free(struct snd_hwdep *hwdep)
 	clear_hwdep_elements(hwdep->private_data);
 }
 
-int /*__devinit*/ snd_hda_create_hwdep(struct hda_codec *codec)
+int snd_hda_create_hwdep(struct hda_codec *codec)
 {
 	char hwname[16];
 	struct snd_hwdep *hwdep;

commit 83012a7ccbb90dee33c97a004b3e374f988612af
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 24 18:38:08 2012 +0200

    ALSA: hda - Clean up CONFIG_SND_HDA_POWER_SAVE
    
    CONFIG_SND_HDA_POWER_SAVE is no longer an experimental feature and its
    behavior can be well controlled via the default value and module
    parameter.  Let's just replace it with the standard CONFIG_PM.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index b9a644ca03b3..1af86d40eb23 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -155,7 +155,7 @@ int /*__devinit*/ snd_hda_create_hwdep(struct hda_codec *codec)
 	return 0;
 }
 
-#ifdef CONFIG_SND_HDA_POWER_SAVE
+#ifdef CONFIG_PM
 static ssize_t power_on_acct_show(struct device *dev,
 				  struct device_attribute *attr,
 				  char *buf)
@@ -191,7 +191,7 @@ int snd_hda_hwdep_add_power_sysfs(struct hda_codec *codec)
 					  hwdep->device, &power_attrs[i]);
 	return 0;
 }
-#endif /* CONFIG_SND_HDA_POWER_SAVE */
+#endif /* CONFIG_PM */
 
 #ifdef CONFIG_SND_HDA_RECONFIG
 

commit 4918cdab497d693f4de288a576fb22e8ff9df21e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 9 12:33:28 2012 +0200

    ALSA: hda - Load firmware in hda_intel.c
    
    This is a preliminary work for the deferred probing for
    request_firmware() errors at init.
    
    This patch moves the call of request_firmware() to hda_intel.c, and
    call it in the earlier stage of probing rather than
    azx_probe_continue().
    
    Tested-by: Thierry Reding <thierry.reding@avionic-design.de>
    Reviewed-by: David Henningsson <david.henningsson@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 6b2efb8cb1f9..b9a644ca03b3 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -25,7 +25,6 @@
 #include <linux/mutex.h>
 #include <linux/ctype.h>
 #include <linux/string.h>
-#include <linux/firmware.h>
 #include <linux/export.h>
 #include <sound/core.h>
 #include "hda_codec.h"
@@ -747,18 +746,21 @@ static int parse_line_mode(char *buf, struct hda_bus *bus)
  *
  * the spaces at the beginning and the end of the line are stripped
  */
-static int get_line_from_fw(char *buf, int size, struct firmware *fw)
+static int get_line_from_fw(char *buf, int size, size_t *fw_size_p,
+			    const void **fw_data_p)
 {
 	int len;
-	const char *p = fw->data;
-	while (isspace(*p) && fw->size) {
+	size_t fw_size = *fw_size_p;
+	const char *p = *fw_data_p;
+
+	while (isspace(*p) && fw_size) {
 		p++;
-		fw->size--;
+		fw_size--;
 	}
-	if (!fw->size)
+	if (!fw_size)
 		return 0;
 
-	for (len = 0; len < fw->size; len++) {
+	for (len = 0; len < fw_size; len++) {
 		if (!*p)
 			break;
 		if (*p == '\n') {
@@ -770,8 +772,8 @@ static int get_line_from_fw(char *buf, int size, struct firmware *fw)
 			*buf++ = *p++;
 	}
 	*buf = 0;
-	fw->size -= len;
-	fw->data = p;
+	*fw_size_p = fw_size - len;
+	*fw_data_p = p;
 	remove_trail_spaces(buf);
 	return 1;
 }
@@ -779,29 +781,15 @@ static int get_line_from_fw(char *buf, int size, struct firmware *fw)
 /*
  * load a "patch" firmware file and parse it
  */
-int snd_hda_load_patch(struct hda_bus *bus, const char *patch)
+int snd_hda_load_patch(struct hda_bus *bus, size_t fw_size, const void *fw_buf)
 {
-	int err;
-	const struct firmware *fw;
-	struct firmware tmp;
 	char buf[128];
 	struct hda_codec *codec;
 	int line_mode;
-	struct device *dev = bus->card->dev;
-
-	if (snd_BUG_ON(!dev))
-		return -ENODEV;
-	err = request_firmware(&fw, patch, dev);
-	if (err < 0) {
-		printk(KERN_ERR "hda-codec: Cannot load the patch '%s'\n",
-		       patch);
-		return err;
-	}
 
-	tmp = *fw;
 	line_mode = LINE_MODE_NONE;
 	codec = NULL;
-	while (get_line_from_fw(buf, sizeof(buf) - 1, &tmp)) {
+	while (get_line_from_fw(buf, sizeof(buf) - 1, &fw_size, &fw_buf)) {
 		if (!*buf || *buf == '#' || *buf == '\n')
 			continue;
 		if (*buf == '[')
@@ -810,7 +798,6 @@ int snd_hda_load_patch(struct hda_bus *bus, const char *patch)
 			 (codec || !patch_items[line_mode].need_codec))
 			patch_items[line_mode].parser(buf, bus, &codec);
 	}
-	release_firmware(fw);
 	return 0;
 }
 EXPORT_SYMBOL_HDA(snd_hda_load_patch);

commit 32aaeffbd4a7457bf2f7448b33b5946ff2a960eb
Merge: 208bca086040 67b84999b1a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 19:44:47 2011 -0800

    Merge branch 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    * 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux: (230 commits)
      Revert "tracing: Include module.h in define_trace.h"
      irq: don't put module.h into irq.h for tracking irqgen modules.
      bluetooth: macroize two small inlines to avoid module.h
      ip_vs.h: fix implicit use of module_get/module_put from module.h
      nf_conntrack.h: fix up fallout from implicit moduleparam.h presence
      include: replace linux/module.h with "struct module" wherever possible
      include: convert various register fcns to macros to avoid include chaining
      crypto.h: remove unused crypto_tfm_alg_modname() inline
      uwb.h: fix implicit use of asm/page.h for PAGE_SIZE
      pm_runtime.h: explicitly requires notifier.h
      linux/dmaengine.h: fix implicit use of bitmap.h and asm/page.h
      miscdevice.h: fix up implicit use of lists and types
      stop_machine.h: fix implicit use of smp.h for smp_processor_id
      of: fix implicit use of errno.h in include/linux/of.h
      of_platform.h: delete needless include <linux/module.h>
      acpi: remove module.h include from platform/aclinux.h
      miscdevice.h: delete unnecessary inclusion of module.h
      device_cgroup.h: delete needless include <linux/module.h>
      net: sch_generic remove redundant use of <linux/module.h>
      net: inet_timewait_sock doesnt need <linux/module.h>
      ...
    
    Fix up trivial conflicts (other header files, and  removal of the ab3550 mfd driver) in
     - drivers/media/dvb/frontends/dibx000_common.c
     - drivers/media/video/{mt9m111.c,ov6650.c}
     - drivers/mfd/ab3550-core.c
     - include/linux/dmaengine.h

commit 359f90982cba0ba8db39b683de05dcb2de64b979
Author: Alexander Stein <alexander.stein@systec-electronic.com>
Date:   Tue Nov 1 09:40:07 2011 +0100

    ALSA: hda_hwdep: Fix possible buffer overflow
    
    If a line in the firmware file is larger than the given buffer size (and
    so the firmware file size), size is set to a value larger than the actual
    buffer size. This results in an overflow in the buffer passed.
    
    Signed-off-by: Alexander Stein <alexander.stein@systec-electronic.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 72e5885007cc..7e7d0788ddcf 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -756,8 +756,6 @@ static int get_line_from_fw(char *buf, int size, struct firmware *fw)
 	}
 	if (!fw->size)
 		return 0;
-	if (size < fw->size)
-		size = fw->size;
 
 	for (len = 0; len < fw->size; len++) {
 		if (!*p)

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 72e5885007cc..a6d54595bb7b 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -26,6 +26,7 @@
 #include <linux/ctype.h>
 #include <linux/string.h>
 #include <linux/firmware.h>
+#include <linux/export.h>
 #include <sound/core.h>
 #include "hda_codec.h"
 #include "hda_local.h"

commit ef940b0403d4ae133c548b01fe64c74fa8a2f0b1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 28 20:12:08 2011 +0200

    ALSA: hda - Allow patching with any vendor/subsystem ids
    
    In the ugly real world, there area really broken devices that don't set
    codec SSID correctly.  In such a case, the ID can be random, thus the
    patching won't work reliably.
    
    For applying the patch forcibly to such a device, the driver will skip
    the vendor and/or subsystem ID checks when zero or a negative number is
    given in [codec] section.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index bf3ced51e0f8..72e5885007cc 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -643,14 +643,14 @@ static inline int strmatch(const char *a, const char *b)
 static void parse_codec_mode(char *buf, struct hda_bus *bus,
 			     struct hda_codec **codecp)
 {
-	unsigned int vendorid, subid, caddr;
+	int vendorid, subid, caddr;
 	struct hda_codec *codec;
 
 	*codecp = NULL;
 	if (sscanf(buf, "%i %i %i", &vendorid, &subid, &caddr) == 3) {
 		list_for_each_entry(codec, &bus->codec_list, list) {
-			if (codec->vendor_id == vendorid &&
-			    codec->subsystem_id == subid &&
+			if ((vendorid <= 0 || codec->vendor_id == vendorid) &&
+			    (subid <= 0 || codec->subsystem_id == subid) &&
 			    codec->addr == caddr) {
 				*codecp = codec;
 				break;

commit 2385b789f1525542396d8f6b0cc37c1eb2493b4c
Author: David Henningsson <diwic@ubuntu.com>
Date:   Wed Jun 2 16:56:41 2010 +0200

    ALSA: hda - Ensure codec patch files are checked for the correct codec ID
    
    Signed-off-by: David Henningsson <diwic@ubuntu.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index a1fc83753cc6..bf3ced51e0f8 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -649,7 +649,9 @@ static void parse_codec_mode(char *buf, struct hda_bus *bus,
 	*codecp = NULL;
 	if (sscanf(buf, "%i %i %i", &vendorid, &subid, &caddr) == 3) {
 		list_for_each_entry(codec, &bus->codec_list, list) {
-			if (codec->addr == caddr) {
+			if (codec->vendor_id == vendorid &&
+			    codec->subsystem_id == subid &&
+			    codec->addr == caddr) {
 				*codecp = codec;
 				break;
 			}

commit b09f3e78ee7bb69171411b75bd9e771fc7f24749
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 28 00:01:53 2010 +0100

    ALSA: hda - Allow override more fields via patch loader
    
    Allow the override of vendor-id, subsystem-id, revision-id and chip name
    via patch loading.  Updated the document, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index b36919c0d363..a1fc83753cc6 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -625,6 +625,10 @@ enum {
 	LINE_MODE_PINCFG,
 	LINE_MODE_VERB,
 	LINE_MODE_HINT,
+	LINE_MODE_VENDOR_ID,
+	LINE_MODE_SUBSYSTEM_ID,
+	LINE_MODE_REVISION_ID,
+	LINE_MODE_CHIP_NAME,
 	NUM_LINE_MODES,
 };
 
@@ -654,53 +658,71 @@ static void parse_codec_mode(char *buf, struct hda_bus *bus,
 }
 
 /* parse the contents after the other command tags, [pincfg], [verb],
- * [hint] and [model]
+ * [vendor_id], [subsystem_id], [revision_id], [chip_name], [hint] and [model]
  * just pass to the sysfs helper (only when any codec was specified)
  */
 static void parse_pincfg_mode(char *buf, struct hda_bus *bus,
 			      struct hda_codec **codecp)
 {
-	if (!*codecp)
-		return;
 	parse_user_pin_configs(*codecp, buf);
 }
 
 static void parse_verb_mode(char *buf, struct hda_bus *bus,
 			    struct hda_codec **codecp)
 {
-	if (!*codecp)
-		return;
 	parse_init_verbs(*codecp, buf);
 }
 
 static void parse_hint_mode(char *buf, struct hda_bus *bus,
 			    struct hda_codec **codecp)
 {
-	if (!*codecp)
-		return;
 	parse_hints(*codecp, buf);
 }
 
 static void parse_model_mode(char *buf, struct hda_bus *bus,
 			     struct hda_codec **codecp)
 {
-	if (!*codecp)
-		return;
 	kfree((*codecp)->modelname);
 	(*codecp)->modelname = kstrdup(buf, GFP_KERNEL);
 }
 
+static void parse_chip_name_mode(char *buf, struct hda_bus *bus,
+				 struct hda_codec **codecp)
+{
+	kfree((*codecp)->chip_name);
+	(*codecp)->chip_name = kstrdup(buf, GFP_KERNEL);
+}
+
+#define DEFINE_PARSE_ID_MODE(name) \
+static void parse_##name##_mode(char *buf, struct hda_bus *bus, \
+				 struct hda_codec **codecp) \
+{ \
+	unsigned long val; \
+	if (!strict_strtoul(buf, 0, &val)) \
+		(*codecp)->name = val; \
+}
+
+DEFINE_PARSE_ID_MODE(vendor_id);
+DEFINE_PARSE_ID_MODE(subsystem_id);
+DEFINE_PARSE_ID_MODE(revision_id);
+
+
 struct hda_patch_item {
 	const char *tag;
 	void (*parser)(char *buf, struct hda_bus *bus, struct hda_codec **retc);
+	int need_codec;
 };
 
 static struct hda_patch_item patch_items[NUM_LINE_MODES] = {
-	[LINE_MODE_CODEC] = { "[codec]", parse_codec_mode },
-	[LINE_MODE_MODEL] = { "[model]", parse_model_mode },
-	[LINE_MODE_VERB] = { "[verb]", parse_verb_mode },
-	[LINE_MODE_PINCFG] = { "[pincfg]", parse_pincfg_mode },
-	[LINE_MODE_HINT] = { "[hint]", parse_hint_mode },
+	[LINE_MODE_CODEC] = { "[codec]", parse_codec_mode, 0 },
+	[LINE_MODE_MODEL] = { "[model]", parse_model_mode, 1 },
+	[LINE_MODE_VERB] = { "[verb]", parse_verb_mode, 1 },
+	[LINE_MODE_PINCFG] = { "[pincfg]", parse_pincfg_mode, 1 },
+	[LINE_MODE_HINT] = { "[hint]", parse_hint_mode, 1 },
+	[LINE_MODE_VENDOR_ID] = { "[vendor_id]", parse_vendor_id_mode, 1 },
+	[LINE_MODE_SUBSYSTEM_ID] = { "[subsystem_id]", parse_subsystem_id_mode, 1 },
+	[LINE_MODE_REVISION_ID] = { "[revision_id]", parse_revision_id_mode, 1 },
+	[LINE_MODE_CHIP_NAME] = { "[chip_name]", parse_chip_name_mode, 1 },
 };
 
 /* check the line starting with '[' -- change the parser mode accodingly */
@@ -783,7 +805,8 @@ int snd_hda_load_patch(struct hda_bus *bus, const char *patch)
 			continue;
 		if (*buf == '[')
 			line_mode = parse_line_mode(buf, bus);
-		else if (patch_items[line_mode].parser)
+		else if (patch_items[line_mode].parser &&
+			 (codec || !patch_items[line_mode].need_codec))
 			patch_items[line_mode].parser(buf, bus, &codec);
 	}
 	release_firmware(fw);

commit 014c41fce1bd5cec381e70fc6f58fdfc96cdaf69
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Dec 27 13:53:24 2009 +0100

    ALSA: hda - Use strict_strtoul()
    
    Rewrite the codes to use strict_strtoul() instead of simple_strtoul().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 40ccb419b6e9..b36919c0d363 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -293,8 +293,11 @@ static ssize_t type##_store(struct device *dev,			\
 {								\
 	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
 	struct hda_codec *codec = hwdep->private_data;		\
-	char *after;						\
-	codec->type = simple_strtoul(buf, &after, 0);		\
+	unsigned long val;					\
+	int err = strict_strtoul(buf, 0, &val);			\
+	if (err < 0)						\
+		return err;					\
+	codec->type = val;					\
 	return count;						\
 }
 

commit e7d2860b690d4f3bed6824757c540579638e3d1e
Author: Andr Goddard Rosa <andre.goddard@gmail.com>
Date:   Mon Dec 14 18:01:06 2009 -0800

    tree-wide: convert open calls to remove spaces to skip_spaces() lib function
    
    Makes use of skip_spaces() defined in lib/string.c for removing leading
    spaces from strings all over the tree.
    
    It decreases lib.a code size by 47 bytes and reuses the function tree-wide:
       text    data     bss     dec     hex filename
      64688     584     592   65864   10148 (TOTALS-BEFORE)
      64641     584     592   65817   10119 (TOTALS-AFTER)
    
    Also, while at it, if we see (*str && isspace(*str)), we can be sure to
    remove the first condition (*str) as the second one (isspace(*str)) also
    evaluates to 0 whenever *str == 0, making it redundant. In other words,
    "a char equals zero is never a space".
    
    Julia Lawall tried the semantic patch (http://coccinelle.lip6.fr) below,
    and found occurrences of this pattern on 3 more files:
        drivers/leds/led-class.c
        drivers/leds/ledtrig-timer.c
        drivers/video/output.c
    
    @@
    expression str;
    @@
    
    ( // ignore skip_spaces cases
    while (*str &&  isspace(*str)) { \(str++;\|++str;\) }
    |
    - *str &&
    isspace(*str)
    )
    
    Signed-off-by: Andr Goddard Rosa <andre.goddard@gmail.com>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Cc: David Howells <dhowells@redhat.com>
    Cc: <linux-ext4@vger.kernel.org>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index d24328661c6a..40ccb419b6e9 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -24,6 +24,7 @@
 #include <linux/compat.h>
 #include <linux/mutex.h>
 #include <linux/ctype.h>
+#include <linux/string.h>
 #include <linux/firmware.h>
 #include <sound/core.h>
 #include "hda_codec.h"
@@ -428,8 +429,7 @@ static int parse_hints(struct hda_codec *codec, const char *buf)
 	char *key, *val;
 	struct hda_hint *hint;
 
-	while (isspace(*buf))
-		buf++;
+	buf = skip_spaces(buf);
 	if (!*buf || *buf == '#' || *buf == '\n')
 		return 0;
 	if (*buf == '=')
@@ -444,8 +444,7 @@ static int parse_hints(struct hda_codec *codec, const char *buf)
 		return -EINVAL;
 	}
 	*val++ = 0;
-	while (isspace(*val))
-		val++;
+	val = skip_spaces(val);
 	remove_trail_spaces(key);
 	remove_trail_spaces(val);
 	hint = get_hint(codec, key);

commit a2f6309e8392e2c14c04594fca8b4876c8c9bc36
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 11 09:34:25 2009 +0100

    ALSA: hda - Add power on/off counter
    
    Added the power on/off counter and expose via sysfs files.
    The sysfs files, power_on_acct and power_off_acct, are created under
    each codec hwdep sysfs directory (e.g. /sys/class/sound/hwC0D0).
    The files show the msec length of the codec power-on and power-off,
    respectively.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index cc24e6721d74..d24328661c6a 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -154,6 +154,44 @@ int /*__devinit*/ snd_hda_create_hwdep(struct hda_codec *codec)
 	return 0;
 }
 
+#ifdef CONFIG_SND_HDA_POWER_SAVE
+static ssize_t power_on_acct_show(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	snd_hda_update_power_acct(codec);
+	return sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_on_acct));
+}
+
+static ssize_t power_off_acct_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	snd_hda_update_power_acct(codec);
+	return sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_off_acct));
+}
+
+static struct device_attribute power_attrs[] = {
+	__ATTR_RO(power_on_acct),
+	__ATTR_RO(power_off_acct),
+};
+
+int snd_hda_hwdep_add_power_sysfs(struct hda_codec *codec)
+{
+	struct snd_hwdep *hwdep = codec->hwdep;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(power_attrs); i++)
+		snd_add_device_sysfs_file(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card,
+					  hwdep->device, &power_attrs[i]);
+	return 0;
+}
+#endif /* CONFIG_SND_HDA_POWER_SAVE */
+
 #ifdef CONFIG_SND_HDA_RECONFIG
 
 /*

commit 4ea6fbc8eb23c3ae5fd2fb55a340ab85c8649bce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 17 09:52:54 2009 +0200

    ALSA: hda - Add patch module option
    
    Added the patch module option to apply a "patch" as a firmware to
    modify pin configurations or give additional hints to the driver
    before actually initializing and configuring the codec.
    
    This can be used as a workaround when the BIOS doesn't give sufficient
    information or give wrong information that doesn't match with the real
    hardware setup, until it's fixed statically in the driver via a quirk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 6812fbe80fa4..cc24e6721d74 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -24,6 +24,7 @@
 #include <linux/compat.h>
 #include <linux/mutex.h>
 #include <linux/ctype.h>
+#include <linux/firmware.h>
 #include <sound/core.h>
 #include "hda_codec.h"
 #include "hda_local.h"
@@ -312,12 +313,8 @@ static ssize_t init_verbs_show(struct device *dev,
 	return len;
 }
 
-static ssize_t init_verbs_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t count)
+static int parse_init_verbs(struct hda_codec *codec, const char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
 	struct hda_verb *v;
 	int nid, verb, param;
 
@@ -331,6 +328,18 @@ static ssize_t init_verbs_store(struct device *dev,
 	v->nid = nid;
 	v->verb = verb;
 	v->param = param;
+	return 0;
+}
+
+static ssize_t init_verbs_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	int err = parse_init_verbs(codec, buf);
+	if (err < 0)
+		return err;
 	return count;
 }
 
@@ -376,19 +385,15 @@ static void remove_trail_spaces(char *str)
 
 #define MAX_HINTS	1024
 
-static ssize_t hints_store(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
+static int parse_hints(struct hda_codec *codec, const char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
 	char *key, *val;
 	struct hda_hint *hint;
 
 	while (isspace(*buf))
 		buf++;
 	if (!*buf || *buf == '#' || *buf == '\n')
-		return count;
+		return 0;
 	if (*buf == '=')
 		return -EINVAL;
 	key = kstrndup_noeol(buf, 1024);
@@ -411,7 +416,7 @@ static ssize_t hints_store(struct device *dev,
 		kfree(hint->key);
 		hint->key = key;
 		hint->val = val;
-		return count;
+		return 0;
 	}
 	/* allocate a new hint entry */
 	if (codec->hints.used >= MAX_HINTS)
@@ -424,6 +429,18 @@ static ssize_t hints_store(struct device *dev,
 	}
 	hint->key = key;
 	hint->val = val;
+	return 0;
+}
+
+static ssize_t hints_store(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	int err = parse_hints(codec, buf);
+	if (err < 0)
+		return err;
 	return count;
 }
 
@@ -469,20 +486,24 @@ static ssize_t driver_pin_configs_show(struct device *dev,
 
 #define MAX_PIN_CONFIGS		32
 
-static ssize_t user_pin_configs_store(struct device *dev,
-				      struct device_attribute *attr,
-				      const char *buf, size_t count)
+static int parse_user_pin_configs(struct hda_codec *codec, const char *buf)
 {
-	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
-	struct hda_codec *codec = hwdep->private_data;
 	int nid, cfg;
-	int err;
 
 	if (sscanf(buf, "%i %i", &nid, &cfg) != 2)
 		return -EINVAL;
 	if (!nid)
 		return -EINVAL;
-	err = snd_hda_add_pincfg(codec, &codec->user_pins, nid, cfg);
+	return snd_hda_add_pincfg(codec, &codec->user_pins, nid, cfg);
+}
+
+static ssize_t user_pin_configs_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	int err = parse_user_pin_configs(codec, buf);
 	if (err < 0)
 		return err;
 	return count;
@@ -553,3 +574,180 @@ int snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)
 EXPORT_SYMBOL_HDA(snd_hda_get_bool_hint);
 
 #endif /* CONFIG_SND_HDA_RECONFIG */
+
+#ifdef CONFIG_SND_HDA_PATCH_LOADER
+
+/* parser mode */
+enum {
+	LINE_MODE_NONE,
+	LINE_MODE_CODEC,
+	LINE_MODE_MODEL,
+	LINE_MODE_PINCFG,
+	LINE_MODE_VERB,
+	LINE_MODE_HINT,
+	NUM_LINE_MODES,
+};
+
+static inline int strmatch(const char *a, const char *b)
+{
+	return strnicmp(a, b, strlen(b)) == 0;
+}
+
+/* parse the contents after the line "[codec]"
+ * accept only the line with three numbers, and assign the current codec
+ */
+static void parse_codec_mode(char *buf, struct hda_bus *bus,
+			     struct hda_codec **codecp)
+{
+	unsigned int vendorid, subid, caddr;
+	struct hda_codec *codec;
+
+	*codecp = NULL;
+	if (sscanf(buf, "%i %i %i", &vendorid, &subid, &caddr) == 3) {
+		list_for_each_entry(codec, &bus->codec_list, list) {
+			if (codec->addr == caddr) {
+				*codecp = codec;
+				break;
+			}
+		}
+	}
+}
+
+/* parse the contents after the other command tags, [pincfg], [verb],
+ * [hint] and [model]
+ * just pass to the sysfs helper (only when any codec was specified)
+ */
+static void parse_pincfg_mode(char *buf, struct hda_bus *bus,
+			      struct hda_codec **codecp)
+{
+	if (!*codecp)
+		return;
+	parse_user_pin_configs(*codecp, buf);
+}
+
+static void parse_verb_mode(char *buf, struct hda_bus *bus,
+			    struct hda_codec **codecp)
+{
+	if (!*codecp)
+		return;
+	parse_init_verbs(*codecp, buf);
+}
+
+static void parse_hint_mode(char *buf, struct hda_bus *bus,
+			    struct hda_codec **codecp)
+{
+	if (!*codecp)
+		return;
+	parse_hints(*codecp, buf);
+}
+
+static void parse_model_mode(char *buf, struct hda_bus *bus,
+			     struct hda_codec **codecp)
+{
+	if (!*codecp)
+		return;
+	kfree((*codecp)->modelname);
+	(*codecp)->modelname = kstrdup(buf, GFP_KERNEL);
+}
+
+struct hda_patch_item {
+	const char *tag;
+	void (*parser)(char *buf, struct hda_bus *bus, struct hda_codec **retc);
+};
+
+static struct hda_patch_item patch_items[NUM_LINE_MODES] = {
+	[LINE_MODE_CODEC] = { "[codec]", parse_codec_mode },
+	[LINE_MODE_MODEL] = { "[model]", parse_model_mode },
+	[LINE_MODE_VERB] = { "[verb]", parse_verb_mode },
+	[LINE_MODE_PINCFG] = { "[pincfg]", parse_pincfg_mode },
+	[LINE_MODE_HINT] = { "[hint]", parse_hint_mode },
+};
+
+/* check the line starting with '[' -- change the parser mode accodingly */
+static int parse_line_mode(char *buf, struct hda_bus *bus)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(patch_items); i++) {
+		if (!patch_items[i].tag)
+			continue;
+		if (strmatch(buf, patch_items[i].tag))
+			return i;
+	}
+	return LINE_MODE_NONE;
+}
+
+/* copy one line from the buffer in fw, and update the fields in fw
+ * return zero if it reaches to the end of the buffer, or non-zero
+ * if successfully copied a line
+ *
+ * the spaces at the beginning and the end of the line are stripped
+ */
+static int get_line_from_fw(char *buf, int size, struct firmware *fw)
+{
+	int len;
+	const char *p = fw->data;
+	while (isspace(*p) && fw->size) {
+		p++;
+		fw->size--;
+	}
+	if (!fw->size)
+		return 0;
+	if (size < fw->size)
+		size = fw->size;
+
+	for (len = 0; len < fw->size; len++) {
+		if (!*p)
+			break;
+		if (*p == '\n') {
+			p++;
+			len++;
+			break;
+		}
+		if (len < size)
+			*buf++ = *p++;
+	}
+	*buf = 0;
+	fw->size -= len;
+	fw->data = p;
+	remove_trail_spaces(buf);
+	return 1;
+}
+
+/*
+ * load a "patch" firmware file and parse it
+ */
+int snd_hda_load_patch(struct hda_bus *bus, const char *patch)
+{
+	int err;
+	const struct firmware *fw;
+	struct firmware tmp;
+	char buf[128];
+	struct hda_codec *codec;
+	int line_mode;
+	struct device *dev = bus->card->dev;
+
+	if (snd_BUG_ON(!dev))
+		return -ENODEV;
+	err = request_firmware(&fw, patch, dev);
+	if (err < 0) {
+		printk(KERN_ERR "hda-codec: Cannot load the patch '%s'\n",
+		       patch);
+		return err;
+	}
+
+	tmp = *fw;
+	line_mode = LINE_MODE_NONE;
+	codec = NULL;
+	while (get_line_from_fw(buf, sizeof(buf) - 1, &tmp)) {
+		if (!*buf || *buf == '#' || *buf == '\n')
+			continue;
+		if (*buf == '[')
+			line_mode = parse_line_mode(buf, bus);
+		else if (patch_items[line_mode].parser)
+			patch_items[line_mode].parser(buf, bus, &codec);
+	}
+	release_firmware(fw);
+	return 0;
+}
+EXPORT_SYMBOL_HDA(snd_hda_load_patch);
+#endif /* CONFIG_SND_HDA_PATCH_LOADER */

commit 812a2cca295ee7f56cd1b988a0f93646285c214a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat May 16 10:00:49 2009 +0200

    ALSA: hda - Split codec->name to vendor and chip name strings
    
    Split the name string in hda_codec struct to vendor_name and chip_name
    strings to be stored directly from the preset name.
    Since mostly only the chip name is referred in many patch_*.c, this
    results in the reduction of many codes in the end.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 1c57505c2874..6812fbe80fa4 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -242,7 +242,8 @@ CODEC_INFO_SHOW(subsystem_id);
 CODEC_INFO_SHOW(revision_id);
 CODEC_INFO_SHOW(afg);
 CODEC_INFO_SHOW(mfg);
-CODEC_INFO_STR_SHOW(name);
+CODEC_INFO_STR_SHOW(vendor_name);
+CODEC_INFO_STR_SHOW(chip_name);
 CODEC_INFO_STR_SHOW(modelname);
 
 #define CODEC_INFO_STORE(type)					\
@@ -275,7 +276,8 @@ static ssize_t type##_store(struct device *dev,			\
 CODEC_INFO_STORE(vendor_id);
 CODEC_INFO_STORE(subsystem_id);
 CODEC_INFO_STORE(revision_id);
-CODEC_INFO_STR_STORE(name);
+CODEC_INFO_STR_STORE(vendor_name);
+CODEC_INFO_STR_STORE(chip_name);
 CODEC_INFO_STR_STORE(modelname);
 
 #define CODEC_ACTION_STORE(type)				\
@@ -499,7 +501,8 @@ static struct device_attribute codec_attrs[] = {
 	CODEC_ATTR_RW(revision_id),
 	CODEC_ATTR_RO(afg),
 	CODEC_ATTR_RO(mfg),
-	CODEC_ATTR_RW(name),
+	CODEC_ATTR_RW(vendor_name),
+	CODEC_ATTR_RW(chip_name),
 	CODEC_ATTR_RW(modelname),
 	CODEC_ATTR_RW(init_verbs),
 	CODEC_ATTR_RW(hints),

commit bb6ac72fb19c6676eb8bafa8e3b8bf970a2294a2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 13 09:02:42 2009 +0100

    ALSA: hda - power up before codec initialization
    
    Change the power state of each widget before starting the initialization
    work so that all verbs are executed properly.
    
    Also, keep power-up during hwdep reconfiguration.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 1e3ccc740afc..1c57505c2874 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -176,25 +176,29 @@ static int reconfig_codec(struct hda_codec *codec)
 {
 	int err;
 
+	snd_hda_power_up(codec);
 	snd_printk(KERN_INFO "hda-codec: reconfiguring\n");
 	err = snd_hda_codec_reset(codec);
 	if (err < 0) {
 		snd_printk(KERN_ERR
 			   "The codec is being used, can't reconfigure.\n");
-		return err;
+		goto error;
 	}
 	err = snd_hda_codec_configure(codec);
 	if (err < 0)
-		return err;
+		goto error;
 	/* rebuild PCMs */
 	err = snd_hda_codec_build_pcms(codec);
 	if (err < 0)
-		return err;
+		goto error;
 	/* rebuild mixers */
 	err = snd_hda_codec_build_controls(codec);
 	if (err < 0)
-		return err;
-	return snd_card_register(codec->bus->card);
+		goto error;
+	err = snd_card_register(codec->bus->card);
+ error:
+	snd_hda_power_down(codec);
+	return err;
 }
 
 /*

commit ab1726f920275b52991b2eff7538ac6d313bf9a2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 2 17:09:25 2009 +0100

    ALSA: hda - Add show for init_verbs and hints sysfs entries
    
    Added the show method for init_verbs and hints hwdep sysfs entries.
    They show the current values.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 5e554de9cd9b..1e3ccc740afc 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -290,6 +290,22 @@ static ssize_t type##_store(struct device *dev,			\
 CODEC_ACTION_STORE(reconfig);
 CODEC_ACTION_STORE(clear);
 
+static ssize_t init_verbs_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	int i, len = 0;
+	for (i = 0; i < codec->init_verbs.used; i++) {
+		struct hda_verb *v = snd_array_elem(&codec->init_verbs, i);
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"0x%02x 0x%03x 0x%04x\n",
+				v->nid, v->verb, v->param);
+	}
+	return len;
+}
+
 static ssize_t init_verbs_store(struct device *dev,
 				struct device_attribute *attr,
 				const char *buf, size_t count)
@@ -312,6 +328,21 @@ static ssize_t init_verbs_store(struct device *dev,
 	return count;
 }
 
+static ssize_t hints_show(struct device *dev,
+			  struct device_attribute *attr,
+			  char *buf)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	int i, len = 0;
+	for (i = 0; i < codec->hints.used; i++) {
+		struct hda_hint *hint = snd_array_elem(&codec->hints, i);
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"%s = %s\n", hint->key, hint->val);
+	}
+	return len;
+}
+
 static struct hda_hint *get_hint(struct hda_codec *codec, const char *key)
 {
 	int i;
@@ -466,8 +497,8 @@ static struct device_attribute codec_attrs[] = {
 	CODEC_ATTR_RO(mfg),
 	CODEC_ATTR_RW(name),
 	CODEC_ATTR_RW(modelname),
-	CODEC_ATTR_WO(init_verbs),
-	CODEC_ATTR_WO(hints),
+	CODEC_ATTR_RW(init_verbs),
+	CODEC_ATTR_RW(hints),
 	CODEC_ATTR_RO(init_pin_configs),
 	CODEC_ATTR_RW(user_pin_configs),
 	CODEC_ATTR_RO(driver_pin_configs),

commit 43b62713f67d9f0655f3a61f5bd14d6297ddd3ce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 2 14:25:17 2009 +0100

    ALSA: hda - Add hint string helper functions
    
    Added snd_hda_get_hint() and snd_hda_get_bool_hint() helper functions
    to retrieve a hint value.
    
    Internally, the hint is stored in a pair of two strings, key and val.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 4af484b8240c..5e554de9cd9b 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -30,6 +30,12 @@
 #include <sound/hda_hwdep.h>
 #include <sound/minors.h>
 
+/* hint string pair */
+struct hda_hint {
+	const char *key;
+	const char *val;	/* contained in the same alloc as key */
+};
+
 /*
  * write/read an out-of-bound verb
  */
@@ -99,15 +105,15 @@ static int hda_hwdep_open(struct snd_hwdep *hw, struct file *file)
 
 static void clear_hwdep_elements(struct hda_codec *codec)
 {
-	char **head;
 	int i;
 
 	/* clear init verbs */
 	snd_array_free(&codec->init_verbs);
 	/* clear hints */
-	head = codec->hints.list;
-	for (i = 0; i < codec->hints.used; i++, head++)
-		kfree(*head);
+	for (i = 0; i < codec->hints.used; i++) {
+		struct hda_hint *hint = snd_array_elem(&codec->hints, i);
+		kfree(hint->key); /* we don't need to free hint->val */
+	}
 	snd_array_free(&codec->hints);
 	snd_array_free(&codec->user_pins);
 }
@@ -141,7 +147,7 @@ int /*__devinit*/ snd_hda_create_hwdep(struct hda_codec *codec)
 #endif
 
 	snd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);
-	snd_array_init(&codec->hints, sizeof(char *), 32);
+	snd_array_init(&codec->hints, sizeof(struct hda_hint), 32);
 	snd_array_init(&codec->user_pins, sizeof(struct hda_pincfg), 16);
 
 	return 0;
@@ -306,26 +312,81 @@ static ssize_t init_verbs_store(struct device *dev,
 	return count;
 }
 
+static struct hda_hint *get_hint(struct hda_codec *codec, const char *key)
+{
+	int i;
+
+	for (i = 0; i < codec->hints.used; i++) {
+		struct hda_hint *hint = snd_array_elem(&codec->hints, i);
+		if (!strcmp(hint->key, key))
+			return hint;
+	}
+	return NULL;
+}
+
+static void remove_trail_spaces(char *str)
+{
+	char *p;
+	if (!*str)
+		return;
+	p = str + strlen(str) - 1;
+	for (; isspace(*p); p--) {
+		*p = 0;
+		if (p == str)
+			return;
+	}
+}
+
+#define MAX_HINTS	1024
+
 static ssize_t hints_store(struct device *dev,
 			   struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
 	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
 	struct hda_codec *codec = hwdep->private_data;
-	char *p;
-	char **hint;
+	char *key, *val;
+	struct hda_hint *hint;
 
-	if (!*buf || isspace(*buf) || *buf == '#' || *buf == '\n')
+	while (isspace(*buf))
+		buf++;
+	if (!*buf || *buf == '#' || *buf == '\n')
 		return count;
-	p = kstrndup_noeol(buf, 1024);
-	if (!p)
+	if (*buf == '=')
+		return -EINVAL;
+	key = kstrndup_noeol(buf, 1024);
+	if (!key)
 		return -ENOMEM;
-	hint = snd_array_new(&codec->hints);
+	/* extract key and val */
+	val = strchr(key, '=');
+	if (!val) {
+		kfree(key);
+		return -EINVAL;
+	}
+	*val++ = 0;
+	while (isspace(*val))
+		val++;
+	remove_trail_spaces(key);
+	remove_trail_spaces(val);
+	hint = get_hint(codec, key);
+	if (hint) {
+		/* replace */
+		kfree(hint->key);
+		hint->key = key;
+		hint->val = val;
+		return count;
+	}
+	/* allocate a new hint entry */
+	if (codec->hints.used >= MAX_HINTS)
+		hint = NULL;
+	else
+		hint = snd_array_new(&codec->hints);
 	if (!hint) {
-		kfree(p);
+		kfree(key);
 		return -ENOMEM;
 	}
-	*hint = p;
+	hint->key = key;
+	hint->val = val;
 	return count;
 }
 
@@ -428,4 +489,29 @@ int snd_hda_hwdep_add_sysfs(struct hda_codec *codec)
 	return 0;
 }
 
+/*
+ * Look for hint string
+ */
+const char *snd_hda_get_hint(struct hda_codec *codec, const char *key)
+{
+	struct hda_hint *hint = get_hint(codec, key);
+	return hint ? hint->val : NULL;
+}
+EXPORT_SYMBOL_HDA(snd_hda_get_hint);
+
+int snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)
+{
+	const char *p = snd_hda_get_hint(codec, key);
+	if (!p || !*p)
+		return -ENOENT;
+	switch (toupper(*p)) {
+	case 'T': /* true */
+	case 'Y': /* yes */
+	case '1':
+		return 1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_HDA(snd_hda_get_bool_hint);
+
 #endif /* CONFIG_SND_HDA_RECONFIG */

commit a65d629ceb4cff5e7d5edadfd6bf1f64c370a517
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 23 16:57:04 2009 +0100

    ALSA: hda - Add pseudo device-locking for clear/reconfig
    
    Added the pseudo device-locking using card->shutdown flag to avoid
    the crash via clear/reconfig during operations.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index c660383ef381..4af484b8240c 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -155,7 +155,13 @@ int /*__devinit*/ snd_hda_create_hwdep(struct hda_codec *codec)
 
 static int clear_codec(struct hda_codec *codec)
 {
-	snd_hda_codec_reset(codec);
+	int err;
+
+	err = snd_hda_codec_reset(codec);
+	if (err < 0) {
+		snd_printk(KERN_ERR "The codec is being used, can't free.\n");
+		return err;
+	}
 	clear_hwdep_elements(codec);
 	return 0;
 }
@@ -165,7 +171,12 @@ static int reconfig_codec(struct hda_codec *codec)
 	int err;
 
 	snd_printk(KERN_INFO "hda-codec: reconfiguring\n");
-	snd_hda_codec_reset(codec);
+	err = snd_hda_codec_reset(codec);
+	if (err < 0) {
+		snd_printk(KERN_ERR
+			   "The codec is being used, can't reconfigure.\n");
+		return err;
+	}
 	err = snd_hda_codec_configure(codec);
 	if (err < 0)
 		return err;

commit 346ff70fdbe9093947b9494fe714c89cafcceade
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 23 09:42:57 2009 +0100

    ALSA: hda - Rename {override,cur}_pin with {user,driver}_pin
    
    Rename from override_pin and cur_pin with user_pin and driver_pin,
    respectively, to be a bit more intuitive.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 71039a6dec28..c660383ef381 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -109,7 +109,7 @@ static void clear_hwdep_elements(struct hda_codec *codec)
 	for (i = 0; i < codec->hints.used; i++, head++)
 		kfree(*head);
 	snd_array_free(&codec->hints);
-	snd_array_free(&codec->override_pins);
+	snd_array_free(&codec->user_pins);
 }
 
 static void hwdep_free(struct snd_hwdep *hwdep)
@@ -142,7 +142,7 @@ int /*__devinit*/ snd_hda_create_hwdep(struct hda_codec *codec)
 
 	snd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);
 	snd_array_init(&codec->hints, sizeof(char *), 32);
-	snd_array_init(&codec->override_pins, sizeof(struct hda_pincfg), 16);
+	snd_array_init(&codec->user_pins, sizeof(struct hda_pincfg), 16);
 
 	return 0;
 }
@@ -340,29 +340,29 @@ static ssize_t init_pin_configs_show(struct device *dev,
 	return pin_configs_show(codec, &codec->init_pins, buf);
 }
 
-static ssize_t override_pin_configs_show(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf)
+static ssize_t user_pin_configs_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
 {
 	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
 	struct hda_codec *codec = hwdep->private_data;
-	return pin_configs_show(codec, &codec->override_pins, buf);
+	return pin_configs_show(codec, &codec->user_pins, buf);
 }
 
-static ssize_t cur_pin_configs_show(struct device *dev,
-				    struct device_attribute *attr,
-				    char *buf)
+static ssize_t driver_pin_configs_show(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
 {
 	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
 	struct hda_codec *codec = hwdep->private_data;
-	return pin_configs_show(codec, &codec->cur_pins, buf);
+	return pin_configs_show(codec, &codec->driver_pins, buf);
 }
 
 #define MAX_PIN_CONFIGS		32
 
-static ssize_t override_pin_configs_store(struct device *dev,
-					  struct device_attribute *attr,
-					  const char *buf, size_t count)
+static ssize_t user_pin_configs_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
 {
 	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
 	struct hda_codec *codec = hwdep->private_data;
@@ -373,7 +373,7 @@ static ssize_t override_pin_configs_store(struct device *dev,
 		return -EINVAL;
 	if (!nid)
 		return -EINVAL;
-	err = snd_hda_add_pincfg(codec, &codec->override_pins, nid, cfg);
+	err = snd_hda_add_pincfg(codec, &codec->user_pins, nid, cfg);
 	if (err < 0)
 		return err;
 	return count;
@@ -397,8 +397,8 @@ static struct device_attribute codec_attrs[] = {
 	CODEC_ATTR_WO(init_verbs),
 	CODEC_ATTR_WO(hints),
 	CODEC_ATTR_RO(init_pin_configs),
-	CODEC_ATTR_RW(override_pin_configs),
-	CODEC_ATTR_RO(cur_pin_configs),
+	CODEC_ATTR_RW(user_pin_configs),
+	CODEC_ATTR_RO(driver_pin_configs),
 	CODEC_ATTR_WO(reconfig),
 	CODEC_ATTR_WO(clear),
 };

commit 3be141494a080a9189b51fa78154c975ad8d9806
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 20 14:11:16 2009 +0100

    ALSA: hda - Add generic pincfg initialization
    
    Added the generic pincfg cache and save/restore functions.
    Also introduced the pin-overriding via hwdep sysfs.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 4ae51dcb81af..71039a6dec28 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -109,6 +109,7 @@ static void clear_hwdep_elements(struct hda_codec *codec)
 	for (i = 0; i < codec->hints.used; i++, head++)
 		kfree(*head);
 	snd_array_free(&codec->hints);
+	snd_array_free(&codec->override_pins);
 }
 
 static void hwdep_free(struct snd_hwdep *hwdep)
@@ -141,6 +142,7 @@ int /*__devinit*/ snd_hda_create_hwdep(struct hda_codec *codec)
 
 	snd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);
 	snd_array_init(&codec->hints, sizeof(char *), 32);
+	snd_array_init(&codec->override_pins, sizeof(struct hda_pincfg), 16);
 
 	return 0;
 }
@@ -316,6 +318,67 @@ static ssize_t hints_store(struct device *dev,
 	return count;
 }
 
+static ssize_t pin_configs_show(struct hda_codec *codec,
+				struct snd_array *list,
+				char *buf)
+{
+	int i, len = 0;
+	for (i = 0; i < list->used; i++) {
+		struct hda_pincfg *pin = snd_array_elem(list, i);
+		len += sprintf(buf + len, "0x%02x 0x%08x\n",
+			       pin->nid, pin->cfg);
+	}
+	return len;
+}
+
+static ssize_t init_pin_configs_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	return pin_configs_show(codec, &codec->init_pins, buf);
+}
+
+static ssize_t override_pin_configs_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	return pin_configs_show(codec, &codec->override_pins, buf);
+}
+
+static ssize_t cur_pin_configs_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	return pin_configs_show(codec, &codec->cur_pins, buf);
+}
+
+#define MAX_PIN_CONFIGS		32
+
+static ssize_t override_pin_configs_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	int nid, cfg;
+	int err;
+
+	if (sscanf(buf, "%i %i", &nid, &cfg) != 2)
+		return -EINVAL;
+	if (!nid)
+		return -EINVAL;
+	err = snd_hda_add_pincfg(codec, &codec->override_pins, nid, cfg);
+	if (err < 0)
+		return err;
+	return count;
+}
+
 #define CODEC_ATTR_RW(type) \
 	__ATTR(type, 0644, type##_show, type##_store)
 #define CODEC_ATTR_RO(type) \
@@ -333,6 +396,9 @@ static struct device_attribute codec_attrs[] = {
 	CODEC_ATTR_RW(modelname),
 	CODEC_ATTR_WO(init_verbs),
 	CODEC_ATTR_WO(hints),
+	CODEC_ATTR_RO(init_pin_configs),
+	CODEC_ATTR_RW(override_pin_configs),
+	CODEC_ATTR_RO(cur_pin_configs),
 	CODEC_ATTR_WO(reconfig),
 	CODEC_ATTR_WO(clear),
 };

commit 55290e1932102f57ea17e7cff895914c2dbdb4c4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 20 15:59:01 2009 +0100

    ALSA: hda - Fix parse of init_verbs sysfs entry
    
    Fixed the parse of init_verbs hwdep sysfs entry.
    Simplieied using sscanf.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 482fb0304ca9..4ae51dcb81af 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -277,18 +277,19 @@ static ssize_t init_verbs_store(struct device *dev,
 {
 	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
 	struct hda_codec *codec = hwdep->private_data;
-	char *p;
-	struct hda_verb verb, *v;
+	struct hda_verb *v;
+	int nid, verb, param;
 
-	verb.nid = simple_strtoul(buf, &p, 0);
-	verb.verb = simple_strtoul(p, &p, 0);
-	verb.param = simple_strtoul(p, &p, 0);
-	if (!verb.nid || !verb.verb || !verb.param)
+	if (sscanf(buf, "%i %i %i", &nid, &verb, &param) != 3)
+		return -EINVAL;
+	if (!nid || !verb)
 		return -EINVAL;
 	v = snd_array_new(&codec->init_verbs);
 	if (!v)
 		return -ENOMEM;
-	*v = verb;
+	v->nid = nid;
+	v->verb = verb;
+	v->param = param;
 	return count;
 }
 

commit 26a74f1f61c5bba1c0b46e67e91e921e941f76d7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 12 00:13:19 2009 +0100

    ALSA: hda - Register (new) devices at reconfig
    
    The devices that have been newly added during reconfig must be
    registered.  Otherwise they won't be visible to user-space.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 300ab407cf42..482fb0304ca9 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -175,7 +175,7 @@ static int reconfig_codec(struct hda_codec *codec)
 	err = snd_hda_codec_build_controls(codec);
 	if (err < 0)
 		return err;
-	return 0;
+	return snd_card_register(codec->bus->card);
 }
 
 /*

commit 1289e9e8b42f973f2ab39e5f4f2239ff826c27e9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 27 15:47:11 2008 +0100

    ALSA: hda - Modularize HD-audio driver
    
    Split the monolithc HD-audio driver into several pieces:
     - snd-hda-intel   HD-audio PCI controller driver; loaded via udev
     - snd-hda-codec   HD-audio codec bus driver
     - snd-hda-codec-* Specific HD-audio codec drivers
    
    When built as modules, snd-hda-codec (that is invoked by snd-hda-intel)
    looks up the codec vendor ID and loads the corresponding codec module
    automatically via request_module().
    
    When built in a kernel, each codec drivers are statically hooked up
    before probing the PCI.
    
    This patch adds appropriate EXPORT_SYMBOL_GPL()'s and the module
    information for each driver, and driver-linking codes between
    codec-bus and codec drivers.
    
    TODO:
      - Avoid EXPORT_SYMBOL*() when built-in kernel
      - Restore __devinit appropriately depending on the condition
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 173af489322f..300ab407cf42 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -116,7 +116,7 @@ static void hwdep_free(struct snd_hwdep *hwdep)
 	clear_hwdep_elements(hwdep->private_data);
 }
 
-int __devinit snd_hda_create_hwdep(struct hda_codec *codec)
+int /*__devinit*/ snd_hda_create_hwdep(struct hda_codec *codec)
 {
 	char hwname[16];
 	struct snd_hwdep *hwdep;

commit 529bd6c4a63f8468fd66f63fdc22d7070439b3cd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 27 14:17:01 2008 +0100

    ALSA: hda - Fix PCM reconfigure
    
    The reconfiguration of PCM affected all PCM streams on the bus, but
    this this should be done rather only for the target codec.
    
    This patch does the following:
    - introduce bitmap indicating the PCM device usages on a hda_bus
    - refactor the PCM build functions
    - fix __devinit prefix in some fucntions
    - add a proper ifdef around HDA-reconfig-specific functions
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 5868bbc131cd..173af489322f 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -168,7 +168,7 @@ static int reconfig_codec(struct hda_codec *codec)
 	if (err < 0)
 		return err;
 	/* rebuild PCMs */
-	err = snd_hda_build_pcms(codec->bus);
+	err = snd_hda_codec_build_pcms(codec);
 	if (err < 0)
 		return err;
 	/* rebuild mixers */

commit e7ee058cac89ec2f2c0c9ab0ec92a3776c182642
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 21 09:26:20 2008 +0100

    ALSA: hda - Make CONFIG_SND_HDA_RECONFIG for codec reconfiguration
    
    Make the codec re-configuration feature selectable via Kconfig,
    CONFIG_SND_HDA_RECONFIG.
    Also mark it as experimental (as it really is).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 653da1d3e4df..5868bbc131cd 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -145,6 +145,8 @@ int __devinit snd_hda_create_hwdep(struct hda_codec *codec)
 	return 0;
 }
 
+#ifdef CONFIG_SND_HDA_RECONFIG
+
 /*
  * sysfs interface
  */
@@ -347,3 +349,5 @@ int snd_hda_hwdep_add_sysfs(struct hda_codec *codec)
 					  hwdep->device, &codec_attrs[i]);
 	return 0;
 }
+
+#endif /* CONFIG_SND_HDA_RECONFIG */

commit 1e1be4329f2aec6a8ec63737a69258fedf34c55d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 30 15:01:46 2008 +0200

    ALSA: hda - Add hints for reconfig
    
    This patch adds the "hints" for reconfiguring codecs.  The hints
    are simply string arrays and can be freely used/parsed by the codec
    patch.  The hints can be input via hwdep sysfs files.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index f3400d75eba4..653da1d3e4df 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -23,6 +23,7 @@
 #include <linux/pci.h>
 #include <linux/compat.h>
 #include <linux/mutex.h>
+#include <linux/ctype.h>
 #include <sound/core.h>
 #include "hda_codec.h"
 #include "hda_local.h"
@@ -98,8 +99,16 @@ static int hda_hwdep_open(struct snd_hwdep *hw, struct file *file)
 
 static void clear_hwdep_elements(struct hda_codec *codec)
 {
+	char **head;
+	int i;
+
 	/* clear init verbs */
 	snd_array_free(&codec->init_verbs);
+	/* clear hints */
+	head = codec->hints.list;
+	for (i = 0; i < codec->hints.used; i++, head++)
+		kfree(*head);
+	snd_array_free(&codec->hints);
 }
 
 static void hwdep_free(struct snd_hwdep *hwdep)
@@ -131,6 +140,7 @@ int __devinit snd_hda_create_hwdep(struct hda_codec *codec)
 #endif
 
 	snd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);
+	snd_array_init(&codec->hints, sizeof(char *), 32);
 
 	return 0;
 }
@@ -280,6 +290,29 @@ static ssize_t init_verbs_store(struct device *dev,
 	return count;
 }
 
+static ssize_t hints_store(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	char *p;
+	char **hint;
+
+	if (!*buf || isspace(*buf) || *buf == '#' || *buf == '\n')
+		return count;
+	p = kstrndup_noeol(buf, 1024);
+	if (!p)
+		return -ENOMEM;
+	hint = snd_array_new(&codec->hints);
+	if (!hint) {
+		kfree(p);
+		return -ENOMEM;
+	}
+	*hint = p;
+	return count;
+}
+
 #define CODEC_ATTR_RW(type) \
 	__ATTR(type, 0644, type##_show, type##_store)
 #define CODEC_ATTR_RO(type) \
@@ -296,6 +329,7 @@ static struct device_attribute codec_attrs[] = {
 	CODEC_ATTR_RW(name),
 	CODEC_ATTR_RW(modelname),
 	CODEC_ATTR_WO(init_verbs),
+	CODEC_ATTR_WO(hints),
 	CODEC_ATTR_WO(reconfig),
 	CODEC_ATTR_WO(clear),
 };

commit 11aeff082ad9bd00e8475bf1630c3264344d3764
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 30 15:01:46 2008 +0200

    ALSA: hda - Add init_verbs entries
    
    This patch enables the additional init verbs for each codec.  The verbs
    can be entered via hwdep sysfs file.  These verbs are executed at
    reconfiguring the codec for non-standard setups like overriding
    the pin-defcfg.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 214772c8b556..f3400d75eba4 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -96,6 +96,17 @@ static int hda_hwdep_open(struct snd_hwdep *hw, struct file *file)
 	return 0;
 }
 
+static void clear_hwdep_elements(struct hda_codec *codec)
+{
+	/* clear init verbs */
+	snd_array_free(&codec->init_verbs);
+}
+
+static void hwdep_free(struct snd_hwdep *hwdep)
+{
+	clear_hwdep_elements(hwdep->private_data);
+}
+
 int __devinit snd_hda_create_hwdep(struct hda_codec *codec)
 {
 	char hwname[16];
@@ -110,6 +121,7 @@ int __devinit snd_hda_create_hwdep(struct hda_codec *codec)
 	sprintf(hwdep->name, "HDA Codec %d", codec->addr);
 	hwdep->iface = SNDRV_HWDEP_IFACE_HDA;
 	hwdep->private_data = codec;
+	hwdep->private_free = hwdep_free;
 	hwdep->exclusive = 1;
 
 	hwdep->ops.open = hda_hwdep_open;
@@ -118,6 +130,8 @@ int __devinit snd_hda_create_hwdep(struct hda_codec *codec)
 	hwdep->ops.ioctl_compat = hda_hwdep_ioctl_compat;
 #endif
 
+	snd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);
+
 	return 0;
 }
 
@@ -128,6 +142,7 @@ int __devinit snd_hda_create_hwdep(struct hda_codec *codec)
 static int clear_codec(struct hda_codec *codec)
 {
 	snd_hda_codec_reset(codec);
+	clear_hwdep_elements(codec);
 	return 0;
 }
 
@@ -244,6 +259,27 @@ static ssize_t type##_store(struct device *dev,			\
 CODEC_ACTION_STORE(reconfig);
 CODEC_ACTION_STORE(clear);
 
+static ssize_t init_verbs_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);
+	struct hda_codec *codec = hwdep->private_data;
+	char *p;
+	struct hda_verb verb, *v;
+
+	verb.nid = simple_strtoul(buf, &p, 0);
+	verb.verb = simple_strtoul(p, &p, 0);
+	verb.param = simple_strtoul(p, &p, 0);
+	if (!verb.nid || !verb.verb || !verb.param)
+		return -EINVAL;
+	v = snd_array_new(&codec->init_verbs);
+	if (!v)
+		return -ENOMEM;
+	*v = verb;
+	return count;
+}
+
 #define CODEC_ATTR_RW(type) \
 	__ATTR(type, 0644, type##_show, type##_store)
 #define CODEC_ATTR_RO(type) \
@@ -259,6 +295,7 @@ static struct device_attribute codec_attrs[] = {
 	CODEC_ATTR_RO(mfg),
 	CODEC_ATTR_RW(name),
 	CODEC_ATTR_RW(modelname),
+	CODEC_ATTR_WO(init_verbs),
 	CODEC_ATTR_WO(reconfig),
 	CODEC_ATTR_WO(clear),
 };

commit d7ffba19ce4c1b153d502a89d829400bf76d6c11
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 30 15:01:46 2008 +0200

    ALSA: hda - Add sysfs entries to hwdep devices
    
    Added the sysfs entries to hwdep devices so that the new features
    like reconfiguration can be done via sysfs.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 6e18a422d993..214772c8b556 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -27,6 +27,7 @@
 #include "hda_codec.h"
 #include "hda_local.h"
 #include <sound/hda_hwdep.h>
+#include <sound/minors.h>
 
 /*
  * write/read an out-of-bound verb
@@ -119,3 +120,159 @@ int __devinit snd_hda_create_hwdep(struct hda_codec *codec)
 
 	return 0;
 }
+
+/*
+ * sysfs interface
+ */
+
+static int clear_codec(struct hda_codec *codec)
+{
+	snd_hda_codec_reset(codec);
+	return 0;
+}
+
+static int reconfig_codec(struct hda_codec *codec)
+{
+	int err;
+
+	snd_printk(KERN_INFO "hda-codec: reconfiguring\n");
+	snd_hda_codec_reset(codec);
+	err = snd_hda_codec_configure(codec);
+	if (err < 0)
+		return err;
+	/* rebuild PCMs */
+	err = snd_hda_build_pcms(codec->bus);
+	if (err < 0)
+		return err;
+	/* rebuild mixers */
+	err = snd_hda_codec_build_controls(codec);
+	if (err < 0)
+		return err;
+	return 0;
+}
+
+/*
+ * allocate a string at most len chars, and remove the trailing EOL
+ */
+static char *kstrndup_noeol(const char *src, size_t len)
+{
+	char *s = kstrndup(src, len, GFP_KERNEL);
+	char *p;
+	if (!s)
+		return NULL;
+	p = strchr(s, '\n');
+	if (p)
+		*p = 0;
+	return s;
+}
+
+#define CODEC_INFO_SHOW(type)					\
+static ssize_t type##_show(struct device *dev,			\
+			   struct device_attribute *attr,	\
+			   char *buf)				\
+{								\
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
+	struct hda_codec *codec = hwdep->private_data;		\
+	return sprintf(buf, "0x%x\n", codec->type);		\
+}
+
+#define CODEC_INFO_STR_SHOW(type)				\
+static ssize_t type##_show(struct device *dev,			\
+			     struct device_attribute *attr,	\
+					char *buf)		\
+{								\
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
+	struct hda_codec *codec = hwdep->private_data;		\
+	return sprintf(buf, "%s\n",				\
+		       codec->type ? codec->type : "");		\
+}
+
+CODEC_INFO_SHOW(vendor_id);
+CODEC_INFO_SHOW(subsystem_id);
+CODEC_INFO_SHOW(revision_id);
+CODEC_INFO_SHOW(afg);
+CODEC_INFO_SHOW(mfg);
+CODEC_INFO_STR_SHOW(name);
+CODEC_INFO_STR_SHOW(modelname);
+
+#define CODEC_INFO_STORE(type)					\
+static ssize_t type##_store(struct device *dev,			\
+			    struct device_attribute *attr,	\
+			    const char *buf, size_t count)	\
+{								\
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
+	struct hda_codec *codec = hwdep->private_data;		\
+	char *after;						\
+	codec->type = simple_strtoul(buf, &after, 0);		\
+	return count;						\
+}
+
+#define CODEC_INFO_STR_STORE(type)				\
+static ssize_t type##_store(struct device *dev,			\
+			    struct device_attribute *attr,	\
+			    const char *buf, size_t count)	\
+{								\
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
+	struct hda_codec *codec = hwdep->private_data;		\
+	char *s = kstrndup_noeol(buf, 64);			\
+	if (!s)							\
+		return -ENOMEM;					\
+	kfree(codec->type);					\
+	codec->type = s;					\
+	return count;						\
+}
+
+CODEC_INFO_STORE(vendor_id);
+CODEC_INFO_STORE(subsystem_id);
+CODEC_INFO_STORE(revision_id);
+CODEC_INFO_STR_STORE(name);
+CODEC_INFO_STR_STORE(modelname);
+
+#define CODEC_ACTION_STORE(type)				\
+static ssize_t type##_store(struct device *dev,			\
+			    struct device_attribute *attr,	\
+			    const char *buf, size_t count)	\
+{								\
+	struct snd_hwdep *hwdep = dev_get_drvdata(dev);		\
+	struct hda_codec *codec = hwdep->private_data;		\
+	int err = 0;						\
+	if (*buf)						\
+		err = type##_codec(codec);			\
+	return err < 0 ? err : count;				\
+}
+
+CODEC_ACTION_STORE(reconfig);
+CODEC_ACTION_STORE(clear);
+
+#define CODEC_ATTR_RW(type) \
+	__ATTR(type, 0644, type##_show, type##_store)
+#define CODEC_ATTR_RO(type) \
+	__ATTR_RO(type)
+#define CODEC_ATTR_WO(type) \
+	__ATTR(type, 0200, NULL, type##_store)
+
+static struct device_attribute codec_attrs[] = {
+	CODEC_ATTR_RW(vendor_id),
+	CODEC_ATTR_RW(subsystem_id),
+	CODEC_ATTR_RW(revision_id),
+	CODEC_ATTR_RO(afg),
+	CODEC_ATTR_RO(mfg),
+	CODEC_ATTR_RW(name),
+	CODEC_ATTR_RW(modelname),
+	CODEC_ATTR_WO(reconfig),
+	CODEC_ATTR_WO(clear),
+};
+
+/*
+ * create sysfs files on hwdep directory
+ */
+int snd_hda_hwdep_add_sysfs(struct hda_codec *codec)
+{
+	struct snd_hwdep *hwdep = codec->hwdep;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(codec_attrs); i++)
+		snd_add_device_sysfs_file(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card,
+					  hwdep->device, &codec_attrs[i]);
+	return 0;
+}

commit 62cf872a8eec1f11aacbec0ac3fe3698bfa9b403
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 20 12:15:15 2008 +0200

    [ALSA] Replace CONFIG_SND_DEBUG_DETECT with CONFIG_SND_DEBUG_VERBOSE
    
    Replace CONFIG_SND_DEBUG_DETECT with CONFIG_SND_DEBUG_VERBOSE to
    represent its meaning more better.  This config isn't provided only
    for the detection but for more verbose debug prints in general.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 2177d9af5334..6e18a422d993 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -88,7 +88,7 @@ static int hda_hwdep_ioctl_compat(struct snd_hwdep *hw, struct file *file,
 
 static int hda_hwdep_open(struct snd_hwdep *hw, struct file *file)
 {
-#ifndef CONFIG_SND_DEBUG_DETECT
+#ifndef CONFIG_SND_DEBUG_VERBOSE
 	if (!capable(CAP_SYS_RAWIO))
 		return -EACCES;
 #endif

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index bafb7b01f5a1..2177d9af5334 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -18,7 +18,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/pci.h>

commit 312d045c75fc76e7de51520c3c1b6b5bec565cc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 31 11:08:10 2007 +0200

    [ALSA] hda-intel - Fix compile warning in snd_hwdep_ioctl_compat()
    
    Fix missing cast:
        sound/pci/hda/hda_hwdep.c:86: warning: passing argument 4 of 'hda_hwdep_ioctl' makes integer from pointer without a cast
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
index 64be7b533488..bafb7b01f5a1 100644
--- a/sound/pci/hda/hda_hwdep.c
+++ b/sound/pci/hda/hda_hwdep.c
@@ -83,7 +83,7 @@ static int hda_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 static int hda_hwdep_ioctl_compat(struct snd_hwdep *hw, struct file *file,
 				  unsigned int cmd, unsigned long arg)
 {
-	return hda_hwdep_ioctl(hw, file, cmd, compat_ptr(arg));
+	return hda_hwdep_ioctl(hw, file, cmd, (unsigned long)compat_ptr(arg));
 }
 #endif
 

commit 2807314d467e7dd929c42050031aabbd28e78f0b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 27 18:58:06 2007 +0200

    [ALSA] hda-intel - Add hwdep interface
    
    Added a hwdep interface for each codec (enabled per kconfig).
    This interface can be used for reading/writing HD-audio verbs
    and other purposes as future extensions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/hda/hda_hwdep.c b/sound/pci/hda/hda_hwdep.c
new file mode 100644
index 000000000000..64be7b533488
--- /dev/null
+++ b/sound/pci/hda/hda_hwdep.c
@@ -0,0 +1,122 @@
+/*
+ * HWDEP Interface for HD-audio codec
+ *
+ * Copyright (c) 2007 Takashi Iwai <tiwai@suse.de>
+ *
+ *  This driver is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This driver is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/compat.h>
+#include <linux/mutex.h>
+#include <sound/core.h>
+#include "hda_codec.h"
+#include "hda_local.h"
+#include <sound/hda_hwdep.h>
+
+/*
+ * write/read an out-of-bound verb
+ */
+static int verb_write_ioctl(struct hda_codec *codec,
+			    struct hda_verb_ioctl __user *arg)
+{
+	u32 verb, res;
+
+	if (get_user(verb, &arg->verb))
+		return -EFAULT;
+	res = snd_hda_codec_read(codec, verb >> 24, 0,
+				 (verb >> 8) & 0xffff, verb & 0xff);
+	if (put_user(res, &arg->res))
+		return -EFAULT;
+	return 0;
+}
+
+static int get_wcap_ioctl(struct hda_codec *codec,
+			  struct hda_verb_ioctl __user *arg)
+{
+	u32 verb, res;
+	
+	if (get_user(verb, &arg->verb))
+		return -EFAULT;
+	res = get_wcaps(codec, verb >> 24);
+	if (put_user(res, &arg->res))
+		return -EFAULT;
+	return 0;
+}
+
+
+/*
+ */
+static int hda_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	struct hda_codec *codec = hw->private_data;
+	void __user *argp = (void __user *)arg;
+
+	switch (cmd) {
+	case HDA_IOCTL_PVERSION:
+		return put_user(HDA_HWDEP_VERSION, (int __user *)argp);
+	case HDA_IOCTL_VERB_WRITE:
+		return verb_write_ioctl(codec, argp);
+	case HDA_IOCTL_GET_WCAP:
+		return get_wcap_ioctl(codec, argp);
+	}
+	return -ENOIOCTLCMD;
+}
+
+#ifdef CONFIG_COMPAT
+static int hda_hwdep_ioctl_compat(struct snd_hwdep *hw, struct file *file,
+				  unsigned int cmd, unsigned long arg)
+{
+	return hda_hwdep_ioctl(hw, file, cmd, compat_ptr(arg));
+}
+#endif
+
+static int hda_hwdep_open(struct snd_hwdep *hw, struct file *file)
+{
+#ifndef CONFIG_SND_DEBUG_DETECT
+	if (!capable(CAP_SYS_RAWIO))
+		return -EACCES;
+#endif
+	return 0;
+}
+
+int __devinit snd_hda_create_hwdep(struct hda_codec *codec)
+{
+	char hwname[16];
+	struct snd_hwdep *hwdep;
+	int err;
+
+	sprintf(hwname, "HDA Codec %d", codec->addr);
+	err = snd_hwdep_new(codec->bus->card, hwname, codec->addr, &hwdep);
+	if (err < 0)
+		return err;
+	codec->hwdep = hwdep;
+	sprintf(hwdep->name, "HDA Codec %d", codec->addr);
+	hwdep->iface = SNDRV_HWDEP_IFACE_HDA;
+	hwdep->private_data = codec;
+	hwdep->exclusive = 1;
+
+	hwdep->ops.open = hda_hwdep_open;
+	hwdep->ops.ioctl = hda_hwdep_ioctl;
+#ifdef CONFIG_COMPAT
+	hwdep->ops.ioctl_compat = hda_hwdep_ioctl_compat;
+#endif
+
+	return 0;
+}
