commit ca58f55108fee41d87c9123f85ad4863e5de7f45
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 28 11:58:03 2019 +0100

    ALSA: hda - Fix pending unsol events at shutdown
    
    This is an alternative fix attemp for the issue reported in the commit
    caa8422d01e9 ("ALSA: hda: Flush interrupts on disabling") that was
    reverted later due to regressions.  Instead of tweaking the hardware
    disablement order and the enforced irq flushing, do calling
    cancel_work_sync() of the unsol work early enough, and explicitly
    ignore the unsol events during the shutdown by checking the
    bus->shutdown flag.
    
    Fixes: caa8422d01e9 ("ALSA: hda: Flush interrupts on disabling")
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://lore.kernel.org/r/s5h1ruxt9cz.wl-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 8272b50b8349..6a8564566375 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -43,6 +43,10 @@ static void hda_codec_unsol_event(struct hdac_device *dev, unsigned int ev)
 {
 	struct hda_codec *codec = container_of(dev, struct hda_codec, core);
 
+	/* ignore unsol events during shutdown */
+	if (codec->bus->shutdown)
+		return;
+
 	if (codec->patch_ops.unsol_event)
 		codec->patch_ops.unsol_event(codec, ev);
 }

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 1ec706ced75c..8272b50b8349 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * HD-audio codec driver binding
  * Copyright (c) Takashi Iwai <tiwai@suse.de>

commit 305a0ade180981686eec1f92aa6252a7c6ebb1cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 30 17:46:03 2019 +0100

    ALSA: hda - Serialize codec registrations
    
    In the current code, the codec registration may happen both at the
    codec bind time and the end of the controller probe time.  In a rare
    occasion, they race with each other, leading to Oops due to the still
    uninitialized card device.
    
    This patch introduces a simple flag to prevent the codec registration
    at the codec bind time as long as the controller probe is going on.
    The controller probe invokes snd_card_register() that does the whole
    registration task, and we don't need to register each piece
    beforehand.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 9174f1b3a987..1ec706ced75c 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -115,7 +115,8 @@ static int hda_codec_driver_probe(struct device *dev)
 	err = snd_hda_codec_build_controls(codec);
 	if (err < 0)
 		goto error_module;
-	if (codec->card->registered) {
+	/* only register after the bus probe finished; otherwise it's racy */
+	if (!codec->bus->bus_probing && codec->card->registered) {
 		err = snd_card_register(codec->card);
 		if (err < 0)
 			goto error_module;

commit 6bae5ea9498926440ffc883f3dbceb0adc65e492
Author: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
Date:   Wed Aug 22 15:25:03 2018 -0500

    ASoC: hdac_hda: add asoc extension for legacy HDA codec drivers
    
    This patch adds a kernel module which is used by the legacy HDA
    codec drivers as library. This implements hdac_ext_bus_ops to enable
    the reuse of legacy HDA codec drivers with ASoC platform drivers.
    
    Signed-off-by: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 2222b47d4ec4..9174f1b3a987 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -81,6 +81,12 @@ static int hda_codec_driver_probe(struct device *dev)
 	hda_codec_patch_t patch;
 	int err;
 
+	if (codec->bus->core.ext_ops) {
+		if (WARN_ON(!codec->bus->core.ext_ops->hdev_attach))
+			return -EINVAL;
+		return codec->bus->core.ext_ops->hdev_attach(&codec->core);
+	}
+
 	if (WARN_ON(!codec->preset))
 		return -EINVAL;
 
@@ -134,6 +140,12 @@ static int hda_codec_driver_remove(struct device *dev)
 {
 	struct hda_codec *codec = dev_to_hda_codec(dev);
 
+	if (codec->bus->core.ext_ops) {
+		if (WARN_ON(!codec->bus->core.ext_ops->hdev_detach))
+			return -EINVAL;
+		return codec->bus->core.ext_ops->hdev_detach(&codec->core);
+	}
+
 	if (codec->patch_ops.free)
 		codec->patch_ops.free(codec);
 	snd_hda_codec_cleanup_for_unbind(codec);

commit b4af16d617add4f6380d6651473b8efba13ca8ca
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Wed Aug 22 15:24:57 2018 -0500

    ALSA: hda: move hda_codec.h to include/sound
    
    As suggested by Takashi, move this header file to make it easier
    to include from e.g. the Intel Skylake driver in follow-up patches
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index d361bb77ca00..2222b47d4ec4 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -11,7 +11,7 @@
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <sound/core.h>
-#include "hda_codec.h"
+#include <sound/hda_codec.h>
 #include "hda_local.h"
 
 /*

commit 284b4c9289766c6294d4c6292aea565f78215b0e
Author: Wang YanQing <udknight@gmail.com>
Date:   Mon Sep 4 23:17:09 2017 +0800

    ALSA: hda: Fix forget to free resource in error handling code path in hda_codec_driver_probe
    
    When hda_codec_driver_probe meet error and return failure, we need
    to free resource with patch_ops.free, or we will get resource leak.
    
    Signed-off-by: Wang YanQing <udknight@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 6efadbfb3fe3..d361bb77ca00 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -100,7 +100,7 @@ static int hda_codec_driver_probe(struct device *dev)
 	if (patch) {
 		err = patch(codec);
 		if (err < 0)
-			goto error_module;
+			goto error_module_put;
 	}
 
 	err = snd_hda_codec_build_pcms(codec);
@@ -120,6 +120,9 @@ static int hda_codec_driver_probe(struct device *dev)
 	return 0;
 
  error_module:
+	if (codec->patch_ops.free)
+		codec->patch_ops.free(codec);
+ error_module_put:
 	module_put(owner);
 
  error:

commit bca8e988043e39483afd7872a2641f03ed7201a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 20 15:46:44 2016 +0100

    ALSA: hda - Fix missing module loading with model=generic option
    
    When the generic codec driver is specified via model option or such,
    the hda driver doesn't try to load the generic driver module but still
    loads the codec-specific driver, and this ends up with the binding
    failure.
    
    This patch fixes it by moving the generic module request in the common
    helper code.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=111021
    Cc: <stable@vger.kernel.org> # v4.4+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 70671ad65d24..6efadbfb3fe3 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -174,14 +174,40 @@ static inline bool codec_probed(struct hda_codec *codec)
 	return device_attach(hda_codec_dev(codec)) > 0 && codec->preset;
 }
 
-/* try to auto-load and bind the codec module */
-static void codec_bind_module(struct hda_codec *codec)
+/* try to auto-load codec module */
+static void request_codec_module(struct hda_codec *codec)
 {
 #ifdef MODULE
 	char modalias[32];
+	const char *mod = NULL;
+
+	switch (codec->probe_id) {
+	case HDA_CODEC_ID_GENERIC_HDMI:
+#if IS_MODULE(CONFIG_SND_HDA_CODEC_HDMI)
+		mod = "snd-hda-codec-hdmi";
+#endif
+		break;
+	case HDA_CODEC_ID_GENERIC:
+#if IS_MODULE(CONFIG_SND_HDA_GENERIC)
+		mod = "snd-hda-codec-generic";
+#endif
+		break;
+	default:
+		snd_hdac_codec_modalias(&codec->core, modalias, sizeof(modalias));
+		mod = modalias;
+		break;
+	}
+
+	if (mod)
+		request_module(mod);
+#endif /* MODULE */
+}
 
-	snd_hdac_codec_modalias(&codec->core, modalias, sizeof(modalias));
-	request_module(modalias);
+/* try to auto-load and bind the codec module */
+static void codec_bind_module(struct hda_codec *codec)
+{
+#ifdef MODULE
+	request_codec_module(codec);
 	if (codec_probed(codec))
 		return;
 #endif
@@ -218,17 +244,13 @@ static int codec_bind_generic(struct hda_codec *codec)
 
 	if (is_likely_hdmi_codec(codec)) {
 		codec->probe_id = HDA_CODEC_ID_GENERIC_HDMI;
-#if IS_MODULE(CONFIG_SND_HDA_CODEC_HDMI)
-		request_module("snd-hda-codec-hdmi");
-#endif
+		request_codec_module(codec);
 		if (codec_probed(codec))
 			return 0;
 	}
 
 	codec->probe_id = HDA_CODEC_ID_GENERIC;
-#if IS_MODULE(CONFIG_SND_HDA_GENERIC)
-	request_module("snd-hda-codec-generic");
-#endif
+	request_codec_module(codec);
 	if (codec_probed(codec))
 		return 0;
 	return -ENODEV;

commit c80a1daa7eb6470b84868ed135a26f414b02bf2e
Merge: 9a30ae2df29c b6e84c99b121
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 20 10:19:40 2015 +0200

    Merge branch 'topic/hda-modalias' into for-next

commit b9a94a9c787d053e8d3bb7e7dff9648e723a4533
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 1 16:20:04 2015 +0200

    ALSA: hda - convert to hda_device_id
    
    Finally we have a proper infrastructure to generate the modaliases
    automatically, let's move to hda_device_id from the legacy
    hda_codec_preset that contains basically the same information.
    
    The patch function hook is stored in driver_data field, which is long,
    and we need an explicit cast.  Other than that, the conversion is
    mostly straightforward.  Each entry is even simplified using a macro,
    and the lengthy (and error-prone) manual modaliases got removed.
    
    As a result, we achieved a quite good diet:
     14 files changed, 407 insertions(+), 595 deletions(-)
    
    Reviewed-by: Vinod Koul <vinod.koul@intel.com>
    Tested-by: Subhransu S Prusty <subhransu.s.prusty@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 021bcce59447..152acdaa0a45 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -15,21 +15,22 @@
 #include "hda_local.h"
 
 /*
- * find a matching codec preset
+ * find a matching codec id
  */
 static int hda_codec_match(struct hdac_device *dev, struct hdac_driver *drv)
 {
 	struct hda_codec *codec = container_of(dev, struct hda_codec, core);
 	struct hda_codec_driver *driver =
 		container_of(drv, struct hda_codec_driver, core);
-	const struct hda_codec_preset *preset;
+	const struct hda_device_id *list;
 	/* check probe_id instead of vendor_id if set */
 	u32 id = codec->probe_id ? codec->probe_id : codec->core.vendor_id;
+	u32 rev_id = codec->core.revision_id;
 
-	for (preset = driver->preset; preset->id; preset++) {
-		if (preset->id == id &&
-		    (!preset->rev || preset->rev == codec->core.revision_id)) {
-			codec->preset = preset;
+	for (list = driver->id; list->vendor_id; list++) {
+		if (list->vendor_id == id &&
+		    (!list->rev_id || list->rev_id == rev_id)) {
+			codec->preset = list;
 			return 1;
 		}
 	}
@@ -77,6 +78,7 @@ static int hda_codec_driver_probe(struct device *dev)
 {
 	struct hda_codec *codec = dev_to_hda_codec(dev);
 	struct module *owner = dev->driver->owner;
+	hda_codec_patch_t patch;
 	int err;
 
 	if (WARN_ON(!codec->preset))
@@ -94,9 +96,12 @@ static int hda_codec_driver_probe(struct device *dev)
 		goto error;
 	}
 
-	err = codec->preset->patch(codec);
-	if (err < 0)
-		goto error_module;
+	patch = (hda_codec_patch_t)codec->preset->driver_data;
+	if (patch) {
+		err = patch(codec);
+		if (err < 0)
+			goto error_module;
+	}
 
 	err = snd_hda_codec_build_pcms(codec);
 	if (err < 0)
@@ -173,11 +178,10 @@ static inline bool codec_probed(struct hda_codec *codec)
 static void codec_bind_module(struct hda_codec *codec)
 {
 #ifdef MODULE
-	request_module("snd-hda-codec-id:%08x", codec->core.vendor_id);
-	if (codec_probed(codec))
-		return;
-	request_module("snd-hda-codec-id:%04x*",
-		       (codec->core.vendor_id >> 16) & 0xffff);
+	char modalias[32];
+
+	snd_hdac_codec_modalias(&codec->core, modalias, sizeof(modalias));
+	request_module(modalias);
 	if (codec_probed(codec))
 		return;
 #endif

commit 2f0eaad91005b00e774a118595a573a9e0fd30fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Oct 17 18:25:38 2015 +0200

    ALSA: hda - Fix bogus codec address check for mixer name assignment
    
    The recent commit [7fbe824a0f0e: ALSA: hda - Update mixer name for the
    lower codec address] tried to improve the mixer chip name assignment
    in the order of codec address.  However, this fix was utterly bogus;
    it checks the field set in each codec, thus this value is reset at
    each codec creation, of course.  For really handling this priority,
    the assignment has to be remembered in the common place, namely in
    hda_bus, instead of hda_codec.
    
    Fixes: 7fbe824a0f0e ('ALSA: hda - Update mixer name for the lower codec address')
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 021bcce59447..57800a498f7b 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -62,11 +62,11 @@ int snd_hda_codec_set_name(struct hda_codec *codec, const char *name)
 
 	/* update the mixer name */
 	if (!*codec->card->mixername ||
-	    codec->mixer_assigned >= codec->core.addr) {
+	    codec->bus->mixer_assigned >= codec->core.addr) {
 		snprintf(codec->card->mixername,
 			 sizeof(codec->card->mixername), "%s %s",
 			 codec->core.vendor_name, codec->core.chip_name);
-		codec->mixer_assigned = codec->core.addr;
+		codec->bus->mixer_assigned = codec->core.addr;
 	}
 
 	return 0;

commit 7fbe824a0f0e6a73de5b589a6690294f7cb9dae3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 15 14:06:14 2015 +0200

    ALSA: hda - Update mixer name for the lower codec address
    
    In most cases, we prefer the onboard codec as the primary device, thus
    it's better to set it as the mixer name.  Currently, however, the
    mixer name is updated per the device instantiation order, and user
    gets often HDMI/DP or other seen as a mixer chip name.  Also, if a
    codec name is renamed by the driver, the old chip name might be left
    still as the mixer name.
    
    This patch addresses these issues by remembering the chip address that
    was referred as the mixer name.  When a codec with the same or lower
    address gives its name, renew the mixer name accordingly, as it's
    either the update of the codec name or we get likely the more
    appropriate chip as the reference.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index ef6b8f836a87..021bcce59447 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -61,10 +61,12 @@ int snd_hda_codec_set_name(struct hda_codec *codec, const char *name)
 		return err;
 
 	/* update the mixer name */
-	if (!*codec->card->mixername) {
+	if (!*codec->card->mixername ||
+	    codec->mixer_assigned >= codec->core.addr) {
 		snprintf(codec->card->mixername,
 			 sizeof(codec->card->mixername), "%s %s",
 			 codec->core.vendor_name, codec->core.chip_name);
+		codec->mixer_assigned = codec->core.addr;
 	}
 
 	return 0;

commit ded255be2276d365a91af2de7c7f8e2c233d4fa2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 1 17:59:43 2015 +0200

    ALSA: hda - consolidate chip rename functions
    
    A few multiple codec drivers do renaming the chip_name string but all
    these are open-coded and some of them have even no error check.  Let's
    make common helpers to do it properly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index d5ac25cc7fee..ef6b8f836a87 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -45,15 +45,31 @@ static void hda_codec_unsol_event(struct hdac_device *dev, unsigned int ev)
 		codec->patch_ops.unsol_event(codec, ev);
 }
 
-/* reset the codec name from the preset */
-static int codec_refresh_name(struct hda_codec *codec, const char *name)
+/**
+ * snd_hda_codec_set_name - set the codec name
+ * @codec: the HDA codec
+ * @name: name string to set
+ */
+int snd_hda_codec_set_name(struct hda_codec *codec, const char *name)
 {
-	if (name) {
-		kfree(codec->core.chip_name);
-		codec->core.chip_name = kstrdup(name, GFP_KERNEL);
+	int err;
+
+	if (!name)
+		return 0;
+	err = snd_hdac_device_set_chip_name(&codec->core, name);
+	if (err < 0)
+		return err;
+
+	/* update the mixer name */
+	if (!*codec->card->mixername) {
+		snprintf(codec->card->mixername,
+			 sizeof(codec->card->mixername), "%s %s",
+			 codec->core.vendor_name, codec->core.chip_name);
 	}
-	return codec->core.chip_name ? 0 : -ENOMEM;
+
+	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_hda_codec_set_name);
 
 static int hda_codec_driver_probe(struct device *dev)
 {
@@ -64,7 +80,7 @@ static int hda_codec_driver_probe(struct device *dev)
 	if (WARN_ON(!codec->preset))
 		return -EINVAL;
 
-	err = codec_refresh_name(codec, codec->preset->name);
+	err = snd_hda_codec_set_name(codec, codec->preset->name);
 	if (err < 0)
 		goto error;
 	err = snd_hdac_regmap_init(&codec->core);
@@ -251,11 +267,6 @@ int snd_hda_codec_configure(struct hda_codec *codec)
 		}
 	}
 
-	/* audio codec should override the mixer name */
-	if (codec->core.afg || !*codec->card->mixername)
-		snprintf(codec->card->mixername,
-			 sizeof(codec->card->mixername), "%s %s",
-			 codec->core.vendor_name, codec->core.chip_name);
 	return 0;
 
  error:

commit 18fe73ef7c96e98668f84c02ebb9ac626f062b67
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu May 28 14:46:55 2015 +0200

    ALSA: hda - Drop unused fields from struct hda_codec_preset
    
    It's very unlikely that we'd need these fields out of sudden.
    Let's drop them.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 00aa31c5f08e..d5ac25cc7fee 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -27,15 +27,7 @@ static int hda_codec_match(struct hdac_device *dev, struct hdac_driver *drv)
 	u32 id = codec->probe_id ? codec->probe_id : codec->core.vendor_id;
 
 	for (preset = driver->preset; preset->id; preset++) {
-		u32 mask = preset->mask;
-
-		if (preset->afg && preset->afg != codec->core.afg)
-			continue;
-		if (preset->mfg && preset->mfg != codec->core.mfg)
-			continue;
-		if (!mask)
-			mask = ~0;
-		if (preset->id == (id & mask) &&
+		if (preset->id == id &&
 		    (!preset->rev || preset->rev == codec->core.revision_id)) {
 			codec->preset = preset;
 			return 1;

commit 4d75faa0448a6bb2fd6d56051a3675a3937cbada
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 25 14:42:38 2015 +0100

    ALSA: hda - Add regmap support
    
    This patch adds an infrastructure to support regmap-based verb
    accesses.  Because o the asymmetric nature of HD-audio verbs,
    especially the amp verbs, we need to translate the verbs as a sort of
    pseudo registers to be mapped uniquely in regmap.
    
    In this patch, a pseudo register is built from the NID, the
    AC_VERB_GET_* and 8bit parameters, i.e. almost in the form to be sent
    to HD-audio bus but without codec address field.  OTOH, for writing,
    the same pseudo register is translated to AC_VERB_SET_* automatically.
    The AC_VERB_SET_AMP_* verb is re-encoded from the corresponding
    AC_VERB_GET_AMP_* verb and parameter at writing.
    
    Some verbs has a single command for read but multiple for writes.  A
    write for such a verb is split automatically to multiple verbs.
    
    The patch provides also a few handy helper functions.  They are
    designed to be accessible even without regmap.  When no regmap is set
    up (e.g. before the codec device instantiation), the direct hardware
    access is used.  Also, it tries to avoid the unnecessary power-up.
    The power up/down sequence is performed only on demand.
    
    The codec driver needs to call snd_hdac_regmap_exit() and
    snd_hdac_regmap_exit() at probe and remove if it wants the regmap
    access.
    
    There is one flag added to hdac_device.  When the flag lazy_cache is
    set, regmap helper ignores a write for a suspended device and returns
    as if it was actually written.  It reduces the hardware access pretty
    much, e.g. when adjusting the mixer volume while in idle.  This
    assumes that the driver will sync the cache later at resume properly,
    so use it carefully.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 7b269c3237e3..00aa31c5f08e 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -73,6 +73,9 @@ static int hda_codec_driver_probe(struct device *dev)
 		return -EINVAL;
 
 	err = codec_refresh_name(codec, codec->preset->name);
+	if (err < 0)
+		goto error;
+	err = snd_hdac_regmap_init(&codec->core);
 	if (err < 0)
 		goto error;
 
@@ -98,6 +101,7 @@ static int hda_codec_driver_probe(struct device *dev)
 		snd_hda_codec_register(codec);
 	}
 
+	codec->core.lazy_cache = true;
 	return 0;
 
  error_module:

commit c4c2533f802d6877803c4d778def43d8a122f27b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 3 17:22:12 2015 +0100

    ALSA: hda - Fix possible runtime PM refcount unbalance
    
    When the driver is unloaded before the codec is bound, it still keeps
    the runtime PM refcount up, and results in the unbalance.  This patch
    covers these cases by introducing a flag indicating the runtime PM
    initialization and handling the codec registration procedure more
    properly.  It also fixes the missing input beep device as a gratis,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 130f672e6f37..7b269c3237e3 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -95,6 +95,7 @@ static int hda_codec_driver_probe(struct device *dev)
 		err = snd_card_register(codec->card);
 		if (err < 0)
 			goto error_module;
+		snd_hda_codec_register(codec);
 	}
 
 	return 0;

commit 3256be6537751f65c76b3ecfbb4e667f87525a2f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 24 14:59:42 2015 +0100

    ALSA: hda - Add widget sysfs tree
    
    This patch changes the sysfs files assigned to the codec device on the
    bus which were formerly identical with hwdep sysfs files.  Now it
    shows only a few core parameter, vendor_id, subsystem_id, revision_id,
    afg, mfg, vendor_name and chip_name.
    
    In addition, now a widget tree is added to the bus device sysfs
    directory for showing the widget topology and attributes.  It's just a
    flat tree consisting of subdirectories named as the widget NID
    including various attributes like widget capability bits.  The AFG
    (usually NID 0x01) is always found there, and it contains always
    amp_in_caps, amp_out_caps and power_caps files.  Each of these
    attributes show a single value.  The rest are the widget nodes
    belonging to that AFG.  Note that the child node might not start from
    0x02 but from another value like 0x0a.
    
    Each child node may contain caps, pin_caps, amp_in_caps, amp_out_caps,
    power_caps and connections files.  The caps (representing the widget
    capability bits) always contain a value.  The rest may contain
    value(s) if the attribute exists on the node.  Only connections file
    show multiple values while other attributes have zero or one single
    value.
    
    An example of ls -R output is like below:
    % ls -R /sys/bus/hdaudio/devices/hdaudioC0D0/
    /sys/bus/hdaudio/devices/hdaudioC0D0/widgets/:
    01/  04/  07/  0a/  0d/  10/  13/  16/  19/  1c/  1f/  22/
    02/  05/  08/  0b/  0e/  11/  14/  17/  1a/  1d/  20/  23/
    03/  06/  09/  0c/  0f/  12/  15/  18/  1b/  1e/  21/
    
    /sys/bus/hdaudio/devices/hdaudioC0D0/widgets/01:
    amp_in_caps  amp_out_caps  power_caps
    
    /sys/bus/hdaudio/devices/hdaudioC0D0/widgets/02:
    amp_in_caps  amp_out_caps  caps  connections  pin_caps  pin_cfg
    power_caps
    
    /sys/bus/hdaudio/devices/hdaudioC0D0/widgets/03:
    .....
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index ad276a9771db..130f672e6f37 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -240,7 +240,7 @@ int snd_hda_codec_configure(struct hda_codec *codec)
 	else
 		codec->probe_id = 0;
 
-	err = device_add(hda_codec_dev(codec));
+	err = snd_hdac_device_register(&codec->core);
 	if (err < 0)
 		return err;
 
@@ -262,7 +262,7 @@ int snd_hda_codec_configure(struct hda_codec *codec)
 	return 0;
 
  error:
-	device_del(hda_codec_dev(codec));
+	snd_hdac_device_unregister(&codec->core);
 	return err;
 }
 EXPORT_SYMBOL_GPL(snd_hda_codec_configure);

commit 7639a06c23c7d4cda34c2546bd7290d8753849ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 3 10:07:24 2015 +0100

    ALSA: hda - Move a part of hda_codec stuff into hdac_device
    
    Now some codes and functionalities of hda_codec struct are moved to
    hdac_device struct.  A few basic attributes like the codec address,
    vendor ID number, FG numbers, etc are moved to hdac_device, and they
    are accessed like codec->core.addr.  The basic verb exec functions are
    moved, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 0b9ea70c546b..ad276a9771db 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -14,36 +14,6 @@
 #include "hda_codec.h"
 #include "hda_local.h"
 
-/* codec vendor labels */
-struct hda_vendor_id {
-	unsigned int id;
-	const char *name;
-};
-
-static struct hda_vendor_id hda_vendor_ids[] = {
-	{ 0x1002, "ATI" },
-	{ 0x1013, "Cirrus Logic" },
-	{ 0x1057, "Motorola" },
-	{ 0x1095, "Silicon Image" },
-	{ 0x10de, "Nvidia" },
-	{ 0x10ec, "Realtek" },
-	{ 0x1102, "Creative" },
-	{ 0x1106, "VIA" },
-	{ 0x111d, "IDT" },
-	{ 0x11c1, "LSI" },
-	{ 0x11d4, "Analog Devices" },
-	{ 0x13f6, "C-Media" },
-	{ 0x14f1, "Conexant" },
-	{ 0x17e8, "Chrontel" },
-	{ 0x1854, "LG" },
-	{ 0x1aec, "Wolfson Microelectronics" },
-	{ 0x1af4, "QEMU" },
-	{ 0x434d, "C-Media" },
-	{ 0x8086, "Intel" },
-	{ 0x8384, "SigmaTel" },
-	{} /* terminator */
-};
-
 /*
  * find a matching codec preset
  */
@@ -54,19 +24,19 @@ static int hda_codec_match(struct hdac_device *dev, struct hdac_driver *drv)
 		container_of(drv, struct hda_codec_driver, core);
 	const struct hda_codec_preset *preset;
 	/* check probe_id instead of vendor_id if set */
-	u32 id = codec->probe_id ? codec->probe_id : codec->vendor_id;
+	u32 id = codec->probe_id ? codec->probe_id : codec->core.vendor_id;
 
 	for (preset = driver->preset; preset->id; preset++) {
 		u32 mask = preset->mask;
 
-		if (preset->afg && preset->afg != codec->afg)
+		if (preset->afg && preset->afg != codec->core.afg)
 			continue;
-		if (preset->mfg && preset->mfg != codec->mfg)
+		if (preset->mfg && preset->mfg != codec->core.mfg)
 			continue;
 		if (!mask)
 			mask = ~0;
 		if (preset->id == (id & mask) &&
-		    (!preset->rev || preset->rev == codec->revision_id)) {
+		    (!preset->rev || preset->rev == codec->core.revision_id)) {
 			codec->preset = preset;
 			return 1;
 		}
@@ -86,15 +56,11 @@ static void hda_codec_unsol_event(struct hdac_device *dev, unsigned int ev)
 /* reset the codec name from the preset */
 static int codec_refresh_name(struct hda_codec *codec, const char *name)
 {
-	char tmp[16];
-
-	kfree(codec->chip_name);
-	if (!name) {
-		sprintf(tmp, "ID %x", codec->vendor_id & 0xffff);
-		name = tmp;
+	if (name) {
+		kfree(codec->core.chip_name);
+		codec->core.chip_name = kstrdup(name, GFP_KERNEL);
 	}
-	codec->chip_name = kstrdup(name, GFP_KERNEL);
-	return codec->chip_name ? 0 : -ENOMEM;
+	return codec->core.chip_name ? 0 : -ENOMEM;
 }
 
 static int hda_codec_driver_probe(struct device *dev)
@@ -192,48 +158,23 @@ static inline bool codec_probed(struct hda_codec *codec)
 static void codec_bind_module(struct hda_codec *codec)
 {
 #ifdef MODULE
-	request_module("snd-hda-codec-id:%08x", codec->vendor_id);
+	request_module("snd-hda-codec-id:%08x", codec->core.vendor_id);
 	if (codec_probed(codec))
 		return;
 	request_module("snd-hda-codec-id:%04x*",
-		       (codec->vendor_id >> 16) & 0xffff);
+		       (codec->core.vendor_id >> 16) & 0xffff);
 	if (codec_probed(codec))
 		return;
 #endif
 }
 
-/* store the codec vendor name */
-static int get_codec_vendor_name(struct hda_codec *codec)
-{
-	const struct hda_vendor_id *c;
-	const char *vendor = NULL;
-	u16 vendor_id = codec->vendor_id >> 16;
-	char tmp[16];
-
-	for (c = hda_vendor_ids; c->id; c++) {
-		if (c->id == vendor_id) {
-			vendor = c->name;
-			break;
-		}
-	}
-	if (!vendor) {
-		sprintf(tmp, "Generic %04x", vendor_id);
-		vendor = tmp;
-	}
-	codec->vendor_name = kstrdup(vendor, GFP_KERNEL);
-	if (!codec->vendor_name)
-		return -ENOMEM;
-	return 0;
-}
-
 #if IS_ENABLED(CONFIG_SND_HDA_CODEC_HDMI)
 /* if all audio out widgets are digital, let's assume the codec as a HDMI/DP */
 static bool is_likely_hdmi_codec(struct hda_codec *codec)
 {
-	hda_nid_t nid = codec->start_nid;
-	int i;
+	hda_nid_t nid;
 
-	for (i = 0; i < codec->num_nodes; i++, nid++) {
+	for_each_hda_codec_node(nid, codec) {
 		unsigned int wcaps = get_wcaps(codec, nid);
 		switch (get_wcaps_type(wcaps)) {
 		case AC_WID_AUD_IN:
@@ -294,12 +235,6 @@ int snd_hda_codec_configure(struct hda_codec *codec)
 {
 	int err;
 
-	if (!codec->vendor_name) {
-		err = get_codec_vendor_name(codec);
-		if (err < 0)
-			return err;
-	}
-
 	if (is_generic_config(codec))
 		codec->probe_id = HDA_CODEC_ID_GENERIC;
 	else
@@ -320,10 +255,10 @@ int snd_hda_codec_configure(struct hda_codec *codec)
 	}
 
 	/* audio codec should override the mixer name */
-	if (codec->afg || !*codec->card->mixername)
+	if (codec->core.afg || !*codec->card->mixername)
 		snprintf(codec->card->mixername,
-			 sizeof(codec->card->mixername),
-			 "%s %s", codec->vendor_name, codec->chip_name);
+			 sizeof(codec->card->mixername), "%s %s",
+			 codec->core.vendor_name, codec->core.chip_name);
 	return 0;
 
  error:

commit d068ebc25e6e1360510ad8023fe7bca3dacd204e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 2 23:22:59 2015 +0100

    ALSA: hda - Move some codes up to hdac_bus struct
    
    A few basic codes for communicating over HD-audio bus are moved to
    struct hdac_bus now.  It has only command and get_response ops in
    addition to the unsolicited event handling.
    
    Note that the codec-side tracing support is disabled temporarily
    during this transition due to the code shuffling.  It will be
    re-enabled later once when all pieces are settled down.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index e3bd2807b644..0b9ea70c546b 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -74,6 +74,15 @@ static int hda_codec_match(struct hdac_device *dev, struct hdac_driver *drv)
 	return 0;
 }
 
+/* process an unsolicited event */
+static void hda_codec_unsol_event(struct hdac_device *dev, unsigned int ev)
+{
+	struct hda_codec *codec = container_of(dev, struct hda_codec, core);
+
+	if (codec->patch_ops.unsol_event)
+		codec->patch_ops.unsol_event(codec, ev);
+}
+
 /* reset the codec name from the preset */
 static int codec_refresh_name(struct hda_codec *codec, const char *name)
 {
@@ -163,6 +172,7 @@ int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
 	drv->core.driver.pm = &hda_codec_driver_pm;
 	drv->core.type = HDA_DEV_LEGACY;
 	drv->core.match = hda_codec_match;
+	drv->core.unsol_event = hda_codec_unsol_event;
 	return driver_register(&drv->core.driver);
 }
 EXPORT_SYMBOL_GPL(__hda_codec_driver_register);

commit e3d280fc6d42017b2379503fbda83655a05294fe
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 17 21:46:37 2015 +0100

    ALSA: hda - Make snd_hda_bus_type public
    
    Define the common hd-audio driver and device types to bind over
    snd_hda_bus_type publicly.  This allows to implement other type of
    device and driver code over hd-audio bus.
    
    Now both struct hda_codec and struct hda_codec_driver inherit these
    new struct hdac_device and struct hdac_driver, respectively.
    
    The bus registration is done in subsys_initcall() to assure it
    before any other driver registrations.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 1f40ce3c1696..e3bd2807b644 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -47,11 +47,11 @@ static struct hda_vendor_id hda_vendor_ids[] = {
 /*
  * find a matching codec preset
  */
-static int hda_bus_match(struct device *dev, struct device_driver *drv)
+static int hda_codec_match(struct hdac_device *dev, struct hdac_driver *drv)
 {
-	struct hda_codec *codec = container_of(dev, struct hda_codec, dev);
+	struct hda_codec *codec = container_of(dev, struct hda_codec, core);
 	struct hda_codec_driver *driver =
-		container_of(drv, struct hda_codec_driver, driver);
+		container_of(drv, struct hda_codec_driver, core);
 	const struct hda_codec_preset *preset;
 	/* check probe_id instead of vendor_id if set */
 	u32 id = codec->probe_id ? codec->probe_id : codec->vendor_id;
@@ -154,20 +154,22 @@ static void hda_codec_driver_shutdown(struct device *dev)
 int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
 			       struct module *owner)
 {
-	drv->driver.name = name;
-	drv->driver.owner = owner;
-	drv->driver.bus = &snd_hda_bus_type;
-	drv->driver.probe = hda_codec_driver_probe;
-	drv->driver.remove = hda_codec_driver_remove;
-	drv->driver.shutdown = hda_codec_driver_shutdown;
-	drv->driver.pm = &hda_codec_driver_pm;
-	return driver_register(&drv->driver);
+	drv->core.driver.name = name;
+	drv->core.driver.owner = owner;
+	drv->core.driver.bus = &snd_hda_bus_type;
+	drv->core.driver.probe = hda_codec_driver_probe;
+	drv->core.driver.remove = hda_codec_driver_remove;
+	drv->core.driver.shutdown = hda_codec_driver_shutdown;
+	drv->core.driver.pm = &hda_codec_driver_pm;
+	drv->core.type = HDA_DEV_LEGACY;
+	drv->core.match = hda_codec_match;
+	return driver_register(&drv->core.driver);
 }
 EXPORT_SYMBOL_GPL(__hda_codec_driver_register);
 
 void hda_codec_driver_unregister(struct hda_codec_driver *drv)
 {
-	driver_unregister(&drv->driver);
+	driver_unregister(&drv->core.driver);
 }
 EXPORT_SYMBOL_GPL(hda_codec_driver_unregister);
 
@@ -319,24 +321,3 @@ int snd_hda_codec_configure(struct hda_codec *codec)
 	return err;
 }
 EXPORT_SYMBOL_GPL(snd_hda_codec_configure);
-
-/*
- * bus registration
- */
-struct bus_type snd_hda_bus_type = {
-	.name = "hdaudio",
-	.match = hda_bus_match,
-};
-
-static int __init hda_codec_init(void)
-{
-	return bus_register(&snd_hda_bus_type);
-}
-
-static void __exit hda_codec_exit(void)
-{
-	bus_unregister(&snd_hda_bus_type);
-}
-
-module_init(hda_codec_init);
-module_exit(hda_codec_exit);

commit b2a0bafa758256442e04d1f34d6d0746b846d23d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 5 17:21:32 2015 +0100

    ALSA: hda - Use shutdown driver ops instead of reboot notifier
    
    The driver shutdown ops is simpler than registering reboot notifier
    manually.  There should be no functional change by this -- the codec
    driver calls its own callback while the bus driver just calls
    azx_stop() like before.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index a49bc45c2ea5..1f40ce3c1696 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/export.h>
 #include <linux/pm.h>
+#include <linux/pm_runtime.h>
 #include <sound/core.h>
 #include "hda_codec.h"
 #include "hda_local.h"
@@ -142,6 +143,14 @@ static int hda_codec_driver_remove(struct device *dev)
 	return 0;
 }
 
+static void hda_codec_driver_shutdown(struct device *dev)
+{
+	struct hda_codec *codec = dev_to_hda_codec(dev);
+
+	if (!pm_runtime_suspended(dev) && codec->patch_ops.reboot_notify)
+		codec->patch_ops.reboot_notify(codec);
+}
+
 int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
 			       struct module *owner)
 {
@@ -150,6 +159,7 @@ int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
 	drv->driver.bus = &snd_hda_bus_type;
 	drv->driver.probe = hda_codec_driver_probe;
 	drv->driver.remove = hda_codec_driver_remove;
+	drv->driver.shutdown = hda_codec_driver_shutdown;
 	drv->driver.pm = &hda_codec_driver_pm;
 	return driver_register(&drv->driver);
 }

commit bcd96557bd0ab1129fcdde073d5700aed8fcb942
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 27 20:44:54 2015 +0100

    ALSA: hda - Build PCMs and controls at codec driver probe
    
    This makes the code flow easier -- instead of the controller driver
    calling snd_hda_build_pcms() and snd_hda_build_controls() explicitly,
    the codec driver itself builds PCMs and controls at probe time.  Then
    the controller driver only needs to call snd_card_register().
    
    Also, this allows us the full bind/unbind control, too.  Even when a
    codec driver is bound later, it automatically registers the new PCM
    and controls by itself.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 311896a23cd1..a49bc45c2ea5 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -106,16 +106,28 @@ static int hda_codec_driver_probe(struct device *dev)
 	}
 
 	err = codec->preset->patch(codec);
-	if (err < 0) {
-		module_put(owner);
-		goto error;
+	if (err < 0)
+		goto error_module;
+
+	err = snd_hda_codec_build_pcms(codec);
+	if (err < 0)
+		goto error_module;
+	err = snd_hda_codec_build_controls(codec);
+	if (err < 0)
+		goto error_module;
+	if (codec->card->registered) {
+		err = snd_card_register(codec->card);
+		if (err < 0)
+			goto error_module;
 	}
 
 	return 0;
 
+ error_module:
+	module_put(owner);
+
  error:
-	codec->preset = NULL;
-	memset(&codec->patch_ops, 0, sizeof(codec->patch_ops));
+	snd_hda_codec_cleanup_for_unbind(codec);
 	return err;
 }
 

commit 9a6246ff78ac33af78f82704cde6fec361597eea
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 27 18:17:28 2015 +0100

    ALSA: hda - Implement unbind more safely
    
    Now we have all pieces ready, and put them into places:
    - add the hda_pcm refcount to azx_pcm_open() and azx_pcm_close(),
    - call the most of cleanup code in hda_codec_reset() from the codec
      driver remove,
    - call the same code also from the hda_codec object free.
    
    Then the codec driver can be unbound more safely now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index 2d00417494e2..311896a23cd1 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -125,8 +125,7 @@ static int hda_codec_driver_remove(struct device *dev)
 
 	if (codec->patch_ops.free)
 		codec->patch_ops.free(codec);
-	codec->preset = NULL;
-	memset(&codec->patch_ops, 0, sizeof(codec->patch_ops));
+	snd_hda_codec_cleanup_for_unbind(codec);
 	module_put(dev->driver->owner);
 	return 0;
 }

commit 6efdd8513f182492c21fb7238592d4539d5c751a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 27 16:09:22 2015 +0100

    ALSA: hda - Add card field to hda_codec struct
    
    Allow the codec object to have an individual card pointer.  Not only
    this simplifies the redirections in many places, also this will allow
    us to make each codec assigned to a different card object.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index ce2dd7b0dc07..2d00417494e2 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -287,9 +287,9 @@ int snd_hda_codec_configure(struct hda_codec *codec)
 	}
 
 	/* audio codec should override the mixer name */
-	if (codec->afg || !*codec->bus->card->mixername)
-		snprintf(codec->bus->card->mixername,
-			 sizeof(codec->bus->card->mixername),
+	if (codec->afg || !*codec->card->mixername)
+		snprintf(codec->card->mixername,
+			 sizeof(codec->card->mixername),
 			 "%s %s", codec->vendor_name, codec->chip_name);
 	return 0;
 

commit 59ed1eade1d6ec24751baca99305f9713a5d779e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 18 15:39:59 2015 +0100

    ALSA: hda - Move codec suspend/resume to codec driver
    
    This patch moves the suspend/resume mechanisms down to each codec
    driver level, as we have a proper codec driver bound on the bus now.
    Then we get the asynchronous PM gratis without fiddling much in the
    driver level.
    
    As a soft-landing transition, implement the common suspend/resume pm
    ops for hda_codec_driver and keep the each codec driver intact.  Only
    the callers of suspend/resume in the controller side (azx_suspend()
    and azx_resume()) are removed.
    
    Another involved place is azx_bus_reset() calling the temporary
    suspend and resume as a hackish method of bus reset.  The HD-audio
    core provide a helper function snd_hda_bus_reset() instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index adf6b475dee1..ce2dd7b0dc07 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -8,6 +8,7 @@
 #include <linux/mutex.h>
 #include <linux/module.h>
 #include <linux/export.h>
+#include <linux/pm.h>
 #include <sound/core.h>
 #include "hda_codec.h"
 #include "hda_local.h"
@@ -138,7 +139,7 @@ int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
 	drv->driver.bus = &snd_hda_bus_type;
 	drv->driver.probe = hda_codec_driver_probe;
 	drv->driver.remove = hda_codec_driver_remove;
-	/* TODO: PM and others */
+	drv->driver.pm = &hda_codec_driver_pm;
 	return driver_register(&drv->driver);
 }
 EXPORT_SYMBOL_GPL(__hda_codec_driver_register);

commit d8a766a16ed90c4b3bd7afa6e1417f8d715db507
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 17 15:25:37 2015 +0100

    ALSA: hda - Bind codecs via standard bus
    
    Now we create the standard HD-audio bus (/sys/bus/hdaudio), and bind
    the codec driver with the codec device over there.  This is the first
    step of the whole transition so that the changes to each codec driver
    are kept as minimal as possible.
    
    Each codec driver needs to register hda_codec_driver struct containing
    the currently existing preset via the new helper macro
    module_hda_codec_driver().  The old hda_codec_preset_list is replaced
    with this infrastructure.  The generic parsers (for HDMI and other)
    are also included in the preset with the special IDs to bind
    uniquely.
    
    In HD-audio core side, the device binding code is split to
    hda_bind.c.  It provides the snd_hda_bus_type implementation to match
    the codec driver with the given codec vendor ID.  It also manages the
    module auto-loading by itself like before: when the matching isn't
    found, it tries to probe the corresponding codec modules, and finally
    falls back to the generic drivers.  (The special ID mentioned above is
    set at this stage.)
    
    The only visible change to outside is that the hdaudio sysfs entry now
    appears in /sys/bus/devices, not as a sound class device.
    
    More works to move the suspend/resume and remove ops will be
    (hopefully) done in later patches.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
new file mode 100644
index 000000000000..adf6b475dee1
--- /dev/null
+++ b/sound/pci/hda/hda_bind.c
@@ -0,0 +1,320 @@
+/*
+ * HD-audio codec driver binding
+ * Copyright (c) Takashi Iwai <tiwai@suse.de>
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/export.h>
+#include <sound/core.h>
+#include "hda_codec.h"
+#include "hda_local.h"
+
+/* codec vendor labels */
+struct hda_vendor_id {
+	unsigned int id;
+	const char *name;
+};
+
+static struct hda_vendor_id hda_vendor_ids[] = {
+	{ 0x1002, "ATI" },
+	{ 0x1013, "Cirrus Logic" },
+	{ 0x1057, "Motorola" },
+	{ 0x1095, "Silicon Image" },
+	{ 0x10de, "Nvidia" },
+	{ 0x10ec, "Realtek" },
+	{ 0x1102, "Creative" },
+	{ 0x1106, "VIA" },
+	{ 0x111d, "IDT" },
+	{ 0x11c1, "LSI" },
+	{ 0x11d4, "Analog Devices" },
+	{ 0x13f6, "C-Media" },
+	{ 0x14f1, "Conexant" },
+	{ 0x17e8, "Chrontel" },
+	{ 0x1854, "LG" },
+	{ 0x1aec, "Wolfson Microelectronics" },
+	{ 0x1af4, "QEMU" },
+	{ 0x434d, "C-Media" },
+	{ 0x8086, "Intel" },
+	{ 0x8384, "SigmaTel" },
+	{} /* terminator */
+};
+
+/*
+ * find a matching codec preset
+ */
+static int hda_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct hda_codec *codec = container_of(dev, struct hda_codec, dev);
+	struct hda_codec_driver *driver =
+		container_of(drv, struct hda_codec_driver, driver);
+	const struct hda_codec_preset *preset;
+	/* check probe_id instead of vendor_id if set */
+	u32 id = codec->probe_id ? codec->probe_id : codec->vendor_id;
+
+	for (preset = driver->preset; preset->id; preset++) {
+		u32 mask = preset->mask;
+
+		if (preset->afg && preset->afg != codec->afg)
+			continue;
+		if (preset->mfg && preset->mfg != codec->mfg)
+			continue;
+		if (!mask)
+			mask = ~0;
+		if (preset->id == (id & mask) &&
+		    (!preset->rev || preset->rev == codec->revision_id)) {
+			codec->preset = preset;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/* reset the codec name from the preset */
+static int codec_refresh_name(struct hda_codec *codec, const char *name)
+{
+	char tmp[16];
+
+	kfree(codec->chip_name);
+	if (!name) {
+		sprintf(tmp, "ID %x", codec->vendor_id & 0xffff);
+		name = tmp;
+	}
+	codec->chip_name = kstrdup(name, GFP_KERNEL);
+	return codec->chip_name ? 0 : -ENOMEM;
+}
+
+static int hda_codec_driver_probe(struct device *dev)
+{
+	struct hda_codec *codec = dev_to_hda_codec(dev);
+	struct module *owner = dev->driver->owner;
+	int err;
+
+	if (WARN_ON(!codec->preset))
+		return -EINVAL;
+
+	err = codec_refresh_name(codec, codec->preset->name);
+	if (err < 0)
+		goto error;
+
+	if (!try_module_get(owner)) {
+		err = -EINVAL;
+		goto error;
+	}
+
+	err = codec->preset->patch(codec);
+	if (err < 0) {
+		module_put(owner);
+		goto error;
+	}
+
+	return 0;
+
+ error:
+	codec->preset = NULL;
+	memset(&codec->patch_ops, 0, sizeof(codec->patch_ops));
+	return err;
+}
+
+static int hda_codec_driver_remove(struct device *dev)
+{
+	struct hda_codec *codec = dev_to_hda_codec(dev);
+
+	if (codec->patch_ops.free)
+		codec->patch_ops.free(codec);
+	codec->preset = NULL;
+	memset(&codec->patch_ops, 0, sizeof(codec->patch_ops));
+	module_put(dev->driver->owner);
+	return 0;
+}
+
+int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
+			       struct module *owner)
+{
+	drv->driver.name = name;
+	drv->driver.owner = owner;
+	drv->driver.bus = &snd_hda_bus_type;
+	drv->driver.probe = hda_codec_driver_probe;
+	drv->driver.remove = hda_codec_driver_remove;
+	/* TODO: PM and others */
+	return driver_register(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(__hda_codec_driver_register);
+
+void hda_codec_driver_unregister(struct hda_codec_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(hda_codec_driver_unregister);
+
+static inline bool codec_probed(struct hda_codec *codec)
+{
+	return device_attach(hda_codec_dev(codec)) > 0 && codec->preset;
+}
+
+/* try to auto-load and bind the codec module */
+static void codec_bind_module(struct hda_codec *codec)
+{
+#ifdef MODULE
+	request_module("snd-hda-codec-id:%08x", codec->vendor_id);
+	if (codec_probed(codec))
+		return;
+	request_module("snd-hda-codec-id:%04x*",
+		       (codec->vendor_id >> 16) & 0xffff);
+	if (codec_probed(codec))
+		return;
+#endif
+}
+
+/* store the codec vendor name */
+static int get_codec_vendor_name(struct hda_codec *codec)
+{
+	const struct hda_vendor_id *c;
+	const char *vendor = NULL;
+	u16 vendor_id = codec->vendor_id >> 16;
+	char tmp[16];
+
+	for (c = hda_vendor_ids; c->id; c++) {
+		if (c->id == vendor_id) {
+			vendor = c->name;
+			break;
+		}
+	}
+	if (!vendor) {
+		sprintf(tmp, "Generic %04x", vendor_id);
+		vendor = tmp;
+	}
+	codec->vendor_name = kstrdup(vendor, GFP_KERNEL);
+	if (!codec->vendor_name)
+		return -ENOMEM;
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_SND_HDA_CODEC_HDMI)
+/* if all audio out widgets are digital, let's assume the codec as a HDMI/DP */
+static bool is_likely_hdmi_codec(struct hda_codec *codec)
+{
+	hda_nid_t nid = codec->start_nid;
+	int i;
+
+	for (i = 0; i < codec->num_nodes; i++, nid++) {
+		unsigned int wcaps = get_wcaps(codec, nid);
+		switch (get_wcaps_type(wcaps)) {
+		case AC_WID_AUD_IN:
+			return false; /* HDMI parser supports only HDMI out */
+		case AC_WID_AUD_OUT:
+			if (!(wcaps & AC_WCAP_DIGITAL))
+				return false;
+			break;
+		}
+	}
+	return true;
+}
+#else
+/* no HDMI codec parser support */
+#define is_likely_hdmi_codec(codec)	false
+#endif /* CONFIG_SND_HDA_CODEC_HDMI */
+
+static int codec_bind_generic(struct hda_codec *codec)
+{
+	if (codec->probe_id)
+		return -ENODEV;
+
+	if (is_likely_hdmi_codec(codec)) {
+		codec->probe_id = HDA_CODEC_ID_GENERIC_HDMI;
+#if IS_MODULE(CONFIG_SND_HDA_CODEC_HDMI)
+		request_module("snd-hda-codec-hdmi");
+#endif
+		if (codec_probed(codec))
+			return 0;
+	}
+
+	codec->probe_id = HDA_CODEC_ID_GENERIC;
+#if IS_MODULE(CONFIG_SND_HDA_GENERIC)
+	request_module("snd-hda-codec-generic");
+#endif
+	if (codec_probed(codec))
+		return 0;
+	return -ENODEV;
+}
+
+#if IS_ENABLED(CONFIG_SND_HDA_GENERIC)
+#define is_generic_config(codec) \
+	(codec->modelname && !strcmp(codec->modelname, "generic"))
+#else
+#define is_generic_config(codec)	0
+#endif
+
+/**
+ * snd_hda_codec_configure - (Re-)configure the HD-audio codec
+ * @codec: the HDA codec
+ *
+ * Start parsing of the given codec tree and (re-)initialize the whole
+ * patch instance.
+ *
+ * Returns 0 if successful or a negative error code.
+ */
+int snd_hda_codec_configure(struct hda_codec *codec)
+{
+	int err;
+
+	if (!codec->vendor_name) {
+		err = get_codec_vendor_name(codec);
+		if (err < 0)
+			return err;
+	}
+
+	if (is_generic_config(codec))
+		codec->probe_id = HDA_CODEC_ID_GENERIC;
+	else
+		codec->probe_id = 0;
+
+	err = device_add(hda_codec_dev(codec));
+	if (err < 0)
+		return err;
+
+	if (!codec->preset)
+		codec_bind_module(codec);
+	if (!codec->preset) {
+		err = codec_bind_generic(codec);
+		if (err < 0) {
+			codec_err(codec, "Unable to bind the codec\n");
+			goto error;
+		}
+	}
+
+	/* audio codec should override the mixer name */
+	if (codec->afg || !*codec->bus->card->mixername)
+		snprintf(codec->bus->card->mixername,
+			 sizeof(codec->bus->card->mixername),
+			 "%s %s", codec->vendor_name, codec->chip_name);
+	return 0;
+
+ error:
+	device_del(hda_codec_dev(codec));
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_hda_codec_configure);
+
+/*
+ * bus registration
+ */
+struct bus_type snd_hda_bus_type = {
+	.name = "hdaudio",
+	.match = hda_bus_match,
+};
+
+static int __init hda_codec_init(void)
+{
+	return bus_register(&snd_hda_bus_type);
+}
+
+static void __exit hda_codec_exit(void)
+{
+	bus_unregister(&snd_hda_bus_type);
+}
+
+module_init(hda_codec_init);
+module_exit(hda_codec_exit);
