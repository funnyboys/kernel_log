commit 8045d0fc95753b00c6f0cb0f3a50a919a0b95038
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:48:19 2020 +0100

    ALSA: fm801: More constification
    
    Apply const prefix to the static register table.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-65-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 40dfad74f8e1..181ebafa550a 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1360,7 +1360,7 @@ static void snd_card_fm801_remove(struct pci_dev *pci)
 }
 
 #ifdef CONFIG_PM_SLEEP
-static unsigned char saved_regs[] = {
+static const unsigned char saved_regs[] = {
 	FM801_PCM_VOL, FM801_I2S_VOL, FM801_FM_VOL, FM801_REC_SRC,
 	FM801_PLY_CTRL, FM801_PLY_COUNT, FM801_PLY_BUF1, FM801_PLY_BUF2,
 	FM801_CAP_CTRL, FM801_CAP_COUNT, FM801_CAP_BUF1, FM801_CAP_BUF2,

commit fb537cd0089db62190405e5ec43ce4740e65f330
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:17:12 2020 +0100

    ALSA: fm801: Constify snd_fm801_tea575x_gpios
    
    The snd_fm801_tea575x_gpios table is referred as read-only, hence it
    can be declared as const gracefully.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-57-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 4117a053eb18..40dfad74f8e1 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -724,7 +724,7 @@ struct snd_fm801_tea575x_gpio {
 	char *name;
 };
 
-static struct snd_fm801_tea575x_gpio snd_fm801_tea575x_gpios[] = {
+static const struct snd_fm801_tea575x_gpio snd_fm801_tea575x_gpios[] = {
 	{ .data = 1, .clk = 3, .wren = 2, .most = 0, .name = "SF256-PCS" },
 	{ .data = 1, .clk = 0, .wren = 2, .most = 3, .name = "SF256-PCP" },
 	{ .data = 2, .clk = 0, .wren = 1, .most = 3, .name = "SF64-PCR" },

commit b4e5e70775546480035e156b40040e5d0d4264d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:53 2020 +0100

    ALSA: pci: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-38-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index ae2b413ff489..4117a053eb18 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -969,7 +969,7 @@ static const DECLARE_TLV_DB_SCALE(db_scale_dsp, -3450, 150, 0);
 
 #define FM801_CONTROLS ARRAY_SIZE(snd_fm801_controls)
 
-static struct snd_kcontrol_new snd_fm801_controls[] = {
+static const struct snd_kcontrol_new snd_fm801_controls[] = {
 FM801_DOUBLE_TLV("Wave Playback Volume", FM801_PCM_VOL, 0, 8, 31, 1,
 		 db_scale_dsp),
 FM801_SINGLE("Wave Playback Switch", FM801_PCM_VOL, 15, 1, 1),
@@ -990,7 +990,7 @@ FM801_SINGLE("FM Playback Switch", FM801_FM_VOL, 15, 1, 1),
 
 #define FM801_CONTROLS_MULTI ARRAY_SIZE(snd_fm801_controls_multi)
 
-static struct snd_kcontrol_new snd_fm801_controls_multi[] = {
+static const struct snd_kcontrol_new snd_fm801_controls_multi[] = {
 FM801_SINGLE("AC97 2ch->4ch Copy Switch", FM801_CODEC_CTRL, 7, 1, 0),
 FM801_SINGLE("AC97 18-bit Switch", FM801_CODEC_CTRL, 10, 1, 0),
 FM801_SINGLE(SNDRV_CTL_NAME_IEC958("",CAPTURE,SWITCH), FM801_I2S_MODE, 8, 1, 0),

commit 51055da51d1e92bb089c9b9e0ecb1be69396f808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:43 2020 +0100

    ALSA: pci: Constify snd_ac97_bus_ops definitions
    
    Now snd_ac97_bus() takes the const ops pointer, so we can define the
    snd_ac97_bus_ops locally as const as well for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index bb5cffee5dac..ae2b413ff489 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1020,7 +1020,7 @@ static int snd_fm801_mixer(struct fm801 *chip)
 	struct snd_ac97_template ac97;
 	unsigned int i;
 	int err;
-	static struct snd_ac97_bus_ops ops = {
+	static const struct snd_ac97_bus_ops ops = {
 		.write = snd_fm801_codec_write,
 		.read = snd_fm801_codec_read,
 	};

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 152fbc352123..bb5cffee5dac 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1183,7 +1183,7 @@ static int snd_fm801_create(struct snd_card *card,
 {
 	struct fm801 *chip;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_fm801_dev_free,
 	};
 

commit e41dbd20383d0dda8813ef6186b142be4de0ddb6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:19 2019 +0100

    ALSA: fm801: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-21-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 3ea10c972682..152fbc352123 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1223,6 +1223,7 @@ static int snd_fm801_create(struct snd_card *card,
 			return -EBUSY;
 		}
 		chip->irq = pci->irq;
+		card->sync_irq = chip->irq;
 		pci_set_master(pci);
 	}
 

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 707173254c55..3ea10c972682 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -673,7 +673,6 @@ static int snd_fm801_capture_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_fm801_playback_ops = {
 	.open =		snd_fm801_playback_open,
 	.close =	snd_fm801_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_fm801_playback_prepare,
 	.trigger =	snd_fm801_playback_trigger,
 	.pointer =	snd_fm801_playback_pointer,
@@ -682,7 +681,6 @@ static const struct snd_pcm_ops snd_fm801_playback_ops = {
 static const struct snd_pcm_ops snd_fm801_capture_ops = {
 	.open =		snd_fm801_capture_open,
 	.close =	snd_fm801_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_fm801_capture_prepare,
 	.trigger =	snd_fm801_capture_trigger,
 	.pointer =	snd_fm801_capture_pointer,

commit 247ed1020476bfdec52459f4019c75d596e27156
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:11 2019 +0100

    ALSA: fm801: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-40-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index a7f8109acced..707173254c55 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -435,17 +435,6 @@ static int snd_fm801_capture_trigger(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static int snd_fm801_hw_params(struct snd_pcm_substream *substream,
-			       struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-}
-
-static int snd_fm801_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 static int snd_fm801_playback_prepare(struct snd_pcm_substream *substream)
 {
 	struct fm801 *chip = snd_pcm_substream_chip(substream);
@@ -685,8 +674,6 @@ static const struct snd_pcm_ops snd_fm801_playback_ops = {
 	.open =		snd_fm801_playback_open,
 	.close =	snd_fm801_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_fm801_hw_params,
-	.hw_free =	snd_fm801_hw_free,
 	.prepare =	snd_fm801_playback_prepare,
 	.trigger =	snd_fm801_playback_trigger,
 	.pointer =	snd_fm801_playback_pointer,
@@ -696,8 +683,6 @@ static const struct snd_pcm_ops snd_fm801_capture_ops = {
 	.open =		snd_fm801_capture_open,
 	.close =	snd_fm801_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_fm801_hw_params,
-	.hw_free =	snd_fm801_hw_free,
 	.prepare =	snd_fm801_capture_prepare,
 	.trigger =	snd_fm801_capture_trigger,
 	.pointer =	snd_fm801_capture_pointer,
@@ -720,9 +705,8 @@ static int snd_fm801_pcm(struct fm801 *chip, int device)
 	strcpy(pcm->name, "FM801");
 	chip->pcm = pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &pdev->dev,
-					      chip->multichannel ? 128*1024 : 64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &pdev->dev,
+				       chip->multichannel ? 128*1024 : 64*1024, 128*1024);
 
 	return snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 				     snd_pcm_alt_chmaps,

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 3ef7d507eb9b..a7f8109acced 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -721,7 +721,7 @@ static int snd_fm801_pcm(struct fm801 *chip, int device)
 	chip->pcm = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(pdev),
+					      &pdev->dev,
 					      chip->multichannel ? 128*1024 : 64*1024, 128*1024);
 
 	return snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 1317f3183eb1..3ef7d507eb9b 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1,17 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  The driver for the ForteMedia FM801 based soundcards
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
  */
 
 #include <linux/delay.h>

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index e3fb9c61017c..1317f3183eb1 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1408,7 +1408,6 @@ static int snd_fm801_suspend(struct device *dev)
 	if (chip->tea575x_tuner & TUNER_ONLY) {
 		/* FIXME: tea575x suspend */
 	} else {
-		snd_pcm_suspend_all(chip->pcm);
 		snd_ac97_suspend(chip->ac97);
 		snd_ac97_suspend(chip->ac97_sec);
 	}

commit ef1ffbe7889e99f5b5cccb41c89e5c94f50f3218
Author: Zhouyang Jia <jiazhouyang09@gmail.com>
Date:   Mon Jun 11 16:04:06 2018 +0800

    ALSA: fm801: add error handling for snd_ctl_add
    
    When snd_ctl_add fails, the lack of error-handling code may
    cause unexpected results.
    
    This patch adds error-handling code after calling snd_ctl_add.
    
    Signed-off-by: Zhouyang Jia <jiazhouyang09@gmail.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 73a67bc3586b..e3fb9c61017c 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1068,11 +1068,19 @@ static int snd_fm801_mixer(struct fm801 *chip)
 		if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97_sec)) < 0)
 			return err;
 	}
-	for (i = 0; i < FM801_CONTROLS; i++)
-		snd_ctl_add(chip->card, snd_ctl_new1(&snd_fm801_controls[i], chip));
+	for (i = 0; i < FM801_CONTROLS; i++) {
+		err = snd_ctl_add(chip->card,
+			snd_ctl_new1(&snd_fm801_controls[i], chip));
+		if (err < 0)
+			return err;
+	}
 	if (chip->multichannel) {
-		for (i = 0; i < FM801_CONTROLS_MULTI; i++)
-			snd_ctl_add(chip->card, snd_ctl_new1(&snd_fm801_controls_multi[i], chip));
+		for (i = 0; i < FM801_CONTROLS_MULTI; i++) {
+			err = snd_ctl_add(chip->card,
+				snd_ctl_new1(&snd_fm801_controls_multi[i], chip));
+			if (err < 0)
+				return err;
+		}
 	}
 	return 0;
 }

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 8e6b04b39dcc..73a67bc3586b 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -599,7 +599,7 @@ static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static struct snd_pcm_hardware snd_fm801_playback =
+static const struct snd_pcm_hardware snd_fm801_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -619,7 +619,7 @@ static struct snd_pcm_hardware snd_fm801_playback =
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_fm801_capture =
+static const struct snd_pcm_hardware snd_fm801_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |

commit 610e1ae9b533be82b3aa118b907e0a703256913d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sun Jul 16 21:40:03 2017 +0300

    ALSA: fm801: Initialize chip after IRQ handler is registered
    
    The commit b56fa687e02b ("ALSA: fm801: detect FM-only card earlier")
    rearranged initialization calls, i.e. it makes snd_fm801_chip_init() to
    be called before we register interrupt handler and set PCI bus
    mastering.
    
    Somehow it prevents FM801-AU to work properly. Thus, partially revert
    initialization order changed by commit mentioned above.
    
    Fixes: b56fa687e02b ("ALSA: fm801: detect FM-only card earlier")
    Reported-by: Émeric MASCHINO <emeric.maschino@gmail.com>
    Tested-by: Émeric MASCHINO <emeric.maschino@gmail.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: <stable@vger.kernel.org> # v4.5+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 2e402ece4c86..8e6b04b39dcc 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1235,8 +1235,6 @@ static int snd_fm801_create(struct snd_card *card,
 		}
 	}
 
-	snd_fm801_chip_init(chip);
-
 	if ((chip->tea575x_tuner & TUNER_ONLY) == 0) {
 		if (devm_request_irq(&pci->dev, pci->irq, snd_fm801_interrupt,
 				IRQF_SHARED, KBUILD_MODNAME, chip)) {
@@ -1248,6 +1246,8 @@ static int snd_fm801_create(struct snd_card *card,
 		pci_set_master(pci);
 	}
 
+	snd_fm801_chip_init(chip);
+
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_fm801_free(chip);
 		return err;

commit d71a13f4c0e659c7ce7bef872c2e6a2287868e0e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:19:28 2017 +0200

    ALSA: fm801: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index c47287d79306..2e402ece4c86 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -334,23 +334,23 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 	return fm801_readw(chip, AC97_DATA);
 }
 
-static unsigned int rates[] = {
+static const unsigned int rates[] = {
   5500,  8000,  9600, 11025,
   16000, 19200, 22050, 32000,
   38400, 44100, 48000
 };
 
-static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
+static const struct snd_pcm_hw_constraint_list hw_constraints_rates = {
 	.count = ARRAY_SIZE(rates),
 	.list = rates,
 	.mask = 0,
 };
 
-static unsigned int channels[] = {
+static const unsigned int channels[] = {
   2, 4, 6
 };
 
-static struct snd_pcm_hw_constraint_list hw_constraints_channels = {
+static const struct snd_pcm_hw_constraint_list hw_constraints_channels = {
 	.count = ARRAY_SIZE(channels),
 	.list = channels,
 	.mask = 0,

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index bade9b907b92..c47287d79306 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -691,7 +691,7 @@ static int snd_fm801_capture_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static struct snd_pcm_ops snd_fm801_playback_ops = {
+static const struct snd_pcm_ops snd_fm801_playback_ops = {
 	.open =		snd_fm801_playback_open,
 	.close =	snd_fm801_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -702,7 +702,7 @@ static struct snd_pcm_ops snd_fm801_playback_ops = {
 	.pointer =	snd_fm801_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_fm801_capture_ops = {
+static const struct snd_pcm_ops snd_fm801_capture_ops = {
 	.open =		snd_fm801_capture_open,
 	.close =	snd_fm801_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit a016af2e70bfca23f2f5de7d8708157b86ea374d
Merge: e535d74bc50d c3b1681375dc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 17 12:05:31 2016 -0800

    Merge tag 'sound-4.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "We've had quite busy weeks in this cycle.  Looking at ALSA core, the
      significant changes are a few fixes wrt timer and sequencer ioctls
      that have been revealed by fuzzer recently.  Other than that, ASoC
      core got a few updates about DAI link handling, but these are rather
      straightforward refactoring.
    
      In drivers scene, ASoC received quite lots of new drivers in addition
      to bunch of updates for still ongoing Intel Skylake support and
      topology API.  HD-audio gained a new HDMI/DP hotplug notification via
      component.  FireWire got a pile of code refactoring/updates with
      SCS.1x driver integration.
    
      More highlights are shown below.
    
      [ NOTE: this contains also many commits for DRM.  This is due to the
        pull of drm stable branch into sound tree, as the base of i915 audio
        component work for HD-audio.  The highlights below don't contain
        these DRM changes, as these are supposed to be pulled via drm tree
        in anyway sooner or later.  ]
    
      Core:
       - Handful fixes to harden ALSA timer and sequencer ioctls against
         races reported by syzkaller fuzzer
       - Irq description string can be unique to each card; only for
         HD-audio for now
    
      ASoC:
       - Conversion of the array of DAI links to a list for supporting
         dynamically adding and removing DAI links
       - Topology API enhancements to make everything more component based
         and being able to specify PCM links via topology
       - Some more fixes for the topology code, though it is still not final
         and ready for enabling in production; we really need to get to the
         point where that can be done
       - A pile of changes for Intel SkyLake drivers which hopefully deliver
         some useful initial functionality for systems with this chipset,
         though there is more work still to come
       - Lots of new features and cleanups for the Renesas drivers
       - ANC support for WM5110
       - New drivers: Imagination Technologies IPs, Atmel class D speaker,
         Cirrus CS47L24 and WM1831, Dialog DA7128, Realtek RT5659 and
         RT56156, Rockchip RK3036, TI PC3168A, and AMD ACP
       - Rename PCM1792a driver to be generic pcm179x
    
      HD-Audio:
       - Use audio component for i915 HDMI/DP hotplug handling
       - On-demand binding with i915 driver
       - bdl_pos_adj parameter adjustment for Baytrail controllers
       - Enable power_save_node for CX20722; this shouldn't lead to
         regression, hopefully
       - Kabylake HDMI/DP codec support
       - Quirks for Lenovo E50-80, Dell Latitude E-series, and other Dell
         machines
       - A few code refactoring
    
      FireWire:
       - Lots of code cleanup and refactoring
       - Integrate the support of SCS.1x devices into snd-oxfw driver;
         snd-scs1x driver is obsoleted
    
      USB-audio:
       - Fix possible NULL dereference at disconnection
       - A regression fix for Native Instruments devices
    
      Misc:
       - A few code cleanups of fm801 driver"
    
    * tag 'sound-4.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (722 commits)
      ALSA: timer: Code cleanup
      ALSA: timer: Harden slave timer list handling
      ALSA: hda - Add fixup for Dell Latitidue E6540
      ALSA: timer: Fix race among timer ioctls
      ALSA: hda - add codec support for Kabylake display audio codec
      ALSA: timer: Fix double unlink of active_list
      ALSA: usb-audio: Fix mixer ctl regression of Native Instrument devices
      ALSA: hda - fix the headset mic detection problem for a Dell laptop
      ALSA: hda - Fix white noise on Dell Latitude E5550
      ALSA: hda_intel: add card number to irq description
      ALSA: seq: Fix race at timer setup and close
      ALSA: seq: Fix missing NULL check at remove_events ioctl
      ALSA: usb-audio: Avoid calling usb_autopm_put_interface() at disconnect
      ASoC: hdac_hdmi: remove unused hdac_hdmi_query_pin_connlist
      ASoC: AMD: Add missing include file
      ALSA: hda - Fixup inverted internal mic for Lenovo E50-80
      ALSA: usb: Add native DSD support for Oppo HA-1
      ASoC: Make aux_dev more like a generic component
      ASoC: bcm2835: cleanup includes by ordering them alphabetically
      ASoC: AMD: Manage ACP 2.x SRAM banks power
      ...

commit cb41f271d01b7c985ab47ea26fdef531a6237561
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 21 19:09:56 2015 +0200

    ALSA: fm801: restore TEA575x state on resume
    
    The suspend / resume cycle resets the settings of the FM tuner. Restore
    frequency settings on resume.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 0b1ae6c684c1..161925b6518e 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1427,6 +1427,11 @@ static int snd_fm801_resume(struct device *dev)
 	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
 		fm801_iowrite16(chip, saved_regs[i], chip->saved_regs[i]);
 
+#ifdef CONFIG_SND_FM801_TEA575X_BOOL
+	if (!(chip->tea575x_tuner & TUNER_DISABLED))
+		snd_tea575x_set_freq(&chip->tea);
+#endif
+
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }

commit 37ba8fca7e42b6e689689217b9739e3a9a3c35e6
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 21 19:09:55 2015 +0200

    ALSA: fm801: save context before suspend devices
    
    In symmetry we save context first before suspend and restore it last after
    resume.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 9e870884c02c..0b1ae6c684c1 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1394,6 +1394,9 @@ static int snd_fm801_suspend(struct device *dev)
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 
+	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
+		chip->saved_regs[i] = fm801_ioread16(chip, saved_regs[i]);
+
 	if (chip->tea575x_tuner & TUNER_ONLY) {
 		/* FIXME: tea575x suspend */
 	} else {
@@ -1402,8 +1405,6 @@ static int snd_fm801_suspend(struct device *dev)
 		snd_ac97_suspend(chip->ac97_sec);
 	}
 
-	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
-		chip->saved_regs[i] = fm801_ioread16(chip, saved_regs[i]);
 	return 0;
 }
 

commit 14da04b5ff8e1e70b53f9f927e915e32a56651e1
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 21 19:09:54 2015 +0200

    ALSA: fm801: no need to suspend absent codec
    
    In case of tuner only card there is no need to take care of the codec which is
    anyway absent.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 294fc131aee0..9e870884c02c 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1393,12 +1393,17 @@ static int snd_fm801_suspend(struct device *dev)
 	int i;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend_all(chip->pcm);
-	snd_ac97_suspend(chip->ac97);
-	snd_ac97_suspend(chip->ac97_sec);
+
+	if (chip->tea575x_tuner & TUNER_ONLY) {
+		/* FIXME: tea575x suspend */
+	} else {
+		snd_pcm_suspend_all(chip->pcm);
+		snd_ac97_suspend(chip->ac97);
+		snd_ac97_suspend(chip->ac97_sec);
+	}
+
 	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
 		chip->saved_regs[i] = fm801_ioread16(chip, saved_regs[i]);
-	/* FIXME: tea575x suspend */
 	return 0;
 }
 
@@ -1414,9 +1419,10 @@ static int snd_fm801_resume(struct device *dev)
 		reset_codec(chip);
 		snd_fm801_chip_multichannel_init(chip);
 		snd_fm801_chip_init(chip);
+		snd_ac97_resume(chip->ac97);
+		snd_ac97_resume(chip->ac97_sec);
 	}
-	snd_ac97_resume(chip->ac97);
-	snd_ac97_resume(chip->ac97_sec);
+
 	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
 		fm801_iowrite16(chip, saved_regs[i], chip->saved_regs[i]);
 

commit b56fa687e02b27f8bd9d282950a88c2ed23d766b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 21 19:09:53 2015 +0200

    ALSA: fm801: detect FM-only card earlier
    
    If user does not supply tea575x_tuner parameter the driver tries to detect the
    tuner type. The failed codec initialization is considered as FM-only card
    present, however the driver still registers an IRQ handler for it.
    
    Move codec detection earlier to set tea575x_tuner parameter before check.
    
    Here the following functions are introduced
     reset_coded()                       resets AC97 codec
     snd_fm801_chip_multichannel_init()  initializes cards with multichannel support
    
    Fixes: 5618955c4269 (ALSA: fm801: move to pcim_* and devm_* functions)
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 63025b8925f5..294fc131aee0 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1098,26 +1098,20 @@ static int wait_for_codec(struct fm801 *chip, unsigned int codec_id,
 	return -EIO;
 }
 
-static int snd_fm801_chip_init(struct fm801 *chip, int resume)
+static int reset_codec(struct fm801 *chip)
 {
-	unsigned short cmdw;
-
-	if (chip->tea575x_tuner & TUNER_ONLY)
-		goto __ac97_ok;
-
 	/* codec cold reset + AC'97 warm reset */
 	fm801_writew(chip, CODEC_CTRL, (1 << 5) | (1 << 6));
 	fm801_readw(chip, CODEC_CTRL); /* flush posting data */
 	udelay(100);
 	fm801_writew(chip, CODEC_CTRL, 0);
 
-	if (wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750)) < 0)
-		if (!resume) {
-			dev_info(chip->card->dev,
-				 "Primary AC'97 codec not found, assume SF64-PCR (tuner-only)\n");
-			chip->tea575x_tuner = 3 | TUNER_ONLY;
-			goto __ac97_ok;
-		}
+	return wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750));
+}
+
+static void snd_fm801_chip_multichannel_init(struct fm801 *chip)
+{
+	unsigned short cmdw;
 
 	if (chip->multichannel) {
 		if (chip->secondary_addr) {
@@ -1144,8 +1138,11 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 		/* cause timeout problems */
 		wait_for_codec(chip, 0, AC97_VENDOR_ID1, msecs_to_jiffies(750));
 	}
+}
 
-      __ac97_ok:
+static void snd_fm801_chip_init(struct fm801 *chip)
+{
+	unsigned short cmdw;
 
 	/* init volume */
 	fm801_writew(chip, PCM_VOL, 0x0808);
@@ -1166,11 +1163,8 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 	/* interrupt clear */
 	fm801_writew(chip, IRQ_STATUS,
 		     FM801_IRQ_PLAYBACK | FM801_IRQ_CAPTURE | FM801_IRQ_MPU);
-
-	return 0;
 }
 
-
 static int snd_fm801_free(struct fm801 *chip)
 {
 	unsigned short cmdw;
@@ -1227,7 +1221,23 @@ static int snd_fm801_create(struct snd_card *card,
 	if ((err = pci_request_regions(pci, "FM801")) < 0)
 		return err;
 	chip->port = pci_resource_start(pci, 0);
-	if ((tea575x_tuner & TUNER_ONLY) == 0) {
+
+	if (pci->revision >= 0xb1)	/* FM801-AU */
+		chip->multichannel = 1;
+
+	if (!(chip->tea575x_tuner & TUNER_ONLY)) {
+		if (reset_codec(chip) < 0) {
+			dev_info(chip->card->dev,
+				 "Primary AC'97 codec not found, assume SF64-PCR (tuner-only)\n");
+			chip->tea575x_tuner = 3 | TUNER_ONLY;
+		} else {
+			snd_fm801_chip_multichannel_init(chip);
+		}
+	}
+
+	snd_fm801_chip_init(chip);
+
+	if ((chip->tea575x_tuner & TUNER_ONLY) == 0) {
 		if (devm_request_irq(&pci->dev, pci->irq, snd_fm801_interrupt,
 				IRQF_SHARED, KBUILD_MODNAME, chip)) {
 			dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
@@ -1238,13 +1248,6 @@ static int snd_fm801_create(struct snd_card *card,
 		pci_set_master(pci);
 	}
 
-	if (pci->revision >= 0xb1)	/* FM801-AU */
-		chip->multichannel = 1;
-
-	snd_fm801_chip_init(chip, 0);
-	/* init might set tuner access method */
-	tea575x_tuner = chip->tea575x_tuner;
-
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_fm801_free(chip);
 		return err;
@@ -1261,15 +1264,15 @@ static int snd_fm801_create(struct snd_card *card,
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_fm801_tea_ops;
 	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
-	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
-	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
+	if ((chip->tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
+	    (chip->tea575x_tuner & TUNER_TYPE_MASK) < 4) {
 		if (snd_tea575x_init(&chip->tea, THIS_MODULE)) {
 			dev_err(card->dev, "TEA575x radio not found\n");
 			snd_fm801_free(chip);
 			return -ENODEV;
 		}
-	} else if ((tea575x_tuner & TUNER_TYPE_MASK) == 0) {
-		unsigned int tuner_only = tea575x_tuner & TUNER_ONLY;
+	} else if ((chip->tea575x_tuner & TUNER_TYPE_MASK) == 0) {
+		unsigned int tuner_only = chip->tea575x_tuner & TUNER_ONLY;
 
 		/* autodetect tuner connection */
 		for (tea575x_tuner = 1; tea575x_tuner <= 3; tea575x_tuner++) {
@@ -1405,7 +1408,13 @@ static int snd_fm801_resume(struct device *dev)
 	struct fm801 *chip = card->private_data;
 	int i;
 
-	snd_fm801_chip_init(chip, 1);
+	if (chip->tea575x_tuner & TUNER_ONLY) {
+		snd_fm801_chip_init(chip);
+	} else {
+		reset_codec(chip);
+		snd_fm801_chip_multichannel_init(chip);
+		snd_fm801_chip_init(chip);
+	}
 	snd_ac97_resume(chip->ac97);
 	snd_ac97_resume(chip->ac97_sec);
 	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)

commit dbec6719ac036f68568d8488805d41346c021eff
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Dec 21 19:09:52 2015 +0200

    ALSA: fm801: propagate TUNER_ONLY bit when autodetected
    
    The commit d7ba858a7f7a (ALSA: fm801: implement TEA575x tuner autodetection)
    brings autodetection to the driver. However the autodetection algorithm misses
    the TUNER_ONLY bit if it is supplied by the user.
    
    Thus, user gets weird messages and no card registered.
    
     snd_fm801 0000:0d:01.0: detected TEA575x radio type SF64-PCR
     snd_fm801 0000:0d:01.0: AC'97 interface is busy (1)
     snd_fm801 0000:0d:01.0: AC'97 interface is busy (1)
    ...
     snd_fm801 0000:0d:01.0: AC'97 0 does not respond - RESET
     snd_fm801 0000:0d:01.0: AC'97 interface is busy (1)
     snd_fm801 0000:0d:01.0: AC'97 interface is busy (1)
     snd_fm801 0000:0d:01.0: AC'97 0 access is not valid [0x0], removing mixer.
     snd_fm801: probe of 0000:0d:01.0 failed with error -5
    
    Do a copy of TUNER_ONLY bit to be applied after autodetection is done.
    
    Fixes: d7ba858a7f7a (ALSA: fm801: implement TEA575x tuner autodetection)
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index e4e610c5d1ba..63025b8925f5 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1269,6 +1269,8 @@ static int snd_fm801_create(struct snd_card *card,
 			return -ENODEV;
 		}
 	} else if ((tea575x_tuner & TUNER_TYPE_MASK) == 0) {
+		unsigned int tuner_only = tea575x_tuner & TUNER_ONLY;
+
 		/* autodetect tuner connection */
 		for (tea575x_tuner = 1; tea575x_tuner <= 3; tea575x_tuner++) {
 			chip->tea575x_tuner = tea575x_tuner;
@@ -1283,6 +1285,8 @@ static int snd_fm801_create(struct snd_card *card,
 			dev_err(card->dev, "TEA575x radio not found\n");
 			chip->tea575x_tuner = TUNER_DISABLED;
 		}
+
+		chip->tea575x_tuner |= tuner_only;
 	}
 	if (!(chip->tea575x_tuner & TUNER_DISABLED)) {
 		strlcpy(chip->tea.card, get_tea575x_gpio(chip)->name,

commit d3d33aabac51341065bcce0e9c2d9d27902a08c4
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 18 21:14:13 2015 +0200

    ALSA: fm801: store struct device instead of pci_dev
    
    There is no need to store struct pci_dev in struct fm801. Generic struct device
    can be easily translated to struct pci_dev whenever it's needed, in particular
    for one user for now.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index c24cb04895b8..e4e610c5d1ba 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -163,6 +163,7 @@ MODULE_PARM_DESC(radio_nr, "Radio device numbers");
  * @cap_ctrl:		capture control
  */
 struct fm801 {
+	struct device *dev;
 	int irq;
 
 	unsigned long port;
@@ -190,7 +191,6 @@ struct fm801 {
 	struct snd_ac97 *ac97;
 	struct snd_ac97 *ac97_sec;
 
-	struct pci_dev *pci;
 	struct snd_card *card;
 	struct snd_pcm *pcm;
 	struct snd_rawmidi *rmidi;
@@ -715,6 +715,7 @@ static struct snd_pcm_ops snd_fm801_capture_ops = {
 
 static int snd_fm801_pcm(struct fm801 *chip, int device)
 {
+	struct pci_dev *pdev = to_pci_dev(chip->dev);
 	struct snd_pcm *pcm;
 	int err;
 
@@ -730,7 +731,7 @@ static int snd_fm801_pcm(struct fm801 *chip, int device)
 	chip->pcm = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(chip->pci),
+					      snd_dma_pci_data(pdev),
 					      chip->multichannel ? 128*1024 : 64*1024, 128*1024);
 
 	return snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
@@ -1182,7 +1183,7 @@ static int snd_fm801_free(struct fm801 *chip)
 	cmdw |= 0x00c3;
 	fm801_writew(chip, IRQ_MASK, cmdw);
 
-	devm_free_irq(&chip->pci->dev, chip->irq, chip);
+	devm_free_irq(chip->dev, chip->irq, chip);
 
       __end_hw:
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
@@ -1220,7 +1221,7 @@ static int snd_fm801_create(struct snd_card *card,
 		return -ENOMEM;
 	spin_lock_init(&chip->reg_lock);
 	chip->card = card;
-	chip->pci = pci;
+	chip->dev = &pci->dev;
 	chip->irq = -1;
 	chip->tea575x_tuner = tea575x_tuner;
 	if ((err = pci_request_regions(pci, "FM801")) < 0)

commit 997c87dad2a322516db391c7df440bd89e18fc31
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 18 21:14:12 2015 +0200

    ALSA: fm801: put curly braces around empty if-body
    
    The compiler complains on unused condition as follows
    
    sound/pci/fm801.c: In function ‘snd_fm801_interrupt’:
    sound/pci/fm801.c:585:3: warning: suggest braces around empty body in an ‘if’ statement [-Wempty-body]
    
    Put the curly braces around empty body as suggested.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index c2afb41907bd..c24cb04895b8 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -592,8 +592,9 @@ static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id)
 	}
 	if (chip->rmidi && (status & FM801_IRQ_MPU))
 		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
-	if (status & FM801_IRQ_VOLUME)
-		;/* TODO */
+	if (status & FM801_IRQ_VOLUME) {
+		/* TODO */
+	}
 
 	return IRQ_HANDLED;
 }

commit 4b5c15f746db70efc710369f62c6e1d323e20fb9
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Fri Dec 18 21:14:11 2015 +0200

    ALSA: fm801: convert rest outw() / inw() to use helpers
    
    The patch introduces two new helpers fm801_iowrite16() and fm801_ioread16() to
    write and read the registers by offset. Previously similar was done to access
    the hardware registers by their names.
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index f57847cc53c1..c2afb41907bd 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -212,6 +212,20 @@ struct fm801 {
 #endif
 };
 
+/*
+ * IO accessors
+ */
+
+static inline void fm801_iowrite16(struct fm801 *chip, unsigned short offset, u16 value)
+{
+	outw(value, chip->port + offset);
+}
+
+static inline u16 fm801_ioread16(struct fm801 *chip, unsigned short offset)
+{
+	return inw(chip->port + offset);
+}
+
 static const struct pci_device_id snd_fm801_ids[] = {
 	{ 0x1319, 0x0801, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* FM801 */
 	{ 0x5213, 0x0510, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* Gallant Odyssey Sound 4 */
@@ -256,11 +270,11 @@ static int snd_fm801_update_bits(struct fm801 *chip, unsigned short reg,
 	unsigned short old, new;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
-	old = inw(chip->port + reg);
+	old = fm801_ioread16(chip, reg);
 	new = (old & ~mask) | value;
 	change = old != new;
 	if (change)
-		outw(new, chip->port + reg);
+		fm801_iowrite16(chip, reg, new);
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 	return change;
 }
@@ -851,10 +865,11 @@ static int snd_fm801_get_single(struct snd_kcontrol *kcontrol,
 	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 	int invert = (kcontrol->private_value >> 24) & 0xff;
+	long *value = ucontrol->value.integer.value;
 
-	ucontrol->value.integer.value[0] = (inw(chip->port + reg) >> shift) & mask;
+	value[0] = (fm801_ioread16(chip, reg) >> shift) & mask;
 	if (invert)
-		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
+		value[0] = mask - value[0];
 	return 0;
 }
 
@@ -907,14 +922,15 @@ static int snd_fm801_get_double(struct snd_kcontrol *kcontrol,
 	int shift_right = (kcontrol->private_value >> 12) & 0x0f;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 	int invert = (kcontrol->private_value >> 24) & 0xff;
+	long *value = ucontrol->value.integer.value;
 
 	spin_lock_irq(&chip->reg_lock);
-	ucontrol->value.integer.value[0] = (inw(chip->port + reg) >> shift_left) & mask;
-	ucontrol->value.integer.value[1] = (inw(chip->port + reg) >> shift_right) & mask;
+	value[0] = (fm801_ioread16(chip, reg) >> shift_left) & mask;
+	value[1] = (fm801_ioread16(chip, reg) >> shift_right) & mask;
 	spin_unlock_irq(&chip->reg_lock);
 	if (invert) {
-		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
-		ucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];
+		value[0] = mask - value[0];
+		value[1] = mask - value[1];
 	}
 	return 0;
 }
@@ -1372,7 +1388,7 @@ static int snd_fm801_suspend(struct device *dev)
 	snd_ac97_suspend(chip->ac97);
 	snd_ac97_suspend(chip->ac97_sec);
 	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
-		chip->saved_regs[i] = inw(chip->port + saved_regs[i]);
+		chip->saved_regs[i] = fm801_ioread16(chip, saved_regs[i]);
 	/* FIXME: tea575x suspend */
 	return 0;
 }
@@ -1387,7 +1403,7 @@ static int snd_fm801_resume(struct device *dev)
 	snd_ac97_resume(chip->ac97);
 	snd_ac97_resume(chip->ac97_sec);
 	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
-		outw(chip->saved_regs[i], chip->port + saved_regs[i]);
+		fm801_iowrite16(chip, saved_regs[i], chip->saved_regs[i]);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;

commit e97e98c63b43040732ad5d1f0b38ad4a8371c73a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 18 21:14:10 2015 +0200

    ALSA: fm801: explicitly free IRQ line
    
    Otherwise we will have a warning on ->remove() since device is a PCI one.
    
    WARNING: CPU: 4 PID: 1411 at /home/andy/prj/linux/fs/proc/generic.c:575 remove_proc_entry+0x137/0x160()
    remove_proc_entry: removing non-empty directory 'irq/21', leaking at least 'snd_fm801'
    
    Fixes: 5618955c4269 (ALSA: fm801: move to pcim_* and devm_* functions)
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 1fdd92b6f18f..f57847cc53c1 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1165,6 +1165,8 @@ static int snd_fm801_free(struct fm801 *chip)
 	cmdw |= 0x00c3;
 	fm801_writew(chip, IRQ_MASK, cmdw);
 
+	devm_free_irq(&chip->pci->dev, chip->irq, chip);
+
       __end_hw:
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
 	if (!(chip->tea575x_tuner & TUNER_DISABLED)) {

commit 22dbec265c4fbea4cecc37bcbdbb730c0bc639ff
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Nov 22 08:32:53 2015 -0200

    [media] media, sound: tea575x: constify snd_tea575x_ops structures
    
    The snd_tea575x_ops structures are never modified, so declare them as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 5144a7fcb5aa..759295aa8366 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -815,7 +815,7 @@ static void snd_fm801_tea575x_set_direction(struct snd_tea575x *tea, bool output
 	fm801_writew(chip, GPIO_CTRL, reg);
 }
 
-static struct snd_tea575x_ops snd_fm801_tea_ops = {
+static const struct snd_tea575x_ops snd_fm801_tea_ops = {
 	.set_pins = snd_fm801_tea575x_set_pins,
 	.get_pins = snd_fm801_tea575x_get_pins,
 	.set_direction = snd_fm801_tea575x_set_direction,

commit d647f0b70ce2b4aeb443639dc92b2d859da697a7
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Nov 13 19:40:07 2015 -0200

    [media] include/media: move driver interface headers to a separate dir
    
    Let's not mix headers used by the core with those headers that
    are needed by some driver-specific interface header.
    
    The headers used on drivers were manually moved using:
        mkdir include/media/drv-intf/
        git mv include/media/cx2341x.h include/media/cx25840.h \
            include/media/exynos-fimc.h include/media/msp3400.h \
            include/media/s3c_camif.h include/media/saa7146.h \
            include/media/saa7146_vv.h  include/media/sh_mobile_ceu.h \
            include/media/sh_mobile_csi2.h include/media/sh_vou.h \
            include/media/si476x.h include/media/soc_mediabus.h \
            include/media/tea575x.h include/media/drv-intf/
    
    And the references for those headers were corrected using:
    
        MAIN_DIR="media/"
        PREV_DIR="media/"
        DIRS="drv-intf/"
    
        echo "Checking affected files" >&2
        for i in $DIRS; do
            for j in $(find include/$MAIN_DIR/$i -type f -name '*.h'); do
                     n=`basename $j`
                    git grep -l $n
            done
        done|sort|uniq >files && (
            echo "Handling files..." >&2;
            echo "for i in \$(cat files|grep -v Documentation); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "perl -ne 's,(include [\\\"\\<])$PREV_DIR($i)([\\\"\\>]),\1$MAIN_DIR$j\2\3,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done";
            );
            echo "Handling documentation..." >&2;
            echo "for i in MAINTAINERS \$(cat files); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "  perl -ne 's,include/$PREV_DIR($i)\b,include/$MAIN_DIR$j\1,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done"
            );
        ) >script && . ./script
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 1fdd92b6f18f..5144a7fcb5aa 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -30,7 +30,7 @@
 #include <sound/initval.h>
 
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
-#include <media/tea575x.h>
+#include <media/drv-intf/tea575x.h>
 #endif
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");

commit 12c243b833c2c441f46dc592ab410fdccb5e056b
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Sat Jan 10 16:57:45 2015 +0200

    ALSA: fm801: remove FSF address
    
    The FSF address is subject to change. So, we remove it from the header.
    
    While here, remove a line with my old and non-functional email from the
    header. Moreover, nowadays we have a Git VCS that contains a history of
    changes.
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 52555bdaf91c..1fdd92b6f18f 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -2,8 +2,6 @@
  *  The driver for the ForteMedia FM801 based soundcards
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
- *  Support FM only card by Andy Shevchenko <andy@smile.org.ua>
- *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
  *   the Free Software Foundation; either version 2 of the License, or
@@ -14,10 +12,6 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *   GNU General Public License for more details.
  *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/delay.h>

commit 9e5947465d72ef1b3a88104474ab2adf78837220
Merge: 624afe4dc9a0 3e41c9b5a1ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 11 11:26:48 2015 +0100

    Merge branch 'topic/pci-cleanup' into for-next

commit 3db084fd0af5407eebeb9b7ebd5d0425b362c519
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Thu Jan 8 00:39:17 2015 +0200

    ALSA: fm801: PCI core handles power state for us
    
    There is no need to repeat the work that is already done in the PCI
    driver core. The patch removes excerpts from suspend and resume
    callbacks.
    
    Note that there is no more calls performed to enable or disable a PCI
    device during suspend-resume cycle. Nowadays they seems to be
    superflous. Someone can read more in [1].
    
    [1] https://www.kernel.org/doc/ols/2009/ols2009-pages-319-330.pdf
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index dd6f23fbbdf9..1a0494eff0c6 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1375,7 +1375,6 @@ static unsigned char saved_regs[] = {
 
 static int snd_fm801_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct fm801 *chip = card->private_data;
 	int i;
@@ -1387,29 +1386,15 @@ static int snd_fm801_suspend(struct device *dev)
 	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
 		chip->saved_regs[i] = inw(chip->port + saved_regs[i]);
 	/* FIXME: tea575x suspend */
-
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int snd_fm801_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct fm801 *chip = card->private_data;
 	int i;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
-
 	snd_fm801_chip_init(chip, 1);
 	snd_ac97_resume(chip->ac97);
 	snd_ac97_resume(chip->ac97_sec);

commit 3b6fe95a07a1bb13784df866aa75c7bcc28529e3
Merge: 4f7946eca787 5618955c4269
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 7 15:54:25 2015 +0100

    Merge branch 'topic/pci-cleanup' into for-next

commit 5618955c4269b07c8177f88a8075d4879e74cd27
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Wed Jan 7 01:40:17 2015 +0200

    ALSA: fm801: move to pcim_* and devm_* functions
    
    The managed functions allow to get ->probe() and ->remove() simplier.
    This patch converts code to use managed functions.
    
    While here remove the dead code and fix the value printed in error
    message.
    
    [removed pci_release_regions() as it's managed in pcim_release(), too
      -- tiwai]
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index d167afffce5f..dd6f23fbbdf9 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1186,12 +1186,6 @@ static int snd_fm801_free(struct fm801 *chip)
 		v4l2_device_unregister(&chip->v4l2_dev);
 	}
 #endif
-	if (chip->irq >= 0)
-		free_irq(chip->irq, chip);
-	pci_release_regions(chip->pci);
-	pci_disable_device(chip->pci);
-
-	kfree(chip);
 	return 0;
 }
 
@@ -1214,28 +1208,23 @@ static int snd_fm801_create(struct snd_card *card,
 	};
 
 	*rchip = NULL;
-	if ((err = pci_enable_device(pci)) < 0)
+	if ((err = pcim_enable_device(pci)) < 0)
 		return err;
-	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
-	if (chip == NULL) {
-		pci_disable_device(pci);
+	chip = devm_kzalloc(&pci->dev, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
 		return -ENOMEM;
-	}
 	spin_lock_init(&chip->reg_lock);
 	chip->card = card;
 	chip->pci = pci;
 	chip->irq = -1;
 	chip->tea575x_tuner = tea575x_tuner;
-	if ((err = pci_request_regions(pci, "FM801")) < 0) {
-		kfree(chip);
-		pci_disable_device(pci);
+	if ((err = pci_request_regions(pci, "FM801")) < 0)
 		return err;
-	}
 	chip->port = pci_resource_start(pci, 0);
 	if ((tea575x_tuner & TUNER_ONLY) == 0) {
-		if (request_irq(pci->irq, snd_fm801_interrupt, IRQF_SHARED,
-				KBUILD_MODNAME, chip)) {
-			dev_err(card->dev, "unable to grab IRQ %d\n", chip->irq);
+		if (devm_request_irq(&pci->dev, pci->irq, snd_fm801_interrupt,
+				IRQF_SHARED, KBUILD_MODNAME, chip)) {
+			dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 			snd_fm801_free(chip);
 			return -EBUSY;
 		}
@@ -1250,12 +1239,6 @@ static int snd_fm801_create(struct snd_card *card,
 	/* init might set tuner access method */
 	tea575x_tuner = chip->tea575x_tuner;
 
-	if (chip->irq >= 0 && (tea575x_tuner & TUNER_ONLY)) {
-		pci_clear_master(pci);
-		free_irq(chip->irq, chip);
-		chip->irq = -1;
-	}
-
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_fm801_free(chip);
 		return err;

commit 483337f903dd39a10d4d6617cf6f30feeead061c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:50 2015 +0100

    ALSA: fm801: Remove always NULL parameter
    
    snd_fm801_pcm() takes a pointer to a pointer of a PCM where if this
    parameter is provided the newly allocated PCM is stored. All callers pass
    NULL though, so remove the parameter. This makes the code a bit cleaner and
    shorter.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index d167afffce5f..9a2122fd3a8e 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -704,13 +704,11 @@ static struct snd_pcm_ops snd_fm801_capture_ops = {
 	.pointer =	snd_fm801_capture_pointer,
 };
 
-static int snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pcm **rpcm)
+static int snd_fm801_pcm(struct fm801 *chip, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
 
-	if (rpcm)
-		*rpcm = NULL;
 	if ((err = snd_pcm_new(chip->card, "FM801", device, 1, 1, &pcm)) < 0)
 		return err;
 
@@ -726,16 +724,10 @@ static int snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pcm **rpcm)
 					      snd_dma_pci_data(chip->pci),
 					      chip->multichannel ? 128*1024 : 64*1024, 128*1024);
 
-	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+	return snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 				     snd_pcm_alt_chmaps,
 				     chip->multichannel ? 6 : 2, 0,
 				     NULL);
-	if (err < 0)
-		return err;
-
-	if (rpcm)
-		*rpcm = pcm;
-	return 0;
 }
 
 /*
@@ -1340,7 +1332,7 @@ static int snd_card_fm801_probe(struct pci_dev *pci,
 	if (chip->tea575x_tuner & TUNER_ONLY)
 		goto __fm801_tuner_only;
 
-	if ((err = snd_fm801_pcm(chip, 0, NULL)) < 0) {
+	if ((err = snd_fm801_pcm(chip, 0)) < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit ca776a28ae10bb06807f23e807f0f459dab78318
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 20 18:17:17 2014 +0200

    ALSA: fm801: Use snd_ctl_enum_info()
    
    ... and reduce the open codes.  Also add missing const to the text array.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index c5038303a126..d167afffce5f 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -958,17 +958,11 @@ static int snd_fm801_put_double(struct snd_kcontrol *kcontrol,
 static int snd_fm801_info_mux(struct snd_kcontrol *kcontrol,
 			      struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[5] = {
+	static const char * const texts[5] = {
 		"AC97 Primary", "FM", "I2S", "PCM", "AC97 Secondary"
 	};
  
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 5;
-	if (uinfo->value.enumerated.item > 4)
-		uinfo->value.enumerated.item = 4;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 5, texts);
 }
 
 static int snd_fm801_get_mux(struct snd_kcontrol *kcontrol,

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 529f5f4f4c9c..c5038303a126 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -218,7 +218,7 @@ struct fm801 {
 #endif
 };
 
-static DEFINE_PCI_DEVICE_TABLE(snd_fm801_ids) = {
+static const struct pci_device_id snd_fm801_ids[] = {
 	{ 0x1319, 0x0801, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* FM801 */
 	{ 0x5213, 0x0510, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* Gallant Odyssey Sound 4 */
 	{ 0, }

commit 052c233e9800b1f7da4c18cb1660576249486a73
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon May 19 14:07:28 2014 +0300

    ALSA: fm801: convert struct description to kernel-doc
    
    Just move field descriptions to the struct description in the kernel-doc
    format. There is no functional change.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index e8910d02580b..529f5f4f4c9c 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -158,21 +158,27 @@ MODULE_PARM_DESC(radio_nr, "Radio device numbers");
 #define FM801_GPIO_GS3		(1<<15)
 #define FM801_GPIO_GS(x)	(1<<(12+(x)))
 	
-/*
-
+/**
+ * struct fm801 - describes FM801 chip
+ * @port:		I/O port number
+ * @multichannel:	multichannel support
+ * @secondary:		secondary codec
+ * @secondary_addr:	address of the secondary codec
+ * @tea575x_tuner:	tuner access method & flags
+ * @ply_ctrl:		playback control
+ * @cap_ctrl:		capture control
  */
-
 struct fm801 {
 	int irq;
 
-	unsigned long port;	/* I/O port number */
-	unsigned int multichannel: 1,	/* multichannel support */
-		     secondary: 1;	/* secondary codec */
-	unsigned char secondary_addr;	/* address of the secondary codec */
-	unsigned int tea575x_tuner;	/* tuner access method & flags */
+	unsigned long port;
+	unsigned int multichannel: 1,
+		     secondary: 1;
+	unsigned char secondary_addr;
+	unsigned int tea575x_tuner;
 
-	unsigned short ply_ctrl; /* playback control */
-	unsigned short cap_ctrl; /* capture control */
+	unsigned short ply_ctrl;
+	unsigned short cap_ctrl;
 
 	unsigned long ply_buffer;
 	unsigned int ply_buf;

commit 02fd1a76bfeb8d6293608dc3a1b8667b1da5a923
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Tue Apr 29 10:56:04 2014 +0300

    ALSA: fm801: introduce fm801_ac97_is_ready()/fm801_ac97_is_valid() helpers
    
    The introduced functios check AC97 if it's ready for communication and
    read data is valid.
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 5be910ca35c5..e8910d02580b 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -224,6 +224,30 @@ MODULE_DEVICE_TABLE(pci, snd_fm801_ids);
  *  common I/O routines
  */
 
+static bool fm801_ac97_is_ready(struct fm801 *chip, unsigned int iterations)
+{
+	unsigned int idx;
+
+	for (idx = 0; idx < iterations; idx++) {
+		if (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))
+			return true;
+		udelay(10);
+	}
+	return false;
+}
+
+static bool fm801_ac97_is_valid(struct fm801 *chip, unsigned int iterations)
+{
+	unsigned int idx;
+
+	for (idx = 0; idx < iterations; idx++) {
+		if (fm801_readw(chip, AC97_CMD) & FM801_AC97_VALID)
+			return true;
+		udelay(10);
+	}
+	return false;
+}
+
 static int snd_fm801_update_bits(struct fm801 *chip, unsigned short reg,
 				 unsigned short mask, unsigned short value)
 {
@@ -246,72 +270,53 @@ static void snd_fm801_codec_write(struct snd_ac97 *ac97,
 				  unsigned short val)
 {
 	struct fm801 *chip = ac97->private_data;
-	int idx;
 
 	/*
 	 *  Wait until the codec interface is not ready..
 	 */
-	for (idx = 0; idx < 100; idx++) {
-		if (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))
-			goto ok1;
-		udelay(10);
+	if (!fm801_ac97_is_ready(chip, 100)) {
+		dev_err(chip->card->dev, "AC'97 interface is busy (1)\n");
+		return;
 	}
-	dev_err(chip->card->dev, "AC'97 interface is busy (1)\n");
-	return;
 
- ok1:
 	/* write data and address */
 	fm801_writew(chip, AC97_DATA, val);
 	fm801_writew(chip, AC97_CMD, reg | (ac97->addr << FM801_AC97_ADDR_SHIFT));
 	/*
 	 *  Wait until the write command is not completed..
-         */
-	for (idx = 0; idx < 1000; idx++) {
-		if (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))
-			return;
-		udelay(10);
-	}
-	dev_err(chip->card->dev, "AC'97 interface #%d is busy (2)\n", ac97->num);
+	 */
+	if (!fm801_ac97_is_ready(chip, 1000))
+		dev_err(chip->card->dev, "AC'97 interface #%d is busy (2)\n",
+		ac97->num);
 }
 
 static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short reg)
 {
 	struct fm801 *chip = ac97->private_data;
-	int idx;
 
 	/*
 	 *  Wait until the codec interface is not ready..
 	 */
-	for (idx = 0; idx < 100; idx++) {
-		if (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))
-			goto ok1;
-		udelay(10);
+	if (!fm801_ac97_is_ready(chip, 100)) {
+		dev_err(chip->card->dev, "AC'97 interface is busy (1)\n");
+		return 0;
 	}
-	dev_err(chip->card->dev, "AC'97 interface is busy (1)\n");
-	return 0;
 
- ok1:
 	/* read command */
 	fm801_writew(chip, AC97_CMD,
 		     reg | (ac97->addr << FM801_AC97_ADDR_SHIFT) | FM801_AC97_READ);
-	for (idx = 0; idx < 100; idx++) {
-		if (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))
-			goto ok2;
-		udelay(10);
+	if (!fm801_ac97_is_ready(chip, 100)) {
+		dev_err(chip->card->dev, "AC'97 interface #%d is busy (2)\n",
+			ac97->num);
+		return 0;
 	}
-	dev_err(chip->card->dev, "AC'97 interface #%d is busy (2)\n", ac97->num);
-	return 0;
 
- ok2:
-	for (idx = 0; idx < 1000; idx++) {
-		if (fm801_readw(chip, AC97_CMD) & FM801_AC97_VALID)
-			goto ok3;
-		udelay(10);
+	if (!fm801_ac97_is_valid(chip, 1000)) {
+		dev_err(chip->card->dev,
+			"AC'97 interface #%d is not valid (2)\n", ac97->num);
+		return 0;
 	}
-	dev_err(chip->card->dev, "AC'97 interface #%d is not valid (2)\n", ac97->num);
-	return 0;
 
- ok3:
 	return fm801_readw(chip, AC97_DATA);
 }
 

commit 215dacc2811091a9248a3f62164e247aefa39de3
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Tue Apr 29 10:56:03 2014 +0300

    ALSA: fm801: introduce macros to access the hardware
    
    It will help to maintain HW accessors and, for example, switch from the
    direct I/O to MMIO which is more convenient for PCI devices.
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index db18ccabadd6..5be910ca35c5 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -23,6 +23,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/io.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/module.h>
@@ -34,8 +35,6 @@
 #include <sound/opl3.h>
 #include <sound/initval.h>
 
-#include <asm/io.h>
-
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
 #include <media/tea575x.h>
 #endif
@@ -80,7 +79,10 @@ MODULE_PARM_DESC(radio_nr, "Radio device numbers");
  *  Direct registers
  */
 
-#define FM801_REG(chip, reg)	(chip->port + FM801_##reg)
+#define fm801_writew(chip,reg,value)	outw((value), chip->port + FM801_##reg)
+#define fm801_readw(chip,reg)		inw(chip->port + FM801_##reg)
+
+#define fm801_writel(chip,reg,value)	outl((value), chip->port + FM801_##reg)
 
 #define FM801_PCM_VOL		0x00	/* PCM Output Volume */
 #define FM801_FM_VOL		0x02	/* FM Output Volume */
@@ -250,7 +252,7 @@ static void snd_fm801_codec_write(struct snd_ac97 *ac97,
 	 *  Wait until the codec interface is not ready..
 	 */
 	for (idx = 0; idx < 100; idx++) {
-		if (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))
+		if (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))
 			goto ok1;
 		udelay(10);
 	}
@@ -259,13 +261,13 @@ static void snd_fm801_codec_write(struct snd_ac97 *ac97,
 
  ok1:
 	/* write data and address */
-	outw(val, FM801_REG(chip, AC97_DATA));
-	outw(reg | (ac97->addr << FM801_AC97_ADDR_SHIFT), FM801_REG(chip, AC97_CMD));
+	fm801_writew(chip, AC97_DATA, val);
+	fm801_writew(chip, AC97_CMD, reg | (ac97->addr << FM801_AC97_ADDR_SHIFT));
 	/*
 	 *  Wait until the write command is not completed..
          */
 	for (idx = 0; idx < 1000; idx++) {
-		if (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))
+		if (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))
 			return;
 		udelay(10);
 	}
@@ -281,7 +283,7 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 	 *  Wait until the codec interface is not ready..
 	 */
 	for (idx = 0; idx < 100; idx++) {
-		if (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))
+		if (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))
 			goto ok1;
 		udelay(10);
 	}
@@ -290,10 +292,10 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 
  ok1:
 	/* read command */
-	outw(reg | (ac97->addr << FM801_AC97_ADDR_SHIFT) | FM801_AC97_READ,
-	     FM801_REG(chip, AC97_CMD));
+	fm801_writew(chip, AC97_CMD,
+		     reg | (ac97->addr << FM801_AC97_ADDR_SHIFT) | FM801_AC97_READ);
 	for (idx = 0; idx < 100; idx++) {
-		if (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))
+		if (!(fm801_readw(chip, AC97_CMD) & FM801_AC97_BUSY))
 			goto ok2;
 		udelay(10);
 	}
@@ -302,7 +304,7 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 
  ok2:
 	for (idx = 0; idx < 1000; idx++) {
-		if (inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_VALID)
+		if (fm801_readw(chip, AC97_CMD) & FM801_AC97_VALID)
 			goto ok3;
 		udelay(10);
 	}
@@ -310,7 +312,7 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 	return 0;
 
  ok3:
-	return inw(FM801_REG(chip, AC97_DATA));
+	return fm801_readw(chip, AC97_DATA);
 }
 
 static unsigned int rates[] = {
@@ -384,7 +386,7 @@ static int snd_fm801_playback_trigger(struct snd_pcm_substream *substream,
 		snd_BUG();
 		return -EINVAL;
 	}
-	outw(chip->ply_ctrl, FM801_REG(chip, PLY_CTRL));
+	fm801_writew(chip, PLY_CTRL, chip->ply_ctrl);
 	spin_unlock(&chip->reg_lock);
 	return 0;
 }
@@ -419,7 +421,7 @@ static int snd_fm801_capture_trigger(struct snd_pcm_substream *substream,
 		snd_BUG();
 		return -EINVAL;
 	}
-	outw(chip->cap_ctrl, FM801_REG(chip, CAP_CTRL));
+	fm801_writew(chip, CAP_CTRL, chip->cap_ctrl);
 	spin_unlock(&chip->reg_lock);
 	return 0;
 }
@@ -457,12 +459,13 @@ static int snd_fm801_playback_prepare(struct snd_pcm_substream *substream)
 	}
 	chip->ply_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;
 	chip->ply_buf = 0;
-	outw(chip->ply_ctrl, FM801_REG(chip, PLY_CTRL));
-	outw(chip->ply_count - 1, FM801_REG(chip, PLY_COUNT));
+	fm801_writew(chip, PLY_CTRL, chip->ply_ctrl);
+	fm801_writew(chip, PLY_COUNT, chip->ply_count - 1);
 	chip->ply_buffer = runtime->dma_addr;
 	chip->ply_pos = 0;
-	outl(chip->ply_buffer, FM801_REG(chip, PLY_BUF1));
-	outl(chip->ply_buffer + (chip->ply_count % chip->ply_size), FM801_REG(chip, PLY_BUF2));
+	fm801_writel(chip, PLY_BUF1, chip->ply_buffer);
+	fm801_writel(chip, PLY_BUF2,
+		     chip->ply_buffer + (chip->ply_count % chip->ply_size));
 	spin_unlock_irq(&chip->reg_lock);
 	return 0;
 }
@@ -483,12 +486,13 @@ static int snd_fm801_capture_prepare(struct snd_pcm_substream *substream)
 		chip->cap_ctrl |= FM801_STEREO;
 	chip->cap_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;
 	chip->cap_buf = 0;
-	outw(chip->cap_ctrl, FM801_REG(chip, CAP_CTRL));
-	outw(chip->cap_count - 1, FM801_REG(chip, CAP_COUNT));
+	fm801_writew(chip, CAP_CTRL, chip->cap_ctrl);
+	fm801_writew(chip, CAP_COUNT, chip->cap_count - 1);
 	chip->cap_buffer = runtime->dma_addr;
 	chip->cap_pos = 0;
-	outl(chip->cap_buffer, FM801_REG(chip, CAP_BUF1));
-	outl(chip->cap_buffer + (chip->cap_count % chip->cap_size), FM801_REG(chip, CAP_BUF2));
+	fm801_writel(chip, CAP_BUF1, chip->cap_buffer);
+	fm801_writel(chip, CAP_BUF2,
+		     chip->cap_buffer + (chip->cap_count % chip->cap_size));
 	spin_unlock_irq(&chip->reg_lock);
 	return 0;
 }
@@ -501,8 +505,8 @@ static snd_pcm_uframes_t snd_fm801_playback_pointer(struct snd_pcm_substream *su
 	if (!(chip->ply_ctrl & FM801_START))
 		return 0;
 	spin_lock(&chip->reg_lock);
-	ptr = chip->ply_pos + (chip->ply_count - 1) - inw(FM801_REG(chip, PLY_COUNT));
-	if (inw(FM801_REG(chip, IRQ_STATUS)) & FM801_IRQ_PLAYBACK) {
+	ptr = chip->ply_pos + (chip->ply_count - 1) - fm801_readw(chip, PLY_COUNT);
+	if (fm801_readw(chip, IRQ_STATUS) & FM801_IRQ_PLAYBACK) {
 		ptr += chip->ply_count;
 		ptr %= chip->ply_size;
 	}
@@ -518,8 +522,8 @@ static snd_pcm_uframes_t snd_fm801_capture_pointer(struct snd_pcm_substream *sub
 	if (!(chip->cap_ctrl & FM801_START))
 		return 0;
 	spin_lock(&chip->reg_lock);
-	ptr = chip->cap_pos + (chip->cap_count - 1) - inw(FM801_REG(chip, CAP_COUNT));
-	if (inw(FM801_REG(chip, IRQ_STATUS)) & FM801_IRQ_CAPTURE) {
+	ptr = chip->cap_pos + (chip->cap_count - 1) - fm801_readw(chip, CAP_COUNT);
+	if (fm801_readw(chip, IRQ_STATUS) & FM801_IRQ_CAPTURE) {
 		ptr += chip->cap_count;
 		ptr %= chip->cap_size;
 	}
@@ -533,12 +537,12 @@ static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id)
 	unsigned short status;
 	unsigned int tmp;
 
-	status = inw(FM801_REG(chip, IRQ_STATUS));
+	status = fm801_readw(chip, IRQ_STATUS);
 	status &= FM801_IRQ_PLAYBACK|FM801_IRQ_CAPTURE|FM801_IRQ_MPU|FM801_IRQ_VOLUME;
 	if (! status)
 		return IRQ_NONE;
 	/* ack first */
-	outw(status, FM801_REG(chip, IRQ_STATUS));
+	fm801_writew(chip, IRQ_STATUS, status);
 	if (chip->pcm && (status & FM801_IRQ_PLAYBACK) && chip->playback_substream) {
 		spin_lock(&chip->reg_lock);
 		chip->ply_buf++;
@@ -546,10 +550,10 @@ static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id)
 		chip->ply_pos %= chip->ply_size;
 		tmp = chip->ply_pos + chip->ply_count;
 		tmp %= chip->ply_size;
-		outl(chip->ply_buffer + tmp,
-				(chip->ply_buf & 1) ?
-					FM801_REG(chip, PLY_BUF1) :
-					FM801_REG(chip, PLY_BUF2));
+		if (chip->ply_buf & 1)
+			fm801_writel(chip, PLY_BUF1, chip->ply_buffer + tmp);
+		else
+			fm801_writel(chip, PLY_BUF2, chip->ply_buffer + tmp);
 		spin_unlock(&chip->reg_lock);
 		snd_pcm_period_elapsed(chip->playback_substream);
 	}
@@ -560,10 +564,10 @@ static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id)
 		chip->cap_pos %= chip->cap_size;
 		tmp = chip->cap_pos + chip->cap_count;
 		tmp %= chip->cap_size;
-		outl(chip->cap_buffer + tmp,
-				(chip->cap_buf & 1) ?
-					FM801_REG(chip, CAP_BUF1) :
-					FM801_REG(chip, CAP_BUF2));
+		if (chip->cap_buf & 1)
+			fm801_writel(chip, CAP_BUF1, chip->cap_buffer + tmp);
+		else
+			fm801_writel(chip, CAP_BUF2, chip->cap_buffer + tmp);
 		spin_unlock(&chip->reg_lock);
 		snd_pcm_period_elapsed(chip->capture_substream);
 	}
@@ -747,7 +751,7 @@ static struct snd_fm801_tea575x_gpio snd_fm801_tea575x_gpios[] = {
 static void snd_fm801_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)
 {
 	struct fm801 *chip = tea->private_data;
-	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
+	unsigned short reg = fm801_readw(chip, GPIO_CTRL);
 	struct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);
 
 	reg &= ~(FM801_GPIO_GP(gpio.data) |
@@ -759,13 +763,13 @@ static void snd_fm801_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)
 	/* WRITE_ENABLE is inverted */
 	reg |= (pins & TEA575X_WREN) ? 0 : FM801_GPIO_GP(gpio.wren);
 
-	outw(reg, FM801_REG(chip, GPIO_CTRL));
+	fm801_writew(chip, GPIO_CTRL, reg);
 }
 
 static u8 snd_fm801_tea575x_get_pins(struct snd_tea575x *tea)
 {
 	struct fm801 *chip = tea->private_data;
-	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
+	unsigned short reg = fm801_readw(chip, GPIO_CTRL);
 	struct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);
 	u8 ret;
 
@@ -780,7 +784,7 @@ static u8 snd_fm801_tea575x_get_pins(struct snd_tea575x *tea)
 static void snd_fm801_tea575x_set_direction(struct snd_tea575x *tea, bool output)
 {
 	struct fm801 *chip = tea->private_data;
-	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
+	unsigned short reg = fm801_readw(chip, GPIO_CTRL);
 	struct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);
 
 	/* use GPIO lines and set write enable bit */
@@ -811,7 +815,7 @@ static void snd_fm801_tea575x_set_direction(struct snd_tea575x *tea, bool output
 			 FM801_GPIO_GP(gpio.clk));
 	}
 
-	outw(reg, FM801_REG(chip, GPIO_CTRL));
+	fm801_writew(chip, GPIO_CTRL, reg);
 }
 
 static struct snd_tea575x_ops snd_fm801_tea_ops = {
@@ -962,7 +966,7 @@ static int snd_fm801_get_mux(struct snd_kcontrol *kcontrol,
 	struct fm801 *chip = snd_kcontrol_chip(kcontrol);
         unsigned short val;
  
-	val = inw(FM801_REG(chip, REC_SRC)) & 7;
+	val = fm801_readw(chip, REC_SRC) & 7;
 	if (val > 4)
 		val = 4;
         ucontrol->value.enumerated.item[0] = val;
@@ -1073,12 +1077,12 @@ static int wait_for_codec(struct fm801 *chip, unsigned int codec_id,
 {
 	unsigned long timeout = jiffies + waits;
 
-	outw(FM801_AC97_READ | (codec_id << FM801_AC97_ADDR_SHIFT) | reg,
-	     FM801_REG(chip, AC97_CMD));
+	fm801_writew(chip, AC97_CMD,
+		     reg | (codec_id << FM801_AC97_ADDR_SHIFT) | FM801_AC97_READ);
 	udelay(5);
 	do {
-		if ((inw(FM801_REG(chip, AC97_CMD)) & (FM801_AC97_VALID|FM801_AC97_BUSY))
-		    == FM801_AC97_VALID)
+		if ((fm801_readw(chip, AC97_CMD) &
+		     (FM801_AC97_VALID | FM801_AC97_BUSY)) == FM801_AC97_VALID)
 			return 0;
 		schedule_timeout_uninterruptible(1);
 	} while (time_after(timeout, jiffies));
@@ -1093,10 +1097,10 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 		goto __ac97_ok;
 
 	/* codec cold reset + AC'97 warm reset */
-	outw((1<<5) | (1<<6), FM801_REG(chip, CODEC_CTRL));
-	inw(FM801_REG(chip, CODEC_CTRL)); /* flush posting data */
+	fm801_writew(chip, CODEC_CTRL, (1 << 5) | (1 << 6));
+	fm801_readw(chip, CODEC_CTRL); /* flush posting data */
 	udelay(100);
-	outw(0, FM801_REG(chip, CODEC_CTRL));
+	fm801_writew(chip, CODEC_CTRL, 0);
 
 	if (wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750)) < 0)
 		if (!resume) {
@@ -1117,7 +1121,7 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 			for (i = 3; i > 0; i--) {
 				if (!wait_for_codec(chip, i, AC97_VENDOR_ID1,
 						     msecs_to_jiffies(50))) {
-					cmdw = inw(FM801_REG(chip, AC97_DATA));
+					cmdw = fm801_readw(chip, AC97_DATA);
 					if (cmdw != 0xffff && cmdw != 0) {
 						chip->secondary = 1;
 						chip->secondary_addr = i;
@@ -1135,23 +1139,24 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
       __ac97_ok:
 
 	/* init volume */
-	outw(0x0808, FM801_REG(chip, PCM_VOL));
-	outw(0x9f1f, FM801_REG(chip, FM_VOL));
-	outw(0x8808, FM801_REG(chip, I2S_VOL));
+	fm801_writew(chip, PCM_VOL, 0x0808);
+	fm801_writew(chip, FM_VOL, 0x9f1f);
+	fm801_writew(chip, I2S_VOL, 0x8808);
 
 	/* I2S control - I2S mode */
-	outw(0x0003, FM801_REG(chip, I2S_MODE));
+	fm801_writew(chip, I2S_MODE, 0x0003);
 
 	/* interrupt setup */
-	cmdw = inw(FM801_REG(chip, IRQ_MASK));
+	cmdw = fm801_readw(chip, IRQ_MASK);
 	if (chip->irq < 0)
 		cmdw |= 0x00c3;		/* mask everything, no PCM nor MPU */
 	else
 		cmdw &= ~0x0083;	/* unmask MPU, PLAYBACK & CAPTURE */
-	outw(cmdw, FM801_REG(chip, IRQ_MASK));
+	fm801_writew(chip, IRQ_MASK, cmdw);
 
 	/* interrupt clear */
-	outw(FM801_IRQ_PLAYBACK|FM801_IRQ_CAPTURE|FM801_IRQ_MPU, FM801_REG(chip, IRQ_STATUS));
+	fm801_writew(chip, IRQ_STATUS,
+		     FM801_IRQ_PLAYBACK | FM801_IRQ_CAPTURE | FM801_IRQ_MPU);
 
 	return 0;
 }
@@ -1165,9 +1170,9 @@ static int snd_fm801_free(struct fm801 *chip)
 		goto __end_hw;
 
 	/* interrupt setup - mask everything */
-	cmdw = inw(FM801_REG(chip, IRQ_MASK));
+	cmdw = fm801_readw(chip, IRQ_MASK);
 	cmdw |= 0x00c3;
-	outw(cmdw, FM801_REG(chip, IRQ_MASK));
+	fm801_writew(chip, IRQ_MASK, cmdw);
 
       __end_hw:
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
@@ -1339,15 +1344,15 @@ static int snd_card_fm801_probe(struct pci_dev *pci,
 		return err;
 	}
 	if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_FM801,
-				       FM801_REG(chip, MPU401_DATA),
+				       chip->port + FM801_MPU401_DATA,
 				       MPU401_INFO_INTEGRATED |
 				       MPU401_INFO_IRQ_HOOK,
 				       -1, &chip->rmidi)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
-	if ((err = snd_opl3_create(card, FM801_REG(chip, OPL3_BANK0),
-				   FM801_REG(chip, OPL3_BANK1),
+	if ((err = snd_opl3_create(card, chip->port + FM801_OPL3_BANK0,
+				   chip->port + FM801_OPL3_BANK1,
 				   OPL3_HW_OPL3_FM801, 1, &opl3)) < 0) {
 		snd_card_free(card);
 		return err;

commit 9c7f9abf62169bb6546faeb61846bdfca63673bd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 14:31:35 2014 +0100

    ALSA: fm801: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 8b6af212cbfe..db18ccabadd6 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -254,7 +254,7 @@ static void snd_fm801_codec_write(struct snd_ac97 *ac97,
 			goto ok1;
 		udelay(10);
 	}
-	snd_printk(KERN_ERR "AC'97 interface is busy (1)\n");
+	dev_err(chip->card->dev, "AC'97 interface is busy (1)\n");
 	return;
 
  ok1:
@@ -269,7 +269,7 @@ static void snd_fm801_codec_write(struct snd_ac97 *ac97,
 			return;
 		udelay(10);
 	}
-	snd_printk(KERN_ERR "AC'97 interface #%d is busy (2)\n", ac97->num);
+	dev_err(chip->card->dev, "AC'97 interface #%d is busy (2)\n", ac97->num);
 }
 
 static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short reg)
@@ -285,7 +285,7 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 			goto ok1;
 		udelay(10);
 	}
-	snd_printk(KERN_ERR "AC'97 interface is busy (1)\n");
+	dev_err(chip->card->dev, "AC'97 interface is busy (1)\n");
 	return 0;
 
  ok1:
@@ -297,7 +297,7 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 			goto ok2;
 		udelay(10);
 	}
-	snd_printk(KERN_ERR "AC'97 interface #%d is busy (2)\n", ac97->num);
+	dev_err(chip->card->dev, "AC'97 interface #%d is busy (2)\n", ac97->num);
 	return 0;
 
  ok2:
@@ -306,7 +306,7 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 			goto ok3;
 		udelay(10);
 	}
-	snd_printk(KERN_ERR "AC'97 interface #%d is not valid (2)\n", ac97->num);
+	dev_err(chip->card->dev, "AC'97 interface #%d is not valid (2)\n", ac97->num);
 	return 0;
 
  ok3:
@@ -1100,8 +1100,8 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 
 	if (wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750)) < 0)
 		if (!resume) {
-			snd_printk(KERN_INFO "Primary AC'97 codec not found, "
-					    "assume SF64-PCR (tuner-only)\n");
+			dev_info(chip->card->dev,
+				 "Primary AC'97 codec not found, assume SF64-PCR (tuner-only)\n");
 			chip->tea575x_tuner = 3 | TUNER_ONLY;
 			goto __ac97_ok;
 		}
@@ -1225,7 +1225,7 @@ static int snd_fm801_create(struct snd_card *card,
 	if ((tea575x_tuner & TUNER_ONLY) == 0) {
 		if (request_irq(pci->irq, snd_fm801_interrupt, IRQF_SHARED,
 				KBUILD_MODNAME, chip)) {
-			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);
+			dev_err(card->dev, "unable to grab IRQ %d\n", chip->irq);
 			snd_fm801_free(chip);
 			return -EBUSY;
 		}
@@ -1265,7 +1265,7 @@ static int snd_fm801_create(struct snd_card *card,
 	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
 	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
 		if (snd_tea575x_init(&chip->tea, THIS_MODULE)) {
-			snd_printk(KERN_ERR "TEA575x radio not found\n");
+			dev_err(card->dev, "TEA575x radio not found\n");
 			snd_fm801_free(chip);
 			return -ENODEV;
 		}
@@ -1274,13 +1274,14 @@ static int snd_fm801_create(struct snd_card *card,
 		for (tea575x_tuner = 1; tea575x_tuner <= 3; tea575x_tuner++) {
 			chip->tea575x_tuner = tea575x_tuner;
 			if (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {
-				snd_printk(KERN_INFO "detected TEA575x radio type %s\n",
+				dev_info(card->dev,
+					 "detected TEA575x radio type %s\n",
 					   get_tea575x_gpio(chip)->name);
 				break;
 			}
 		}
 		if (tea575x_tuner == 4) {
-			snd_printk(KERN_ERR "TEA575x radio not found\n");
+			dev_err(card->dev, "TEA575x radio not found\n");
 			chip->tea575x_tuner = TUNER_DISABLED;
 		}
 	}
@@ -1410,8 +1411,7 @@ static int snd_fm801_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "fm801: pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 45bc8a95b7c4..8b6af212cbfe 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1251,8 +1251,6 @@ static int snd_fm801_create(struct snd_card *card,
 		return err;
 	}
 
-	snd_card_set_dev(card, &pci->dev);
-
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
 	err = v4l2_device_register(&pci->dev, &chip->v4l2_dev);
 	if (err < 0) {
@@ -1312,7 +1310,8 @@ static int snd_card_fm801_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 	if (err < 0)
 		return err;
 	if ((err = snd_fm801_create(card, pci, tea575x_tuner[dev], radio_nr[dev], &chip)) < 0) {

commit 59b564599bc66f086856b09e480f89555d47b35c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jul 28 16:01:43 2013 -0300

    [media] tea575x: Move header from sound to media
    
    Move include/sound/tea575x-tuner.h to include/media/tea575x.h and update files that include it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 706c5b67b708..45bc8a95b7c4 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -37,7 +37,7 @@
 #include <asm/io.h>
 
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
-#include <sound/tea575x-tuner.h>
+#include <media/tea575x.h>
 #endif
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 4f07fda5adf2..706c5b67b708 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1370,7 +1370,6 @@ static int snd_card_fm801_probe(struct pci_dev *pci,
 static void snd_card_fm801_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 #ifdef CONFIG_PM_SLEEP

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index c5806f89be1e..4f07fda5adf2 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -689,7 +689,7 @@ static struct snd_pcm_ops snd_fm801_capture_ops = {
 	.pointer =	snd_fm801_capture_pointer,
 };
 
-static int __devinit snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pcm ** rpcm)
+static int snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pcm **rpcm)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -984,7 +984,7 @@ static const DECLARE_TLV_DB_SCALE(db_scale_dsp, -3450, 150, 0);
 
 #define FM801_CONTROLS ARRAY_SIZE(snd_fm801_controls)
 
-static struct snd_kcontrol_new snd_fm801_controls[] __devinitdata = {
+static struct snd_kcontrol_new snd_fm801_controls[] = {
 FM801_DOUBLE_TLV("Wave Playback Volume", FM801_PCM_VOL, 0, 8, 31, 1,
 		 db_scale_dsp),
 FM801_SINGLE("Wave Playback Switch", FM801_PCM_VOL, 15, 1, 1),
@@ -1005,7 +1005,7 @@ FM801_SINGLE("FM Playback Switch", FM801_FM_VOL, 15, 1, 1),
 
 #define FM801_CONTROLS_MULTI ARRAY_SIZE(snd_fm801_controls_multi)
 
-static struct snd_kcontrol_new snd_fm801_controls_multi[] __devinitdata = {
+static struct snd_kcontrol_new snd_fm801_controls_multi[] = {
 FM801_SINGLE("AC97 2ch->4ch Copy Switch", FM801_CODEC_CTRL, 7, 1, 0),
 FM801_SINGLE("AC97 18-bit Switch", FM801_CODEC_CTRL, 10, 1, 0),
 FM801_SINGLE(SNDRV_CTL_NAME_IEC958("",CAPTURE,SWITCH), FM801_I2S_MODE, 8, 1, 0),
@@ -1030,7 +1030,7 @@ static void snd_fm801_mixer_free_ac97(struct snd_ac97 *ac97)
 	}
 }
 
-static int __devinit snd_fm801_mixer(struct fm801 *chip)
+static int snd_fm801_mixer(struct fm801 *chip)
 {
 	struct snd_ac97_template ac97;
 	unsigned int i;
@@ -1191,11 +1191,11 @@ static int snd_fm801_dev_free(struct snd_device *device)
 	return snd_fm801_free(chip);
 }
 
-static int __devinit snd_fm801_create(struct snd_card *card,
-				      struct pci_dev * pci,
-				      int tea575x_tuner,
-				      int radio_nr,
-				      struct fm801 ** rchip)
+static int snd_fm801_create(struct snd_card *card,
+			    struct pci_dev *pci,
+			    int tea575x_tuner,
+			    int radio_nr,
+			    struct fm801 **rchip)
 {
 	struct fm801 *chip;
 	int err;
@@ -1296,8 +1296,8 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	return 0;
 }
 
-static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
-					  const struct pci_device_id *pci_id)
+static int snd_card_fm801_probe(struct pci_dev *pci,
+				const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_card *card;
@@ -1367,7 +1367,7 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit snd_card_fm801_remove(struct pci_dev *pci)
+static void snd_card_fm801_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -1439,7 +1439,7 @@ static struct pci_driver fm801_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_fm801_ids,
 	.probe = snd_card_fm801_probe,
-	.remove = __devexit_p(snd_card_fm801_remove),
+	.remove = snd_card_fm801_remove,
 	.driver = {
 		.pm = SND_FM801_PM_OPS,
 	},

commit effded75e24c7941961d473e4f4babed4c52af3c
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Nov 14 11:23:54 2012 +0300

    ALSA: fm801: precedence bug in snd_fm801_tea575x_get_pins()
    
    There is a precedence bug because | has higher precedence than ?:.  This
    code was cut and pasted and I fixed a similar bug a few days ago.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index cc2e91d15538..c5806f89be1e 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -767,9 +767,14 @@ static u8 snd_fm801_tea575x_get_pins(struct snd_tea575x *tea)
 	struct fm801 *chip = tea->private_data;
 	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
 	struct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);
-
-	return  (reg & FM801_GPIO_GP(gpio.data)) ? TEA575X_DATA : 0 |
-		(reg & FM801_GPIO_GP(gpio.most)) ? TEA575X_MOST : 0;
+	u8 ret;
+
+	ret = 0;
+	if (reg & FM801_GPIO_GP(gpio.data))
+		ret |= TEA575X_DATA;
+	if (reg & FM801_GPIO_GP(gpio.most))
+		ret |= TEA575X_MOST;
+	return ret;
 }
 
 static void snd_fm801_tea575x_set_direction(struct snd_tea575x *tea, bool output)

commit e36e3b86c78cee9c7435eb33e0ef8a788193e812
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 3 18:01:40 2012 +0200

    ALSA: Implement channel maps for standard onboard AC97 drivers
    
    Just set the channel maps depending on the hardware availability.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index ce3e548de41d..cc2e91d15538 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -711,6 +711,13 @@ static int __devinit snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pc
 					      snd_dma_pci_data(chip->pci),
 					      chip->multichannel ? 128*1024 : 64*1024, 128*1024);
 
+	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				     snd_pcm_alt_chmaps,
+				     chip->multichannel ? 6 : 2, 0,
+				     NULL);
+	if (err < 0)
+		return err;
+
 	if (rpcm)
 		*rpcm = pcm;
 	return 0;

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 522c8706f244..ce3e548de41d 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -205,7 +205,7 @@ struct fm801 {
 	struct snd_tea575x tea;
 #endif
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	u16 saved_regs[0x20];
 #endif
 };
@@ -1361,7 +1361,7 @@ static void __devexit snd_card_fm801_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static unsigned char saved_regs[] = {
 	FM801_PCM_VOL, FM801_I2S_VOL, FM801_FM_VOL, FM801_REC_SRC,
 	FM801_PLY_CTRL, FM801_PLY_COUNT, FM801_PLY_BUF1, FM801_PLY_BUF2,
@@ -1421,7 +1421,7 @@ static SIMPLE_DEV_PM_OPS(snd_fm801_pm, snd_fm801_suspend, snd_fm801_resume);
 #define SND_FM801_PM_OPS	&snd_fm801_pm
 #else
 #define SND_FM801_PM_OPS	NULL
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 static struct pci_driver fm801_driver = {
 	.name = KBUILD_MODNAME,

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index b32e8024ea86..522c8706f244 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1369,9 +1369,10 @@ static unsigned char saved_regs[] = {
 	FM801_CODEC_CTRL, FM801_I2S_MODE, FM801_VOLUME, FM801_GEN_CTRL,
 };
 
-static int snd_fm801_suspend(struct pci_dev *pci, pm_message_t state)
+static int snd_fm801_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct fm801 *chip = card->private_data;
 	int i;
 
@@ -1385,13 +1386,14 @@ static int snd_fm801_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int snd_fm801_resume(struct pci_dev *pci)
+static int snd_fm801_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct fm801 *chip = card->private_data;
 	int i;
 
@@ -1414,17 +1416,21 @@ static int snd_fm801_resume(struct pci_dev *pci)
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
-#endif
+
+static SIMPLE_DEV_PM_OPS(snd_fm801_pm, snd_fm801_suspend, snd_fm801_resume);
+#define SND_FM801_PM_OPS	&snd_fm801_pm
+#else
+#define SND_FM801_PM_OPS	NULL
+#endif /* CONFIG_PM */
 
 static struct pci_driver fm801_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_fm801_ids,
 	.probe = snd_card_fm801_probe,
 	.remove = __devexit_p(snd_card_fm801_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_fm801_suspend,
-	.resume = snd_fm801_resume,
-#endif
+	.driver = {
+		.pm = SND_FM801_PM_OPS,
+	},
 };
 
 module_pci_driver(fm801_driver);

commit aace99e57c90353a51952e9dd1f6f110eec30d15
Merge: bbcaf4111880 099987f0aaf2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 25 14:53:09 2012 -0700

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media fixes from Mauro Carvalho Chehab.
    
    Trivial conflict due to new USB HID ID's being added next to each other
    (Baanto vs Axentia).
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (44 commits)
      [media] smia: Fix compile failures
      [media]  Fix VIDIOC_DQEVENT docbook entry
      [media] s5p-fimc: Fix control creation function
      [media] s5p-mfc: Fix checkpatch error in s5p_mfc_shm.h file
      [media] s5p-mfc: Fix setting controls
      [media] v4l/s5p-mfc: added image size align in VIDIOC_TRY_FMT
      [media] v4l/s5p-mfc: corrected encoder v4l control definitions
      [media] v4l: mem2mem_testdev: Fix race conditions in driver
      [media] s5p-mfc: Bug fix of timestamp/timecode copy mechanism
      [media] cxd2820r: Fix an incorrect modulation type bitmask
      [media] em28xx: Show a warning if the board does not support remote controls
      [media] em28xx: Add remote control support for Terratec's Cinergy HTC Stick HD
      [media] USB: Staging: media: lirc: initialize spinlocks before usage
      [media] Revert "[media] media: mx2_camera: Fix mbus format handling"
      [media] bw-qcam: driver and pixfmt documentation fixes
      [media] cx88: fix firmware load on big-endian systems
      [media] cx18: support big-endian systems
      [media] ivtv: fix support for big-endian systems
      [media] tuner-core: return the frequency range of the correct tuner
      [media] v4l2-dev.c: fix g_parm regression in determine_valid_ioctls()
      ...

commit 5daf53a6eb5c54c618c9def388d81c2769fd11a0
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat May 19 07:57:03 2012 -0300

    [media] snd_tea575x: Make the module using snd_tea575x the fops owner
    
    Before this patch the owner field of the /dev/radio# device fops was set to
    the snd-tea575x-tuner module itself. Meaning that the module which was using
    it could be rmmod-ed while the device is open, and then BAD things happen.
    
    I know, as I found out the hard way :)
    
    Note that there is no need to also somehow increase the refcount of the
    snd-tea575x-tuner module itself, since any drivers using it will have
    symbolic references to it.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    CC: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index a416ea8af3e9..5265c576a26a 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1254,7 +1254,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
 	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
 	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
-		if (snd_tea575x_init(&chip->tea)) {
+		if (snd_tea575x_init(&chip->tea, THIS_MODULE)) {
 			snd_printk(KERN_ERR "TEA575x radio not found\n");
 			snd_fm801_free(chip);
 			return -ENODEV;
@@ -1263,7 +1263,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		/* autodetect tuner connection */
 		for (tea575x_tuner = 1; tea575x_tuner <= 3; tea575x_tuner++) {
 			chip->tea575x_tuner = tea575x_tuner;
-			if (!snd_tea575x_init(&chip->tea)) {
+			if (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {
 				snd_printk(KERN_INFO "detected TEA575x radio type %s\n",
 					   get_tea575x_gpio(chip)->name);
 				break;

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index a416ea8af3e9..f69662322750 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1416,7 +1416,7 @@ static int snd_fm801_resume(struct pci_dev *pci)
 }
 #endif
 
-static struct pci_driver driver = {
+static struct pci_driver fm801_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_fm801_ids,
 	.probe = snd_card_fm801_probe,
@@ -1427,15 +1427,4 @@ static struct pci_driver driver = {
 #endif
 };
 
-static int __init alsa_card_fm801_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_fm801_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_fm801_init)
-module_exit(alsa_card_fm801_exit)
+module_pci_driver(fm801_driver);

commit d4ecc83b79cc290eadf1ffb33a589c3c72bbc295
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Feb 27 05:30:13 2012 -0300

    [media] tea575x-tuner: update to latest V4L2 framework requirements
    
    The tea575x-tuner module has been updated to use the latest V4L2 framework
    functionality. This also required changes in the drivers that rely on it.
    
    The tea575x changes are:
    
    - The drivers must provide a v4l2_device struct to the tea module.
    - The radio_nr module parameter must be part of the actual radio driver,
      and not of the tea module.
    - Changed the frequency range to the normal 76-108 MHz range instead of
      50-150.
    - Add hardware frequency seek support.
    - Fix broken rxsubchans/audmode handling.
    - The application can now select between stereo and mono.
    - Support polling for control events.
    - Add V4L2 priority handling.
    
    And radio-sf16fmr2.c now uses the isa bus kernel framework.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Thanks-to: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 9597ef1eccca..a416ea8af3e9 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -58,6 +58,7 @@ static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card
  *  High 16-bits are video (radio) device number + 1
  */
 static int tea575x_tuner[SNDRV_CARDS];
+static int radio_nr[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -1};
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the FM801 soundcard.");
@@ -67,6 +68,9 @@ module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable FM801 soundcard.");
 module_param_array(tea575x_tuner, int, NULL, 0444);
 MODULE_PARM_DESC(tea575x_tuner, "TEA575x tuner access method (0 = auto, 1 = SF256-PCS, 2=SF256-PCP, 3=SF64-PCR, 8=disable, +16=tuner-only).");
+module_param_array(radio_nr, int, NULL, 0444);
+MODULE_PARM_DESC(radio_nr, "Radio device numbers");
+
 
 #define TUNER_DISABLED		(1<<3)
 #define TUNER_ONLY		(1<<4)
@@ -197,6 +201,7 @@ struct fm801 {
 	struct snd_info_entry *proc_entry;
 
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
+	struct v4l2_device v4l2_dev;
 	struct snd_tea575x tea;
 #endif
 
@@ -1154,8 +1159,10 @@ static int snd_fm801_free(struct fm801 *chip)
 
       __end_hw:
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
-	if (!(chip->tea575x_tuner & TUNER_DISABLED))
+	if (!(chip->tea575x_tuner & TUNER_DISABLED)) {
 		snd_tea575x_exit(&chip->tea);
+		v4l2_device_unregister(&chip->v4l2_dev);
+	}
 #endif
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
@@ -1175,6 +1182,7 @@ static int snd_fm801_dev_free(struct snd_device *device)
 static int __devinit snd_fm801_create(struct snd_card *card,
 				      struct pci_dev * pci,
 				      int tea575x_tuner,
+				      int radio_nr,
 				      struct fm801 ** rchip)
 {
 	struct fm801 *chip;
@@ -1234,6 +1242,13 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	snd_card_set_dev(card, &pci->dev);
 
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
+	err = v4l2_device_register(&pci->dev, &chip->v4l2_dev);
+	if (err < 0) {
+		snd_fm801_free(chip);
+		return err;
+	}
+	chip->tea.v4l2_dev = &chip->v4l2_dev;
+	chip->tea.radio_nr = radio_nr;
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_fm801_tea_ops;
 	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
@@ -1241,6 +1256,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
 		if (snd_tea575x_init(&chip->tea)) {
 			snd_printk(KERN_ERR "TEA575x radio not found\n");
+			snd_fm801_free(chip);
 			return -ENODEV;
 		}
 	} else if ((tea575x_tuner & TUNER_TYPE_MASK) == 0) {
@@ -1287,7 +1303,7 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
 	if (err < 0)
 		return err;
-	if ((err = snd_fm801_create(card, pci, tea575x_tuner[dev], &chip)) < 0) {
+	if ((err = snd_fm801_create(card, pci, tea575x_tuner[dev], radio_nr[dev], &chip)) < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index ec05ef5a5abf..9597ef1eccca 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -48,7 +48,7 @@ MODULE_SUPPORTED_DEVICE("{{ForteMedia,FM801},"
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 /*
  *  Enable TEA575x tuner
  *    1 = MediaForte 256-PCS

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 136f7232bb7c..ec05ef5a5abf 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -25,7 +25,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/tlv.h>

commit 8e699d2cc286506c00ce8ecc67c3d7d6cca9e814
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 22 16:54:23 2011 +0200

    ALSA: fm801 - Clean up redundant reference to snd_fm801_tea575x_gpios[]
    
    Use macro to improve readability.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 76465f5d9f58..136f7232bb7c 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -729,11 +729,14 @@ static struct snd_fm801_tea575x_gpio snd_fm801_tea575x_gpios[] = {
 	{ .data = 2, .clk = 0, .wren = 1, .most = 3, .name = "SF64-PCR" },
 };
 
+#define get_tea575x_gpio(chip) \
+	(&snd_fm801_tea575x_gpios[((chip)->tea575x_tuner & TUNER_TYPE_MASK) - 1])
+
 static void snd_fm801_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)
 {
 	struct fm801 *chip = tea->private_data;
 	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
-	struct snd_fm801_tea575x_gpio gpio = snd_fm801_tea575x_gpios[(chip->tea575x_tuner & TUNER_TYPE_MASK) - 1];
+	struct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);
 
 	reg &= ~(FM801_GPIO_GP(gpio.data) |
 		 FM801_GPIO_GP(gpio.clk) |
@@ -751,7 +754,7 @@ static u8 snd_fm801_tea575x_get_pins(struct snd_tea575x *tea)
 {
 	struct fm801 *chip = tea->private_data;
 	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
-	struct snd_fm801_tea575x_gpio gpio = snd_fm801_tea575x_gpios[(chip->tea575x_tuner & TUNER_TYPE_MASK) - 1];
+	struct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);
 
 	return  (reg & FM801_GPIO_GP(gpio.data)) ? TEA575X_DATA : 0 |
 		(reg & FM801_GPIO_GP(gpio.most)) ? TEA575X_MOST : 0;
@@ -761,7 +764,7 @@ static void snd_fm801_tea575x_set_direction(struct snd_tea575x *tea, bool output
 {
 	struct fm801 *chip = tea->private_data;
 	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
-	struct snd_fm801_tea575x_gpio gpio = snd_fm801_tea575x_gpios[(chip->tea575x_tuner & TUNER_TYPE_MASK) - 1];
+	struct snd_fm801_tea575x_gpio gpio = *get_tea575x_gpio(chip);
 
 	/* use GPIO lines and set write enable bit */
 	reg |= FM801_GPIO_GS(gpio.data) |
@@ -1246,7 +1249,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 			chip->tea575x_tuner = tea575x_tuner;
 			if (!snd_tea575x_init(&chip->tea)) {
 				snd_printk(KERN_INFO "detected TEA575x radio type %s\n",
-					snd_fm801_tea575x_gpios[tea575x_tuner - 1].name);
+					   get_tea575x_gpio(chip)->name);
 				break;
 			}
 		}
@@ -1256,9 +1259,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		}
 	}
 	if (!(chip->tea575x_tuner & TUNER_DISABLED)) {
-		strlcpy(chip->tea.card,
-			snd_fm801_tea575x_gpios[(tea575x_tuner &
-						 TUNER_TYPE_MASK) - 1].name,
+		strlcpy(chip->tea.card, get_tea575x_gpio(chip)->name,
 			sizeof(chip->tea.card));
 	}
 #endif

commit 272a487056ac2f39fe57fb54a55556b30c1522ba
Merge: 5495ffbd7b56 c37279b92aba
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 22 16:41:52 2011 +0200

    Merge branch 'fix/misc' into topic/misc

commit c37279b92aba2893578f61076cd2eef5c5fa0e99
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Thu Sep 22 14:39:52 2011 +0100

    ALSA: fm801: Gracefully handle failure of tuner auto-detect
    
    Commit 9676001559fce06e37c7dc230ab275f605556176
    ("ALSA: fm801: add error handling if auto-detect fails") seems to
    break systems that were previously working without a tuner.
    
    As a bonus, this should fix init and cleanup for the case where the
    tuner is explicitly disabled.
    
    Reported-and-tested-by: Hor Jiun Shyong <jiunshyong@gmail.com>
    References: http://bugs.debian.org/641946
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: stable@kernel.org [v3.0+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index a96456daf393..32b02d906703 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -68,6 +68,7 @@ MODULE_PARM_DESC(enable, "Enable FM801 soundcard.");
 module_param_array(tea575x_tuner, int, NULL, 0444);
 MODULE_PARM_DESC(tea575x_tuner, "TEA575x tuner access method (0 = auto, 1 = SF256-PCS, 2=SF256-PCP, 3=SF64-PCR, 8=disable, +16=tuner-only).");
 
+#define TUNER_DISABLED		(1<<3)
 #define TUNER_ONLY		(1<<4)
 #define TUNER_TYPE_MASK		(~TUNER_ONLY & 0xFFFF)
 
@@ -1150,7 +1151,8 @@ static int snd_fm801_free(struct fm801 *chip)
 
       __end_hw:
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
-	snd_tea575x_exit(&chip->tea);
+	if (!(chip->tea575x_tuner & TUNER_DISABLED))
+		snd_tea575x_exit(&chip->tea);
 #endif
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
@@ -1250,10 +1252,15 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		}
 		if (tea575x_tuner == 4) {
 			snd_printk(KERN_ERR "TEA575x radio not found\n");
-			return -ENODEV;
+			chip->tea575x_tuner = TUNER_DISABLED;
 		}
 	}
-	strlcpy(chip->tea.card, snd_fm801_tea575x_gpios[(tea575x_tuner & TUNER_TYPE_MASK) - 1].name, sizeof(chip->tea.card));
+	if (!(chip->tea575x_tuner & TUNER_DISABLED)) {
+		strlcpy(chip->tea.card,
+			snd_fm801_tea575x_gpios[(tea575x_tuner &
+						 TUNER_TYPE_MASK) - 1].name,
+			sizeof(chip->tea.card));
+	}
 #endif
 
 	*rchip = chip;

commit 2ba34e43ba0469086d1ff81c13a9aa9070c1a0e1
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Thu Sep 22 14:38:58 2011 +0100

    ALSA: fm801: Fix double free in case of error in tuner detection
    
    Commit 9676001559fce06e37c7dc230ab275f605556176
    ("ALSA: fm801: add error handling if auto-detect fails") added
    incorrect error handling.
    
    Once we have successfully called snd_device_new(), the cleanup
    function fm801_free() will automatically be called by snd_card_free()
    and we must *not* also call fm801_free() directly.
    
    Reported-by: Hor Jiun Shyong <jiunshyong@gmail.com>
    References: http://bugs.debian.org/641946
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: stable@kernel.org [v3.0+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index f9123f09e83e..a96456daf393 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1236,7 +1236,6 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
 		if (snd_tea575x_init(&chip->tea)) {
 			snd_printk(KERN_ERR "TEA575x radio not found\n");
-			snd_fm801_free(chip);
 			return -ENODEV;
 		}
 	} else if ((tea575x_tuner & TUNER_TYPE_MASK) == 0) {
@@ -1251,7 +1250,6 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		}
 		if (tea575x_tuner == 4) {
 			snd_printk(KERN_ERR "TEA575x radio not found\n");
-			snd_fm801_free(chip);
 			return -ENODEV;
 		}
 	}

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index f9123f09e83e..c55b1b319b74 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1306,8 +1306,9 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 	}
 	if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_FM801,
 				       FM801_REG(chip, MPU401_DATA),
-				       MPU401_INFO_INTEGRATED,
-				       chip->irq, 0, &chip->rmidi)) < 0) {
+				       MPU401_INFO_INTEGRATED |
+				       MPU401_INFO_IRQ_HOOK,
+				       -1, &chip->rmidi)) < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index db3963c4bf88..f9123f09e83e 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1199,7 +1199,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	chip->port = pci_resource_start(pci, 0);
 	if ((tea575x_tuner & TUNER_ONLY) == 0) {
 		if (request_irq(pci->irq, snd_fm801_interrupt, IRQF_SHARED,
-				"FM801", chip)) {
+				KBUILD_MODNAME, chip)) {
 			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);
 			snd_fm801_free(chip);
 			return -EBUSY;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index a7ec7030cf87..db3963c4bf88 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1394,7 +1394,7 @@ static int snd_fm801_resume(struct pci_dev *pci)
 #endif
 
 static struct pci_driver driver = {
-	.name = "FM801",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_fm801_ids,
 	.probe = snd_card_fm801_probe,
 	.remove = __devexit_p(snd_card_fm801_remove),

commit 9676001559fce06e37c7dc230ab275f605556176
Author: Dan Carpenter <error27@gmail.com>
Date:   Thu May 26 11:47:35 2011 +0300

    ALSA: fm801: add error handling if auto-detect fails
    
    In the original code if auto detect failed and tea575x_tuner == 4
    then we copy bogus information to chip->tea.card.  I've changed the
    autodetect code to cleanup and return -ENODEV on error instead.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index eacd4901a308..a7ec7030cf87 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1234,9 +1234,12 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
 	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
 	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
-		if (snd_tea575x_init(&chip->tea))
+		if (snd_tea575x_init(&chip->tea)) {
 			snd_printk(KERN_ERR "TEA575x radio not found\n");
-	} else if ((tea575x_tuner & TUNER_TYPE_MASK) == 0)
+			snd_fm801_free(chip);
+			return -ENODEV;
+		}
+	} else if ((tea575x_tuner & TUNER_TYPE_MASK) == 0) {
 		/* autodetect tuner connection */
 		for (tea575x_tuner = 1; tea575x_tuner <= 3; tea575x_tuner++) {
 			chip->tea575x_tuner = tea575x_tuner;
@@ -1246,6 +1249,12 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 				break;
 			}
 		}
+		if (tea575x_tuner == 4) {
+			snd_printk(KERN_ERR "TEA575x radio not found\n");
+			snd_fm801_free(chip);
+			return -ENODEV;
+		}
+	}
 	strlcpy(chip->tea.card, snd_fm801_tea575x_gpios[(tea575x_tuner & TUNER_TYPE_MASK) - 1].name, sizeof(chip->tea.card));
 #endif
 

commit fdb62b500d27b2a2d6a111769e5c44c1c9f4d909
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sat May 14 22:51:01 2011 +0200

    ALSA: fm801: clean-up radio-related Kconfig
    
    Remove TEA575X_RADIO define from fm801.c.
    Also update Kconfig help text to include all supported cards.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 05553da2f6cf..eacd4901a308 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -38,7 +38,6 @@
 
 #ifdef CONFIG_SND_FM801_TEA575X_BOOL
 #include <sound/tea575x-tuner.h>
-#define TEA575X_RADIO 1
 #endif
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
@@ -196,7 +195,7 @@ struct fm801 {
 	spinlock_t reg_lock;
 	struct snd_info_entry *proc_entry;
 
-#ifdef TEA575X_RADIO
+#ifdef CONFIG_SND_FM801_TEA575X_BOOL
 	struct snd_tea575x tea;
 #endif
 
@@ -715,7 +714,7 @@ static int __devinit snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pc
  *  TEA5757 radio
  */
 
-#ifdef TEA575X_RADIO
+#ifdef CONFIG_SND_FM801_TEA575X_BOOL
 
 /* GPIO to TEA575x maps */
 struct snd_fm801_tea575x_gpio {
@@ -1150,7 +1149,7 @@ static int snd_fm801_free(struct fm801 *chip)
 	outw(cmdw, FM801_REG(chip, IRQ_MASK));
 
       __end_hw:
-#ifdef TEA575X_RADIO
+#ifdef CONFIG_SND_FM801_TEA575X_BOOL
 	snd_tea575x_exit(&chip->tea);
 #endif
 	if (chip->irq >= 0)
@@ -1229,7 +1228,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 
 	snd_card_set_dev(card, &pci->dev);
 
-#ifdef TEA575X_RADIO
+#ifdef CONFIG_SND_FM801_TEA575X_BOOL
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_fm801_tea_ops;
 	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));

commit 10ca72014741554ad37c149ff0d9e93c1e3d5b7d
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu May 12 22:18:22 2011 +0200

    ALSA: tea575x: use better card and bus names
    
    Provide real card and bus_info instead of hardcoded values.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index ae5c270bfa7d..05553da2f6cf 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1232,6 +1232,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 #ifdef TEA575X_RADIO
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_fm801_tea_ops;
+	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
 	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
 	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
 		if (snd_tea575x_init(&chip->tea))
@@ -1246,6 +1247,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 				break;
 			}
 		}
+	strlcpy(chip->tea.card, snd_fm801_tea575x_gpios[(tea575x_tuner & TUNER_TYPE_MASK) - 1].name, sizeof(chip->tea.card));
 #endif
 
 	*rchip = chip;

commit 3d11ba5593b801b1db85e9680d585713e6039112
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu May 12 22:18:09 2011 +0200

    ALSA: tea575x: remove unused card from struct
    
    struct snd_card *card is present in struct snd_tea575x but never used.
    Remove it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 1d4e71cc18b6..ae5c270bfa7d 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1230,7 +1230,6 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	snd_card_set_dev(card, &pci->dev);
 
 #ifdef TEA575X_RADIO
-	chip->tea.card = card;
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_fm801_tea_ops;
 	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&

commit ea27316e4cd13b25727715c0db8adb0b1661f5e7
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu May 12 22:17:56 2011 +0200

    ALSA: tea575x: remove freq_fixup from struct
    
    freq_fixup is a constant, no need to hold it in struct snd_tea575x and set in
    each driver.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 5aa3fd6f25f7..1d4e71cc18b6 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1231,7 +1231,6 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 
 #ifdef TEA575X_RADIO
 	chip->tea.card = card;
-	chip->tea.freq_fixup = 10700;
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_fm801_tea_ops;
 	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&

commit d7ba858a7f7a95d1617756a83ff0717767f624fd
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue May 10 23:24:15 2011 +0200

    ALSA: fm801: implement TEA575x tuner autodetection
    
    Autodetect TEA575x tuner connection type during init. This allows tuner to
    work out-of-the box.
    
    tea575x_tuner module parameter remains functional to force tuner type.
    
    Tested with SF256-PCP and SF64-PCR.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 1db5ead62a98..5aa3fd6f25f7 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -53,7 +53,7 @@ static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card *
 /*
  *  Enable TEA575x tuner
  *    1 = MediaForte 256-PCS
- *    2 = MediaForte 256-PCPR
+ *    2 = MediaForte 256-PCP
  *    3 = MediaForte 64-PCR
  *   16 = setup tuner only (this is additional bit), i.e. SF64-PCR FM card
  *  High 16-bits are video (radio) device number + 1
@@ -67,7 +67,7 @@ MODULE_PARM_DESC(id, "ID string for the FM801 soundcard.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable FM801 soundcard.");
 module_param_array(tea575x_tuner, int, NULL, 0444);
-MODULE_PARM_DESC(tea575x_tuner, "TEA575x tuner access method (1 = SF256-PCS, 2=SF256-PCPR, 3=SF64-PCR, +16=tuner-only).");
+MODULE_PARM_DESC(tea575x_tuner, "TEA575x tuner access method (0 = auto, 1 = SF256-PCS, 2=SF256-PCP, 3=SF64-PCR, 8=disable, +16=tuner-only).");
 
 #define TUNER_ONLY		(1<<4)
 #define TUNER_TYPE_MASK		(~TUNER_ONLY & 0xFFFF)
@@ -720,12 +720,13 @@ static int __devinit snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pc
 /* GPIO to TEA575x maps */
 struct snd_fm801_tea575x_gpio {
 	u8 data, clk, wren, most;
+	char *name;
 };
 
 static struct snd_fm801_tea575x_gpio snd_fm801_tea575x_gpios[] = {
-	{ .data = 1, .clk = 3, .wren = 2, .most = 0 },	/* SF256-PCS */
-	{ .data = 1, .clk = 0, .wren = 2, .most = 3 },	/* SF256-PCP */
-	{ .data = 2, .clk = 0, .wren = 1, .most = 3 },	/* SF64-PCR */
+	{ .data = 1, .clk = 3, .wren = 2, .most = 0, .name = "SF256-PCS" },
+	{ .data = 1, .clk = 0, .wren = 2, .most = 3, .name = "SF256-PCP" },
+	{ .data = 2, .clk = 0, .wren = 1, .most = 3, .name = "SF64-PCR" },
 };
 
 static void snd_fm801_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)
@@ -1229,14 +1230,24 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	snd_card_set_dev(card, &pci->dev);
 
 #ifdef TEA575X_RADIO
+	chip->tea.card = card;
+	chip->tea.freq_fixup = 10700;
+	chip->tea.private_data = chip;
+	chip->tea.ops = &snd_fm801_tea_ops;
 	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
 	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
-		chip->tea.card = card;
-		chip->tea.freq_fixup = 10700;
-		chip->tea.private_data = chip;
-		chip->tea.ops = &snd_fm801_tea_ops;
-		snd_tea575x_init(&chip->tea);
-	}
+		if (snd_tea575x_init(&chip->tea))
+			snd_printk(KERN_ERR "TEA575x radio not found\n");
+	} else if ((tea575x_tuner & TUNER_TYPE_MASK) == 0)
+		/* autodetect tuner connection */
+		for (tea575x_tuner = 1; tea575x_tuner <= 3; tea575x_tuner++) {
+			chip->tea575x_tuner = tea575x_tuner;
+			if (!snd_tea575x_init(&chip->tea)) {
+				snd_printk(KERN_INFO "detected TEA575x radio type %s\n",
+					snd_fm801_tea575x_gpios[tea575x_tuner - 1].name);
+				break;
+			}
+		}
 #endif
 
 	*rchip = chip;

commit 938a1566b162aa485acd8dea2ebd92d92dfa0a45
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon May 9 23:39:51 2011 +0200

    ALSA: fm801: convert TEA575x support to new interface
    
    Use common functions to access TEA575x tuner - remove original read/write
    functions and provide new pin manipulation functions instead.
    
    Also convert the original triple implementation to a simple GPIO pin map.
    
    Tested with SF256-PCP and SF64-PCR (added the GPIO pin for MO/ST signal
    for them).
    SF256-PCS untested (pin for MO/ST signal is a guess).
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index f4dc1c77202b..1db5ead62a98 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -717,308 +717,86 @@ static int __devinit snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pc
 
 #ifdef TEA575X_RADIO
 
-/* 256PCS GPIO numbers */
-#define TEA_256PCS_DATA			1
-#define TEA_256PCS_WRITE_ENABLE		2	/* inverted */
-#define TEA_256PCS_BUS_CLOCK		3
-
-static void snd_fm801_tea575x_256pcs_write(struct snd_tea575x *tea, unsigned int val)
-{
-	struct fm801 *chip = tea->private_data;
-	unsigned short reg;
-	int i = 25;
-
-	spin_lock_irq(&chip->reg_lock);
-	reg = inw(FM801_REG(chip, GPIO_CTRL));
-	/* use GPIO lines and set write enable bit */
-	reg |= FM801_GPIO_GS(TEA_256PCS_DATA) |
-	       FM801_GPIO_GS(TEA_256PCS_WRITE_ENABLE) |
-	       FM801_GPIO_GS(TEA_256PCS_BUS_CLOCK);
-	/* all of lines are in the write direction */
-	/* clear data and clock lines */
-	reg &= ~(FM801_GPIO_GD(TEA_256PCS_DATA) |
-	         FM801_GPIO_GD(TEA_256PCS_WRITE_ENABLE) |
-	         FM801_GPIO_GD(TEA_256PCS_BUS_CLOCK) |
-	         FM801_GPIO_GP(TEA_256PCS_DATA) |
-	         FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK) |
-		 FM801_GPIO_GP(TEA_256PCS_WRITE_ENABLE));
-	outw(reg, FM801_REG(chip, GPIO_CTRL));
-	udelay(1);
-
-	while (i--) {
-		if (val & (1 << i))
-			reg |= FM801_GPIO_GP(TEA_256PCS_DATA);
-		else
-			reg &= ~FM801_GPIO_GP(TEA_256PCS_DATA);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-		reg |= FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		reg &= ~FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-	}
+/* GPIO to TEA575x maps */
+struct snd_fm801_tea575x_gpio {
+	u8 data, clk, wren, most;
+};
 
-	/* and reset the write enable bit */
-	reg |= FM801_GPIO_GP(TEA_256PCS_WRITE_ENABLE) |
-	       FM801_GPIO_GP(TEA_256PCS_DATA);
-	outw(reg, FM801_REG(chip, GPIO_CTRL));
-	spin_unlock_irq(&chip->reg_lock);
-}
+static struct snd_fm801_tea575x_gpio snd_fm801_tea575x_gpios[] = {
+	{ .data = 1, .clk = 3, .wren = 2, .most = 0 },	/* SF256-PCS */
+	{ .data = 1, .clk = 0, .wren = 2, .most = 3 },	/* SF256-PCP */
+	{ .data = 2, .clk = 0, .wren = 1, .most = 3 },	/* SF64-PCR */
+};
 
-static unsigned int snd_fm801_tea575x_256pcs_read(struct snd_tea575x *tea)
+static void snd_fm801_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)
 {
 	struct fm801 *chip = tea->private_data;
-	unsigned short reg;
-	unsigned int val = 0;
-	int i;
-	
-	spin_lock_irq(&chip->reg_lock);
-	reg = inw(FM801_REG(chip, GPIO_CTRL));
-	/* use GPIO lines, set data direction to input */
-	reg |= FM801_GPIO_GS(TEA_256PCS_DATA) |
-	       FM801_GPIO_GS(TEA_256PCS_WRITE_ENABLE) |
-	       FM801_GPIO_GS(TEA_256PCS_BUS_CLOCK) |
-	       FM801_GPIO_GD(TEA_256PCS_DATA) |
-	       FM801_GPIO_GP(TEA_256PCS_DATA) |
-	       FM801_GPIO_GP(TEA_256PCS_WRITE_ENABLE);
-	/* all of lines are in the write direction, except data */
-	/* clear data, write enable and clock lines */
-	reg &= ~(FM801_GPIO_GD(TEA_256PCS_WRITE_ENABLE) |
-	         FM801_GPIO_GD(TEA_256PCS_BUS_CLOCK) |
-	         FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK));
-
-	for (i = 0; i < 24; i++) {
-		reg &= ~FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-		reg |= FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-		val <<= 1;
-		if (inw(FM801_REG(chip, GPIO_CTRL)) & FM801_GPIO_GP(TEA_256PCS_DATA))
-			val |= 1;
-	}
-
-	spin_unlock_irq(&chip->reg_lock);
-
-	return val;
-}
-
-/* 256PCPR GPIO numbers */
-#define TEA_256PCPR_BUS_CLOCK		0
-#define TEA_256PCPR_DATA		1
-#define TEA_256PCPR_WRITE_ENABLE	2	/* inverted */
+	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
+	struct snd_fm801_tea575x_gpio gpio = snd_fm801_tea575x_gpios[(chip->tea575x_tuner & TUNER_TYPE_MASK) - 1];
 
-static void snd_fm801_tea575x_256pcpr_write(struct snd_tea575x *tea, unsigned int val)
-{
-	struct fm801 *chip = tea->private_data;
-	unsigned short reg;
-	int i = 25;
+	reg &= ~(FM801_GPIO_GP(gpio.data) |
+		 FM801_GPIO_GP(gpio.clk) |
+		 FM801_GPIO_GP(gpio.wren));
 
-	spin_lock_irq(&chip->reg_lock);
-	reg = inw(FM801_REG(chip, GPIO_CTRL));
-	/* use GPIO lines and set write enable bit */
-	reg |= FM801_GPIO_GS(TEA_256PCPR_DATA) |
-	       FM801_GPIO_GS(TEA_256PCPR_WRITE_ENABLE) |
-	       FM801_GPIO_GS(TEA_256PCPR_BUS_CLOCK);
-	/* all of lines are in the write direction */
-	/* clear data and clock lines */
-	reg &= ~(FM801_GPIO_GD(TEA_256PCPR_DATA) |
-	         FM801_GPIO_GD(TEA_256PCPR_WRITE_ENABLE) |
-	         FM801_GPIO_GD(TEA_256PCPR_BUS_CLOCK) |
-	         FM801_GPIO_GP(TEA_256PCPR_DATA) |
-	         FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK) |
-		 FM801_GPIO_GP(TEA_256PCPR_WRITE_ENABLE));
-	outw(reg, FM801_REG(chip, GPIO_CTRL));
-	udelay(1);
-
-	while (i--) {
-		if (val & (1 << i))
-			reg |= FM801_GPIO_GP(TEA_256PCPR_DATA);
-		else
-			reg &= ~FM801_GPIO_GP(TEA_256PCPR_DATA);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-		reg |= FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		reg &= ~FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-	}
+	reg |= (pins & TEA575X_DATA) ? FM801_GPIO_GP(gpio.data) : 0;
+	reg |= (pins & TEA575X_CLK)  ? FM801_GPIO_GP(gpio.clk) : 0;
+	/* WRITE_ENABLE is inverted */
+	reg |= (pins & TEA575X_WREN) ? 0 : FM801_GPIO_GP(gpio.wren);
 
-	/* and reset the write enable bit */
-	reg |= FM801_GPIO_GP(TEA_256PCPR_WRITE_ENABLE) |
-	       FM801_GPIO_GP(TEA_256PCPR_DATA);
 	outw(reg, FM801_REG(chip, GPIO_CTRL));
-	spin_unlock_irq(&chip->reg_lock);
 }
 
-static unsigned int snd_fm801_tea575x_256pcpr_read(struct snd_tea575x *tea)
+static u8 snd_fm801_tea575x_get_pins(struct snd_tea575x *tea)
 {
 	struct fm801 *chip = tea->private_data;
-	unsigned short reg;
-	unsigned int val = 0;
-	int i;
-	
-	spin_lock_irq(&chip->reg_lock);
-	reg = inw(FM801_REG(chip, GPIO_CTRL));
-	/* use GPIO lines, set data direction to input */
-	reg |= FM801_GPIO_GS(TEA_256PCPR_DATA) |
-	       FM801_GPIO_GS(TEA_256PCPR_WRITE_ENABLE) |
-	       FM801_GPIO_GS(TEA_256PCPR_BUS_CLOCK) |
-	       FM801_GPIO_GD(TEA_256PCPR_DATA) |
-	       FM801_GPIO_GP(TEA_256PCPR_DATA) |
-	       FM801_GPIO_GP(TEA_256PCPR_WRITE_ENABLE);
-	/* all of lines are in the write direction, except data */
-	/* clear data, write enable and clock lines */
-	reg &= ~(FM801_GPIO_GD(TEA_256PCPR_WRITE_ENABLE) |
-	         FM801_GPIO_GD(TEA_256PCPR_BUS_CLOCK) |
-	         FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK));
-
-	for (i = 0; i < 24; i++) {
-		reg &= ~FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-		reg |= FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-		val <<= 1;
-		if (inw(FM801_REG(chip, GPIO_CTRL)) & FM801_GPIO_GP(TEA_256PCPR_DATA))
-			val |= 1;
-	}
-
-	spin_unlock_irq(&chip->reg_lock);
+	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
+	struct snd_fm801_tea575x_gpio gpio = snd_fm801_tea575x_gpios[(chip->tea575x_tuner & TUNER_TYPE_MASK) - 1];
 
-	return val;
+	return  (reg & FM801_GPIO_GP(gpio.data)) ? TEA575X_DATA : 0 |
+		(reg & FM801_GPIO_GP(gpio.most)) ? TEA575X_MOST : 0;
 }
 
-/* 64PCR GPIO numbers */
-#define TEA_64PCR_BUS_CLOCK		0
-#define TEA_64PCR_WRITE_ENABLE		1	/* inverted */
-#define TEA_64PCR_DATA			2
-
-static void snd_fm801_tea575x_64pcr_write(struct snd_tea575x *tea, unsigned int val)
+static void snd_fm801_tea575x_set_direction(struct snd_tea575x *tea, bool output)
 {
 	struct fm801 *chip = tea->private_data;
-	unsigned short reg;
-	int i = 25;
+	unsigned short reg = inw(FM801_REG(chip, GPIO_CTRL));
+	struct snd_fm801_tea575x_gpio gpio = snd_fm801_tea575x_gpios[(chip->tea575x_tuner & TUNER_TYPE_MASK) - 1];
 
-	spin_lock_irq(&chip->reg_lock);
-	reg = inw(FM801_REG(chip, GPIO_CTRL));
 	/* use GPIO lines and set write enable bit */
-	reg |= FM801_GPIO_GS(TEA_64PCR_DATA) |
-	       FM801_GPIO_GS(TEA_64PCR_WRITE_ENABLE) |
-	       FM801_GPIO_GS(TEA_64PCR_BUS_CLOCK);
-	/* all of lines are in the write direction */
-	/* clear data and clock lines */
-	reg &= ~(FM801_GPIO_GD(TEA_64PCR_DATA) |
-	         FM801_GPIO_GD(TEA_64PCR_WRITE_ENABLE) |
-	         FM801_GPIO_GD(TEA_64PCR_BUS_CLOCK) |
-	         FM801_GPIO_GP(TEA_64PCR_DATA) |
-	         FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK) |
-		 FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE));
-	outw(reg, FM801_REG(chip, GPIO_CTRL));
-	udelay(1);
-
-	while (i--) {
-		if (val & (1 << i))
-			reg |= FM801_GPIO_GP(TEA_64PCR_DATA);
-		else
-			reg &= ~FM801_GPIO_GP(TEA_64PCR_DATA);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-		reg |= FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		reg &= ~FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-	}
-
-	/* and reset the write enable bit */
-	reg |= FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE) |
-	       FM801_GPIO_GP(TEA_64PCR_DATA);
-	outw(reg, FM801_REG(chip, GPIO_CTRL));
-	spin_unlock_irq(&chip->reg_lock);
-}
-
-static unsigned int snd_fm801_tea575x_64pcr_read(struct snd_tea575x *tea)
-{
-	struct fm801 *chip = tea->private_data;
-	unsigned short reg;
-	unsigned int val = 0;
-	int i;
-	
-	spin_lock_irq(&chip->reg_lock);
-	reg = inw(FM801_REG(chip, GPIO_CTRL));
-	/* use GPIO lines, set data direction to input */
-	reg |= FM801_GPIO_GS(TEA_64PCR_DATA) |
-	       FM801_GPIO_GS(TEA_64PCR_WRITE_ENABLE) |
-	       FM801_GPIO_GS(TEA_64PCR_BUS_CLOCK) |
-	       FM801_GPIO_GD(TEA_64PCR_DATA) |
-	       FM801_GPIO_GP(TEA_64PCR_DATA) |
-	       FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE);
-	/* all of lines are in the write direction, except data */
-	/* clear data, write enable and clock lines */
-	reg &= ~(FM801_GPIO_GD(TEA_64PCR_WRITE_ENABLE) |
-	         FM801_GPIO_GD(TEA_64PCR_BUS_CLOCK) |
-	         FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK));
-
-	for (i = 0; i < 24; i++) {
-		reg &= ~FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-		reg |= FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK);
-		outw(reg, FM801_REG(chip, GPIO_CTRL));
-		udelay(1);
-		val <<= 1;
-		if (inw(FM801_REG(chip, GPIO_CTRL)) & FM801_GPIO_GP(TEA_64PCR_DATA))
-			val |= 1;
+	reg |= FM801_GPIO_GS(gpio.data) |
+	       FM801_GPIO_GS(gpio.wren) |
+	       FM801_GPIO_GS(gpio.clk) |
+	       FM801_GPIO_GS(gpio.most);
+	if (output) {
+		/* all of lines are in the write direction */
+		/* clear data and clock lines */
+		reg &= ~(FM801_GPIO_GD(gpio.data) |
+			 FM801_GPIO_GD(gpio.wren) |
+			 FM801_GPIO_GD(gpio.clk) |
+			 FM801_GPIO_GP(gpio.data) |
+			 FM801_GPIO_GP(gpio.clk) |
+			 FM801_GPIO_GP(gpio.wren));
+	} else {
+		/* use GPIO lines, set data direction to input */
+		reg |= FM801_GPIO_GD(gpio.data) |
+		       FM801_GPIO_GD(gpio.most) |
+		       FM801_GPIO_GP(gpio.data) |
+		       FM801_GPIO_GP(gpio.most) |
+		       FM801_GPIO_GP(gpio.wren);
+		/* all of lines are in the write direction, except data */
+		/* clear data, write enable and clock lines */
+		reg &= ~(FM801_GPIO_GD(gpio.wren) |
+			 FM801_GPIO_GD(gpio.clk) |
+			 FM801_GPIO_GP(gpio.clk));
 	}
 
-	spin_unlock_irq(&chip->reg_lock);
-
-	return val;
-}
-
-static void snd_fm801_tea575x_64pcr_mute(struct snd_tea575x *tea,
-					  unsigned int mute)
-{
-	struct fm801 *chip = tea->private_data;
-	unsigned short reg;
-
-	spin_lock_irq(&chip->reg_lock);
-
-	reg = inw(FM801_REG(chip, GPIO_CTRL));
-	if (mute)
-		/* 0xf800 (mute) */
-		reg &= ~FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE);
-	else
-		/* 0xf802 (unmute) */
-		reg |= FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE);
 	outw(reg, FM801_REG(chip, GPIO_CTRL));
-	udelay(1);
-
-	spin_unlock_irq(&chip->reg_lock);
 }
 
-static struct snd_tea575x_ops snd_fm801_tea_ops[3] = {
-	{
-		/* 1 = MediaForte 256-PCS */
-		.write = snd_fm801_tea575x_256pcs_write,
-		.read = snd_fm801_tea575x_256pcs_read,
-	},
-	{
-		/* 2 = MediaForte 256-PCPR */
-		.write = snd_fm801_tea575x_256pcpr_write,
-		.read = snd_fm801_tea575x_256pcpr_read,
-	},
-	{
-		/* 3 = MediaForte 64-PCR */
-		.write = snd_fm801_tea575x_64pcr_write,
-		.read = snd_fm801_tea575x_64pcr_read,
-		.mute = snd_fm801_tea575x_64pcr_mute,
-	}
+static struct snd_tea575x_ops snd_fm801_tea_ops = {
+	.set_pins = snd_fm801_tea575x_set_pins,
+	.get_pins = snd_fm801_tea575x_get_pins,
+	.set_direction = snd_fm801_tea575x_set_direction,
 };
 #endif
 
@@ -1456,7 +1234,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		chip->tea.card = card;
 		chip->tea.freq_fixup = 10700;
 		chip->tea.private_data = chip;
-		chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & TUNER_TYPE_MASK) - 1];
+		chip->tea.ops = &snd_fm801_tea_ops;
 		snd_tea575x_init(&chip->tea);
 	}
 #endif

commit f8960d61bc8ba945b07a4de1288aac5d52f8607b
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sat Mar 19 16:33:01 2011 +0100

    ALSA: tea575x-tuner: remove dev_nr
    
    Remove unused dev_nr from struct tea575x_tuner.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index e1baad74ea4b..f4dc1c77202b 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1453,7 +1453,6 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 #ifdef TEA575X_RADIO
 	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
 	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
-		chip->tea.dev_nr = tea575x_tuner >> 16;
 		chip->tea.card = card;
 		chip->tea.freq_fixup = 10700;
 		chip->tea.private_data = chip;

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 83508b3964fb..e1baad74ea4b 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -205,7 +205,7 @@ struct fm801 {
 #endif
 };
 
-static struct pci_device_id snd_fm801_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_fm801_ids) = {
 	{ 0x1319, 0x0801, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* FM801 */
 	{ 0x5213, 0x0510, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* Gallant Odyssey Sound 4 */
 	{ 0, }

commit fb716c0b7bed36064cd41d800c8f339f41adf084
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Nov 27 18:18:33 2009 +0100

    snd-fm801: autodetect SF64-PCR (tuner-only) card
    
    When primary AC97 is not found, don't fail with tons of AC97 errors.
    Assume that the card is SF64-PCR (tuner-only).
    This makes the SF64-PCR radio card work "out of the box".
    
    Also fixes a bug that can cause an oops here:
            if (tea575x_tuner > 0 && (tea575x_tuner & 0x000f) < 4) {
    when tea575x_tuner == 16, it passes this check and causes problems
    a couple lines below:
            chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & 0x000f) - 1];
    
    Tested with SF64-PCR, but I don't have any of those sound or sound+radio cards
    to test if I didn't break anything.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 60cdb9e0b68d..83508b3964fb 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -55,7 +55,7 @@ static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card *
  *    1 = MediaForte 256-PCS
  *    2 = MediaForte 256-PCPR
  *    3 = MediaForte 64-PCR
- *   16 = setup tuner only (this is additional bit), i.e. SF-64-PCR FM card
+ *   16 = setup tuner only (this is additional bit), i.e. SF64-PCR FM card
  *  High 16-bits are video (radio) device number + 1
  */
 static int tea575x_tuner[SNDRV_CARDS];
@@ -67,7 +67,10 @@ MODULE_PARM_DESC(id, "ID string for the FM801 soundcard.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable FM801 soundcard.");
 module_param_array(tea575x_tuner, int, NULL, 0444);
-MODULE_PARM_DESC(tea575x_tuner, "Enable TEA575x tuner.");
+MODULE_PARM_DESC(tea575x_tuner, "TEA575x tuner access method (1 = SF256-PCS, 2=SF256-PCPR, 3=SF64-PCR, +16=tuner-only).");
+
+#define TUNER_ONLY		(1<<4)
+#define TUNER_TYPE_MASK		(~TUNER_ONLY & 0xFFFF)
 
 /*
  *  Direct registers
@@ -160,7 +163,7 @@ struct fm801 {
 	unsigned int multichannel: 1,	/* multichannel support */
 		     secondary: 1;	/* secondary codec */
 	unsigned char secondary_addr;	/* address of the secondary codec */
-	unsigned int tea575x_tuner;	/* tuner flags */
+	unsigned int tea575x_tuner;	/* tuner access method & flags */
 
 	unsigned short ply_ctrl; /* playback control */
 	unsigned short cap_ctrl; /* capture control */
@@ -1287,7 +1290,7 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 {
 	unsigned short cmdw;
 
-	if (chip->tea575x_tuner & 0x0010)
+	if (chip->tea575x_tuner & TUNER_ONLY)
 		goto __ac97_ok;
 
 	/* codec cold reset + AC'97 warm reset */
@@ -1296,11 +1299,13 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 	udelay(100);
 	outw(0, FM801_REG(chip, CODEC_CTRL));
 
-	if (wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750)) < 0) {
-		snd_printk(KERN_ERR "Primary AC'97 codec not found\n");
-		if (! resume)
-			return -EIO;
-	}
+	if (wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750)) < 0)
+		if (!resume) {
+			snd_printk(KERN_INFO "Primary AC'97 codec not found, "
+					    "assume SF64-PCR (tuner-only)\n");
+			chip->tea575x_tuner = 3 | TUNER_ONLY;
+			goto __ac97_ok;
+		}
 
 	if (chip->multichannel) {
 		if (chip->secondary_addr) {
@@ -1414,7 +1419,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		return err;
 	}
 	chip->port = pci_resource_start(pci, 0);
-	if ((tea575x_tuner & 0x0010) == 0) {
+	if ((tea575x_tuner & TUNER_ONLY) == 0) {
 		if (request_irq(pci->irq, snd_fm801_interrupt, IRQF_SHARED,
 				"FM801", chip)) {
 			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);
@@ -1429,6 +1434,14 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		chip->multichannel = 1;
 
 	snd_fm801_chip_init(chip, 0);
+	/* init might set tuner access method */
+	tea575x_tuner = chip->tea575x_tuner;
+
+	if (chip->irq >= 0 && (tea575x_tuner & TUNER_ONLY)) {
+		pci_clear_master(pci);
+		free_irq(chip->irq, chip);
+		chip->irq = -1;
+	}
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_fm801_free(chip);
@@ -1438,12 +1451,13 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	snd_card_set_dev(card, &pci->dev);
 
 #ifdef TEA575X_RADIO
-	if (tea575x_tuner > 0 && (tea575x_tuner & 0x000f) < 4) {
+	if ((tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
+	    (tea575x_tuner & TUNER_TYPE_MASK) < 4) {
 		chip->tea.dev_nr = tea575x_tuner >> 16;
 		chip->tea.card = card;
 		chip->tea.freq_fixup = 10700;
 		chip->tea.private_data = chip;
-		chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & 0x000f) - 1];
+		chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & TUNER_TYPE_MASK) - 1];
 		snd_tea575x_init(&chip->tea);
 	}
 #endif
@@ -1483,7 +1497,7 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 	sprintf(card->longname, "%s at 0x%lx, irq %i",
 		card->shortname, chip->port, chip->irq);
 
-	if (tea575x_tuner[dev] & 0x0010)
+	if (chip->tea575x_tuner & TUNER_ONLY)
 		goto __fm801_tuner_only;
 
 	if ((err = snd_fm801_pcm(chip, 0, NULL)) < 0) {

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index c129f9e2072c..60cdb9e0b68d 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1468,9 +1468,9 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 	if ((err = snd_fm801_create(card, pci, tea575x_tuner[dev], &chip)) < 0) {
 		snd_card_free(card);
 		return err;

commit 58e4334e82c0f4eb0147a905a127bd14f0ea0a2d
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Feb 28 11:55:07 2008 +0100

    [ALSA] sound: fm801.c fix shadowed variable warning
    
    id was only used as a counter in a for loop, move the declaration
    to where it is used and change it to i.
    sound/pci/fm801.c:1288:6: warning: symbol 'id' shadows an earlier one
    sound/pci/fm801.c:51:13: originally declared here
    
    [tiwai - fixed a coding style issue as well]
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 4c300e6149fc..c129f9e2072c 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1285,7 +1285,6 @@ static int wait_for_codec(struct fm801 *chip, unsigned int codec_id,
 
 static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 {
-	int id;
 	unsigned short cmdw;
 
 	if (chip->tea575x_tuner & 0x0010)
@@ -1310,13 +1309,14 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 		} else {
 			/* my card has the secondary codec */
 			/* at address #3, so the loop is inverted */
-			for (id = 3; id > 0; id--) {
-				if (! wait_for_codec(chip, id, AC97_VENDOR_ID1,
+			int i;
+			for (i = 3; i > 0; i--) {
+				if (!wait_for_codec(chip, i, AC97_VENDOR_ID1,
 						     msecs_to_jiffies(50))) {
 					cmdw = inw(FM801_REG(chip, AC97_DATA));
 					if (cmdw != 0xffff && cmdw != 0) {
 						chip->secondary = 1;
-						chip->secondary_addr = id;
+						chip->secondary_addr = i;
 						break;
 					}
 				}

commit 69252128ec628e9d19739db0101e1826d993aecb
Author: Andy Shevchenko <andy@smile.org.ua>
Date:   Thu Jan 24 18:11:53 2008 +0100

    [ALSA] fm801 - Add mute support for FM-only card with FM801 PCI to tuner bridge
    
    This is improvement of the early support of the FM-only cards where the
    fm801 chip represents the PCI to tuner bridge.
    The tuner initialization isn't included the mute on as well as mute support
    via V4L request. Proposed patch should fix this at least for 64-PCR model.
    
    Signed-off-by: Andy Shevchenko <andy@smile.org.ua>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 25c1087d2c00..4c300e6149fc 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -978,6 +978,27 @@ static unsigned int snd_fm801_tea575x_64pcr_read(struct snd_tea575x *tea)
 	return val;
 }
 
+static void snd_fm801_tea575x_64pcr_mute(struct snd_tea575x *tea,
+					  unsigned int mute)
+{
+	struct fm801 *chip = tea->private_data;
+	unsigned short reg;
+
+	spin_lock_irq(&chip->reg_lock);
+
+	reg = inw(FM801_REG(chip, GPIO_CTRL));
+	if (mute)
+		/* 0xf800 (mute) */
+		reg &= ~FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE);
+	else
+		/* 0xf802 (unmute) */
+		reg |= FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE);
+	outw(reg, FM801_REG(chip, GPIO_CTRL));
+	udelay(1);
+
+	spin_unlock_irq(&chip->reg_lock);
+}
+
 static struct snd_tea575x_ops snd_fm801_tea_ops[3] = {
 	{
 		/* 1 = MediaForte 256-PCS */
@@ -993,6 +1014,7 @@ static struct snd_tea575x_ops snd_fm801_tea_ops[3] = {
 		/* 3 = MediaForte 64-PCR */
 		.write = snd_fm801_tea575x_64pcr_write,
 		.read = snd_fm801_tea575x_64pcr_read,
+		.mute = snd_fm801_tea575x_64pcr_mute,
 	}
 };
 #endif

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 9939109f05a2..25c1087d2c00 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -20,7 +20,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 11015178e207..9939109f05a2 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1,6 +1,6 @@
 /*
  *  The driver for the ForteMedia FM801 based soundcards
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *  Support FM only card by Andy Shevchenko <andy@smile.org.ua>
  *
@@ -42,7 +42,7 @@
 #define TEA575X_RADIO 1
 #endif
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("ForteMedia FM801");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{ForteMedia,FM801},"

commit 44c10138fd4bbc4b6d6bff0873c24902f2a9da65
Author: Auke Kok <auke-jan.h.kok@intel.com>
Date:   Fri Jun 8 15:46:36 2007 -0700

    PCI: Change all drivers to use pci_device->revision
    
    Instead of all drivers reading pci config space to get the revision
    ID, they can now use the pci_device->revision member.
    
    This exposes some issues where drivers where reading a word or a dword
    for the revision number, and adding useless error-handling around the
    read. Some drivers even just read it for no purpose of all.
    
    In devices where the revision ID is being copied over and used in what
    appears to be the equivalent of hotpath, I have left the copy code
    and the cached copy as not to influence the driver's performance.
    
    Compile tested with make all{yes,mod}config on x86_64 and i386.
    
    Signed-off-by: Auke Kok <auke-jan.h.kok@intel.com>
    Acked-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 6dc578bbeec9..11015178e207 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1369,7 +1369,6 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 				      struct fm801 ** rchip)
 {
 	struct fm801 *chip;
-	unsigned char rev;
 	int err;
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_fm801_dev_free,
@@ -1405,8 +1404,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		pci_set_master(pci);
 	}
 
-	pci_read_config_byte(pci, PCI_REVISION_ID, &rev);
-	if (rev >= 0xb1)	/* FM801-AU */
+	if (pci->revision >= 0xb1)	/* FM801-AU */
 		chip->multichannel = 1;
 
 	snd_fm801_chip_init(chip, 0);

commit 0cb29ea0d449d7c0ecc9649a08ab63476389701d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 29 15:33:49 2007 +0100

    [ALSA] Add even more 'const' to everything related to TLV
    
    Mark TLV data as 'const'
    Signed-of-by: Philipp Matthias Hahn <pmhahn@pmhahn.de>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index b7b361ce3a93..6dc578bbeec9 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1157,7 +1157,7 @@ static int snd_fm801_put_mux(struct snd_kcontrol *kcontrol,
 	return snd_fm801_update_bits(chip, FM801_REC_SRC, 7, val);
 }
 
-static DECLARE_TLV_DB_SCALE(db_scale_dsp, -3450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_dsp, -3450, 150, 0);
 
 #define FM801_CONTROLS ARRAY_SIZE(snd_fm801_controls)
 

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 77e3d5c18302..b7b361ce3a93 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1395,7 +1395,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	}
 	chip->port = pci_resource_start(pci, 0);
 	if ((tea575x_tuner & 0x0010) == 0) {
-		if (request_irq(pci->irq, snd_fm801_interrupt, IRQF_DISABLED|IRQF_SHARED,
+		if (request_irq(pci->irq, snd_fm801_interrupt, IRQF_SHARED,
 				"FM801", chip)) {
 			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);
 			snd_fm801_free(chip);

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 3ec7d7ee04dd..77e3d5c18302 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1531,9 +1531,9 @@ static int snd_fm801_suspend(struct pci_dev *pci, pm_message_t state)
 		chip->saved_regs[i] = inw(chip->port + saved_regs[i]);
 	/* FIXME: tea575x suspend */
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1543,9 +1543,14 @@ static int snd_fm801_resume(struct pci_dev *pci)
 	struct fm801 *chip = card->private_data;
 	int i;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "fm801: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_fm801_chip_init(chip, 1);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index bdfda1997d5b..3ec7d7ee04dd 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -520,7 +520,7 @@ static snd_pcm_uframes_t snd_fm801_capture_pointer(struct snd_pcm_substream *sub
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id)
 {
 	struct fm801 *chip = dev_id;
 	unsigned short status;
@@ -561,7 +561,7 @@ static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id, struct pt_regs *re
 		snd_pcm_period_elapsed(chip->capture_substream);
 	}
 	if (chip->rmidi && (status & FM801_IRQ_MPU))
-		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
+		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
 	if (status & FM801_IRQ_VOLUME)
 		;/* TODO */
 

commit 666c70ffd1c4be795de988f26a8ab13524d4ed47
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 23 12:32:06 2006 +0200

    [ALSA] Add dB scale information to fm801 driver
    
    Added the dB scale information to fm801 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index f3f2b2c99723..bdfda1997d5b 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -29,6 +29,7 @@
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
+#include <sound/tlv.h>
 #include <sound/ac97_codec.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
@@ -1053,6 +1054,13 @@ static int snd_fm801_put_single(struct snd_kcontrol *kcontrol,
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_fm801_info_double, \
   .get = snd_fm801_get_double, .put = snd_fm801_put_double, \
   .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24) }
+#define FM801_DOUBLE_TLV(xname, reg, shift_left, shift_right, mask, invert, xtlv) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .info = snd_fm801_info_double, \
+  .get = snd_fm801_get_double, .put = snd_fm801_put_double, \
+  .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24), \
+  .tlv = { .p = (xtlv) } }
 
 static int snd_fm801_info_double(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_info *uinfo)
@@ -1149,14 +1157,19 @@ static int snd_fm801_put_mux(struct snd_kcontrol *kcontrol,
 	return snd_fm801_update_bits(chip, FM801_REC_SRC, 7, val);
 }
 
+static DECLARE_TLV_DB_SCALE(db_scale_dsp, -3450, 150, 0);
+
 #define FM801_CONTROLS ARRAY_SIZE(snd_fm801_controls)
 
 static struct snd_kcontrol_new snd_fm801_controls[] __devinitdata = {
-FM801_DOUBLE("Wave Playback Volume", FM801_PCM_VOL, 0, 8, 31, 1),
+FM801_DOUBLE_TLV("Wave Playback Volume", FM801_PCM_VOL, 0, 8, 31, 1,
+		 db_scale_dsp),
 FM801_SINGLE("Wave Playback Switch", FM801_PCM_VOL, 15, 1, 1),
-FM801_DOUBLE("I2S Playback Volume", FM801_I2S_VOL, 0, 8, 31, 1),
+FM801_DOUBLE_TLV("I2S Playback Volume", FM801_I2S_VOL, 0, 8, 31, 1,
+		 db_scale_dsp),
 FM801_SINGLE("I2S Playback Switch", FM801_I2S_VOL, 15, 1, 1),
-FM801_DOUBLE("FM Playback Volume", FM801_FM_VOL, 0, 8, 31, 1),
+FM801_DOUBLE_TLV("FM Playback Volume", FM801_FM_VOL, 0, 8, 31, 1,
+		 db_scale_dsp),
 FM801_SINGLE("FM Playback Switch", FM801_FM_VOL, 15, 1, 1),
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,

commit 5e4968e24ced93b7b130e7e1fc947a79f82776bf
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Aug 16 12:56:16 2006 +0200

    [ALSA] sound/pci/fm801: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0])
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 88a3e9f3224a..f3f2b2c99723 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -321,10 +321,8 @@ static unsigned int channels[] = {
   2, 4, 6
 };
 
-#define CHANNELS sizeof(channels) / sizeof(channels[0])
-
 static struct snd_pcm_hw_constraint_list hw_constraints_channels = {
-	.count = CHANNELS,
+	.count = ARRAY_SIZE(channels),
 	.list = channels,
 	.mask = 0,
 };

commit 6bbe13ecbbce4415a5a7959b3bc35b18313025e0
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Tue Jul 4 13:39:55 2006 +0200

    [ALSA] fm801: fixed broken previous patch for the FM tuner only code
    
    - do not allocate and enable interrupt
    - do not do the FM tuner mute (it should be handled more cleanly)
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index a30257fa6dbc..88a3e9f3224a 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -160,6 +160,7 @@ struct fm801 {
 	unsigned int multichannel: 1,	/* multichannel support */
 		     secondary: 1;	/* secondary codec */
 	unsigned char secondary_addr;	/* address of the secondary codec */
+	unsigned int tea575x_tuner;	/* tuner flags */
 
 	unsigned short ply_ctrl; /* playback control */
 	unsigned short cap_ctrl; /* capture control */
@@ -1255,7 +1256,7 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 	int id;
 	unsigned short cmdw;
 
-	if (tea575x_tuner & 0x0010)
+	if (chip->tea575x_tuner & 0x0010)
 		goto __ac97_ok;
 
 	/* codec cold reset + AC'97 warm reset */
@@ -1295,6 +1296,8 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 		wait_for_codec(chip, 0, AC97_VENDOR_ID1, msecs_to_jiffies(750));
 	}
 
+      __ac97_ok:
+
 	/* init volume */
 	outw(0x0808, FM801_REG(chip, PCM_VOL));
 	outw(0x9f1f, FM801_REG(chip, FM_VOL));
@@ -1303,9 +1306,12 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 	/* I2S control - I2S mode */
 	outw(0x0003, FM801_REG(chip, I2S_MODE));
 
-	/* interrupt setup - unmask MPU, PLAYBACK & CAPTURE */
+	/* interrupt setup */
 	cmdw = inw(FM801_REG(chip, IRQ_MASK));
-	cmdw &= ~0x0083;
+	if (chip->irq < 0)
+		cmdw |= 0x00c3;		/* mask everything, no PCM nor MPU */
+	else
+		cmdw &= ~0x0083;	/* unmask MPU, PLAYBACK & CAPTURE */
 	outw(cmdw, FM801_REG(chip, IRQ_MASK));
 
 	/* interrupt clear */
@@ -1370,20 +1376,23 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	chip->card = card;
 	chip->pci = pci;
 	chip->irq = -1;
+	chip->tea575x_tuner = tea575x_tuner;
 	if ((err = pci_request_regions(pci, "FM801")) < 0) {
 		kfree(chip);
 		pci_disable_device(pci);
 		return err;
 	}
 	chip->port = pci_resource_start(pci, 0);
-	if (request_irq(pci->irq, snd_fm801_interrupt, IRQF_DISABLED|IRQF_SHARED,
-			"FM801", chip)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);
-		snd_fm801_free(chip);
-		return -EBUSY;
+	if ((tea575x_tuner & 0x0010) == 0) {
+		if (request_irq(pci->irq, snd_fm801_interrupt, IRQF_DISABLED|IRQF_SHARED,
+				"FM801", chip)) {
+			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);
+			snd_fm801_free(chip);
+			return -EBUSY;
+		}
+		chip->irq = pci->irq;
+		pci_set_master(pci);
 	}
-	chip->irq = pci->irq;
-	pci_set_master(pci);
 
 	pci_read_config_byte(pci, PCI_REVISION_ID, &rev);
 	if (rev >= 0xb1)	/* FM801-AU */
@@ -1406,9 +1415,6 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		chip->tea.private_data = chip;
 		chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & 0x000f) - 1];
 		snd_tea575x_init(&chip->tea);
-
-		/* Mute FM tuner */
-		outw(0xf800, FM801_REG(chip, GPIO_CTRL));
 	}
 #endif
 

commit e0a5d82a966172c5f1dff6229d4a07be2222e8b3
Author: Andy Shevchenko <andy@smile.org.ua>
Date:   Tue Jul 4 12:05:14 2006 +0200

    [ALSA] fm801: Support FM only card
    
    
    Signed-off-by: Andy Shevchenko <andy@smile.org.ua>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 13868c985126..a30257fa6dbc 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -2,6 +2,7 @@
  *  The driver for the ForteMedia FM801 based soundcards
  *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
  *
+ *  Support FM only card by Andy Shevchenko <andy@smile.org.ua>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -54,6 +55,7 @@ static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card *
  *    1 = MediaForte 256-PCS
  *    2 = MediaForte 256-PCPR
  *    3 = MediaForte 64-PCR
+ *   16 = setup tuner only (this is additional bit), i.e. SF-64-PCR FM card
  *  High 16-bits are video (radio) device number + 1
  */
 static int tea575x_tuner[SNDRV_CARDS];
@@ -1253,6 +1255,9 @@ static int snd_fm801_chip_init(struct fm801 *chip, int resume)
 	int id;
 	unsigned short cmdw;
 
+	if (tea575x_tuner & 0x0010)
+		goto __ac97_ok;
+
 	/* codec cold reset + AC'97 warm reset */
 	outw((1<<5) | (1<<6), FM801_REG(chip, CODEC_CTRL));
 	inw(FM801_REG(chip, CODEC_CTRL)); /* flush posting data */
@@ -1394,13 +1399,16 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	snd_card_set_dev(card, &pci->dev);
 
 #ifdef TEA575X_RADIO
-	if (tea575x_tuner > 0 && (tea575x_tuner & 0xffff) < 4) {
+	if (tea575x_tuner > 0 && (tea575x_tuner & 0x000f) < 4) {
 		chip->tea.dev_nr = tea575x_tuner >> 16;
 		chip->tea.card = card;
 		chip->tea.freq_fixup = 10700;
 		chip->tea.private_data = chip;
-		chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & 0xffff) - 1];
+		chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & 0x000f) - 1];
 		snd_tea575x_init(&chip->tea);
+
+		/* Mute FM tuner */
+		outw(0xf800, FM801_REG(chip, GPIO_CTRL));
 	}
 #endif
 
@@ -1439,6 +1447,9 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 	sprintf(card->longname, "%s at 0x%lx, irq %i",
 		card->shortname, chip->port, chip->irq);
 
+	if (tea575x_tuner[dev] & 0x0010)
+		goto __fm801_tuner_only;
+
 	if ((err = snd_fm801_pcm(chip, 0, NULL)) < 0) {
 		snd_card_free(card);
 		return err;
@@ -1465,6 +1476,7 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 		return err;
 	}
 
+      __fm801_tuner_only:
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);
 		return err;

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 0b782e1e12f8..13868c985126 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -199,7 +199,7 @@ struct fm801 {
 #endif
 };
 
-static struct pci_device_id snd_fm801_ids[] __devinitdata = {
+static struct pci_device_id snd_fm801_ids[] = {
 	{ 0x1319, 0x0801, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* FM801 */
 	{ 0x5213, 0x0510, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* Gallant Odyssey Sound 4 */
 	{ 0, }

commit efce4bb9ecd033c9e0f221549be0098bcf6a3aad
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Jun 29 13:22:29 2006 +0200

    [ALSA] fix the SND_FM801_TEA575X dependencies
    
    CONFIG_SND_FM801=y, CONFIG_SND_FM801_TEA575X=m resulted in the following
    compile error:
    <--  snip  -->
    ...
      LD      vmlinux
    sound/built-in.o: In function 'snd_fm801_free':
    fm801.c:(.text+0x3c15b): undefined reference to 'snd_tea575x_exit'
    sound/built-in.o: In function 'snd_card_fm801_probe':
    fm801.c:(.text+0x3cfde): undefined reference to 'snd_tea575x_init'
    make: *** [vmlinux] Error 1
    <--  snip  -->
    This patch fixes kernel Bugzilla #6458.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 3aed27eace2c..0b782e1e12f8 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -35,7 +35,7 @@
 
 #include <asm/io.h>
 
-#if (defined(CONFIG_SND_FM801_TEA575X) || defined(CONFIG_SND_FM801_TEA575X_MODULE)) && (defined(CONFIG_VIDEO_DEV) || defined(CONFIG_VIDEO_DEV_MODULE))
+#ifdef CONFIG_SND_FM801_TEA575X_BOOL
 #include <sound/tea575x-tuner.h>
 #define TEA575X_RADIO 1
 #endif

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 0afa573dd244..3aed27eace2c 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1371,7 +1371,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 		return err;
 	}
 	chip->port = pci_resource_start(pci, 0);
-	if (request_irq(pci->irq, snd_fm801_interrupt, SA_INTERRUPT|SA_SHIRQ,
+	if (request_irq(pci->irq, snd_fm801_interrupt, IRQF_DISABLED|IRQF_SHARED,
 			"FM801", chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);
 		snd_fm801_free(chip);

commit 302e4c2f9e2b9f07c69649782330a61c60001ac4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 23 13:24:30 2006 +0200

    [ALSA] Change an arugment of snd_mpu401_uart_new() to bit flags
    
    Change the 5th argument of snd_mpu401_uart_new() to bit flags
    instead of a boolean.  The argument takes bits that consist of
    MPU401_INFO_XXX flags.
    The callers that used the value 1 there are replaced with
    MPU401_INFO_INTEGRATED.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 0ec90f377319..0afa573dd244 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1448,7 +1448,8 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 		return err;
 	}
 	if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_FM801,
-				       FM801_REG(chip, MPU401_DATA), 1,
+				       FM801_REG(chip, MPU401_DATA),
+				       MPU401_INFO_INTEGRATED,
 				       chip->irq, 0, &chip->rmidi)) < 0) {
 		snd_card_free(card);
 		return err;

commit 6581f4e74d8541dd7d579f64e94822622cbb1654
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 17 17:14:51 2006 +0200

    [ALSA] Remove zero-initialization of static variables
    
    Removed zero-initializations of static variables.
    A tiny optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index d72fc28c580e..0ec90f377319 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -56,7 +56,7 @@ static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card *
  *    3 = MediaForte 64-PCR
  *  High 16-bits are video (radio) device number + 1
  */
-static int tea575x_tuner[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 };
+static int tea575x_tuner[SNDRV_CARDS];
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the FM801 soundcard.");

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 6ab4aefbccf8..d72fc28c580e 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -199,7 +199,7 @@ struct fm801 {
 #endif
 };
 
-static struct pci_device_id snd_fm801_ids[] = {
+static struct pci_device_id snd_fm801_ids[] __devinitdata = {
 	{ 0x1319, 0x0801, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* FM801 */
 	{ 0x5213, 0x0510, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* Gallant Odyssey Sound 4 */
 	{ 0, }

commit b1e9ed26a9e472548a63a59014708fdae013b7a3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:14:33 2005 +0100

    [ALSA] fm801 - Add PM support
    
    Modules: FM801 driver
    
    Add PM support to fm801 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index a57aca72e91a..6ab4aefbccf8 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -103,7 +103,11 @@ MODULE_PARM_DESC(tea575x_tuner, "Enable TEA575x tuner.");
 #define FM801_OPL3_DATA1	0x6b	/* OPL3 Bank 1 Write */
 #define FM801_POWERDOWN		0x70	/* Blocks Power Down Control */
 
-#define FM801_AC97_ADDR_SHIFT	10
+/* codec access */
+#define FM801_AC97_READ		(1<<7)	/* read=1, write=0 */
+#define FM801_AC97_VALID	(1<<8)	/* port valid=1 */
+#define FM801_AC97_BUSY		(1<<9)	/* busy=1 */
+#define FM801_AC97_ADDR_SHIFT	10	/* codec id (2bit) */
 
 /* playback and record control register bits */
 #define FM801_BUF1_LAST		(1<<1)
@@ -189,6 +193,10 @@ struct fm801 {
 #ifdef TEA575X_RADIO
 	struct snd_tea575x tea;
 #endif
+
+#ifdef CONFIG_PM
+	u16 saved_regs[0x20];
+#endif
 };
 
 static struct pci_device_id snd_fm801_ids[] = {
@@ -231,7 +239,7 @@ static void snd_fm801_codec_write(struct snd_ac97 *ac97,
 	 *  Wait until the codec interface is not ready..
 	 */
 	for (idx = 0; idx < 100; idx++) {
-		if (!(inw(FM801_REG(chip, AC97_CMD)) & (1<<9)))
+		if (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))
 			goto ok1;
 		udelay(10);
 	}
@@ -246,7 +254,7 @@ static void snd_fm801_codec_write(struct snd_ac97 *ac97,
 	 *  Wait until the write command is not completed..
          */
 	for (idx = 0; idx < 1000; idx++) {
-		if (!(inw(FM801_REG(chip, AC97_CMD)) & (1<<9)))
+		if (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))
 			return;
 		udelay(10);
 	}
@@ -262,7 +270,7 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 	 *  Wait until the codec interface is not ready..
 	 */
 	for (idx = 0; idx < 100; idx++) {
-		if (!(inw(FM801_REG(chip, AC97_CMD)) & (1<<9)))
+		if (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))
 			goto ok1;
 		udelay(10);
 	}
@@ -271,9 +279,10 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 
  ok1:
 	/* read command */
-	outw(reg | (ac97->addr << FM801_AC97_ADDR_SHIFT) | (1<<7), FM801_REG(chip, AC97_CMD));
+	outw(reg | (ac97->addr << FM801_AC97_ADDR_SHIFT) | FM801_AC97_READ,
+	     FM801_REG(chip, AC97_CMD));
 	for (idx = 0; idx < 100; idx++) {
-		if (!(inw(FM801_REG(chip, AC97_CMD)) & (1<<9)))
+		if (!(inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_BUSY))
 			goto ok2;
 		udelay(10);
 	}
@@ -282,7 +291,7 @@ static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short
 
  ok2:
 	for (idx = 0; idx < 1000; idx++) {
-		if (inw(FM801_REG(chip, AC97_CMD)) & (1<<8))
+		if (inw(FM801_REG(chip, AC97_CMD)) & FM801_AC97_VALID)
 			goto ok3;
 		udelay(10);
 	}
@@ -354,9 +363,11 @@ static int snd_fm801_playback_trigger(struct snd_pcm_substream *substream,
 		chip->ply_ctrl &= ~(FM801_START | FM801_PAUSE);
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		chip->ply_ctrl |= FM801_PAUSE;
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
 		chip->ply_ctrl &= ~FM801_PAUSE;
 		break;
 	default:
@@ -387,9 +398,11 @@ static int snd_fm801_capture_trigger(struct snd_pcm_substream *substream,
 		chip->cap_ctrl &= ~(FM801_START | FM801_PAUSE);
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		chip->cap_ctrl |= FM801_PAUSE;
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
 		chip->cap_ctrl &= ~FM801_PAUSE;
 		break;
 	default:
@@ -557,7 +570,7 @@ static struct snd_pcm_hardware snd_fm801_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
-				 SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME |
 				 SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
@@ -577,7 +590,7 @@ static struct snd_pcm_hardware snd_fm801_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
-				 SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME |
 				 SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
@@ -1218,6 +1231,85 @@ static int __devinit snd_fm801_mixer(struct fm801 *chip)
  *  initialization routines
  */
 
+static int wait_for_codec(struct fm801 *chip, unsigned int codec_id,
+			  unsigned short reg, unsigned long waits)
+{
+	unsigned long timeout = jiffies + waits;
+
+	outw(FM801_AC97_READ | (codec_id << FM801_AC97_ADDR_SHIFT) | reg,
+	     FM801_REG(chip, AC97_CMD));
+	udelay(5);
+	do {
+		if ((inw(FM801_REG(chip, AC97_CMD)) & (FM801_AC97_VALID|FM801_AC97_BUSY))
+		    == FM801_AC97_VALID)
+			return 0;
+		schedule_timeout_uninterruptible(1);
+	} while (time_after(timeout, jiffies));
+	return -EIO;
+}
+
+static int snd_fm801_chip_init(struct fm801 *chip, int resume)
+{
+	int id;
+	unsigned short cmdw;
+
+	/* codec cold reset + AC'97 warm reset */
+	outw((1<<5) | (1<<6), FM801_REG(chip, CODEC_CTRL));
+	inw(FM801_REG(chip, CODEC_CTRL)); /* flush posting data */
+	udelay(100);
+	outw(0, FM801_REG(chip, CODEC_CTRL));
+
+	if (wait_for_codec(chip, 0, AC97_RESET, msecs_to_jiffies(750)) < 0) {
+		snd_printk(KERN_ERR "Primary AC'97 codec not found\n");
+		if (! resume)
+			return -EIO;
+	}
+
+	if (chip->multichannel) {
+		if (chip->secondary_addr) {
+			wait_for_codec(chip, chip->secondary_addr,
+				       AC97_VENDOR_ID1, msecs_to_jiffies(50));
+		} else {
+			/* my card has the secondary codec */
+			/* at address #3, so the loop is inverted */
+			for (id = 3; id > 0; id--) {
+				if (! wait_for_codec(chip, id, AC97_VENDOR_ID1,
+						     msecs_to_jiffies(50))) {
+					cmdw = inw(FM801_REG(chip, AC97_DATA));
+					if (cmdw != 0xffff && cmdw != 0) {
+						chip->secondary = 1;
+						chip->secondary_addr = id;
+						break;
+					}
+				}
+			}
+		}
+
+		/* the recovery phase, it seems that probing for non-existing codec might */
+		/* cause timeout problems */
+		wait_for_codec(chip, 0, AC97_VENDOR_ID1, msecs_to_jiffies(750));
+	}
+
+	/* init volume */
+	outw(0x0808, FM801_REG(chip, PCM_VOL));
+	outw(0x9f1f, FM801_REG(chip, FM_VOL));
+	outw(0x8808, FM801_REG(chip, I2S_VOL));
+
+	/* I2S control - I2S mode */
+	outw(0x0003, FM801_REG(chip, I2S_MODE));
+
+	/* interrupt setup - unmask MPU, PLAYBACK & CAPTURE */
+	cmdw = inw(FM801_REG(chip, IRQ_MASK));
+	cmdw &= ~0x0083;
+	outw(cmdw, FM801_REG(chip, IRQ_MASK));
+
+	/* interrupt clear */
+	outw(FM801_IRQ_PLAYBACK|FM801_IRQ_CAPTURE|FM801_IRQ_MPU, FM801_REG(chip, IRQ_STATUS));
+
+	return 0;
+}
+
+
 static int snd_fm801_free(struct fm801 *chip)
 {
 	unsigned short cmdw;
@@ -1255,9 +1347,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 				      struct fm801 ** rchip)
 {
 	struct fm801 *chip;
-	unsigned char rev, id;
-	unsigned short cmdw;
-	unsigned long timeout;
+	unsigned char rev;
 	int err;
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_fm801_dev_free,
@@ -1294,81 +1384,7 @@ static int __devinit snd_fm801_create(struct snd_card *card,
 	if (rev >= 0xb1)	/* FM801-AU */
 		chip->multichannel = 1;
 
-	/* codec cold reset + AC'97 warm reset */
-	outw((1<<5)|(1<<6), FM801_REG(chip, CODEC_CTRL));
-	inw(FM801_REG(chip, CODEC_CTRL)); /* flush posting data */
-	udelay(100);
-	outw(0, FM801_REG(chip, CODEC_CTRL));
-
-	timeout = (jiffies + (3 * HZ) / 4) + 1;		/* min 750ms */
-
-	outw((1<<7) | (0 << FM801_AC97_ADDR_SHIFT), FM801_REG(chip, AC97_CMD));
-	udelay(5);
-	do {
-		if ((inw(FM801_REG(chip, AC97_CMD)) & (3<<8)) == (1<<8))
-			goto __ac97_secondary;
-		schedule_timeout_uninterruptible(1);
-	} while (time_after(timeout, jiffies));
-	snd_printk(KERN_ERR "Primary AC'97 codec not found\n");
-	snd_fm801_free(chip);
-	return -EIO;
-
-      __ac97_secondary:
-      	if (!chip->multichannel)	/* lookup is not required */
-      		goto __ac97_ok;
-	for (id = 3; id > 0; id--) {	/* my card has the secondary codec */
-					/* at address #3, so the loop is inverted */
-
-		timeout = jiffies + HZ / 20;
-
-		outw((1<<7) | (id << FM801_AC97_ADDR_SHIFT) | AC97_VENDOR_ID1,
-		     FM801_REG(chip, AC97_CMD));
-		udelay(5);
-		do {
-			if ((inw(FM801_REG(chip, AC97_CMD)) & (3<<8)) == (1<<8)) {
-				cmdw = inw(FM801_REG(chip, AC97_DATA));
-				if (cmdw != 0xffff && cmdw != 0) {
-					chip->secondary = 1;
-					chip->secondary_addr = id;
-					goto __ac97_ok;
-				}
-			}
-			schedule_timeout_uninterruptible(1);
-		} while (time_after(timeout, jiffies));
-	}
-
-	/* the recovery phase, it seems that probing for non-existing codec might */
-	/* cause timeout problems */
-	timeout = (jiffies + (3 * HZ) / 4) + 1;		/* min 750ms */
-
-	outw((1<<7) | (0 << FM801_AC97_ADDR_SHIFT), FM801_REG(chip, AC97_CMD));
-	udelay(5);
-	do {
-		if ((inw(FM801_REG(chip, AC97_CMD)) & (3<<8)) == (1<<8))
-			goto __ac97_ok;
-		schedule_timeout_uninterruptible(1);
-	} while (time_after(timeout, jiffies));
-	snd_printk(KERN_ERR "Primary AC'97 codec not responding\n");
-	snd_fm801_free(chip);
-	return -EIO;
-
-      __ac97_ok:
-
-	/* init volume */
-	outw(0x0808, FM801_REG(chip, PCM_VOL));
-	outw(0x9f1f, FM801_REG(chip, FM_VOL));
-	outw(0x8808, FM801_REG(chip, I2S_VOL));
-
-	/* I2S control - I2S mode */
-	outw(0x0003, FM801_REG(chip, I2S_MODE));
-
-	/* interrupt setup - unmask MPU, PLAYBACK & CAPTURE */
-	cmdw = inw(FM801_REG(chip, IRQ_MASK));
-	cmdw &= ~0x0083;
-	outw(cmdw, FM801_REG(chip, IRQ_MASK));
-
-	/* interrupt clear */
-	outw(FM801_IRQ_PLAYBACK|FM801_IRQ_CAPTURE|FM801_IRQ_MPU, FM801_REG(chip, IRQ_STATUS));
+	snd_fm801_chip_init(chip, 0);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_fm801_free(chip);
@@ -1415,6 +1431,7 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 		snd_card_free(card);
 		return err;
 	}
+	card->private_data = chip;
 
 	strcpy(card->driver, "FM801");
 	strcpy(card->shortname, "ForteMedia FM801-");
@@ -1462,11 +1479,65 @@ static void __devexit snd_card_fm801_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
+#ifdef CONFIG_PM
+static unsigned char saved_regs[] = {
+	FM801_PCM_VOL, FM801_I2S_VOL, FM801_FM_VOL, FM801_REC_SRC,
+	FM801_PLY_CTRL, FM801_PLY_COUNT, FM801_PLY_BUF1, FM801_PLY_BUF2,
+	FM801_CAP_CTRL, FM801_CAP_COUNT, FM801_CAP_BUF1, FM801_CAP_BUF2,
+	FM801_CODEC_CTRL, FM801_I2S_MODE, FM801_VOLUME, FM801_GEN_CTRL,
+};
+
+static int snd_fm801_suspend(struct pci_dev *pci, pm_message_t state)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct fm801 *chip = card->private_data;
+	int i;
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	snd_pcm_suspend_all(chip->pcm);
+	snd_ac97_suspend(chip->ac97);
+	snd_ac97_suspend(chip->ac97_sec);
+	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
+		chip->saved_regs[i] = inw(chip->port + saved_regs[i]);
+	/* FIXME: tea575x suspend */
+
+	pci_set_power_state(pci, PCI_D3hot);
+	pci_disable_device(pci);
+	pci_save_state(pci);
+	return 0;
+}
+
+static int snd_fm801_resume(struct pci_dev *pci)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct fm801 *chip = card->private_data;
+	int i;
+
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+	pci_set_power_state(pci, PCI_D0);
+	pci_set_master(pci);
+
+	snd_fm801_chip_init(chip, 1);
+	snd_ac97_resume(chip->ac97);
+	snd_ac97_resume(chip->ac97_sec);
+	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
+		outw(chip->saved_regs[i], chip->port + saved_regs[i]);
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+}
+#endif
+
 static struct pci_driver driver = {
 	.name = "FM801",
 	.id_table = snd_fm801_ids,
 	.probe = snd_card_fm801_probe,
 	.remove = __devexit_p(snd_card_fm801_remove),
+#ifdef CONFIG_PM
+	.suspend = snd_fm801_suspend,
+	.resume = snd_fm801_resume,
+#endif
 };
 
 static int __init alsa_card_fm801_init(void)

commit a5f22156e03d40f1da24a1b19a8a84c4fb3208f2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:04:28 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI FM801
    
    Modules: FM801 driver
    
    Remove xxx_t typedefs from the PCI FM801 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 261061b76c7f..a57aca72e91a 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -147,9 +147,7 @@ MODULE_PARM_DESC(tea575x_tuner, "Enable TEA575x tuner.");
 
  */
 
-typedef struct _snd_fm801 fm801_t;
-
-struct _snd_fm801 {
+struct fm801 {
 	int irq;
 
 	unsigned long port;	/* I/O port number */
@@ -172,24 +170,24 @@ struct _snd_fm801 {
 	unsigned int cap_size;
 	unsigned int cap_pos;
 
-	ac97_bus_t *ac97_bus;
-	ac97_t *ac97;
-	ac97_t *ac97_sec;
+	struct snd_ac97_bus *ac97_bus;
+	struct snd_ac97 *ac97;
+	struct snd_ac97 *ac97_sec;
 
 	struct pci_dev *pci;
-	snd_card_t *card;
-	snd_pcm_t *pcm;
-	snd_rawmidi_t *rmidi;
-	snd_pcm_substream_t *playback_substream;
-	snd_pcm_substream_t *capture_substream;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	struct snd_rawmidi *rmidi;
+	struct snd_pcm_substream *playback_substream;
+	struct snd_pcm_substream *capture_substream;
 	unsigned int p_dma_size;
 	unsigned int c_dma_size;
 
 	spinlock_t reg_lock;
-	snd_info_entry_t *proc_entry;
+	struct snd_info_entry *proc_entry;
 
 #ifdef TEA575X_RADIO
-	tea575x_t tea;
+	struct snd_tea575x tea;
 #endif
 };
 
@@ -205,7 +203,7 @@ MODULE_DEVICE_TABLE(pci, snd_fm801_ids);
  *  common I/O routines
  */
 
-static int snd_fm801_update_bits(fm801_t *chip, unsigned short reg,
+static int snd_fm801_update_bits(struct fm801 *chip, unsigned short reg,
 				 unsigned short mask, unsigned short value)
 {
 	int change;
@@ -222,11 +220,11 @@ static int snd_fm801_update_bits(fm801_t *chip, unsigned short reg,
 	return change;
 }
 
-static void snd_fm801_codec_write(ac97_t *ac97,
+static void snd_fm801_codec_write(struct snd_ac97 *ac97,
 				  unsigned short reg,
 				  unsigned short val)
 {
-	fm801_t *chip = ac97->private_data;
+	struct fm801 *chip = ac97->private_data;
 	int idx;
 
 	/*
@@ -255,9 +253,9 @@ static void snd_fm801_codec_write(ac97_t *ac97,
 	snd_printk(KERN_ERR "AC'97 interface #%d is busy (2)\n", ac97->num);
 }
 
-static unsigned short snd_fm801_codec_read(ac97_t *ac97, unsigned short reg)
+static unsigned short snd_fm801_codec_read(struct snd_ac97 *ac97, unsigned short reg)
 {
-	fm801_t *chip = ac97->private_data;
+	struct fm801 *chip = ac97->private_data;
 	int idx;
 
 	/*
@@ -301,7 +299,7 @@ static unsigned int rates[] = {
   38400, 44100, 48000
 };
 
-static snd_pcm_hw_constraint_list_t hw_constraints_rates = {
+static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
 	.count = ARRAY_SIZE(rates),
 	.list = rates,
 	.mask = 0,
@@ -313,7 +311,7 @@ static unsigned int channels[] = {
 
 #define CHANNELS sizeof(channels) / sizeof(channels[0])
 
-static snd_pcm_hw_constraint_list_t hw_constraints_channels = {
+static struct snd_pcm_hw_constraint_list hw_constraints_channels = {
 	.count = CHANNELS,
 	.list = channels,
 	.mask = 0,
@@ -338,10 +336,10 @@ static unsigned short snd_fm801_rate_bits(unsigned int rate)
  *  PCM part
  */
 
-static int snd_fm801_playback_trigger(snd_pcm_substream_t * substream,
+static int snd_fm801_playback_trigger(struct snd_pcm_substream *substream,
 				      int cmd)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
 
 	spin_lock(&chip->reg_lock);
 	switch (cmd) {
@@ -371,10 +369,10 @@ static int snd_fm801_playback_trigger(snd_pcm_substream_t * substream,
 	return 0;
 }
 
-static int snd_fm801_capture_trigger(snd_pcm_substream_t * substream,
+static int snd_fm801_capture_trigger(struct snd_pcm_substream *substream,
 				     int cmd)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
 
 	spin_lock(&chip->reg_lock);
 	switch (cmd) {
@@ -404,21 +402,21 @@ static int snd_fm801_capture_trigger(snd_pcm_substream_t * substream,
 	return 0;
 }
 
-static int snd_fm801_hw_params(snd_pcm_substream_t * substream,
-			       snd_pcm_hw_params_t * hw_params)
+static int snd_fm801_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static int snd_fm801_hw_free(snd_pcm_substream_t * substream)
+static int snd_fm801_hw_free(struct snd_pcm_substream *substream)
 {
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static int snd_fm801_playback_prepare(snd_pcm_substream_t * substream)
+static int snd_fm801_playback_prepare(struct snd_pcm_substream *substream)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	chip->ply_size = snd_pcm_lib_buffer_bytes(substream);
 	chip->ply_count = snd_pcm_lib_period_bytes(substream);
@@ -447,10 +445,10 @@ static int snd_fm801_playback_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_fm801_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_fm801_capture_prepare(struct snd_pcm_substream *substream)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	chip->cap_size = snd_pcm_lib_buffer_bytes(substream);
 	chip->cap_count = snd_pcm_lib_period_bytes(substream);
@@ -473,9 +471,9 @@ static int snd_fm801_capture_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static snd_pcm_uframes_t snd_fm801_playback_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_fm801_playback_pointer(struct snd_pcm_substream *substream)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
 	size_t ptr;
 
 	if (!(chip->ply_ctrl & FM801_START))
@@ -490,9 +488,9 @@ static snd_pcm_uframes_t snd_fm801_playback_pointer(snd_pcm_substream_t * substr
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static snd_pcm_uframes_t snd_fm801_capture_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_fm801_capture_pointer(struct snd_pcm_substream *substream)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
 	size_t ptr;
 
 	if (!(chip->cap_ctrl & FM801_START))
@@ -509,7 +507,7 @@ static snd_pcm_uframes_t snd_fm801_capture_pointer(snd_pcm_substream_t * substre
 
 static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	fm801_t *chip = dev_id;
+	struct fm801 *chip = dev_id;
 	unsigned short status;
 	unsigned int tmp;
 
@@ -555,7 +553,7 @@ static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id, struct pt_regs *re
 	return IRQ_HANDLED;
 }
 
-static snd_pcm_hardware_t snd_fm801_playback =
+static struct snd_pcm_hardware snd_fm801_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -575,7 +573,7 @@ static snd_pcm_hardware_t snd_fm801_playback =
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_fm801_capture =
+static struct snd_pcm_hardware snd_fm801_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -595,55 +593,59 @@ static snd_pcm_hardware_t snd_fm801_capture =
 	.fifo_size =		0,
 };
 
-static int snd_fm801_playback_open(snd_pcm_substream_t * substream)
+static int snd_fm801_playback_open(struct snd_pcm_substream *substream)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 
 	chip->playback_substream = substream;
 	runtime->hw = snd_fm801_playback;
-	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				   &hw_constraints_rates);
 	if (chip->multichannel) {
 		runtime->hw.channels_max = 6;
-		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels);
+		snd_pcm_hw_constraint_list(runtime, 0,
+					   SNDRV_PCM_HW_PARAM_CHANNELS,
+					   &hw_constraints_channels);
 	}
 	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
 		return err;
 	return 0;
 }
 
-static int snd_fm801_capture_open(snd_pcm_substream_t * substream)
+static int snd_fm801_capture_open(struct snd_pcm_substream *substream)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 
 	chip->capture_substream = substream;
 	runtime->hw = snd_fm801_capture;
-	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				   &hw_constraints_rates);
 	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
 		return err;
 	return 0;
 }
 
-static int snd_fm801_playback_close(snd_pcm_substream_t * substream)
+static int snd_fm801_playback_close(struct snd_pcm_substream *substream)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
 
 	chip->playback_substream = NULL;
 	return 0;
 }
 
-static int snd_fm801_capture_close(snd_pcm_substream_t * substream)
+static int snd_fm801_capture_close(struct snd_pcm_substream *substream)
 {
-	fm801_t *chip = snd_pcm_substream_chip(substream);
+	struct fm801 *chip = snd_pcm_substream_chip(substream);
 
 	chip->capture_substream = NULL;
 	return 0;
 }
 
-static snd_pcm_ops_t snd_fm801_playback_ops = {
+static struct snd_pcm_ops snd_fm801_playback_ops = {
 	.open =		snd_fm801_playback_open,
 	.close =	snd_fm801_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -654,7 +656,7 @@ static snd_pcm_ops_t snd_fm801_playback_ops = {
 	.pointer =	snd_fm801_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_fm801_capture_ops = {
+static struct snd_pcm_ops snd_fm801_capture_ops = {
 	.open =		snd_fm801_capture_open,
 	.close =	snd_fm801_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -665,9 +667,9 @@ static snd_pcm_ops_t snd_fm801_capture_ops = {
 	.pointer =	snd_fm801_capture_pointer,
 };
 
-static int __devinit snd_fm801_pcm(fm801_t *chip, int device, snd_pcm_t ** rpcm)
+static int __devinit snd_fm801_pcm(struct fm801 *chip, int device, struct snd_pcm ** rpcm)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if (rpcm)
@@ -703,9 +705,9 @@ static int __devinit snd_fm801_pcm(fm801_t *chip, int device, snd_pcm_t ** rpcm)
 #define TEA_256PCS_WRITE_ENABLE		2	/* inverted */
 #define TEA_256PCS_BUS_CLOCK		3
 
-static void snd_fm801_tea575x_256pcs_write(tea575x_t *tea, unsigned int val)
+static void snd_fm801_tea575x_256pcs_write(struct snd_tea575x *tea, unsigned int val)
 {
-	fm801_t *chip = tea->private_data;
+	struct fm801 *chip = tea->private_data;
 	unsigned short reg;
 	int i = 25;
 
@@ -747,9 +749,9 @@ static void snd_fm801_tea575x_256pcs_write(tea575x_t *tea, unsigned int val)
 	spin_unlock_irq(&chip->reg_lock);
 }
 
-static unsigned int snd_fm801_tea575x_256pcs_read(tea575x_t *tea)
+static unsigned int snd_fm801_tea575x_256pcs_read(struct snd_tea575x *tea)
 {
-	fm801_t *chip = tea->private_data;
+	struct fm801 *chip = tea->private_data;
 	unsigned short reg;
 	unsigned int val = 0;
 	int i;
@@ -791,9 +793,9 @@ static unsigned int snd_fm801_tea575x_256pcs_read(tea575x_t *tea)
 #define TEA_256PCPR_DATA		1
 #define TEA_256PCPR_WRITE_ENABLE	2	/* inverted */
 
-static void snd_fm801_tea575x_256pcpr_write(tea575x_t *tea, unsigned int val)
+static void snd_fm801_tea575x_256pcpr_write(struct snd_tea575x *tea, unsigned int val)
 {
-	fm801_t *chip = tea->private_data;
+	struct fm801 *chip = tea->private_data;
 	unsigned short reg;
 	int i = 25;
 
@@ -835,9 +837,9 @@ static void snd_fm801_tea575x_256pcpr_write(tea575x_t *tea, unsigned int val)
 	spin_unlock_irq(&chip->reg_lock);
 }
 
-static unsigned int snd_fm801_tea575x_256pcpr_read(tea575x_t *tea)
+static unsigned int snd_fm801_tea575x_256pcpr_read(struct snd_tea575x *tea)
 {
-	fm801_t *chip = tea->private_data;
+	struct fm801 *chip = tea->private_data;
 	unsigned short reg;
 	unsigned int val = 0;
 	int i;
@@ -879,9 +881,9 @@ static unsigned int snd_fm801_tea575x_256pcpr_read(tea575x_t *tea)
 #define TEA_64PCR_WRITE_ENABLE		1	/* inverted */
 #define TEA_64PCR_DATA			2
 
-static void snd_fm801_tea575x_64pcr_write(tea575x_t *tea, unsigned int val)
+static void snd_fm801_tea575x_64pcr_write(struct snd_tea575x *tea, unsigned int val)
 {
-	fm801_t *chip = tea->private_data;
+	struct fm801 *chip = tea->private_data;
 	unsigned short reg;
 	int i = 25;
 
@@ -923,9 +925,9 @@ static void snd_fm801_tea575x_64pcr_write(tea575x_t *tea, unsigned int val)
 	spin_unlock_irq(&chip->reg_lock);
 }
 
-static unsigned int snd_fm801_tea575x_64pcr_read(tea575x_t *tea)
+static unsigned int snd_fm801_tea575x_64pcr_read(struct snd_tea575x *tea)
 {
-	fm801_t *chip = tea->private_data;
+	struct fm801 *chip = tea->private_data;
 	unsigned short reg;
 	unsigned int val = 0;
 	int i;
@@ -990,7 +992,8 @@ static struct snd_tea575x_ops snd_fm801_tea_ops[3] = {
   .get = snd_fm801_get_single, .put = snd_fm801_put_single, \
   .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
 
-static int snd_fm801_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_fm801_info_single(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
 {
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 
@@ -1001,9 +1004,10 @@ static int snd_fm801_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	return 0;
 }
 
-static int snd_fm801_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_fm801_get_single(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+	struct fm801 *chip = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
@@ -1015,9 +1019,10 @@ static int snd_fm801_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 
-static int snd_fm801_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_fm801_put_single(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+	struct fm801 *chip = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
@@ -1035,7 +1040,8 @@ static int snd_fm801_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
   .get = snd_fm801_get_double, .put = snd_fm801_put_double, \
   .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24) }
 
-static int snd_fm801_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_fm801_info_double(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
 {
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 
@@ -1046,9 +1052,10 @@ static int snd_fm801_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	return 0;
 }
 
-static int snd_fm801_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_fm801_get_double(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+	struct fm801 *chip = snd_kcontrol_chip(kcontrol);
         int reg = kcontrol->private_value & 0xff;
 	int shift_left = (kcontrol->private_value >> 8) & 0x0f;
 	int shift_right = (kcontrol->private_value >> 12) & 0x0f;
@@ -1066,9 +1073,10 @@ static int snd_fm801_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 
-static int snd_fm801_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_fm801_put_double(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+	struct fm801 *chip = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
 	int shift_left = (kcontrol->private_value >> 8) & 0x0f;
 	int shift_right = (kcontrol->private_value >> 12) & 0x0f;
@@ -1087,7 +1095,8 @@ static int snd_fm801_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 				     (val1 << shift_left ) | (val2 << shift_right));
 }
 
-static int snd_fm801_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_fm801_info_mux(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[5] = {
 		"AC97 Primary", "FM", "I2S", "PCM", "AC97 Secondary"
@@ -1102,9 +1111,10 @@ static int snd_fm801_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * ui
 	return 0;
 }
 
-static int snd_fm801_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_fm801_get_mux(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
 {
-	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+	struct fm801 *chip = snd_kcontrol_chip(kcontrol);
         unsigned short val;
  
 	val = inw(FM801_REG(chip, REC_SRC)) & 7;
@@ -1114,9 +1124,10 @@ static int snd_fm801_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * u
         return 0;
 }
 
-static int snd_fm801_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_fm801_put_mux(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
 {
-	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+	struct fm801 *chip = snd_kcontrol_chip(kcontrol);
         unsigned short val;
  
         if ((val = ucontrol->value.enumerated.item[0]) > 4)
@@ -1124,9 +1135,9 @@ static int snd_fm801_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * u
 	return snd_fm801_update_bits(chip, FM801_REC_SRC, 7, val);
 }
 
-#define FM801_CONTROLS (sizeof(snd_fm801_controls)/sizeof(snd_kcontrol_new_t))
+#define FM801_CONTROLS ARRAY_SIZE(snd_fm801_controls)
 
-static snd_kcontrol_new_t snd_fm801_controls[] __devinitdata = {
+static struct snd_kcontrol_new snd_fm801_controls[] __devinitdata = {
 FM801_DOUBLE("Wave Playback Volume", FM801_PCM_VOL, 0, 8, 31, 1),
 FM801_SINGLE("Wave Playback Switch", FM801_PCM_VOL, 15, 1, 1),
 FM801_DOUBLE("I2S Playback Volume", FM801_I2S_VOL, 0, 8, 31, 1),
@@ -1142,9 +1153,9 @@ FM801_SINGLE("FM Playback Switch", FM801_FM_VOL, 15, 1, 1),
 }
 };
 
-#define FM801_CONTROLS_MULTI (sizeof(snd_fm801_controls_multi)/sizeof(snd_kcontrol_new_t))
+#define FM801_CONTROLS_MULTI ARRAY_SIZE(snd_fm801_controls_multi)
 
-static snd_kcontrol_new_t snd_fm801_controls_multi[] __devinitdata = {
+static struct snd_kcontrol_new snd_fm801_controls_multi[] __devinitdata = {
 FM801_SINGLE("AC97 2ch->4ch Copy Switch", FM801_CODEC_CTRL, 7, 1, 0),
 FM801_SINGLE("AC97 18-bit Switch", FM801_CODEC_CTRL, 10, 1, 0),
 FM801_SINGLE(SNDRV_CTL_NAME_IEC958("",CAPTURE,SWITCH), FM801_I2S_MODE, 8, 1, 0),
@@ -1153,15 +1164,15 @@ FM801_SINGLE(SNDRV_CTL_NAME_IEC958("Raw Data ",CAPTURE,SWITCH), FM801_I2S_MODE,
 FM801_SINGLE(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH), FM801_GEN_CTRL, 2, 1, 0),
 };
 
-static void snd_fm801_mixer_free_ac97_bus(ac97_bus_t *bus)
+static void snd_fm801_mixer_free_ac97_bus(struct snd_ac97_bus *bus)
 {
-	fm801_t *chip = bus->private_data;
+	struct fm801 *chip = bus->private_data;
 	chip->ac97_bus = NULL;
 }
 
-static void snd_fm801_mixer_free_ac97(ac97_t *ac97)
+static void snd_fm801_mixer_free_ac97(struct snd_ac97 *ac97)
 {
-	fm801_t *chip = ac97->private_data;
+	struct fm801 *chip = ac97->private_data;
 	if (ac97->num == 0) {
 		chip->ac97 = NULL;
 	} else {
@@ -1169,12 +1180,12 @@ static void snd_fm801_mixer_free_ac97(ac97_t *ac97)
 	}
 }
 
-static int __devinit snd_fm801_mixer(fm801_t *chip)
+static int __devinit snd_fm801_mixer(struct fm801 *chip)
 {
-	ac97_template_t ac97;
+	struct snd_ac97_template ac97;
 	unsigned int i;
 	int err;
-	static ac97_bus_ops_t ops = {
+	static struct snd_ac97_bus_ops ops = {
 		.write = snd_fm801_codec_write,
 		.read = snd_fm801_codec_read,
 	};
@@ -1207,7 +1218,7 @@ static int __devinit snd_fm801_mixer(fm801_t *chip)
  *  initialization routines
  */
 
-static int snd_fm801_free(fm801_t *chip)
+static int snd_fm801_free(struct fm801 *chip)
 {
 	unsigned short cmdw;
 
@@ -1224,7 +1235,7 @@ static int snd_fm801_free(fm801_t *chip)
 	snd_tea575x_exit(&chip->tea);
 #endif
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 	pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
 
@@ -1232,23 +1243,23 @@ static int snd_fm801_free(fm801_t *chip)
 	return 0;
 }
 
-static int snd_fm801_dev_free(snd_device_t *device)
+static int snd_fm801_dev_free(struct snd_device *device)
 {
-	fm801_t *chip = device->device_data;
+	struct fm801 *chip = device->device_data;
 	return snd_fm801_free(chip);
 }
 
-static int __devinit snd_fm801_create(snd_card_t * card,
+static int __devinit snd_fm801_create(struct snd_card *card,
 				      struct pci_dev * pci,
 				      int tea575x_tuner,
-				      fm801_t ** rchip)
+				      struct fm801 ** rchip)
 {
-	fm801_t *chip;
+	struct fm801 *chip;
 	unsigned char rev, id;
 	unsigned short cmdw;
 	unsigned long timeout;
 	int err;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_fm801_dev_free,
 	};
 
@@ -1270,7 +1281,8 @@ static int __devinit snd_fm801_create(snd_card_t * card,
 		return err;
 	}
 	chip->port = pci_resource_start(pci, 0);
-	if (request_irq(pci->irq, snd_fm801_interrupt, SA_INTERRUPT|SA_SHIRQ, "FM801", (void *)chip)) {
+	if (request_irq(pci->irq, snd_fm801_interrupt, SA_INTERRUPT|SA_SHIRQ,
+			"FM801", chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);
 		snd_fm801_free(chip);
 		return -EBUSY;
@@ -1309,7 +1321,8 @@ static int __devinit snd_fm801_create(snd_card_t * card,
 
 		timeout = jiffies + HZ / 20;
 
-		outw((1<<7) | (id << FM801_AC97_ADDR_SHIFT) | AC97_VENDOR_ID1, FM801_REG(chip, AC97_CMD));
+		outw((1<<7) | (id << FM801_AC97_ADDR_SHIFT) | AC97_VENDOR_ID1,
+		     FM801_REG(chip, AC97_CMD));
 		udelay(5);
 		do {
 			if ((inw(FM801_REG(chip, AC97_CMD)) & (3<<8)) == (1<<8)) {
@@ -1383,9 +1396,9 @@ static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
 					  const struct pci_device_id *pci_id)
 {
 	static int dev;
-	snd_card_t *card;
-	fm801_t *chip;
-	opl3_t *opl3;
+	struct snd_card *card;
+	struct fm801 *chip;
+	struct snd_opl3 *opl3;
 	int err;
 
         if (dev >= SNDRV_CARDS)

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 4e1d3434888d..261061b76c7f 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -665,13 +665,6 @@ static snd_pcm_ops_t snd_fm801_capture_ops = {
 	.pointer =	snd_fm801_capture_pointer,
 };
 
-static void snd_fm801_pcm_free(snd_pcm_t *pcm)
-{
-	fm801_t *chip = pcm->private_data;
-	chip->pcm = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static int __devinit snd_fm801_pcm(fm801_t *chip, int device, snd_pcm_t ** rpcm)
 {
 	snd_pcm_t *pcm;
@@ -686,7 +679,6 @@ static int __devinit snd_fm801_pcm(fm801_t *chip, int device, snd_pcm_t ** rpcm)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_fm801_capture_ops);
 
 	pcm->private_data = chip;
-	pcm->private_free = snd_fm801_pcm_free;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "FM801");
 	chip->pcm = pcm;

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 4c7c8d225c7f..4e1d3434888d 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1459,7 +1459,6 @@ static void __devexit snd_card_fm801_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "FM801",
-	.owner = THIS_MODULE,
 	.id_table = snd_fm801_ids,
 	.probe = snd_card_fm801_probe,
 	.remove = __devexit_p(snd_card_fm801_remove),

commit 8433a509c0eb6bb1f33ce39c82c580b8901619ee
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Oct 24 15:02:37 2005 +0200

    [ALSA] Fix schedule_timeout usage
    
    Use schedule_timeout_{,un}interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.  Also use
    human-time conversion functions instead of hard-coded division to avoid
    rounding issues.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 47dbe317069f..4c7c8d225c7f 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1303,8 +1303,7 @@ static int __devinit snd_fm801_create(snd_card_t * card,
 	do {
 		if ((inw(FM801_REG(chip, AC97_CMD)) & (3<<8)) == (1<<8))
 			goto __ac97_secondary;
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	} while (time_after(timeout, jiffies));
 	snd_printk(KERN_ERR "Primary AC'97 codec not found\n");
 	snd_fm801_free(chip);
@@ -1329,8 +1328,7 @@ static int __devinit snd_fm801_create(snd_card_t * card,
 					goto __ac97_ok;
 				}
 			}
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_timeout_uninterruptible(1);
 		} while (time_after(timeout, jiffies));
 	}
 
@@ -1343,8 +1341,7 @@ static int __devinit snd_fm801_create(snd_card_t * card,
 	do {
 		if ((inw(FM801_REG(chip, AC97_CMD)) & (3<<8)) == (1<<8))
 			goto __ac97_ok;
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	} while (time_after(timeout, jiffies));
 	snd_printk(KERN_ERR "Primary AC'97 codec not responding\n");
 	snd_fm801_free(chip);

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index e5cfa2a0c246..47dbe317069f 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -237,7 +237,7 @@ static void snd_fm801_codec_write(ac97_t *ac97,
 			goto ok1;
 		udelay(10);
 	}
-	snd_printk("AC'97 interface is busy (1)\n");
+	snd_printk(KERN_ERR "AC'97 interface is busy (1)\n");
 	return;
 
  ok1:
@@ -252,7 +252,7 @@ static void snd_fm801_codec_write(ac97_t *ac97,
 			return;
 		udelay(10);
 	}
-	snd_printk("AC'97 interface #%d is busy (2)\n", ac97->num);
+	snd_printk(KERN_ERR "AC'97 interface #%d is busy (2)\n", ac97->num);
 }
 
 static unsigned short snd_fm801_codec_read(ac97_t *ac97, unsigned short reg)
@@ -268,7 +268,7 @@ static unsigned short snd_fm801_codec_read(ac97_t *ac97, unsigned short reg)
 			goto ok1;
 		udelay(10);
 	}
-	snd_printk("AC'97 interface is busy (1)\n");
+	snd_printk(KERN_ERR "AC'97 interface is busy (1)\n");
 	return 0;
 
  ok1:
@@ -279,7 +279,7 @@ static unsigned short snd_fm801_codec_read(ac97_t *ac97, unsigned short reg)
 			goto ok2;
 		udelay(10);
 	}
-	snd_printk("AC'97 interface #%d is busy (2)\n", ac97->num);
+	snd_printk(KERN_ERR "AC'97 interface #%d is busy (2)\n", ac97->num);
 	return 0;
 
  ok2:
@@ -288,7 +288,7 @@ static unsigned short snd_fm801_codec_read(ac97_t *ac97, unsigned short reg)
 			goto ok3;
 		udelay(10);
 	}
-	snd_printk("AC'97 interface #%d is not valid (2)\n", ac97->num);
+	snd_printk(KERN_ERR "AC'97 interface #%d is not valid (2)\n", ac97->num);
 	return 0;
 
  ok3:
@@ -1279,7 +1279,7 @@ static int __devinit snd_fm801_create(snd_card_t * card,
 	}
 	chip->port = pci_resource_start(pci, 0);
 	if (request_irq(pci->irq, snd_fm801_interrupt, SA_INTERRUPT|SA_SHIRQ, "FM801", (void *)chip)) {
-		snd_printk("unable to grab IRQ %d\n", chip->irq);
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->irq);
 		snd_fm801_free(chip);
 		return -EBUSY;
 	}
@@ -1306,7 +1306,7 @@ static int __devinit snd_fm801_create(snd_card_t * card,
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(1);
 	} while (time_after(timeout, jiffies));
-	snd_printk("Primary AC'97 codec not found\n");
+	snd_printk(KERN_ERR "Primary AC'97 codec not found\n");
 	snd_fm801_free(chip);
 	return -EIO;
 
@@ -1346,7 +1346,7 @@ static int __devinit snd_fm801_create(snd_card_t * card,
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(1);
 	} while (time_after(timeout, jiffies));
-	snd_printk("Primary AC'97 codec not responding\n");
+	snd_printk(KERN_ERR "Primary AC'97 codec not responding\n");
 	snd_fm801_free(chip);
 	return -EIO;
 

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index aaa41fb480a7..e5cfa2a0c246 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1462,6 +1462,7 @@ static void __devexit snd_card_fm801_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "FM801",
+	.owner = THIS_MODULE,
 	.id_table = snd_fm801_ids,
 	.probe = snd_card_fm801_probe,
 	.remove = __devexit_p(snd_card_fm801_remove),

commit e560d8d8368ad8b6161839984b253de622863265
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:21:46 2005 +0200

    [ALSA] Replace with kzalloc() - pci stuff
    
    AD1889 driver,ATIIXP driver,ATIIXP-modem driver,AZT3328 driver
    BT87x driver,CMIPCI driver,CS4281 driver,ENS1370/1+ driver
    ES1938 driver,ES1968 driver,FM801 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,SonicVibes driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,AK4531 codec,au88x0 driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    HDA generic driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,Trident driver,YMFPCI driver
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 36b2f62e8573..aaa41fb480a7 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1263,7 +1263,7 @@ static int __devinit snd_fm801_create(snd_card_t * card,
 	*rchip = NULL;
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
-	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (chip == NULL) {
 		pci_disable_device(pci);
 		return -ENOMEM;

commit 10e8d78a94fc57f1bf11d50b97ff85b005e46d0b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Aug 3 13:40:08 2005 +0200

    [ALSA] use SNDRV_CTL_NAME_IEC958 macro
    
    CMI8330 driver,ENS1370/1+ driver,FM801 driver,VIA82xx driver,AC97 Codec
    ALI5451 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    ICE1712 driver,ICE1724 driver
    Where appropriate, use the SNDRV_CTL_NAME_IEC958 instead of a literal
    string.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index ff10e637a95e..36b2f62e8573 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1155,10 +1155,10 @@ FM801_SINGLE("FM Playback Switch", FM801_FM_VOL, 15, 1, 1),
 static snd_kcontrol_new_t snd_fm801_controls_multi[] __devinitdata = {
 FM801_SINGLE("AC97 2ch->4ch Copy Switch", FM801_CODEC_CTRL, 7, 1, 0),
 FM801_SINGLE("AC97 18-bit Switch", FM801_CODEC_CTRL, 10, 1, 0),
-FM801_SINGLE("IEC958 Capture Switch", FM801_I2S_MODE, 8, 1, 0),
-FM801_SINGLE("IEC958 Raw Data Playback Switch", FM801_I2S_MODE, 9, 1, 0),
-FM801_SINGLE("IEC958 Raw Data Capture Switch", FM801_I2S_MODE, 10, 1, 0),
-FM801_SINGLE("IEC958 Playback Switch", FM801_GEN_CTRL, 2, 1, 0),
+FM801_SINGLE(SNDRV_CTL_NAME_IEC958("",CAPTURE,SWITCH), FM801_I2S_MODE, 8, 1, 0),
+FM801_SINGLE(SNDRV_CTL_NAME_IEC958("Raw Data ",PLAYBACK,SWITCH), FM801_I2S_MODE, 9, 1, 0),
+FM801_SINGLE(SNDRV_CTL_NAME_IEC958("Raw Data ",CAPTURE,SWITCH), FM801_I2S_MODE, 10, 1, 0),
+FM801_SINGLE(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH), FM801_GEN_CTRL, 2, 1, 0),
 };
 
 static void snd_fm801_mixer_free_ac97_bus(ac97_bus_t *bus)

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 3291434f3e0c..ff10e637a95e 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1469,7 +1469,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_fm801_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_fm801_exit(void)

commit 26be865923ce9edefe8ddc007ddb1c098c29c449
Author: Sergey Vlasov <vsu@altlinux.ru>
Date:   Mon Apr 11 14:17:19 2005 +0200

    [ALSA] Add PCI ID for Gallant Odyssey Sound 4
    
    FM801 driver
    The Gallant Odyssey Sound 4 card is based on the ForteMedia FM801
    chip, but has a different PCI ID.
    
    Signed-off-by: Sergey Vlasov <vsu@altlinux.ru>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 08e7c5a296d5..3291434f3e0c 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -195,6 +195,7 @@ struct _snd_fm801 {
 
 static struct pci_device_id snd_fm801_ids[] = {
 	{ 0x1319, 0x0801, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* FM801 */
+	{ 0x5213, 0x0510, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* Gallant Odyssey Sound 4 */
 	{ 0, }
 };
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
new file mode 100644
index 000000000000..08e7c5a296d5
--- /dev/null
+++ b/sound/pci/fm801.c
@@ -0,0 +1,1480 @@
+/*
+ *  The driver for the ForteMedia FM801 based soundcards
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/mpu401.h>
+#include <sound/opl3.h>
+#include <sound/initval.h>
+
+#include <asm/io.h>
+
+#if (defined(CONFIG_SND_FM801_TEA575X) || defined(CONFIG_SND_FM801_TEA575X_MODULE)) && (defined(CONFIG_VIDEO_DEV) || defined(CONFIG_VIDEO_DEV_MODULE))
+#include <sound/tea575x-tuner.h>
+#define TEA575X_RADIO 1
+#endif
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("ForteMedia FM801");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{ForteMedia,FM801},"
+		"{Genius,SoundMaker Live 5.1}}");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+/*
+ *  Enable TEA575x tuner
+ *    1 = MediaForte 256-PCS
+ *    2 = MediaForte 256-PCPR
+ *    3 = MediaForte 64-PCR
+ *  High 16-bits are video (radio) device number + 1
+ */
+static int tea575x_tuner[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 };
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for the FM801 soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for the FM801 soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable FM801 soundcard.");
+module_param_array(tea575x_tuner, int, NULL, 0444);
+MODULE_PARM_DESC(tea575x_tuner, "Enable TEA575x tuner.");
+
+/*
+ *  Direct registers
+ */
+
+#define FM801_REG(chip, reg)	(chip->port + FM801_##reg)
+
+#define FM801_PCM_VOL		0x00	/* PCM Output Volume */
+#define FM801_FM_VOL		0x02	/* FM Output Volume */
+#define FM801_I2S_VOL		0x04	/* I2S Volume */
+#define FM801_REC_SRC		0x06	/* Record Source */
+#define FM801_PLY_CTRL		0x08	/* Playback Control */
+#define FM801_PLY_COUNT		0x0a	/* Playback Count */
+#define FM801_PLY_BUF1		0x0c	/* Playback Bufer I */
+#define FM801_PLY_BUF2		0x10	/* Playback Buffer II */
+#define FM801_CAP_CTRL		0x14	/* Capture Control */
+#define FM801_CAP_COUNT		0x16	/* Capture Count */
+#define FM801_CAP_BUF1		0x18	/* Capture Buffer I */
+#define FM801_CAP_BUF2		0x1c	/* Capture Buffer II */
+#define FM801_CODEC_CTRL	0x22	/* Codec Control */
+#define FM801_I2S_MODE		0x24	/* I2S Mode Control */
+#define FM801_VOLUME		0x26	/* Volume Up/Down/Mute Status */
+#define FM801_I2C_CTRL		0x29	/* I2C Control */
+#define FM801_AC97_CMD		0x2a	/* AC'97 Command */
+#define FM801_AC97_DATA		0x2c	/* AC'97 Data */
+#define FM801_MPU401_DATA	0x30	/* MPU401 Data */
+#define FM801_MPU401_CMD	0x31	/* MPU401 Command */
+#define FM801_GPIO_CTRL		0x52	/* General Purpose I/O Control */
+#define FM801_GEN_CTRL		0x54	/* General Control */
+#define FM801_IRQ_MASK		0x56	/* Interrupt Mask */
+#define FM801_IRQ_STATUS	0x5a	/* Interrupt Status */
+#define FM801_OPL3_BANK0	0x68	/* OPL3 Status Read / Bank 0 Write */
+#define FM801_OPL3_DATA0	0x69	/* OPL3 Data 0 Write */
+#define FM801_OPL3_BANK1	0x6a	/* OPL3 Bank 1 Write */
+#define FM801_OPL3_DATA1	0x6b	/* OPL3 Bank 1 Write */
+#define FM801_POWERDOWN		0x70	/* Blocks Power Down Control */
+
+#define FM801_AC97_ADDR_SHIFT	10
+
+/* playback and record control register bits */
+#define FM801_BUF1_LAST		(1<<1)
+#define FM801_BUF2_LAST		(1<<2)
+#define FM801_START		(1<<5)
+#define FM801_PAUSE		(1<<6)
+#define FM801_IMMED_STOP	(1<<7)
+#define FM801_RATE_SHIFT	8
+#define FM801_RATE_MASK		(15 << FM801_RATE_SHIFT)
+#define FM801_CHANNELS_4	(1<<12)	/* playback only */
+#define FM801_CHANNELS_6	(2<<12)	/* playback only */
+#define FM801_CHANNELS_6MS	(3<<12)	/* playback only */
+#define FM801_CHANNELS_MASK	(3<<12)
+#define FM801_16BIT		(1<<14)
+#define FM801_STEREO		(1<<15)
+
+/* IRQ status bits */
+#define FM801_IRQ_PLAYBACK	(1<<8)
+#define FM801_IRQ_CAPTURE	(1<<9)
+#define FM801_IRQ_VOLUME	(1<<14)
+#define FM801_IRQ_MPU		(1<<15)
+
+/* GPIO control register */
+#define FM801_GPIO_GP0		(1<<0)	/* read/write */
+#define FM801_GPIO_GP1		(1<<1)
+#define FM801_GPIO_GP2		(1<<2)
+#define FM801_GPIO_GP3		(1<<3)
+#define FM801_GPIO_GP(x)	(1<<(0+(x)))
+#define FM801_GPIO_GD0		(1<<8)	/* directions: 1 = input, 0 = output*/
+#define FM801_GPIO_GD1		(1<<9)
+#define FM801_GPIO_GD2		(1<<10)
+#define FM801_GPIO_GD3		(1<<11)
+#define FM801_GPIO_GD(x)	(1<<(8+(x)))
+#define FM801_GPIO_GS0		(1<<12)	/* function select: */
+#define FM801_GPIO_GS1		(1<<13)	/*    1 = GPIO */
+#define FM801_GPIO_GS2		(1<<14)	/*    0 = other (S/PDIF, VOL) */
+#define FM801_GPIO_GS3		(1<<15)
+#define FM801_GPIO_GS(x)	(1<<(12+(x)))
+	
+/*
+
+ */
+
+typedef struct _snd_fm801 fm801_t;
+
+struct _snd_fm801 {
+	int irq;
+
+	unsigned long port;	/* I/O port number */
+	unsigned int multichannel: 1,	/* multichannel support */
+		     secondary: 1;	/* secondary codec */
+	unsigned char secondary_addr;	/* address of the secondary codec */
+
+	unsigned short ply_ctrl; /* playback control */
+	unsigned short cap_ctrl; /* capture control */
+
+	unsigned long ply_buffer;
+	unsigned int ply_buf;
+	unsigned int ply_count;
+	unsigned int ply_size;
+	unsigned int ply_pos;
+
+	unsigned long cap_buffer;
+	unsigned int cap_buf;
+	unsigned int cap_count;
+	unsigned int cap_size;
+	unsigned int cap_pos;
+
+	ac97_bus_t *ac97_bus;
+	ac97_t *ac97;
+	ac97_t *ac97_sec;
+
+	struct pci_dev *pci;
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	snd_rawmidi_t *rmidi;
+	snd_pcm_substream_t *playback_substream;
+	snd_pcm_substream_t *capture_substream;
+	unsigned int p_dma_size;
+	unsigned int c_dma_size;
+
+	spinlock_t reg_lock;
+	snd_info_entry_t *proc_entry;
+
+#ifdef TEA575X_RADIO
+	tea575x_t tea;
+#endif
+};
+
+static struct pci_device_id snd_fm801_ids[] = {
+	{ 0x1319, 0x0801, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, 0, },   /* FM801 */
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_fm801_ids);
+
+/*
+ *  common I/O routines
+ */
+
+static int snd_fm801_update_bits(fm801_t *chip, unsigned short reg,
+				 unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned long flags;
+	unsigned short old, new;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	old = inw(chip->port + reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	if (change)
+		outw(new, chip->port + reg);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return change;
+}
+
+static void snd_fm801_codec_write(ac97_t *ac97,
+				  unsigned short reg,
+				  unsigned short val)
+{
+	fm801_t *chip = ac97->private_data;
+	int idx;
+
+	/*
+	 *  Wait until the codec interface is not ready..
+	 */
+	for (idx = 0; idx < 100; idx++) {
+		if (!(inw(FM801_REG(chip, AC97_CMD)) & (1<<9)))
+			goto ok1;
+		udelay(10);
+	}
+	snd_printk("AC'97 interface is busy (1)\n");
+	return;
+
+ ok1:
+	/* write data and address */
+	outw(val, FM801_REG(chip, AC97_DATA));
+	outw(reg | (ac97->addr << FM801_AC97_ADDR_SHIFT), FM801_REG(chip, AC97_CMD));
+	/*
+	 *  Wait until the write command is not completed..
+         */
+	for (idx = 0; idx < 1000; idx++) {
+		if (!(inw(FM801_REG(chip, AC97_CMD)) & (1<<9)))
+			return;
+		udelay(10);
+	}
+	snd_printk("AC'97 interface #%d is busy (2)\n", ac97->num);
+}
+
+static unsigned short snd_fm801_codec_read(ac97_t *ac97, unsigned short reg)
+{
+	fm801_t *chip = ac97->private_data;
+	int idx;
+
+	/*
+	 *  Wait until the codec interface is not ready..
+	 */
+	for (idx = 0; idx < 100; idx++) {
+		if (!(inw(FM801_REG(chip, AC97_CMD)) & (1<<9)))
+			goto ok1;
+		udelay(10);
+	}
+	snd_printk("AC'97 interface is busy (1)\n");
+	return 0;
+
+ ok1:
+	/* read command */
+	outw(reg | (ac97->addr << FM801_AC97_ADDR_SHIFT) | (1<<7), FM801_REG(chip, AC97_CMD));
+	for (idx = 0; idx < 100; idx++) {
+		if (!(inw(FM801_REG(chip, AC97_CMD)) & (1<<9)))
+			goto ok2;
+		udelay(10);
+	}
+	snd_printk("AC'97 interface #%d is busy (2)\n", ac97->num);
+	return 0;
+
+ ok2:
+	for (idx = 0; idx < 1000; idx++) {
+		if (inw(FM801_REG(chip, AC97_CMD)) & (1<<8))
+			goto ok3;
+		udelay(10);
+	}
+	snd_printk("AC'97 interface #%d is not valid (2)\n", ac97->num);
+	return 0;
+
+ ok3:
+	return inw(FM801_REG(chip, AC97_DATA));
+}
+
+static unsigned int rates[] = {
+  5500,  8000,  9600, 11025,
+  16000, 19200, 22050, 32000,
+  38400, 44100, 48000
+};
+
+static snd_pcm_hw_constraint_list_t hw_constraints_rates = {
+	.count = ARRAY_SIZE(rates),
+	.list = rates,
+	.mask = 0,
+};
+
+static unsigned int channels[] = {
+  2, 4, 6
+};
+
+#define CHANNELS sizeof(channels) / sizeof(channels[0])
+
+static snd_pcm_hw_constraint_list_t hw_constraints_channels = {
+	.count = CHANNELS,
+	.list = channels,
+	.mask = 0,
+};
+
+/*
+ *  Sample rate routines
+ */
+
+static unsigned short snd_fm801_rate_bits(unsigned int rate)
+{
+	unsigned int idx;
+
+	for (idx = 0; idx < ARRAY_SIZE(rates); idx++)
+		if (rates[idx] == rate)
+			return idx;
+	snd_BUG();
+	return ARRAY_SIZE(rates) - 1;
+}
+
+/*
+ *  PCM part
+ */
+
+static int snd_fm801_playback_trigger(snd_pcm_substream_t * substream,
+				      int cmd)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+
+	spin_lock(&chip->reg_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		chip->ply_ctrl &= ~(FM801_BUF1_LAST |
+				     FM801_BUF2_LAST |
+				     FM801_PAUSE);
+		chip->ply_ctrl |= FM801_START |
+				   FM801_IMMED_STOP;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		chip->ply_ctrl &= ~(FM801_START | FM801_PAUSE);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		chip->ply_ctrl |= FM801_PAUSE;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		chip->ply_ctrl &= ~FM801_PAUSE;
+		break;
+	default:
+		spin_unlock(&chip->reg_lock);
+		snd_BUG();
+		return -EINVAL;
+	}
+	outw(chip->ply_ctrl, FM801_REG(chip, PLY_CTRL));
+	spin_unlock(&chip->reg_lock);
+	return 0;
+}
+
+static int snd_fm801_capture_trigger(snd_pcm_substream_t * substream,
+				     int cmd)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+
+	spin_lock(&chip->reg_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		chip->cap_ctrl &= ~(FM801_BUF1_LAST |
+				     FM801_BUF2_LAST |
+				     FM801_PAUSE);
+		chip->cap_ctrl |= FM801_START |
+				   FM801_IMMED_STOP;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		chip->cap_ctrl &= ~(FM801_START | FM801_PAUSE);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		chip->cap_ctrl |= FM801_PAUSE;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		chip->cap_ctrl &= ~FM801_PAUSE;
+		break;
+	default:
+		spin_unlock(&chip->reg_lock);
+		snd_BUG();
+		return -EINVAL;
+	}
+	outw(chip->cap_ctrl, FM801_REG(chip, CAP_CTRL));
+	spin_unlock(&chip->reg_lock);
+	return 0;
+}
+
+static int snd_fm801_hw_params(snd_pcm_substream_t * substream,
+			       snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int snd_fm801_hw_free(snd_pcm_substream_t * substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_fm801_playback_prepare(snd_pcm_substream_t * substream)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	chip->ply_size = snd_pcm_lib_buffer_bytes(substream);
+	chip->ply_count = snd_pcm_lib_period_bytes(substream);
+	spin_lock_irq(&chip->reg_lock);
+	chip->ply_ctrl &= ~(FM801_START | FM801_16BIT |
+			     FM801_STEREO | FM801_RATE_MASK |
+			     FM801_CHANNELS_MASK);
+	if (snd_pcm_format_width(runtime->format) == 16)
+		chip->ply_ctrl |= FM801_16BIT;
+	if (runtime->channels > 1) {
+		chip->ply_ctrl |= FM801_STEREO;
+		if (runtime->channels == 4)
+			chip->ply_ctrl |= FM801_CHANNELS_4;
+		else if (runtime->channels == 6)
+			chip->ply_ctrl |= FM801_CHANNELS_6;
+	}
+	chip->ply_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;
+	chip->ply_buf = 0;
+	outw(chip->ply_ctrl, FM801_REG(chip, PLY_CTRL));
+	outw(chip->ply_count - 1, FM801_REG(chip, PLY_COUNT));
+	chip->ply_buffer = runtime->dma_addr;
+	chip->ply_pos = 0;
+	outl(chip->ply_buffer, FM801_REG(chip, PLY_BUF1));
+	outl(chip->ply_buffer + (chip->ply_count % chip->ply_size), FM801_REG(chip, PLY_BUF2));
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static int snd_fm801_capture_prepare(snd_pcm_substream_t * substream)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	chip->cap_size = snd_pcm_lib_buffer_bytes(substream);
+	chip->cap_count = snd_pcm_lib_period_bytes(substream);
+	spin_lock_irq(&chip->reg_lock);
+	chip->cap_ctrl &= ~(FM801_START | FM801_16BIT |
+			     FM801_STEREO | FM801_RATE_MASK);
+	if (snd_pcm_format_width(runtime->format) == 16)
+		chip->cap_ctrl |= FM801_16BIT;
+	if (runtime->channels > 1)
+		chip->cap_ctrl |= FM801_STEREO;
+	chip->cap_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;
+	chip->cap_buf = 0;
+	outw(chip->cap_ctrl, FM801_REG(chip, CAP_CTRL));
+	outw(chip->cap_count - 1, FM801_REG(chip, CAP_COUNT));
+	chip->cap_buffer = runtime->dma_addr;
+	chip->cap_pos = 0;
+	outl(chip->cap_buffer, FM801_REG(chip, CAP_BUF1));
+	outl(chip->cap_buffer + (chip->cap_count % chip->cap_size), FM801_REG(chip, CAP_BUF2));
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_fm801_playback_pointer(snd_pcm_substream_t * substream)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+	size_t ptr;
+
+	if (!(chip->ply_ctrl & FM801_START))
+		return 0;
+	spin_lock(&chip->reg_lock);
+	ptr = chip->ply_pos + (chip->ply_count - 1) - inw(FM801_REG(chip, PLY_COUNT));
+	if (inw(FM801_REG(chip, IRQ_STATUS)) & FM801_IRQ_PLAYBACK) {
+		ptr += chip->ply_count;
+		ptr %= chip->ply_size;
+	}
+	spin_unlock(&chip->reg_lock);
+	return bytes_to_frames(substream->runtime, ptr);
+}
+
+static snd_pcm_uframes_t snd_fm801_capture_pointer(snd_pcm_substream_t * substream)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+	size_t ptr;
+
+	if (!(chip->cap_ctrl & FM801_START))
+		return 0;
+	spin_lock(&chip->reg_lock);
+	ptr = chip->cap_pos + (chip->cap_count - 1) - inw(FM801_REG(chip, CAP_COUNT));
+	if (inw(FM801_REG(chip, IRQ_STATUS)) & FM801_IRQ_CAPTURE) {
+		ptr += chip->cap_count;
+		ptr %= chip->cap_size;
+	}
+	spin_unlock(&chip->reg_lock);
+	return bytes_to_frames(substream->runtime, ptr);
+}
+
+static irqreturn_t snd_fm801_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	fm801_t *chip = dev_id;
+	unsigned short status;
+	unsigned int tmp;
+
+	status = inw(FM801_REG(chip, IRQ_STATUS));
+	status &= FM801_IRQ_PLAYBACK|FM801_IRQ_CAPTURE|FM801_IRQ_MPU|FM801_IRQ_VOLUME;
+	if (! status)
+		return IRQ_NONE;
+	/* ack first */
+	outw(status, FM801_REG(chip, IRQ_STATUS));
+	if (chip->pcm && (status & FM801_IRQ_PLAYBACK) && chip->playback_substream) {
+		spin_lock(&chip->reg_lock);
+		chip->ply_buf++;
+		chip->ply_pos += chip->ply_count;
+		chip->ply_pos %= chip->ply_size;
+		tmp = chip->ply_pos + chip->ply_count;
+		tmp %= chip->ply_size;
+		outl(chip->ply_buffer + tmp,
+				(chip->ply_buf & 1) ?
+					FM801_REG(chip, PLY_BUF1) :
+					FM801_REG(chip, PLY_BUF2));
+		spin_unlock(&chip->reg_lock);
+		snd_pcm_period_elapsed(chip->playback_substream);
+	}
+	if (chip->pcm && (status & FM801_IRQ_CAPTURE) && chip->capture_substream) {
+		spin_lock(&chip->reg_lock);
+		chip->cap_buf++;
+		chip->cap_pos += chip->cap_count;
+		chip->cap_pos %= chip->cap_size;
+		tmp = chip->cap_pos + chip->cap_count;
+		tmp %= chip->cap_size;
+		outl(chip->cap_buffer + tmp,
+				(chip->cap_buf & 1) ?
+					FM801_REG(chip, CAP_BUF1) :
+					FM801_REG(chip, CAP_BUF2));
+		spin_unlock(&chip->reg_lock);
+		snd_pcm_period_elapsed(chip->capture_substream);
+	}
+	if (chip->rmidi && (status & FM801_IRQ_MPU))
+		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
+	if (status & FM801_IRQ_VOLUME)
+		;/* TODO */
+
+	return IRQ_HANDLED;
+}
+
+static snd_pcm_hardware_t snd_fm801_playback =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		5500,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_fm801_capture =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		5500,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static int snd_fm801_playback_open(snd_pcm_substream_t * substream)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	chip->playback_substream = substream;
+	runtime->hw = snd_fm801_playback;
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+	if (chip->multichannel) {
+		runtime->hw.channels_max = 6;
+		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels);
+	}
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	return 0;
+}
+
+static int snd_fm801_capture_open(snd_pcm_substream_t * substream)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	chip->capture_substream = substream;
+	runtime->hw = snd_fm801_capture;
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	return 0;
+}
+
+static int snd_fm801_playback_close(snd_pcm_substream_t * substream)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+
+	chip->playback_substream = NULL;
+	return 0;
+}
+
+static int snd_fm801_capture_close(snd_pcm_substream_t * substream)
+{
+	fm801_t *chip = snd_pcm_substream_chip(substream);
+
+	chip->capture_substream = NULL;
+	return 0;
+}
+
+static snd_pcm_ops_t snd_fm801_playback_ops = {
+	.open =		snd_fm801_playback_open,
+	.close =	snd_fm801_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_fm801_hw_params,
+	.hw_free =	snd_fm801_hw_free,
+	.prepare =	snd_fm801_playback_prepare,
+	.trigger =	snd_fm801_playback_trigger,
+	.pointer =	snd_fm801_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_fm801_capture_ops = {
+	.open =		snd_fm801_capture_open,
+	.close =	snd_fm801_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_fm801_hw_params,
+	.hw_free =	snd_fm801_hw_free,
+	.prepare =	snd_fm801_capture_prepare,
+	.trigger =	snd_fm801_capture_trigger,
+	.pointer =	snd_fm801_capture_pointer,
+};
+
+static void snd_fm801_pcm_free(snd_pcm_t *pcm)
+{
+	fm801_t *chip = pcm->private_data;
+	chip->pcm = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __devinit snd_fm801_pcm(fm801_t *chip, int device, snd_pcm_t ** rpcm)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if (rpcm)
+		*rpcm = NULL;
+	if ((err = snd_pcm_new(chip->card, "FM801", device, 1, 1, &pcm)) < 0)
+		return err;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_fm801_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_fm801_capture_ops);
+
+	pcm->private_data = chip;
+	pcm->private_free = snd_fm801_pcm_free;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "FM801");
+	chip->pcm = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(chip->pci),
+					      chip->multichannel ? 128*1024 : 64*1024, 128*1024);
+
+	if (rpcm)
+		*rpcm = pcm;
+	return 0;
+}
+
+/*
+ *  TEA5757 radio
+ */
+
+#ifdef TEA575X_RADIO
+
+/* 256PCS GPIO numbers */
+#define TEA_256PCS_DATA			1
+#define TEA_256PCS_WRITE_ENABLE		2	/* inverted */
+#define TEA_256PCS_BUS_CLOCK		3
+
+static void snd_fm801_tea575x_256pcs_write(tea575x_t *tea, unsigned int val)
+{
+	fm801_t *chip = tea->private_data;
+	unsigned short reg;
+	int i = 25;
+
+	spin_lock_irq(&chip->reg_lock);
+	reg = inw(FM801_REG(chip, GPIO_CTRL));
+	/* use GPIO lines and set write enable bit */
+	reg |= FM801_GPIO_GS(TEA_256PCS_DATA) |
+	       FM801_GPIO_GS(TEA_256PCS_WRITE_ENABLE) |
+	       FM801_GPIO_GS(TEA_256PCS_BUS_CLOCK);
+	/* all of lines are in the write direction */
+	/* clear data and clock lines */
+	reg &= ~(FM801_GPIO_GD(TEA_256PCS_DATA) |
+	         FM801_GPIO_GD(TEA_256PCS_WRITE_ENABLE) |
+	         FM801_GPIO_GD(TEA_256PCS_BUS_CLOCK) |
+	         FM801_GPIO_GP(TEA_256PCS_DATA) |
+	         FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK) |
+		 FM801_GPIO_GP(TEA_256PCS_WRITE_ENABLE));
+	outw(reg, FM801_REG(chip, GPIO_CTRL));
+	udelay(1);
+
+	while (i--) {
+		if (val & (1 << i))
+			reg |= FM801_GPIO_GP(TEA_256PCS_DATA);
+		else
+			reg &= ~FM801_GPIO_GP(TEA_256PCS_DATA);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+		reg |= FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		reg &= ~FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+	}
+
+	/* and reset the write enable bit */
+	reg |= FM801_GPIO_GP(TEA_256PCS_WRITE_ENABLE) |
+	       FM801_GPIO_GP(TEA_256PCS_DATA);
+	outw(reg, FM801_REG(chip, GPIO_CTRL));
+	spin_unlock_irq(&chip->reg_lock);
+}
+
+static unsigned int snd_fm801_tea575x_256pcs_read(tea575x_t *tea)
+{
+	fm801_t *chip = tea->private_data;
+	unsigned short reg;
+	unsigned int val = 0;
+	int i;
+	
+	spin_lock_irq(&chip->reg_lock);
+	reg = inw(FM801_REG(chip, GPIO_CTRL));
+	/* use GPIO lines, set data direction to input */
+	reg |= FM801_GPIO_GS(TEA_256PCS_DATA) |
+	       FM801_GPIO_GS(TEA_256PCS_WRITE_ENABLE) |
+	       FM801_GPIO_GS(TEA_256PCS_BUS_CLOCK) |
+	       FM801_GPIO_GD(TEA_256PCS_DATA) |
+	       FM801_GPIO_GP(TEA_256PCS_DATA) |
+	       FM801_GPIO_GP(TEA_256PCS_WRITE_ENABLE);
+	/* all of lines are in the write direction, except data */
+	/* clear data, write enable and clock lines */
+	reg &= ~(FM801_GPIO_GD(TEA_256PCS_WRITE_ENABLE) |
+	         FM801_GPIO_GD(TEA_256PCS_BUS_CLOCK) |
+	         FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK));
+
+	for (i = 0; i < 24; i++) {
+		reg &= ~FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+		reg |= FM801_GPIO_GP(TEA_256PCS_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+		val <<= 1;
+		if (inw(FM801_REG(chip, GPIO_CTRL)) & FM801_GPIO_GP(TEA_256PCS_DATA))
+			val |= 1;
+	}
+
+	spin_unlock_irq(&chip->reg_lock);
+
+	return val;
+}
+
+/* 256PCPR GPIO numbers */
+#define TEA_256PCPR_BUS_CLOCK		0
+#define TEA_256PCPR_DATA		1
+#define TEA_256PCPR_WRITE_ENABLE	2	/* inverted */
+
+static void snd_fm801_tea575x_256pcpr_write(tea575x_t *tea, unsigned int val)
+{
+	fm801_t *chip = tea->private_data;
+	unsigned short reg;
+	int i = 25;
+
+	spin_lock_irq(&chip->reg_lock);
+	reg = inw(FM801_REG(chip, GPIO_CTRL));
+	/* use GPIO lines and set write enable bit */
+	reg |= FM801_GPIO_GS(TEA_256PCPR_DATA) |
+	       FM801_GPIO_GS(TEA_256PCPR_WRITE_ENABLE) |
+	       FM801_GPIO_GS(TEA_256PCPR_BUS_CLOCK);
+	/* all of lines are in the write direction */
+	/* clear data and clock lines */
+	reg &= ~(FM801_GPIO_GD(TEA_256PCPR_DATA) |
+	         FM801_GPIO_GD(TEA_256PCPR_WRITE_ENABLE) |
+	         FM801_GPIO_GD(TEA_256PCPR_BUS_CLOCK) |
+	         FM801_GPIO_GP(TEA_256PCPR_DATA) |
+	         FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK) |
+		 FM801_GPIO_GP(TEA_256PCPR_WRITE_ENABLE));
+	outw(reg, FM801_REG(chip, GPIO_CTRL));
+	udelay(1);
+
+	while (i--) {
+		if (val & (1 << i))
+			reg |= FM801_GPIO_GP(TEA_256PCPR_DATA);
+		else
+			reg &= ~FM801_GPIO_GP(TEA_256PCPR_DATA);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+		reg |= FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		reg &= ~FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+	}
+
+	/* and reset the write enable bit */
+	reg |= FM801_GPIO_GP(TEA_256PCPR_WRITE_ENABLE) |
+	       FM801_GPIO_GP(TEA_256PCPR_DATA);
+	outw(reg, FM801_REG(chip, GPIO_CTRL));
+	spin_unlock_irq(&chip->reg_lock);
+}
+
+static unsigned int snd_fm801_tea575x_256pcpr_read(tea575x_t *tea)
+{
+	fm801_t *chip = tea->private_data;
+	unsigned short reg;
+	unsigned int val = 0;
+	int i;
+	
+	spin_lock_irq(&chip->reg_lock);
+	reg = inw(FM801_REG(chip, GPIO_CTRL));
+	/* use GPIO lines, set data direction to input */
+	reg |= FM801_GPIO_GS(TEA_256PCPR_DATA) |
+	       FM801_GPIO_GS(TEA_256PCPR_WRITE_ENABLE) |
+	       FM801_GPIO_GS(TEA_256PCPR_BUS_CLOCK) |
+	       FM801_GPIO_GD(TEA_256PCPR_DATA) |
+	       FM801_GPIO_GP(TEA_256PCPR_DATA) |
+	       FM801_GPIO_GP(TEA_256PCPR_WRITE_ENABLE);
+	/* all of lines are in the write direction, except data */
+	/* clear data, write enable and clock lines */
+	reg &= ~(FM801_GPIO_GD(TEA_256PCPR_WRITE_ENABLE) |
+	         FM801_GPIO_GD(TEA_256PCPR_BUS_CLOCK) |
+	         FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK));
+
+	for (i = 0; i < 24; i++) {
+		reg &= ~FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+		reg |= FM801_GPIO_GP(TEA_256PCPR_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+		val <<= 1;
+		if (inw(FM801_REG(chip, GPIO_CTRL)) & FM801_GPIO_GP(TEA_256PCPR_DATA))
+			val |= 1;
+	}
+
+	spin_unlock_irq(&chip->reg_lock);
+
+	return val;
+}
+
+/* 64PCR GPIO numbers */
+#define TEA_64PCR_BUS_CLOCK		0
+#define TEA_64PCR_WRITE_ENABLE		1	/* inverted */
+#define TEA_64PCR_DATA			2
+
+static void snd_fm801_tea575x_64pcr_write(tea575x_t *tea, unsigned int val)
+{
+	fm801_t *chip = tea->private_data;
+	unsigned short reg;
+	int i = 25;
+
+	spin_lock_irq(&chip->reg_lock);
+	reg = inw(FM801_REG(chip, GPIO_CTRL));
+	/* use GPIO lines and set write enable bit */
+	reg |= FM801_GPIO_GS(TEA_64PCR_DATA) |
+	       FM801_GPIO_GS(TEA_64PCR_WRITE_ENABLE) |
+	       FM801_GPIO_GS(TEA_64PCR_BUS_CLOCK);
+	/* all of lines are in the write direction */
+	/* clear data and clock lines */
+	reg &= ~(FM801_GPIO_GD(TEA_64PCR_DATA) |
+	         FM801_GPIO_GD(TEA_64PCR_WRITE_ENABLE) |
+	         FM801_GPIO_GD(TEA_64PCR_BUS_CLOCK) |
+	         FM801_GPIO_GP(TEA_64PCR_DATA) |
+	         FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK) |
+		 FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE));
+	outw(reg, FM801_REG(chip, GPIO_CTRL));
+	udelay(1);
+
+	while (i--) {
+		if (val & (1 << i))
+			reg |= FM801_GPIO_GP(TEA_64PCR_DATA);
+		else
+			reg &= ~FM801_GPIO_GP(TEA_64PCR_DATA);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+		reg |= FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		reg &= ~FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+	}
+
+	/* and reset the write enable bit */
+	reg |= FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE) |
+	       FM801_GPIO_GP(TEA_64PCR_DATA);
+	outw(reg, FM801_REG(chip, GPIO_CTRL));
+	spin_unlock_irq(&chip->reg_lock);
+}
+
+static unsigned int snd_fm801_tea575x_64pcr_read(tea575x_t *tea)
+{
+	fm801_t *chip = tea->private_data;
+	unsigned short reg;
+	unsigned int val = 0;
+	int i;
+	
+	spin_lock_irq(&chip->reg_lock);
+	reg = inw(FM801_REG(chip, GPIO_CTRL));
+	/* use GPIO lines, set data direction to input */
+	reg |= FM801_GPIO_GS(TEA_64PCR_DATA) |
+	       FM801_GPIO_GS(TEA_64PCR_WRITE_ENABLE) |
+	       FM801_GPIO_GS(TEA_64PCR_BUS_CLOCK) |
+	       FM801_GPIO_GD(TEA_64PCR_DATA) |
+	       FM801_GPIO_GP(TEA_64PCR_DATA) |
+	       FM801_GPIO_GP(TEA_64PCR_WRITE_ENABLE);
+	/* all of lines are in the write direction, except data */
+	/* clear data, write enable and clock lines */
+	reg &= ~(FM801_GPIO_GD(TEA_64PCR_WRITE_ENABLE) |
+	         FM801_GPIO_GD(TEA_64PCR_BUS_CLOCK) |
+	         FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK));
+
+	for (i = 0; i < 24; i++) {
+		reg &= ~FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+		reg |= FM801_GPIO_GP(TEA_64PCR_BUS_CLOCK);
+		outw(reg, FM801_REG(chip, GPIO_CTRL));
+		udelay(1);
+		val <<= 1;
+		if (inw(FM801_REG(chip, GPIO_CTRL)) & FM801_GPIO_GP(TEA_64PCR_DATA))
+			val |= 1;
+	}
+
+	spin_unlock_irq(&chip->reg_lock);
+
+	return val;
+}
+
+static struct snd_tea575x_ops snd_fm801_tea_ops[3] = {
+	{
+		/* 1 = MediaForte 256-PCS */
+		.write = snd_fm801_tea575x_256pcs_write,
+		.read = snd_fm801_tea575x_256pcs_read,
+	},
+	{
+		/* 2 = MediaForte 256-PCPR */
+		.write = snd_fm801_tea575x_256pcpr_write,
+		.read = snd_fm801_tea575x_256pcpr_read,
+	},
+	{
+		/* 3 = MediaForte 64-PCR */
+		.write = snd_fm801_tea575x_64pcr_write,
+		.read = snd_fm801_tea575x_64pcr_read,
+	}
+};
+#endif
+
+/*
+ *  Mixer routines
+ */
+
+#define FM801_SINGLE(xname, reg, shift, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_fm801_info_single, \
+  .get = snd_fm801_get_single, .put = snd_fm801_put_single, \
+  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
+
+static int snd_fm801_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+
+	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+
+static int snd_fm801_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+
+	ucontrol->value.integer.value[0] = (inw(chip->port + reg) >> shift) & mask;
+	if (invert)
+		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int snd_fm801_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+	unsigned short val;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = mask - val;
+	return snd_fm801_update_bits(chip, reg, mask << shift, val << shift);
+}
+
+#define FM801_DOUBLE(xname, reg, shift_left, shift_right, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_fm801_info_double, \
+  .get = snd_fm801_get_double, .put = snd_fm801_put_double, \
+  .private_value = reg | (shift_left << 8) | (shift_right << 12) | (mask << 16) | (invert << 24) }
+
+static int snd_fm801_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+
+	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+
+static int snd_fm801_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+        int reg = kcontrol->private_value & 0xff;
+	int shift_left = (kcontrol->private_value >> 8) & 0x0f;
+	int shift_right = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+
+	spin_lock_irq(&chip->reg_lock);
+	ucontrol->value.integer.value[0] = (inw(chip->port + reg) >> shift_left) & mask;
+	ucontrol->value.integer.value[1] = (inw(chip->port + reg) >> shift_right) & mask;
+	spin_unlock_irq(&chip->reg_lock);
+	if (invert) {
+		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
+		ucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];
+	}
+	return 0;
+}
+
+static int snd_fm801_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift_left = (kcontrol->private_value >> 8) & 0x0f;
+	int shift_right = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+	unsigned short val1, val2;
+ 
+	val1 = ucontrol->value.integer.value[0] & mask;
+	val2 = ucontrol->value.integer.value[1] & mask;
+	if (invert) {
+		val1 = mask - val1;
+		val2 = mask - val2;
+	}
+	return snd_fm801_update_bits(chip, reg,
+				     (mask << shift_left) | (mask << shift_right),
+				     (val1 << shift_left ) | (val2 << shift_right));
+}
+
+static int snd_fm801_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[5] = {
+		"AC97 Primary", "FM", "I2S", "PCM", "AC97 Secondary"
+	};
+ 
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 5;
+	if (uinfo->value.enumerated.item > 4)
+		uinfo->value.enumerated.item = 4;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_fm801_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+        unsigned short val;
+ 
+	val = inw(FM801_REG(chip, REC_SRC)) & 7;
+	if (val > 4)
+		val = 4;
+        ucontrol->value.enumerated.item[0] = val;
+        return 0;
+}
+
+static int snd_fm801_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	fm801_t *chip = snd_kcontrol_chip(kcontrol);
+        unsigned short val;
+ 
+        if ((val = ucontrol->value.enumerated.item[0]) > 4)
+                return -EINVAL;
+	return snd_fm801_update_bits(chip, FM801_REC_SRC, 7, val);
+}
+
+#define FM801_CONTROLS (sizeof(snd_fm801_controls)/sizeof(snd_kcontrol_new_t))
+
+static snd_kcontrol_new_t snd_fm801_controls[] __devinitdata = {
+FM801_DOUBLE("Wave Playback Volume", FM801_PCM_VOL, 0, 8, 31, 1),
+FM801_SINGLE("Wave Playback Switch", FM801_PCM_VOL, 15, 1, 1),
+FM801_DOUBLE("I2S Playback Volume", FM801_I2S_VOL, 0, 8, 31, 1),
+FM801_SINGLE("I2S Playback Switch", FM801_I2S_VOL, 15, 1, 1),
+FM801_DOUBLE("FM Playback Volume", FM801_FM_VOL, 0, 8, 31, 1),
+FM801_SINGLE("FM Playback Switch", FM801_FM_VOL, 15, 1, 1),
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Digital Capture Source",
+	.info = snd_fm801_info_mux,
+	.get = snd_fm801_get_mux,
+	.put = snd_fm801_put_mux,
+}
+};
+
+#define FM801_CONTROLS_MULTI (sizeof(snd_fm801_controls_multi)/sizeof(snd_kcontrol_new_t))
+
+static snd_kcontrol_new_t snd_fm801_controls_multi[] __devinitdata = {
+FM801_SINGLE("AC97 2ch->4ch Copy Switch", FM801_CODEC_CTRL, 7, 1, 0),
+FM801_SINGLE("AC97 18-bit Switch", FM801_CODEC_CTRL, 10, 1, 0),
+FM801_SINGLE("IEC958 Capture Switch", FM801_I2S_MODE, 8, 1, 0),
+FM801_SINGLE("IEC958 Raw Data Playback Switch", FM801_I2S_MODE, 9, 1, 0),
+FM801_SINGLE("IEC958 Raw Data Capture Switch", FM801_I2S_MODE, 10, 1, 0),
+FM801_SINGLE("IEC958 Playback Switch", FM801_GEN_CTRL, 2, 1, 0),
+};
+
+static void snd_fm801_mixer_free_ac97_bus(ac97_bus_t *bus)
+{
+	fm801_t *chip = bus->private_data;
+	chip->ac97_bus = NULL;
+}
+
+static void snd_fm801_mixer_free_ac97(ac97_t *ac97)
+{
+	fm801_t *chip = ac97->private_data;
+	if (ac97->num == 0) {
+		chip->ac97 = NULL;
+	} else {
+		chip->ac97_sec = NULL;
+	}
+}
+
+static int __devinit snd_fm801_mixer(fm801_t *chip)
+{
+	ac97_template_t ac97;
+	unsigned int i;
+	int err;
+	static ac97_bus_ops_t ops = {
+		.write = snd_fm801_codec_write,
+		.read = snd_fm801_codec_read,
+	};
+
+	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)
+		return err;
+	chip->ac97_bus->private_free = snd_fm801_mixer_free_ac97_bus;
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = chip;
+	ac97.private_free = snd_fm801_mixer_free_ac97;
+	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
+		return err;
+	if (chip->secondary) {
+		ac97.num = 1;
+		ac97.addr = chip->secondary_addr;
+		if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97_sec)) < 0)
+			return err;
+	}
+	for (i = 0; i < FM801_CONTROLS; i++)
+		snd_ctl_add(chip->card, snd_ctl_new1(&snd_fm801_controls[i], chip));
+	if (chip->multichannel) {
+		for (i = 0; i < FM801_CONTROLS_MULTI; i++)
+			snd_ctl_add(chip->card, snd_ctl_new1(&snd_fm801_controls_multi[i], chip));
+	}
+	return 0;
+}
+
+/*
+ *  initialization routines
+ */
+
+static int snd_fm801_free(fm801_t *chip)
+{
+	unsigned short cmdw;
+
+	if (chip->irq < 0)
+		goto __end_hw;
+
+	/* interrupt setup - mask everything */
+	cmdw = inw(FM801_REG(chip, IRQ_MASK));
+	cmdw |= 0x00c3;
+	outw(cmdw, FM801_REG(chip, IRQ_MASK));
+
+      __end_hw:
+#ifdef TEA575X_RADIO
+	snd_tea575x_exit(&chip->tea);
+#endif
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void *)chip);
+	pci_release_regions(chip->pci);
+	pci_disable_device(chip->pci);
+
+	kfree(chip);
+	return 0;
+}
+
+static int snd_fm801_dev_free(snd_device_t *device)
+{
+	fm801_t *chip = device->device_data;
+	return snd_fm801_free(chip);
+}
+
+static int __devinit snd_fm801_create(snd_card_t * card,
+				      struct pci_dev * pci,
+				      int tea575x_tuner,
+				      fm801_t ** rchip)
+{
+	fm801_t *chip;
+	unsigned char rev, id;
+	unsigned short cmdw;
+	unsigned long timeout;
+	int err;
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_fm801_dev_free,
+	};
+
+	*rchip = NULL;
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+	spin_lock_init(&chip->reg_lock);
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+	if ((err = pci_request_regions(pci, "FM801")) < 0) {
+		kfree(chip);
+		pci_disable_device(pci);
+		return err;
+	}
+	chip->port = pci_resource_start(pci, 0);
+	if (request_irq(pci->irq, snd_fm801_interrupt, SA_INTERRUPT|SA_SHIRQ, "FM801", (void *)chip)) {
+		snd_printk("unable to grab IRQ %d\n", chip->irq);
+		snd_fm801_free(chip);
+		return -EBUSY;
+	}
+	chip->irq = pci->irq;
+	pci_set_master(pci);
+
+	pci_read_config_byte(pci, PCI_REVISION_ID, &rev);
+	if (rev >= 0xb1)	/* FM801-AU */
+		chip->multichannel = 1;
+
+	/* codec cold reset + AC'97 warm reset */
+	outw((1<<5)|(1<<6), FM801_REG(chip, CODEC_CTRL));
+	inw(FM801_REG(chip, CODEC_CTRL)); /* flush posting data */
+	udelay(100);
+	outw(0, FM801_REG(chip, CODEC_CTRL));
+
+	timeout = (jiffies + (3 * HZ) / 4) + 1;		/* min 750ms */
+
+	outw((1<<7) | (0 << FM801_AC97_ADDR_SHIFT), FM801_REG(chip, AC97_CMD));
+	udelay(5);
+	do {
+		if ((inw(FM801_REG(chip, AC97_CMD)) & (3<<8)) == (1<<8))
+			goto __ac97_secondary;
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	} while (time_after(timeout, jiffies));
+	snd_printk("Primary AC'97 codec not found\n");
+	snd_fm801_free(chip);
+	return -EIO;
+
+      __ac97_secondary:
+      	if (!chip->multichannel)	/* lookup is not required */
+      		goto __ac97_ok;
+	for (id = 3; id > 0; id--) {	/* my card has the secondary codec */
+					/* at address #3, so the loop is inverted */
+
+		timeout = jiffies + HZ / 20;
+
+		outw((1<<7) | (id << FM801_AC97_ADDR_SHIFT) | AC97_VENDOR_ID1, FM801_REG(chip, AC97_CMD));
+		udelay(5);
+		do {
+			if ((inw(FM801_REG(chip, AC97_CMD)) & (3<<8)) == (1<<8)) {
+				cmdw = inw(FM801_REG(chip, AC97_DATA));
+				if (cmdw != 0xffff && cmdw != 0) {
+					chip->secondary = 1;
+					chip->secondary_addr = id;
+					goto __ac97_ok;
+				}
+			}
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1);
+		} while (time_after(timeout, jiffies));
+	}
+
+	/* the recovery phase, it seems that probing for non-existing codec might */
+	/* cause timeout problems */
+	timeout = (jiffies + (3 * HZ) / 4) + 1;		/* min 750ms */
+
+	outw((1<<7) | (0 << FM801_AC97_ADDR_SHIFT), FM801_REG(chip, AC97_CMD));
+	udelay(5);
+	do {
+		if ((inw(FM801_REG(chip, AC97_CMD)) & (3<<8)) == (1<<8))
+			goto __ac97_ok;
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	} while (time_after(timeout, jiffies));
+	snd_printk("Primary AC'97 codec not responding\n");
+	snd_fm801_free(chip);
+	return -EIO;
+
+      __ac97_ok:
+
+	/* init volume */
+	outw(0x0808, FM801_REG(chip, PCM_VOL));
+	outw(0x9f1f, FM801_REG(chip, FM_VOL));
+	outw(0x8808, FM801_REG(chip, I2S_VOL));
+
+	/* I2S control - I2S mode */
+	outw(0x0003, FM801_REG(chip, I2S_MODE));
+
+	/* interrupt setup - unmask MPU, PLAYBACK & CAPTURE */
+	cmdw = inw(FM801_REG(chip, IRQ_MASK));
+	cmdw &= ~0x0083;
+	outw(cmdw, FM801_REG(chip, IRQ_MASK));
+
+	/* interrupt clear */
+	outw(FM801_IRQ_PLAYBACK|FM801_IRQ_CAPTURE|FM801_IRQ_MPU, FM801_REG(chip, IRQ_STATUS));
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
+		snd_fm801_free(chip);
+		return err;
+	}
+
+	snd_card_set_dev(card, &pci->dev);
+
+#ifdef TEA575X_RADIO
+	if (tea575x_tuner > 0 && (tea575x_tuner & 0xffff) < 4) {
+		chip->tea.dev_nr = tea575x_tuner >> 16;
+		chip->tea.card = card;
+		chip->tea.freq_fixup = 10700;
+		chip->tea.private_data = chip;
+		chip->tea.ops = &snd_fm801_tea_ops[(tea575x_tuner & 0xffff) - 1];
+		snd_tea575x_init(&chip->tea);
+	}
+#endif
+
+	*rchip = chip;
+	return 0;
+}
+
+static int __devinit snd_card_fm801_probe(struct pci_dev *pci,
+					  const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	fm801_t *chip;
+	opl3_t *opl3;
+	int err;
+
+        if (dev >= SNDRV_CARDS)
+                return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+	if ((err = snd_fm801_create(card, pci, tea575x_tuner[dev], &chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->driver, "FM801");
+	strcpy(card->shortname, "ForteMedia FM801-");
+	strcat(card->shortname, chip->multichannel ? "AU" : "AS");
+	sprintf(card->longname, "%s at 0x%lx, irq %i",
+		card->shortname, chip->port, chip->irq);
+
+	if ((err = snd_fm801_pcm(chip, 0, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_fm801_mixer(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_FM801,
+				       FM801_REG(chip, MPU401_DATA), 1,
+				       chip->irq, 0, &chip->rmidi)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_opl3_create(card, FM801_REG(chip, OPL3_BANK0),
+				   FM801_REG(chip, OPL3_BANK1),
+				   OPL3_HW_OPL3_FM801, 1, &opl3)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_card_fm801_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "FM801",
+	.id_table = snd_fm801_ids,
+	.probe = snd_card_fm801_probe,
+	.remove = __devexit_p(snd_card_fm801_remove),
+};
+
+static int __init alsa_card_fm801_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_fm801_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_fm801_init)
+module_exit(alsa_card_fm801_exit)
