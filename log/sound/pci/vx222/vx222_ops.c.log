commit c09482455ca586539802282380f59f54a1febf16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:22 2020 +0100

    ALSA: vx: More constifications
    
    Apply const prefix to every possible place: the static tables for DSP
    commands, the string tables, and register/offset tables.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-8-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 6245240d8768..23d4338dc553 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -19,7 +19,7 @@
 #include "vx222.h"
 
 
-static int vx2_reg_offset[VX_REG_MAX] = {
+static const int vx2_reg_offset[VX_REG_MAX] = {
 	[VX_ICR]    = 0x00,
 	[VX_CVR]    = 0x04,
 	[VX_ISR]    = 0x08,
@@ -45,7 +45,7 @@ static int vx2_reg_offset[VX_REG_MAX] = {
 	[VX_GPIOC]  = 0x54,		// VX_GPIOC (new with PLX9030)
 };
 
-static int vx2_reg_index[VX_REG_MAX] = {
+static const int vx2_reg_index[VX_REG_MAX] = {
 	[VX_ICR]	= 1,
 	[VX_CVR]	= 1,
 	[VX_ISR]	= 1,

commit f8ae2d2919481817d2e942617c203fc792687c66
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:46 2020 +0100

    ALSA: vx: Constify snd_vx_hardware and snd_vx_ops definitions
    
    Both snd_vx_hardware and snd_vx_ops are only referred without
    modification, hence they can be constified gracefully for further
    optimizations.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-31-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index c145951e2fc6..6245240d8768 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -984,7 +984,7 @@ static int vx2_add_mic_controls(struct vx_core *_chip)
 /*
  * callbacks
  */
-struct snd_vx_ops vx222_ops = {
+const struct snd_vx_ops vx222_ops = {
 	.in8 = vx2_inb,
 	.in32 = vx2_inl,
 	.out8 = vx2_outb,
@@ -1004,7 +1004,7 @@ struct snd_vx_ops vx222_ops = {
 };
 
 /* for old VX222 board */
-struct snd_vx_ops vx222_old_ops = {
+const struct snd_vx_ops vx222_old_ops = {
 	.in8 = vx2_inb,
 	.in32 = vx2_inl,
 	.out8 = vx2_outb,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index c0d0bf44f365..c145951e2fc6 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for Digigram VX222 V2/Mic soundcards
  *
  * VX222-specific low-level routines
  *
  * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/delay.h>

commit fff71a4c050ba46e305d910c837b99ba1728135e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 17:10:11 2018 +0200

    ALSA: vx222: Fix invalid endian conversions
    
    The endian conversions used in vx2_dma_read() and vx2_dma_write() are
    superfluous and even wrong on big-endian machines, as inl() and outl()
    already do conversions.  Kill them.
    
    Spotted by sparse, a warning like:
      sound/pci/vx222/vx222_ops.c:278:30: warning: incorrect type in argument 1 (different base types)
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index d4298af6d3ee..c0d0bf44f365 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -275,7 +275,7 @@ static void vx2_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 		length >>= 2; /* in 32bit words */
 		/* Transfer using pseudo-dma. */
 		for (; length > 0; length--) {
-			outl(cpu_to_le32(*addr), port);
+			outl(*addr, port);
 			addr++;
 		}
 		addr = (u32 *)runtime->dma_area;
@@ -285,7 +285,7 @@ static void vx2_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	count >>= 2; /* in 32bit words */
 	/* Transfer using pseudo-dma. */
 	for (; count > 0; count--) {
-		outl(cpu_to_le32(*addr), port);
+		outl(*addr, port);
 		addr++;
 	}
 
@@ -313,7 +313,7 @@ static void vx2_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 		length >>= 2; /* in 32bit words */
 		/* Transfer using pseudo-dma. */
 		for (; length > 0; length--)
-			*addr++ = le32_to_cpu(inl(port));
+			*addr++ = inl(port);
 		addr = (u32 *)runtime->dma_area;
 		pipe->hw_ptr = 0;
 	}
@@ -321,7 +321,7 @@ static void vx2_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	count >>= 2; /* in 32bit words */
 	/* Transfer using pseudo-dma. */
 	for (; count > 0; count--)
-		*addr++ = le32_to_cpu(inl(port));
+		*addr++ = inl(port);
 
 	vx2_release_pseudo_dma(chip);
 }

commit 5f976f58917eafbd8f725b9b7c0efcf6937e0e83
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 12 10:02:08 2017 +0200

    ALSA: vx222: Use container_of()
    
    The vx222 driver is using the explicit cast from the parent class
    pointer, but it'll be broken when the structure field randomization is
    applied.  Use container_of() in a modern manner, instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 7df1663ea510..d4298af6d3ee 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -86,7 +86,7 @@ static int vx2_reg_index[VX_REG_MAX] = {
 
 static inline unsigned long vx2_reg_addr(struct vx_core *_chip, int reg)
 {
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 	return chip->port[vx2_reg_index[reg]] + vx2_reg_offset[reg];
 }
 
@@ -159,7 +159,7 @@ static void vx2_outl(struct vx_core *chip, int offset, unsigned int val)
 
 static void vx2_reset_dsp(struct vx_core *_chip)
 {
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 
 	/* set the reset dsp bit to 0 */
 	vx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_DSP_RESET_MASK);
@@ -174,7 +174,7 @@ static void vx2_reset_dsp(struct vx_core *_chip)
 
 static int vx2_test_xilinx(struct vx_core *_chip)
 {
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 	unsigned int data;
 
 	dev_dbg(_chip->card->dev, "testing xilinx...\n");
@@ -479,7 +479,7 @@ static int vx2_test_and_ack(struct vx_core *chip)
  */
 static void vx2_validate_irq(struct vx_core *_chip, int enable)
 {
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 
 	/* Set the interrupt enable bit to 1 in CDSP register */
 	if (enable) {
@@ -730,7 +730,7 @@ static void vx2_old_write_codec_bit(struct vx_core *chip, int codec, unsigned in
  */
 static void vx2_reset_codec(struct vx_core *_chip)
 {
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 
 	/* Set the reset CODEC bit to 0. */
 	vx_outl(chip, CDSP, chip->regCDSP &~ VX_CDSP_CODEC_RESET_MASK);
@@ -772,7 +772,7 @@ static void vx2_reset_codec(struct vx_core *_chip)
  */
 static void vx2_change_audio_source(struct vx_core *_chip, int src)
 {
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 
 	switch (src) {
 	case VX_AUDIO_SRC_DIGITAL:
@@ -791,7 +791,7 @@ static void vx2_change_audio_source(struct vx_core *_chip, int src)
  */
 static void vx2_set_clock_source(struct vx_core *_chip, int source)
 {
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 
 	if (source == INTERNAL_QUARTZ)
 		chip->regCFG &= ~VX_CFG_CLOCKIN_SEL_MASK;
@@ -805,7 +805,7 @@ static void vx2_set_clock_source(struct vx_core *_chip, int source)
  */
 static void vx2_reset_board(struct vx_core *_chip, int cold_reset)
 {
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 
 	/* initialize the register values */
 	chip->regCDSP = VX_CDSP_CODEC_RESET_MASK | VX_CDSP_DSP_RESET_MASK ;
@@ -878,7 +878,7 @@ static int vx_input_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_ele
 static int vx_input_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 	mutex_lock(&_chip->mixer_mutex);
 	ucontrol->value.integer.value[0] = chip->input_level[0];
 	ucontrol->value.integer.value[1] = chip->input_level[1];
@@ -889,7 +889,7 @@ static int vx_input_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem
 static int vx_input_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 	if (ucontrol->value.integer.value[0] < 0 ||
 	    ucontrol->value.integer.value[0] > MIC_LEVEL_MAX)
 		return -EINVAL;
@@ -922,7 +922,7 @@ static int vx_mic_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 static int vx_mic_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 	ucontrol->value.integer.value[0] = chip->mic_level;
 	return 0;
 }
@@ -930,7 +930,7 @@ static int vx_mic_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_v
 static int vx_mic_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 	if (ucontrol->value.integer.value[0] < 0 ||
 	    ucontrol->value.integer.value[0] > MIC_LEVEL_MAX)
 		return -EINVAL;
@@ -973,7 +973,7 @@ static const struct snd_kcontrol_new vx_control_mic_level = {
 
 static int vx2_add_mic_controls(struct vx_core *_chip)
 {
-	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	struct snd_vx222 *chip = to_vx222(_chip);
 	int err;
 
 	if (_chip->type != VX_TYPE_MIC)

commit f3b827e0b1841f4cfc18436e09f4f269f3be908e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Feb 20 00:18:09 2017 +0530

    ALSA: pci: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new structures as const as they are only passed as
    an argument to the function snd_ctl_new1. This argument is of type
    const, so snd_kcontrol_new structures having the same property can be
    made const too.
    Done using Coccinelle:
    
    @r1 disable optional_qualifier @
    identifier i;
    position p;
    @@
    static struct snd_kcontrol_new i@p = {...};
    
    @ok1@
    identifier r1.i;
    position p;
    expression e1;
    @@
    snd_ctl_new1(&i@p,e1)
    
    @bad@
    position p!={r1.p,ok1.p};
    identifier r1.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    +const
    struct snd_kcontrol_new i;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 8e457ea27f89..7df1663ea510 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -945,7 +945,7 @@ static int vx_mic_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_v
 	return 0;
 }
 
-static struct snd_kcontrol_new vx_control_input_level = {
+static const struct snd_kcontrol_new vx_control_input_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
 			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
@@ -956,7 +956,7 @@ static struct snd_kcontrol_new vx_control_input_level = {
 	.tlv = { .p = db_scale_mic },
 };
 
-static struct snd_kcontrol_new vx_control_mic_level = {
+static const struct snd_kcontrol_new vx_control_mic_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
 			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),

commit 874e1f6fad9a5184b67f4cee37c1335cd2cc5677
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 4 12:19:15 2017 +0100

    ALSA: vx: Fix possible transfer overflow
    
    The pseudo DMA transfer codes in VX222 and VX-pocket driver have a
    slight bug where they check the buffer boundary wrongly, and may
    overflow.  Also, the zero sample count might be handled badly for the
    playback (although it shouldn't happen in theory).  This patch
    addresses these issues.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=141541
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index af83b3b38052..8e457ea27f89 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -269,12 +269,12 @@ static void vx2_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 
 	/* Transfer using pseudo-dma.
 	 */
-	if (offset + count > pipe->buffer_bytes) {
+	if (offset + count >= pipe->buffer_bytes) {
 		int length = pipe->buffer_bytes - offset;
 		count -= length;
 		length >>= 2; /* in 32bit words */
 		/* Transfer using pseudo-dma. */
-		while (length-- > 0) {
+		for (; length > 0; length--) {
 			outl(cpu_to_le32(*addr), port);
 			addr++;
 		}
@@ -284,7 +284,7 @@ static void vx2_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	pipe->hw_ptr += count;
 	count >>= 2; /* in 32bit words */
 	/* Transfer using pseudo-dma. */
-	while (count-- > 0) {
+	for (; count > 0; count--) {
 		outl(cpu_to_le32(*addr), port);
 		addr++;
 	}
@@ -307,12 +307,12 @@ static void vx2_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	vx2_setup_pseudo_dma(chip, 0);
 	/* Transfer using pseudo-dma.
 	 */
-	if (offset + count > pipe->buffer_bytes) {
+	if (offset + count >= pipe->buffer_bytes) {
 		int length = pipe->buffer_bytes - offset;
 		count -= length;
 		length >>= 2; /* in 32bit words */
 		/* Transfer using pseudo-dma. */
-		while (length-- > 0)
+		for (; length > 0; length--)
 			*addr++ = le32_to_cpu(inl(port));
 		addr = (u32 *)runtime->dma_area;
 		pipe->hw_ptr = 0;
@@ -320,7 +320,7 @@ static void vx2_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	pipe->hw_ptr += count;
 	count >>= 2; /* in 32bit words */
 	/* Transfer using pseudo-dma. */
-	while (count-- > 0)
+	for (; count > 0; count--)
 		*addr++ = le32_to_cpu(inl(port));
 
 	vx2_release_pseudo_dma(chip);

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 52c1a8d5b88a..af83b3b38052 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -24,11 +24,11 @@
 #include <linux/device.h>
 #include <linux/firmware.h>
 #include <linux/mutex.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/tlv.h>
-#include <asm/io.h>
 #include "vx222.h"
 
 

commit 2a9e8df00951092e825144a9968285398f8aa162
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 10 16:46:35 2014 +0100

    ALSA: vx: Fix missing kerneldoc parameter descriptions
    
    The file isn't processed, but it's not bad to fix beforehand.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 2d1570273e99..52c1a8d5b88a 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -92,6 +92,7 @@ static inline unsigned long vx2_reg_addr(struct vx_core *_chip, int reg)
 
 /**
  * snd_vx_inb - read a byte from the register
+ * @chip: VX core instance
  * @offset: register enum
  */
 static unsigned char vx2_inb(struct vx_core *chip, int offset)
@@ -101,6 +102,7 @@ static unsigned char vx2_inb(struct vx_core *chip, int offset)
 
 /**
  * snd_vx_outb - write a byte on the register
+ * @chip: VX core instance
  * @offset: the register offset
  * @val: the value to write
  */
@@ -114,6 +116,7 @@ static void vx2_outb(struct vx_core *chip, int offset, unsigned char val)
 
 /**
  * snd_vx_inl - read a 32bit word from the register
+ * @chip: VX core instance
  * @offset: register enum
  */
 static unsigned int vx2_inl(struct vx_core *chip, int offset)
@@ -123,6 +126,7 @@ static unsigned int vx2_inl(struct vx_core *chip, int offset)
 
 /**
  * snd_vx_outl - write a 32bit word on the register
+ * @chip: VX core instance
  * @offset: the register enum
  * @val: the value to write
  */
@@ -223,6 +227,7 @@ static int vx2_test_xilinx(struct vx_core *_chip)
 
 /**
  * vx_setup_pseudo_dma - set up the pseudo dma read/write mode.
+ * @chip: VX core instance
  * @do_write: 0 = read, 1 = set up for DMA write
  */
 static void vx2_setup_pseudo_dma(struct vx_core *chip, int do_write)

commit 4c826c492f151afb2fef9068660c61c27d191a5a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 12:13:57 2014 +0100

    ALSA: vx222: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index a69e774d0b13..2d1570273e99 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -108,7 +108,7 @@ static void vx2_outb(struct vx_core *chip, int offset, unsigned char val)
 {
 	outb(val, vx2_reg_addr(chip, offset));
 	/*
-	printk(KERN_DEBUG "outb: %x -> %x\n", val, vx2_reg_addr(chip, offset));
+	dev_dbg(chip->card->dev, "outb: %x -> %x\n", val, vx2_reg_addr(chip, offset));
 	*/
 }
 
@@ -129,7 +129,7 @@ static unsigned int vx2_inl(struct vx_core *chip, int offset)
 static void vx2_outl(struct vx_core *chip, int offset, unsigned int val)
 {
 	/*
-	printk(KERN_DEBUG "outl: %x -> %x\n", val, vx2_reg_addr(chip, offset));
+	dev_dbg(chip->card->dev, "outl: %x -> %x\n", val, vx2_reg_addr(chip, offset));
 	*/
 	outl(val, vx2_reg_addr(chip, offset));
 }
@@ -173,7 +173,7 @@ static int vx2_test_xilinx(struct vx_core *_chip)
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	unsigned int data;
 
-	snd_printdd("testing xilinx...\n");
+	dev_dbg(_chip->card->dev, "testing xilinx...\n");
 	/* This test uses several write/read sequences on TEST0 and TEST1 bits
 	 * to figure out whever or not the xilinx was correctly loaded
 	 */
@@ -183,7 +183,7 @@ static int vx2_test_xilinx(struct vx_core *_chip)
 	vx_inl(chip, ISR);
 	data = vx_inl(chip, STATUS);
 	if ((data & VX_STATUS_VAL_TEST0_MASK) == VX_STATUS_VAL_TEST0_MASK) {
-		snd_printdd("bad!\n");
+		dev_dbg(_chip->card->dev, "bad!\n");
 		return -ENODEV;
 	}
 
@@ -192,7 +192,7 @@ static int vx2_test_xilinx(struct vx_core *_chip)
 	vx_inl(chip, ISR);
 	data = vx_inl(chip, STATUS);
 	if (! (data & VX_STATUS_VAL_TEST0_MASK)) {
-		snd_printdd("bad! #2\n");
+		dev_dbg(_chip->card->dev, "bad! #2\n");
 		return -ENODEV;
 	}
 
@@ -203,7 +203,7 @@ static int vx2_test_xilinx(struct vx_core *_chip)
 		vx_inl(chip, ISR);
 		data = vx_inl(chip, STATUS);
 		if ((data & VX_STATUS_VAL_TEST1_MASK) == VX_STATUS_VAL_TEST1_MASK) {
-			snd_printdd("bad! #3\n");
+			dev_dbg(_chip->card->dev, "bad! #3\n");
 			return -ENODEV;
 		}
 
@@ -212,11 +212,11 @@ static int vx2_test_xilinx(struct vx_core *_chip)
 		vx_inl(chip, ISR);
 		data = vx_inl(chip, STATUS);
 		if (! (data & VX_STATUS_VAL_TEST1_MASK)) {
-			snd_printdd("bad! #4\n");
+			dev_dbg(_chip->card->dev, "bad! #4\n");
 			return -ENODEV;
 		}
 	}
-	snd_printdd("ok, xilinx fine.\n");
+	dev_dbg(_chip->card->dev, "ok, xilinx fine.\n");
 	return 0;
 }
 
@@ -397,7 +397,8 @@ static int vx2_load_xilinx_binary(struct vx_core *chip, const struct firmware *x
 		i = vx_inl(chip, GPIOC);
 		if (i & 0x0100)
 			return 0;
-		snd_printk(KERN_ERR "vx222: xilinx test failed after load, GPIOC=0x%x\n", i);
+		dev_err(chip->card->dev,
+			"xilinx test failed after load, GPIOC=0x%x\n", i);
 		return -EINVAL;
 	}
 

commit edd1365e90eb32625041d09de427d7b03461bc5c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 24 09:11:58 2009 +0200

    sound: vx222: fix input level control range check
    
    Fix a logic error in the range check of the input level control that
    would prevent setting any volume less than the maximum.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 6416d3f0c7be..a69e774d0b13 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -885,10 +885,10 @@ static int vx_input_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	if (ucontrol->value.integer.value[0] < 0 ||
-	    ucontrol->value.integer.value[0] < MIC_LEVEL_MAX)
+	    ucontrol->value.integer.value[0] > MIC_LEVEL_MAX)
 		return -EINVAL;
 	if (ucontrol->value.integer.value[1] < 0 ||
-	    ucontrol->value.integer.value[1] < MIC_LEVEL_MAX)
+	    ucontrol->value.integer.value[1] > MIC_LEVEL_MAX)
 		return -EINVAL;
 	mutex_lock(&_chip->mixer_mutex);
 	if (chip->input_level[0] != ucontrol->value.integer.value[0] ||

commit 19af5cdb7c79ff5ec96a99893ffb7f894f4a3dc1
Author: Martin Olsson <martin@minimum.se>
Date:   Thu Apr 23 11:37:37 2009 +0200

    trivial: fix typo milisecond/millisecond for documentation and source comments.
    
    Signed-off-by: Martin Olsson <martin@minimum.se>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index c0efe4491116..6416d3f0c7be 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -367,7 +367,7 @@ static int vx2_load_xilinx_binary(struct vx_core *chip, const struct firmware *x
 	unsigned int port;
 	const unsigned char *image;
 
-	/* XILINX reset (wait at least 1 milisecond between reset on and off). */
+	/* XILINX reset (wait at least 1 millisecond between reset on and off). */
 	vx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE | VX_XILINX_RESET_MASK);
 	vx_inl(chip, CNTRL);
 	msleep(10);

commit ee419653a38de93b75a577851d9e4003cf0bbe07
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:11:31 2009 +0100

    ALSA: Fix missing KERN_* prefix to printk in sound/pci
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 7e87f398ff0b..c0efe4491116 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -107,7 +107,9 @@ static unsigned char vx2_inb(struct vx_core *chip, int offset)
 static void vx2_outb(struct vx_core *chip, int offset, unsigned char val)
 {
 	outb(val, vx2_reg_addr(chip, offset));
-	//printk("outb: %x -> %x\n", val, vx2_reg_addr(chip, offset));
+	/*
+	printk(KERN_DEBUG "outb: %x -> %x\n", val, vx2_reg_addr(chip, offset));
+	*/
 }
 
 /**
@@ -126,7 +128,9 @@ static unsigned int vx2_inl(struct vx_core *chip, int offset)
  */
 static void vx2_outl(struct vx_core *chip, int offset, unsigned int val)
 {
-	// printk("outl: %x -> %x\n", val, vx2_reg_addr(chip, offset));
+	/*
+	printk(KERN_DEBUG "outl: %x -> %x\n", val, vx2_reg_addr(chip, offset));
+	*/
 	outl(val, vx2_reg_addr(chip, offset));
 }
 

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 631f3a639993..7e87f398ff0b 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -253,7 +253,8 @@ static void vx2_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	int offset = pipe->hw_ptr;
 	u32 *addr = (u32 *)(runtime->dma_area + offset);
 
-	snd_assert(count % 4 == 0, return);
+	if (snd_BUG_ON(count % 4))
+		return;
 
 	vx2_setup_pseudo_dma(chip, 1);
 
@@ -291,7 +292,8 @@ static void vx2_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	u32 *addr = (u32 *)(runtime->dma_area + offset);
 	unsigned long port = vx2_reg_addr(chip, VX_DMA);
 
-	snd_assert(count % 4 == 0, return);
+	if (snd_BUG_ON(count % 4))
+		return;
 
 	vx2_setup_pseudo_dma(chip, 0);
 	/* Transfer using pseudo-dma.
@@ -675,7 +677,8 @@ static void vx2_write_akm(struct vx_core *chip, int reg, unsigned int data)
 	   a look up table, as there is no linear matching between the driver codec values
 	   and the real dBu value
 	*/
-	snd_assert(data < sizeof(vx2_akm_gains_lut), return);
+	if (snd_BUG_ON(data >= sizeof(vx2_akm_gains_lut)))
+		return;
 
 	switch (reg) {
 	case XX_CODEC_LEVEL_LEFT_REGISTER:
@@ -823,7 +826,8 @@ static void vx2_set_input_level(struct snd_vx222 *chip)
 		preamp++;	/* raise pre ampli + 18dB */
 		miclevel -= (18 * 2);   /* lower level 18 dB (*2 because of 0.5 dB steps !) */
         }
-	snd_assert(preamp < 4, return);
+	if (snd_BUG_ON(preamp >= 4))
+		return;
 
 	/* set pre-amp level */
 	chip->regSELMIC &= ~MICRO_SELECT_PREAMPLI_MASK;

commit c2ba47d776bf9a45e15f28fc73ad44877437bef9
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat May 24 00:01:40 2008 +0100

    vx222: treat firmware data as const
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index b4bfc1acde88..631f3a639993 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -359,7 +359,7 @@ static int vx2_load_xilinx_binary(struct vx_core *chip, const struct firmware *x
 {
 	unsigned int i;
 	unsigned int port;
-	unsigned char *image;
+	const unsigned char *image;
 
 	/* XILINX reset (wait at least 1 milisecond between reset on and off). */
 	vx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE | VX_XILINX_RESET_MASK);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index f4f0427a7420..b4bfc1acde88 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -20,7 +20,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/firmware.h>

commit 4e98d6a7ce934b19bffb309f2522b22384355fef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 15 15:58:13 2007 +0100

    [ALSA] pci - check value range in ctl callbacks
    
    Check the value ranges in ctl put callbacks properly in the rest of
    PCI drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 55558bef7166..f4f0427a7420 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -877,6 +877,12 @@ static int vx_input_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem
 {
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] < MIC_LEVEL_MAX)
+		return -EINVAL;
+	if (ucontrol->value.integer.value[1] < 0 ||
+	    ucontrol->value.integer.value[1] < MIC_LEVEL_MAX)
+		return -EINVAL;
 	mutex_lock(&_chip->mixer_mutex);
 	if (chip->input_level[0] != ucontrol->value.integer.value[0] ||
 	    chip->input_level[1] != ucontrol->value.integer.value[1]) {
@@ -912,6 +918,9 @@ static int vx_mic_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_v
 {
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > MIC_LEVEL_MAX)
+		return -EINVAL;
 	mutex_lock(&_chip->mixer_mutex);
 	if (chip->mic_level != ucontrol->value.integer.value[0]) {
 		chip->mic_level = ucontrol->value.integer.value[0];

commit 0cb29ea0d449d7c0ecc9649a08ab63476389701d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 29 15:33:49 2007 +0100

    [ALSA] Add even more 'const' to everything related to TLV
    
    Mark TLV data as 'const'
    Signed-of-by: Philipp Matthias Hahn <pmhahn@pmhahn.de>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 5e51950e05f9..55558bef7166 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -846,7 +846,7 @@ static void vx2_set_input_level(struct snd_vx222 *chip)
 
 #define MIC_LEVEL_MAX	0xff
 
-static DECLARE_TLV_DB_SCALE(db_scale_mic, -6450, 50, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_mic, -6450, 50, 0);
 
 /*
  * controls API for input levels

commit 1186ed8c7dc9c0185e783beddf241509cc224f1a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 23 19:53:28 2006 +0200

    [ALSA] Add dB scale information to vxpocket and vx222 drivers
    
    Added the dB scale information to vxpocket and vx222 drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 9b6d345b83a6..5e51950e05f9 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -28,6 +28,7 @@
 
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <asm/io.h>
 #include "vx222.h"
 
@@ -845,6 +846,8 @@ static void vx2_set_input_level(struct snd_vx222 *chip)
 
 #define MIC_LEVEL_MAX	0xff
 
+static DECLARE_TLV_DB_SCALE(db_scale_mic, -6450, 50, 0);
+
 /*
  * controls API for input levels
  */
@@ -922,18 +925,24 @@ static int vx_mic_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_v
 
 static struct snd_kcontrol_new vx_control_input_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name =		"Capture Volume",
 	.info =		vx_input_level_info,
 	.get =		vx_input_level_get,
 	.put =		vx_input_level_put,
+	.tlv = { .p = db_scale_mic },
 };
 
 static struct snd_kcontrol_new vx_control_mic_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name =		"Mic Capture Volume",
 	.info =		vx_mic_level_info,
 	.get =		vx_mic_level_get,
 	.put =		vx_mic_level_put,
+	.tlv = { .p = db_scale_mic },
 };
 
 /*

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index c705af409b0f..9b6d345b83a6 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -24,6 +24,8 @@
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/firmware.h>
+#include <linux/mutex.h>
+
 #include <sound/core.h>
 #include <sound/control.h>
 #include <asm/io.h>
@@ -861,10 +863,10 @@ static int vx_input_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem
 {
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
-	down(&_chip->mixer_mutex);
+	mutex_lock(&_chip->mixer_mutex);
 	ucontrol->value.integer.value[0] = chip->input_level[0];
 	ucontrol->value.integer.value[1] = chip->input_level[1];
-	up(&_chip->mixer_mutex);
+	mutex_unlock(&_chip->mixer_mutex);
 	return 0;
 }
 
@@ -872,16 +874,16 @@ static int vx_input_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem
 {
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
-	down(&_chip->mixer_mutex);
+	mutex_lock(&_chip->mixer_mutex);
 	if (chip->input_level[0] != ucontrol->value.integer.value[0] ||
 	    chip->input_level[1] != ucontrol->value.integer.value[1]) {
 		chip->input_level[0] = ucontrol->value.integer.value[0];
 		chip->input_level[1] = ucontrol->value.integer.value[1];
 		vx2_set_input_level(chip);
-		up(&_chip->mixer_mutex);
+		mutex_unlock(&_chip->mixer_mutex);
 		return 1;
 	}
-	up(&_chip->mixer_mutex);
+	mutex_unlock(&_chip->mixer_mutex);
 	return 0;
 }
 
@@ -907,14 +909,14 @@ static int vx_mic_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_v
 {
 	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
-	down(&_chip->mixer_mutex);
+	mutex_lock(&_chip->mixer_mutex);
 	if (chip->mic_level != ucontrol->value.integer.value[0]) {
 		chip->mic_level = ucontrol->value.integer.value[0];
 		vx2_set_input_level(chip);
-		up(&_chip->mixer_mutex);
+		mutex_unlock(&_chip->mixer_mutex);
 		return 1;
 	}
-	up(&_chip->mixer_mutex);
+	mutex_unlock(&_chip->mixer_mutex);
 	return 0;
 }
 

commit af26367f69a474ed809e4a59abb5855b47daaff4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:46:59 2005 +0100

    [ALSA] Remove xxx_t typedefs: VXdriver
    
    Remove xxx_t typedefs from the VXdriver codes
    (vx_core support, vx222 and vxpocket).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 2d4d0c29b4c4..c705af409b0f 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -82,7 +82,7 @@ static int vx2_reg_index[VX_REG_MAX] = {
 	[VX_GPIOC]	= 0,	/* on the PLX */
 };
 
-static inline unsigned long vx2_reg_addr(vx_core_t *_chip, int reg)
+static inline unsigned long vx2_reg_addr(struct vx_core *_chip, int reg)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	return chip->port[vx2_reg_index[reg]] + vx2_reg_offset[reg];
@@ -92,7 +92,7 @@ static inline unsigned long vx2_reg_addr(vx_core_t *_chip, int reg)
  * snd_vx_inb - read a byte from the register
  * @offset: register enum
  */
-static unsigned char vx2_inb(vx_core_t *chip, int offset)
+static unsigned char vx2_inb(struct vx_core *chip, int offset)
 {
 	return inb(vx2_reg_addr(chip, offset));
 }
@@ -102,7 +102,7 @@ static unsigned char vx2_inb(vx_core_t *chip, int offset)
  * @offset: the register offset
  * @val: the value to write
  */
-static void vx2_outb(vx_core_t *chip, int offset, unsigned char val)
+static void vx2_outb(struct vx_core *chip, int offset, unsigned char val)
 {
 	outb(val, vx2_reg_addr(chip, offset));
 	//printk("outb: %x -> %x\n", val, vx2_reg_addr(chip, offset));
@@ -112,7 +112,7 @@ static void vx2_outb(vx_core_t *chip, int offset, unsigned char val)
  * snd_vx_inl - read a 32bit word from the register
  * @offset: register enum
  */
-static unsigned int vx2_inl(vx_core_t *chip, int offset)
+static unsigned int vx2_inl(struct vx_core *chip, int offset)
 {
 	return inl(vx2_reg_addr(chip, offset));
 }
@@ -122,7 +122,7 @@ static unsigned int vx2_inl(vx_core_t *chip, int offset)
  * @offset: the register enum
  * @val: the value to write
  */
-static void vx2_outl(vx_core_t *chip, int offset, unsigned int val)
+static void vx2_outl(struct vx_core *chip, int offset, unsigned int val)
 {
 	// printk("outl: %x -> %x\n", val, vx2_reg_addr(chip, offset));
 	outl(val, vx2_reg_addr(chip, offset));
@@ -132,13 +132,13 @@ static void vx2_outl(vx_core_t *chip, int offset, unsigned int val)
  * redefine macros to call directly
  */
 #undef vx_inb
-#define vx_inb(chip,reg)	vx2_inb((vx_core_t*)(chip), VX_##reg)
+#define vx_inb(chip,reg)	vx2_inb((struct vx_core*)(chip), VX_##reg)
 #undef vx_outb
-#define vx_outb(chip,reg,val)	vx2_outb((vx_core_t*)(chip), VX_##reg, val)
+#define vx_outb(chip,reg,val)	vx2_outb((struct vx_core*)(chip), VX_##reg, val)
 #undef vx_inl
-#define vx_inl(chip,reg)	vx2_inl((vx_core_t*)(chip), VX_##reg)
+#define vx_inl(chip,reg)	vx2_inl((struct vx_core*)(chip), VX_##reg)
 #undef vx_outl
-#define vx_outl(chip,reg,val)	vx2_outl((vx_core_t*)(chip), VX_##reg, val)
+#define vx_outl(chip,reg,val)	vx2_outl((struct vx_core*)(chip), VX_##reg, val)
 
 
 /*
@@ -147,7 +147,7 @@ static void vx2_outl(vx_core_t *chip, int offset, unsigned int val)
 
 #define XX_DSP_RESET_WAIT_TIME		2	/* ms */
 
-static void vx2_reset_dsp(vx_core_t *_chip)
+static void vx2_reset_dsp(struct vx_core *_chip)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 
@@ -162,7 +162,7 @@ static void vx2_reset_dsp(vx_core_t *_chip)
 }
 
 
-static int vx2_test_xilinx(vx_core_t *_chip)
+static int vx2_test_xilinx(struct vx_core *_chip)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	unsigned int data;
@@ -219,7 +219,7 @@ static int vx2_test_xilinx(vx_core_t *_chip)
  * vx_setup_pseudo_dma - set up the pseudo dma read/write mode.
  * @do_write: 0 = read, 1 = set up for DMA write
  */
-static void vx2_setup_pseudo_dma(vx_core_t *chip, int do_write)
+static void vx2_setup_pseudo_dma(struct vx_core *chip, int do_write)
 {
 	/* Interrupt mode and HREQ pin enabled for host transmit data transfers
 	 * (in case of the use of the pseudo-dma facility).
@@ -235,7 +235,7 @@ static void vx2_setup_pseudo_dma(vx_core_t *chip, int do_write)
 /*
  * vx_release_pseudo_dma - disable the pseudo-DMA mode
  */
-static inline void vx2_release_pseudo_dma(vx_core_t *chip)
+static inline void vx2_release_pseudo_dma(struct vx_core *chip)
 {
 	/* HREQ pin disabled. */
 	vx_outl(chip, ICR, 0);
@@ -244,8 +244,8 @@ static inline void vx2_release_pseudo_dma(vx_core_t *chip)
 
 
 /* pseudo-dma write */
-static void vx2_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
-			  vx_pipe_t *pipe, int count)
+static void vx2_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
+			  struct vx_pipe *pipe, int count)
 {
 	unsigned long port = vx2_reg_addr(chip, VX_DMA);
 	int offset = pipe->hw_ptr;
@@ -282,8 +282,8 @@ static void vx2_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
 
 
 /* pseudo dma read */
-static void vx2_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
-			 vx_pipe_t *pipe, int count)
+static void vx2_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
+			 struct vx_pipe *pipe, int count)
 {
 	int offset = pipe->hw_ptr;
 	u32 *addr = (u32 *)(runtime->dma_area + offset);
@@ -321,7 +321,7 @@ static void vx2_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
 /*
  * transfer counts bits to PLX
  */
-static int put_xilinx_data(vx_core_t *chip, unsigned int port, unsigned int counts, unsigned char data)
+static int put_xilinx_data(struct vx_core *chip, unsigned int port, unsigned int counts, unsigned char data)
 {
 	unsigned int i;
 
@@ -353,7 +353,7 @@ static int put_xilinx_data(vx_core_t *chip, unsigned int port, unsigned int coun
 /*
  * load the xilinx image
  */
-static int vx2_load_xilinx_binary(vx_core_t *chip, const struct firmware *xilinx)
+static int vx2_load_xilinx_binary(struct vx_core *chip, const struct firmware *xilinx)
 {
 	unsigned int i;
 	unsigned int port;
@@ -400,7 +400,7 @@ static int vx2_load_xilinx_binary(vx_core_t *chip, const struct firmware *xilinx
 /*
  * load the boot/dsp images
  */
-static int vx2_load_dsp(vx_core_t *vx, int index, const struct firmware *dsp)
+static int vx2_load_dsp(struct vx_core *vx, int index, const struct firmware *dsp)
 {
 	int err;
 
@@ -432,7 +432,7 @@ static int vx2_load_dsp(vx_core_t *vx, int index, const struct firmware *dsp)
  *
  * spinlock held!
  */
-static int vx2_test_and_ack(vx_core_t *chip)
+static int vx2_test_and_ack(struct vx_core *chip)
 {
 	/* not booted yet? */
 	if (! (chip->chip_status & VX_STAT_XILINX_LOADED))
@@ -463,7 +463,7 @@ static int vx2_test_and_ack(vx_core_t *chip)
 /*
  * vx_validate_irq - enable/disable IRQ
  */
-static void vx2_validate_irq(vx_core_t *_chip, int enable)
+static void vx2_validate_irq(struct vx_core *_chip, int enable)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 
@@ -484,7 +484,7 @@ static void vx2_validate_irq(vx_core_t *_chip, int enable)
 /*
  * write an AKM codec data (24bit)
  */
-static void vx2_write_codec_reg(vx_core_t *chip, unsigned int data)
+static void vx2_write_codec_reg(struct vx_core *chip, unsigned int data)
 {
 	unsigned int i;
 
@@ -660,7 +660,7 @@ static const u8 vx2_akm_gains_lut[VX2_AKM_LEVEL_MAX+1] = {
 /*
  * pseudo-codec write entry
  */
-static void vx2_write_akm(vx_core_t *chip, int reg, unsigned int data)
+static void vx2_write_akm(struct vx_core *chip, int reg, unsigned int data)
 {
 	unsigned int val;
 
@@ -695,7 +695,7 @@ static void vx2_write_akm(vx_core_t *chip, int reg, unsigned int data)
 /*
  * write codec bit for old VX222 board
  */
-static void vx2_old_write_codec_bit(vx_core_t *chip, int codec, unsigned int data)
+static void vx2_old_write_codec_bit(struct vx_core *chip, int codec, unsigned int data)
 {
 	int i;
 
@@ -713,7 +713,7 @@ static void vx2_old_write_codec_bit(vx_core_t *chip, int codec, unsigned int dat
 /*
  * reset codec bit
  */
-static void vx2_reset_codec(vx_core_t *_chip)
+static void vx2_reset_codec(struct vx_core *_chip)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 
@@ -755,7 +755,7 @@ static void vx2_reset_codec(vx_core_t *_chip)
 /*
  * change the audio source
  */
-static void vx2_change_audio_source(vx_core_t *_chip, int src)
+static void vx2_change_audio_source(struct vx_core *_chip, int src)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 
@@ -774,7 +774,7 @@ static void vx2_change_audio_source(vx_core_t *_chip, int src)
 /*
  * set the clock source
  */
-static void vx2_set_clock_source(vx_core_t *_chip, int source)
+static void vx2_set_clock_source(struct vx_core *_chip, int source)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 
@@ -788,7 +788,7 @@ static void vx2_set_clock_source(vx_core_t *_chip, int source)
 /*
  * reset the board
  */
-static void vx2_reset_board(vx_core_t *_chip, int cold_reset)
+static void vx2_reset_board(struct vx_core *_chip, int cold_reset)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 
@@ -848,7 +848,7 @@ static void vx2_set_input_level(struct snd_vx222 *chip)
  */
 
 /* input levels */
-static int vx_input_level_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_input_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -857,9 +857,9 @@ static int vx_input_level_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *ui
 	return 0;
 }
 
-static int vx_input_level_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_input_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *_chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	down(&_chip->mixer_mutex);
 	ucontrol->value.integer.value[0] = chip->input_level[0];
@@ -868,9 +868,9 @@ static int vx_input_level_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uc
 	return 0;
 }
 
-static int vx_input_level_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_input_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *_chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	down(&_chip->mixer_mutex);
 	if (chip->input_level[0] != ucontrol->value.integer.value[0] ||
@@ -886,7 +886,7 @@ static int vx_input_level_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uc
 }
 
 /* mic level */
-static int vx_mic_level_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_mic_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -895,17 +895,17 @@ static int vx_mic_level_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinf
 	return 0;
 }
 
-static int vx_mic_level_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_mic_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *_chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	ucontrol->value.integer.value[0] = chip->mic_level;
 	return 0;
 }
 
-static int vx_mic_level_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_mic_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *_chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *_chip = snd_kcontrol_chip(kcontrol);
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	down(&_chip->mixer_mutex);
 	if (chip->mic_level != ucontrol->value.integer.value[0]) {
@@ -918,7 +918,7 @@ static int vx_mic_level_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucon
 	return 0;
 }
 
-static snd_kcontrol_new_t vx_control_input_level = {
+static struct snd_kcontrol_new vx_control_input_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Capture Volume",
 	.info =		vx_input_level_info,
@@ -926,7 +926,7 @@ static snd_kcontrol_new_t vx_control_input_level = {
 	.put =		vx_input_level_put,
 };
 
-static snd_kcontrol_new_t vx_control_mic_level = {
+static struct snd_kcontrol_new vx_control_mic_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Mic Capture Volume",
 	.info =		vx_mic_level_info,
@@ -938,7 +938,7 @@ static snd_kcontrol_new_t vx_control_mic_level = {
  * FIXME: compressor/limiter implementation is missing yet...
  */
 
-static int vx2_add_mic_controls(vx_core_t *_chip)
+static int vx2_add_mic_controls(struct vx_core *_chip)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	int err;

commit bdbae7e62837c22c5399df0789a24e9d8a1d675f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:21:19 2005 +0100

    [ALSA] Remove snd_vx_delay() function
    
    Replace snd_vx_delay() with appropriate delay/sleep functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 967bd5e6b23c..2d4d0c29b4c4 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -154,7 +154,7 @@ static void vx2_reset_dsp(vx_core_t *_chip)
 	/* set the reset dsp bit to 0 */
 	vx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_DSP_RESET_MASK);
 
-	snd_vx_delay(_chip, XX_DSP_RESET_WAIT_TIME);
+	mdelay(XX_DSP_RESET_WAIT_TIME);
 
 	chip->regCDSP |= VX_CDSP_DSP_RESET_MASK;
 	/* set the reset dsp bit to 1 */
@@ -362,10 +362,10 @@ static int vx2_load_xilinx_binary(vx_core_t *chip, const struct firmware *xilinx
 	/* XILINX reset (wait at least 1 milisecond between reset on and off). */
 	vx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE | VX_XILINX_RESET_MASK);
 	vx_inl(chip, CNTRL);
-	snd_vx_delay(chip, 10);
+	msleep(10);
 	vx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE);
 	vx_inl(chip, CNTRL);
-	snd_vx_delay(chip, 10);
+	msleep(10);
 
 	if (chip->type == VX_TYPE_BOARD)
 		port = VX_CNTRL;
@@ -381,7 +381,7 @@ static int vx2_load_xilinx_binary(vx_core_t *chip, const struct firmware *xilinx
 	}
 	put_xilinx_data(chip, port, 4, 0xff); /* end signature */
 
-	snd_vx_delay(chip, 200);
+	msleep(200);
 
 	/* test after loading (is buggy with VX222) */
 	if (chip->type != VX_TYPE_BOARD) {
@@ -720,17 +720,17 @@ static void vx2_reset_codec(vx_core_t *_chip)
 	/* Set the reset CODEC bit to 0. */
 	vx_outl(chip, CDSP, chip->regCDSP &~ VX_CDSP_CODEC_RESET_MASK);
 	vx_inl(chip, CDSP);
-	snd_vx_delay(_chip, 10);
+	msleep(10);
 	/* Set the reset CODEC bit to 1. */
 	chip->regCDSP |= VX_CDSP_CODEC_RESET_MASK;
 	vx_outl(chip, CDSP, chip->regCDSP);
 	vx_inl(chip, CDSP);
 	if (_chip->type == VX_TYPE_BOARD) {
-		snd_vx_delay(_chip, 1);
+		msleep(1);
 		return;
 	}
 
-	snd_vx_delay(_chip, 5);  /* additionnel wait time for AKM's */
+	msleep(5);  /* additionnel wait time for AKM's */
 
 	vx2_write_codec_reg(_chip, AKM_CODEC_POWER_CONTROL_CMD); /* DAC power up, ADC power up, Vref power down */
 	

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
index 683e9799976f..967bd5e6b23c 100644
--- a/sound/pci/vx222/vx222_ops.c
+++ b/sound/pci/vx222/vx222_ops.c
@@ -82,7 +82,7 @@ static int vx2_reg_index[VX_REG_MAX] = {
 	[VX_GPIOC]	= 0,	/* on the PLX */
 };
 
-inline static unsigned long vx2_reg_addr(vx_core_t *_chip, int reg)
+static inline unsigned long vx2_reg_addr(vx_core_t *_chip, int reg)
 {
 	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
 	return chip->port[vx2_reg_index[reg]] + vx2_reg_offset[reg];
@@ -235,7 +235,7 @@ static void vx2_setup_pseudo_dma(vx_core_t *chip, int do_write)
 /*
  * vx_release_pseudo_dma - disable the pseudo-DMA mode
  */
-inline static void vx2_release_pseudo_dma(vx_core_t *chip)
+static inline void vx2_release_pseudo_dma(vx_core_t *chip)
 {
 	/* HREQ pin disabled. */
 	vx_outl(chip, ICR, 0);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/vx222/vx222_ops.c b/sound/pci/vx222/vx222_ops.c
new file mode 100644
index 000000000000..683e9799976f
--- /dev/null
+++ b/sound/pci/vx222/vx222_ops.c
@@ -0,0 +1,1004 @@
+/*
+ * Driver for Digigram VX222 V2/Mic soundcards
+ *
+ * VX222-specific low-level routines
+ *
+ * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <asm/io.h>
+#include "vx222.h"
+
+
+static int vx2_reg_offset[VX_REG_MAX] = {
+	[VX_ICR]    = 0x00,
+	[VX_CVR]    = 0x04,
+	[VX_ISR]    = 0x08,
+	[VX_IVR]    = 0x0c,
+	[VX_RXH]    = 0x14,
+	[VX_RXM]    = 0x18,
+	[VX_RXL]    = 0x1c,
+	[VX_DMA]    = 0x10,
+	[VX_CDSP]   = 0x20,
+	[VX_CFG]    = 0x24,
+	[VX_RUER]   = 0x28,
+	[VX_DATA]   = 0x2c,
+	[VX_STATUS] = 0x30,
+	[VX_LOFREQ] = 0x34,
+	[VX_HIFREQ] = 0x38,
+	[VX_CSUER]  = 0x3c,
+	[VX_SELMIC] = 0x40,
+	[VX_COMPOT] = 0x44, // Write: POTENTIOMETER ; Read: COMPRESSION LEVEL activate
+	[VX_SCOMPR] = 0x48, // Read: COMPRESSION THRESHOLD activate
+	[VX_GLIMIT] = 0x4c, // Read: LEVEL LIMITATION activate
+	[VX_INTCSR] = 0x4c, // VX_INTCSR_REGISTER_OFFSET
+	[VX_CNTRL]  = 0x50,		// VX_CNTRL_REGISTER_OFFSET
+	[VX_GPIOC]  = 0x54,		// VX_GPIOC (new with PLX9030)
+};
+
+static int vx2_reg_index[VX_REG_MAX] = {
+	[VX_ICR]	= 1,
+	[VX_CVR]	= 1,
+	[VX_ISR]	= 1,
+	[VX_IVR]	= 1,
+	[VX_RXH]	= 1,
+	[VX_RXM]	= 1,
+	[VX_RXL]	= 1,
+	[VX_DMA]	= 1,
+	[VX_CDSP]	= 1,
+	[VX_CFG]	= 1,
+	[VX_RUER]	= 1,
+	[VX_DATA]	= 1,
+	[VX_STATUS]	= 1,
+	[VX_LOFREQ]	= 1,
+	[VX_HIFREQ]	= 1,
+	[VX_CSUER]	= 1,
+	[VX_SELMIC]	= 1,
+	[VX_COMPOT]	= 1,
+	[VX_SCOMPR]	= 1,
+	[VX_GLIMIT]	= 1,
+	[VX_INTCSR]	= 0,	/* on the PLX */
+	[VX_CNTRL]	= 0,	/* on the PLX */
+	[VX_GPIOC]	= 0,	/* on the PLX */
+};
+
+inline static unsigned long vx2_reg_addr(vx_core_t *_chip, int reg)
+{
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	return chip->port[vx2_reg_index[reg]] + vx2_reg_offset[reg];
+}
+
+/**
+ * snd_vx_inb - read a byte from the register
+ * @offset: register enum
+ */
+static unsigned char vx2_inb(vx_core_t *chip, int offset)
+{
+	return inb(vx2_reg_addr(chip, offset));
+}
+
+/**
+ * snd_vx_outb - write a byte on the register
+ * @offset: the register offset
+ * @val: the value to write
+ */
+static void vx2_outb(vx_core_t *chip, int offset, unsigned char val)
+{
+	outb(val, vx2_reg_addr(chip, offset));
+	//printk("outb: %x -> %x\n", val, vx2_reg_addr(chip, offset));
+}
+
+/**
+ * snd_vx_inl - read a 32bit word from the register
+ * @offset: register enum
+ */
+static unsigned int vx2_inl(vx_core_t *chip, int offset)
+{
+	return inl(vx2_reg_addr(chip, offset));
+}
+
+/**
+ * snd_vx_outl - write a 32bit word on the register
+ * @offset: the register enum
+ * @val: the value to write
+ */
+static void vx2_outl(vx_core_t *chip, int offset, unsigned int val)
+{
+	// printk("outl: %x -> %x\n", val, vx2_reg_addr(chip, offset));
+	outl(val, vx2_reg_addr(chip, offset));
+}
+
+/*
+ * redefine macros to call directly
+ */
+#undef vx_inb
+#define vx_inb(chip,reg)	vx2_inb((vx_core_t*)(chip), VX_##reg)
+#undef vx_outb
+#define vx_outb(chip,reg,val)	vx2_outb((vx_core_t*)(chip), VX_##reg, val)
+#undef vx_inl
+#define vx_inl(chip,reg)	vx2_inl((vx_core_t*)(chip), VX_##reg)
+#undef vx_outl
+#define vx_outl(chip,reg,val)	vx2_outl((vx_core_t*)(chip), VX_##reg, val)
+
+
+/*
+ * vx_reset_dsp - reset the DSP
+ */
+
+#define XX_DSP_RESET_WAIT_TIME		2	/* ms */
+
+static void vx2_reset_dsp(vx_core_t *_chip)
+{
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+
+	/* set the reset dsp bit to 0 */
+	vx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_DSP_RESET_MASK);
+
+	snd_vx_delay(_chip, XX_DSP_RESET_WAIT_TIME);
+
+	chip->regCDSP |= VX_CDSP_DSP_RESET_MASK;
+	/* set the reset dsp bit to 1 */
+	vx_outl(chip, CDSP, chip->regCDSP);
+}
+
+
+static int vx2_test_xilinx(vx_core_t *_chip)
+{
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	unsigned int data;
+
+	snd_printdd("testing xilinx...\n");
+	/* This test uses several write/read sequences on TEST0 and TEST1 bits
+	 * to figure out whever or not the xilinx was correctly loaded
+	 */
+
+	/* We write 1 on CDSP.TEST0. We should get 0 on STATUS.TEST0. */
+	vx_outl(chip, CDSP, chip->regCDSP | VX_CDSP_TEST0_MASK);
+	vx_inl(chip, ISR);
+	data = vx_inl(chip, STATUS);
+	if ((data & VX_STATUS_VAL_TEST0_MASK) == VX_STATUS_VAL_TEST0_MASK) {
+		snd_printdd("bad!\n");
+		return -ENODEV;
+	}
+
+	/* We write 0 on CDSP.TEST0. We should get 1 on STATUS.TEST0. */
+	vx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_TEST0_MASK);
+	vx_inl(chip, ISR);
+	data = vx_inl(chip, STATUS);
+	if (! (data & VX_STATUS_VAL_TEST0_MASK)) {
+		snd_printdd("bad! #2\n");
+		return -ENODEV;
+	}
+
+	if (_chip->type == VX_TYPE_BOARD) {
+		/* not implemented on VX_2_BOARDS */
+		/* We write 1 on CDSP.TEST1. We should get 0 on STATUS.TEST1. */
+		vx_outl(chip, CDSP, chip->regCDSP | VX_CDSP_TEST1_MASK);
+		vx_inl(chip, ISR);
+		data = vx_inl(chip, STATUS);
+		if ((data & VX_STATUS_VAL_TEST1_MASK) == VX_STATUS_VAL_TEST1_MASK) {
+			snd_printdd("bad! #3\n");
+			return -ENODEV;
+		}
+
+		/* We write 0 on CDSP.TEST1. We should get 1 on STATUS.TEST1. */
+		vx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_TEST1_MASK);
+		vx_inl(chip, ISR);
+		data = vx_inl(chip, STATUS);
+		if (! (data & VX_STATUS_VAL_TEST1_MASK)) {
+			snd_printdd("bad! #4\n");
+			return -ENODEV;
+		}
+	}
+	snd_printdd("ok, xilinx fine.\n");
+	return 0;
+}
+
+
+/**
+ * vx_setup_pseudo_dma - set up the pseudo dma read/write mode.
+ * @do_write: 0 = read, 1 = set up for DMA write
+ */
+static void vx2_setup_pseudo_dma(vx_core_t *chip, int do_write)
+{
+	/* Interrupt mode and HREQ pin enabled for host transmit data transfers
+	 * (in case of the use of the pseudo-dma facility).
+	 */
+	vx_outl(chip, ICR, do_write ? ICR_TREQ : ICR_RREQ);
+
+	/* Reset the pseudo-dma register (in case of the use of the
+	 * pseudo-dma facility).
+	 */
+	vx_outl(chip, RESET_DMA, 0);
+}
+
+/*
+ * vx_release_pseudo_dma - disable the pseudo-DMA mode
+ */
+inline static void vx2_release_pseudo_dma(vx_core_t *chip)
+{
+	/* HREQ pin disabled. */
+	vx_outl(chip, ICR, 0);
+}
+
+
+
+/* pseudo-dma write */
+static void vx2_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+			  vx_pipe_t *pipe, int count)
+{
+	unsigned long port = vx2_reg_addr(chip, VX_DMA);
+	int offset = pipe->hw_ptr;
+	u32 *addr = (u32 *)(runtime->dma_area + offset);
+
+	snd_assert(count % 4 == 0, return);
+
+	vx2_setup_pseudo_dma(chip, 1);
+
+	/* Transfer using pseudo-dma.
+	 */
+	if (offset + count > pipe->buffer_bytes) {
+		int length = pipe->buffer_bytes - offset;
+		count -= length;
+		length >>= 2; /* in 32bit words */
+		/* Transfer using pseudo-dma. */
+		while (length-- > 0) {
+			outl(cpu_to_le32(*addr), port);
+			addr++;
+		}
+		addr = (u32 *)runtime->dma_area;
+		pipe->hw_ptr = 0;
+	}
+	pipe->hw_ptr += count;
+	count >>= 2; /* in 32bit words */
+	/* Transfer using pseudo-dma. */
+	while (count-- > 0) {
+		outl(cpu_to_le32(*addr), port);
+		addr++;
+	}
+
+	vx2_release_pseudo_dma(chip);
+}
+
+
+/* pseudo dma read */
+static void vx2_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+			 vx_pipe_t *pipe, int count)
+{
+	int offset = pipe->hw_ptr;
+	u32 *addr = (u32 *)(runtime->dma_area + offset);
+	unsigned long port = vx2_reg_addr(chip, VX_DMA);
+
+	snd_assert(count % 4 == 0, return);
+
+	vx2_setup_pseudo_dma(chip, 0);
+	/* Transfer using pseudo-dma.
+	 */
+	if (offset + count > pipe->buffer_bytes) {
+		int length = pipe->buffer_bytes - offset;
+		count -= length;
+		length >>= 2; /* in 32bit words */
+		/* Transfer using pseudo-dma. */
+		while (length-- > 0)
+			*addr++ = le32_to_cpu(inl(port));
+		addr = (u32 *)runtime->dma_area;
+		pipe->hw_ptr = 0;
+	}
+	pipe->hw_ptr += count;
+	count >>= 2; /* in 32bit words */
+	/* Transfer using pseudo-dma. */
+	while (count-- > 0)
+		*addr++ = le32_to_cpu(inl(port));
+
+	vx2_release_pseudo_dma(chip);
+}
+
+#define VX_XILINX_RESET_MASK        0x40000000
+#define VX_USERBIT0_MASK            0x00000004
+#define VX_USERBIT1_MASK            0x00000020
+#define VX_CNTRL_REGISTER_VALUE     0x00172012
+
+/*
+ * transfer counts bits to PLX
+ */
+static int put_xilinx_data(vx_core_t *chip, unsigned int port, unsigned int counts, unsigned char data)
+{
+	unsigned int i;
+
+	for (i = 0; i < counts; i++) {
+		unsigned int val;
+
+		/* set the clock bit to 0. */
+		val = VX_CNTRL_REGISTER_VALUE & ~VX_USERBIT0_MASK;
+		vx2_outl(chip, port, val);
+		vx2_inl(chip, port);
+		udelay(1);
+
+		if (data & (1 << i))
+			val |= VX_USERBIT1_MASK;
+		else
+			val &= ~VX_USERBIT1_MASK;
+		vx2_outl(chip, port, val);
+		vx2_inl(chip, port);
+
+		/* set the clock bit to 1. */
+		val |= VX_USERBIT0_MASK;
+		vx2_outl(chip, port, val);
+		vx2_inl(chip, port);
+		udelay(1);
+	}
+	return 0;
+}
+
+/*
+ * load the xilinx image
+ */
+static int vx2_load_xilinx_binary(vx_core_t *chip, const struct firmware *xilinx)
+{
+	unsigned int i;
+	unsigned int port;
+	unsigned char *image;
+
+	/* XILINX reset (wait at least 1 milisecond between reset on and off). */
+	vx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE | VX_XILINX_RESET_MASK);
+	vx_inl(chip, CNTRL);
+	snd_vx_delay(chip, 10);
+	vx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE);
+	vx_inl(chip, CNTRL);
+	snd_vx_delay(chip, 10);
+
+	if (chip->type == VX_TYPE_BOARD)
+		port = VX_CNTRL;
+	else
+		port = VX_GPIOC; /* VX222 V2 and VX222_MIC_BOARD with new PLX9030 use this register */
+
+	image = xilinx->data;
+	for (i = 0; i < xilinx->size; i++, image++) {
+		if (put_xilinx_data(chip, port, 8, *image) < 0)
+			return -EINVAL;
+		/* don't take too much time in this loop... */
+		cond_resched();
+	}
+	put_xilinx_data(chip, port, 4, 0xff); /* end signature */
+
+	snd_vx_delay(chip, 200);
+
+	/* test after loading (is buggy with VX222) */
+	if (chip->type != VX_TYPE_BOARD) {
+		/* Test if load successful: test bit 8 of register GPIOC (VX222: use CNTRL) ! */
+		i = vx_inl(chip, GPIOC);
+		if (i & 0x0100)
+			return 0;
+		snd_printk(KERN_ERR "vx222: xilinx test failed after load, GPIOC=0x%x\n", i);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+	
+/*
+ * load the boot/dsp images
+ */
+static int vx2_load_dsp(vx_core_t *vx, int index, const struct firmware *dsp)
+{
+	int err;
+
+	switch (index) {
+	case 1:
+		/* xilinx image */
+		if ((err = vx2_load_xilinx_binary(vx, dsp)) < 0)
+			return err;
+		if ((err = vx2_test_xilinx(vx)) < 0)
+			return err;
+		return 0;
+	case 2:
+		/* DSP boot */
+		return snd_vx_dsp_boot(vx, dsp);
+	case 3:
+		/* DSP image */
+		return snd_vx_dsp_load(vx, dsp);
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
+}
+
+
+/*
+ * vx_test_and_ack - test and acknowledge interrupt
+ *
+ * called from irq hander, too
+ *
+ * spinlock held!
+ */
+static int vx2_test_and_ack(vx_core_t *chip)
+{
+	/* not booted yet? */
+	if (! (chip->chip_status & VX_STAT_XILINX_LOADED))
+		return -ENXIO;
+
+	if (! (vx_inl(chip, STATUS) & VX_STATUS_MEMIRQ_MASK))
+		return -EIO;
+	
+	/* ok, interrupts generated, now ack it */
+	/* set ACQUIT bit up and down */
+	vx_outl(chip, STATUS, 0);
+	/* useless read just to spend some time and maintain
+	 * the ACQUIT signal up for a while ( a bus cycle )
+	 */
+	vx_inl(chip, STATUS);
+	/* ack */
+	vx_outl(chip, STATUS, VX_STATUS_MEMIRQ_MASK);
+	/* useless read just to spend some time and maintain
+	 * the ACQUIT signal up for a while ( a bus cycle ) */
+	vx_inl(chip, STATUS);
+	/* clear */
+	vx_outl(chip, STATUS, 0);
+
+	return 0;
+}
+
+
+/*
+ * vx_validate_irq - enable/disable IRQ
+ */
+static void vx2_validate_irq(vx_core_t *_chip, int enable)
+{
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+
+	/* Set the interrupt enable bit to 1 in CDSP register */
+	if (enable) {
+		/* Set the PCI interrupt enable bit to 1.*/
+		vx_outl(chip, INTCSR, VX_INTCSR_VALUE|VX_PCI_INTERRUPT_MASK);
+		chip->regCDSP |= VX_CDSP_VALID_IRQ_MASK;
+	} else {
+		/* Set the PCI interrupt enable bit to 0. */
+		vx_outl(chip, INTCSR, VX_INTCSR_VALUE&~VX_PCI_INTERRUPT_MASK);
+		chip->regCDSP &= ~VX_CDSP_VALID_IRQ_MASK;
+	}
+	vx_outl(chip, CDSP, chip->regCDSP);
+}
+
+
+/*
+ * write an AKM codec data (24bit)
+ */
+static void vx2_write_codec_reg(vx_core_t *chip, unsigned int data)
+{
+	unsigned int i;
+
+	vx_inl(chip, HIFREQ);
+
+	/* We have to send 24 bits (3 x 8 bits). Start with most signif. Bit */
+	for (i = 0; i < 24; i++, data <<= 1)
+		vx_outl(chip, DATA, ((data & 0x800000) ? VX_DATA_CODEC_MASK : 0));
+	/* Terminate access to codec registers */
+	vx_inl(chip, RUER);
+}
+
+
+#define AKM_CODEC_POWER_CONTROL_CMD 0xA007
+#define AKM_CODEC_RESET_ON_CMD      0xA100
+#define AKM_CODEC_RESET_OFF_CMD     0xA103
+#define AKM_CODEC_CLOCK_FORMAT_CMD  0xA240
+#define AKM_CODEC_MUTE_CMD          0xA38D
+#define AKM_CODEC_UNMUTE_CMD        0xA30D
+#define AKM_CODEC_LEFT_LEVEL_CMD    0xA400
+#define AKM_CODEC_RIGHT_LEVEL_CMD   0xA500
+
+static const u8 vx2_akm_gains_lut[VX2_AKM_LEVEL_MAX+1] = {
+    0x7f,       // [000] =  +0.000 dB  ->  AKM(0x7f) =  +0.000 dB  error(+0.000 dB)
+    0x7d,       // [001] =  -0.500 dB  ->  AKM(0x7d) =  -0.572 dB  error(-0.072 dB)
+    0x7c,       // [002] =  -1.000 dB  ->  AKM(0x7c) =  -0.873 dB  error(+0.127 dB)
+    0x7a,       // [003] =  -1.500 dB  ->  AKM(0x7a) =  -1.508 dB  error(-0.008 dB)
+    0x79,       // [004] =  -2.000 dB  ->  AKM(0x79) =  -1.844 dB  error(+0.156 dB)
+    0x77,       // [005] =  -2.500 dB  ->  AKM(0x77) =  -2.557 dB  error(-0.057 dB)
+    0x76,       // [006] =  -3.000 dB  ->  AKM(0x76) =  -2.937 dB  error(+0.063 dB)
+    0x75,       // [007] =  -3.500 dB  ->  AKM(0x75) =  -3.334 dB  error(+0.166 dB)
+    0x73,       // [008] =  -4.000 dB  ->  AKM(0x73) =  -4.188 dB  error(-0.188 dB)
+    0x72,       // [009] =  -4.500 dB  ->  AKM(0x72) =  -4.648 dB  error(-0.148 dB)
+    0x71,       // [010] =  -5.000 dB  ->  AKM(0x71) =  -5.134 dB  error(-0.134 dB)
+    0x70,       // [011] =  -5.500 dB  ->  AKM(0x70) =  -5.649 dB  error(-0.149 dB)
+    0x6f,       // [012] =  -6.000 dB  ->  AKM(0x6f) =  -6.056 dB  error(-0.056 dB)
+    0x6d,       // [013] =  -6.500 dB  ->  AKM(0x6d) =  -6.631 dB  error(-0.131 dB)
+    0x6c,       // [014] =  -7.000 dB  ->  AKM(0x6c) =  -6.933 dB  error(+0.067 dB)
+    0x6a,       // [015] =  -7.500 dB  ->  AKM(0x6a) =  -7.571 dB  error(-0.071 dB)
+    0x69,       // [016] =  -8.000 dB  ->  AKM(0x69) =  -7.909 dB  error(+0.091 dB)
+    0x67,       // [017] =  -8.500 dB  ->  AKM(0x67) =  -8.626 dB  error(-0.126 dB)
+    0x66,       // [018] =  -9.000 dB  ->  AKM(0x66) =  -9.008 dB  error(-0.008 dB)
+    0x65,       // [019] =  -9.500 dB  ->  AKM(0x65) =  -9.407 dB  error(+0.093 dB)
+    0x64,       // [020] = -10.000 dB  ->  AKM(0x64) =  -9.826 dB  error(+0.174 dB)
+    0x62,       // [021] = -10.500 dB  ->  AKM(0x62) = -10.730 dB  error(-0.230 dB)
+    0x61,       // [022] = -11.000 dB  ->  AKM(0x61) = -11.219 dB  error(-0.219 dB)
+    0x60,       // [023] = -11.500 dB  ->  AKM(0x60) = -11.738 dB  error(-0.238 dB)
+    0x5f,       // [024] = -12.000 dB  ->  AKM(0x5f) = -12.149 dB  error(-0.149 dB)
+    0x5e,       // [025] = -12.500 dB  ->  AKM(0x5e) = -12.434 dB  error(+0.066 dB)
+    0x5c,       // [026] = -13.000 dB  ->  AKM(0x5c) = -13.033 dB  error(-0.033 dB)
+    0x5b,       // [027] = -13.500 dB  ->  AKM(0x5b) = -13.350 dB  error(+0.150 dB)
+    0x59,       // [028] = -14.000 dB  ->  AKM(0x59) = -14.018 dB  error(-0.018 dB)
+    0x58,       // [029] = -14.500 dB  ->  AKM(0x58) = -14.373 dB  error(+0.127 dB)
+    0x56,       // [030] = -15.000 dB  ->  AKM(0x56) = -15.130 dB  error(-0.130 dB)
+    0x55,       // [031] = -15.500 dB  ->  AKM(0x55) = -15.534 dB  error(-0.034 dB)
+    0x54,       // [032] = -16.000 dB  ->  AKM(0x54) = -15.958 dB  error(+0.042 dB)
+    0x53,       // [033] = -16.500 dB  ->  AKM(0x53) = -16.404 dB  error(+0.096 dB)
+    0x52,       // [034] = -17.000 dB  ->  AKM(0x52) = -16.874 dB  error(+0.126 dB)
+    0x51,       // [035] = -17.500 dB  ->  AKM(0x51) = -17.371 dB  error(+0.129 dB)
+    0x50,       // [036] = -18.000 dB  ->  AKM(0x50) = -17.898 dB  error(+0.102 dB)
+    0x4e,       // [037] = -18.500 dB  ->  AKM(0x4e) = -18.605 dB  error(-0.105 dB)
+    0x4d,       // [038] = -19.000 dB  ->  AKM(0x4d) = -18.905 dB  error(+0.095 dB)
+    0x4b,       // [039] = -19.500 dB  ->  AKM(0x4b) = -19.538 dB  error(-0.038 dB)
+    0x4a,       // [040] = -20.000 dB  ->  AKM(0x4a) = -19.872 dB  error(+0.128 dB)
+    0x48,       // [041] = -20.500 dB  ->  AKM(0x48) = -20.583 dB  error(-0.083 dB)
+    0x47,       // [042] = -21.000 dB  ->  AKM(0x47) = -20.961 dB  error(+0.039 dB)
+    0x46,       // [043] = -21.500 dB  ->  AKM(0x46) = -21.356 dB  error(+0.144 dB)
+    0x44,       // [044] = -22.000 dB  ->  AKM(0x44) = -22.206 dB  error(-0.206 dB)
+    0x43,       // [045] = -22.500 dB  ->  AKM(0x43) = -22.664 dB  error(-0.164 dB)
+    0x42,       // [046] = -23.000 dB  ->  AKM(0x42) = -23.147 dB  error(-0.147 dB)
+    0x41,       // [047] = -23.500 dB  ->  AKM(0x41) = -23.659 dB  error(-0.159 dB)
+    0x40,       // [048] = -24.000 dB  ->  AKM(0x40) = -24.203 dB  error(-0.203 dB)
+    0x3f,       // [049] = -24.500 dB  ->  AKM(0x3f) = -24.635 dB  error(-0.135 dB)
+    0x3e,       // [050] = -25.000 dB  ->  AKM(0x3e) = -24.935 dB  error(+0.065 dB)
+    0x3c,       // [051] = -25.500 dB  ->  AKM(0x3c) = -25.569 dB  error(-0.069 dB)
+    0x3b,       // [052] = -26.000 dB  ->  AKM(0x3b) = -25.904 dB  error(+0.096 dB)
+    0x39,       // [053] = -26.500 dB  ->  AKM(0x39) = -26.615 dB  error(-0.115 dB)
+    0x38,       // [054] = -27.000 dB  ->  AKM(0x38) = -26.994 dB  error(+0.006 dB)
+    0x37,       // [055] = -27.500 dB  ->  AKM(0x37) = -27.390 dB  error(+0.110 dB)
+    0x36,       // [056] = -28.000 dB  ->  AKM(0x36) = -27.804 dB  error(+0.196 dB)
+    0x34,       // [057] = -28.500 dB  ->  AKM(0x34) = -28.699 dB  error(-0.199 dB)
+    0x33,       // [058] = -29.000 dB  ->  AKM(0x33) = -29.183 dB  error(-0.183 dB)
+    0x32,       // [059] = -29.500 dB  ->  AKM(0x32) = -29.696 dB  error(-0.196 dB)
+    0x31,       // [060] = -30.000 dB  ->  AKM(0x31) = -30.241 dB  error(-0.241 dB)
+    0x31,       // [061] = -30.500 dB  ->  AKM(0x31) = -30.241 dB  error(+0.259 dB)
+    0x30,       // [062] = -31.000 dB  ->  AKM(0x30) = -30.823 dB  error(+0.177 dB)
+    0x2e,       // [063] = -31.500 dB  ->  AKM(0x2e) = -31.610 dB  error(-0.110 dB)
+    0x2d,       // [064] = -32.000 dB  ->  AKM(0x2d) = -31.945 dB  error(+0.055 dB)
+    0x2b,       // [065] = -32.500 dB  ->  AKM(0x2b) = -32.659 dB  error(-0.159 dB)
+    0x2a,       // [066] = -33.000 dB  ->  AKM(0x2a) = -33.038 dB  error(-0.038 dB)
+    0x29,       // [067] = -33.500 dB  ->  AKM(0x29) = -33.435 dB  error(+0.065 dB)
+    0x28,       // [068] = -34.000 dB  ->  AKM(0x28) = -33.852 dB  error(+0.148 dB)
+    0x27,       // [069] = -34.500 dB  ->  AKM(0x27) = -34.289 dB  error(+0.211 dB)
+    0x25,       // [070] = -35.000 dB  ->  AKM(0x25) = -35.235 dB  error(-0.235 dB)
+    0x24,       // [071] = -35.500 dB  ->  AKM(0x24) = -35.750 dB  error(-0.250 dB)
+    0x24,       // [072] = -36.000 dB  ->  AKM(0x24) = -35.750 dB  error(+0.250 dB)
+    0x23,       // [073] = -36.500 dB  ->  AKM(0x23) = -36.297 dB  error(+0.203 dB)
+    0x22,       // [074] = -37.000 dB  ->  AKM(0x22) = -36.881 dB  error(+0.119 dB)
+    0x21,       // [075] = -37.500 dB  ->  AKM(0x21) = -37.508 dB  error(-0.008 dB)
+    0x20,       // [076] = -38.000 dB  ->  AKM(0x20) = -38.183 dB  error(-0.183 dB)
+    0x1f,       // [077] = -38.500 dB  ->  AKM(0x1f) = -38.726 dB  error(-0.226 dB)
+    0x1e,       // [078] = -39.000 dB  ->  AKM(0x1e) = -39.108 dB  error(-0.108 dB)
+    0x1d,       // [079] = -39.500 dB  ->  AKM(0x1d) = -39.507 dB  error(-0.007 dB)
+    0x1c,       // [080] = -40.000 dB  ->  AKM(0x1c) = -39.926 dB  error(+0.074 dB)
+    0x1b,       // [081] = -40.500 dB  ->  AKM(0x1b) = -40.366 dB  error(+0.134 dB)
+    0x1a,       // [082] = -41.000 dB  ->  AKM(0x1a) = -40.829 dB  error(+0.171 dB)
+    0x19,       // [083] = -41.500 dB  ->  AKM(0x19) = -41.318 dB  error(+0.182 dB)
+    0x18,       // [084] = -42.000 dB  ->  AKM(0x18) = -41.837 dB  error(+0.163 dB)
+    0x17,       // [085] = -42.500 dB  ->  AKM(0x17) = -42.389 dB  error(+0.111 dB)
+    0x16,       // [086] = -43.000 dB  ->  AKM(0x16) = -42.978 dB  error(+0.022 dB)
+    0x15,       // [087] = -43.500 dB  ->  AKM(0x15) = -43.610 dB  error(-0.110 dB)
+    0x14,       // [088] = -44.000 dB  ->  AKM(0x14) = -44.291 dB  error(-0.291 dB)
+    0x14,       // [089] = -44.500 dB  ->  AKM(0x14) = -44.291 dB  error(+0.209 dB)
+    0x13,       // [090] = -45.000 dB  ->  AKM(0x13) = -45.031 dB  error(-0.031 dB)
+    0x12,       // [091] = -45.500 dB  ->  AKM(0x12) = -45.840 dB  error(-0.340 dB)
+    0x12,       // [092] = -46.000 dB  ->  AKM(0x12) = -45.840 dB  error(+0.160 dB)
+    0x11,       // [093] = -46.500 dB  ->  AKM(0x11) = -46.731 dB  error(-0.231 dB)
+    0x11,       // [094] = -47.000 dB  ->  AKM(0x11) = -46.731 dB  error(+0.269 dB)
+    0x10,       // [095] = -47.500 dB  ->  AKM(0x10) = -47.725 dB  error(-0.225 dB)
+    0x10,       // [096] = -48.000 dB  ->  AKM(0x10) = -47.725 dB  error(+0.275 dB)
+    0x0f,       // [097] = -48.500 dB  ->  AKM(0x0f) = -48.553 dB  error(-0.053 dB)
+    0x0e,       // [098] = -49.000 dB  ->  AKM(0x0e) = -49.152 dB  error(-0.152 dB)
+    0x0d,       // [099] = -49.500 dB  ->  AKM(0x0d) = -49.796 dB  error(-0.296 dB)
+    0x0d,       // [100] = -50.000 dB  ->  AKM(0x0d) = -49.796 dB  error(+0.204 dB)
+    0x0c,       // [101] = -50.500 dB  ->  AKM(0x0c) = -50.491 dB  error(+0.009 dB)
+    0x0b,       // [102] = -51.000 dB  ->  AKM(0x0b) = -51.247 dB  error(-0.247 dB)
+    0x0b,       // [103] = -51.500 dB  ->  AKM(0x0b) = -51.247 dB  error(+0.253 dB)
+    0x0a,       // [104] = -52.000 dB  ->  AKM(0x0a) = -52.075 dB  error(-0.075 dB)
+    0x0a,       // [105] = -52.500 dB  ->  AKM(0x0a) = -52.075 dB  error(+0.425 dB)
+    0x09,       // [106] = -53.000 dB  ->  AKM(0x09) = -52.990 dB  error(+0.010 dB)
+    0x09,       // [107] = -53.500 dB  ->  AKM(0x09) = -52.990 dB  error(+0.510 dB)
+    0x08,       // [108] = -54.000 dB  ->  AKM(0x08) = -54.013 dB  error(-0.013 dB)
+    0x08,       // [109] = -54.500 dB  ->  AKM(0x08) = -54.013 dB  error(+0.487 dB)
+    0x07,       // [110] = -55.000 dB  ->  AKM(0x07) = -55.173 dB  error(-0.173 dB)
+    0x07,       // [111] = -55.500 dB  ->  AKM(0x07) = -55.173 dB  error(+0.327 dB)
+    0x06,       // [112] = -56.000 dB  ->  AKM(0x06) = -56.512 dB  error(-0.512 dB)
+    0x06,       // [113] = -56.500 dB  ->  AKM(0x06) = -56.512 dB  error(-0.012 dB)
+    0x06,       // [114] = -57.000 dB  ->  AKM(0x06) = -56.512 dB  error(+0.488 dB)
+    0x05,       // [115] = -57.500 dB  ->  AKM(0x05) = -58.095 dB  error(-0.595 dB)
+    0x05,       // [116] = -58.000 dB  ->  AKM(0x05) = -58.095 dB  error(-0.095 dB)
+    0x05,       // [117] = -58.500 dB  ->  AKM(0x05) = -58.095 dB  error(+0.405 dB)
+    0x05,       // [118] = -59.000 dB  ->  AKM(0x05) = -58.095 dB  error(+0.905 dB)
+    0x04,       // [119] = -59.500 dB  ->  AKM(0x04) = -60.034 dB  error(-0.534 dB)
+    0x04,       // [120] = -60.000 dB  ->  AKM(0x04) = -60.034 dB  error(-0.034 dB)
+    0x04,       // [121] = -60.500 dB  ->  AKM(0x04) = -60.034 dB  error(+0.466 dB)
+    0x04,       // [122] = -61.000 dB  ->  AKM(0x04) = -60.034 dB  error(+0.966 dB)
+    0x03,       // [123] = -61.500 dB  ->  AKM(0x03) = -62.532 dB  error(-1.032 dB)
+    0x03,       // [124] = -62.000 dB  ->  AKM(0x03) = -62.532 dB  error(-0.532 dB)
+    0x03,       // [125] = -62.500 dB  ->  AKM(0x03) = -62.532 dB  error(-0.032 dB)
+    0x03,       // [126] = -63.000 dB  ->  AKM(0x03) = -62.532 dB  error(+0.468 dB)
+    0x03,       // [127] = -63.500 dB  ->  AKM(0x03) = -62.532 dB  error(+0.968 dB)
+    0x03,       // [128] = -64.000 dB  ->  AKM(0x03) = -62.532 dB  error(+1.468 dB)
+    0x02,       // [129] = -64.500 dB  ->  AKM(0x02) = -66.054 dB  error(-1.554 dB)
+    0x02,       // [130] = -65.000 dB  ->  AKM(0x02) = -66.054 dB  error(-1.054 dB)
+    0x02,       // [131] = -65.500 dB  ->  AKM(0x02) = -66.054 dB  error(-0.554 dB)
+    0x02,       // [132] = -66.000 dB  ->  AKM(0x02) = -66.054 dB  error(-0.054 dB)
+    0x02,       // [133] = -66.500 dB  ->  AKM(0x02) = -66.054 dB  error(+0.446 dB)
+    0x02,       // [134] = -67.000 dB  ->  AKM(0x02) = -66.054 dB  error(+0.946 dB)
+    0x02,       // [135] = -67.500 dB  ->  AKM(0x02) = -66.054 dB  error(+1.446 dB)
+    0x02,       // [136] = -68.000 dB  ->  AKM(0x02) = -66.054 dB  error(+1.946 dB)
+    0x02,       // [137] = -68.500 dB  ->  AKM(0x02) = -66.054 dB  error(+2.446 dB)
+    0x02,       // [138] = -69.000 dB  ->  AKM(0x02) = -66.054 dB  error(+2.946 dB)
+    0x01,       // [139] = -69.500 dB  ->  AKM(0x01) = -72.075 dB  error(-2.575 dB)
+    0x01,       // [140] = -70.000 dB  ->  AKM(0x01) = -72.075 dB  error(-2.075 dB)
+    0x01,       // [141] = -70.500 dB  ->  AKM(0x01) = -72.075 dB  error(-1.575 dB)
+    0x01,       // [142] = -71.000 dB  ->  AKM(0x01) = -72.075 dB  error(-1.075 dB)
+    0x01,       // [143] = -71.500 dB  ->  AKM(0x01) = -72.075 dB  error(-0.575 dB)
+    0x01,       // [144] = -72.000 dB  ->  AKM(0x01) = -72.075 dB  error(-0.075 dB)
+    0x01,       // [145] = -72.500 dB  ->  AKM(0x01) = -72.075 dB  error(+0.425 dB)
+    0x01,       // [146] = -73.000 dB  ->  AKM(0x01) = -72.075 dB  error(+0.925 dB)
+    0x00};      // [147] = -73.500 dB  ->  AKM(0x00) =  mute       error(+infini)
+
+/*
+ * pseudo-codec write entry
+ */
+static void vx2_write_akm(vx_core_t *chip, int reg, unsigned int data)
+{
+	unsigned int val;
+
+	if (reg == XX_CODEC_DAC_CONTROL_REGISTER) {
+		vx2_write_codec_reg(chip, data ? AKM_CODEC_MUTE_CMD : AKM_CODEC_UNMUTE_CMD);
+		return;
+	}
+
+	/* `data' is a value between 0x0 and VX2_AKM_LEVEL_MAX = 0x093, in the case of the AKM codecs, we need
+	   a look up table, as there is no linear matching between the driver codec values
+	   and the real dBu value
+	*/
+	snd_assert(data < sizeof(vx2_akm_gains_lut), return);
+
+	switch (reg) {
+	case XX_CODEC_LEVEL_LEFT_REGISTER:
+		val = AKM_CODEC_LEFT_LEVEL_CMD;
+		break;
+	case XX_CODEC_LEVEL_RIGHT_REGISTER:
+		val = AKM_CODEC_RIGHT_LEVEL_CMD;
+		break;
+	default:
+		snd_BUG();
+		return;
+	}
+	val |= vx2_akm_gains_lut[data];
+
+	vx2_write_codec_reg(chip, val);
+}
+
+
+/*
+ * write codec bit for old VX222 board
+ */
+static void vx2_old_write_codec_bit(vx_core_t *chip, int codec, unsigned int data)
+{
+	int i;
+
+	/* activate access to codec registers */
+	vx_inl(chip, HIFREQ);
+
+	for (i = 0; i < 24; i++, data <<= 1)
+		vx_outl(chip, DATA, ((data & 0x800000) ? VX_DATA_CODEC_MASK : 0));
+
+	/* Terminate access to codec registers */
+	vx_inl(chip, RUER);
+}
+
+
+/*
+ * reset codec bit
+ */
+static void vx2_reset_codec(vx_core_t *_chip)
+{
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+
+	/* Set the reset CODEC bit to 0. */
+	vx_outl(chip, CDSP, chip->regCDSP &~ VX_CDSP_CODEC_RESET_MASK);
+	vx_inl(chip, CDSP);
+	snd_vx_delay(_chip, 10);
+	/* Set the reset CODEC bit to 1. */
+	chip->regCDSP |= VX_CDSP_CODEC_RESET_MASK;
+	vx_outl(chip, CDSP, chip->regCDSP);
+	vx_inl(chip, CDSP);
+	if (_chip->type == VX_TYPE_BOARD) {
+		snd_vx_delay(_chip, 1);
+		return;
+	}
+
+	snd_vx_delay(_chip, 5);  /* additionnel wait time for AKM's */
+
+	vx2_write_codec_reg(_chip, AKM_CODEC_POWER_CONTROL_CMD); /* DAC power up, ADC power up, Vref power down */
+	
+	vx2_write_codec_reg(_chip, AKM_CODEC_CLOCK_FORMAT_CMD); /* default */
+	vx2_write_codec_reg(_chip, AKM_CODEC_MUTE_CMD); /* Mute = ON ,Deemphasis = OFF */
+	vx2_write_codec_reg(_chip, AKM_CODEC_RESET_OFF_CMD); /* DAC and ADC normal operation */
+
+	if (_chip->type == VX_TYPE_MIC) {
+		/* set up the micro input selector */
+		chip->regSELMIC =  MICRO_SELECT_INPUT_NORM |
+			MICRO_SELECT_PREAMPLI_G_0 |
+			MICRO_SELECT_NOISE_T_52DB;
+
+		/* reset phantom power supply */
+		chip->regSELMIC &= ~MICRO_SELECT_PHANTOM_ALIM;
+
+		vx_outl(_chip, SELMIC, chip->regSELMIC);
+	}
+}
+
+
+/*
+ * change the audio source
+ */
+static void vx2_change_audio_source(vx_core_t *_chip, int src)
+{
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+
+	switch (src) {
+	case VX_AUDIO_SRC_DIGITAL:
+		chip->regCFG |= VX_CFG_DATAIN_SEL_MASK;
+		break;
+	default:
+		chip->regCFG &= ~VX_CFG_DATAIN_SEL_MASK;
+		break;
+	}
+	vx_outl(chip, CFG, chip->regCFG);
+}
+
+
+/*
+ * set the clock source
+ */
+static void vx2_set_clock_source(vx_core_t *_chip, int source)
+{
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+
+	if (source == INTERNAL_QUARTZ)
+		chip->regCFG &= ~VX_CFG_CLOCKIN_SEL_MASK;
+	else
+		chip->regCFG |= VX_CFG_CLOCKIN_SEL_MASK;
+	vx_outl(chip, CFG, chip->regCFG);
+}
+
+/*
+ * reset the board
+ */
+static void vx2_reset_board(vx_core_t *_chip, int cold_reset)
+{
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+
+	/* initialize the register values */
+	chip->regCDSP = VX_CDSP_CODEC_RESET_MASK | VX_CDSP_DSP_RESET_MASK ;
+	chip->regCFG = 0;
+}
+
+
+
+/*
+ * input level controls for VX222 Mic
+ */
+
+/* Micro level is specified to be adjustable from -96dB to 63 dB (board coded 0x00 ... 318),
+ * 318 = 210 + 36 + 36 + 36   (210 = +9dB variable) (3 * 36 = 3 steps of 18dB pre ampli)
+ * as we will mute if less than -110dB, so let's simply use line input coded levels and add constant offset !
+ */
+#define V2_MICRO_LEVEL_RANGE        (318 - 255)
+
+static void vx2_set_input_level(struct snd_vx222 *chip)
+{
+	int i, miclevel, preamp;
+	unsigned int data;
+
+	miclevel = chip->mic_level;
+	miclevel += V2_MICRO_LEVEL_RANGE; /* add 318 - 0xff */
+	preamp = 0;
+        while (miclevel > 210) { /* limitation to +9dB of 3310 real gain */
+		preamp++;	/* raise pre ampli + 18dB */
+		miclevel -= (18 * 2);   /* lower level 18 dB (*2 because of 0.5 dB steps !) */
+        }
+	snd_assert(preamp < 4, return);
+
+	/* set pre-amp level */
+	chip->regSELMIC &= ~MICRO_SELECT_PREAMPLI_MASK;
+	chip->regSELMIC |= (preamp << MICRO_SELECT_PREAMPLI_OFFSET) & MICRO_SELECT_PREAMPLI_MASK;
+	vx_outl(chip, SELMIC, chip->regSELMIC);
+
+	data = (unsigned int)miclevel << 16 |
+		(unsigned int)chip->input_level[1] << 8 |
+		(unsigned int)chip->input_level[0];
+	vx_inl(chip, DATA); /* Activate input level programming */
+
+	/* We have to send 32 bits (4 x 8 bits) */
+	for (i = 0; i < 32; i++, data <<= 1)
+		vx_outl(chip, DATA, ((data & 0x80000000) ? VX_DATA_CODEC_MASK : 0));
+
+	vx_inl(chip, RUER); /* Terminate input level programming */
+}
+
+
+#define MIC_LEVEL_MAX	0xff
+
+/*
+ * controls API for input levels
+ */
+
+/* input levels */
+static int vx_input_level_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = MIC_LEVEL_MAX;
+	return 0;
+}
+
+static int vx_input_level_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *_chip = snd_kcontrol_chip(kcontrol);
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	down(&_chip->mixer_mutex);
+	ucontrol->value.integer.value[0] = chip->input_level[0];
+	ucontrol->value.integer.value[1] = chip->input_level[1];
+	up(&_chip->mixer_mutex);
+	return 0;
+}
+
+static int vx_input_level_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *_chip = snd_kcontrol_chip(kcontrol);
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	down(&_chip->mixer_mutex);
+	if (chip->input_level[0] != ucontrol->value.integer.value[0] ||
+	    chip->input_level[1] != ucontrol->value.integer.value[1]) {
+		chip->input_level[0] = ucontrol->value.integer.value[0];
+		chip->input_level[1] = ucontrol->value.integer.value[1];
+		vx2_set_input_level(chip);
+		up(&_chip->mixer_mutex);
+		return 1;
+	}
+	up(&_chip->mixer_mutex);
+	return 0;
+}
+
+/* mic level */
+static int vx_mic_level_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = MIC_LEVEL_MAX;
+	return 0;
+}
+
+static int vx_mic_level_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *_chip = snd_kcontrol_chip(kcontrol);
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	ucontrol->value.integer.value[0] = chip->mic_level;
+	return 0;
+}
+
+static int vx_mic_level_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *_chip = snd_kcontrol_chip(kcontrol);
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	down(&_chip->mixer_mutex);
+	if (chip->mic_level != ucontrol->value.integer.value[0]) {
+		chip->mic_level = ucontrol->value.integer.value[0];
+		vx2_set_input_level(chip);
+		up(&_chip->mixer_mutex);
+		return 1;
+	}
+	up(&_chip->mixer_mutex);
+	return 0;
+}
+
+static snd_kcontrol_new_t vx_control_input_level = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Capture Volume",
+	.info =		vx_input_level_info,
+	.get =		vx_input_level_get,
+	.put =		vx_input_level_put,
+};
+
+static snd_kcontrol_new_t vx_control_mic_level = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Mic Capture Volume",
+	.info =		vx_mic_level_info,
+	.get =		vx_mic_level_get,
+	.put =		vx_mic_level_put,
+};
+
+/*
+ * FIXME: compressor/limiter implementation is missing yet...
+ */
+
+static int vx2_add_mic_controls(vx_core_t *_chip)
+{
+	struct snd_vx222 *chip = (struct snd_vx222 *)_chip;
+	int err;
+
+	if (_chip->type != VX_TYPE_MIC)
+		return 0;
+
+	/* mute input levels */
+	chip->input_level[0] = chip->input_level[1] = 0;
+	chip->mic_level = 0;
+	vx2_set_input_level(chip);
+
+	/* controls */
+	if ((err = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_input_level, chip))) < 0)
+		return err;
+	if ((err = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_mic_level, chip))) < 0)
+		return err;
+
+	return 0;
+}
+
+
+/*
+ * callbacks
+ */
+struct snd_vx_ops vx222_ops = {
+	.in8 = vx2_inb,
+	.in32 = vx2_inl,
+	.out8 = vx2_outb,
+	.out32 = vx2_outl,
+	.test_and_ack = vx2_test_and_ack,
+	.validate_irq = vx2_validate_irq,
+	.akm_write = vx2_write_akm,
+	.reset_codec = vx2_reset_codec,
+	.change_audio_source = vx2_change_audio_source,
+	.set_clock_source = vx2_set_clock_source,
+	.load_dsp = vx2_load_dsp,
+	.reset_dsp = vx2_reset_dsp,
+	.reset_board = vx2_reset_board,
+	.dma_write = vx2_dma_write,
+	.dma_read = vx2_dma_read,
+	.add_controls = vx2_add_mic_controls,
+};
+
+/* for old VX222 board */
+struct snd_vx_ops vx222_old_ops = {
+	.in8 = vx2_inb,
+	.in32 = vx2_inl,
+	.out8 = vx2_outb,
+	.out32 = vx2_outl,
+	.test_and_ack = vx2_test_and_ack,
+	.validate_irq = vx2_validate_irq,
+	.write_codec = vx2_old_write_codec_bit,
+	.reset_codec = vx2_reset_codec,
+	.change_audio_source = vx2_change_audio_source,
+	.set_clock_source = vx2_set_clock_source,
+	.load_dsp = vx2_load_dsp,
+	.reset_dsp = vx2_reset_dsp,
+	.reset_board = vx2_reset_board,
+	.dma_write = vx2_dma_write,
+	.dma_read = vx2_dma_read,
+};
+
