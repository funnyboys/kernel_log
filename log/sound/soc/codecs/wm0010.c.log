commit 681c896ceb411ccd2ce0a88059d86ccf8d7a497e
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Feb 11 14:05:49 2020 -0600

    ASoC: wm0010: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertenly introduced[3] to the codebase from now on.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Link: https://lore.kernel.org/r/20200211200549.GA12072@embeddedor
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 727d6703c905..fbcee21736e8 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -43,7 +43,7 @@ struct dfw_binrec {
 	u8 command;
 	u32 length:24;
 	u32 address;
-	uint8_t data[0];
+	uint8_t data[];
 } __packed;
 
 struct dfw_inforec {

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index abd2defe7530..727d6703c905 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * wm0010.c  --  WM0010 DSP Driver
  *
@@ -6,10 +7,6 @@
  * Authors: Mark Brown <broonie@opensource.wolfsonmicro.com>
  *          Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
  *          Scott Ling <sl@opensource.wolfsonmicro.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/module.h>

commit b5311eede823588b9c33774a1c4dc51843a42a41
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 29 02:58:43 2018 +0000

    ASoC: wm0010: replace codec to component
    
    Now we can replace Codec to Component. Let's do it.
    
    Note:
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 1      ->      .idle_bias_on = 0
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 0147d2fb7b0a..abd2defe7530 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -90,7 +90,7 @@ enum wm0010_state {
 };
 
 struct wm0010_priv {
-	struct snd_soc_codec *codec;
+	struct snd_soc_component *component;
 
 	struct mutex lock;
 	struct device *dev;
@@ -157,9 +157,9 @@ static const char *wm0010_state_to_str(enum wm0010_state state)
 }
 
 /* Called with wm0010->lock held */
-static void wm0010_halt(struct snd_soc_codec *codec)
+static void wm0010_halt(struct snd_soc_component *component)
 {
-	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	struct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);
 	unsigned long flags;
 	enum wm0010_state state;
 
@@ -193,7 +193,7 @@ static void wm0010_halt(struct snd_soc_codec *codec)
 
 struct wm0010_boot_xfer {
 	struct list_head list;
-	struct snd_soc_codec *codec;
+	struct snd_soc_component *component;
 	struct completion *done;
 	struct spi_message m;
 	struct spi_transfer t;
@@ -218,13 +218,13 @@ static void wm0010_mark_boot_failure(struct wm0010_priv *wm0010)
 static void wm0010_boot_xfer_complete(void *data)
 {
 	struct wm0010_boot_xfer *xfer = data;
-	struct snd_soc_codec *codec = xfer->codec;
-	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = xfer->component;
+	struct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);
 	u32 *out32 = xfer->t.rx_buf;
 	int i;
 
 	if (xfer->m.status != 0) {
-		dev_err(codec->dev, "SPI transfer failed: %d\n",
+		dev_err(component->dev, "SPI transfer failed: %d\n",
 			xfer->m.status);
 		wm0010_mark_boot_failure(wm0010);
 		if (xfer->done)
@@ -233,11 +233,11 @@ static void wm0010_boot_xfer_complete(void *data)
 	}
 
 	for (i = 0; i < xfer->t.len / 4; i++) {
-		dev_dbg(codec->dev, "%d: %04x\n", i, out32[i]);
+		dev_dbg(component->dev, "%d: %04x\n", i, out32[i]);
 
 		switch (be32_to_cpu(out32[i])) {
 		case 0xe0e0e0e0:
-			dev_err(codec->dev,
+			dev_err(component->dev,
 				"%d: ROM error reported in stage 2\n", i);
 			wm0010_mark_boot_failure(wm0010);
 			break;
@@ -245,82 +245,82 @@ static void wm0010_boot_xfer_complete(void *data)
 		case 0x55555555:
 			if (wm0010->state < WM0010_STAGE2)
 				break;
-			dev_err(codec->dev,
+			dev_err(component->dev,
 				"%d: ROM bootloader running in stage 2\n", i);
 			wm0010_mark_boot_failure(wm0010);
 			break;
 
 		case 0x0fed0000:
-			dev_dbg(codec->dev, "Stage2 loader running\n");
+			dev_dbg(component->dev, "Stage2 loader running\n");
 			break;
 
 		case 0x0fed0007:
-			dev_dbg(codec->dev, "CODE_HDR packet received\n");
+			dev_dbg(component->dev, "CODE_HDR packet received\n");
 			break;
 
 		case 0x0fed0008:
-			dev_dbg(codec->dev, "CODE_DATA packet received\n");
+			dev_dbg(component->dev, "CODE_DATA packet received\n");
 			break;
 
 		case 0x0fed0009:
-			dev_dbg(codec->dev, "Download complete\n");
+			dev_dbg(component->dev, "Download complete\n");
 			break;
 
 		case 0x0fed000c:
-			dev_dbg(codec->dev, "Application start\n");
+			dev_dbg(component->dev, "Application start\n");
 			break;
 
 		case 0x0fed000e:
-			dev_dbg(codec->dev, "PLL packet received\n");
+			dev_dbg(component->dev, "PLL packet received\n");
 			wm0010->pll_running = true;
 			break;
 
 		case 0x0fed0025:
-			dev_err(codec->dev, "Device reports image too long\n");
+			dev_err(component->dev, "Device reports image too long\n");
 			wm0010_mark_boot_failure(wm0010);
 			break;
 
 		case 0x0fed002c:
-			dev_err(codec->dev, "Device reports bad SPI packet\n");
+			dev_err(component->dev, "Device reports bad SPI packet\n");
 			wm0010_mark_boot_failure(wm0010);
 			break;
 
 		case 0x0fed0031:
-			dev_err(codec->dev, "Device reports SPI read overflow\n");
+			dev_err(component->dev, "Device reports SPI read overflow\n");
 			wm0010_mark_boot_failure(wm0010);
 			break;
 
 		case 0x0fed0032:
-			dev_err(codec->dev, "Device reports SPI underclock\n");
+			dev_err(component->dev, "Device reports SPI underclock\n");
 			wm0010_mark_boot_failure(wm0010);
 			break;
 
 		case 0x0fed0033:
-			dev_err(codec->dev, "Device reports bad header packet\n");
+			dev_err(component->dev, "Device reports bad header packet\n");
 			wm0010_mark_boot_failure(wm0010);
 			break;
 
 		case 0x0fed0034:
-			dev_err(codec->dev, "Device reports invalid packet type\n");
+			dev_err(component->dev, "Device reports invalid packet type\n");
 			wm0010_mark_boot_failure(wm0010);
 			break;
 
 		case 0x0fed0035:
-			dev_err(codec->dev, "Device reports data before header error\n");
+			dev_err(component->dev, "Device reports data before header error\n");
 			wm0010_mark_boot_failure(wm0010);
 			break;
 
 		case 0x0fed0038:
-			dev_err(codec->dev, "Device reports invalid PLL packet\n");
+			dev_err(component->dev, "Device reports invalid PLL packet\n");
 			break;
 
 		case 0x0fed003a:
-			dev_err(codec->dev, "Device reports packet alignment error\n");
+			dev_err(component->dev, "Device reports packet alignment error\n");
 			wm0010_mark_boot_failure(wm0010);
 			break;
 
 		default:
-			dev_err(codec->dev, "Unrecognised return 0x%x\n",
+			dev_err(component->dev, "Unrecognised return 0x%x\n",
 			    be32_to_cpu(out32[i]));
 			wm0010_mark_boot_failure(wm0010);
 			break;
@@ -342,10 +342,10 @@ static void byte_swap_64(u64 *data_in, u64 *data_out, u32 len)
 		data_out[i] = cpu_to_be64(le64_to_cpu(data_in[i]));
 }
 
-static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
+static int wm0010_firmware_load(const char *name, struct snd_soc_component *component)
 {
-	struct spi_device *spi = to_spi_device(codec->dev);
-	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	struct spi_device *spi = to_spi_device(component->dev);
+	struct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);
 	struct list_head xfer_list;
 	struct wm0010_boot_xfer *xfer;
 	int ret;
@@ -359,9 +359,9 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 
 	INIT_LIST_HEAD(&xfer_list);
 
-	ret = request_firmware(&fw, name, codec->dev);
+	ret = request_firmware(&fw, name, component->dev);
 	if (ret != 0) {
-		dev_err(codec->dev, "Failed to request application(%s): %d\n",
+		dev_err(component->dev, "Failed to request application(%s): %d\n",
 			name, ret);
 		return ret;
 	}
@@ -377,25 +377,25 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 
 	/* First record should be INFO */
 	if (rec->command != DFW_CMD_INFO) {
-		dev_err(codec->dev, "First record not INFO\r\n");
+		dev_err(component->dev, "First record not INFO\r\n");
 		ret = -EINVAL;
 		goto abort;
 	}
 
 	if (inforec->info_version != INFO_VERSION) {
-		dev_err(codec->dev,
+		dev_err(component->dev,
 			"Unsupported version (%02d) of INFO record\r\n",
 			inforec->info_version);
 		ret = -EINVAL;
 		goto abort;
 	}
 
-	dev_dbg(codec->dev, "Version v%02d INFO record found\r\n",
+	dev_dbg(component->dev, "Version v%02d INFO record found\r\n",
 		inforec->info_version);
 
 	/* Check it's a DSP file */
 	if (dsp != DEVICE_ID_WM0010) {
-		dev_err(codec->dev, "Not a WM0010 firmware file.\r\n");
+		dev_err(component->dev, "Not a WM0010 firmware file.\r\n");
 		ret = -EINVAL;
 		goto abort;
 	}
@@ -405,7 +405,7 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 	rec = (void *)&rec->data[rec->length];
 
 	while (offset < fw->size) {
-		dev_dbg(codec->dev,
+		dev_dbg(component->dev,
 			"Packet: command %d, data length = 0x%x\r\n",
 			rec->command, rec->length);
 		len = rec->length + 8;
@@ -416,7 +416,7 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 			goto abort;
 		}
 
-		xfer->codec = codec;
+		xfer->component = component;
 		list_add_tail(&xfer->list, &xfer_list);
 
 		out = kzalloc(len, GFP_KERNEL | GFP_DMA);
@@ -460,18 +460,18 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 		rec = (void *)&rec->data[rec->length];
 
 		if (offset >= fw->size) {
-			dev_dbg(codec->dev, "All transfers scheduled\n");
+			dev_dbg(component->dev, "All transfers scheduled\n");
 			xfer->done = &done;
 		}
 
 		ret = spi_async(spi, &xfer->m);
 		if (ret != 0) {
-			dev_err(codec->dev, "Write failed: %d\n", ret);
+			dev_err(component->dev, "Write failed: %d\n", ret);
 			goto abort1;
 		}
 
 		if (wm0010->boot_failed) {
-			dev_dbg(codec->dev, "Boot fail!\n");
+			dev_dbg(component->dev, "Boot fail!\n");
 			ret = -EINVAL;
 			goto abort1;
 		}
@@ -496,10 +496,10 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 	return ret;
 }
 
-static int wm0010_stage2_load(struct snd_soc_codec *codec)
+static int wm0010_stage2_load(struct snd_soc_component *component)
 {
-	struct spi_device *spi = to_spi_device(codec->dev);
-	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	struct spi_device *spi = to_spi_device(component->dev);
+	struct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);
 	const struct firmware *fw;
 	struct spi_message m;
 	struct spi_transfer t;
@@ -508,14 +508,14 @@ static int wm0010_stage2_load(struct snd_soc_codec *codec)
 	int i;
 	int ret = 0;
 
-	ret = request_firmware(&fw, "wm0010_stage2.bin", codec->dev);
+	ret = request_firmware(&fw, "wm0010_stage2.bin", component->dev);
 	if (ret != 0) {
-		dev_err(codec->dev, "Failed to request stage2 loader: %d\n",
+		dev_err(component->dev, "Failed to request stage2 loader: %d\n",
 			ret);
 		return ret;
 	}
 
-	dev_dbg(codec->dev, "Downloading %zu byte stage 2 loader\n", fw->size);
+	dev_dbg(component->dev, "Downloading %zu byte stage 2 loader\n", fw->size);
 
 	/* Copy to local buffer first as vmalloc causes problems for dma */
 	img = kzalloc(fw->size, GFP_KERNEL | GFP_DMA);
@@ -541,19 +541,19 @@ static int wm0010_stage2_load(struct snd_soc_codec *codec)
 	t.speed_hz = wm0010->sysclk / 10;
 	spi_message_add_tail(&t, &m);
 
-	dev_dbg(codec->dev, "Starting initial download at %dHz\n",
+	dev_dbg(component->dev, "Starting initial download at %dHz\n",
 		t.speed_hz);
 
 	ret = spi_sync(spi, &m);
 	if (ret != 0) {
-		dev_err(codec->dev, "Initial download failed: %d\n", ret);
+		dev_err(component->dev, "Initial download failed: %d\n", ret);
 		goto abort;
 	}
 
 	/* Look for errors from the boot ROM */
 	for (i = 0; i < fw->size; i++) {
 		if (out[i] != 0x55) {
-			dev_err(codec->dev, "Boot ROM error: %x in %d\n",
+			dev_err(component->dev, "Boot ROM error: %x in %d\n",
 				out[i], i);
 			wm0010_mark_boot_failure(wm0010);
 			ret = -EBUSY;
@@ -570,10 +570,10 @@ static int wm0010_stage2_load(struct snd_soc_codec *codec)
 	return ret;
 }
 
-static int wm0010_boot(struct snd_soc_codec *codec)
+static int wm0010_boot(struct snd_soc_component *component)
 {
-	struct spi_device *spi = to_spi_device(codec->dev);
-	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	struct spi_device *spi = to_spi_device(component->dev);
+	struct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);
 	unsigned long flags;
 	int ret;
 	struct spi_message m;
@@ -590,7 +590,7 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
 
 	if (wm0010->sysclk > 26000000) {
-		dev_err(codec->dev, "Max DSP clock frequency is 26MHz\n");
+		dev_err(component->dev, "Max DSP clock frequency is 26MHz\n");
 		ret = -ECANCELED;
 		goto err;
 	}
@@ -598,7 +598,7 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	mutex_lock(&wm0010->lock);
 	wm0010->pll_running = false;
 
-	dev_dbg(codec->dev, "max_spi_freq: %d\n", wm0010->max_spi_freq);
+	dev_dbg(component->dev, "max_spi_freq: %d\n", wm0010->max_spi_freq);
 
 	ret = regulator_bulk_enable(ARRAY_SIZE(wm0010->core_supplies),
 				    wm0010->core_supplies);
@@ -623,19 +623,19 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 
 	if (!wait_for_completion_timeout(&wm0010->boot_completion,
 					 msecs_to_jiffies(20)))
-		dev_err(codec->dev, "Failed to get interrupt from DSP\n");
+		dev_err(component->dev, "Failed to get interrupt from DSP\n");
 
 	spin_lock_irqsave(&wm0010->irq_lock, flags);
 	wm0010->state = WM0010_BOOTROM;
 	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
 
-	ret = wm0010_stage2_load(codec);
+	ret = wm0010_stage2_load(component);
 	if (ret)
 		goto abort;
 
 	if (!wait_for_completion_timeout(&wm0010->boot_completion,
 					 msecs_to_jiffies(20)))
-		dev_err(codec->dev, "Failed to get interrupt from DSP loader.\n");
+		dev_err(component->dev, "Failed to get interrupt from DSP loader.\n");
 
 	spin_lock_irqsave(&wm0010->irq_lock, flags);
 	wm0010->state = WM0010_STAGE2;
@@ -676,14 +676,14 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 
 		ret = spi_sync(spi, &m);
 		if (ret) {
-			dev_err(codec->dev, "First PLL write failed: %d\n", ret);
+			dev_err(component->dev, "First PLL write failed: %d\n", ret);
 			goto abort_swap;
 		}
 
 		/* Use a second send of the message to get the return status */
 		ret = spi_sync(spi, &m);
 		if (ret) {
-			dev_err(codec->dev, "Second PLL write failed: %d\n", ret);
+			dev_err(component->dev, "Second PLL write failed: %d\n", ret);
 			goto abort_swap;
 		}
 
@@ -692,7 +692,7 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		/* Look for PLL active code from the DSP */
 		for (i = 0; i < len / 4; i++) {
 			if (*p == 0x0e00ed0f) {
-				dev_dbg(codec->dev, "PLL packet received\n");
+				dev_dbg(component->dev, "PLL packet received\n");
 				wm0010->pll_running = true;
 				break;
 			}
@@ -702,9 +702,9 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		kfree(img_swap);
 		kfree(out);
 	} else
-		dev_dbg(codec->dev, "Not enabling DSP PLL.");
+		dev_dbg(component->dev, "Not enabling DSP PLL.");
 
-	ret = wm0010_firmware_load("wm0010.dfw", codec);
+	ret = wm0010_firmware_load("wm0010.dfw", component);
 
 	if (ret != 0)
 		goto abort;
@@ -723,7 +723,7 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	kfree(out);
 abort:
 	/* Put the chip back into reset */
-	wm0010_halt(codec);
+	wm0010_halt(component);
 	mutex_unlock(&wm0010->lock);
 	return ret;
 
@@ -735,22 +735,22 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	return ret;
 }
 
-static int wm0010_set_bias_level(struct snd_soc_codec *codec,
+static int wm0010_set_bias_level(struct snd_soc_component *component,
 				 enum snd_soc_bias_level level)
 {
-	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	struct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
-		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_PREPARE)
-			wm0010_boot(codec);
+		if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_PREPARE)
+			wm0010_boot(component);
 		break;
 	case SND_SOC_BIAS_PREPARE:
 		break;
 	case SND_SOC_BIAS_STANDBY:
-		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_PREPARE) {
+		if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_PREPARE) {
 			mutex_lock(&wm0010->lock);
-			wm0010_halt(codec);
+			wm0010_halt(component);
 			mutex_unlock(&wm0010->lock);
 		}
 		break;
@@ -761,10 +761,10 @@ static int wm0010_set_bias_level(struct snd_soc_codec *codec,
 	return 0;
 }
 
-static int wm0010_set_sysclk(struct snd_soc_codec *codec, int source,
+static int wm0010_set_sysclk(struct snd_soc_component *component, int source,
 			     int clk_id, unsigned int freq, int dir)
 {
-	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	struct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);
 	unsigned int i;
 
 	wm0010->sysclk = freq;
@@ -783,20 +783,19 @@ static int wm0010_set_sysclk(struct snd_soc_codec *codec, int source,
 	return 0;
 }
 
-static int wm0010_probe(struct snd_soc_codec *codec);
-
-static const struct snd_soc_codec_driver soc_codec_dev_wm0010 = {
-	.probe = wm0010_probe,
-	.set_bias_level = wm0010_set_bias_level,
-	.set_sysclk = wm0010_set_sysclk,
-	.idle_bias_off = true,
-
-	.component_driver = {
-		.dapm_widgets		= wm0010_dapm_widgets,
-		.num_dapm_widgets	= ARRAY_SIZE(wm0010_dapm_widgets),
-		.dapm_routes		= wm0010_dapm_routes,
-		.num_dapm_routes	= ARRAY_SIZE(wm0010_dapm_routes),
-	},
+static int wm0010_probe(struct snd_soc_component *component);
+
+static const struct snd_soc_component_driver soc_component_dev_wm0010 = {
+	.probe			= wm0010_probe,
+	.set_bias_level		= wm0010_set_bias_level,
+	.set_sysclk		= wm0010_set_sysclk,
+	.dapm_widgets		= wm0010_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(wm0010_dapm_widgets),
+	.dapm_routes		= wm0010_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(wm0010_dapm_routes),
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
 };
 
 #define WM0010_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
@@ -860,11 +859,11 @@ static irqreturn_t wm0010_irq(int irq, void *data)
 	return IRQ_NONE;
 }
 
-static int wm0010_probe(struct snd_soc_codec *codec)
+static int wm0010_probe(struct snd_soc_component *component)
 {
-	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	struct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);
 
-	wm0010->codec = codec;
+	wm0010->component = component;
 
 	return 0;
 }
@@ -967,8 +966,8 @@ static int wm0010_spi_probe(struct spi_device *spi)
 	else
 		wm0010->board_max_spi_speed = 0;
 
-	ret = snd_soc_register_codec(&spi->dev,
-				     &soc_codec_dev_wm0010, wm0010_dai,
+	ret = devm_snd_soc_register_component(&spi->dev,
+				     &soc_component_dev_wm0010, wm0010_dai,
 				     ARRAY_SIZE(wm0010_dai));
 	if (ret < 0)
 		return ret;
@@ -980,8 +979,6 @@ static int wm0010_spi_remove(struct spi_device *spi)
 {
 	struct wm0010_priv *wm0010 = spi_get_drvdata(spi);
 
-	snd_soc_unregister_codec(&spi->dev);
-
 	gpio_set_value_cansleep(wm0010->gpio_reset,
 				wm0010->gpio_reset_value);
 

commit 316c85c3db55588893f51907de3424f85020f0eb
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Nov 22 17:17:48 2017 +0100

    ASoC: wm0010: Delete an error message for a failed memory allocation in wm0010_boot()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 4f5f5710b569..0147d2fb7b0a 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -655,11 +655,8 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		ret = -ENOMEM;
 		len = pll_rec.length + 8;
 		out = kzalloc(len, GFP_KERNEL | GFP_DMA);
-		if (!out) {
-			dev_err(codec->dev,
-				"Failed to allocate RX buffer\n");
+		if (!out)
 			goto abort;
-		}
 
 		img_swap = kzalloc(len, GFP_KERNEL | GFP_DMA);
 		if (!img_swap)

commit 98856d5ad89c4bb13544b1f1367a4d8355296a2d
Author: Corentin Labbe <clabbe.montjoie@gmail.com>
Date:   Thu Dec 15 16:19:43 2016 +0100

    ASoC: wm0010: Remove unneeded linux/miscdevice.h include
    
    sound/soc/codecs/wm0010.c does not use any miscdevice so this patch
    remove this unnecessary inclusion.
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Acked-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 0eb5dcf4c29d..4f5f5710b569 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -21,7 +21,6 @@
 #include <linux/firmware.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
-#include <linux/miscdevice.h>
 #include <linux/gpio.h>
 #include <linux/regulator/consumer.h>
 #include <linux/mutex.h>

commit f802d6c020658b5dce1732da0d5999a1a65afdd6
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Aug 31 23:52:27 2016 +0200

    ASoC: constify snd_soc_codec_driver structures
    
    Check for snd_soc_codec_driver structures that are only passed to
    snd_soc_register_codec or memcpy (2nd arg), for which the corresponding
    parameters are declared const.  Declare as const snd_soc_codec_driver
    structures that have these properties.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_soc_codec_driver i@p = { ... };
    
    @ok@
    identifier r.i;
    expression e1,e2,e3;
    position p;
    @@
    (
    snd_soc_register_codec(e1,&i@p,e2,e3)
    |
    memcpy(e1,&i@p,e2)
    )
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_soc_codec_driver i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 4ef6919ab1a1..0eb5dcf4c29d 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -789,7 +789,7 @@ static int wm0010_set_sysclk(struct snd_soc_codec *codec, int source,
 
 static int wm0010_probe(struct snd_soc_codec *codec);
 
-static struct snd_soc_codec_driver soc_codec_dev_wm0010 = {
+static const struct snd_soc_codec_driver soc_codec_dev_wm0010 = {
 	.probe = wm0010_probe,
 	.set_bias_level = wm0010_set_bias_level,
 	.set_sysclk = wm0010_set_sysclk,

commit 022f86d6f3b15bcd4865bccf837d309eb336f5a2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Aug 8 09:28:08 2016 +0000

    ASoC: codec duplicated callback function goes to component on wm0010
    
    codec driver and component driver has duplicated callback functions,
    and codec side functions are just copied to component side when
    register timing. This was quick-hack, but no longer needed.
    This patch moves these functions from codec driver to component driver.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index e3c34bdc2772..4ef6919ab1a1 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -795,10 +795,12 @@ static struct snd_soc_codec_driver soc_codec_dev_wm0010 = {
 	.set_sysclk = wm0010_set_sysclk,
 	.idle_bias_off = true,
 
-	.dapm_widgets = wm0010_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(wm0010_dapm_widgets),
-	.dapm_routes = wm0010_dapm_routes,
-	.num_dapm_routes = ARRAY_SIZE(wm0010_dapm_routes),
+	.component_driver = {
+		.dapm_widgets		= wm0010_dapm_widgets,
+		.num_dapm_widgets	= ARRAY_SIZE(wm0010_dapm_widgets),
+		.dapm_routes		= wm0010_dapm_routes,
+		.num_dapm_routes	= ARRAY_SIZE(wm0010_dapm_routes),
+	},
 };
 
 #define WM0010_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)

commit 4c84518523f888994c618585021c76fa499d465e
Merge: fc579056af0b 76f67ea9bf27 160f8d069165 3821a065f567 54bf4505bd64 0db642151ad8
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 4 11:02:12 2015 +0000

    Merge remote-tracking branches 'spi/topic/omap-100k', 'spi/topic/omap-uwire', 'spi/topic/owner', 'spi/topic/pxa' and 'spi/topic/pxa2xx' into spi-next

commit 3821a065f5672c430a088ae68b4da2a2d2b34106
Author: Andrew F. Davis <afd@ti.com>
Date:   Fri Oct 23 08:59:11 2015 -0500

    spi: Drop owner assignment from spi_drivers
    
    An spi_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index f2c6ad4b8fde..9cf4a0dab46f 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -1003,7 +1003,6 @@ static int wm0010_spi_remove(struct spi_device *spi)
 static struct spi_driver wm0010_spi_driver = {
 	.driver = {
 		.name	= "wm0010",
-		.owner	= THIS_MODULE,
 	},
 	.probe		= wm0010_spi_probe,
 	.remove		= wm0010_spi_remove,

commit d86a2fe4dc97cbbad04f5db941d9a1bb82e22b5f
Merge: 312e0bce7f2d e4fba9b5be12 921e54680aef 8811191fdf7e 42617869bf09 3a0e27d84bb9 f072f91aa751
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Sep 23 11:01:08 2015 -0700

    Merge remote-tracking branches 'asoc/fix/mtk', 'asoc/fix/psc', 'asoc/fix/pxa', 'asoc/fix/spear', 'asoc/fix/sti' and 'asoc/fix/wm0010' into asoc-linus

commit f072f91aa7517386344476813ca0799e08fd0c35
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Sep 18 16:02:21 2015 +0530

    ASoC: wm0010: fix error path
    
    Fix the error path so that we can free the allocated memory on the error
    path instead of releasing them individually on each error.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 7a1bc40538ca..76b2f88d9d9b 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -663,10 +663,8 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		}
 
 		img_swap = kzalloc(len, GFP_KERNEL | GFP_DMA);
-		if (!img_swap) {
-			kfree(out);
-			goto abort;
-		}
+		if (!img_swap)
+			goto abort_out;
 
 		/* We need to re-order for 0010 */
 		byte_swap_64((u64 *)&pll_rec, img_swap, len);
@@ -681,20 +679,16 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		spi_message_add_tail(&t, &m);
 
 		ret = spi_sync(spi, &m);
-		if (ret != 0) {
+		if (ret) {
 			dev_err(codec->dev, "First PLL write failed: %d\n", ret);
-			kfree(img_swap);
-			kfree(out);
-			goto abort;
+			goto abort_swap;
 		}
 
 		/* Use a second send of the message to get the return status */
 		ret = spi_sync(spi, &m);
-		if (ret != 0) {
+		if (ret) {
 			dev_err(codec->dev, "Second PLL write failed: %d\n", ret);
-			kfree(img_swap);
-			kfree(out);
-			goto abort;
+			goto abort_swap;
 		}
 
 		p = (u32 *)out;
@@ -727,6 +721,10 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 
 	return 0;
 
+abort_swap:
+	kfree(img_swap);
+abort_out:
+	kfree(out);
 abort:
 	/* Put the chip back into reset */
 	wm0010_halt(codec);

commit 2ace47be5a315def8f493ca77aa59c077ade30a1
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Sep 18 16:02:20 2015 +0530

    ASoC: wm0010: fix memory leak
    
    We have requested for the firmware but we have missed releasing it both
    on success and on error path.
    While checking the code it turned out that the requested firmware is not
    even used. More over the same firmware is being loaded by
    wm0010_stage2_load().
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 9d370a45abe8..7a1bc40538ca 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -577,7 +577,6 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
 	unsigned long flags;
 	int ret;
-	const struct firmware *fw;
 	struct spi_message m;
 	struct spi_transfer t;
 	struct dfw_pllrec pll_rec;
@@ -623,14 +622,6 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	wm0010->state = WM0010_OUT_OF_RESET;
 	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
 
-	/* First the bootloader */
-	ret = request_firmware(&fw, "wm0010_stage2.bin", codec->dev);
-	if (ret != 0) {
-		dev_err(codec->dev, "Failed to request stage2 loader: %d\n",
-			ret);
-		goto abort;
-	}
-
 	if (!wait_for_completion_timeout(&wm0010->boot_completion,
 					 msecs_to_jiffies(20)))
 		dev_err(codec->dev, "Failed to get interrupt from DSP\n");

commit 51d2eeef1d958ef6834b24f548194f5acea0f499
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Tue Sep 1 11:14:05 2015 +0530

    ASoC: wm0010: fix memory leak
    
    We were aborting if the kzalloc of img_swap fails but without freeing the
    already allocated out. Similarly we were aborting if spi_sync fails
    without releasing out and img_swap.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 6560a66b3f35..9d370a45abe8 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -672,8 +672,10 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		}
 
 		img_swap = kzalloc(len, GFP_KERNEL | GFP_DMA);
-		if (!img_swap)
+		if (!img_swap) {
+			kfree(out);
 			goto abort;
+		}
 
 		/* We need to re-order for 0010 */
 		byte_swap_64((u64 *)&pll_rec, img_swap, len);
@@ -690,6 +692,8 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		ret = spi_sync(spi, &m);
 		if (ret != 0) {
 			dev_err(codec->dev, "First PLL write failed: %d\n", ret);
+			kfree(img_swap);
+			kfree(out);
 			goto abort;
 		}
 
@@ -697,6 +701,8 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		ret = spi_sync(spi, &m);
 		if (ret != 0) {
 			dev_err(codec->dev, "Second PLL write failed: %d\n", ret);
+			kfree(img_swap);
+			kfree(out);
 			goto abort;
 		}
 

commit 030e6ee241f0586308622bcdd273a317976b3169
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Jul 2 21:26:44 2015 +0800

    ASoC: wm0010: Remove spurious missing IRQF_ONESHOT
    
    This reverts 58d468328646 ("ASoC: wm0010: Add missing IRQF_ONESHOT").
    
    The coccinelle warnings is false positive because the original code does
    set IRQF_ONESHOT by "trigger |= IRQF_ONESHOT;".
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index e1da49f39334..f2c6ad4b8fde 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -953,7 +953,7 @@ static int wm0010_spi_probe(struct spi_device *spi)
 		trigger = IRQF_TRIGGER_FALLING;
 	trigger |= IRQF_ONESHOT;
 
-	ret = request_threaded_irq(irq, NULL, wm0010_irq, trigger | IRQF_ONESHOT,
+	ret = request_threaded_irq(irq, NULL, wm0010_irq, trigger,
 				   "wm0010", wm0010);
 	if (ret) {
 		dev_err(wm0010->dev, "Failed to request IRQ %d: %d\n",

commit 93d5fc8bd143d94105279796451dcfd3d657453a
Author: Antonio Borneo <borneo.antonio@gmail.com>
Date:   Tue Jun 23 22:52:12 2015 +0800

    ASoC: wm0010: Remove redundant spi driver bus initialization
    
    In ancient times it was necessary to manually initialize the bus
    field of an spi_driver to spi_bus_type. These days this is done in
    spi_register_driver(), so we can drop the manual assignment.
    
    Signed-off-by: Antonio Borneo <borneo.antonio@gmail.com>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 6560a66b3f35..e1da49f39334 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -1003,7 +1003,6 @@ static int wm0010_spi_remove(struct spi_device *spi)
 static struct spi_driver wm0010_spi_driver = {
 	.driver = {
 		.name	= "wm0010",
-		.bus 	= &spi_bus_type,
 		.owner	= THIS_MODULE,
 	},
 	.probe		= wm0010_spi_probe,

commit e566b53251fb394501830397e82b5eb46841f36a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 1 10:10:25 2015 +0200

    ASoC: wm0010: Replace direct snd_soc_codec dapm field access
    
    The dapm field of the snd_soc_codec struct is eventually going to be
    removed, in preparation for this replace all manual access to
    codec->dapm.bias_level with snd_soc_codec_get_bias_level().
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 3358dd6811fa..6560a66b3f35 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -751,13 +751,13 @@ static int wm0010_set_bias_level(struct snd_soc_codec *codec,
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
-		if (codec->dapm.bias_level == SND_SOC_BIAS_PREPARE)
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_PREPARE)
 			wm0010_boot(codec);
 		break;
 	case SND_SOC_BIAS_PREPARE:
 		break;
 	case SND_SOC_BIAS_STANDBY:
-		if (codec->dapm.bias_level == SND_SOC_BIAS_PREPARE) {
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_PREPARE) {
 			mutex_lock(&wm0010->lock);
 			wm0010_halt(codec);
 			mutex_unlock(&wm0010->lock);

commit f4bf8d770b58862c2af9d17adc2fee05bef8f2c0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 27 22:13:25 2015 +0200

    ASoC: Move bias level update to the core
    
    All drivers have the same line at the end of the set_bias_level callback to
    update the bias_level state. Move this update into
    snd_soc_dapm_force_bias_level() and remove them from the drivers.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index f37989ec7cba..3358dd6811fa 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -767,8 +767,6 @@ static int wm0010_set_bias_level(struct snd_soc_codec *codec,
 		break;
 	}
 
-	codec->dapm.bias_level = level;
-
 	return 0;
 }
 

commit e99a866c4c6749eb3754e61d43eb18ef32e3556a
Merge: c5e64c7636eb 3e3e2922c12f 563fe71fe762 5bca396919ae 8bfcab7c6b44 d7821953cfe9
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Aug 4 16:32:18 2014 +0100

    Merge remote-tracking branches 'asoc/topic/tlv320aic3x', 'asoc/topic/width', 'asoc/topic/wm0010', 'asoc/topic/wm8904' and 'asoc/topic/wm8962' into asoc-next

commit 5bca396919aed5fbed61197019824bd3ff9f127d
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue May 27 08:57:55 2014 +0200

    ASoC: wm0010.c: add static to local variable
    
    Also add const to array
    
     text      data     bss     dec     hex filename
     10946     2904    3528   17378    43e2 sound/soc/codecs/wm0010.o-before
     10891     2840    3512   17243    435b sound/soc/codecs/wm0010.o-after
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 71ce3159a62e..65d7c79716a0 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -144,7 +144,7 @@ static const struct snd_soc_dapm_route wm0010_dapm_routes[] = {
 
 static const char *wm0010_state_to_str(enum wm0010_state state)
 {
-	const char *state_to_str[] = {
+	static const char * const state_to_str[] = {
 		"Power off",
 		"Out of reset",
 		"Boot ROM",

commit 84cbc75f9a72d646701ec4fb4accdfdc5f6f3ea2
Author: Sachin Kamat <sachin.kamat@samsung.com>
Date:   Fri Jun 20 15:29:05 2014 +0530

    ASoC: wm0010: Remove redundant OOM message
    
    Let memory subsystem handle the error logging.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 71ce3159a62e..982467c1d56a 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -413,7 +413,6 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 
 		xfer = kzalloc(sizeof(*xfer), GFP_KERNEL);
 		if (!xfer) {
-			dev_err(codec->dev, "Failed to allocate xfer\n");
 			ret = -ENOMEM;
 			goto abort;
 		}
@@ -423,8 +422,6 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 
 		out = kzalloc(len, GFP_KERNEL | GFP_DMA);
 		if (!out) {
-			dev_err(codec->dev,
-				"Failed to allocate RX buffer\n");
 			ret = -ENOMEM;
 			goto abort1;
 		}
@@ -432,8 +429,6 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 
 		img = kzalloc(len, GFP_KERNEL | GFP_DMA);
 		if (!img) {
-			dev_err(codec->dev,
-				"Failed to allocate image buffer\n");
 			ret = -ENOMEM;
 			goto abort1;
 		}
@@ -526,14 +521,12 @@ static int wm0010_stage2_load(struct snd_soc_codec *codec)
 	/* Copy to local buffer first as vmalloc causes problems for dma */
 	img = kzalloc(fw->size, GFP_KERNEL | GFP_DMA);
 	if (!img) {
-		dev_err(codec->dev, "Failed to allocate image buffer\n");
 		ret = -ENOMEM;
 		goto abort2;
 	}
 
 	out = kzalloc(fw->size, GFP_KERNEL | GFP_DMA);
 	if (!out) {
-		dev_err(codec->dev, "Failed to allocate output buffer\n");
 		ret = -ENOMEM;
 		goto abort1;
 	}
@@ -679,11 +672,8 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		}
 
 		img_swap = kzalloc(len, GFP_KERNEL | GFP_DMA);
-		if (!img_swap) {
-			dev_err(codec->dev,
-				"Failed to allocate image buffer\n");
+		if (!img_swap)
 			goto abort;
-		}
 
 		/* We need to re-order for 0010 */
 		byte_swap_64((u64 *)&pll_rec, img_swap, len);

commit a941145d2b3510242453242b88bb4e69b0a298e3
Merge: 108145a60675 c36c89096cb9
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Nov 8 10:43:41 2013 +0000

    Merge remote-tracking branch 'asoc/topic/wm0010' into asoc-next

commit f5b3a563943f415b99823be9918119f07337e328
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 18:39:52 2013 +0100

    ASoC: wm0010: Use WARN_ON() instead of BUG_ON()
    
    Use WARN_ON() and handle the error cases accordingly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index d5ebcb00019b..aea916431227 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -372,7 +372,8 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 	offset = 0;
 	dsp = inforec->dsp_target;
 	wm0010->boot_failed = false;
-	BUG_ON(!list_empty(&xfer_list));
+	if (WARN_ON(!list_empty(&xfer_list)))
+		return -EINVAL;
 	init_completion(&done);
 
 	/* First record should be INFO */

commit c36c89096cb9f95fbdb0a6f3d80d4b9a50537ed3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 30 08:35:03 2013 +0100

    ASoC: wm0010: Fix possible out-of-bounds array read
    
    Spotted by coverity CID 744701.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index d5ebcb00019b..bf7804a12863 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -793,11 +793,11 @@ static int wm0010_set_sysclk(struct snd_soc_codec *codec, int source,
 		wm0010->max_spi_freq = 0;
 	} else {
 		for (i = 0; i < ARRAY_SIZE(pll_clock_map); i++)
-			if (freq >= pll_clock_map[i].max_sysclk)
+			if (freq >= pll_clock_map[i].max_sysclk) {
+				wm0010->max_spi_freq = pll_clock_map[i].max_pll_spi_speed;
+				wm0010->pll_clkctrl1 = pll_clock_map[i].pll_clkctrl1;
 				break;
-
-		wm0010->max_spi_freq = pll_clock_map[i].max_pll_spi_speed;
-		wm0010->pll_clkctrl1 = pll_clock_map[i].pll_clkctrl1;
+			}
 	}
 
 	return 0;

commit d4780eec779c4e6d2fe5963dd2aee0a85d956122
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Aug 1 09:53:45 2013 +0100

    ASoC: wm0010: Use DMA-safe memory for SPI transfers
    
    We should be allocating our buffers for the SPI transfers
    from the DMA zone.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 10adc4145d46..d5ebcb00019b 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -420,7 +420,7 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 		xfer->codec = codec;
 		list_add_tail(&xfer->list, &xfer_list);
 
-		out = kzalloc(len, GFP_KERNEL);
+		out = kzalloc(len, GFP_KERNEL | GFP_DMA);
 		if (!out) {
 			dev_err(codec->dev,
 				"Failed to allocate RX buffer\n");
@@ -429,7 +429,7 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 		}
 		xfer->t.rx_buf = out;
 
-		img = kzalloc(len, GFP_KERNEL);
+		img = kzalloc(len, GFP_KERNEL | GFP_DMA);
 		if (!img) {
 			dev_err(codec->dev,
 				"Failed to allocate image buffer\n");
@@ -523,14 +523,14 @@ static int wm0010_stage2_load(struct snd_soc_codec *codec)
 	dev_dbg(codec->dev, "Downloading %zu byte stage 2 loader\n", fw->size);
 
 	/* Copy to local buffer first as vmalloc causes problems for dma */
-	img = kzalloc(fw->size, GFP_KERNEL);
+	img = kzalloc(fw->size, GFP_KERNEL | GFP_DMA);
 	if (!img) {
 		dev_err(codec->dev, "Failed to allocate image buffer\n");
 		ret = -ENOMEM;
 		goto abort2;
 	}
 
-	out = kzalloc(fw->size, GFP_KERNEL);
+	out = kzalloc(fw->size, GFP_KERNEL | GFP_DMA);
 	if (!out) {
 		dev_err(codec->dev, "Failed to allocate output buffer\n");
 		ret = -ENOMEM;
@@ -670,14 +670,14 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 
 		ret = -ENOMEM;
 		len = pll_rec.length + 8;
-		out = kzalloc(len, GFP_KERNEL);
+		out = kzalloc(len, GFP_KERNEL | GFP_DMA);
 		if (!out) {
 			dev_err(codec->dev,
 				"Failed to allocate RX buffer\n");
 			goto abort;
 		}
 
-		img_swap = kzalloc(len, GFP_KERNEL);
+		img_swap = kzalloc(len, GFP_KERNEL | GFP_DMA);
 		if (!img_swap) {
 			dev_err(codec->dev,
 				"Failed to allocate image buffer\n");

commit 4f8b19143d74e1c3360b21640065765a12bafb1b
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Jul 31 13:28:52 2013 +0100

    ASoC: wm0010: Fix resource leak
    
    If kzalloc() fails for `img' then we are going to leak the memory
    for `out'.  We are freeing the memory of all the tx/rx transfers
    but the tx/rx buf pointers will be NULL if we drop out earlier.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index f5e835662cdc..10adc4145d46 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -410,6 +410,16 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 			rec->command, rec->length);
 		len = rec->length + 8;
 
+		xfer = kzalloc(sizeof(*xfer), GFP_KERNEL);
+		if (!xfer) {
+			dev_err(codec->dev, "Failed to allocate xfer\n");
+			ret = -ENOMEM;
+			goto abort;
+		}
+
+		xfer->codec = codec;
+		list_add_tail(&xfer->list, &xfer_list);
+
 		out = kzalloc(len, GFP_KERNEL);
 		if (!out) {
 			dev_err(codec->dev,
@@ -417,6 +427,7 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 			ret = -ENOMEM;
 			goto abort1;
 		}
+		xfer->t.rx_buf = out;
 
 		img = kzalloc(len, GFP_KERNEL);
 		if (!img) {
@@ -425,24 +436,13 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 			ret = -ENOMEM;
 			goto abort1;
 		}
+		xfer->t.tx_buf = img;
 
 		byte_swap_64((u64 *)&rec->command, img, len);
 
-		xfer = kzalloc(sizeof(*xfer), GFP_KERNEL);
-		if (!xfer) {
-			dev_err(codec->dev, "Failed to allocate xfer\n");
-			ret = -ENOMEM;
-			goto abort1;
-		}
-
-		xfer->codec = codec;
-		list_add_tail(&xfer->list, &xfer_list);
-
 		spi_message_init(&xfer->m);
 		xfer->m.complete = wm0010_boot_xfer_complete;
 		xfer->m.context = xfer;
-		xfer->t.tx_buf = img;
-		xfer->t.rx_buf = out;
 		xfer->t.len = len;
 		xfer->t.bits_per_word = 8;
 

commit fd8b96574456e23fe7dad491711f371f86034c64
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Jun 3 15:57:55 2013 +0100

    ASoC: wm0010: Clear IRQ as wake source and include missing header
    
    Both clear the IRQ as being a wake source when we are finished with it
    and include a missing header file that is required.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index b6df319869ac..f5e835662cdc 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -14,6 +14,7 @@
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
+#include <linux/interrupt.h>
 #include <linux/irqreturn.h>
 #include <linux/init.h>
 #include <linux/spi/spi.h>
@@ -1002,6 +1003,8 @@ static int wm0010_spi_remove(struct spi_device *spi)
 	gpio_set_value_cansleep(wm0010->gpio_reset,
 				wm0010->gpio_reset_value);
 
+	irq_set_irq_wake(wm0010->irq, 0);
+
 	if (wm0010->irq)
 		free_irq(wm0010->irq, wm0010);
 

commit e684533b1044498606a37e2b5ba8bb0bef56067f
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu May 30 10:06:01 2013 +0100

    ASoC: wm0010: Set IRQ as a wake source
    
    The DSPs IRQ should be a wake source as several of the possible
    algorithms may run whilst the AP is asleepi and require to wake the AP
    to push or pull more data, such as compressed playback.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 370af0cbcc9a..b6df319869ac 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -972,6 +972,13 @@ static int wm0010_spi_probe(struct spi_device *spi)
 	}
 	wm0010->irq = irq;
 
+	ret = irq_set_irq_wake(irq, 1);
+	if (ret) {
+		dev_err(wm0010->dev, "Failed to set IRQ %d as wake source: %d\n",
+			irq, ret);
+		return ret;
+	}
+
 	if (spi->max_speed_hz)
 		wm0010->board_max_spi_speed = spi->max_speed_hz;
 	else

commit 407a0e18ecfbd7f58f49c307a657b63e6f32544d
Merge: c583eac39abf 2e0192f13c44
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue May 14 16:53:21 2013 +0400

    Merge remote-tracking branch 'asoc/fix/wm0010' into asoc-linus

commit 2e0192f13c4428bb624838a9cc6713b6237bab3b
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Tue May 7 19:38:52 2013 +0800

    ASoC: wm0010: fix error return code in wm0010_boot()
    
    Fix to return -ENOMEM in the memory malloc of 'out' and 'img_swap' error
    handling case instead of 0, as done elsewhere in this function.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index ad2fee4bb4cd..fe5e10fd51df 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -667,6 +667,7 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		/* On wm0010 only the CLKCTRL1 value is used */
 		pll_rec.clkctrl1 = wm0010->pll_clkctrl1;
 
+		ret = -ENOMEM;
 		len = pll_rec.length + 8;
 		out = kzalloc(len, GFP_KERNEL);
 		if (!out) {

commit 3e112af51eedda46fe87d2cba427d48c4b7695fd
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Fri Mar 29 09:45:35 2013 +0000

    ASoC: wm0010: Report filename when we fail to load firmware
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 55fdf0f4406c..8df2b6e1a1a6 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -361,8 +361,8 @@ static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 
 	ret = request_firmware(&fw, name, codec->dev);
 	if (ret != 0) {
-		dev_err(codec->dev, "Failed to request application: %d\n",
-			ret);
+		dev_err(codec->dev, "Failed to request application(%s): %d\n",
+			name, ret);
 		return ret;
 	}
 

commit 961b0fc840bf70511ef87d2f799eab014b4d2d37
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Fri Mar 29 09:45:34 2013 +0000

    ASoC: wm0010: Constify usage of firmware filenames
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index ad2fee4bb4cd..55fdf0f4406c 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -342,7 +342,7 @@ static void byte_swap_64(u64 *data_in, u64 *data_out, u32 len)
 		data_out[i] = cpu_to_be64(le64_to_cpu(data_in[i]));
 }
 
-static int wm0010_firmware_load(char *name, struct snd_soc_codec *codec)
+static int wm0010_firmware_load(const char *name, struct snd_soc_codec *codec)
 {
 	struct spi_device *spi = to_spi_device(codec->dev);
 	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);

commit 7a79e94e973639da7bf1b8242d504f9db9e5e848
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Dec 7 09:26:37 2012 -0500

    ASoC: codecs: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 40256b526259..ad2fee4bb4cd 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -885,7 +885,7 @@ static int wm0010_probe(struct snd_soc_codec *codec)
 	return 0;
 }
 
-static int __devinit wm0010_spi_probe(struct spi_device *spi)
+static int wm0010_spi_probe(struct spi_device *spi)
 {
 	unsigned long gpio_flags;
 	int ret;
@@ -985,7 +985,7 @@ static int __devinit wm0010_spi_probe(struct spi_device *spi)
 	return 0;
 }
 
-static int __devexit wm0010_spi_remove(struct spi_device *spi)
+static int wm0010_spi_remove(struct spi_device *spi)
 {
 	struct wm0010_priv *wm0010 = spi_get_drvdata(spi);
 
@@ -1007,7 +1007,7 @@ static struct spi_driver wm0010_spi_driver = {
 		.owner	= THIS_MODULE,
 	},
 	.probe		= wm0010_spi_probe,
-	.remove		= __devexit_p(wm0010_spi_remove),
+	.remove		= wm0010_spi_remove,
 };
 
 module_spi_driver(wm0010_spi_driver);

commit 5d910966d24b755c2ad2231e934fc71af55a1ee7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Oct 8 14:48:17 2012 +0900

    ASoC: wm0010: Ignore interrupts in power down mode
    
    The device should not be generating interrupts when it does not have power
    so ignore incoming interrupts.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 3c3a7b16bb8b..40256b526259 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -862,7 +862,6 @@ static irqreturn_t wm0010_irq(int irq, void *data)
 	struct wm0010_priv *wm0010 = data;
 
 	switch (wm0010->state) {
-	case WM0010_POWER_OFF:
 	case WM0010_OUT_OF_RESET:
 	case WM0010_BOOTROM:
 	case WM0010_STAGE2:

commit 68e1969ea705dafcee721f02c4fbc34466917f83
Author: Scott Ling <sl@opensource.wolfsonmicro.com>
Date:   Fri Nov 23 12:37:35 2012 +0000

    ASoC: wm0010: Add checking for .dfw info record version.
    
    The info record at the start of the dsp firmware file has been
    expanded to incorporate additional version information. We need
    to check the version to make sure we understand the layout of
    the information in the record. The srec2image tool is currently
    used to create this record during creation of the .dfw file.
    
    Signed-off-by: Scott Ling <sl@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 8ebb8da88f73..3c3a7b16bb8b 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -31,6 +31,9 @@
 
 #define DEVICE_ID_WM0010	10
 
+/* We only support v1 of the .dfw INFO record */
+#define INFO_VERSION		1
+
 enum dfw_cmd {
 	DFW_CMD_FUSE = 0x01,
 	DFW_CMD_CODE_HDR,
@@ -46,6 +49,13 @@ struct dfw_binrec {
 	uint8_t data[0];
 } __packed;
 
+struct dfw_inforec {
+	u8 info_version;
+	u8 tool_major_version;
+	u8 tool_minor_version;
+	u8 dsp_target;
+};
+
 struct dfw_pllrec {
 	u8 command;
 	u32 length:24;
@@ -342,6 +352,7 @@ static int wm0010_firmware_load(char *name, struct snd_soc_codec *codec)
 	struct completion done;
 	const struct firmware *fw;
 	const struct dfw_binrec *rec;
+	const struct dfw_inforec *inforec;
 	u64 *img;
 	u8 *out, dsp;
 	u32 len, offset;
@@ -356,8 +367,9 @@ static int wm0010_firmware_load(char *name, struct snd_soc_codec *codec)
 	}
 
 	rec = (const struct dfw_binrec *)fw->data;
+	inforec = (const struct dfw_inforec *)rec->data;
 	offset = 0;
-	dsp = rec->data[0];
+	dsp = inforec->dsp_target;
 	wm0010->boot_failed = false;
 	BUG_ON(!list_empty(&xfer_list));
 	init_completion(&done);
@@ -369,6 +381,17 @@ static int wm0010_firmware_load(char *name, struct snd_soc_codec *codec)
 		goto abort;
 	}
 
+	if (inforec->info_version != INFO_VERSION) {
+		dev_err(codec->dev,
+			"Unsupported version (%02d) of INFO record\r\n",
+			inforec->info_version);
+		ret = -EINVAL;
+		goto abort;
+	}
+
+	dev_dbg(codec->dev, "Version v%02d INFO record found\r\n",
+		inforec->info_version);
+
 	/* Check it's a DSP file */
 	if (dsp != DEVICE_ID_WM0010) {
 		dev_err(codec->dev, "Not a WM0010 firmware file.\r\n");

commit 631fcab2eafc38a1415165ceaa217494c3f70ba5
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Nov 21 10:47:44 2012 +0000

    ASoC: wm0010: Up the completion timeout to 20ms instead of 10ms
    
    Increase timeout to be more reliable and avoid the chance of
    missing interrupts during boot.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 4b68ea86d7cb..8ebb8da88f73 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -614,7 +614,7 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	}
 
 	if (!wait_for_completion_timeout(&wm0010->boot_completion,
-					 msecs_to_jiffies(10)))
+					 msecs_to_jiffies(20)))
 		dev_err(codec->dev, "Failed to get interrupt from DSP\n");
 
 	spin_lock_irqsave(&wm0010->irq_lock, flags);
@@ -626,7 +626,7 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		goto abort;
 
 	if (!wait_for_completion_timeout(&wm0010->boot_completion,
-					 msecs_to_jiffies(10)))
+					 msecs_to_jiffies(20)))
 		dev_err(codec->dev, "Failed to get interrupt from DSP loader.\n");
 
 	spin_lock_irqsave(&wm0010->irq_lock, flags);

commit 3f5475df378cfcac51e9384153aef122555a60cb
Author: Scott Ling <sl@opensource.wolfsonmicro.com>
Date:   Wed Nov 7 16:53:18 2012 +0000

    ASoC: wm0010: Split out the stage2 load from the boot function
    
    Signed-off-by: Scott Ling <sl@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 7576330044ba..4b68ea86d7cb 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -477,6 +477,82 @@ static int wm0010_firmware_load(char *name, struct snd_soc_codec *codec)
 	return ret;
 }
 
+static int wm0010_stage2_load(struct snd_soc_codec *codec)
+{
+	struct spi_device *spi = to_spi_device(codec->dev);
+	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	const struct firmware *fw;
+	struct spi_message m;
+	struct spi_transfer t;
+	u32 *img;
+	u8 *out;
+	int i;
+	int ret = 0;
+
+	ret = request_firmware(&fw, "wm0010_stage2.bin", codec->dev);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to request stage2 loader: %d\n",
+			ret);
+		return ret;
+	}
+
+	dev_dbg(codec->dev, "Downloading %zu byte stage 2 loader\n", fw->size);
+
+	/* Copy to local buffer first as vmalloc causes problems for dma */
+	img = kzalloc(fw->size, GFP_KERNEL);
+	if (!img) {
+		dev_err(codec->dev, "Failed to allocate image buffer\n");
+		ret = -ENOMEM;
+		goto abort2;
+	}
+
+	out = kzalloc(fw->size, GFP_KERNEL);
+	if (!out) {
+		dev_err(codec->dev, "Failed to allocate output buffer\n");
+		ret = -ENOMEM;
+		goto abort1;
+	}
+
+	memcpy(img, &fw->data[0], fw->size);
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+	t.rx_buf = out;
+	t.tx_buf = img;
+	t.len = fw->size;
+	t.bits_per_word = 8;
+	t.speed_hz = wm0010->sysclk / 10;
+	spi_message_add_tail(&t, &m);
+
+	dev_dbg(codec->dev, "Starting initial download at %dHz\n",
+		t.speed_hz);
+
+	ret = spi_sync(spi, &m);
+	if (ret != 0) {
+		dev_err(codec->dev, "Initial download failed: %d\n", ret);
+		goto abort;
+	}
+
+	/* Look for errors from the boot ROM */
+	for (i = 0; i < fw->size; i++) {
+		if (out[i] != 0x55) {
+			dev_err(codec->dev, "Boot ROM error: %x in %d\n",
+				out[i], i);
+			wm0010_mark_boot_failure(wm0010);
+			ret = -EBUSY;
+			goto abort;
+		}
+	}
+abort:
+	kfree(out);
+abort1:
+	kfree(img);
+abort2:
+	release_firmware(fw);
+
+	return ret;
+}
+
 static int wm0010_boot(struct snd_soc_codec *codec)
 {
 	struct spi_device *spi = to_spi_device(codec->dev);
@@ -487,10 +563,9 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	struct spi_message m;
 	struct spi_transfer t;
 	struct dfw_pllrec pll_rec;
-	u32 *img, *p;
+	u32 *p, len;
 	u64 *img_swap;
 	u8 *out;
-	u32 len;
 	int i;
 
 	spin_lock_irqsave(&wm0010->irq_lock, flags);
@@ -546,55 +621,9 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	wm0010->state = WM0010_BOOTROM;
 	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
 
-	dev_dbg(codec->dev, "Downloading %zu byte stage 2 loader\n", fw->size);
-
-	/* Copy to local buffer first as vmalloc causes problems for dma */
-	img = kzalloc(fw->size, GFP_KERNEL);
-	if (!img) {
-		dev_err(codec->dev, "Failed to allocate image buffer\n");
-		goto abort;
-	}
-
-	out = kzalloc(fw->size, GFP_KERNEL);
-	if (!out) {
-		dev_err(codec->dev, "Failed to allocate output buffer\n");
-		goto abort;
-	}
-
-	memcpy(img, &fw->data[0], fw->size);
-
-	spi_message_init(&m);
-	memset(&t, 0, sizeof(t));
-	t.rx_buf = out;
-	t.tx_buf = img;
-	t.len = fw->size;
-	t.bits_per_word = 8;
-	t.speed_hz = wm0010->sysclk / 10;
-	spi_message_add_tail(&t, &m);
-
-	dev_dbg(codec->dev, "Starting initial download at %dHz\n",
-		t.speed_hz);
-
-	ret = spi_sync(spi, &m);
-	if (ret != 0) {
-		dev_err(codec->dev, "Initial download failed: %d\n", ret);
+	ret = wm0010_stage2_load(codec);
+	if (ret)
 		goto abort;
-	}
-
-	/* Look for errors from the boot ROM */
-	for (i = 0; i < fw->size; i++) {
-		if (out[i] != 0x55) {
-			ret = -EBUSY;
-			dev_err(codec->dev, "Boot ROM error: %x in %d\n",
-				out[i], i);
-			wm0010_mark_boot_failure(wm0010);
-			goto abort;
-		}
-	}
-
-	release_firmware(fw);
-	kfree(img);
-	kfree(out);
 
 	if (!wait_for_completion_timeout(&wm0010->boot_completion,
 					 msecs_to_jiffies(10)))

commit 8f7d52affeb8341cbc602209b6f35eedb410d3ee
Author: Scott Ling <sl@opensource.wolfsonmicro.com>
Date:   Wed Nov 7 16:53:17 2012 +0000

    ASoC: wm0010: Split out the firmware file parsing from the boot
    
    Move the firmware load and record parsing functionality out into
    a separate function from the boot function.
    
    Signed-off-by: Scott Ling <sl@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 5c1291748326..7576330044ba 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -332,24 +332,165 @@ static void byte_swap_64(u64 *data_in, u64 *data_out, u32 len)
 		data_out[i] = cpu_to_be64(le64_to_cpu(data_in[i]));
 }
 
-static int wm0010_boot(struct snd_soc_codec *codec)
+static int wm0010_firmware_load(char *name, struct snd_soc_codec *codec)
 {
 	struct spi_device *spi = to_spi_device(codec->dev);
 	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
-	unsigned long flags;
 	struct list_head xfer_list;
 	struct wm0010_boot_xfer *xfer;
 	int ret;
 	struct completion done;
 	const struct firmware *fw;
 	const struct dfw_binrec *rec;
+	u64 *img;
+	u8 *out, dsp;
+	u32 len, offset;
+
+	INIT_LIST_HEAD(&xfer_list);
+
+	ret = request_firmware(&fw, name, codec->dev);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to request application: %d\n",
+			ret);
+		return ret;
+	}
+
+	rec = (const struct dfw_binrec *)fw->data;
+	offset = 0;
+	dsp = rec->data[0];
+	wm0010->boot_failed = false;
+	BUG_ON(!list_empty(&xfer_list));
+	init_completion(&done);
+
+	/* First record should be INFO */
+	if (rec->command != DFW_CMD_INFO) {
+		dev_err(codec->dev, "First record not INFO\r\n");
+		ret = -EINVAL;
+		goto abort;
+	}
+
+	/* Check it's a DSP file */
+	if (dsp != DEVICE_ID_WM0010) {
+		dev_err(codec->dev, "Not a WM0010 firmware file.\r\n");
+		ret = -EINVAL;
+		goto abort;
+	}
+
+	/* Skip the info record as we don't need to send it */
+	offset += ((rec->length) + 8);
+	rec = (void *)&rec->data[rec->length];
+
+	while (offset < fw->size) {
+		dev_dbg(codec->dev,
+			"Packet: command %d, data length = 0x%x\r\n",
+			rec->command, rec->length);
+		len = rec->length + 8;
+
+		out = kzalloc(len, GFP_KERNEL);
+		if (!out) {
+			dev_err(codec->dev,
+				"Failed to allocate RX buffer\n");
+			ret = -ENOMEM;
+			goto abort1;
+		}
+
+		img = kzalloc(len, GFP_KERNEL);
+		if (!img) {
+			dev_err(codec->dev,
+				"Failed to allocate image buffer\n");
+			ret = -ENOMEM;
+			goto abort1;
+		}
+
+		byte_swap_64((u64 *)&rec->command, img, len);
+
+		xfer = kzalloc(sizeof(*xfer), GFP_KERNEL);
+		if (!xfer) {
+			dev_err(codec->dev, "Failed to allocate xfer\n");
+			ret = -ENOMEM;
+			goto abort1;
+		}
+
+		xfer->codec = codec;
+		list_add_tail(&xfer->list, &xfer_list);
+
+		spi_message_init(&xfer->m);
+		xfer->m.complete = wm0010_boot_xfer_complete;
+		xfer->m.context = xfer;
+		xfer->t.tx_buf = img;
+		xfer->t.rx_buf = out;
+		xfer->t.len = len;
+		xfer->t.bits_per_word = 8;
+
+		if (!wm0010->pll_running) {
+			xfer->t.speed_hz = wm0010->sysclk / 6;
+		} else {
+			xfer->t.speed_hz = wm0010->max_spi_freq;
+
+			if (wm0010->board_max_spi_speed &&
+			   (wm0010->board_max_spi_speed < wm0010->max_spi_freq))
+					xfer->t.speed_hz = wm0010->board_max_spi_speed;
+		}
+
+		/* Store max usable spi frequency for later use */
+		wm0010->max_spi_freq = xfer->t.speed_hz;
+
+		spi_message_add_tail(&xfer->t, &xfer->m);
+
+		offset += ((rec->length) + 8);
+		rec = (void *)&rec->data[rec->length];
+
+		if (offset >= fw->size) {
+			dev_dbg(codec->dev, "All transfers scheduled\n");
+			xfer->done = &done;
+		}
+
+		ret = spi_async(spi, &xfer->m);
+		if (ret != 0) {
+			dev_err(codec->dev, "Write failed: %d\n", ret);
+			goto abort1;
+		}
+
+		if (wm0010->boot_failed) {
+			dev_dbg(codec->dev, "Boot fail!\n");
+			ret = -EINVAL;
+			goto abort1;
+		}
+	}
+
+	wait_for_completion(&done);
+
+	ret = 0;
+
+abort1:
+	while (!list_empty(&xfer_list)) {
+		xfer = list_first_entry(&xfer_list, struct wm0010_boot_xfer,
+					list);
+		kfree(xfer->t.rx_buf);
+		kfree(xfer->t.tx_buf);
+		list_del(&xfer->list);
+		kfree(xfer);
+	}
+
+abort:
+	release_firmware(fw);
+	return ret;
+}
+
+static int wm0010_boot(struct snd_soc_codec *codec)
+{
+	struct spi_device *spi = to_spi_device(codec->dev);
+	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	unsigned long flags;
+	int ret;
+	const struct firmware *fw;
 	struct spi_message m;
 	struct spi_transfer t;
 	struct dfw_pllrec pll_rec;
 	u32 *img, *p;
 	u64 *img_swap;
 	u8 *out;
-	u32 len, offset;
+	u32 len;
 	int i;
 
 	spin_lock_irqsave(&wm0010->irq_lock, flags);
@@ -363,8 +504,6 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 		goto err;
 	}
 
-	INIT_LIST_HEAD(&xfer_list);
-
 	mutex_lock(&wm0010->lock);
 	wm0010->pll_running = false;
 
@@ -533,109 +672,10 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	} else
 		dev_dbg(codec->dev, "Not enabling DSP PLL.");
 
-	ret = request_firmware(&fw, "wm0010.dfw", codec->dev);
-	if (ret != 0) {
-		dev_err(codec->dev, "Failed to request application: %d\n",
-			ret);
-		goto abort;
-	}
+	ret = wm0010_firmware_load("wm0010.dfw", codec);
 
-	rec = (const struct dfw_binrec *)fw->data;
-	offset = 0;
-	wm0010->boot_failed = false;
-	BUG_ON(!list_empty(&xfer_list));
-	init_completion(&done);
-
-	/* First record should be INFO */
-	if (rec->command != DFW_CMD_INFO) {
-		dev_err(codec->dev, "First record not INFO\r\n");
-		goto abort;
-	}
-
-	/* Check it's a 0010 file */
-	if (rec->data[0] != DEVICE_ID_WM0010) {
-		dev_err(codec->dev, "Not a WM0010 firmware file.\r\n");
+	if (ret != 0)
 		goto abort;
-	}
-
-	/* Skip the info record as we don't need to send it */
-	offset += ((rec->length) + 8);
-	rec = (void *)&rec->data[rec->length];
-
-	while (offset < fw->size) {
-		dev_dbg(codec->dev,
-			"Packet: command %d, data length = 0x%x\r\n",
-			rec->command, rec->length);
-		len = rec->length + 8;
-
-		out = kzalloc(len, GFP_KERNEL);
-		if (!out) {
-			dev_err(codec->dev,
-				"Failed to allocate RX buffer\n");
-			goto abort;
-		}
-
-		img_swap = kzalloc(len, GFP_KERNEL);
-		if (!img_swap) {
-			dev_err(codec->dev,
-				"Failed to allocate image buffer\n");
-			goto abort;
-		}
-
-		/* We need to re-order for 0010 */
-		byte_swap_64((u64 *)&rec->command, img_swap, len);
-
-		xfer = kzalloc(sizeof(*xfer), GFP_KERNEL);
-		if (!xfer) {
-			dev_err(codec->dev, "Failed to allocate xfer\n");
-			goto abort;
-		}
-
-		xfer->codec = codec;
-		list_add_tail(&xfer->list, &xfer_list);
-
-		spi_message_init(&xfer->m);
-		xfer->m.complete = wm0010_boot_xfer_complete;
-		xfer->m.context = xfer;
-		xfer->t.tx_buf = img_swap;
-		xfer->t.rx_buf = out;
-		xfer->t.len = len;
-		xfer->t.bits_per_word = 8;
-
-		if (!wm0010->pll_running) {
-			xfer->t.speed_hz = wm0010->sysclk / 6;
-		} else {
-			xfer->t.speed_hz = wm0010->max_spi_freq;
-
-			if (wm0010->board_max_spi_speed &&
-			   (wm0010->board_max_spi_speed < wm0010->max_spi_freq))
-					xfer->t.speed_hz = wm0010->board_max_spi_speed;
-		}
-
-		/* Store max usable spi frequency for later use */
-		wm0010->max_spi_freq = xfer->t.speed_hz;
-
-		spi_message_add_tail(&xfer->t, &xfer->m);
-
-		offset += ((rec->length) + 8);
-		rec = (void *)&rec->data[rec->length];
-
-		if (offset >= fw->size) {
-			dev_dbg(codec->dev, "All transfers scheduled\n");
-			xfer->done = &done;
-		}
-
-		ret = spi_async(spi, &xfer->m);
-		if (ret != 0) {
-			dev_err(codec->dev, "Write failed: %d\n", ret);
-			goto abort;
-		}
-
-		if (wm0010->boot_failed)
-			goto abort;
-	}
-
-	wait_for_completion(&done);
 
 	spin_lock_irqsave(&wm0010->irq_lock, flags);
 	wm0010->state = WM0010_FIRMWARE;
@@ -643,17 +683,6 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 
 	mutex_unlock(&wm0010->lock);
 
-	release_firmware(fw);
-
-	while (!list_empty(&xfer_list)) {
-		xfer = list_first_entry(&xfer_list, struct wm0010_boot_xfer,
-					list);
-		kfree(xfer->t.rx_buf);
-		kfree(xfer->t.tx_buf);
-		list_del(&xfer->list);
-		kfree(xfer);
-	}
-
 	return 0;
 
 abort:

commit f9baa0ccb2500be60c51aec6d1f3988dec0df3fe
Author: Scott Ling <scott.ling@wolfsonmicro.com>
Date:   Mon Nov 5 14:44:25 2012 +0000

    ASoC: wm0010: Remove boot_done variable as no longer required.
    
    Remove the boot_done counter variable and check the wm0010 state
    variable instead.
    
    Signed-off-by: Scott Ling <scott.ling@wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 99afc003a084..5c1291748326 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -97,7 +97,6 @@ struct wm0010_priv {
 
 	enum wm0010_state state;
 	bool boot_failed;
-	int boot_done;
 	bool ready;
 	bool pll_running;
 	int max_spi_freq;
@@ -234,7 +233,7 @@ static void wm0010_boot_xfer_complete(void *data)
 			break;
 
 		case 0x55555555:
-			if (wm0010->boot_done == 0)
+			if (wm0010->state < WM0010_STAGE2)
 				break;
 			dev_err(codec->dev,
 				"%d: ROM bootloader running in stage 2\n", i);
@@ -321,7 +320,6 @@ static void wm0010_boot_xfer_complete(void *data)
 			break;
 	}
 
-	wm0010->boot_done++;
 	if (xfer->done)
 		complete(xfer->done);
 }
@@ -544,7 +542,6 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 
 	rec = (const struct dfw_binrec *)fw->data;
 	offset = 0;
-	wm0010->boot_done = 0;
 	wm0010->boot_failed = false;
 	BUG_ON(!list_empty(&xfer_list));
 	init_completion(&done);

commit 9bb684442cf48c0e0736f5902f112c4f39ee3677
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 25 19:04:25 2012 +0100

    ASoC: wm0010: Initialise chip state before we register the interrupt
    
    The interrupt handler uses the chip state.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 780110a15c97..99afc003a084 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -810,7 +810,6 @@ static int wm0010_probe(struct snd_soc_codec *codec)
 
 static int __devinit wm0010_spi_probe(struct spi_device *spi)
 {
-	unsigned long flags;
 	unsigned long gpio_flags;
 	int ret;
 	int trigger;
@@ -877,6 +876,8 @@ static int __devinit wm0010_spi_probe(struct spi_device *spi)
 		return -EINVAL;
 	}
 
+	wm0010->state = WM0010_POWER_OFF;
+
 	irq = spi->irq;
 	if (wm0010->pdata.irq_flags)
 		trigger = wm0010->pdata.irq_flags;
@@ -898,10 +899,6 @@ static int __devinit wm0010_spi_probe(struct spi_device *spi)
 	else
 		wm0010->board_max_spi_speed = 0;
 
-	spin_lock_irqsave(&wm0010->irq_lock, flags);
-	wm0010->state = WM0010_POWER_OFF;
-	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
-
 	ret = snd_soc_register_codec(&spi->dev,
 				     &soc_codec_dev_wm0010, wm0010_dai,
 				     ARRAY_SIZE(wm0010_dai));

commit 5afe5bfe243d649aa5118c74317cbcbe85a04cb9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 25 16:36:56 2012 +0100

    ASoC: wm0010: Don't check if reset GPIO is defined when removing
    
    We will fail to probe without one.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 4722acfb82a8..780110a15c97 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -917,11 +917,8 @@ static int __devexit wm0010_spi_remove(struct spi_device *spi)
 
 	snd_soc_unregister_codec(&spi->dev);
 
-	if (wm0010->gpio_reset) {
-		/* Remember to put chip back into reset */
-		gpio_set_value_cansleep(wm0010->gpio_reset,
-					wm0010->gpio_reset_value);
-	}
+	gpio_set_value_cansleep(wm0010->gpio_reset,
+				wm0010->gpio_reset_value);
 
 	if (wm0010->irq)
 		free_irq(wm0010->irq, wm0010);

commit fff00cbca13ab303b3995353d22c47e6b0f68fd8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 25 16:35:26 2012 +0100

    ASoC: wm0010: Allow slow GPIO for reset
    
    We never set the GPIO from atomic context so there's no reason why we
    can't support a GPIO that needs to sleep when configuring.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index f8d6c31db870..4722acfb82a8 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -168,7 +168,8 @@ static void wm0010_halt(struct snd_soc_codec *codec)
 	case WM0010_STAGE2:
 	case WM0010_FIRMWARE:
 		/* Remember to put chip back into reset */
-		gpio_set_value(wm0010->gpio_reset, wm0010->gpio_reset_value);
+		gpio_set_value_cansleep(wm0010->gpio_reset,
+					wm0010->gpio_reset_value);
 		/* Disable the regulators */
 		regulator_disable(wm0010->dbvdd);
 		regulator_bulk_disable(ARRAY_SIZE(wm0010->core_supplies),
@@ -387,7 +388,7 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	}
 
 	/* Release reset */
-	gpio_set_value(wm0010->gpio_reset, !wm0010->gpio_reset_value);
+	gpio_set_value_cansleep(wm0010->gpio_reset, !wm0010->gpio_reset_value);
 	spin_lock_irqsave(&wm0010->irq_lock, flags);
 	wm0010->state = WM0010_OUT_OF_RESET;
 	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
@@ -918,7 +919,8 @@ static int __devexit wm0010_spi_remove(struct spi_device *spi)
 
 	if (wm0010->gpio_reset) {
 		/* Remember to put chip back into reset */
-		gpio_set_value(wm0010->gpio_reset, wm0010->gpio_reset_value);
+		gpio_set_value_cansleep(wm0010->gpio_reset,
+					wm0010->gpio_reset_value);
 	}
 
 	if (wm0010->irq)

commit 5d86e25c70407cd97a5aa8f39cc3be390bcab116
Author: Emil Goode <emilgoode@gmail.com>
Date:   Wed Sep 5 22:22:24 2012 +0200

    ASoC: wm0010: Fix warning, use format %zu for type size_t
    
    Fix warning by using format specifier %zu for type size_t
    
    Sparse warning:
    sound/soc/codecs/wm0010.c:411:2: warning:
            format ‘%d’ expects argument of type ‘int’,
            but argument 4 has type ‘size_t’ [-Wformat]
    
    Signed-off-by: Emil Goode <emilgoode@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 0274f04a940a..f8d6c31db870 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -408,7 +408,7 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	wm0010->state = WM0010_BOOTROM;
 	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
 
-	dev_dbg(codec->dev, "Downloading %d byte stage 2 loader\n", fw->size);
+	dev_dbg(codec->dev, "Downloading %zu byte stage 2 loader\n", fw->size);
 
 	/* Copy to local buffer first as vmalloc causes problems for dma */
 	img = kzalloc(fw->size, GFP_KERNEL);

commit 4f3ad7956d91a5371a572f0420cc07f8c4f32c22
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Sep 5 15:29:46 2012 +0300

    ASoC: wm0010: unlock on error path
    
    We're holding the wm0010->lock mutex when we goto err_core.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index a4c35119792e..0274f04a940a 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -663,7 +663,9 @@ static int wm0010_boot(struct snd_soc_codec *codec)
 	wm0010_halt(codec);
 	mutex_unlock(&wm0010->lock);
 	return ret;
+
 err_core:
+	mutex_unlock(&wm0010->lock);
 	regulator_bulk_disable(ARRAY_SIZE(wm0010->core_supplies),
 			       wm0010->core_supplies);
 err:

commit 58d468328646effa72ada4deaa33e80d678980d6
Author: Fengguang Wu <fengguang.wu@intel.com>
Date:   Thu Aug 30 08:16:52 2012 -0700

    ASoC: wm0010: Add missing IRQF_ONESHOT
    
    FYI, there are new coccinelle warnings show up in
    
    tree:   git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound.git for-3.7
    head:   e3523e01869da20fdd12ffd19ae1df7bf492650e
    commit: e3523e01869da20fdd12ffd19ae1df7bf492650e [95/95] ASoC: wm0010: Add initial wm0010 DSP driver
    
    All coccinelle warnings:
    
    + sound/soc/codecs/wm0010.c:850:7-27: ERROR: Threaded IRQ with no primary handler requested without IRQF_ONESHOT
    --
    + sound/soc/codecs/wm0010.c:660:1-7: preceding lock on line 359
    
    vim +850 sound/soc/codecs/wm0010.c
       847                  trigger = IRQF_TRIGGER_FALLING;
       848          trigger |= IRQF_ONESHOT;
       849
     > 850          ret = request_threaded_irq(irq, NULL, wm0010_irq, trigger,
       851                                     "wm0010", wm0010);
       852          if (ret)
       853                  dev_err(wm0010->dev, "Failed to request IRQ %d: %d\n",
    
    Please consider folding the attached diff :-)
    
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 5f99148447e1..a4c35119792e 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -881,7 +881,7 @@ static int __devinit wm0010_spi_probe(struct spi_device *spi)
 		trigger = IRQF_TRIGGER_FALLING;
 	trigger |= IRQF_ONESHOT;
 
-	ret = request_threaded_irq(irq, NULL, wm0010_irq, trigger,
+	ret = request_threaded_irq(irq, NULL, wm0010_irq, trigger | IRQF_ONESHOT,
 				   "wm0010", wm0010);
 	if (ret) {
 		dev_err(wm0010->dev, "Failed to request IRQ %d: %d\n",

commit 32c50a31aad77e8faf2718d149da13f2136c1b46
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Aug 25 13:04:04 2012 -0700

    ASoC: wm0010: Move resource acquisition to device probe
    
    This is more idimatic for modern drivers. Also fix a couple of return
    codes while we're at it.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 30ec0bd85307..5f99148447e1 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -799,14 +799,35 @@ static irqreturn_t wm0010_irq(int irq, void *data)
 static int wm0010_probe(struct snd_soc_codec *codec)
 {
 	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
-	struct spi_device *spi = to_spi_device(wm0010->dev);
+
+	wm0010->codec = codec;
+
+	return 0;
+}
+
+static int __devinit wm0010_spi_probe(struct spi_device *spi)
+{
 	unsigned long flags;
 	unsigned long gpio_flags;
 	int ret;
 	int trigger;
 	int irq;
+	struct wm0010_priv *wm0010;
 
-	wm0010->codec = codec;
+	wm0010 = devm_kzalloc(&spi->dev, sizeof(*wm0010),
+			      GFP_KERNEL);
+	if (!wm0010)
+		return -ENOMEM;
+
+	mutex_init(&wm0010->lock);
+	spin_lock_init(&wm0010->irq_lock);
+
+	spi_set_drvdata(spi, wm0010);
+	wm0010->dev = &spi->dev;
+
+	if (dev_get_platdata(&spi->dev))
+		memcpy(&wm0010->pdata, dev_get_platdata(&spi->dev),
+		       sizeof(wm0010->pdata));
 
 	init_completion(&wm0010->boot_completion);
 
@@ -850,7 +871,7 @@ static int wm0010_probe(struct snd_soc_codec *codec)
 		}
 	} else {
 		dev_err(wm0010->dev, "No reset GPIO configured\n");
-		return ret;
+		return -EINVAL;
 	}
 
 	irq = spi->irq;
@@ -862,9 +883,11 @@ static int wm0010_probe(struct snd_soc_codec *codec)
 
 	ret = request_threaded_irq(irq, NULL, wm0010_irq, trigger,
 				   "wm0010", wm0010);
-	if (ret)
+	if (ret) {
 		dev_err(wm0010->dev, "Failed to request IRQ %d: %d\n",
 			irq, ret);
+		return ret;
+	}
 	wm0010->irq = irq;
 
 	if (spi->max_speed_hz)
@@ -876,29 +899,6 @@ static int wm0010_probe(struct snd_soc_codec *codec)
 	wm0010->state = WM0010_POWER_OFF;
 	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
 
-	return 0;
-}
-
-static int __devinit wm0010_spi_probe(struct spi_device *spi)
-{
-	struct wm0010_priv *wm0010;
-	int ret;
-
-	wm0010 = devm_kzalloc(&spi->dev, sizeof(*wm0010),
-			      GFP_KERNEL);
-	if (!wm0010)
-		return -ENOMEM;
-
-	mutex_init(&wm0010->lock);
-	spin_lock_init(&wm0010->irq_lock);
-
-	spi_set_drvdata(spi, wm0010);
-	wm0010->dev = &spi->dev;
-
-	if (dev_get_platdata(&spi->dev))
-		memcpy(&wm0010->pdata, dev_get_platdata(&spi->dev),
-		       sizeof(wm0010->pdata));
-
 	ret = snd_soc_register_codec(&spi->dev,
 				     &soc_codec_dev_wm0010, wm0010_dai,
 				     ARRAY_SIZE(wm0010_dai));

commit bf9d323722845c8643287dca436e04e34cb21bb8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Aug 25 13:01:15 2012 -0700

    ASoC: wm0010: Tweak diagnostic output
    
    Make it scan better by writing ROM with capitals.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 6c4a2fa90fbe..30ec0bd85307 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -137,7 +137,7 @@ static const char *wm0010_state_to_str(enum wm0010_state state)
 	const char *state_to_str[] = {
 		"Power off",
 		"Out of reset",
-		"Bootrom",
+		"Boot ROM",
 		"Stage2",
 		"Firmware"
 	};

commit 4f3c3c1b32bb8fddcd7f626c2fb09d55f469f976
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Aug 25 09:24:16 2012 -0700

    ASoC: wm0010: Don't double free reset GPIO
    
    We are using devm_ to allocate the GPIO so it will be freed automatically.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 61ec7633fe5a..6c4a2fa90fbe 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -917,7 +917,6 @@ static int __devexit wm0010_spi_remove(struct spi_device *spi)
 	if (wm0010->gpio_reset) {
 		/* Remember to put chip back into reset */
 		gpio_set_value(wm0010->gpio_reset, wm0010->gpio_reset_value);
-		gpio_free(wm0010->gpio_reset);
 	}
 
 	if (wm0010->irq)

commit d3fd716e82ed643d804c49ca9ca554079c429a5c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Aug 25 09:23:40 2012 -0700

    ASoC: wm0010: Set idle_bias_off
    
    Doesn't make any practical difference given that _SUSPEND and _OFF are
    equivalent for the driver but it's what we're really doing.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index b6f7097d7953..61ec7633fe5a 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -726,6 +726,7 @@ static struct snd_soc_codec_driver soc_codec_dev_wm0010 = {
 	.probe = wm0010_probe,
 	.set_bias_level = wm0010_set_bias_level,
 	.set_sysclk = wm0010_set_sysclk,
+	.idle_bias_off = true,
 
 	.dapm_widgets = wm0010_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(wm0010_dapm_widgets),

commit 1470bfacb675ab0e25c30c97772a764ca16e0e52
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Aug 25 09:17:42 2012 -0700

    ASoC: wm0010: Add dummy widget for CLKIN
    
    Make it easier to integrate the management of the clock supplying the
    WM0010 with DAPM by providing a dummy supply widget which supplies the
    interface widgets, this can be connected to clock outputs by the machines.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index f820b5725163..b6f7097d7953 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -118,9 +118,18 @@ struct wm0010_spi_msg {
 	size_t len;
 };
 
+static const struct snd_soc_dapm_widget wm0010_dapm_widgets[] = {
+SND_SOC_DAPM_SUPPLY("CLKIN",  SND_SOC_NOPM, 0, 0, NULL, 0),
+};
+
 static const struct snd_soc_dapm_route wm0010_dapm_routes[] = {
 	{ "SDI2 Capture", NULL, "SDI1 Playback" },
 	{ "SDI1 Capture", NULL, "SDI2 Playback" },
+
+	{ "SDI1 Capture", NULL, "CLKIN" },
+	{ "SDI2 Capture", NULL, "CLKIN" },
+	{ "SDI1 Playback", NULL, "CLKIN" },
+	{ "SDI2 Playback", NULL, "CLKIN" },
 };
 
 static const char *wm0010_state_to_str(enum wm0010_state state)
@@ -718,6 +727,8 @@ static struct snd_soc_codec_driver soc_codec_dev_wm0010 = {
 	.set_bias_level = wm0010_set_bias_level,
 	.set_sysclk = wm0010_set_sysclk,
 
+	.dapm_widgets = wm0010_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(wm0010_dapm_widgets),
 	.dapm_routes = wm0010_dapm_routes,
 	.num_dapm_routes = ARRAY_SIZE(wm0010_dapm_routes),
 };

commit 6df3198635e2ad961952566a05994bc592abe774
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Aug 25 14:05:35 2012 +0100

    ASoC: wm0010: Enable 44.1kHz support
    
    With appropriate clocking configuration the WM0010 driver supports 44.1kHz
    audio; enable that.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index e1315e0e7856..f820b5725163 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -722,7 +722,7 @@ static struct snd_soc_codec_driver soc_codec_dev_wm0010 = {
 	.num_dapm_routes = ARRAY_SIZE(wm0010_dapm_routes),
 };
 
-#define WM0010_RATES (SNDRV_PCM_RATE_48000)
+#define WM0010_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
 #define WM0010_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |\
 			SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |\
 			SNDRV_PCM_FMTBIT_S32_LE)

commit 1549c34bfdf3dc29b769c803f6cfdc53dfc67f93
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Aug 23 17:50:52 2012 +0100

    ASoC: wm0010: Fix passthrough routing
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
index 8e0b6d6bffaf..e1315e0e7856 100644
--- a/sound/soc/codecs/wm0010.c
+++ b/sound/soc/codecs/wm0010.c
@@ -119,7 +119,8 @@ struct wm0010_spi_msg {
 };
 
 static const struct snd_soc_dapm_route wm0010_dapm_routes[] = {
-	{ "SDI2 Playback", NULL, "SDI1 Playback" },
+	{ "SDI2 Capture", NULL, "SDI1 Playback" },
+	{ "SDI1 Capture", NULL, "SDI2 Playback" },
 };
 
 static const char *wm0010_state_to_str(enum wm0010_state state)

commit e3523e01869da20fdd12ffd19ae1df7bf492650e
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Aug 23 15:59:56 2012 +0100

    ASoC: wm0010: Add initial wm0010 DSP driver
    
    The WM0010 is a compact digital signal processor that has been
    highly optimised for low-power audio applications.  Extensive memory
    resources and core optimisation allow the device to manage all audio
    processing algorithms efficiently and autonomously, while the host
    processor sleeps or performs other tasks.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/wm0010.c b/sound/soc/codecs/wm0010.c
new file mode 100644
index 000000000000..8e0b6d6bffaf
--- /dev/null
+++ b/sound/soc/codecs/wm0010.c
@@ -0,0 +1,930 @@
+/*
+ * wm0010.c  --  WM0010 DSP Driver
+ *
+ * Copyright 2012 Wolfson Microelectronics PLC.
+ *
+ * Authors: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *          Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
+ *          Scott Ling <sl@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/irqreturn.h>
+#include <linux/init.h>
+#include <linux/spi/spi.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+
+#include <sound/soc.h>
+#include <sound/wm0010.h>
+
+#define DEVICE_ID_WM0010	10
+
+enum dfw_cmd {
+	DFW_CMD_FUSE = 0x01,
+	DFW_CMD_CODE_HDR,
+	DFW_CMD_CODE_DATA,
+	DFW_CMD_PLL,
+	DFW_CMD_INFO = 0xff
+};
+
+struct dfw_binrec {
+	u8 command;
+	u32 length:24;
+	u32 address;
+	uint8_t data[0];
+} __packed;
+
+struct dfw_pllrec {
+	u8 command;
+	u32 length:24;
+	u32 address;
+	u32 clkctrl1;
+	u32 clkctrl2;
+	u32 clkctrl3;
+	u32 ldetctrl;
+	u32 uart_div;
+	u32 spi_div;
+} __packed;
+
+static struct pll_clock_map {
+	int max_sysclk;
+	int max_pll_spi_speed;
+	u32 pll_clkctrl1;
+} pll_clock_map[] = {			   /* Dividers */
+	{ 22000000, 26000000, 0x00201f11 }, /* 2,32,2  */
+	{ 18000000, 26000000, 0x00203f21 }, /* 2,64,4  */
+	{ 14000000, 26000000, 0x00202620 }, /* 1,39,4  */
+	{ 10000000, 22000000, 0x00203120 }, /* 1,50,4  */
+	{  6500000, 22000000, 0x00204520 }, /* 1,70,4  */
+	{  5500000, 22000000, 0x00103f10 }, /* 1,64,2  */
+};
+
+enum wm0010_state {
+	WM0010_POWER_OFF,
+	WM0010_OUT_OF_RESET,
+	WM0010_BOOTROM,
+	WM0010_STAGE2,
+	WM0010_FIRMWARE,
+};
+
+struct wm0010_priv {
+	struct snd_soc_codec *codec;
+
+	struct mutex lock;
+	struct device *dev;
+
+	struct wm0010_pdata pdata;
+
+	int gpio_reset;
+	int gpio_reset_value;
+
+	struct regulator_bulk_data core_supplies[2];
+	struct regulator *dbvdd;
+
+	int sysclk;
+
+	enum wm0010_state state;
+	bool boot_failed;
+	int boot_done;
+	bool ready;
+	bool pll_running;
+	int max_spi_freq;
+	int board_max_spi_speed;
+	u32 pll_clkctrl1;
+
+	spinlock_t irq_lock;
+	int irq;
+
+	struct completion boot_completion;
+};
+
+struct wm0010_spi_msg {
+	struct spi_message m;
+	struct spi_transfer t;
+	u8 *tx_buf;
+	u8 *rx_buf;
+	size_t len;
+};
+
+static const struct snd_soc_dapm_route wm0010_dapm_routes[] = {
+	{ "SDI2 Playback", NULL, "SDI1 Playback" },
+};
+
+static const char *wm0010_state_to_str(enum wm0010_state state)
+{
+	const char *state_to_str[] = {
+		"Power off",
+		"Out of reset",
+		"Bootrom",
+		"Stage2",
+		"Firmware"
+	};
+
+	if (state < 0 || state >= ARRAY_SIZE(state_to_str))
+		return "null";
+	return state_to_str[state];
+}
+
+/* Called with wm0010->lock held */
+static void wm0010_halt(struct snd_soc_codec *codec)
+{
+	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	unsigned long flags;
+	enum wm0010_state state;
+
+	/* Fetch the wm0010 state */
+	spin_lock_irqsave(&wm0010->irq_lock, flags);
+	state = wm0010->state;
+	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
+
+	switch (state) {
+	case WM0010_POWER_OFF:
+		/* If there's nothing to do, bail out */
+		return;
+	case WM0010_OUT_OF_RESET:
+	case WM0010_BOOTROM:
+	case WM0010_STAGE2:
+	case WM0010_FIRMWARE:
+		/* Remember to put chip back into reset */
+		gpio_set_value(wm0010->gpio_reset, wm0010->gpio_reset_value);
+		/* Disable the regulators */
+		regulator_disable(wm0010->dbvdd);
+		regulator_bulk_disable(ARRAY_SIZE(wm0010->core_supplies),
+				       wm0010->core_supplies);
+		break;
+	}
+
+	spin_lock_irqsave(&wm0010->irq_lock, flags);
+	wm0010->state = WM0010_POWER_OFF;
+	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
+}
+
+struct wm0010_boot_xfer {
+	struct list_head list;
+	struct snd_soc_codec *codec;
+	struct completion *done;
+	struct spi_message m;
+	struct spi_transfer t;
+};
+
+/* Called with wm0010->lock held */
+static void wm0010_mark_boot_failure(struct wm0010_priv *wm0010)
+{
+	enum wm0010_state state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wm0010->irq_lock, flags);
+	state = wm0010->state;
+	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
+
+	dev_err(wm0010->dev, "Failed to transition from `%s' state to `%s' state\n",
+		wm0010_state_to_str(state), wm0010_state_to_str(state + 1));
+
+	wm0010->boot_failed = true;
+}
+
+static void wm0010_boot_xfer_complete(void *data)
+{
+	struct wm0010_boot_xfer *xfer = data;
+	struct snd_soc_codec *codec = xfer->codec;
+	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	u32 *out32 = xfer->t.rx_buf;
+	int i;
+
+	if (xfer->m.status != 0) {
+		dev_err(codec->dev, "SPI transfer failed: %d\n",
+			xfer->m.status);
+		wm0010_mark_boot_failure(wm0010);
+		if (xfer->done)
+			complete(xfer->done);
+		return;
+	}
+
+	for (i = 0; i < xfer->t.len / 4; i++) {
+		dev_dbg(codec->dev, "%d: %04x\n", i, out32[i]);
+
+		switch (be32_to_cpu(out32[i])) {
+		case 0xe0e0e0e0:
+			dev_err(codec->dev,
+				"%d: ROM error reported in stage 2\n", i);
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		case 0x55555555:
+			if (wm0010->boot_done == 0)
+				break;
+			dev_err(codec->dev,
+				"%d: ROM bootloader running in stage 2\n", i);
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		case 0x0fed0000:
+			dev_dbg(codec->dev, "Stage2 loader running\n");
+			break;
+
+		case 0x0fed0007:
+			dev_dbg(codec->dev, "CODE_HDR packet received\n");
+			break;
+
+		case 0x0fed0008:
+			dev_dbg(codec->dev, "CODE_DATA packet received\n");
+			break;
+
+		case 0x0fed0009:
+			dev_dbg(codec->dev, "Download complete\n");
+			break;
+
+		case 0x0fed000c:
+			dev_dbg(codec->dev, "Application start\n");
+			break;
+
+		case 0x0fed000e:
+			dev_dbg(codec->dev, "PLL packet received\n");
+			wm0010->pll_running = true;
+			break;
+
+		case 0x0fed0025:
+			dev_err(codec->dev, "Device reports image too long\n");
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		case 0x0fed002c:
+			dev_err(codec->dev, "Device reports bad SPI packet\n");
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		case 0x0fed0031:
+			dev_err(codec->dev, "Device reports SPI read overflow\n");
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		case 0x0fed0032:
+			dev_err(codec->dev, "Device reports SPI underclock\n");
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		case 0x0fed0033:
+			dev_err(codec->dev, "Device reports bad header packet\n");
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		case 0x0fed0034:
+			dev_err(codec->dev, "Device reports invalid packet type\n");
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		case 0x0fed0035:
+			dev_err(codec->dev, "Device reports data before header error\n");
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		case 0x0fed0038:
+			dev_err(codec->dev, "Device reports invalid PLL packet\n");
+			break;
+
+		case 0x0fed003a:
+			dev_err(codec->dev, "Device reports packet alignment error\n");
+			wm0010_mark_boot_failure(wm0010);
+			break;
+
+		default:
+			dev_err(codec->dev, "Unrecognised return 0x%x\n",
+			    be32_to_cpu(out32[i]));
+			wm0010_mark_boot_failure(wm0010);
+			break;
+		}
+
+		if (wm0010->boot_failed)
+			break;
+	}
+
+	wm0010->boot_done++;
+	if (xfer->done)
+		complete(xfer->done);
+}
+
+static void byte_swap_64(u64 *data_in, u64 *data_out, u32 len)
+{
+	int i;
+
+	for (i = 0; i < len / 8; i++)
+		data_out[i] = cpu_to_be64(le64_to_cpu(data_in[i]));
+}
+
+static int wm0010_boot(struct snd_soc_codec *codec)
+{
+	struct spi_device *spi = to_spi_device(codec->dev);
+	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	unsigned long flags;
+	struct list_head xfer_list;
+	struct wm0010_boot_xfer *xfer;
+	int ret;
+	struct completion done;
+	const struct firmware *fw;
+	const struct dfw_binrec *rec;
+	struct spi_message m;
+	struct spi_transfer t;
+	struct dfw_pllrec pll_rec;
+	u32 *img, *p;
+	u64 *img_swap;
+	u8 *out;
+	u32 len, offset;
+	int i;
+
+	spin_lock_irqsave(&wm0010->irq_lock, flags);
+	if (wm0010->state != WM0010_POWER_OFF)
+		dev_warn(wm0010->dev, "DSP already powered up!\n");
+	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
+
+	if (wm0010->sysclk > 26000000) {
+		dev_err(codec->dev, "Max DSP clock frequency is 26MHz\n");
+		ret = -ECANCELED;
+		goto err;
+	}
+
+	INIT_LIST_HEAD(&xfer_list);
+
+	mutex_lock(&wm0010->lock);
+	wm0010->pll_running = false;
+
+	dev_dbg(codec->dev, "max_spi_freq: %d\n", wm0010->max_spi_freq);
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(wm0010->core_supplies),
+				    wm0010->core_supplies);
+	if (ret != 0) {
+		dev_err(&spi->dev, "Failed to enable core supplies: %d\n",
+			ret);
+		mutex_unlock(&wm0010->lock);
+		goto err;
+	}
+
+	ret = regulator_enable(wm0010->dbvdd);
+	if (ret != 0) {
+		dev_err(&spi->dev, "Failed to enable DBVDD: %d\n", ret);
+		goto err_core;
+	}
+
+	/* Release reset */
+	gpio_set_value(wm0010->gpio_reset, !wm0010->gpio_reset_value);
+	spin_lock_irqsave(&wm0010->irq_lock, flags);
+	wm0010->state = WM0010_OUT_OF_RESET;
+	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
+
+	/* First the bootloader */
+	ret = request_firmware(&fw, "wm0010_stage2.bin", codec->dev);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to request stage2 loader: %d\n",
+			ret);
+		goto abort;
+	}
+
+	if (!wait_for_completion_timeout(&wm0010->boot_completion,
+					 msecs_to_jiffies(10)))
+		dev_err(codec->dev, "Failed to get interrupt from DSP\n");
+
+	spin_lock_irqsave(&wm0010->irq_lock, flags);
+	wm0010->state = WM0010_BOOTROM;
+	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
+
+	dev_dbg(codec->dev, "Downloading %d byte stage 2 loader\n", fw->size);
+
+	/* Copy to local buffer first as vmalloc causes problems for dma */
+	img = kzalloc(fw->size, GFP_KERNEL);
+	if (!img) {
+		dev_err(codec->dev, "Failed to allocate image buffer\n");
+		goto abort;
+	}
+
+	out = kzalloc(fw->size, GFP_KERNEL);
+	if (!out) {
+		dev_err(codec->dev, "Failed to allocate output buffer\n");
+		goto abort;
+	}
+
+	memcpy(img, &fw->data[0], fw->size);
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+	t.rx_buf = out;
+	t.tx_buf = img;
+	t.len = fw->size;
+	t.bits_per_word = 8;
+	t.speed_hz = wm0010->sysclk / 10;
+	spi_message_add_tail(&t, &m);
+
+	dev_dbg(codec->dev, "Starting initial download at %dHz\n",
+		t.speed_hz);
+
+	ret = spi_sync(spi, &m);
+	if (ret != 0) {
+		dev_err(codec->dev, "Initial download failed: %d\n", ret);
+		goto abort;
+	}
+
+	/* Look for errors from the boot ROM */
+	for (i = 0; i < fw->size; i++) {
+		if (out[i] != 0x55) {
+			ret = -EBUSY;
+			dev_err(codec->dev, "Boot ROM error: %x in %d\n",
+				out[i], i);
+			wm0010_mark_boot_failure(wm0010);
+			goto abort;
+		}
+	}
+
+	release_firmware(fw);
+	kfree(img);
+	kfree(out);
+
+	if (!wait_for_completion_timeout(&wm0010->boot_completion,
+					 msecs_to_jiffies(10)))
+		dev_err(codec->dev, "Failed to get interrupt from DSP loader.\n");
+
+	spin_lock_irqsave(&wm0010->irq_lock, flags);
+	wm0010->state = WM0010_STAGE2;
+	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
+
+	/* Only initialise PLL if max_spi_freq initialised */
+	if (wm0010->max_spi_freq) {
+
+		/* Initialise a PLL record */
+		memset(&pll_rec, 0, sizeof(pll_rec));
+		pll_rec.command = DFW_CMD_PLL;
+		pll_rec.length = (sizeof(pll_rec) - 8);
+
+		/* On wm0010 only the CLKCTRL1 value is used */
+		pll_rec.clkctrl1 = wm0010->pll_clkctrl1;
+
+		len = pll_rec.length + 8;
+		out = kzalloc(len, GFP_KERNEL);
+		if (!out) {
+			dev_err(codec->dev,
+				"Failed to allocate RX buffer\n");
+			goto abort;
+		}
+
+		img_swap = kzalloc(len, GFP_KERNEL);
+		if (!img_swap) {
+			dev_err(codec->dev,
+				"Failed to allocate image buffer\n");
+			goto abort;
+		}
+
+		/* We need to re-order for 0010 */
+		byte_swap_64((u64 *)&pll_rec, img_swap, len);
+
+		spi_message_init(&m);
+		memset(&t, 0, sizeof(t));
+		t.rx_buf = out;
+		t.tx_buf = img_swap;
+		t.len = len;
+		t.bits_per_word = 8;
+		t.speed_hz = wm0010->sysclk / 6;
+		spi_message_add_tail(&t, &m);
+
+		ret = spi_sync(spi, &m);
+		if (ret != 0) {
+			dev_err(codec->dev, "First PLL write failed: %d\n", ret);
+			goto abort;
+		}
+
+		/* Use a second send of the message to get the return status */
+		ret = spi_sync(spi, &m);
+		if (ret != 0) {
+			dev_err(codec->dev, "Second PLL write failed: %d\n", ret);
+			goto abort;
+		}
+
+		p = (u32 *)out;
+
+		/* Look for PLL active code from the DSP */
+		for (i = 0; i < len / 4; i++) {
+			if (*p == 0x0e00ed0f) {
+				dev_dbg(codec->dev, "PLL packet received\n");
+				wm0010->pll_running = true;
+				break;
+			}
+			p++;
+		}
+
+		kfree(img_swap);
+		kfree(out);
+	} else
+		dev_dbg(codec->dev, "Not enabling DSP PLL.");
+
+	ret = request_firmware(&fw, "wm0010.dfw", codec->dev);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to request application: %d\n",
+			ret);
+		goto abort;
+	}
+
+	rec = (const struct dfw_binrec *)fw->data;
+	offset = 0;
+	wm0010->boot_done = 0;
+	wm0010->boot_failed = false;
+	BUG_ON(!list_empty(&xfer_list));
+	init_completion(&done);
+
+	/* First record should be INFO */
+	if (rec->command != DFW_CMD_INFO) {
+		dev_err(codec->dev, "First record not INFO\r\n");
+		goto abort;
+	}
+
+	/* Check it's a 0010 file */
+	if (rec->data[0] != DEVICE_ID_WM0010) {
+		dev_err(codec->dev, "Not a WM0010 firmware file.\r\n");
+		goto abort;
+	}
+
+	/* Skip the info record as we don't need to send it */
+	offset += ((rec->length) + 8);
+	rec = (void *)&rec->data[rec->length];
+
+	while (offset < fw->size) {
+		dev_dbg(codec->dev,
+			"Packet: command %d, data length = 0x%x\r\n",
+			rec->command, rec->length);
+		len = rec->length + 8;
+
+		out = kzalloc(len, GFP_KERNEL);
+		if (!out) {
+			dev_err(codec->dev,
+				"Failed to allocate RX buffer\n");
+			goto abort;
+		}
+
+		img_swap = kzalloc(len, GFP_KERNEL);
+		if (!img_swap) {
+			dev_err(codec->dev,
+				"Failed to allocate image buffer\n");
+			goto abort;
+		}
+
+		/* We need to re-order for 0010 */
+		byte_swap_64((u64 *)&rec->command, img_swap, len);
+
+		xfer = kzalloc(sizeof(*xfer), GFP_KERNEL);
+		if (!xfer) {
+			dev_err(codec->dev, "Failed to allocate xfer\n");
+			goto abort;
+		}
+
+		xfer->codec = codec;
+		list_add_tail(&xfer->list, &xfer_list);
+
+		spi_message_init(&xfer->m);
+		xfer->m.complete = wm0010_boot_xfer_complete;
+		xfer->m.context = xfer;
+		xfer->t.tx_buf = img_swap;
+		xfer->t.rx_buf = out;
+		xfer->t.len = len;
+		xfer->t.bits_per_word = 8;
+
+		if (!wm0010->pll_running) {
+			xfer->t.speed_hz = wm0010->sysclk / 6;
+		} else {
+			xfer->t.speed_hz = wm0010->max_spi_freq;
+
+			if (wm0010->board_max_spi_speed &&
+			   (wm0010->board_max_spi_speed < wm0010->max_spi_freq))
+					xfer->t.speed_hz = wm0010->board_max_spi_speed;
+		}
+
+		/* Store max usable spi frequency for later use */
+		wm0010->max_spi_freq = xfer->t.speed_hz;
+
+		spi_message_add_tail(&xfer->t, &xfer->m);
+
+		offset += ((rec->length) + 8);
+		rec = (void *)&rec->data[rec->length];
+
+		if (offset >= fw->size) {
+			dev_dbg(codec->dev, "All transfers scheduled\n");
+			xfer->done = &done;
+		}
+
+		ret = spi_async(spi, &xfer->m);
+		if (ret != 0) {
+			dev_err(codec->dev, "Write failed: %d\n", ret);
+			goto abort;
+		}
+
+		if (wm0010->boot_failed)
+			goto abort;
+	}
+
+	wait_for_completion(&done);
+
+	spin_lock_irqsave(&wm0010->irq_lock, flags);
+	wm0010->state = WM0010_FIRMWARE;
+	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
+
+	mutex_unlock(&wm0010->lock);
+
+	release_firmware(fw);
+
+	while (!list_empty(&xfer_list)) {
+		xfer = list_first_entry(&xfer_list, struct wm0010_boot_xfer,
+					list);
+		kfree(xfer->t.rx_buf);
+		kfree(xfer->t.tx_buf);
+		list_del(&xfer->list);
+		kfree(xfer);
+	}
+
+	return 0;
+
+abort:
+	/* Put the chip back into reset */
+	wm0010_halt(codec);
+	mutex_unlock(&wm0010->lock);
+	return ret;
+err_core:
+	regulator_bulk_disable(ARRAY_SIZE(wm0010->core_supplies),
+			       wm0010->core_supplies);
+err:
+	return ret;
+}
+
+static int wm0010_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_PREPARE)
+			wm0010_boot(codec);
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_PREPARE) {
+			mutex_lock(&wm0010->lock);
+			wm0010_halt(codec);
+			mutex_unlock(&wm0010->lock);
+		}
+		break;
+	case SND_SOC_BIAS_OFF:
+		break;
+	}
+
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+static int wm0010_set_sysclk(struct snd_soc_codec *codec, int source,
+			     int clk_id, unsigned int freq, int dir)
+{
+	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	unsigned int i;
+
+	wm0010->sysclk = freq;
+
+	if (freq < pll_clock_map[ARRAY_SIZE(pll_clock_map)-1].max_sysclk) {
+		wm0010->max_spi_freq = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(pll_clock_map); i++)
+			if (freq >= pll_clock_map[i].max_sysclk)
+				break;
+
+		wm0010->max_spi_freq = pll_clock_map[i].max_pll_spi_speed;
+		wm0010->pll_clkctrl1 = pll_clock_map[i].pll_clkctrl1;
+	}
+
+	return 0;
+}
+
+static int wm0010_probe(struct snd_soc_codec *codec);
+
+static struct snd_soc_codec_driver soc_codec_dev_wm0010 = {
+	.probe = wm0010_probe,
+	.set_bias_level = wm0010_set_bias_level,
+	.set_sysclk = wm0010_set_sysclk,
+
+	.dapm_routes = wm0010_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(wm0010_dapm_routes),
+};
+
+#define WM0010_RATES (SNDRV_PCM_RATE_48000)
+#define WM0010_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |\
+			SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |\
+			SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_driver wm0010_dai[] = {
+	{
+		.name = "wm0010-sdi1",
+		.playback = {
+			.stream_name = "SDI1 Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = WM0010_RATES,
+			.formats = WM0010_FORMATS,
+		},
+		.capture = {
+			 .stream_name = "SDI1 Capture",
+			 .channels_min = 1,
+			 .channels_max = 2,
+			 .rates = WM0010_RATES,
+			 .formats = WM0010_FORMATS,
+		 },
+	},
+	{
+		.name = "wm0010-sdi2",
+		.playback = {
+			.stream_name = "SDI2 Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = WM0010_RATES,
+			.formats = WM0010_FORMATS,
+		},
+		.capture = {
+			 .stream_name = "SDI2 Capture",
+			 .channels_min = 1,
+			 .channels_max = 2,
+			 .rates = WM0010_RATES,
+			 .formats = WM0010_FORMATS,
+		 },
+	},
+};
+
+static irqreturn_t wm0010_irq(int irq, void *data)
+{
+	struct wm0010_priv *wm0010 = data;
+
+	switch (wm0010->state) {
+	case WM0010_POWER_OFF:
+	case WM0010_OUT_OF_RESET:
+	case WM0010_BOOTROM:
+	case WM0010_STAGE2:
+		spin_lock(&wm0010->irq_lock);
+		complete(&wm0010->boot_completion);
+		spin_unlock(&wm0010->irq_lock);
+		return IRQ_HANDLED;
+	default:
+		return IRQ_NONE;
+	}
+
+	return IRQ_NONE;
+}
+
+static int wm0010_probe(struct snd_soc_codec *codec)
+{
+	struct wm0010_priv *wm0010 = snd_soc_codec_get_drvdata(codec);
+	struct spi_device *spi = to_spi_device(wm0010->dev);
+	unsigned long flags;
+	unsigned long gpio_flags;
+	int ret;
+	int trigger;
+	int irq;
+
+	wm0010->codec = codec;
+
+	init_completion(&wm0010->boot_completion);
+
+	wm0010->core_supplies[0].supply = "AVDD";
+	wm0010->core_supplies[1].supply = "DCVDD";
+	ret = devm_regulator_bulk_get(wm0010->dev, ARRAY_SIZE(wm0010->core_supplies),
+				      wm0010->core_supplies);
+	if (ret != 0) {
+		dev_err(wm0010->dev, "Failed to obtain core supplies: %d\n",
+			ret);
+		return ret;
+	}
+
+	wm0010->dbvdd = devm_regulator_get(wm0010->dev, "DBVDD");
+	if (IS_ERR(wm0010->dbvdd)) {
+		ret = PTR_ERR(wm0010->dbvdd);
+		dev_err(wm0010->dev, "Failed to obtain DBVDD: %d\n", ret);
+		return ret;
+	}
+
+	if (wm0010->pdata.gpio_reset) {
+		wm0010->gpio_reset = wm0010->pdata.gpio_reset;
+
+		if (wm0010->pdata.reset_active_high)
+			wm0010->gpio_reset_value = 1;
+		else
+			wm0010->gpio_reset_value = 0;
+
+		if (wm0010->gpio_reset_value)
+			gpio_flags = GPIOF_OUT_INIT_HIGH;
+		else
+			gpio_flags = GPIOF_OUT_INIT_LOW;
+
+		ret = devm_gpio_request_one(wm0010->dev, wm0010->gpio_reset,
+					    gpio_flags, "wm0010 reset");
+		if (ret < 0) {
+			dev_err(wm0010->dev,
+				"Failed to request GPIO for DSP reset: %d\n",
+				ret);
+			return ret;
+		}
+	} else {
+		dev_err(wm0010->dev, "No reset GPIO configured\n");
+		return ret;
+	}
+
+	irq = spi->irq;
+	if (wm0010->pdata.irq_flags)
+		trigger = wm0010->pdata.irq_flags;
+	else
+		trigger = IRQF_TRIGGER_FALLING;
+	trigger |= IRQF_ONESHOT;
+
+	ret = request_threaded_irq(irq, NULL, wm0010_irq, trigger,
+				   "wm0010", wm0010);
+	if (ret)
+		dev_err(wm0010->dev, "Failed to request IRQ %d: %d\n",
+			irq, ret);
+	wm0010->irq = irq;
+
+	if (spi->max_speed_hz)
+		wm0010->board_max_spi_speed = spi->max_speed_hz;
+	else
+		wm0010->board_max_spi_speed = 0;
+
+	spin_lock_irqsave(&wm0010->irq_lock, flags);
+	wm0010->state = WM0010_POWER_OFF;
+	spin_unlock_irqrestore(&wm0010->irq_lock, flags);
+
+	return 0;
+}
+
+static int __devinit wm0010_spi_probe(struct spi_device *spi)
+{
+	struct wm0010_priv *wm0010;
+	int ret;
+
+	wm0010 = devm_kzalloc(&spi->dev, sizeof(*wm0010),
+			      GFP_KERNEL);
+	if (!wm0010)
+		return -ENOMEM;
+
+	mutex_init(&wm0010->lock);
+	spin_lock_init(&wm0010->irq_lock);
+
+	spi_set_drvdata(spi, wm0010);
+	wm0010->dev = &spi->dev;
+
+	if (dev_get_platdata(&spi->dev))
+		memcpy(&wm0010->pdata, dev_get_platdata(&spi->dev),
+		       sizeof(wm0010->pdata));
+
+	ret = snd_soc_register_codec(&spi->dev,
+				     &soc_codec_dev_wm0010, wm0010_dai,
+				     ARRAY_SIZE(wm0010_dai));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int __devexit wm0010_spi_remove(struct spi_device *spi)
+{
+	struct wm0010_priv *wm0010 = spi_get_drvdata(spi);
+
+	snd_soc_unregister_codec(&spi->dev);
+
+	if (wm0010->gpio_reset) {
+		/* Remember to put chip back into reset */
+		gpio_set_value(wm0010->gpio_reset, wm0010->gpio_reset_value);
+		gpio_free(wm0010->gpio_reset);
+	}
+
+	if (wm0010->irq)
+		free_irq(wm0010->irq, wm0010);
+
+	return 0;
+}
+
+static struct spi_driver wm0010_spi_driver = {
+	.driver = {
+		.name	= "wm0010",
+		.bus 	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm0010_spi_probe,
+	.remove		= __devexit_p(wm0010_spi_remove),
+};
+
+module_spi_driver(wm0010_spi_driver);
+
+MODULE_DESCRIPTION("ASoC WM0010 driver");
+MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfsonmicro.com>");
+MODULE_LICENSE("GPL");
