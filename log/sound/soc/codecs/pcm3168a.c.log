commit 4ec48e7cbe6e70352c802b5cb172b00ebd8af8e0
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Nov 20 15:17:53 2019 +0200

    ASoC: pcm3168a: Update the RST gpio handling to align with documentation
    
    The RST (reset-gpios) is low active so the driver must handle it
    accordingly.
    
    Add comments to explain clearly how the line is used.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20191120131753.6831-3-peter.ujfalusi@ti.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index f3475134b519..9711fab296eb 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -707,11 +707,15 @@ int pcm3168a_probe(struct device *dev, struct regmap *regmap)
 	dev_set_drvdata(dev, pcm3168a);
 
 	/*
-	 * Request the RST gpio line as non exclusive as the same reset line
-	 * might be connected to multiple pcm3168a codec
+	 * Request the reset (connected to RST pin) gpio line as non exclusive
+	 * as the same reset line might be connected to multiple pcm3168a codec
+	 *
+	 * The RST is low active, we want the GPIO line to be high initially, so
+	 * request the initial level to LOW which in practice means DEASSERTED:
+	 * The deasserted level of GPIO_ACTIVE_LOW is HIGH.
 	 */
-	pcm3168a->gpio_rst = devm_gpiod_get_optional(dev, "rst",
-						GPIOD_OUT_HIGH |
+	pcm3168a->gpio_rst = devm_gpiod_get_optional(dev, "reset",
+						GPIOD_OUT_LOW |
 						GPIOD_FLAGS_BIT_NONEXCLUSIVE);
 	if (IS_ERR(pcm3168a->gpio_rst)) {
 		ret = PTR_ERR(pcm3168a->gpio_rst);
@@ -814,7 +818,13 @@ void pcm3168a_remove(struct device *dev)
 {
 	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
 
-	gpiod_set_value_cansleep(pcm3168a->gpio_rst, 0);
+	/*
+	 * The RST is low active, we want the GPIO line to be low when the
+	 * driver is removed, so set level to 1 which in practice means
+	 * ASSERTED:
+	 * The asserted level of GPIO_ACTIVE_LOW is LOW.
+	 */
+	gpiod_set_value_cansleep(pcm3168a->gpio_rst, 1);
 	pm_runtime_disable(dev);
 #ifndef CONFIG_PM
 	pcm3168a_disable(dev);

commit 79f6c108c87b470aacf25fc25a86f48694d03ae8
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Nov 13 14:47:34 2019 +0200

    ASoC: pcm3168a: Add support for optional RST gpio handling
    
    In case the RST line is connected to a GPIO line it needs to be pulled high
    when the driver probes to be able to use the codec.
    
    Add support also for cases when more than one codec is is controlled by the
    same GPIO line by requesting the gpio with GPIOD_FLAGS_BIT_NONEXCLUSIVE.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    
    Link: https://lore.kernel.org/r/20191113124734.27984-3-peter.ujfalusi@ti.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 313500ab36df..f3475134b519 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -9,7 +9,9 @@
 
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/gpio/consumer.h>
 #include <linux/module.h>
+#include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 
@@ -59,6 +61,7 @@ struct pcm3168a_priv {
 	struct regulator_bulk_data supplies[PCM3168A_NUM_SUPPLIES];
 	struct regmap *regmap;
 	struct clk *scki;
+	struct gpio_desc *gpio_rst;
 	unsigned long sysclk;
 
 	struct pcm3168a_io_params io_params[2];
@@ -643,6 +646,7 @@ static bool pcm3168a_readable_register(struct device *dev, unsigned int reg)
 static bool pcm3168a_volatile_register(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
+	case PCM3168A_RST_SMODE:
 	case PCM3168A_DAC_ZERO:
 	case PCM3168A_ADC_OV:
 		return true;
@@ -702,6 +706,21 @@ int pcm3168a_probe(struct device *dev, struct regmap *regmap)
 
 	dev_set_drvdata(dev, pcm3168a);
 
+	/*
+	 * Request the RST gpio line as non exclusive as the same reset line
+	 * might be connected to multiple pcm3168a codec
+	 */
+	pcm3168a->gpio_rst = devm_gpiod_get_optional(dev, "rst",
+						GPIOD_OUT_HIGH |
+						GPIOD_FLAGS_BIT_NONEXCLUSIVE);
+	if (IS_ERR(pcm3168a->gpio_rst)) {
+		ret = PTR_ERR(pcm3168a->gpio_rst);
+		if (ret != -EPROBE_DEFER )
+			dev_err(dev, "failed to acquire RST gpio: %d\n", ret);
+
+		return ret;
+	}
+
 	pcm3168a->scki = devm_clk_get(dev, "scki");
 	if (IS_ERR(pcm3168a->scki)) {
 		ret = PTR_ERR(pcm3168a->scki);
@@ -743,10 +762,18 @@ int pcm3168a_probe(struct device *dev, struct regmap *regmap)
 		goto err_regulator;
 	}
 
-	ret = pcm3168a_reset(pcm3168a);
-	if (ret) {
-		dev_err(dev, "Failed to reset device: %d\n", ret);
-		goto err_regulator;
+	if (pcm3168a->gpio_rst) {
+		/*
+		 * The device is taken out from reset via GPIO line, wait for
+		 * 3846 SCKI clock cycles for the internal reset de-assertion
+		 */
+		msleep(DIV_ROUND_UP(3846 * 1000, pcm3168a->sysclk));
+	} else {
+		ret = pcm3168a_reset(pcm3168a);
+		if (ret) {
+			dev_err(dev, "Failed to reset device: %d\n", ret);
+			goto err_regulator;
+		}
 	}
 
 	pm_runtime_set_active(dev);
@@ -785,6 +812,9 @@ static void pcm3168a_disable(struct device *dev)
 
 void pcm3168a_remove(struct device *dev)
 {
+	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
+
+	gpiod_set_value_cansleep(pcm3168a->gpio_rst, 0);
 	pm_runtime_disable(dev);
 #ifndef CONFIG_PM
 	pcm3168a_disable(dev);

commit a35716a95655d8fc15042c9d574374eceb9daf3d
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Oct 15 12:00:37 2019 +0300

    ASoC: pcm3168a: Fix serial mode dependent format support
    
    fmt 0 is perfectly valid (PCM3168A_FMT_I2S). Remove the return in case
    fmt == 0.
    
    Fixes: ("ASoC: pcm3168a: Use fixup instead of constraint for channels and formats")
    Reported-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20191015090037.23271-1-peter.ujfalusi@ti.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 708dac27feff..313500ab36df 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -322,9 +322,6 @@ static void pcm3168a_update_fixup_pcm_stream(struct snd_soc_dai *dai)
 	u64 formats = SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE;
 	unsigned int channel_max = dai->id == PCM3168A_DAI_DAC ? 8 : 6;
 
-	if (!pcm3168a->io_params[dai->id].fmt)
-		return;
-
 	if (pcm3168a->io_params[dai->id].fmt == PCM3168A_FMT_RIGHT_J) {
 		/* S16_LE is only supported in RIGHT_J mode */
 		formats |= SNDRV_PCM_FMTBIT_S16_LE;

commit cfc28ac124c456ffbff5b34d4108d8a201cd7fbb
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Oct 8 14:57:20 2019 +0300

    ASoC: pcm3168a: Use fixup instead of constraint for channels and formats
    
    The snd_pcm_hw_constraint_minmax() works fine when a single codec is
    connected to a single CPU DAI, but in multicodec or DPCM setup the
    constraints placed by the driver will apply to the whole PCM stream (FE
    included) and thus prevents more than 8 playback channels for example.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20191008115720.7135-1-peter.ujfalusi@ti.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 88b75695fbf7..708dac27feff 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -62,6 +62,7 @@ struct pcm3168a_priv {
 	unsigned long sysclk;
 
 	struct pcm3168a_io_params io_params[2];
+	struct snd_soc_dai_driver dai_drv[2];
 };
 
 static const char *const pcm3168a_roll_off[] = { "Sharp", "Slow" };
@@ -314,6 +315,37 @@ static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai,
 	return 0;
 }
 
+static void pcm3168a_update_fixup_pcm_stream(struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
+	u64 formats = SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE;
+	unsigned int channel_max = dai->id == PCM3168A_DAI_DAC ? 8 : 6;
+
+	if (!pcm3168a->io_params[dai->id].fmt)
+		return;
+
+	if (pcm3168a->io_params[dai->id].fmt == PCM3168A_FMT_RIGHT_J) {
+		/* S16_LE is only supported in RIGHT_J mode */
+		formats |= SNDRV_PCM_FMTBIT_S16_LE;
+
+		/*
+		 * If multi DIN/DOUT is not selected, RIGHT_J can only support
+		 * two channels (no TDM support)
+		 */
+		if (pcm3168a->io_params[dai->id].tdm_slots != 2)
+			channel_max = 2;
+	}
+
+	if (dai->id == PCM3168A_DAI_DAC) {
+		dai->driver->playback.channels_max = channel_max;
+		dai->driver->playback.formats = formats;
+	} else {
+		dai->driver->capture.channels_max = channel_max;
+		dai->driver->capture.formats = formats;
+	}
+}
+
 static int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai, unsigned int format)
 {
 	struct snd_soc_component *component = dai->component;
@@ -376,6 +408,8 @@ static int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai, unsigned int format)
 
 	regmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);
 
+	pcm3168a_update_fixup_pcm_stream(dai);
+
 	return 0;
 }
 
@@ -409,6 +443,8 @@ static int pcm3168a_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 	else
 		io_params->tdm_mask = rx_mask;
 
+	pcm3168a_update_fixup_pcm_stream(dai);
+
 	return 0;
 }
 
@@ -530,63 +566,7 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static int pcm3168a_startup(struct snd_pcm_substream *substream,
-			    struct snd_soc_dai *dai)
-{
-	struct snd_soc_component *component = dai->component;
-	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
-	unsigned int sample_min;
-	unsigned int channel_max;
-	unsigned int channel_maxs[] = {
-		8, /* DAC */
-		6  /* ADC */
-	};
-
-	/*
-	 * Available Data Bits
-	 *
-	 * RIGHT_J : 24 / 16
-	 * LEFT_J  : 24
-	 * I2S     : 24
-	 *
-	 * TDM available
-	 *
-	 * I2S
-	 * LEFT_J
-	 */
-	switch (pcm3168a->io_params[dai->id].fmt) {
-	case PCM3168A_FMT_RIGHT_J:
-		sample_min  = 16;
-		channel_max =  2;
-		break;
-	case PCM3168A_FMT_LEFT_J:
-	case PCM3168A_FMT_I2S:
-	case PCM3168A_FMT_DSP_A:
-	case PCM3168A_FMT_DSP_B:
-		sample_min  = 24;
-		channel_max = channel_maxs[dai->id];
-		break;
-	default:
-		sample_min  = 24;
-		channel_max =  2;
-	}
-
-	snd_pcm_hw_constraint_minmax(substream->runtime,
-				     SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
-				     sample_min, 32);
-
-	/* Allow all channels in multi DIN/DOUT mode */
-	if (pcm3168a->io_params[dai->id].tdm_slots == 2)
-		channel_max = channel_maxs[dai->id];
-
-	snd_pcm_hw_constraint_minmax(substream->runtime,
-				     SNDRV_PCM_HW_PARAM_CHANNELS,
-				     2, channel_max);
-
-	return 0;
-}
 static const struct snd_soc_dai_ops pcm3168a_dai_ops = {
-	.startup	= pcm3168a_startup,
 	.set_fmt	= pcm3168a_set_dai_fmt,
 	.set_sysclk	= pcm3168a_set_dai_sysclk,
 	.hw_params	= pcm3168a_hw_params,
@@ -776,8 +756,10 @@ int pcm3168a_probe(struct device *dev, struct regmap *regmap)
 	pm_runtime_enable(dev);
 	pm_runtime_idle(dev);
 
-	ret = devm_snd_soc_register_component(dev, &pcm3168a_driver, pcm3168a_dais,
-			ARRAY_SIZE(pcm3168a_dais));
+	memcpy(pcm3168a->dai_drv, pcm3168a_dais, sizeof(pcm3168a->dai_drv));
+	ret = devm_snd_soc_register_component(dev, &pcm3168a_driver,
+					      pcm3168a->dai_drv,
+					      ARRAY_SIZE(pcm3168a->dai_drv));
 	if (ret) {
 		dev_err(dev, "failed to register component: %d\n", ret);
 		goto err_regulator;

commit 7b2db65b59c30d58c129d3c8b2101feca686155a
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Sep 19 10:16:52 2019 +0300

    ASoC: pcm3168a: The codec does not support S32_LE
    
    24 bits is supported in all modes and 16 bit only when the codec is slave
    and the DAI is set to RIGHT_J.
    
    Remove the unsupported sample format.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20190919071652.31724-1-peter.ujfalusi@ti.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 50ed86d45c26..88b75695fbf7 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -21,8 +21,7 @@
 
 #define PCM3168A_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
 			 SNDRV_PCM_FMTBIT_S24_3LE | \
-			 SNDRV_PCM_FMTBIT_S24_LE | \
-			 SNDRV_PCM_FMTBIT_S32_LE)
+			 SNDRV_PCM_FMTBIT_S24_LE)
 
 #define PCM3168A_FMT_I2S		0x0
 #define PCM3168A_FMT_LEFT_J		0x1

commit 6fa4e0cae684d268d309d1b1f929d52e3df5649c
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Mon Aug 12 12:52:26 2019 +0300

    ASoC: pcm3168a: Allow reconfiguration of tdm_slots and slot_width
    
    When using right_j format and the codec is slave it can support 16bit
    format, but only if slot_width == 16, in the same DAI mode the 24 bit
    audio can work with 24 or 32 slot_width.
    
    Because of this, the codec and CPU needs to be reconfigured when the sample
    format changes.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20190812095226.18870-3-peter.ujfalusi@ti.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 75fa8e9ee894..50ed86d45c26 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -402,18 +402,6 @@ static int pcm3168a_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 		return -EINVAL;
 	}
 
-	if (io_params->tdm_slots && io_params->tdm_slots != slots) {
-		dev_err(component->dev, "Not matching slots %d vs %d\n",
-			io_params->tdm_slots, slots);
-		return -EINVAL;
-	}
-
-	if (io_params->slot_width && io_params->slot_width != slot_width) {
-		dev_err(component->dev, "Not matching slot_width %d vs %d\n",
-			io_params->slot_width, slot_width);
-		return -EINVAL;
-	}
-
 	io_params->tdm_slots = slots;
 	io_params->slot_width = slot_width;
 	/* Ignore the not relevant mask for the DAI/direction */

commit abe51c351827e0086dad079dfe02918fecdf4830
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Mon Aug 12 12:52:25 2019 +0300

    ASoC: pcm3168a: Retain the independence of DAC and ADC side of the codec
    
    The DAC and ADC path of the codec is independent, have dedicated LRCK (FS)
    and BCK for DAC/ADC.
    
    They can be configured to use different format, TDM slots and slot_width if
    needed.
    
    Move these parameters under dedicated io_params structure and manage them
    independently based on the dai.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20190812095226.18870-2-peter.ujfalusi@ti.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index e84a1509fe65..75fa8e9ee894 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -44,18 +44,25 @@ static const char *const pcm3168a_supply_names[PCM3168A_NUM_SUPPLIES] = {
 	"VCCDA2"
 };
 
+#define PCM3168A_DAI_DAC		0
+#define PCM3168A_DAI_ADC		1
+
+/* ADC/DAC side parameters */
+struct pcm3168a_io_params {
+	bool master_mode;
+	unsigned int fmt;
+	int tdm_slots;
+	u32 tdm_mask;
+	int slot_width;
+};
+
 struct pcm3168a_priv {
 	struct regulator_bulk_data supplies[PCM3168A_NUM_SUPPLIES];
 	struct regmap *regmap;
 	struct clk *scki;
-	bool adc_master_mode;
-	bool dac_master_mode;
 	unsigned long sysclk;
-	unsigned int adc_fmt;
-	unsigned int dac_fmt;
-	int tdm_slots;
-	u32 tdm_mask[2];
-	int slot_width;
+
+	struct pcm3168a_io_params io_params[2];
 };
 
 static const char *const pcm3168a_roll_off[] = { "Sharp", "Slow" };
@@ -308,8 +315,7 @@ static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai,
 	return 0;
 }
 
-static int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai,
-			       unsigned int format, bool dac)
+static int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai, unsigned int format)
 {
 	struct snd_soc_component *component = dai->component;
 	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
@@ -356,43 +362,31 @@ static int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai,
 		return -EINVAL;
 	}
 
-	if (dac) {
+	if (dai->id == PCM3168A_DAI_DAC) {
 		reg = PCM3168A_DAC_PWR_MST_FMT;
 		mask = PCM3168A_DAC_FMT_MASK;
 		shift = PCM3168A_DAC_FMT_SHIFT;
-		pcm3168a->dac_master_mode = master_mode;
-		pcm3168a->dac_fmt = fmt;
 	} else {
 		reg = PCM3168A_ADC_MST_FMT;
 		mask = PCM3168A_ADC_FMTAD_MASK;
 		shift = PCM3168A_ADC_FMTAD_SHIFT;
-		pcm3168a->adc_master_mode = master_mode;
-		pcm3168a->adc_fmt = fmt;
 	}
 
+	pcm3168a->io_params[dai->id].master_mode = master_mode;
+	pcm3168a->io_params[dai->id].fmt = fmt;
+
 	regmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);
 
 	return 0;
 }
 
-static int pcm3168a_set_dai_fmt_dac(struct snd_soc_dai *dai,
-			       unsigned int format)
-{
-	return pcm3168a_set_dai_fmt(dai, format, true);
-}
-
-static int pcm3168a_set_dai_fmt_adc(struct snd_soc_dai *dai,
-			       unsigned int format)
-{
-	return pcm3168a_set_dai_fmt(dai, format, false);
-}
-
 static int pcm3168a_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 				 unsigned int rx_mask, int slots,
 				 int slot_width)
 {
 	struct snd_soc_component *component = dai->component;
 	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
+	struct pcm3168a_io_params *io_params = &pcm3168a->io_params[dai->id];
 
 	if (tx_mask >= (1<<slots) || rx_mask >= (1<<slots)) {
 		dev_err(component->dev,
@@ -408,22 +402,25 @@ static int pcm3168a_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 		return -EINVAL;
 	}
 
-	if (pcm3168a->tdm_slots && pcm3168a->tdm_slots != slots) {
+	if (io_params->tdm_slots && io_params->tdm_slots != slots) {
 		dev_err(component->dev, "Not matching slots %d vs %d\n",
-			pcm3168a->tdm_slots, slots);
+			io_params->tdm_slots, slots);
 		return -EINVAL;
 	}
 
-	if (pcm3168a->slot_width && pcm3168a->slot_width != slot_width) {
+	if (io_params->slot_width && io_params->slot_width != slot_width) {
 		dev_err(component->dev, "Not matching slot_width %d vs %d\n",
-			pcm3168a->slot_width, slot_width);
+			io_params->slot_width, slot_width);
 		return -EINVAL;
 	}
 
-	pcm3168a->tdm_slots = slots;
-	pcm3168a->slot_width = slot_width;
-	pcm3168a->tdm_mask[SNDRV_PCM_STREAM_PLAYBACK] = tx_mask;
-	pcm3168a->tdm_mask[SNDRV_PCM_STREAM_CAPTURE] = rx_mask;
+	io_params->tdm_slots = slots;
+	io_params->slot_width = slot_width;
+	/* Ignore the not relevant mask for the DAI/direction */
+	if (dai->id == PCM3168A_DAI_DAC)
+		io_params->tdm_mask = tx_mask;
+	else
+		io_params->tdm_mask = rx_mask;
 
 	return 0;
 }
@@ -434,7 +431,8 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 {
 	struct snd_soc_component *component = dai->component;
 	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
-	bool tx, master_mode;
+	struct pcm3168a_io_params *io_params = &pcm3168a->io_params[dai->id];
+	bool master_mode;
 	u32 val, mask, shift, reg;
 	unsigned int rate, fmt, ratio, max_ratio;
 	unsigned int tdm_slots;
@@ -444,23 +442,21 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 
 	ratio = pcm3168a->sysclk / rate;
 
-	tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
-	if (tx) {
+	if (dai->id == PCM3168A_DAI_DAC) {
 		max_ratio = PCM3168A_NUM_SCKI_RATIOS_DAC;
 		reg = PCM3168A_DAC_PWR_MST_FMT;
 		mask = PCM3168A_DAC_MSDA_MASK;
 		shift = PCM3168A_DAC_MSDA_SHIFT;
-		master_mode = pcm3168a->dac_master_mode;
-		fmt = pcm3168a->dac_fmt;
 	} else {
 		max_ratio = PCM3168A_NUM_SCKI_RATIOS_ADC;
 		reg = PCM3168A_ADC_MST_FMT;
 		mask = PCM3168A_ADC_MSAD_MASK;
 		shift = PCM3168A_ADC_MSAD_SHIFT;
-		master_mode = pcm3168a->adc_master_mode;
-		fmt = pcm3168a->adc_fmt;
 	}
 
+	master_mode = io_params->master_mode;
+	fmt = io_params->fmt;
+
 	for (i = 0; i < max_ratio; i++) {
 		if (pcm3168a_scki_ratios[i] == ratio)
 			break;
@@ -471,8 +467,8 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	if (pcm3168a->slot_width)
-		slot_width = pcm3168a->slot_width;
+	if (io_params->slot_width)
+		slot_width = io_params->slot_width;
 	else
 		slot_width = params_width(params);
 
@@ -497,8 +493,8 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	if (pcm3168a->tdm_slots)
-		tdm_slots = pcm3168a->tdm_slots;
+	if (io_params->tdm_slots)
+		tdm_slots = io_params->tdm_slots;
 	else
 		tdm_slots = params_channels(params);
 
@@ -534,7 +530,7 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 
 	regmap_update_bits(pcm3168a->regmap, reg, mask, val);
 
-	if (tx) {
+	if (dai->id == PCM3168A_DAI_DAC) {
 		mask = PCM3168A_DAC_FMT_MASK;
 		shift = PCM3168A_DAC_FMT_SHIFT;
 	} else {
@@ -552,20 +548,13 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 {
 	struct snd_soc_component *component = dai->component;
 	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
-	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
-	unsigned int fmt;
 	unsigned int sample_min;
 	unsigned int channel_max;
 	unsigned int channel_maxs[] = {
-		6, /* rx */
-		8  /* tx */
+		8, /* DAC */
+		6  /* ADC */
 	};
 
-	if (tx)
-		fmt = pcm3168a->dac_fmt;
-	else
-		fmt = pcm3168a->adc_fmt;
-
 	/*
 	 * Available Data Bits
 	 *
@@ -578,7 +567,7 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 	 * I2S
 	 * LEFT_J
 	 */
-	switch (fmt) {
+	switch (pcm3168a->io_params[dai->id].fmt) {
 	case PCM3168A_FMT_RIGHT_J:
 		sample_min  = 16;
 		channel_max =  2;
@@ -588,7 +577,7 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 	case PCM3168A_FMT_DSP_A:
 	case PCM3168A_FMT_DSP_B:
 		sample_min  = 24;
-		channel_max = channel_maxs[tx];
+		channel_max = channel_maxs[dai->id];
 		break;
 	default:
 		sample_min  = 24;
@@ -600,8 +589,8 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 				     sample_min, 32);
 
 	/* Allow all channels in multi DIN/DOUT mode */
-	if (pcm3168a->tdm_slots == 2)
-		channel_max = channel_maxs[tx];
+	if (pcm3168a->io_params[dai->id].tdm_slots == 2)
+		channel_max = channel_maxs[dai->id];
 
 	snd_pcm_hw_constraint_minmax(substream->runtime,
 				     SNDRV_PCM_HW_PARAM_CHANNELS,
@@ -609,26 +598,19 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 
 	return 0;
 }
-static const struct snd_soc_dai_ops pcm3168a_dac_dai_ops = {
+static const struct snd_soc_dai_ops pcm3168a_dai_ops = {
 	.startup	= pcm3168a_startup,
-	.set_fmt	= pcm3168a_set_dai_fmt_dac,
+	.set_fmt	= pcm3168a_set_dai_fmt,
 	.set_sysclk	= pcm3168a_set_dai_sysclk,
 	.hw_params	= pcm3168a_hw_params,
 	.digital_mute	= pcm3168a_digital_mute,
 	.set_tdm_slot	= pcm3168a_set_tdm_slot,
 };
 
-static const struct snd_soc_dai_ops pcm3168a_adc_dai_ops = {
-	.startup	= pcm3168a_startup,
-	.set_fmt	= pcm3168a_set_dai_fmt_adc,
-	.set_sysclk	= pcm3168a_set_dai_sysclk,
-	.hw_params	= pcm3168a_hw_params,
-	.set_tdm_slot	= pcm3168a_set_tdm_slot,
-};
-
 static struct snd_soc_dai_driver pcm3168a_dais[] = {
 	{
 		.name = "pcm3168a-dac",
+		.id = PCM3168A_DAI_DAC,
 		.playback = {
 			.stream_name = "Playback",
 			.channels_min = 1,
@@ -636,10 +618,11 @@ static struct snd_soc_dai_driver pcm3168a_dais[] = {
 			.rates = SNDRV_PCM_RATE_8000_192000,
 			.formats = PCM3168A_FORMATS
 		},
-		.ops = &pcm3168a_dac_dai_ops
+		.ops = &pcm3168a_dai_ops
 	},
 	{
 		.name = "pcm3168a-adc",
+		.id = PCM3168A_DAI_ADC,
 		.capture = {
 			.stream_name = "Capture",
 			.channels_min = 1,
@@ -647,7 +630,7 @@ static struct snd_soc_dai_driver pcm3168a_dais[] = {
 			.rates = SNDRV_PCM_RATE_8000_96000,
 			.formats = PCM3168A_FORMATS
 		},
-		.ops = &pcm3168a_adc_dai_ops
+		.ops = &pcm3168a_dai_ops
 	},
 };
 

commit f2c8b57014038ae064a0f918f939af510f0aed02
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Jul 25 11:33:21 2019 +0300

    ASoC: pcm3168a: Allow all channels in case of parallel DIN/DOUT setup
    
    If multi DIN/DOUT mode is selected (tdm_slots == 2) then configure the
    channel constraint to allow all channels.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Link: https://lore.kernel.org/r/20190725083321.6776-1-peter.ujfalusi@ti.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 5d59ce254821..e84a1509fe65 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -599,6 +599,10 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 				     SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
 				     sample_min, 32);
 
+	/* Allow all channels in multi DIN/DOUT mode */
+	if (pcm3168a->tdm_slots == 2)
+		channel_max = channel_maxs[tx];
+
 	snd_pcm_hw_constraint_minmax(substream->runtime,
 				     SNDRV_PCM_HW_PARAM_CHANNELS,
 				     2, channel_max);

commit f8f85216f8d309daadb37aba8a4b0826783d8747
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Mon Jul 22 23:15:28 2019 +0200

    ASoC: pcm3168a: Fix a typo in the name of a constant
    
    There is a typo in PCM1368A_MAX_SYSCLK, it should be PCM3168A_MAX_SYSCLK
    (1 and 3 switched in 3168)
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Link: https://lore.kernel.org/r/20190722211528.26600-1-christophe.jaillet@wanadoo.fr
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index f1104d7d6426..5d59ce254821 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -263,7 +263,7 @@ static unsigned int pcm3168a_scki_ratios[] = {
 #define PCM3168A_NUM_SCKI_RATIOS_DAC	ARRAY_SIZE(pcm3168a_scki_ratios)
 #define PCM3168A_NUM_SCKI_RATIOS_ADC	(ARRAY_SIZE(pcm3168a_scki_ratios) - 2)
 
-#define PCM1368A_MAX_SYSCLK		36864000
+#define PCM3168A_MAX_SYSCLK		36864000
 
 static int pcm3168a_reset(struct pcm3168a_priv *pcm3168a)
 {
@@ -296,7 +296,7 @@ static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai,
 	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(dai->component);
 	int ret;
 
-	if (freq > PCM1368A_MAX_SYSCLK)
+	if (freq > PCM3168A_MAX_SYSCLK)
 		return -EINVAL;
 
 	ret = clk_set_rate(pcm3168a->scki, freq);

commit 53c8b29abe42e5601cfa0ea5962532f0cfdec8a0
Merge: e3303268f9cf 4b972a01a7da
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Jun 26 12:39:34 2019 +0100

    Merge tag 'v5.2-rc6' into asoc-5.3
    
    Linux 5.2-rc6

commit 9700022109b6c495fb571f77324d34b294b29145
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Jun 20 12:26:56 2019 +0300

    ASoC: pcm3168a: Add support for multi DIN/DOUT with TDM slots parameter
    
    The driver was wired to be only usable in DIN1/DOUT1 mode, switching
    between TDM and non TDM modes based on the number of channels.
    
    While keeping this functionality for compatibility add support for using
    all DIN1/2/3/4 and DOUT1/2/3 if it is needed by setting the TDM slots to
    2.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index e1658947090b..d4e372182c55 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -411,9 +411,11 @@ static int pcm3168a_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 		return -EINVAL;
 	}
 
-	pcm3168a->tdm_slots = slots;
-	pcm3168a->tdm_mask[SNDRV_PCM_STREAM_PLAYBACK] = tx_mask;
-	pcm3168a->tdm_mask[SNDRV_PCM_STREAM_CAPTURE] = rx_mask;
+	if (pcm3168a->tdm_slots && pcm3168a->tdm_slots != slots) {
+		dev_err(component->dev, "Not matching slots %d vs %d\n",
+			pcm3168a->tdm_slots, slots);
+		return -EINVAL;
+	}
 
 	if (pcm3168a->slot_width && pcm3168a->slot_width != slot_width) {
 		dev_err(component->dev, "Not matching slot_width %d vs %d\n",
@@ -421,7 +423,11 @@ static int pcm3168a_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
 		return -EINVAL;
 	}
 
+	pcm3168a->tdm_slots = slots;
 	pcm3168a->slot_width = slot_width;
+	pcm3168a->tdm_mask[SNDRV_PCM_STREAM_PLAYBACK] = tx_mask;
+	pcm3168a->tdm_mask[SNDRV_PCM_STREAM_CAPTURE] = rx_mask;
+
 	return 0;
 }
 
@@ -434,11 +440,10 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	bool tx, master_mode;
 	u32 val, mask, shift, reg;
 	unsigned int rate, fmt, ratio, max_ratio;
-	unsigned int chan;
+	unsigned int tdm_slots;
 	int i, slot_width;
 
 	rate = params_rate(params);
-	chan = params_channels(params);
 
 	ratio = pcm3168a->sysclk / rate;
 
@@ -495,8 +500,20 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	/* for TDM */
-	if (chan > 2) {
+	if (pcm3168a->tdm_slots)
+		tdm_slots = pcm3168a->tdm_slots;
+	else
+		tdm_slots = params_channels(params);
+
+	/*
+	 * Switch the codec to TDM mode when more than 2 TDM slots are needed
+	 * for the stream.
+	 * If pcm3168a->tdm_slots is not set or set to more than 2 (8/6 usually)
+	 * then DIN1/DOUT1 is used in TDM mode.
+	 * If pcm3168a->tdm_slots is set to 2 then DIN1/2/3/4 and DOUT1/2/3 is
+	 * used in normal mode, no need to switch to TDM modes.
+	 */
+	if (tdm_slots > 2) {
 		switch (fmt) {
 		case PCM3168A_FMT_I2S:
 		case PCM3168A_FMT_DSP_A:

commit b5d8dffb8cc9792c3bb4310e142932c8bc5c0387
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Jun 20 12:26:55 2019 +0300

    ASoC: pcm3168a: Rename min_frame_size to slot_width
    
    It represents slot size and not frame.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 9eb24ca09793..e1658947090b 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -435,7 +435,7 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	u32 val, mask, shift, reg;
 	unsigned int rate, fmt, ratio, max_ratio;
 	unsigned int chan;
-	int i, min_frame_size;
+	int i, slot_width;
 
 	rate = params_rate(params);
 	chan = params_channels(params);
@@ -470,11 +470,11 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	if (pcm3168a->slot_width)
-		min_frame_size = pcm3168a->slot_width;
+		slot_width = pcm3168a->slot_width;
 	else
-		min_frame_size = params_width(params);
+		slot_width = params_width(params);
 
-	switch (min_frame_size) {
+	switch (slot_width) {
 	case 16:
 		if (master_mode || (fmt != PCM3168A_FMT_RIGHT_J)) {
 			dev_err(component->dev, "16-bit slots are supported only for slave mode using right justified\n");
@@ -491,7 +491,7 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	case 32:
 		break;
 	default:
-		dev_err(component->dev, "unsupported frame size: %d\n", min_frame_size);
+		dev_err(component->dev, "unsupported frame size: %d\n", slot_width);
 		return -EINVAL;
 	}
 

commit 75a6faf617d107bdbc74d36ccf89f2280b96ac26
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:37 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 422
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 101 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190113.822954939@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index e0d5839fe1a7..ca568b9bf0f2 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * PCM3168A codec driver
  *
  * Copyright (C) 2015 Imagination Technologies Ltd.
  *
  * Author: Damien Horsley <Damien.Horsley@imgtec.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
  */
 
 #include <linux/clk.h>

commit 9b8e8b893ff52264df2b54a6820ae3c4bb820624
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Jun 4 14:12:49 2019 +0300

    ASoC: pcm3168a: Implement set_tdm_slot callback
    
    Initially we only going to care about the slot_width as for example
    DSP_A/B needs 32 bclk per slots and to be able to use TDM mode the codec
    (and CPU) needs to use DSP_A/B modes.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index e0d5839fe1a7..9eb24ca09793 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -56,6 +56,9 @@ struct pcm3168a_priv {
 	unsigned long sysclk;
 	unsigned int adc_fmt;
 	unsigned int dac_fmt;
+	int tdm_slots;
+	u32 tdm_mask[2];
+	int slot_width;
 };
 
 static const char *const pcm3168a_roll_off[] = { "Sharp", "Slow" };
@@ -387,6 +390,41 @@ static int pcm3168a_set_dai_fmt_adc(struct snd_soc_dai *dai,
 	return pcm3168a_set_dai_fmt(dai, format, false);
 }
 
+static int pcm3168a_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
+				 unsigned int rx_mask, int slots,
+				 int slot_width)
+{
+	struct snd_soc_component *component = dai->component;
+	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
+
+	if (tx_mask >= (1<<slots) || rx_mask >= (1<<slots)) {
+		dev_err(component->dev,
+			"Bad tdm mask tx: 0x%08x rx: 0x%08x slots %d\n",
+			tx_mask, rx_mask, slots);
+		return -EINVAL;
+	}
+
+	if (slot_width &&
+	    (slot_width != 16 && slot_width != 24 && slot_width != 32 )) {
+		dev_err(component->dev, "Unsupported slot_width %d\n",
+			slot_width);
+		return -EINVAL;
+	}
+
+	pcm3168a->tdm_slots = slots;
+	pcm3168a->tdm_mask[SNDRV_PCM_STREAM_PLAYBACK] = tx_mask;
+	pcm3168a->tdm_mask[SNDRV_PCM_STREAM_CAPTURE] = rx_mask;
+
+	if (pcm3168a->slot_width && pcm3168a->slot_width != slot_width) {
+		dev_err(component->dev, "Not matching slot_width %d vs %d\n",
+			pcm3168a->slot_width, slot_width);
+		return -EINVAL;
+	}
+
+	pcm3168a->slot_width = slot_width;
+	return 0;
+}
+
 static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 			     struct snd_pcm_hw_params *params,
 			     struct snd_soc_dai *dai)
@@ -431,22 +469,26 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	min_frame_size = params_width(params) * 2;
+	if (pcm3168a->slot_width)
+		min_frame_size = pcm3168a->slot_width;
+	else
+		min_frame_size = params_width(params);
+
 	switch (min_frame_size) {
-	case 32:
+	case 16:
 		if (master_mode || (fmt != PCM3168A_FMT_RIGHT_J)) {
-			dev_err(component->dev, "32-bit frames are supported only for slave mode using right justified\n");
+			dev_err(component->dev, "16-bit slots are supported only for slave mode using right justified\n");
 			return -EINVAL;
 		}
 		fmt = PCM3168A_FMT_RIGHT_J_16;
 		break;
-	case 48:
+	case 24:
 		if (master_mode || (fmt & PCM3168A_FMT_DSP_MASK)) {
-			dev_err(component->dev, "48-bit frames not supported in master mode, or slave mode using DSP\n");
+			dev_err(component->dev, "24-bit slots not supported in master mode, or slave mode using DSP\n");
 			return -EINVAL;
 		}
 		break;
-	case 64:
+	case 32:
 		break;
 	default:
 		dev_err(component->dev, "unsupported frame size: %d\n", min_frame_size);
@@ -554,14 +596,16 @@ static const struct snd_soc_dai_ops pcm3168a_dac_dai_ops = {
 	.set_fmt	= pcm3168a_set_dai_fmt_dac,
 	.set_sysclk	= pcm3168a_set_dai_sysclk,
 	.hw_params	= pcm3168a_hw_params,
-	.digital_mute	= pcm3168a_digital_mute
+	.digital_mute	= pcm3168a_digital_mute,
+	.set_tdm_slot	= pcm3168a_set_tdm_slot,
 };
 
 static const struct snd_soc_dai_ops pcm3168a_adc_dai_ops = {
 	.startup	= pcm3168a_startup,
 	.set_fmt	= pcm3168a_set_dai_fmt_adc,
 	.set_sysclk	= pcm3168a_set_dai_sysclk,
-	.hw_params	= pcm3168a_hw_params
+	.hw_params	= pcm3168a_hw_params,
+	.set_tdm_slot	= pcm3168a_set_tdm_slot,
 };
 
 static struct snd_soc_dai_driver pcm3168a_dais[] = {

commit 5011454ee34a84700e9a8c7eb1138efceea9d662
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Apr 17 14:31:40 2019 +0300

    ASoC: pcm3168a: Enable TDM support for DSP_A/B modes
    
    The 24-bit TDM mode also applies to DSP_A and DSP_B modes.
    Most dais on the SoC side can not interpret I2S/Left_j with other than 2
    channels of audio.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 08d3fe192e65..e0d5839fe1a7 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -457,13 +457,16 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	if (chan > 2) {
 		switch (fmt) {
 		case PCM3168A_FMT_I2S:
+		case PCM3168A_FMT_DSP_A:
 			fmt = PCM3168A_FMT_I2S_TDM;
 			break;
 		case PCM3168A_FMT_LEFT_J:
+		case PCM3168A_FMT_DSP_B:
 			fmt = PCM3168A_FMT_LEFT_J_TDM;
 			break;
 		default:
-			dev_err(component->dev, "TDM is supported under I2S/Left_J only\n");
+			dev_err(component->dev,
+				"TDM is supported under DSP/I2S/Left_J only\n");
 			return -EINVAL;
 		}
 	}
@@ -526,6 +529,8 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 		break;
 	case PCM3168A_FMT_LEFT_J:
 	case PCM3168A_FMT_I2S:
+	case PCM3168A_FMT_DSP_A:
+	case PCM3168A_FMT_DSP_B:
 		sample_min  = 24;
 		channel_max = channel_maxs[tx];
 		break;

commit 8fe8915b6c0b5298fa547be21957b3860c39c46e
Merge: 1b46ed96961d a01b8d1d2445
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Dec 13 14:36:46 2018 +0000

    Merge branch 'for-4.20' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-4.21 intel dep

commit 489db5d941500249583ec6b49fa70e006bd8f632
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Wed Nov 28 21:26:12 2018 +0900

    ASoC: pcm3168a: Don't disable pcm3168a when CONFIG_PM defined
    
    pcm3168 codec support runtime_[resume|suspend], whenever it
    is not active, it enters suspend mode, and it's clock and regulators
    will be disabled. so there is no need to disable them again in
    remove callback.  Otherwise we got following kernel warnings,
    when unload pcm3168a driver
    
    [  222.257514] unbalanced disables for amp-en-regulator
    [  222.262526] ------------[ cut here ]------------
    [  222.267158] WARNING: CPU: 0 PID: 2423 at drivers/regulator/core.c:2264 _regulator_disable+0x28/0x108
    [  222.276291] Modules linked in:
    [  222.279343]  snd_soc_pcm3168a_i2c(-)
    [  222.282916]  snd_aloop
    [  222.285272]  arc4
    [  222.287194]  wl18xx
    [  222.289289]  wlcore
    [  222.291385]  mac80211
    [  222.293654]  cfg80211
    [  222.295923]  aes_ce_blk
    [  222.298366]  crypto_simd
    [  222.300896]  cryptd
    [  222.302992]  aes_ce_cipher
    [  222.305696]  crc32_ce
    [  222.307965]  ghash_ce
    [  222.310234]  aes_arm64
    [  222.312590]  gf128mul
    [  222.314860]  snd_soc_rcar
    [  222.317476]  sha2_ce
    [  222.319658]  xhci_plat_hcd
    [  222.322362]  sha256_arm64
    [  222.324978]  xhci_hcd
    [  222.327247]  sha1_ce
    [  222.329430]  renesas_usbhs
    [  222.332133]  evdev
    [  222.334142]  sha1_generic
    [  222.336758]  rcar_gen3_thermal
    [  222.339810]  cpufreq_dt
    [  222.342253]  ravb_streaming(C)
    [  222.345304]  wlcore_sdio
    [  222.347834]  thermal_sys
    [  222.350363]  udc_core
    [  222.352632]  mch_core(C)
    [  222.355161]  usb_dmac
    [  222.357430]  snd_soc_pcm3168a
    [  222.360394]  snd_soc_ak4613
    [  222.363184]  gpio_keys
    [  222.365540]  virt_dma
    [  222.367809]  nfsd
    [  222.369730]  ipv6
    [  222.371652]  autofs4
    [  222.373834]  [last unloaded: snd_soc_pcm3168a_i2c]
    [  222.378629] CPU: 0 PID: 2423 Comm: rmmod Tainted: G        WC      4.14.63-04798-gd456126e4a42-dirty #457
    [  222.388196] Hardware name: Renesas H3ULCB Kingfisher board based on r8a7795 ES2.0+ (DT)
    [  222.396199] task: ffff8006fa8c6200 task.stack: ffff00000a0a0000
    [  222.402117] PC is at _regulator_disable+0x28/0x108
    [  222.406906] LR is at _regulator_disable+0x28/0x108
    [  222.411695] pc : [<ffff0000083bd89c>] lr : [<ffff0000083bd89c>] pstate: 00000145
    [  222.419089] sp : ffff00000a0a3c80
    [  222.422401] x29: ffff00000a0a3c80
    [  222.425799] x28: ffff8006fa8c6200
    [  222.429199] x27: ffff0000086f1000
    [  222.432597] x26: 000000000000006a
    [  222.435997] x25: 0000000000000124
    [  222.439395] x24: 0000000000000018
    [  222.442795] x23: 0000000000000006
    [  222.446193] x22: ffff8006f925d490
    [  222.449592] x21: ffff8006f9ac2068
    [  222.452991] x20: ffff8006f9ac2000
    [  222.456390] x19: 0000000000000005
    [  222.459787] x18: 000000000000000a
    [  222.463186] x17: 0000000000000000
    [  222.466584] x16: 0000000000000000
    [  222.469984] x15: 000000000d3f616a
    [  222.473382] x14: 0720072007200720
    [  222.476781] x13: 0720072007200720
    [  222.480179] x12: 0720072007200720
    [  222.483578] x11: 0720072007200720
    [  222.486975] x10: 0720072007200720
    [  222.490375] x9 : 0720072007200720
    [  222.493773] x8 : 07200772076f0774
    [  222.497172] x7 : 0000000000000000
    [  222.500570] x6 : 0000000000000007
    [  222.503969] x5 : 0000000000000000
    [  222.507367] x4 : 0000000000000000
    [  222.510766] x3 : 0000000000000000
    [  222.514164] x2 : c790b852091e2600
    [  222.517563] x1 : 0000000000000000
    [  222.520961] x0 : 0000000000000028
    [  222.524361] Call trace:
    [  222.526805] Exception stack(0xffff00000a0a3b40 to 0xffff00000a0a3c80)
    [  222.533245] 3b40: 0000000000000028 0000000000000000 c790b852091e2600 0000000000000000
    [  222.541075] 3b60: 0000000000000000 0000000000000000 0000000000000007 0000000000000000
    [  222.548905] 3b80: 07200772076f0774 0720072007200720 0720072007200720 0720072007200720
    [  222.556735] 3ba0: 0720072007200720 0720072007200720 0720072007200720 000000000d3f616a
    [  222.564564] 3bc0: 0000000000000000 0000000000000000 000000000000000a 0000000000000005
    [  222.572394] 3be0: ffff8006f9ac2000 ffff8006f9ac2068 ffff8006f925d490 0000000000000006
    [  222.580224] 3c00: 0000000000000018 0000000000000124 000000000000006a ffff0000086f1000
    [  222.588053] 3c20: ffff8006fa8c6200 ffff00000a0a3c80 ffff0000083bd89c ffff00000a0a3c80
    [  222.595883] 3c40: ffff0000083bd89c 0000000000000145 0000000000000000 0000000000000000
    [  222.603713] 3c60: 0000ffffffffffff ffff00000a0a3c30 ffff00000a0a3c80 ffff0000083bd89c
    [  222.611543] [<ffff0000083bd89c>] _regulator_disable+0x28/0x108
    [  222.617375] [<ffff0000083bd9c4>] regulator_disable+0x48/0x68
    [  222.623033] [<ffff0000083be8e4>] regulator_bulk_disable+0x58/0xc0
    [  222.629134] [<ffff0000007d831c>] pcm3168a_remove+0x30/0x50 [snd_soc_pcm3168a]
    [  222.636270] [<ffff0000007e5010>] pcm3168a_i2c_remove+0x10/0x1c [snd_soc_pcm3168a_i2c]
    [  222.644106] [<ffff0000084b9d9c>] i2c_device_remove+0x38/0x70
    [  222.649766] [<ffff00000843cd5c>] device_release_driver_internal+0xd0/0x1c0
    [  222.656640] [<ffff00000843ced8>] driver_detach+0x70/0x7c
    [  222.661951] [<ffff00000843bf68>] bus_remove_driver+0x74/0xa0
    [  222.667609] [<ffff00000843d7e4>] driver_unregister+0x48/0x4c
    [  222.673268] [<ffff0000084ba8dc>] i2c_del_driver+0x24/0x30
    [  222.678666] [<ffff0000007e5078>] pcm3168a_i2c_driver_exit+0x10/0xf98 [snd_soc_pcm3168a_i2c]
    [  222.687019] [<ffff00000811bd28>] SyS_delete_module+0x198/0x1d4
    [  222.692850] Exception stack(0xffff00000a0a3ec0 to 0xffff00000a0a4000)
    [  222.699289] 3ec0: 0000aaaafeb4b268 0000000000000800 14453f6470497100 0000fffffaa520d8
    [  222.707119] 3ee0: 0000fffffaa520d9 000000000000000a 1999999999999999 0000000000000000
    [  222.714948] 3f00: 000000000000006a 0000ffffa8f7d1d8 000000000000000a 0000000000000005
    [  222.722778] 3f20: 0000000000000000 0000000000000000 000000000000002d 0000000000000000
    [  222.730607] 3f40: 0000aaaae19b9f68 0000ffffa8f411f0 0000000000000000 0000aaaae19b9000
    [  222.738436] 3f60: 0000fffffaa533b8 0000fffffaa531f0 0000000000000000 0000000000000001
    [  222.746266] 3f80: 0000fffffaa53ec6 0000000000000000 0000aaaafeb4b200 0000aaaafeb4a010
    [  222.754096] 3fa0: 0000000000000000 0000fffffaa53130 0000aaaae199f36c 0000fffffaa53130
    [  222.761926] 3fc0: 0000ffffa8f411f8 0000000000000000 0000aaaafeb4b268 000000000000006a
    [  222.769755] 3fe0: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
    [  222.777589] [<ffff0000080832c0>] el0_svc_naked+0x34/0x38
    [  222.782899] ---[ end trace eaf8939a3698b1a8 ]---
    [  222.787609] Failed to disable VCCDA2: -5
    [  222.791649] ------------[ cut here ]------------
    [  222.796283] WARNING: CPU: 0 PID: 2423 at drivers/clk/clk.c:595 clk_core_disable+0xc/0x1d8
    [  222.804460] Modules linked in:
    [  222.807511]  snd_soc_pcm3168a_i2c(-)
    [  222.811083]  snd_aloop
    [  222.813439]  arc4
    [  222.815360]  wl18xx
    [  222.817456]  wlcore
    [  222.819551]  mac80211
    [  222.821820]  cfg80211
    [  222.824088]  aes_ce_blk
    [  222.826531]  crypto_simd
    [  222.829060]  cryptd
    [  222.831155]  aes_ce_cipher
    [  222.833859]  crc32_ce
    [  222.836127]  ghash_ce
    [  222.838396]  aes_arm64
    [  222.840752]  gf128mul
    [  222.843020]  snd_soc_rcar
    [  222.845637]  sha2_ce
    [  222.847818]  xhci_plat_hcd
    [  222.850522]  sha256_arm64
    [  222.853138]  xhci_hcd
    [  222.855407]  sha1_ce
    [  222.857589]  renesas_usbhs
    [  222.860292]  evdev
    [  222.862300]  sha1_generic
    [  222.864917]  rcar_gen3_thermal
    [  222.867968]  cpufreq_dt
    [  222.870410]  ravb_streaming(C)
    [  222.873461]  wlcore_sdio
    [  222.875991]  thermal_sys
    [  222.878520]  udc_core
    [  222.880789]  mch_core(C)
    [  222.883318]  usb_dmac
    [  222.885587]  snd_soc_pcm3168a
    [  222.888551]  snd_soc_ak4613
    [  222.891341]  gpio_keys
    [  222.893696]  virt_dma
    [  222.895965]  nfsd
    [  222.897886]  ipv6
    [  222.899808]  autofs4
    [  222.901990]  [last unloaded: snd_soc_pcm3168a_i2c]
    [  222.906783] CPU: 0 PID: 2423 Comm: rmmod Tainted: G        WC      4.14.63-04798-gd456126e4a42-dirty #457
    [  222.916349] Hardware name: Renesas H3ULCB Kingfisher board based on r8a7795 ES2.0+ (DT)
    [  222.924351] task: ffff8006fa8c6200 task.stack: ffff00000a0a0000
    [  222.930270] PC is at clk_core_disable+0xc/0x1d8
    [  222.934799] LR is at clk_core_disable_lock+0x20/0x34
    [  222.939761] pc : [<ffff0000083ab9b8>] lr : [<ffff0000083acd28>] pstate: 800001c5
    [  222.947154] sp : ffff00000a0a3cf0
    [  222.950466] x29: ffff00000a0a3cf0
    [  222.953864] x28: ffff8006fa8c6200
    [  222.957263] x27: ffff0000086f1000
    [  222.960661] x26: 000000000000006a
    [  222.964061] x25: 0000000000000124
    [  222.967458] x24: 0000000000000015
    [  222.970858] x23: ffff8006f9ffa8d0
    [  222.974256] x22: ffff8006faf16480
    [  222.977655] x21: ffff0000007e7040
    [  222.981053] x20: ffff8006faadd100
    [  222.984452] x19: 0000000000000140
    [  222.987850] x18: 000000000000000a
    [  222.991249] x17: 0000000000000000
    [  222.994647] x16: 0000000000000000
    [  222.998046] x15: 000000000d477819
    [  223.001444] x14: 0720072007200720
    [  223.004843] x13: 0720072007200720
    [  223.008242] x12: 0720072007200720
    [  223.011641] x11: 0720072007200720
    [  223.015039] x10: 0720072007200720
    [  223.018438] x9 : 0720072007200720
    [  223.021837] x8 : 0720072007200720
    [  223.025236] x7 : 0000000000000000
    [  223.028634] x6 : 0000000000000007
    [  223.032034] x5 : 0000000000000000
    [  223.035432] x4 : 0000000000000000
    [  223.038831] x3 : 0000000000000000
    [  223.042229] x2 : 0000000004720471
    [  223.045628] x1 : 0000000000000000
    [  223.049026] x0 : ffff8006faadd100
    [  223.052426] Call trace:
    [  223.054870] Exception stack(0xffff00000a0a3bb0 to 0xffff00000a0a3cf0)
    [  223.061309] 3ba0:                                   ffff8006faadd100 0000000000000000
    [  223.069139] 3bc0: 0000000004720471 0000000000000000 0000000000000000 0000000000000000
    [  223.076969] 3be0: 0000000000000007 0000000000000000 0720072007200720 0720072007200720
    [  223.084798] 3c00: 0720072007200720 0720072007200720 0720072007200720 0720072007200720
    [  223.092628] 3c20: 0720072007200720 000000000d477819 0000000000000000 0000000000000000
    [  223.100458] 3c40: 000000000000000a 0000000000000140 ffff8006faadd100 ffff0000007e7040
    [  223.108287] 3c60: ffff8006faf16480 ffff8006f9ffa8d0 0000000000000015 0000000000000124
    [  223.116117] 3c80: 000000000000006a ffff0000086f1000 ffff8006fa8c6200 ffff00000a0a3cf0
    [  223.123947] 3ca0: ffff0000083acd28 ffff00000a0a3cf0 ffff0000083ab9b8 00000000800001c5
    [  223.131777] 3cc0: ffff00000a0a3cf0 ffff0000083acd1c 0000ffffffffffff ffff8006faadd100
    [  223.139606] 3ce0: ffff00000a0a3cf0 ffff0000083ab9b8
    [  223.144483] [<ffff0000083ab9b8>] clk_core_disable+0xc/0x1d8
    [  223.150054] [<ffff0000083acd58>] clk_disable+0x1c/0x28
    [  223.155198] [<ffff0000007d8328>] pcm3168a_remove+0x3c/0x50 [snd_soc_pcm3168a]
    [  223.162334] [<ffff0000007e5010>] pcm3168a_i2c_remove+0x10/0x1c [snd_soc_pcm3168a_i2c]
    [  223.170167] [<ffff0000084b9d9c>] i2c_device_remove+0x38/0x70
    [  223.175826] [<ffff00000843cd5c>] device_release_driver_internal+0xd0/0x1c0
    [  223.182700] [<ffff00000843ced8>] driver_detach+0x70/0x7c
    [  223.188012] [<ffff00000843bf68>] bus_remove_driver+0x74/0xa0
    [  223.193669] [<ffff00000843d7e4>] driver_unregister+0x48/0x4c
    [  223.199329] [<ffff0000084ba8dc>] i2c_del_driver+0x24/0x30
    [  223.204726] [<ffff0000007e5078>] pcm3168a_i2c_driver_exit+0x10/0xf98 [snd_soc_pcm3168a_i2c]
    [  223.213079] [<ffff00000811bd28>] SyS_delete_module+0x198/0x1d4
    [  223.218909] Exception stack(0xffff00000a0a3ec0 to 0xffff00000a0a4000)
    [  223.225349] 3ec0: 0000aaaafeb4b268 0000000000000800 14453f6470497100 0000fffffaa520d8
    [  223.233179] 3ee0: 0000fffffaa520d9 000000000000000a 1999999999999999 0000000000000000
    [  223.241008] 3f00: 000000000000006a 0000ffffa8f7d1d8 000000000000000a 0000000000000005
    [  223.248838] 3f20: 0000000000000000 0000000000000000 000000000000002d 0000000000000000
    [  223.256668] 3f40: 0000aaaae19b9f68 0000ffffa8f411f0 0000000000000000 0000aaaae19b9000
    [  223.264497] 3f60: 0000fffffaa533b8 0000fffffaa531f0 0000000000000000 0000000000000001
    [  223.272327] 3f80: 0000fffffaa53ec6 0000000000000000 0000aaaafeb4b200 0000aaaafeb4a010
    [  223.280157] 3fa0: 0000000000000000 0000fffffaa53130 0000aaaae199f36c 0000fffffaa53130
    [  223.287986] 3fc0: 0000ffffa8f411f8 0000000000000000 0000aaaafeb4b268 000000000000006a
    [  223.295816] 3fe0: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
    [  223.303648] [<ffff0000080832c0>] el0_svc_naked+0x34/0x38
    [  223.308958] ---[ end trace eaf8939a3698b1a9 ]---
    [  223.313752] ------------[ cut here ]------------
    [  223.318383] WARNING: CPU: 0 PID: 2423 at drivers/clk/clk.c:477 clk_core_unprepare+0xc/0x1ac
    [  223.326733] Modules linked in:
    [  223.329784]  snd_soc_pcm3168a_i2c(-)
    [  223.333356]  snd_aloop
    [  223.335712]  arc4
    [  223.337633]  wl18xx
    [  223.339728]  wlcore
    [  223.341823]  mac80211
    [  223.344092]  cfg80211
    [  223.346360]  aes_ce_blk
    [  223.348803]  crypto_simd
    [  223.351332]  cryptd
    [  223.353428]  aes_ce_cipher
    [  223.356131]  crc32_ce
    [  223.358400]  ghash_ce
    [  223.360668]  aes_arm64
    [  223.363024]  gf128mul
    [  223.365293]  snd_soc_rcar
    [  223.367909]  sha2_ce
    [  223.370091]  xhci_plat_hcd
    [  223.372794]  sha256_arm64
    [  223.375410]  xhci_hcd
    [  223.377679]  sha1_ce
    [  223.379861]  renesas_usbhs
    [  223.382564]  evdev
    [  223.384572]  sha1_generic
    [  223.387188]  rcar_gen3_thermal
    [  223.390239]  cpufreq_dt
    [  223.392682]  ravb_streaming(C)
    [  223.395732]  wlcore_sdio
    [  223.398261]  thermal_sys
    [  223.400790]  udc_core
    [  223.403059]  mch_core(C)
    [  223.405588]  usb_dmac
    [  223.407856]  snd_soc_pcm3168a
    [  223.410820]  snd_soc_ak4613
    [  223.413609]  gpio_keys
    [  223.415965]  virt_dma
    [  223.418234]  nfsd
    [  223.420155]  ipv6
    [  223.422076]  autofs4
    [  223.424258]  [last unloaded: snd_soc_pcm3168a_i2c]
    [  223.429050] CPU: 0 PID: 2423 Comm: rmmod Tainted: G        WC      4.14.63-04798-gd456126e4a42-dirty #457
    [  223.438616] Hardware name: Renesas H3ULCB Kingfisher board based on r8a7795 ES2.0+ (DT)
    [  223.446618] task: ffff8006fa8c6200 task.stack: ffff00000a0a0000
    [  223.452536] PC is at clk_core_unprepare+0xc/0x1ac
    [  223.457239] LR is at clk_unprepare+0x28/0x3c
    [  223.461506] pc : [<ffff0000083ab5a4>] lr : [<ffff0000083ace4c>] pstate: 60000145
    [  223.468900] sp : ffff00000a0a3d00
    [  223.472211] x29: ffff00000a0a3d00
    [  223.475609] x28: ffff8006fa8c6200
    [  223.479009] x27: ffff0000086f1000
    [  223.482407] x26: 000000000000006a
    [  223.485807] x25: 0000000000000124
    [  223.489205] x24: 0000000000000015
    [  223.492604] x23: ffff8006f9ffa8d0
    [  223.496003] x22: ffff8006faf16480
    [  223.499402] x21: ffff0000007e7040
    [  223.502800] x20: ffff8006faf16420
    [  223.506199] x19: ffff8006faadd100
    [  223.509597] x18: 000000000000000a
    [  223.512997] x17: 0000000000000000
    [  223.516395] x16: 0000000000000000
    [  223.519794] x15: 0000000000000000
    [  223.523192] x14: 00000033fe89076c
    [  223.526591] x13: 0000000000000400
    [  223.529989] x12: 0000000000000400
    [  223.533388] x11: 0000000000000000
    [  223.536786] x10: 00000000000009e0
    [  223.540185] x9 : ffff00000a0a3be0
    [  223.543583] x8 : ffff8006fa8c6c40
    [  223.546982] x7 : ffff8006fa8c6400
    [  223.550380] x6 : 0000000000000001
    [  223.553780] x5 : 0000000000000000
    [  223.557178] x4 : ffff8006fa8c6200
    [  223.560577] x3 : 0000000000000000
    [  223.563975] x2 : ffff8006fa8c6200
    [  223.567374] x1 : 0000000000000000
    [  223.570772] x0 : ffff8006faadd100
    [  223.574170] Call trace:
    [  223.576615] Exception stack(0xffff00000a0a3bc0 to 0xffff00000a0a3d00)
    [  223.583054] 3bc0: ffff8006faadd100 0000000000000000 ffff8006fa8c6200 0000000000000000
    [  223.590884] 3be0: ffff8006fa8c6200 0000000000000000 0000000000000001 ffff8006fa8c6400
    [  223.598714] 3c00: ffff8006fa8c6c40 ffff00000a0a3be0 00000000000009e0 0000000000000000
    [  223.606544] 3c20: 0000000000000400 0000000000000400 00000033fe89076c 0000000000000000
    [  223.614374] 3c40: 0000000000000000 0000000000000000 000000000000000a ffff8006faadd100
    [  223.622204] 3c60: ffff8006faf16420 ffff0000007e7040 ffff8006faf16480 ffff8006f9ffa8d0
    [  223.630033] 3c80: 0000000000000015 0000000000000124 000000000000006a ffff0000086f1000
    [  223.637863] 3ca0: ffff8006fa8c6200 ffff00000a0a3d00 ffff0000083ace4c ffff00000a0a3d00
    [  223.645693] 3cc0: ffff0000083ab5a4 0000000060000145 0000000000000140 ffff8006faadd100
    [  223.653523] 3ce0: 0000ffffffffffff ffff0000083ace44 ffff00000a0a3d00 ffff0000083ab5a4
    [  223.661353] [<ffff0000083ab5a4>] clk_core_unprepare+0xc/0x1ac
    [  223.667103] [<ffff0000007d8330>] pcm3168a_remove+0x44/0x50 [snd_soc_pcm3168a]
    [  223.674239] [<ffff0000007e5010>] pcm3168a_i2c_remove+0x10/0x1c [snd_soc_pcm3168a_i2c]
    [  223.682070] [<ffff0000084b9d9c>] i2c_device_remove+0x38/0x70
    [  223.687731] [<ffff00000843cd5c>] device_release_driver_internal+0xd0/0x1c0
    [  223.694604] [<ffff00000843ced8>] driver_detach+0x70/0x7c
    [  223.699915] [<ffff00000843bf68>] bus_remove_driver+0x74/0xa0
    [  223.705572] [<ffff00000843d7e4>] driver_unregister+0x48/0x4c
    [  223.711230] [<ffff0000084ba8dc>] i2c_del_driver+0x24/0x30
    [  223.716628] [<ffff0000007e5078>] pcm3168a_i2c_driver_exit+0x10/0xf98 [snd_soc_pcm3168a_i2c]
    [  223.724980] [<ffff00000811bd28>] SyS_delete_module+0x198/0x1d4
    [  223.730811] Exception stack(0xffff00000a0a3ec0 to 0xffff00000a0a4000)
    [  223.737250] 3ec0: 0000aaaafeb4b268 0000000000000800 14453f6470497100 0000fffffaa520d8
    [  223.745079] 3ee0: 0000fffffaa520d9 000000000000000a 1999999999999999 0000000000000000
    [  223.752909] 3f00: 000000000000006a 0000ffffa8f7d1d8 000000000000000a 0000000000000005
    [  223.760739] 3f20: 0000000000000000 0000000000000000 000000000000002d 0000000000000000
    [  223.768568] 3f40: 0000aaaae19b9f68 0000ffffa8f411f0 0000000000000000 0000aaaae19b9000
    [  223.776398] 3f60: 0000fffffaa533b8 0000fffffaa531f0 0000000000000000 0000000000000001
    [  223.784227] 3f80: 0000fffffaa53ec6 0000000000000000 0000aaaafeb4b200 0000aaaafeb4a010
    [  223.792057] 3fa0: 0000000000000000 0000fffffaa53130 0000aaaae199f36c 0000fffffaa53130
    [  223.799886] 3fc0: 0000ffffa8f411f8 0000000000000000 0000aaaafeb4b268 000000000000006a
    [  223.807715] 3fe0: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
    [  223.815546] [<ffff0000080832c0>] el0_svc_naked+0x34/0x38
    [  223.820855] ---[ end trace eaf8939a3698b1aa ]---
    
    Fix this issue by only disable clock and regulators in remove callback
    when CONFIG_PM isn't defined
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 52cc950c9fd1..445d025e1409 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -770,15 +770,22 @@ int pcm3168a_probe(struct device *dev, struct regmap *regmap)
 }
 EXPORT_SYMBOL_GPL(pcm3168a_probe);
 
-void pcm3168a_remove(struct device *dev)
+static void pcm3168a_disable(struct device *dev)
 {
 	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
 
-	pm_runtime_disable(dev);
 	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
-				pcm3168a->supplies);
+			       pcm3168a->supplies);
 	clk_disable_unprepare(pcm3168a->scki);
 }
+
+void pcm3168a_remove(struct device *dev)
+{
+	pm_runtime_disable(dev);
+#ifndef CONFIG_PM
+	pcm3168a_disable(dev);
+#endif
+}
 EXPORT_SYMBOL_GPL(pcm3168a_remove);
 
 #ifdef CONFIG_PM
@@ -833,10 +840,7 @@ static int pcm3168a_rt_suspend(struct device *dev)
 
 	regcache_cache_only(pcm3168a->regmap, true);
 
-	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
-			       pcm3168a->supplies);
-
-	clk_disable_unprepare(pcm3168a->scki);
+	pcm3168a_disable(dev);
 
 	return 0;
 }

commit 223bc10b84970fd772c105b550beeef3ac3502be
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 6 04:33:02 2018 +0000

    ASoC: pcm3168a: remove read-only status register from snd_kcontrol_new
    
    "DACn Zero Flag" and "ADCn Overflow Flag" are read-only status
    register. These information are needed for driver not for user.
    Let's remove these from snd_kcontrol_new.
    
    There is no detail explanation for these register on
    datasheet, but, judging from its behavior, it seems these register
    needs clock to read. Otherwise, I2C returns error.
    Therefor, amixer command will be failed under non working timing.
    
    Without this patch, user often fail amixer command.
    This patch is tested on R-Car H3 ulcb-kf board, SSI3/4 TDM sound.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 5f4327f5b725..115f21658222 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -133,10 +133,6 @@ static const struct snd_kcontrol_new pcm3168a_snd_controls[] = {
 	SOC_DOUBLE("DAC2 Invert Switch", PCM3168A_DAC_INV, 2, 3, 1, 0),
 	SOC_DOUBLE("DAC3 Invert Switch", PCM3168A_DAC_INV, 4, 5, 1, 0),
 	SOC_DOUBLE("DAC4 Invert Switch", PCM3168A_DAC_INV, 6, 7, 1, 0),
-	SOC_DOUBLE_STS("DAC1 Zero Flag", PCM3168A_DAC_ZERO, 0, 1, 1, 0),
-	SOC_DOUBLE_STS("DAC2 Zero Flag", PCM3168A_DAC_ZERO, 2, 3, 1, 0),
-	SOC_DOUBLE_STS("DAC3 Zero Flag", PCM3168A_DAC_ZERO, 4, 5, 1, 0),
-	SOC_DOUBLE_STS("DAC4 Zero Flag", PCM3168A_DAC_ZERO, 6, 7, 1, 0),
 	SOC_ENUM("DAC Volume Control Type", pcm3168a_dac_volume_type),
 	SOC_ENUM("DAC Volume Rate Multiplier", pcm3168a_dac_att_mult),
 	SOC_ENUM("DAC De-Emphasis", pcm3168a_dac_demp),
@@ -176,9 +172,6 @@ static const struct snd_kcontrol_new pcm3168a_snd_controls[] = {
 	SOC_DOUBLE("ADC1 Mute Switch", PCM3168A_ADC_MUTE, 0, 1, 1, 0),
 	SOC_DOUBLE("ADC2 Mute Switch", PCM3168A_ADC_MUTE, 2, 3, 1, 0),
 	SOC_DOUBLE("ADC3 Mute Switch", PCM3168A_ADC_MUTE, 4, 5, 1, 0),
-	SOC_DOUBLE_STS("ADC1 Overflow Flag", PCM3168A_ADC_OV, 0, 1, 1, 0),
-	SOC_DOUBLE_STS("ADC2 Overflow Flag", PCM3168A_ADC_OV, 2, 3, 1, 0),
-	SOC_DOUBLE_STS("ADC3 Overflow Flag", PCM3168A_ADC_OV, 4, 5, 1, 0),
 	SOC_ENUM("ADC Volume Control Type", pcm3168a_adc_volume_type),
 	SOC_ENUM("ADC Volume Rate Multiplier", pcm3168a_adc_att_mult),
 	SOC_ENUM("ADC Overflow Flag Polarity", pcm3168a_adc_ov_pol),

commit 0900d1e64815b3b8d4d04197aa135e77317176e1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 30 07:31:40 2018 +0000

    ASoC: pcm3168a: cleanup hw_constraint for LEFT_J/I2S
    
    hw constraint for LEFT_J/I2S are same, but had duplicated code.
    This code cleanup these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 52cc950c9fd1..5f4327f5b725 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -504,6 +504,10 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 	unsigned int fmt;
 	unsigned int sample_min;
 	unsigned int channel_max;
+	unsigned int channel_maxs[] = {
+		6, /* rx */
+		8  /* tx */
+	};
 
 	if (tx)
 		fmt = pcm3168a->dac_fmt;
@@ -528,18 +532,9 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 		channel_max =  2;
 		break;
 	case PCM3168A_FMT_LEFT_J:
-		sample_min  = 24;
-		if (tx)
-			channel_max = 8;
-		else
-			channel_max = 6;
-		break;
 	case PCM3168A_FMT_I2S:
 		sample_min  = 24;
-		if (tx)
-			channel_max = 8;
-		else
-			channel_max = 6;
+		channel_max = channel_maxs[tx];
 		break;
 	default:
 		sample_min  = 24;

commit 4e9e07c5675706983ed649cfb92521a4d8aa1d6d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 17 01:54:33 2018 +0000

    ASoC: pcm3168a: add hw constraint for capture channel
    
    LEFT_J / I2S only can use TDM.
    commit 594680ea4a394 ("ASoC: pcm3168a: add hw constraint for channel")
    commit 3809688980205 ("ASoC: pcm3168a: add HW constraint for non
    RIGHT_J") added channel constraint for it, but, it was only for playback.
    This patch adds constraint for capture.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 63aa02592bc0..52cc950c9fd1 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -529,11 +529,17 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 		break;
 	case PCM3168A_FMT_LEFT_J:
 		sample_min  = 24;
-		channel_max =  8;
+		if (tx)
+			channel_max = 8;
+		else
+			channel_max = 6;
 		break;
 	case PCM3168A_FMT_I2S:
 		sample_min  = 24;
-		channel_max =  8;
+		if (tx)
+			channel_max = 8;
+		else
+			channel_max = 6;
 		break;
 	default:
 		sample_min  = 24;
@@ -559,6 +565,7 @@ static const struct snd_soc_dai_ops pcm3168a_dac_dai_ops = {
 };
 
 static const struct snd_soc_dai_ops pcm3168a_adc_dai_ops = {
+	.startup	= pcm3168a_startup,
 	.set_fmt	= pcm3168a_set_dai_fmt_adc,
 	.set_sysclk	= pcm3168a_set_dai_sysclk,
 	.hw_params	= pcm3168a_hw_params

commit 471a7ba89158c6d52dae69636c94c4aa1a6b7b22
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Oct 12 06:31:49 2018 +0000

    ASoC: pcm3168a: add I2S/Left_J TDM support
    
    pcm3168a is supporting TDM on I2S/Left_J, but there is no
    settings for it. This patch add it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index f0e2b886323e..63aa02592bc0 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -33,6 +33,8 @@
 #define PCM3168A_FMT_RIGHT_J_16		0x3
 #define PCM3168A_FMT_DSP_A		0x4
 #define PCM3168A_FMT_DSP_B		0x5
+#define PCM3168A_FMT_I2S_TDM		0x6
+#define PCM3168A_FMT_LEFT_J_TDM		0x7
 #define PCM3168A_FMT_DSP_MASK		0x4
 
 #define PCM3168A_NUM_SUPPLIES 6
@@ -401,9 +403,11 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	bool tx, master_mode;
 	u32 val, mask, shift, reg;
 	unsigned int rate, fmt, ratio, max_ratio;
+	unsigned int chan;
 	int i, min_frame_size;
 
 	rate = params_rate(params);
+	chan = params_channels(params);
 
 	ratio = pcm3168a->sysclk / rate;
 
@@ -456,6 +460,21 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
+	/* for TDM */
+	if (chan > 2) {
+		switch (fmt) {
+		case PCM3168A_FMT_I2S:
+			fmt = PCM3168A_FMT_I2S_TDM;
+			break;
+		case PCM3168A_FMT_LEFT_J:
+			fmt = PCM3168A_FMT_LEFT_J_TDM;
+			break;
+		default:
+			dev_err(component->dev, "TDM is supported under I2S/Left_J only\n");
+			return -EINVAL;
+		}
+	}
+
 	if (master_mode)
 		val = ((i + 1) << shift);
 	else

commit 594680ea4a394f19d38a39a7d7c673fbad02a3d6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Oct 12 06:31:18 2018 +0000

    ASoC: pcm3168a: add hw constraint for channel
    
    LEFT_J / I2S only can use TDM.
    This patch adds channel constraint for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 233a8df5d7a5..f0e2b886323e 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -484,6 +484,7 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 	unsigned int fmt;
 	unsigned int sample_min;
+	unsigned int channel_max;
 
 	if (tx)
 		fmt = pcm3168a->dac_fmt;
@@ -496,19 +497,38 @@ static int pcm3168a_startup(struct snd_pcm_substream *substream,
 	 * RIGHT_J : 24 / 16
 	 * LEFT_J  : 24
 	 * I2S     : 24
+	 *
+	 * TDM available
+	 *
+	 * I2S
+	 * LEFT_J
 	 */
 	switch (fmt) {
 	case PCM3168A_FMT_RIGHT_J:
 		sample_min  = 16;
+		channel_max =  2;
+		break;
+	case PCM3168A_FMT_LEFT_J:
+		sample_min  = 24;
+		channel_max =  8;
+		break;
+	case PCM3168A_FMT_I2S:
+		sample_min  = 24;
+		channel_max =  8;
 		break;
 	default:
 		sample_min  = 24;
+		channel_max =  2;
 	}
 
 	snd_pcm_hw_constraint_minmax(substream->runtime,
 				     SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
 				     sample_min, 32);
 
+	snd_pcm_hw_constraint_minmax(substream->runtime,
+				     SNDRV_PCM_HW_PARAM_CHANNELS,
+				     2, channel_max);
+
 	return 0;
 }
 static const struct snd_soc_dai_ops pcm3168a_dac_dai_ops = {

commit 3809688980205622f75ed5d5890759430da4e7e4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Oct 12 06:31:00 2018 +0000

    ASoC: pcm3168a: add HW constraint for non RIGHT_J
    
    RIGHT_J only can handle 16bit data bits.
    Current driver just errored if user requests non RIGHT_J
    + 16bit combination. But it is not useful for user.
    This patch adds HW constraint for it, and avoid
    error on such situation.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 3356c91f55b0..233a8df5d7a5 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -476,7 +476,43 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+static int pcm3168a_startup(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	unsigned int fmt;
+	unsigned int sample_min;
+
+	if (tx)
+		fmt = pcm3168a->dac_fmt;
+	else
+		fmt = pcm3168a->adc_fmt;
+
+	/*
+	 * Available Data Bits
+	 *
+	 * RIGHT_J : 24 / 16
+	 * LEFT_J  : 24
+	 * I2S     : 24
+	 */
+	switch (fmt) {
+	case PCM3168A_FMT_RIGHT_J:
+		sample_min  = 16;
+		break;
+	default:
+		sample_min  = 24;
+	}
+
+	snd_pcm_hw_constraint_minmax(substream->runtime,
+				     SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+				     sample_min, 32);
+
+	return 0;
+}
 static const struct snd_soc_dai_ops pcm3168a_dac_dai_ops = {
+	.startup	= pcm3168a_startup,
 	.set_fmt	= pcm3168a_set_dai_fmt_dac,
 	.set_sysclk	= pcm3168a_set_dai_sysclk,
 	.hw_params	= pcm3168a_hw_params,

commit 29751c1cdf3098380b44c52d2027dd3ba1baadf0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 29 04:19:39 2018 +0000

    ASoC: pcm3168a: replace codec to component
    
    Now we can replace Codec to Component. Let's do it.
    
    Note:
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 1      ->      .idle_bias_on = 0
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index b9d1207ccef2..3356c91f55b0 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -287,8 +287,8 @@ static int pcm3168a_reset(struct pcm3168a_priv *pcm3168a)
 
 static int pcm3168a_digital_mute(struct snd_soc_dai *dai, int mute)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
 
 	regmap_write(pcm3168a->regmap, PCM3168A_DAC_MUTE, mute ? 0xff : 0);
 
@@ -298,7 +298,7 @@ static int pcm3168a_digital_mute(struct snd_soc_dai *dai, int mute)
 static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai,
 				  int clk_id, unsigned int freq, int dir)
 {
-	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(dai->codec);
+	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(dai->component);
 	int ret;
 
 	if (freq > PCM1368A_MAX_SYSCLK)
@@ -316,8 +316,8 @@ static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai,
 static int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai,
 			       unsigned int format, bool dac)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
 	u32 fmt, reg, mask, shift;
 	bool master_mode;
 
@@ -338,7 +338,7 @@ static int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai,
 		fmt = PCM3168A_FMT_DSP_B;
 		break;
 	default:
-		dev_err(codec->dev, "unsupported dai format\n");
+		dev_err(component->dev, "unsupported dai format\n");
 		return -EINVAL;
 	}
 
@@ -350,7 +350,7 @@ static int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai,
 		master_mode = true;
 		break;
 	default:
-		dev_err(codec->dev, "unsupported master/slave mode\n");
+		dev_err(component->dev, "unsupported master/slave mode\n");
 		return -EINVAL;
 	}
 
@@ -396,8 +396,8 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 			     struct snd_pcm_hw_params *params,
 			     struct snd_soc_dai *dai)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);
 	bool tx, master_mode;
 	u32 val, mask, shift, reg;
 	unsigned int rate, fmt, ratio, max_ratio;
@@ -430,7 +430,7 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	if (i == max_ratio) {
-		dev_err(codec->dev, "unsupported sysclk ratio\n");
+		dev_err(component->dev, "unsupported sysclk ratio\n");
 		return -EINVAL;
 	}
 
@@ -438,21 +438,21 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	switch (min_frame_size) {
 	case 32:
 		if (master_mode || (fmt != PCM3168A_FMT_RIGHT_J)) {
-			dev_err(codec->dev, "32-bit frames are supported only for slave mode using right justified\n");
+			dev_err(component->dev, "32-bit frames are supported only for slave mode using right justified\n");
 			return -EINVAL;
 		}
 		fmt = PCM3168A_FMT_RIGHT_J_16;
 		break;
 	case 48:
 		if (master_mode || (fmt & PCM3168A_FMT_DSP_MASK)) {
-			dev_err(codec->dev, "48-bit frames not supported in master mode, or slave mode using DSP\n");
+			dev_err(component->dev, "48-bit frames not supported in master mode, or slave mode using DSP\n");
 			return -EINVAL;
 		}
 		break;
 	case 64:
 		break;
 	default:
-		dev_err(codec->dev, "unsupported frame size: %d\n", min_frame_size);
+		dev_err(component->dev, "unsupported frame size: %d\n", min_frame_size);
 		return -EINVAL;
 	}
 
@@ -595,16 +595,16 @@ const struct regmap_config pcm3168a_regmap = {
 };
 EXPORT_SYMBOL_GPL(pcm3168a_regmap);
 
-static const struct snd_soc_codec_driver pcm3168a_driver = {
-	.idle_bias_off = true,
-	.component_driver = {
-		.controls		= pcm3168a_snd_controls,
-		.num_controls		= ARRAY_SIZE(pcm3168a_snd_controls),
-		.dapm_widgets		= pcm3168a_dapm_widgets,
-		.num_dapm_widgets	= ARRAY_SIZE(pcm3168a_dapm_widgets),
-		.dapm_routes		= pcm3168a_dapm_routes,
-		.num_dapm_routes	= ARRAY_SIZE(pcm3168a_dapm_routes)
-	},
+static const struct snd_soc_component_driver pcm3168a_driver = {
+	.controls		= pcm3168a_snd_controls,
+	.num_controls		= ARRAY_SIZE(pcm3168a_snd_controls),
+	.dapm_widgets		= pcm3168a_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(pcm3168a_dapm_widgets),
+	.dapm_routes		= pcm3168a_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(pcm3168a_dapm_routes),
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
 };
 
 int pcm3168a_probe(struct device *dev, struct regmap *regmap)
@@ -669,10 +669,10 @@ int pcm3168a_probe(struct device *dev, struct regmap *regmap)
 	pm_runtime_enable(dev);
 	pm_runtime_idle(dev);
 
-	ret = snd_soc_register_codec(dev, &pcm3168a_driver, pcm3168a_dais,
+	ret = devm_snd_soc_register_component(dev, &pcm3168a_driver, pcm3168a_dais,
 			ARRAY_SIZE(pcm3168a_dais));
 	if (ret) {
-		dev_err(dev, "failed to register codec: %d\n", ret);
+		dev_err(dev, "failed to register component: %d\n", ret);
 		goto err_regulator;
 	}
 
@@ -692,7 +692,6 @@ void pcm3168a_remove(struct device *dev)
 {
 	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
 
-	snd_soc_unregister_codec(dev);
 	pm_runtime_disable(dev);
 	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
 				pcm3168a->supplies);

commit fc25914631d623880b5fc3abf067bcb3e8c6b4d4
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Dec 8 23:01:33 2016 +0530

    ASoC: pcm3168a: remove unused ‘format’
    
    In pcm3168a_hw_params(), 'format' is initialized but never used.
    
    sound/soc/codecs/pcm3168a.c: In function ‘pcm3168a_hw_params’:
    sound/soc/codecs/pcm3168a.c:405:19: warning: variable ‘format’ set but not
    used [-Wunused-but-set-variable]
      snd_pcm_format_t format;
    
    Cc: Damien.Horsley <Damien.Horsley@imgtec.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 39bc02d5bc5d..b9d1207ccef2 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -402,10 +402,8 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	u32 val, mask, shift, reg;
 	unsigned int rate, fmt, ratio, max_ratio;
 	int i, min_frame_size;
-	snd_pcm_format_t format;
 
 	rate = params_rate(params);
-	format = params_format(params);
 
 	ratio = pcm3168a->sysclk / rate;
 

commit d4fff1ba4768dc7b8dd09db0eee19c1ff098ee60
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Aug 8 08:59:41 2016 +0000

    ASoC: codec duplicated callback function goes to component on pcm3168a
    
    codec driver and component driver has duplicated callback functions,
    and codec side functions are just copied to component side when
    register timing. This was quick-hack, but no longer needed.
    This patch moves these functions from codec driver to component driver.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 992a77edcd5d..39bc02d5bc5d 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -599,12 +599,14 @@ EXPORT_SYMBOL_GPL(pcm3168a_regmap);
 
 static const struct snd_soc_codec_driver pcm3168a_driver = {
 	.idle_bias_off = true,
-	.controls = pcm3168a_snd_controls,
-	.num_controls = ARRAY_SIZE(pcm3168a_snd_controls),
-	.dapm_widgets = pcm3168a_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(pcm3168a_dapm_widgets),
-	.dapm_routes = pcm3168a_dapm_routes,
-	.num_dapm_routes = ARRAY_SIZE(pcm3168a_dapm_routes)
+	.component_driver = {
+		.controls		= pcm3168a_snd_controls,
+		.num_controls		= ARRAY_SIZE(pcm3168a_snd_controls),
+		.dapm_widgets		= pcm3168a_dapm_widgets,
+		.num_dapm_widgets	= ARRAY_SIZE(pcm3168a_dapm_widgets),
+		.dapm_routes		= pcm3168a_dapm_routes,
+		.num_dapm_routes	= ARRAY_SIZE(pcm3168a_dapm_routes)
+	},
 };
 
 int pcm3168a_probe(struct device *dev, struct regmap *regmap)

commit e7a508f2b137092500fbad09d9713d3a1c5d4826
Author: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
Date:   Fri Mar 4 16:27:14 2016 +0530

    ASoC: pcm3168a: remove unused variable
    
    While building we were getting build warning about:
    sound/soc/codecs/pcm3168a.c:403:21: warning: variable 'channels' set but
    not used
    
    The variable channels were being assigned some value but that was never
    reused.
    
    Signed-off-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 0c7248ab6a37..992a77edcd5d 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -400,13 +400,12 @@ static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
 	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
 	bool tx, master_mode;
 	u32 val, mask, shift, reg;
-	unsigned int rate, channels, fmt, ratio, max_ratio;
+	unsigned int rate, fmt, ratio, max_ratio;
 	int i, min_frame_size;
 	snd_pcm_format_t format;
 
 	rate = params_rate(params);
 	format = params_format(params);
-	channels = params_channels(params);
 
 	ratio = pcm3168a->sysclk / rate;
 

commit f1188b898ec5aa2e94da8fb998648a2738f4fb3b
Author: Damien.Horsley <Damien.Horsley@imgtec.com>
Date:   Thu Jan 28 16:54:20 2016 +0000

    ASoC: pcm3168a: Call clk_set_rate in pcm3168a_set_dai_sysclk
    
    Call clk_set_rate in pcm3168a_set_dai_sysclk
    
    Signed-off-by: Damien.Horsley <Damien.Horsley@imgtec.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
index 44b268aa4dd8..0c7248ab6a37 100644
--- a/sound/soc/codecs/pcm3168a.c
+++ b/sound/soc/codecs/pcm3168a.c
@@ -299,10 +299,15 @@ static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai,
 				  int clk_id, unsigned int freq, int dir)
 {
 	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(dai->codec);
+	int ret;
 
 	if (freq > PCM1368A_MAX_SYSCLK)
 		return -EINVAL;
 
+	ret = clk_set_rate(pcm3168a->scki, freq);
+	if (ret)
+		return ret;
+
 	pcm3168a->sysclk = freq;
 
 	return 0;

commit a9b17a638af5ae374677c5349653114231483419
Author: Damien.Horsley <Damien.Horsley@imgtec.com>
Date:   Tue Dec 8 15:59:00 2015 +0000

    ASoC: pcm3168a: Add driver for pcm3168a codec
    
    Add driver for Texas Instruments pcm3168a codec
    
    Signed-off-by: Damien.Horsley <Damien.Horsley@imgtec.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
new file mode 100644
index 000000000000..44b268aa4dd8
--- /dev/null
+++ b/sound/soc/codecs/pcm3168a.c
@@ -0,0 +1,767 @@
+/*
+ * PCM3168A codec driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "pcm3168a.h"
+
+#define PCM3168A_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+			 SNDRV_PCM_FMTBIT_S24_3LE | \
+			 SNDRV_PCM_FMTBIT_S24_LE | \
+			 SNDRV_PCM_FMTBIT_S32_LE)
+
+#define PCM3168A_FMT_I2S		0x0
+#define PCM3168A_FMT_LEFT_J		0x1
+#define PCM3168A_FMT_RIGHT_J		0x2
+#define PCM3168A_FMT_RIGHT_J_16		0x3
+#define PCM3168A_FMT_DSP_A		0x4
+#define PCM3168A_FMT_DSP_B		0x5
+#define PCM3168A_FMT_DSP_MASK		0x4
+
+#define PCM3168A_NUM_SUPPLIES 6
+static const char *const pcm3168a_supply_names[PCM3168A_NUM_SUPPLIES] = {
+	"VDD1",
+	"VDD2",
+	"VCCAD1",
+	"VCCAD2",
+	"VCCDA1",
+	"VCCDA2"
+};
+
+struct pcm3168a_priv {
+	struct regulator_bulk_data supplies[PCM3168A_NUM_SUPPLIES];
+	struct regmap *regmap;
+	struct clk *scki;
+	bool adc_master_mode;
+	bool dac_master_mode;
+	unsigned long sysclk;
+	unsigned int adc_fmt;
+	unsigned int dac_fmt;
+};
+
+static const char *const pcm3168a_roll_off[] = { "Sharp", "Slow" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d1_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT, pcm3168a_roll_off);
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d2_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT + 1, pcm3168a_roll_off);
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d3_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT + 2, pcm3168a_roll_off);
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d4_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT + 3, pcm3168a_roll_off);
+
+static const char *const pcm3168a_volume_type[] = {
+		"Individual", "Master + Individual" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_volume_type, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_ATMDDA_SHIFT, pcm3168a_volume_type);
+
+static const char *const pcm3168a_att_speed_mult[] = { "2048", "4096" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_att_mult, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_ATSPDA_SHIFT, pcm3168a_att_speed_mult);
+
+static const char *const pcm3168a_demp[] = {
+		"Disabled", "48khz", "44.1khz", "32khz" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_demp, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_DEMP_SHIFT, pcm3168a_demp);
+
+static const char *const pcm3168a_zf_func[] = {
+		"DAC 1/2/3/4 AND", "DAC 1/2/3/4 OR", "DAC 1/2/3 AND",
+		"DAC 1/2/3 OR", "DAC 4 AND", "DAC 4 OR" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_zf_func, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_AZRO_SHIFT, pcm3168a_zf_func);
+
+static const char *const pcm3168a_pol[] = { "Active High", "Active Low" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_zf_pol, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_ATSPDA_SHIFT, pcm3168a_pol);
+
+static const char *const pcm3168a_con[] = { "Differential", "Single-Ended" };
+
+static SOC_ENUM_DOUBLE_DECL(pcm3168a_adc1_con, PCM3168A_ADC_SEAD,
+				0, 1, pcm3168a_con);
+static SOC_ENUM_DOUBLE_DECL(pcm3168a_adc2_con, PCM3168A_ADC_SEAD,
+				2, 3, pcm3168a_con);
+static SOC_ENUM_DOUBLE_DECL(pcm3168a_adc3_con, PCM3168A_ADC_SEAD,
+				4, 5, pcm3168a_con);
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_adc_volume_type, PCM3168A_ADC_ATT_OVF,
+		PCM3168A_ADC_ATMDAD_SHIFT, pcm3168a_volume_type);
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_adc_att_mult, PCM3168A_ADC_ATT_OVF,
+		PCM3168A_ADC_ATSPAD_SHIFT, pcm3168a_att_speed_mult);
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_adc_ov_pol, PCM3168A_ADC_ATT_OVF,
+		PCM3168A_ADC_OVFP_SHIFT, pcm3168a_pol);
+
+/* -100db to 0db, register values 0-54 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3168a_dac_tlv, -10050, 50, 1);
+
+/* -100db to 20db, register values 0-14 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3168a_adc_tlv, -10050, 50, 1);
+
+static const struct snd_kcontrol_new pcm3168a_snd_controls[] = {
+	SOC_SINGLE("DAC Power-Save Switch", PCM3168A_DAC_PWR_MST_FMT,
+			PCM3168A_DAC_PSMDA_SHIFT, 1, 1),
+	SOC_ENUM("DAC1 Digital Filter roll-off", pcm3168a_d1_roll_off),
+	SOC_ENUM("DAC2 Digital Filter roll-off", pcm3168a_d2_roll_off),
+	SOC_ENUM("DAC3 Digital Filter roll-off", pcm3168a_d3_roll_off),
+	SOC_ENUM("DAC4 Digital Filter roll-off", pcm3168a_d4_roll_off),
+	SOC_DOUBLE("DAC1 Invert Switch", PCM3168A_DAC_INV, 0, 1, 1, 0),
+	SOC_DOUBLE("DAC2 Invert Switch", PCM3168A_DAC_INV, 2, 3, 1, 0),
+	SOC_DOUBLE("DAC3 Invert Switch", PCM3168A_DAC_INV, 4, 5, 1, 0),
+	SOC_DOUBLE("DAC4 Invert Switch", PCM3168A_DAC_INV, 6, 7, 1, 0),
+	SOC_DOUBLE_STS("DAC1 Zero Flag", PCM3168A_DAC_ZERO, 0, 1, 1, 0),
+	SOC_DOUBLE_STS("DAC2 Zero Flag", PCM3168A_DAC_ZERO, 2, 3, 1, 0),
+	SOC_DOUBLE_STS("DAC3 Zero Flag", PCM3168A_DAC_ZERO, 4, 5, 1, 0),
+	SOC_DOUBLE_STS("DAC4 Zero Flag", PCM3168A_DAC_ZERO, 6, 7, 1, 0),
+	SOC_ENUM("DAC Volume Control Type", pcm3168a_dac_volume_type),
+	SOC_ENUM("DAC Volume Rate Multiplier", pcm3168a_dac_att_mult),
+	SOC_ENUM("DAC De-Emphasis", pcm3168a_dac_demp),
+	SOC_ENUM("DAC Zero Flag Function", pcm3168a_dac_zf_func),
+	SOC_ENUM("DAC Zero Flag Polarity", pcm3168a_dac_zf_pol),
+	SOC_SINGLE_RANGE_TLV("Master Playback Volume",
+			PCM3168A_DAC_VOL_MASTER, 0, 54, 255, 0,
+			pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC1 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START,
+			PCM3168A_DAC_VOL_CHAN_START + 1,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC2 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START + 2,
+			PCM3168A_DAC_VOL_CHAN_START + 3,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC3 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START + 4,
+			PCM3168A_DAC_VOL_CHAN_START + 5,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC4 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START + 6,
+			PCM3168A_DAC_VOL_CHAN_START + 7,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_SINGLE("ADC1 High-Pass Filter Switch", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_BYP_SHIFT, 1, 1),
+	SOC_SINGLE("ADC2 High-Pass Filter Switch", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_BYP_SHIFT + 1, 1, 1),
+	SOC_SINGLE("ADC3 High-Pass Filter Switch", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_BYP_SHIFT + 2, 1, 1),
+	SOC_ENUM("ADC1 Connection Type", pcm3168a_adc1_con),
+	SOC_ENUM("ADC2 Connection Type", pcm3168a_adc2_con),
+	SOC_ENUM("ADC3 Connection Type", pcm3168a_adc3_con),
+	SOC_DOUBLE("ADC1 Invert Switch", PCM3168A_ADC_INV, 0, 1, 1, 0),
+	SOC_DOUBLE("ADC2 Invert Switch", PCM3168A_ADC_INV, 2, 3, 1, 0),
+	SOC_DOUBLE("ADC3 Invert Switch", PCM3168A_ADC_INV, 4, 5, 1, 0),
+	SOC_DOUBLE("ADC1 Mute Switch", PCM3168A_ADC_MUTE, 0, 1, 1, 0),
+	SOC_DOUBLE("ADC2 Mute Switch", PCM3168A_ADC_MUTE, 2, 3, 1, 0),
+	SOC_DOUBLE("ADC3 Mute Switch", PCM3168A_ADC_MUTE, 4, 5, 1, 0),
+	SOC_DOUBLE_STS("ADC1 Overflow Flag", PCM3168A_ADC_OV, 0, 1, 1, 0),
+	SOC_DOUBLE_STS("ADC2 Overflow Flag", PCM3168A_ADC_OV, 2, 3, 1, 0),
+	SOC_DOUBLE_STS("ADC3 Overflow Flag", PCM3168A_ADC_OV, 4, 5, 1, 0),
+	SOC_ENUM("ADC Volume Control Type", pcm3168a_adc_volume_type),
+	SOC_ENUM("ADC Volume Rate Multiplier", pcm3168a_adc_att_mult),
+	SOC_ENUM("ADC Overflow Flag Polarity", pcm3168a_adc_ov_pol),
+	SOC_SINGLE_RANGE_TLV("Master Capture Volume",
+			PCM3168A_ADC_VOL_MASTER, 0, 14, 255, 0,
+			pcm3168a_adc_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("ADC1 Capture Volume",
+			PCM3168A_ADC_VOL_CHAN_START,
+			PCM3168A_ADC_VOL_CHAN_START + 1,
+			0, 14, 255, 0, pcm3168a_adc_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("ADC2 Capture Volume",
+			PCM3168A_ADC_VOL_CHAN_START + 2,
+			PCM3168A_ADC_VOL_CHAN_START + 3,
+			0, 14, 255, 0, pcm3168a_adc_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("ADC3 Capture Volume",
+			PCM3168A_ADC_VOL_CHAN_START + 4,
+			PCM3168A_ADC_VOL_CHAN_START + 5,
+			0, 14, 255, 0, pcm3168a_adc_tlv)
+};
+
+static const struct snd_soc_dapm_widget pcm3168a_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DAC1", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT, 1),
+	SND_SOC_DAPM_DAC("DAC2", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT + 1, 1),
+	SND_SOC_DAPM_DAC("DAC3", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT + 2, 1),
+	SND_SOC_DAPM_DAC("DAC4", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT + 3, 1),
+
+	SND_SOC_DAPM_OUTPUT("AOUT1L"),
+	SND_SOC_DAPM_OUTPUT("AOUT1R"),
+	SND_SOC_DAPM_OUTPUT("AOUT2L"),
+	SND_SOC_DAPM_OUTPUT("AOUT2R"),
+	SND_SOC_DAPM_OUTPUT("AOUT3L"),
+	SND_SOC_DAPM_OUTPUT("AOUT3R"),
+	SND_SOC_DAPM_OUTPUT("AOUT4L"),
+	SND_SOC_DAPM_OUTPUT("AOUT4R"),
+
+	SND_SOC_DAPM_ADC("ADC1", "Capture", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_PSVAD_SHIFT, 1),
+	SND_SOC_DAPM_ADC("ADC2", "Capture", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_PSVAD_SHIFT + 1, 1),
+	SND_SOC_DAPM_ADC("ADC3", "Capture", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_PSVAD_SHIFT + 2, 1),
+
+	SND_SOC_DAPM_INPUT("AIN1L"),
+	SND_SOC_DAPM_INPUT("AIN1R"),
+	SND_SOC_DAPM_INPUT("AIN2L"),
+	SND_SOC_DAPM_INPUT("AIN2R"),
+	SND_SOC_DAPM_INPUT("AIN3L"),
+	SND_SOC_DAPM_INPUT("AIN3R")
+};
+
+static const struct snd_soc_dapm_route pcm3168a_dapm_routes[] = {
+	/* Playback */
+	{ "AOUT1L", NULL, "DAC1" },
+	{ "AOUT1R", NULL, "DAC1" },
+
+	{ "AOUT2L", NULL, "DAC2" },
+	{ "AOUT2R", NULL, "DAC2" },
+
+	{ "AOUT3L", NULL, "DAC3" },
+	{ "AOUT3R", NULL, "DAC3" },
+
+	{ "AOUT4L", NULL, "DAC4" },
+	{ "AOUT4R", NULL, "DAC4" },
+
+	/* Capture */
+	{ "ADC1", NULL, "AIN1L" },
+	{ "ADC1", NULL, "AIN1R" },
+
+	{ "ADC2", NULL, "AIN2L" },
+	{ "ADC2", NULL, "AIN2R" },
+
+	{ "ADC3", NULL, "AIN3L" },
+	{ "ADC3", NULL, "AIN3R" }
+};
+
+static unsigned int pcm3168a_scki_ratios[] = {
+	768,
+	512,
+	384,
+	256,
+	192,
+	128
+};
+
+#define PCM3168A_NUM_SCKI_RATIOS_DAC	ARRAY_SIZE(pcm3168a_scki_ratios)
+#define PCM3168A_NUM_SCKI_RATIOS_ADC	(ARRAY_SIZE(pcm3168a_scki_ratios) - 2)
+
+#define PCM1368A_MAX_SYSCLK		36864000
+
+static int pcm3168a_reset(struct pcm3168a_priv *pcm3168a)
+{
+	int ret;
+
+	ret = regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE, 0);
+	if (ret)
+		return ret;
+
+	/* Internal reset is de-asserted after 3846 SCKI cycles */
+	msleep(DIV_ROUND_UP(3846 * 1000, pcm3168a->sysclk));
+
+	return regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE,
+			PCM3168A_MRST_MASK | PCM3168A_SRST_MASK);
+}
+
+static int pcm3168a_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+
+	regmap_write(pcm3168a->regmap, PCM3168A_DAC_MUTE, mute ? 0xff : 0);
+
+	return 0;
+}
+
+static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(dai->codec);
+
+	if (freq > PCM1368A_MAX_SYSCLK)
+		return -EINVAL;
+
+	pcm3168a->sysclk = freq;
+
+	return 0;
+}
+
+static int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai,
+			       unsigned int format, bool dac)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+	u32 fmt, reg, mask, shift;
+	bool master_mode;
+
+	switch (format & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+		fmt = PCM3168A_FMT_LEFT_J;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		fmt = PCM3168A_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		fmt = PCM3168A_FMT_RIGHT_J;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		fmt = PCM3168A_FMT_DSP_A;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		fmt = PCM3168A_FMT_DSP_B;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported dai format\n");
+		return -EINVAL;
+	}
+
+	switch (format & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		master_mode = false;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		master_mode = true;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported master/slave mode\n");
+		return -EINVAL;
+	}
+
+	switch (format & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (dac) {
+		reg = PCM3168A_DAC_PWR_MST_FMT;
+		mask = PCM3168A_DAC_FMT_MASK;
+		shift = PCM3168A_DAC_FMT_SHIFT;
+		pcm3168a->dac_master_mode = master_mode;
+		pcm3168a->dac_fmt = fmt;
+	} else {
+		reg = PCM3168A_ADC_MST_FMT;
+		mask = PCM3168A_ADC_FMTAD_MASK;
+		shift = PCM3168A_ADC_FMTAD_SHIFT;
+		pcm3168a->adc_master_mode = master_mode;
+		pcm3168a->adc_fmt = fmt;
+	}
+
+	regmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);
+
+	return 0;
+}
+
+static int pcm3168a_set_dai_fmt_dac(struct snd_soc_dai *dai,
+			       unsigned int format)
+{
+	return pcm3168a_set_dai_fmt(dai, format, true);
+}
+
+static int pcm3168a_set_dai_fmt_adc(struct snd_soc_dai *dai,
+			       unsigned int format)
+{
+	return pcm3168a_set_dai_fmt(dai, format, false);
+}
+
+static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+	bool tx, master_mode;
+	u32 val, mask, shift, reg;
+	unsigned int rate, channels, fmt, ratio, max_ratio;
+	int i, min_frame_size;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	format = params_format(params);
+	channels = params_channels(params);
+
+	ratio = pcm3168a->sysclk / rate;
+
+	tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	if (tx) {
+		max_ratio = PCM3168A_NUM_SCKI_RATIOS_DAC;
+		reg = PCM3168A_DAC_PWR_MST_FMT;
+		mask = PCM3168A_DAC_MSDA_MASK;
+		shift = PCM3168A_DAC_MSDA_SHIFT;
+		master_mode = pcm3168a->dac_master_mode;
+		fmt = pcm3168a->dac_fmt;
+	} else {
+		max_ratio = PCM3168A_NUM_SCKI_RATIOS_ADC;
+		reg = PCM3168A_ADC_MST_FMT;
+		mask = PCM3168A_ADC_MSAD_MASK;
+		shift = PCM3168A_ADC_MSAD_SHIFT;
+		master_mode = pcm3168a->adc_master_mode;
+		fmt = pcm3168a->adc_fmt;
+	}
+
+	for (i = 0; i < max_ratio; i++) {
+		if (pcm3168a_scki_ratios[i] == ratio)
+			break;
+	}
+
+	if (i == max_ratio) {
+		dev_err(codec->dev, "unsupported sysclk ratio\n");
+		return -EINVAL;
+	}
+
+	min_frame_size = params_width(params) * 2;
+	switch (min_frame_size) {
+	case 32:
+		if (master_mode || (fmt != PCM3168A_FMT_RIGHT_J)) {
+			dev_err(codec->dev, "32-bit frames are supported only for slave mode using right justified\n");
+			return -EINVAL;
+		}
+		fmt = PCM3168A_FMT_RIGHT_J_16;
+		break;
+	case 48:
+		if (master_mode || (fmt & PCM3168A_FMT_DSP_MASK)) {
+			dev_err(codec->dev, "48-bit frames not supported in master mode, or slave mode using DSP\n");
+			return -EINVAL;
+		}
+		break;
+	case 64:
+		break;
+	default:
+		dev_err(codec->dev, "unsupported frame size: %d\n", min_frame_size);
+		return -EINVAL;
+	}
+
+	if (master_mode)
+		val = ((i + 1) << shift);
+	else
+		val = 0;
+
+	regmap_update_bits(pcm3168a->regmap, reg, mask, val);
+
+	if (tx) {
+		mask = PCM3168A_DAC_FMT_MASK;
+		shift = PCM3168A_DAC_FMT_SHIFT;
+	} else {
+		mask = PCM3168A_ADC_FMTAD_MASK;
+		shift = PCM3168A_ADC_FMTAD_SHIFT;
+	}
+
+	regmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops pcm3168a_dac_dai_ops = {
+	.set_fmt	= pcm3168a_set_dai_fmt_dac,
+	.set_sysclk	= pcm3168a_set_dai_sysclk,
+	.hw_params	= pcm3168a_hw_params,
+	.digital_mute	= pcm3168a_digital_mute
+};
+
+static const struct snd_soc_dai_ops pcm3168a_adc_dai_ops = {
+	.set_fmt	= pcm3168a_set_dai_fmt_adc,
+	.set_sysclk	= pcm3168a_set_dai_sysclk,
+	.hw_params	= pcm3168a_hw_params
+};
+
+static struct snd_soc_dai_driver pcm3168a_dais[] = {
+	{
+		.name = "pcm3168a-dac",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = PCM3168A_FORMATS
+		},
+		.ops = &pcm3168a_dac_dai_ops
+	},
+	{
+		.name = "pcm3168a-adc",
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 6,
+			.rates = SNDRV_PCM_RATE_8000_96000,
+			.formats = PCM3168A_FORMATS
+		},
+		.ops = &pcm3168a_adc_dai_ops
+	},
+};
+
+static const struct reg_default pcm3168a_reg_default[] = {
+	{ PCM3168A_RST_SMODE, PCM3168A_MRST_MASK | PCM3168A_SRST_MASK },
+	{ PCM3168A_DAC_PWR_MST_FMT, 0x00 },
+	{ PCM3168A_DAC_OP_FLT, 0x00 },
+	{ PCM3168A_DAC_INV, 0x00 },
+	{ PCM3168A_DAC_MUTE, 0x00 },
+	{ PCM3168A_DAC_ZERO, 0x00 },
+	{ PCM3168A_DAC_ATT_DEMP_ZF, 0x00 },
+	{ PCM3168A_DAC_VOL_MASTER, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 1, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 2, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 3, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 4, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 5, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 6, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 7, 0xff },
+	{ PCM3168A_ADC_SMODE, 0x00 },
+	{ PCM3168A_ADC_MST_FMT, 0x00 },
+	{ PCM3168A_ADC_PWR_HPFB, 0x00 },
+	{ PCM3168A_ADC_SEAD, 0x00 },
+	{ PCM3168A_ADC_INV, 0x00 },
+	{ PCM3168A_ADC_MUTE, 0x00 },
+	{ PCM3168A_ADC_OV, 0x00 },
+	{ PCM3168A_ADC_ATT_OVF, 0x00 },
+	{ PCM3168A_ADC_VOL_MASTER, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 1, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 2, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 3, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 4, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 5, 0xd3 }
+};
+
+static bool pcm3168a_readable_register(struct device *dev, unsigned int reg)
+{
+	if (reg >= PCM3168A_RST_SMODE)
+		return true;
+	else
+		return false;
+}
+
+static bool pcm3168a_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case PCM3168A_DAC_ZERO:
+	case PCM3168A_ADC_OV:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool pcm3168a_writeable_register(struct device *dev, unsigned int reg)
+{
+	if (reg < PCM3168A_RST_SMODE)
+		return false;
+
+	switch (reg) {
+	case PCM3168A_DAC_ZERO:
+	case PCM3168A_ADC_OV:
+		return false;
+	default:
+		return true;
+	}
+}
+
+const struct regmap_config pcm3168a_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = PCM3168A_ADC_VOL_CHAN_START + 5,
+	.reg_defaults = pcm3168a_reg_default,
+	.num_reg_defaults = ARRAY_SIZE(pcm3168a_reg_default),
+	.readable_reg = pcm3168a_readable_register,
+	.volatile_reg = pcm3168a_volatile_register,
+	.writeable_reg = pcm3168a_writeable_register,
+	.cache_type = REGCACHE_FLAT
+};
+EXPORT_SYMBOL_GPL(pcm3168a_regmap);
+
+static const struct snd_soc_codec_driver pcm3168a_driver = {
+	.idle_bias_off = true,
+	.controls = pcm3168a_snd_controls,
+	.num_controls = ARRAY_SIZE(pcm3168a_snd_controls),
+	.dapm_widgets = pcm3168a_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(pcm3168a_dapm_widgets),
+	.dapm_routes = pcm3168a_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(pcm3168a_dapm_routes)
+};
+
+int pcm3168a_probe(struct device *dev, struct regmap *regmap)
+{
+	struct pcm3168a_priv *pcm3168a;
+	int ret, i;
+
+	pcm3168a = devm_kzalloc(dev, sizeof(*pcm3168a), GFP_KERNEL);
+	if (pcm3168a == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, pcm3168a);
+
+	pcm3168a->scki = devm_clk_get(dev, "scki");
+	if (IS_ERR(pcm3168a->scki)) {
+		ret = PTR_ERR(pcm3168a->scki);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "failed to acquire clock 'scki': %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pcm3168a->scki);
+	if (ret) {
+		dev_err(dev, "Failed to enable mclk: %d\n", ret);
+		return ret;
+	}
+
+	pcm3168a->sysclk = clk_get_rate(pcm3168a->scki);
+
+	for (i = 0; i < ARRAY_SIZE(pcm3168a->supplies); i++)
+		pcm3168a->supplies[i].supply = pcm3168a_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev,
+			ARRAY_SIZE(pcm3168a->supplies), pcm3168a->supplies);
+	if (ret) {
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "failed to request supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),
+				    pcm3168a->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	pcm3168a->regmap = regmap;
+	if (IS_ERR(pcm3168a->regmap)) {
+		ret = PTR_ERR(pcm3168a->regmap);
+		dev_err(dev, "failed to allocate regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	ret = pcm3168a_reset(pcm3168a);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	ret = snd_soc_register_codec(dev, &pcm3168a_driver, pcm3168a_dais,
+			ARRAY_SIZE(pcm3168a_dais));
+	if (ret) {
+		dev_err(dev, "failed to register codec: %d\n", ret);
+		goto err_regulator;
+	}
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+			pcm3168a->supplies);
+err_clk:
+	clk_disable_unprepare(pcm3168a->scki);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcm3168a_probe);
+
+void pcm3168a_remove(struct device *dev)
+{
+	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
+
+	snd_soc_unregister_codec(dev);
+	pm_runtime_disable(dev);
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+				pcm3168a->supplies);
+	clk_disable_unprepare(pcm3168a->scki);
+}
+EXPORT_SYMBOL_GPL(pcm3168a_remove);
+
+#ifdef CONFIG_PM
+static int pcm3168a_rt_resume(struct device *dev)
+{
+	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(pcm3168a->scki);
+	if (ret) {
+		dev_err(dev, "Failed to enable mclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),
+				    pcm3168a->supplies);
+	if (ret) {
+		dev_err(dev, "Failed to enable supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = pcm3168a_reset(pcm3168a);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	regcache_cache_only(pcm3168a->regmap, false);
+
+	regcache_mark_dirty(pcm3168a->regmap);
+
+	ret = regcache_sync(pcm3168a->regmap);
+	if (ret) {
+		dev_err(dev, "Failed to sync regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+			       pcm3168a->supplies);
+err_clk:
+	clk_disable_unprepare(pcm3168a->scki);
+
+	return ret;
+}
+
+static int pcm3168a_rt_suspend(struct device *dev)
+{
+	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
+
+	regcache_cache_only(pcm3168a->regmap, true);
+
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+			       pcm3168a->supplies);
+
+	clk_disable_unprepare(pcm3168a->scki);
+
+	return 0;
+}
+#endif
+
+const struct dev_pm_ops pcm3168a_pm_ops = {
+	SET_RUNTIME_PM_OPS(pcm3168a_rt_suspend, pcm3168a_rt_resume, NULL)
+};
+EXPORT_SYMBOL_GPL(pcm3168a_pm_ops);
+
+MODULE_DESCRIPTION("PCM3168A codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
