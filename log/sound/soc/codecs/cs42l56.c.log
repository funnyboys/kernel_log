commit e33d565795930d0341bb946aec457a814ccd53e6
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Thu Aug 15 17:24:36 2019 +0800

    ASoC: cs42l56: remove unused variable 'adc_swap_enum'
    
    sound/soc/codecs/cs42l56.c:206:30: warning:
     adc_swap_enum defined but not used [-Wunused-const-variable=]
    
    It is never used, so can be removed.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lore.kernel.org/r/20190815092436.34632-1-yuehaibing@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index b4d7627525f9..ac569ab3d30f 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -199,14 +199,6 @@ static const struct soc_enum beep_bass_enum =
 	SOC_ENUM_SINGLE(CS42L56_BEEP_TONE_CFG, 1,
 			ARRAY_SIZE(beep_bass_text), beep_bass_text);
 
-static const char * const adc_swap_text[] = {
-	"None", "A+B/2", "A-B/2", "Swap"
-};
-
-static const struct soc_enum adc_swap_enum =
-	SOC_ENUM_SINGLE(CS42L56_MISC_ADC_CTL, 3,
-			ARRAY_SIZE(adc_swap_text), adc_swap_text);
-
 static const char * const pgaa_mux_text[] = {
 	"AIN1A", "AIN2A", "AIN3A"};
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index a5c8736fad77..b4d7627525f9 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * cs42l56.c -- CS42L56 ALSA SoC audio driver
  *
  * Copyright 2014 CirrusLogic, Inc.
  *
  * Author: Brian Austin <brian.austin@cirrus.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 
 #include <linux/module.h>

commit e48f7466f9d93232da3f33ca722aa23a0a892f9e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 29 03:58:25 2018 +0000

    ASoC: cs42l56: replace codec to component
    
    Now we can replace Codec to Component. Let's do it.
    
    Note:
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 0      ->      .idle_bias_on = 1
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index fd7b8d32c2b2..a5c8736fad77 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -45,7 +45,7 @@ static const char *const cs42l56_supply_names[CS42L56_NUM_SUPPLIES] = {
 
 struct  cs42l56_private {
 	struct regmap *regmap;
-	struct snd_soc_codec *codec;
+	struct snd_soc_component *component;
 	struct device *dev;
 	struct cs42l56_platform_data pdata;
 	struct regulator_bulk_data supplies[CS42L56_NUM_SUPPLIES];
@@ -726,8 +726,8 @@ static int cs42l56_get_mclk_ratio(int mclk, int rate)
 static int cs42l56_set_sysclk(struct snd_soc_dai *codec_dai,
 			int clk_id, unsigned int freq, int dir)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = codec_dai->component;
+	struct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);
 
 	switch (freq) {
 	case CS42L56_MCLK_5P6448MHZ:
@@ -753,10 +753,10 @@ static int cs42l56_set_sysclk(struct snd_soc_dai *codec_dai,
 	}
 	cs42l56->mclk = freq;
 
-	snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+	snd_soc_component_update_bits(component, CS42L56_CLKCTL_1,
 			    CS42L56_MCLK_PREDIV_MASK,
 				cs42l56->mclk_prediv);
-	snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+	snd_soc_component_update_bits(component, CS42L56_CLKCTL_1,
 			    CS42L56_MCLK_DIV2_MASK,
 				cs42l56->mclk_div2);
 
@@ -765,8 +765,8 @@ static int cs42l56_set_sysclk(struct snd_soc_dai *codec_dai,
 
 static int cs42l56_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = codec_dai->component;
+	struct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);
 
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBM_CFM:
@@ -803,22 +803,22 @@ static int cs42l56_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 		return -EINVAL;
 	}
 
-	snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+	snd_soc_component_update_bits(component, CS42L56_CLKCTL_1,
 			    CS42L56_MS_MODE_MASK, cs42l56->iface);
-	snd_soc_update_bits(codec, CS42L56_SERIAL_FMT,
+	snd_soc_component_update_bits(component, CS42L56_SERIAL_FMT,
 			    CS42L56_DIG_FMT_MASK, cs42l56->iface_fmt);
-	snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+	snd_soc_component_update_bits(component, CS42L56_CLKCTL_1,
 			    CS42L56_SCLK_INV_MASK, cs42l56->iface_inv);
 	return 0;
 }
 
 static int cs42l56_digital_mute(struct snd_soc_dai *dai, int mute)
 {
-	struct snd_soc_codec *codec = dai->codec;
+	struct snd_soc_component *component = dai->component;
 
 	if (mute) {
 		/* Hit the DSP Mixer first */
-		snd_soc_update_bits(codec, CS42L56_DSP_MUTE_CTL,
+		snd_soc_component_update_bits(component, CS42L56_DSP_MUTE_CTL,
 				    CS42L56_ADCAMIX_MUTE_MASK |
 				    CS42L56_ADCBMIX_MUTE_MASK |
 				    CS42L56_PCMAMIX_MUTE_MASK |
@@ -827,21 +827,21 @@ static int cs42l56_digital_mute(struct snd_soc_dai *dai, int mute)
 				    CS42L56_MSTA_MUTE_MASK,
 				    CS42L56_MUTE_ALL);
 		/* Mute ADC's */
-		snd_soc_update_bits(codec, CS42L56_MISC_ADC_CTL,
+		snd_soc_component_update_bits(component, CS42L56_MISC_ADC_CTL,
 				    CS42L56_ADCA_MUTE_MASK |
 				    CS42L56_ADCB_MUTE_MASK,
 				    CS42L56_MUTE_ALL);
 		/* HP And LO */
-		snd_soc_update_bits(codec, CS42L56_HPA_VOLUME,
+		snd_soc_component_update_bits(component, CS42L56_HPA_VOLUME,
 				    CS42L56_HP_MUTE_MASK, CS42L56_MUTE_ALL);
-		snd_soc_update_bits(codec, CS42L56_HPB_VOLUME,
+		snd_soc_component_update_bits(component, CS42L56_HPB_VOLUME,
 				    CS42L56_HP_MUTE_MASK, CS42L56_MUTE_ALL);
-		snd_soc_update_bits(codec, CS42L56_LOA_VOLUME,
+		snd_soc_component_update_bits(component, CS42L56_LOA_VOLUME,
 				    CS42L56_LO_MUTE_MASK, CS42L56_MUTE_ALL);
-		snd_soc_update_bits(codec, CS42L56_LOB_VOLUME,
+		snd_soc_component_update_bits(component, CS42L56_LOB_VOLUME,
 				    CS42L56_LO_MUTE_MASK, CS42L56_MUTE_ALL);
 	} else {
-		snd_soc_update_bits(codec, CS42L56_DSP_MUTE_CTL,
+		snd_soc_component_update_bits(component, CS42L56_DSP_MUTE_CTL,
 				    CS42L56_ADCAMIX_MUTE_MASK |
 				    CS42L56_ADCBMIX_MUTE_MASK |
 				    CS42L56_PCMAMIX_MUTE_MASK |
@@ -850,18 +850,18 @@ static int cs42l56_digital_mute(struct snd_soc_dai *dai, int mute)
 				    CS42L56_MSTA_MUTE_MASK,
 				    CS42L56_UNMUTE);
 
-		snd_soc_update_bits(codec, CS42L56_MISC_ADC_CTL,
+		snd_soc_component_update_bits(component, CS42L56_MISC_ADC_CTL,
 				    CS42L56_ADCA_MUTE_MASK |
 				    CS42L56_ADCB_MUTE_MASK,
 				    CS42L56_UNMUTE);
 
-		snd_soc_update_bits(codec, CS42L56_HPA_VOLUME,
+		snd_soc_component_update_bits(component, CS42L56_HPA_VOLUME,
 				    CS42L56_HP_MUTE_MASK, CS42L56_UNMUTE);
-		snd_soc_update_bits(codec, CS42L56_HPB_VOLUME,
+		snd_soc_component_update_bits(component, CS42L56_HPB_VOLUME,
 				    CS42L56_HP_MUTE_MASK, CS42L56_UNMUTE);
-		snd_soc_update_bits(codec, CS42L56_LOA_VOLUME,
+		snd_soc_component_update_bits(component, CS42L56_LOA_VOLUME,
 				    CS42L56_LO_MUTE_MASK, CS42L56_UNMUTE);
-		snd_soc_update_bits(codec, CS42L56_LOB_VOLUME,
+		snd_soc_component_update_bits(component, CS42L56_LOB_VOLUME,
 				    CS42L56_LO_MUTE_MASK, CS42L56_UNMUTE);
 	}
 	return 0;
@@ -871,39 +871,39 @@ static int cs42l56_pcm_hw_params(struct snd_pcm_substream *substream,
 				     struct snd_pcm_hw_params *params,
 				     struct snd_soc_dai *dai)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);
 	int ratio;
 
 	ratio = cs42l56_get_mclk_ratio(cs42l56->mclk, params_rate(params));
 	if (ratio >= 0) {
-		snd_soc_update_bits(codec, CS42L56_CLKCTL_2,
+		snd_soc_component_update_bits(component, CS42L56_CLKCTL_2,
 				    CS42L56_CLK_RATIO_MASK, ratio);
 	} else {
-		dev_err(codec->dev, "unsupported mclk/sclk/lrclk ratio\n");
+		dev_err(component->dev, "unsupported mclk/sclk/lrclk ratio\n");
 		return -EINVAL;
 	}
 
 	return 0;
 }
 
-static int cs42l56_set_bias_level(struct snd_soc_codec *codec,
+static int cs42l56_set_bias_level(struct snd_soc_component *component,
 					enum snd_soc_bias_level level)
 {
-	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	struct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);
 	int ret;
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
 		break;
 	case SND_SOC_BIAS_PREPARE:
-		snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+		snd_soc_component_update_bits(component, CS42L56_CLKCTL_1,
 				    CS42L56_MCLK_DIS_MASK, 0);
-		snd_soc_update_bits(codec, CS42L56_PWRCTL_1,
+		snd_soc_component_update_bits(component, CS42L56_PWRCTL_1,
 				    CS42L56_PDN_ALL_MASK, 0);
 		break;
 	case SND_SOC_BIAS_STANDBY:
-		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
+		if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {
 			regcache_cache_only(cs42l56->regmap, false);
 			regcache_sync(cs42l56->regmap);
 			ret = regulator_bulk_enable(ARRAY_SIZE(cs42l56->supplies),
@@ -915,13 +915,13 @@ static int cs42l56_set_bias_level(struct snd_soc_codec *codec,
 				return ret;
 			}
 		}
-		snd_soc_update_bits(codec, CS42L56_PWRCTL_1,
+		snd_soc_component_update_bits(component, CS42L56_PWRCTL_1,
 				    CS42L56_PDN_ALL_MASK, 1);
 		break;
 	case SND_SOC_BIAS_OFF:
-		snd_soc_update_bits(codec, CS42L56_PWRCTL_1,
+		snd_soc_component_update_bits(component, CS42L56_PWRCTL_1,
 				    CS42L56_PDN_ALL_MASK, 1);
-		snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+		snd_soc_component_update_bits(component, CS42L56_CLKCTL_1,
 				    CS42L56_MCLK_DIS_MASK, 1);
 		regcache_cache_only(cs42l56->regmap, true);
 		regulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),
@@ -974,8 +974,8 @@ static void cs42l56_beep_work(struct work_struct *work)
 {
 	struct cs42l56_private *cs42l56 =
 		container_of(work, struct cs42l56_private, beep_work);
-	struct snd_soc_codec *codec = cs42l56->codec;
-	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	struct snd_soc_component *component = cs42l56->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	int i;
 	int val = 0;
 	int best = 0;
@@ -987,18 +987,18 @@ static void cs42l56_beep_work(struct work_struct *work)
 				best = i;
 		}
 
-		dev_dbg(codec->dev, "Set beep rate %dHz for requested %dHz\n",
+		dev_dbg(component->dev, "Set beep rate %dHz for requested %dHz\n",
 			beep_freq[best], cs42l56->beep_rate);
 
 		val = (best << CS42L56_BEEP_RATE_SHIFT);
 
 		snd_soc_dapm_enable_pin(dapm, "Beep");
 	} else {
-		dev_dbg(codec->dev, "Disabling beep\n");
+		dev_dbg(component->dev, "Disabling beep\n");
 		snd_soc_dapm_disable_pin(dapm, "Beep");
 	}
 
-	snd_soc_update_bits(codec, CS42L56_BEEP_FREQ_ONTIME,
+	snd_soc_component_update_bits(component, CS42L56_BEEP_FREQ_ONTIME,
 			    CS42L56_BEEP_FREQ_MASK, val);
 
 	snd_soc_dapm_sync(dapm);
@@ -1010,10 +1010,10 @@ static void cs42l56_beep_work(struct work_struct *work)
 static int cs42l56_beep_event(struct input_dev *dev, unsigned int type,
 			     unsigned int code, int hz)
 {
-	struct snd_soc_codec *codec = input_get_drvdata(dev);
-	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = input_get_drvdata(dev);
+	struct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);
 
-	dev_dbg(codec->dev, "Beep event %x %x\n", code, hz);
+	dev_dbg(component->dev, "Beep event %x %x\n", code, hz);
 
 	switch (code) {
 	case SND_BELL:
@@ -1050,14 +1050,14 @@ static ssize_t cs42l56_beep_set(struct device *dev,
 
 static DEVICE_ATTR(beep, 0200, NULL, cs42l56_beep_set);
 
-static void cs42l56_init_beep(struct snd_soc_codec *codec)
+static void cs42l56_init_beep(struct snd_soc_component *component)
 {
-	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	struct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);
 	int ret;
 
-	cs42l56->beep = devm_input_allocate_device(codec->dev);
+	cs42l56->beep = devm_input_allocate_device(component->dev);
 	if (!cs42l56->beep) {
-		dev_err(codec->dev, "Failed to allocate beep device\n");
+		dev_err(component->dev, "Failed to allocate beep device\n");
 		return;
 	}
 
@@ -1065,68 +1065,67 @@ static void cs42l56_init_beep(struct snd_soc_codec *codec)
 	cs42l56->beep_rate = 0;
 
 	cs42l56->beep->name = "CS42L56 Beep Generator";
-	cs42l56->beep->phys = dev_name(codec->dev);
+	cs42l56->beep->phys = dev_name(component->dev);
 	cs42l56->beep->id.bustype = BUS_I2C;
 
 	cs42l56->beep->evbit[0] = BIT_MASK(EV_SND);
 	cs42l56->beep->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);
 	cs42l56->beep->event = cs42l56_beep_event;
-	cs42l56->beep->dev.parent = codec->dev;
-	input_set_drvdata(cs42l56->beep, codec);
+	cs42l56->beep->dev.parent = component->dev;
+	input_set_drvdata(cs42l56->beep, component);
 
 	ret = input_register_device(cs42l56->beep);
 	if (ret != 0) {
 		cs42l56->beep = NULL;
-		dev_err(codec->dev, "Failed to register beep device\n");
+		dev_err(component->dev, "Failed to register beep device\n");
 	}
 
-	ret = device_create_file(codec->dev, &dev_attr_beep);
+	ret = device_create_file(component->dev, &dev_attr_beep);
 	if (ret != 0) {
-		dev_err(codec->dev, "Failed to create keyclick file: %d\n",
+		dev_err(component->dev, "Failed to create keyclick file: %d\n",
 			ret);
 	}
 }
 
-static void cs42l56_free_beep(struct snd_soc_codec *codec)
+static void cs42l56_free_beep(struct snd_soc_component *component)
 {
-	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	struct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);
 
-	device_remove_file(codec->dev, &dev_attr_beep);
+	device_remove_file(component->dev, &dev_attr_beep);
 	cancel_work_sync(&cs42l56->beep_work);
 	cs42l56->beep = NULL;
 
-	snd_soc_update_bits(codec, CS42L56_BEEP_TONE_CFG,
+	snd_soc_component_update_bits(component, CS42L56_BEEP_TONE_CFG,
 			    CS42L56_BEEP_EN_MASK, 0);
 }
 
-static int cs42l56_probe(struct snd_soc_codec *codec)
+static int cs42l56_probe(struct snd_soc_component *component)
 {
-	cs42l56_init_beep(codec);
+	cs42l56_init_beep(component);
 
 	return 0;
 }
 
-static int cs42l56_remove(struct snd_soc_codec *codec)
+static void cs42l56_remove(struct snd_soc_component *component)
 {
-	cs42l56_free_beep(codec);
-
-	return 0;
+	cs42l56_free_beep(component);
 }
 
-static const struct snd_soc_codec_driver soc_codec_dev_cs42l56 = {
-	.probe = cs42l56_probe,
-	.remove = cs42l56_remove,
-	.set_bias_level = cs42l56_set_bias_level,
-	.suspend_bias_off = true,
-
-	.component_driver = {
-		.controls		= cs42l56_snd_controls,
-		.num_controls		= ARRAY_SIZE(cs42l56_snd_controls),
-		.dapm_widgets		= cs42l56_dapm_widgets,
-		.num_dapm_widgets	= ARRAY_SIZE(cs42l56_dapm_widgets),
-		.dapm_routes		= cs42l56_audio_map,
-		.num_dapm_routes	= ARRAY_SIZE(cs42l56_audio_map),
-	},
+static const struct snd_soc_component_driver soc_component_dev_cs42l56 = {
+	.probe			= cs42l56_probe,
+	.remove			= cs42l56_remove,
+	.set_bias_level		= cs42l56_set_bias_level,
+	.controls		= cs42l56_snd_controls,
+	.num_controls		= ARRAY_SIZE(cs42l56_snd_controls),
+	.dapm_widgets		= cs42l56_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(cs42l56_dapm_widgets),
+	.dapm_routes		= cs42l56_audio_map,
+	.num_dapm_routes	= ARRAY_SIZE(cs42l56_audio_map),
+	.suspend_bias_off	= 1,
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
 };
 
 static const struct regmap_config cs42l56_regmap = {
@@ -1315,8 +1314,8 @@ static int cs42l56_i2c_probe(struct i2c_client *i2c_client,
 				   CS42L56_ADAPT_PWR_MASK,
 				cs42l56->pdata.adaptive_pwr);
 
-	ret =  snd_soc_register_codec(&i2c_client->dev,
-			&soc_codec_dev_cs42l56, &cs42l56_dai, 1);
+	ret =  devm_snd_soc_register_component(&i2c_client->dev,
+			&soc_component_dev_cs42l56, &cs42l56_dai, 1);
 	if (ret < 0)
 		return ret;
 
@@ -1332,7 +1331,6 @@ static int cs42l56_i2c_remove(struct i2c_client *client)
 {
 	struct cs42l56_private *cs42l56 = i2c_get_clientdata(client);
 
-	snd_soc_unregister_codec(&client->dev);
 	regulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),
 			       cs42l56->supplies);
 	return 0;

commit e8d8b98c0a6edab5d6cc0292e1ed603d8d4ff5b6
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Nov 23 09:33:15 2017 +0100

    ASoC: cs42l56: Improve two size determinations in cs42l56_i2c_probe()
    
    Replace the specification of two data structures by pointer dereferences
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 13ee46217d78..fd7b8d32c2b2 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -1190,9 +1190,7 @@ static int cs42l56_i2c_probe(struct i2c_client *i2c_client,
 	unsigned int alpha_rev, metal_rev;
 	unsigned int reg;
 
-	cs42l56 = devm_kzalloc(&i2c_client->dev,
-			       sizeof(struct cs42l56_private),
-			       GFP_KERNEL);
+	cs42l56 = devm_kzalloc(&i2c_client->dev, sizeof(*cs42l56), GFP_KERNEL);
 	if (cs42l56 == NULL)
 		return -ENOMEM;
 	cs42l56->dev = &i2c_client->dev;
@@ -1207,8 +1205,7 @@ static int cs42l56_i2c_probe(struct i2c_client *i2c_client,
 	if (pdata) {
 		cs42l56->pdata = *pdata;
 	} else {
-		pdata = devm_kzalloc(&i2c_client->dev,
-				     sizeof(struct cs42l56_platform_data),
+		pdata = devm_kzalloc(&i2c_client->dev, sizeof(*pdata),
 				     GFP_KERNEL);
 		if (!pdata)
 			return -ENOMEM;

commit 277631ccff503f2a8e8150574c9773a8383fc926
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Nov 23 09:26:08 2017 +0100

    ASoC: cs42l56: Delete an error message for a failed memory allocation in cs42l56_i2c_probe()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index cb6ca85f1536..13ee46217d78 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -1210,11 +1210,9 @@ static int cs42l56_i2c_probe(struct i2c_client *i2c_client,
 		pdata = devm_kzalloc(&i2c_client->dev,
 				     sizeof(struct cs42l56_platform_data),
 				     GFP_KERNEL);
-		if (!pdata) {
-			dev_err(&i2c_client->dev,
-				"could not allocate pdata\n");
+		if (!pdata)
 			return -ENOMEM;
-		}
+
 		if (i2c_client->dev.of_node) {
 			ret = cs42l56_handle_of_data(i2c_client,
 						     &cs42l56->pdata);

commit 8c317fafdd4e3b988c44d986022c66cebf71fc41
Author: Florian Vaussard <florian.vaussard@gmail.com>
Date:   Tue Nov 29 18:10:49 2016 +0100

    ASoC: cs42l56: Fix misuse of regmap_update_bits
    
    Using regmap_update_bits(..., mask, 1) with 'mask' following (1 << k)
    and k greater than 0 is wrong. Indeed, _regmap_update_bits will perform
    (mask & 1), which results in 0 if LSB of mask is 0. Thus the call
    regmap_update_bits(..., mask, 1) is in reality equivalent to
    regmap_update_bits(..., mask, 0).
    
    In such a case, the correct use is regmap_update_bits(..., mask, mask).
    
    This driver is performing such a mistake with the CS42L56_AIN*_REF_MASK
    masks, which equal 0x10, 0x20, 0x40 and 0x80. Fix the driver to make it
    consistent with the API. Please note that this change is untested,
    as I do not have this piece of hardware. Testers are welcome!
    
    Signed-off-by: Florian Vaussard <florian.vaussard@heig-vd.ch>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 3e2c04642f1e..cb6ca85f1536 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -1277,19 +1277,23 @@ static int cs42l56_i2c_probe(struct i2c_client *i2c_client,
 
 	if (cs42l56->pdata.ain1a_ref_cfg)
 		regmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,
-				   CS42L56_AIN1A_REF_MASK, 1);
+				   CS42L56_AIN1A_REF_MASK,
+				   CS42L56_AIN1A_REF_MASK);
 
 	if (cs42l56->pdata.ain1b_ref_cfg)
 		regmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,
-				   CS42L56_AIN1B_REF_MASK, 1);
+				   CS42L56_AIN1B_REF_MASK,
+				   CS42L56_AIN1B_REF_MASK);
 
 	if (cs42l56->pdata.ain2a_ref_cfg)
 		regmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,
-				   CS42L56_AIN2A_REF_MASK, 1);
+				   CS42L56_AIN2A_REF_MASK,
+				   CS42L56_AIN2A_REF_MASK);
 
 	if (cs42l56->pdata.ain2b_ref_cfg)
 		regmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,
-				   CS42L56_AIN2B_REF_MASK, 1);
+				   CS42L56_AIN2B_REF_MASK,
+				   CS42L56_AIN2B_REF_MASK);
 
 	if (cs42l56->pdata.micbias_lvl)
 		regmap_update_bits(cs42l56->regmap, CS42L56_GAIN_BIAS_CTL,

commit da5eb41763c750d1660ca0a962f15f268821b3e6
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Oct 25 16:42:30 2016 +0100

    ASoC: cs42l56: Make ID registers volatile and remove cache bypass
    
    Rather than manually enabling cache bypass when reading the ID registers
    simply remove the default which will cause the first read to go to the
    hardware. The old code worked this is simply the more standard way to
    implement this.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 54c1768bc818..3e2c04642f1e 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -64,8 +64,6 @@ struct  cs42l56_private {
 };
 
 static const struct reg_default cs42l56_reg_defaults[] = {
-	{ 1, 0x56 },	/* r01	- ID 1 */
-	{ 2, 0x04 },	/* r02	- ID 2 */
 	{ 3, 0x7f },	/* r03	- Power Ctl 1 */
 	{ 4, 0xff },	/* r04	- Power Ctl 2 */
 	{ 5, 0x00 },	/* ro5	- Clocking Ctl 1 */
@@ -1262,8 +1260,6 @@ static int cs42l56_i2c_probe(struct i2c_client *i2c_client,
 		return ret;
 	}
 
-	regcache_cache_bypass(cs42l56->regmap, true);
-
 	ret = regmap_read(cs42l56->regmap, CS42L56_CHIP_ID_1, &reg);
 	devid = reg & CS42L56_CHIP_ID_MASK;
 	if (devid != CS42L56_DEVID) {
@@ -1279,8 +1275,6 @@ static int cs42l56_i2c_probe(struct i2c_client *i2c_client,
 	dev_info(&i2c_client->dev, "Alpha Rev %X Metal Rev %X\n",
 		 alpha_rev, metal_rev);
 
-	regcache_cache_bypass(cs42l56->regmap, false);
-
 	if (cs42l56->pdata.ain1a_ref_cfg)
 		regmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,
 				   CS42L56_AIN1A_REF_MASK, 1);

commit 561828f821c95c73177e5291e5831b909b400450
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Aug 8 09:03:06 2016 +0000

    ASoC: codec duplicated callback function goes to component on cs42l56
    
    codec driver and component driver has duplicated callback functions,
    and codec side functions are just copied to component side when
    register timing. This was quick-hack, but no longer needed.
    This patch moves these functions from codec driver to component driver.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index eec1ff853b98..54c1768bc818 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -1121,13 +1121,14 @@ static const struct snd_soc_codec_driver soc_codec_dev_cs42l56 = {
 	.set_bias_level = cs42l56_set_bias_level,
 	.suspend_bias_off = true,
 
-	.dapm_widgets = cs42l56_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(cs42l56_dapm_widgets),
-	.dapm_routes = cs42l56_audio_map,
-	.num_dapm_routes = ARRAY_SIZE(cs42l56_audio_map),
-
-	.controls = cs42l56_snd_controls,
-	.num_controls = ARRAY_SIZE(cs42l56_snd_controls),
+	.component_driver = {
+		.controls		= cs42l56_snd_controls,
+		.num_controls		= ARRAY_SIZE(cs42l56_snd_controls),
+		.dapm_widgets		= cs42l56_dapm_widgets,
+		.num_dapm_widgets	= ARRAY_SIZE(cs42l56_dapm_widgets),
+		.dapm_routes		= cs42l56_audio_map,
+		.num_dapm_routes	= ARRAY_SIZE(cs42l56_audio_map),
+	},
 };
 
 static const struct regmap_config cs42l56_regmap = {

commit de06f22f717b30641229036439b804ae79a7ad4d
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Mon Apr 25 19:30:39 2016 -0400

    ASoC: cs42l56: Use IS_ENABLED() instead of checking for built-in or module
    
    The IS_ENABLED() macro checks if a Kconfig symbol has been enabled either
    built-in or as a module, use that macro instead of open coding the same.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 7cd5f769bb61..eec1ff853b98 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -56,7 +56,7 @@ struct  cs42l56_private {
 	u8 iface;
 	u8 iface_fmt;
 	u8 iface_inv;
-#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)
+#if IS_ENABLED(CONFIG_INPUT)
 	struct input_dev *beep;
 	struct work_struct beep_work;
 	int beep_rate;

commit 428157c1e8c9eaf0029430ae82ec0df8578de46b
Merge: 0a5ff077572d 82cf77a1bd61 9425e9d8c77d f57ddcdfa146 2e45a25f9cb6 1a3232d2f61d
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:57:34 2015 +0100

    Merge remote-tracking branches 'asoc/topic/tas2552', 'asoc/topic/tas5086', 'asoc/topic/tegra', 'asoc/topic/tlv' and 'asoc/topic/topology' into asoc-next

commit 399962239c07ab00adbfda72064b045c9c2c7b40
Merge: b18fec9fe428 7f325bfc933d fbf917e14eb6 f755d114cba9 a01da00cbccc
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:53:22 2015 +0100

    Merge remote-tracking branches 'asoc/topic/cs42l56', 'asoc/topic/cs42l73', 'asoc/topic/cs4349' and 'asoc/topic/da732x' into asoc-next

commit b18fec9fe42846784e1744e6bd6c754751e1d172
Merge: 48997b9c03a8 647930475587 c17633081a0d 80deaf09cb3f 4caae9546d2c
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:52:59 2015 +0100

    Merge remote-tracking branches 'asoc/topic/const', 'asoc/topic/cs35l32', 'asoc/topic/cs4265' and 'asoc/topic/cs42l52' into asoc-next

commit 7f325bfc933d140337e55507821d6bb021321059
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Aug 12 11:09:39 2015 +0800

    ASoC: cs42l56: Use case range at appropriate place
    
    The readable registers are in continuous range: 0x01 ~ 0x2e.
    Use case range syntax makes the code shorter with better readability when
    we have a large number of continuous switch cases.
    No functional change with this patch.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 1e11ba45a79f..98a68c66cf71 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -115,52 +115,7 @@ static const struct reg_default cs42l56_reg_defaults[] = {
 static bool cs42l56_readable_register(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
-	case CS42L56_CHIP_ID_1:
-	case CS42L56_CHIP_ID_2:
-	case CS42L56_PWRCTL_1:
-	case CS42L56_PWRCTL_2:
-	case CS42L56_CLKCTL_1:
-	case CS42L56_CLKCTL_2:
-	case CS42L56_SERIAL_FMT:
-	case CS42L56_CLASSH_CTL:
-	case CS42L56_MISC_CTL:
-	case CS42L56_INT_STATUS:
-	case CS42L56_PLAYBACK_CTL:
-	case CS42L56_DSP_MUTE_CTL:
-	case CS42L56_ADCA_MIX_VOLUME:
-	case CS42L56_ADCB_MIX_VOLUME:
-	case CS42L56_PCMA_MIX_VOLUME:
-	case CS42L56_PCMB_MIX_VOLUME:
-	case CS42L56_ANAINPUT_ADV_VOLUME:
-	case CS42L56_DIGINPUT_ADV_VOLUME:
-	case CS42L56_MASTER_A_VOLUME:
-	case CS42L56_MASTER_B_VOLUME:
-	case CS42L56_BEEP_FREQ_ONTIME:
-	case CS42L56_BEEP_FREQ_OFFTIME:
-	case CS42L56_BEEP_TONE_CFG:
-	case CS42L56_TONE_CTL:
-	case CS42L56_CHAN_MIX_SWAP:
-	case CS42L56_AIN_REFCFG_ADC_MUX:
-	case CS42L56_HPF_CTL:
-	case CS42L56_MISC_ADC_CTL:
-	case CS42L56_GAIN_BIAS_CTL:
-	case CS42L56_PGAA_MUX_VOLUME:
-	case CS42L56_PGAB_MUX_VOLUME:
-	case CS42L56_ADCA_ATTENUATOR:
-	case CS42L56_ADCB_ATTENUATOR:
-	case CS42L56_ALC_EN_ATTACK_RATE:
-	case CS42L56_ALC_RELEASE_RATE:
-	case CS42L56_ALC_THRESHOLD:
-	case CS42L56_NOISE_GATE_CTL:
-	case CS42L56_ALC_LIM_SFT_ZC:
-	case CS42L56_AMUTE_HPLO_MUX:
-	case CS42L56_HPA_VOLUME:
-	case CS42L56_HPB_VOLUME:
-	case CS42L56_LOA_VOLUME:
-	case CS42L56_LOB_VOLUME:
-	case CS42L56_LIM_THRESHOLD_CTL:
-	case CS42L56_LIM_CTL_RELEASE_RATE:
-	case CS42L56_LIM_ATTACK_RATE:
+	case CS42L56_CHIP_ID_1 ... CS42L56_LIM_ATTACK_RATE:
 		return true;
 	default:
 		return false;

commit 37879bafc2e0932279ad440d5a81c323e0c5c58c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Aug 2 17:19:35 2015 +0200

    ASoC: cs42l56: Replace TLV_DB_RANGE_HEAD with DECLARE_TLV_DB_RANGE
    
    DECLARE_TLV_DB_RANGE() has the advantage over using TLV_DB_RANGE_HEAD()
    that it automatically calculates the number of items in the TLV and is
    hence less prone to manual error.
    
    Generate using the following coccinelle script
    
    // <smpl>
    @@
    declarer name DECLARE_TLV_DB_RANGE;
    identifier tlv;
    constant x;
    @@
    -unsigned int tlv[] = {
    -       TLV_DB_RANGE_HEAD(x),
    +DECLARE_TLV_DB_RANGE(tlv,
            ...
    -};
    +);
    // </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 1e11ba45a79f..e88a559e04b9 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -185,21 +185,18 @@ static DECLARE_TLV_DB_SCALE(tone_tlv, -1050, 150, 0);
 static DECLARE_TLV_DB_SCALE(preamp_tlv, 0, 1000, 0);
 static DECLARE_TLV_DB_SCALE(pga_tlv, -600, 50, 0);
 
-static const unsigned int ngnb_tlv[] = {
-	TLV_DB_RANGE_HEAD(2),
+static const DECLARE_TLV_DB_RANGE(ngnb_tlv,
 	0, 1, TLV_DB_SCALE_ITEM(-8200, 600, 0),
-	2, 5, TLV_DB_SCALE_ITEM(-7600, 300, 0),
-};
-static const unsigned int ngb_tlv[] = {
-	TLV_DB_RANGE_HEAD(2),
+	2, 5, TLV_DB_SCALE_ITEM(-7600, 300, 0)
+);
+static const DECLARE_TLV_DB_RANGE(ngb_tlv,
 	0, 2, TLV_DB_SCALE_ITEM(-6400, 600, 0),
-	3, 7, TLV_DB_SCALE_ITEM(-4600, 300, 0),
-};
-static const unsigned int alc_tlv[] = {
-	TLV_DB_RANGE_HEAD(2),
+	3, 7, TLV_DB_SCALE_ITEM(-4600, 300, 0)
+);
+static const DECLARE_TLV_DB_RANGE(alc_tlv,
 	0, 2, TLV_DB_SCALE_ITEM(-3000, 600, 0),
-	3, 7, TLV_DB_SCALE_ITEM(-1200, 300, 0),
-};
+	3, 7, TLV_DB_SCALE_ITEM(-1200, 300, 0)
+);
 
 static const char * const beep_config_text[] = {
 	"Off", "Single", "Multiple", "Continuous"

commit 1c07a4de5baad76585f7ffb86b5b0bc34c33e8a6
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Wed Jul 15 13:21:44 2015 +0900

    ASoC: drivers: Drop owner assignment from i2c_driver
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 1e11ba45a79f..4ae793365985 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -1408,7 +1408,6 @@ MODULE_DEVICE_TABLE(i2c, cs42l56_id);
 static struct i2c_driver cs42l56_i2c_driver = {
 	.driver = {
 		.name = "cs42l56",
-		.owner = THIS_MODULE,
 		.of_match_table = cs42l56_of_match,
 	},
 	.id_table = cs42l56_id,

commit 64793047558781330a1d13b159a2bc9385bdf97f
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Jul 15 15:38:14 2015 +0800

    ASoC: Constify snd_soc_dai_ops variables
    
    The snd_soc_dai_ops variables are not modified after initialization in
    these drivers, so make them const.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 1e11ba45a79f..22bc2f3460a5 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -989,7 +989,7 @@ static int cs42l56_set_bias_level(struct snd_soc_codec *codec,
 			SNDRV_PCM_FMTBIT_S32_LE)
 
 
-static struct snd_soc_dai_ops cs42l56_ops = {
+static const struct snd_soc_dai_ops cs42l56_ops = {
 	.hw_params	= cs42l56_pcm_hw_params,
 	.digital_mute	= cs42l56_digital_mute,
 	.set_fmt	= cs42l56_set_dai_fmt,

commit 46a35b0d4d26090aedc0e72ac701d0f5304e29a0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 1 10:10:21 2015 +0200

    ASoC: cs42l56: Replace direct snd_soc_codec dapm field access
    
    The dapm field of the snd_soc_codec struct is eventually going to be
    removed, in preparation for this replace all manual access to
    codec->dapm.bias_level with snd_soc_codec_get_bias_level() and replace all
    other manual access to codec->dapm with snd_soc_codec_get_dapm().
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index a7638c52b509..1e11ba45a79f 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -953,7 +953,7 @@ static int cs42l56_set_bias_level(struct snd_soc_codec *codec,
 				    CS42L56_PDN_ALL_MASK, 0);
 		break;
 	case SND_SOC_BIAS_STANDBY:
-		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
 			regcache_cache_only(cs42l56->regmap, false);
 			regcache_sync(cs42l56->regmap);
 			ret = regulator_bulk_enable(ARRAY_SIZE(cs42l56->supplies),
@@ -1025,7 +1025,7 @@ static void cs42l56_beep_work(struct work_struct *work)
 	struct cs42l56_private *cs42l56 =
 		container_of(work, struct cs42l56_private, beep_work);
 	struct snd_soc_codec *codec = cs42l56->codec;
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
 	int i;
 	int val = 0;
 	int best = 0;

commit f4bf8d770b58862c2af9d17adc2fee05bef8f2c0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 27 22:13:25 2015 +0200

    ASoC: Move bias level update to the core
    
    All drivers have the same line at the end of the set_bias_level callback to
    update the bias_level state. Move this update into
    snd_soc_dapm_force_bias_level() and remove them from the drivers.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index cbc654fe48c7..a7638c52b509 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -978,7 +978,6 @@ static int cs42l56_set_bias_level(struct snd_soc_codec *codec,
 						    cs42l56->supplies);
 		break;
 	}
-	codec->dapm.bias_level = level;
 
 	return 0;
 }

commit cf0efa1c71c86b3ba731b9f3bad37ea4ceee6fbe
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Jan 5 10:18:24 2015 +0100

    ASoC: cs42l56: Constify struct regmap_config and snd_soc_codec_driver
    
    The regmap_config struct may be const because it is not modified by the
    driver and regmap_init() accepts pointer to const. Make struct
    snd_soc_codec_driver const as well (snd_soc_register_codec() accepts
    pointer to const).
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 2ddc7ac10ad7..cbc654fe48c7 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -1164,7 +1164,7 @@ static int cs42l56_remove(struct snd_soc_codec *codec)
 	return 0;
 }
 
-static struct snd_soc_codec_driver soc_codec_dev_cs42l56 = {
+static const struct snd_soc_codec_driver soc_codec_dev_cs42l56 = {
 	.probe = cs42l56_probe,
 	.remove = cs42l56_remove,
 	.set_bias_level = cs42l56_set_bias_level,
@@ -1179,7 +1179,7 @@ static struct snd_soc_codec_driver soc_codec_dev_cs42l56 = {
 	.num_controls = ARRAY_SIZE(cs42l56_snd_controls),
 };
 
-static struct regmap_config cs42l56_regmap = {
+static const struct regmap_config cs42l56_regmap = {
 	.reg_bits = 8,
 	.val_bits = 8,
 

commit 2a4bc751fcc50c15bd4782cfc2ea513bef92a20f
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Sep 9 20:42:41 2014 +0200

    ASoC: cs42l56: Cleanup manual bias level transitions
    
    Set the CODEC driver's suspend_bias_off flag rather than manually going to
    SND_SOC_BIAS_OFF in suspend and SND_SOC_BIAS_STANDBY in resume. This makes
    the code a bit shorter and cleaner.
    
    Since the ASoC core now takes care of setting the bias level to
    SND_SOC_BIAS_OFF when removing the CODEC there is no need to do it manually
    anymore either.
    
    The manual transition to SND_SOC_BIAS_STANDBY at the end of CODEC probe()
    can also be removed as the core will automatically do this after the CODEC
    has been probed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index bb74dd17fa26..2ddc7ac10ad7 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -1016,20 +1016,6 @@ static struct snd_soc_dai_driver cs42l56_dai = {
 		.ops = &cs42l56_ops,
 };
 
-static int cs42l56_suspend(struct snd_soc_codec *codec)
-{
-	cs42l56_set_bias_level(codec, SND_SOC_BIAS_OFF);
-
-	return 0;
-}
-
-static int cs42l56_resume(struct snd_soc_codec *codec)
-{
-	cs42l56_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-
-	return 0;
-}
-
 static int beep_freq[] = {
 	261, 522, 585, 667, 706, 774, 889, 1000,
 	1043, 1200, 1333, 1412, 1600, 1714, 2000, 2182
@@ -1168,15 +1154,12 @@ static int cs42l56_probe(struct snd_soc_codec *codec)
 {
 	cs42l56_init_beep(codec);
 
-	cs42l56_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
-
 	return 0;
 }
 
 static int cs42l56_remove(struct snd_soc_codec *codec)
 {
 	cs42l56_free_beep(codec);
-	cs42l56_set_bias_level(codec, SND_SOC_BIAS_OFF);
 
 	return 0;
 }
@@ -1184,9 +1167,8 @@ static int cs42l56_remove(struct snd_soc_codec *codec)
 static struct snd_soc_codec_driver soc_codec_dev_cs42l56 = {
 	.probe = cs42l56_probe,
 	.remove = cs42l56_remove,
-	.suspend = cs42l56_suspend,
-	.resume = cs42l56_resume,
 	.set_bias_level = cs42l56_set_bias_level,
+	.suspend_bias_off = true,
 
 	.dapm_widgets = cs42l56_dapm_widgets,
 	.num_dapm_widgets = ARRAY_SIZE(cs42l56_dapm_widgets),

commit a4f87cea72d78f80c0bda1b4d8a821278eb1e4e2
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Aug 28 17:55:20 2014 +0800

    ASoC: cs42l56: Remove unneeded regulator_bulk_free call in cs42l56_remove
    
    The regulator_bulk_free() call is not required because current code is using
    devm_regulator_bulk_get().
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index b1c7396c80c8..bb74dd17fa26 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -1175,11 +1175,8 @@ static int cs42l56_probe(struct snd_soc_codec *codec)
 
 static int cs42l56_remove(struct snd_soc_codec *codec)
 {
-	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
-
 	cs42l56_free_beep(codec);
 	cs42l56_set_bias_level(codec, SND_SOC_BIAS_OFF);
-	regulator_bulk_free(ARRAY_SIZE(cs42l56->supplies), cs42l56->supplies);
 
 	return 0;
 }

commit c2b49ae678b8bd1fd4ea3e3ae106020d663e8969
Author: Brian Austin <brian.austin@cirrus.com>
Date:   Thu Aug 28 10:02:42 2014 -0500

    ASoC: cs42l56: use true/false returns for bool functions
    
    Return true or false instead of 1 and 0
    
    Signed-off-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index c766a5a9ce80..b1c7396c80c8 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -171,9 +171,9 @@ static bool cs42l56_volatile_register(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
 	case CS42L56_INT_STATUS:
-		return 1;
+		return true;
 	default:
-		return 0;
+		return false;
 	}
 }
 

commit 01954a7b67021e5899dd85946ffe7609afbaa069
Merge: 62e951ea6516 12efd9f4b751 c4324bfa54d2 689dc6438599 aaed2a62c289 37119dd791f3
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Aug 4 16:31:33 2014 +0100

    Merge remote-tracking branches 'asoc/topic/cs4265', 'asoc/topic/cs42l56', 'asoc/topic/cs42xx8', 'asoc/topic/cx20442' and 'asoc/topic/davinci' into asoc-next

commit a046558719770f94d8660f77654ce9cc712ffe54
Author: Brian Austin <brian.austin@cirrus.com>
Date:   Thu Jul 17 13:16:55 2014 -0500

    ASoC: Fix SOC_DOUBLE_R_SX_TLV volume mixer arguments
    
    Remove unnecessary bit shifts.
    Correct min value to match datasheet.
    Num steps = number of steps between min and max.
    
    Reported-by: Ryan Harvey <ryan.harvey@cirrus.com>
    Signed-off-by: Ryan Harvey <ryan.harvey@cirrus.com>
    Signed-off-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 8e68ef5de849..24fbffee09ea 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -421,15 +421,15 @@ static const struct soc_enum ng_delay_enum =
 static const struct snd_kcontrol_new cs42l56_snd_controls[] = {
 
 	SOC_DOUBLE_R_SX_TLV("Master Volume", CS42L56_MASTER_A_VOLUME,
-			      CS42L56_MASTER_B_VOLUME, 0, 0x34, 0xfd, adv_tlv),
+			      CS42L56_MASTER_B_VOLUME, 0, 0x34, 0xE4, adv_tlv),
 	SOC_DOUBLE("Master Mute Switch", CS42L56_DSP_MUTE_CTL, 0, 1, 1, 1),
 
 	SOC_DOUBLE_R_SX_TLV("ADC Mixer Volume", CS42L56_ADCA_MIX_VOLUME,
-			      CS42L56_ADCB_MIX_VOLUME, 0, 0x88, 0xa9, hl_tlv),
+			      CS42L56_ADCB_MIX_VOLUME, 0, 0x88, 0x90, hl_tlv),
 	SOC_DOUBLE("ADC Mixer Mute Switch", CS42L56_DSP_MUTE_CTL, 6, 7, 1, 1),
 
 	SOC_DOUBLE_R_SX_TLV("PCM Mixer Volume", CS42L56_PCMA_MIX_VOLUME,
-			      CS42L56_PCMB_MIX_VOLUME, 0, 0x88, 0xa9, hl_tlv),
+			      CS42L56_PCMB_MIX_VOLUME, 0, 0x88, 0x90, hl_tlv),
 	SOC_DOUBLE("PCM Mixer Mute Switch", CS42L56_DSP_MUTE_CTL, 4, 5, 1, 1),
 
 	SOC_SINGLE_TLV("Analog Advisory Volume",
@@ -438,16 +438,16 @@ static const struct snd_kcontrol_new cs42l56_snd_controls[] = {
 			  CS42L56_DIGINPUT_ADV_VOLUME, 0, 0x00, 1, adv_tlv),
 
 	SOC_DOUBLE_R_SX_TLV("PGA Volume", CS42L56_PGAA_MUX_VOLUME,
-			      CS42L56_PGAB_MUX_VOLUME, 0, 0x34, 0xfd, pga_tlv),
+			      CS42L56_PGAB_MUX_VOLUME, 0, 0x34, 0x24, pga_tlv),
 	SOC_DOUBLE_R_TLV("ADC Volume", CS42L56_ADCA_ATTENUATOR,
 			      CS42L56_ADCB_ATTENUATOR, 0, 0x00, 1, adc_tlv),
 	SOC_DOUBLE("ADC Mute Switch", CS42L56_MISC_ADC_CTL, 2, 3, 1, 1),
 	SOC_DOUBLE("ADC Boost Switch", CS42L56_GAIN_BIAS_CTL, 3, 2, 1, 1),
 
 	SOC_DOUBLE_R_SX_TLV("Headphone Volume", CS42L56_HPA_VOLUME,
-			      CS42L56_HPB_VOLUME, 0, 0x44, 0x55, hl_tlv),
+			      CS42L56_HPB_VOLUME, 0, 0x84, 0x48, hl_tlv),
 	SOC_DOUBLE_R_SX_TLV("LineOut Volume", CS42L56_LOA_VOLUME,
-			      CS42L56_LOB_VOLUME, 0, 0x44, 0x55, hl_tlv),
+			      CS42L56_LOB_VOLUME, 0, 0x84, 0x48, hl_tlv),
 
 	SOC_SINGLE_TLV("Bass Shelving Volume", CS42L56_TONE_CTL,
 			0, 0x00, 1, tone_tlv),

commit 95b47f8de787214f7db88b26759d7edc7c64d74a
Author: Brian Austin <brian.austin@cirrus.com>
Date:   Thu Jul 17 13:16:54 2014 -0500

    ASoC: cs42l56: Fix stereo channel register assignment for Headphone and LineOut volume mixers
    
    Stereo Headphone and LineOut volume mixers are now attached to HPA+HPB, LOA+LOB.
    
    Reported-by: Ryan Harvey <ryan.harvey@cirrus.com>
    Signed-off-by: Ryan Harvey <ryan.harvey@cirrus.com>
    Signed-off-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index fdc4bd27b0df..8e68ef5de849 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -445,9 +445,9 @@ static const struct snd_kcontrol_new cs42l56_snd_controls[] = {
 	SOC_DOUBLE("ADC Boost Switch", CS42L56_GAIN_BIAS_CTL, 3, 2, 1, 1),
 
 	SOC_DOUBLE_R_SX_TLV("Headphone Volume", CS42L56_HPA_VOLUME,
-			      CS42L56_HPA_VOLUME, 0, 0x44, 0x55, hl_tlv),
+			      CS42L56_HPB_VOLUME, 0, 0x44, 0x55, hl_tlv),
 	SOC_DOUBLE_R_SX_TLV("LineOut Volume", CS42L56_LOA_VOLUME,
-			      CS42L56_LOA_VOLUME, 0, 0x44, 0x55, hl_tlv),
+			      CS42L56_LOB_VOLUME, 0, 0x44, 0x55, hl_tlv),
 
 	SOC_SINGLE_TLV("Bass Shelving Volume", CS42L56_TONE_CTL,
 			0, 0x00, 1, tone_tlv),

commit c4324bfa54d2a59b4920239c1b10b3e5f3a851d3
Author: Brian Austin <brian.austin@cirrus.com>
Date:   Tue Jul 8 09:56:35 2014 -0500

    ASoC: cs42l56: Move ADC/PCM Swap to DAPM
    
    The Swap controls for ADC/PCM paths should be in the DAPM domain.
    
    Signed-off-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index fdc4bd27b0df..e5ef223be86c 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -318,24 +318,32 @@ static const struct soc_enum adca_swap_enum =
 			      ARRAY_SIZE(left_swap_text),
 			      left_swap_text,
 			      swap_values);
+static const struct snd_kcontrol_new adca_swap_mux =
+	SOC_DAPM_ENUM("Route", adca_swap_enum);
 
 static const struct soc_enum pcma_swap_enum =
 	SOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 4, 3,
 			      ARRAY_SIZE(left_swap_text),
 			      left_swap_text,
 			      swap_values);
+static const struct snd_kcontrol_new pcma_swap_mux =
+	SOC_DAPM_ENUM("Route", pcma_swap_enum);
 
 static const struct soc_enum adcb_swap_enum =
 	SOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 2, 3,
 			      ARRAY_SIZE(right_swap_text),
 			      right_swap_text,
 			      swap_values);
+static const struct snd_kcontrol_new adcb_swap_mux =
+	SOC_DAPM_ENUM("Route", adcb_swap_enum);
 
 static const struct soc_enum pcmb_swap_enum =
 	SOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 6, 3,
 			      ARRAY_SIZE(right_swap_text),
 			      right_swap_text,
 			      swap_values);
+static const struct snd_kcontrol_new pcmb_swap_mux =
+	SOC_DAPM_ENUM("Route", pcmb_swap_enum);
 
 static const struct snd_kcontrol_new hpa_switch =
 	SOC_DAPM_SINGLE("Switch", CS42L56_PWRCTL_2, 6, 1, 1);
@@ -467,11 +475,6 @@ static const struct snd_kcontrol_new cs42l56_snd_controls[] = {
 	SOC_SINGLE("ADCA Invert", CS42L56_MISC_ADC_CTL, 2, 1, 1),
 	SOC_SINGLE("ADCB Invert", CS42L56_MISC_ADC_CTL, 3, 1, 1),
 
-	SOC_ENUM("PCMA Swap", pcma_swap_enum),
-	SOC_ENUM("PCMB Swap", pcmb_swap_enum),
-	SOC_ENUM("ADCA Swap", adca_swap_enum),
-	SOC_ENUM("ADCB Swap", adcb_swap_enum),
-
 	SOC_DOUBLE("HPF Switch", CS42L56_HPF_CTL, 5, 7, 1, 1),
 	SOC_DOUBLE("HPF Freeze Switch", CS42L56_HPF_CTL, 4, 6, 1, 1),
 	SOC_ENUM("HPFA Corner Freq", hpfa_freq_enum),
@@ -570,6 +573,16 @@ static const struct snd_soc_dapm_widget cs42l56_dapm_widgets[] = {
 	SND_SOC_DAPM_ADC("ADCA", NULL, CS42L56_PWRCTL_1, 1, 1),
 	SND_SOC_DAPM_ADC("ADCB", NULL, CS42L56_PWRCTL_1, 2, 1),
 
+	SND_SOC_DAPM_MUX("ADCA Swap Mux", SND_SOC_NOPM, 0, 0,
+		&adca_swap_mux),
+	SND_SOC_DAPM_MUX("ADCB Swap Mux", SND_SOC_NOPM, 0, 0,
+		&adcb_swap_mux),
+
+	SND_SOC_DAPM_MUX("PCMA Swap Mux", SND_SOC_NOPM, 0, 0,
+		&pcma_swap_mux),
+	SND_SOC_DAPM_MUX("PCMB Swap Mux", SND_SOC_NOPM, 0, 0,
+		&pcmb_swap_mux),
+
 	SND_SOC_DAPM_DAC("DACA", NULL, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_DAC("DACB", NULL, SND_SOC_NOPM, 0, 0),
 
@@ -607,8 +620,19 @@ static const struct snd_soc_dapm_route cs42l56_audio_map[] = {
 	{"Digital Output Mux", NULL, "ADCA"},
 	{"Digital Output Mux", NULL, "ADCB"},
 
-	{"ADCB", NULL, "ADCB Mux"},
-	{"ADCA", NULL, "ADCA Mux"},
+	{"ADCB", NULL, "ADCB Swap Mux"},
+	{"ADCA", NULL, "ADCA Swap Mux"},
+
+	{"ADCA Swap Mux", NULL, "ADCA"},
+	{"ADCB Swap Mux", NULL, "ADCB"},
+
+	{"DACA", "Left", "ADCA Swap Mux"},
+	{"DACA", "LR 2", "ADCA Swap Mux"},
+	{"DACA", "Right", "ADCA Swap Mux"},
+
+	{"DACB", "Left", "ADCB Swap Mux"},
+	{"DACB", "LR 2", "ADCB Swap Mux"},
+	{"DACB", "Right", "ADCB Swap Mux"},
 
 	{"ADCA Mux", NULL, "AIN3A"},
 	{"ADCA Mux", NULL, "AIN2A"},
@@ -633,30 +657,32 @@ static const struct snd_soc_dapm_route cs42l56_audio_map[] = {
 	{"PGAB Input Mux", NULL, "AIN2B"},
 	{"PGAB Input Mux", NULL, "AIN3B"},
 
-	{"LOB", NULL, "Lineout Right"},
-	{"LOA", NULL, "Lineout Left"},
-
-	{"Lineout Right", "Switch", "LINEOUTB Input Mux"},
-	{"Lineout Left", "Switch", "LINEOUTA Input Mux"},
+	{"LOB", "Switch", "LINEOUTB Input Mux"},
+	{"LOA", "Switch", "LINEOUTA Input Mux"},
 
 	{"LINEOUTA Input Mux", "PGAA", "PGAA"},
 	{"LINEOUTB Input Mux", "PGAB", "PGAB"},
 	{"LINEOUTA Input Mux", "DACA", "DACA"},
 	{"LINEOUTB Input Mux", "DACB", "DACB"},
 
-	{"HPA", NULL, "Headphone Left"},
-	{"HPB", NULL, "Headphone Right"},
-
-	{"Headphone Right", "Switch", "HPB Input Mux"},
-	{"Headphone Left", "Switch", "HPA Input Mux"},
+	{"HPA", "Switch", "HPB Input Mux"},
+	{"HPB", "Switch", "HPA Input Mux"},
 
 	{"HPA Input Mux", "PGAA", "PGAA"},
 	{"HPB Input Mux", "PGAB", "PGAB"},
 	{"HPA Input Mux", "DACA", "DACA"},
 	{"HPB Input Mux", "DACB", "DACB"},
 
-	{"DACB", NULL, "HiFi Playback"},
-	{"DACA", NULL, "HiFi Playback"},
+	{"DACA", NULL, "PCMA Swap Mux"},
+	{"DACB", NULL, "PCMB Swap Mux"},
+
+	{"PCMB Swap Mux", "Left", "HiFi Playback"},
+	{"PCMB Swap Mux", "LR 2", "HiFi Playback"},
+	{"PCMB Swap Mux", "Right", "HiFi Playback"},
+
+	{"PCMA Swap Mux", "Left", "HiFi Playback"},
+	{"PCMA Swap Mux", "LR 2", "HiFi Playback"},
+	{"PCMA Swap Mux", "Right", "HiFi Playback"},
 
 };
 

commit 4641c771b67e0d1df9395ed789c618dcfbc62709
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri May 23 13:05:31 2014 +0800

    ASoC: cs42l56: Fix new value argument in snd_soc_update_bits calls
    
    The new value argument needs proper shift to match the mask bit fields.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Tested-by: Brian Austin <brian.austin@cirrus.com>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
index 5bb134b4ab9b..fdc4bd27b0df 100644
--- a/sound/soc/codecs/cs42l56.c
+++ b/sound/soc/codecs/cs42l56.c
@@ -763,14 +763,14 @@ static int cs42l56_set_sysclk(struct snd_soc_dai *codec_dai,
 	case CS42L56_MCLK_11P2896MHZ:
 	case CS42L56_MCLK_12MHZ:
 	case CS42L56_MCLK_12P288MHZ:
-		cs42l56->mclk_div2 = 1;
+		cs42l56->mclk_div2 = CS42L56_MCLK_DIV2;
 		cs42l56->mclk_prediv = 0;
 		break;
 	case CS42L56_MCLK_22P5792MHZ:
 	case CS42L56_MCLK_24MHZ:
 	case CS42L56_MCLK_24P576MHZ:
-		cs42l56->mclk_div2 = 1;
-		cs42l56->mclk_prediv = 1;
+		cs42l56->mclk_div2 = CS42L56_MCLK_DIV2;
+		cs42l56->mclk_prediv = CS42L56_MCLK_PREDIV;
 		break;
 	default:
 		return -EINVAL;
@@ -844,57 +844,49 @@ static int cs42l56_digital_mute(struct snd_soc_dai *dai, int mute)
 		/* Hit the DSP Mixer first */
 		snd_soc_update_bits(codec, CS42L56_DSP_MUTE_CTL,
 				    CS42L56_ADCAMIX_MUTE_MASK |
-				CS42L56_ADCBMIX_MUTE_MASK |
-				CS42L56_PCMAMIX_MUTE_MASK |
-				CS42L56_PCMBMIX_MUTE_MASK |
-				CS42L56_MSTB_MUTE_MASK |
-				CS42L56_MSTA_MUTE_MASK,
-				CS42L56_MUTE);
+				    CS42L56_ADCBMIX_MUTE_MASK |
+				    CS42L56_PCMAMIX_MUTE_MASK |
+				    CS42L56_PCMBMIX_MUTE_MASK |
+				    CS42L56_MSTB_MUTE_MASK |
+				    CS42L56_MSTA_MUTE_MASK,
+				    CS42L56_MUTE_ALL);
 		/* Mute ADC's */
 		snd_soc_update_bits(codec, CS42L56_MISC_ADC_CTL,
-				CS42L56_ADCA_MUTE_MASK |
-				CS42L56_ADCB_MUTE_MASK,
-				CS42L56_MUTE);
+				    CS42L56_ADCA_MUTE_MASK |
+				    CS42L56_ADCB_MUTE_MASK,
+				    CS42L56_MUTE_ALL);
 		/* HP And LO */
 		snd_soc_update_bits(codec, CS42L56_HPA_VOLUME,
-				CS42L56_HP_MUTE_MASK,
-				CS42L56_MUTE);
+				    CS42L56_HP_MUTE_MASK, CS42L56_MUTE_ALL);
 		snd_soc_update_bits(codec, CS42L56_HPB_VOLUME,
-				CS42L56_HP_MUTE_MASK,
-				CS42L56_MUTE);
+				    CS42L56_HP_MUTE_MASK, CS42L56_MUTE_ALL);
 		snd_soc_update_bits(codec, CS42L56_LOA_VOLUME,
-				CS42L56_LO_MUTE_MASK,
-				CS42L56_MUTE);
+				    CS42L56_LO_MUTE_MASK, CS42L56_MUTE_ALL);
 		snd_soc_update_bits(codec, CS42L56_LOB_VOLUME,
-				CS42L56_LO_MUTE_MASK,
-				CS42L56_MUTE);
-
-
+				    CS42L56_LO_MUTE_MASK, CS42L56_MUTE_ALL);
 	} else {
 		snd_soc_update_bits(codec, CS42L56_DSP_MUTE_CTL,
 				    CS42L56_ADCAMIX_MUTE_MASK |
-				CS42L56_ADCBMIX_MUTE_MASK |
-				CS42L56_PCMAMIX_MUTE_MASK |
-				CS42L56_PCMBMIX_MUTE_MASK |
-				CS42L56_MSTB_MUTE_MASK |
-				CS42L56_MSTA_MUTE_MASK,
-				CS42L56_UNMUTE);
+				    CS42L56_ADCBMIX_MUTE_MASK |
+				    CS42L56_PCMAMIX_MUTE_MASK |
+				    CS42L56_PCMBMIX_MUTE_MASK |
+				    CS42L56_MSTB_MUTE_MASK |
+				    CS42L56_MSTA_MUTE_MASK,
+				    CS42L56_UNMUTE);
+
 		snd_soc_update_bits(codec, CS42L56_MISC_ADC_CTL,
-				CS42L56_ADCA_MUTE_MASK |
-				CS42L56_ADCB_MUTE_MASK,
-				CS42L56_UNMUTE);
+				    CS42L56_ADCA_MUTE_MASK |
+				    CS42L56_ADCB_MUTE_MASK,
+				    CS42L56_UNMUTE);
+
 		snd_soc_update_bits(codec, CS42L56_HPA_VOLUME,
-				CS42L56_HP_MUTE_MASK,
-				CS42L56_UNMUTE);
+				    CS42L56_HP_MUTE_MASK, CS42L56_UNMUTE);
 		snd_soc_update_bits(codec, CS42L56_HPB_VOLUME,
-				CS42L56_HP_MUTE_MASK,
-				CS42L56_UNMUTE);
+				    CS42L56_HP_MUTE_MASK, CS42L56_UNMUTE);
 		snd_soc_update_bits(codec, CS42L56_LOA_VOLUME,
-				CS42L56_LO_MUTE_MASK,
-				CS42L56_UNMUTE);
+				    CS42L56_LO_MUTE_MASK, CS42L56_UNMUTE);
 		snd_soc_update_bits(codec, CS42L56_LOB_VOLUME,
-				CS42L56_LO_MUTE_MASK,
-				CS42L56_UNMUTE);
+				    CS42L56_LO_MUTE_MASK, CS42L56_UNMUTE);
 	}
 	return 0;
 }

commit 272b5edd3b8fe51d4e22fbea996a8d6560b8d048
Author: Brian Austin <brian.austin@cirrus.com>
Date:   Mon May 5 15:09:08 2014 -0500

    ASoC: Add support for CS42L56 CODEC
    
    This patch adds support for the Cirrus Logic Low Power Stereo I2C CODEC
    
    Signed-off-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/cs42l56.c b/sound/soc/codecs/cs42l56.c
new file mode 100644
index 000000000000..5bb134b4ab9b
--- /dev/null
+++ b/sound/soc/codecs/cs42l56.c
@@ -0,0 +1,1427 @@
+/*
+ * cs42l56.c -- CS42L56 ALSA SoC audio driver
+ *
+ * Copyright 2014 CirrusLogic, Inc.
+ *
+ * Author: Brian Austin <brian.austin@cirrus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <sound/cs42l56.h>
+#include "cs42l56.h"
+
+#define CS42L56_NUM_SUPPLIES 3
+static const char *const cs42l56_supply_names[CS42L56_NUM_SUPPLIES] = {
+	"VA",
+	"VCP",
+	"VLDO",
+};
+
+struct  cs42l56_private {
+	struct regmap *regmap;
+	struct snd_soc_codec *codec;
+	struct device *dev;
+	struct cs42l56_platform_data pdata;
+	struct regulator_bulk_data supplies[CS42L56_NUM_SUPPLIES];
+	u32 mclk;
+	u8 mclk_prediv;
+	u8 mclk_div2;
+	u8 mclk_ratio;
+	u8 iface;
+	u8 iface_fmt;
+	u8 iface_inv;
+#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)
+	struct input_dev *beep;
+	struct work_struct beep_work;
+	int beep_rate;
+#endif
+};
+
+static const struct reg_default cs42l56_reg_defaults[] = {
+	{ 1, 0x56 },	/* r01	- ID 1 */
+	{ 2, 0x04 },	/* r02	- ID 2 */
+	{ 3, 0x7f },	/* r03	- Power Ctl 1 */
+	{ 4, 0xff },	/* r04	- Power Ctl 2 */
+	{ 5, 0x00 },	/* ro5	- Clocking Ctl 1 */
+	{ 6, 0x0b },	/* r06	- Clocking Ctl 2 */
+	{ 7, 0x00 },	/* r07	- Serial Format */
+	{ 8, 0x05 },	/* r08	- Class H Ctl */
+	{ 9, 0x0c },	/* r09	- Misc Ctl */
+	{ 10, 0x80 },	/* r0a	- INT Status */
+	{ 11, 0x00 },	/* r0b	- Playback Ctl */
+	{ 12, 0x0c },	/* r0c	- DSP Mute Ctl */
+	{ 13, 0x00 },	/* r0d	- ADCA Mixer Volume */
+	{ 14, 0x00 },	/* r0e	- ADCB Mixer Volume */
+	{ 15, 0x00 },	/* r0f	- PCMA Mixer Volume */
+	{ 16, 0x00 },	/* r10	- PCMB Mixer Volume */
+	{ 17, 0x00 },	/* r11	- Analog Input Advisory Volume */
+	{ 18, 0x00 },	/* r12	- Digital Input Advisory Volume */
+	{ 19, 0x00 },	/* r13	- Master A Volume */
+	{ 20, 0x00 },	/* r14	- Master B Volume */
+	{ 21, 0x00 },	/* r15	- Beep Freq / On Time */
+	{ 22, 0x00 },	/* r16	- Beep Volume / Off Time */
+	{ 23, 0x00 },	/* r17	- Beep Tone Ctl */
+	{ 24, 0x88 },	/* r18	- Tone Ctl */
+	{ 25, 0x00 },	/* r19	- Channel Mixer & Swap */
+	{ 26, 0x00 },	/* r1a	- AIN Ref Config / ADC Mux */
+	{ 27, 0xa0 },	/* r1b	- High-Pass Filter Ctl */
+	{ 28, 0x00 },	/* r1c	- Misc ADC Ctl */
+	{ 29, 0x00 },	/* r1d	- Gain & Bias Ctl */
+	{ 30, 0x00 },	/* r1e	- PGAA Mux & Volume */
+	{ 31, 0x00 },	/* r1f	- PGAB Mux & Volume */
+	{ 32, 0x00 },	/* r20	- ADCA Attenuator */
+	{ 33, 0x00 },	/* r21	- ADCB Attenuator */
+	{ 34, 0x00 },	/* r22	- ALC Enable & Attack Rate */
+	{ 35, 0xbf },	/* r23	- ALC Release Rate */
+	{ 36, 0x00 },	/* r24	- ALC Threshold */
+	{ 37, 0x00 },	/* r25	- Noise Gate Ctl */
+	{ 38, 0x00 },	/* r26	- ALC, Limiter, SFT, ZeroCross */
+	{ 39, 0x00 },	/* r27	- Analog Mute, LO & HP Mux */
+	{ 40, 0x00 },	/* r28	- HP A Volume */
+	{ 41, 0x00 },	/* r29	- HP B Volume */
+	{ 42, 0x00 },	/* r2a	- LINEOUT A Volume */
+	{ 43, 0x00 },	/* r2b	- LINEOUT B Volume */
+	{ 44, 0x00 },	/* r2c	- Limit Threshold Ctl */
+	{ 45, 0x7f },	/* r2d	- Limiter Ctl & Release Rate */
+	{ 46, 0x00 },	/* r2e	- Limiter Attack Rate */
+};
+
+static bool cs42l56_readable_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case CS42L56_CHIP_ID_1:
+	case CS42L56_CHIP_ID_2:
+	case CS42L56_PWRCTL_1:
+	case CS42L56_PWRCTL_2:
+	case CS42L56_CLKCTL_1:
+	case CS42L56_CLKCTL_2:
+	case CS42L56_SERIAL_FMT:
+	case CS42L56_CLASSH_CTL:
+	case CS42L56_MISC_CTL:
+	case CS42L56_INT_STATUS:
+	case CS42L56_PLAYBACK_CTL:
+	case CS42L56_DSP_MUTE_CTL:
+	case CS42L56_ADCA_MIX_VOLUME:
+	case CS42L56_ADCB_MIX_VOLUME:
+	case CS42L56_PCMA_MIX_VOLUME:
+	case CS42L56_PCMB_MIX_VOLUME:
+	case CS42L56_ANAINPUT_ADV_VOLUME:
+	case CS42L56_DIGINPUT_ADV_VOLUME:
+	case CS42L56_MASTER_A_VOLUME:
+	case CS42L56_MASTER_B_VOLUME:
+	case CS42L56_BEEP_FREQ_ONTIME:
+	case CS42L56_BEEP_FREQ_OFFTIME:
+	case CS42L56_BEEP_TONE_CFG:
+	case CS42L56_TONE_CTL:
+	case CS42L56_CHAN_MIX_SWAP:
+	case CS42L56_AIN_REFCFG_ADC_MUX:
+	case CS42L56_HPF_CTL:
+	case CS42L56_MISC_ADC_CTL:
+	case CS42L56_GAIN_BIAS_CTL:
+	case CS42L56_PGAA_MUX_VOLUME:
+	case CS42L56_PGAB_MUX_VOLUME:
+	case CS42L56_ADCA_ATTENUATOR:
+	case CS42L56_ADCB_ATTENUATOR:
+	case CS42L56_ALC_EN_ATTACK_RATE:
+	case CS42L56_ALC_RELEASE_RATE:
+	case CS42L56_ALC_THRESHOLD:
+	case CS42L56_NOISE_GATE_CTL:
+	case CS42L56_ALC_LIM_SFT_ZC:
+	case CS42L56_AMUTE_HPLO_MUX:
+	case CS42L56_HPA_VOLUME:
+	case CS42L56_HPB_VOLUME:
+	case CS42L56_LOA_VOLUME:
+	case CS42L56_LOB_VOLUME:
+	case CS42L56_LIM_THRESHOLD_CTL:
+	case CS42L56_LIM_CTL_RELEASE_RATE:
+	case CS42L56_LIM_ATTACK_RATE:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool cs42l56_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case CS42L56_INT_STATUS:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static DECLARE_TLV_DB_SCALE(beep_tlv, -5000, 200, 0);
+static DECLARE_TLV_DB_SCALE(hl_tlv, -6000, 50, 0);
+static DECLARE_TLV_DB_SCALE(adv_tlv, -10200, 50, 0);
+static DECLARE_TLV_DB_SCALE(adc_tlv, -9600, 100, 0);
+static DECLARE_TLV_DB_SCALE(tone_tlv, -1050, 150, 0);
+static DECLARE_TLV_DB_SCALE(preamp_tlv, 0, 1000, 0);
+static DECLARE_TLV_DB_SCALE(pga_tlv, -600, 50, 0);
+
+static const unsigned int ngnb_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 1, TLV_DB_SCALE_ITEM(-8200, 600, 0),
+	2, 5, TLV_DB_SCALE_ITEM(-7600, 300, 0),
+};
+static const unsigned int ngb_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 2, TLV_DB_SCALE_ITEM(-6400, 600, 0),
+	3, 7, TLV_DB_SCALE_ITEM(-4600, 300, 0),
+};
+static const unsigned int alc_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 2, TLV_DB_SCALE_ITEM(-3000, 600, 0),
+	3, 7, TLV_DB_SCALE_ITEM(-1200, 300, 0),
+};
+
+static const char * const beep_config_text[] = {
+	"Off", "Single", "Multiple", "Continuous"
+};
+
+static const struct soc_enum beep_config_enum =
+	SOC_ENUM_SINGLE(CS42L56_BEEP_TONE_CFG, 6,
+			ARRAY_SIZE(beep_config_text), beep_config_text);
+
+static const char * const beep_pitch_text[] = {
+	"C4", "C5", "D5", "E5", "F5", "G5", "A5", "B5",
+	"C6", "D6", "E6", "F6", "G6", "A6", "B6", "C7"
+};
+
+static const struct soc_enum beep_pitch_enum =
+	SOC_ENUM_SINGLE(CS42L56_BEEP_FREQ_ONTIME, 4,
+			ARRAY_SIZE(beep_pitch_text), beep_pitch_text);
+
+static const char * const beep_ontime_text[] = {
+	"86 ms", "430 ms", "780 ms", "1.20 s", "1.50 s",
+	"1.80 s", "2.20 s", "2.50 s", "2.80 s", "3.20 s",
+	"3.50 s", "3.80 s", "4.20 s", "4.50 s", "4.80 s", "5.20 s"
+};
+
+static const struct soc_enum beep_ontime_enum =
+	SOC_ENUM_SINGLE(CS42L56_BEEP_FREQ_ONTIME, 0,
+			ARRAY_SIZE(beep_ontime_text), beep_ontime_text);
+
+static const char * const beep_offtime_text[] = {
+	"1.23 s", "2.58 s", "3.90 s", "5.20 s",
+	"6.60 s", "8.05 s", "9.35 s", "10.80 s"
+};
+
+static const struct soc_enum beep_offtime_enum =
+	SOC_ENUM_SINGLE(CS42L56_BEEP_FREQ_OFFTIME, 5,
+			ARRAY_SIZE(beep_offtime_text), beep_offtime_text);
+
+static const char * const beep_treble_text[] = {
+	"5kHz", "7kHz", "10kHz", "15kHz"
+};
+
+static const struct soc_enum beep_treble_enum =
+	SOC_ENUM_SINGLE(CS42L56_BEEP_TONE_CFG, 3,
+			ARRAY_SIZE(beep_treble_text), beep_treble_text);
+
+static const char * const beep_bass_text[] = {
+	"50Hz", "100Hz", "200Hz", "250Hz"
+};
+
+static const struct soc_enum beep_bass_enum =
+	SOC_ENUM_SINGLE(CS42L56_BEEP_TONE_CFG, 1,
+			ARRAY_SIZE(beep_bass_text), beep_bass_text);
+
+static const char * const adc_swap_text[] = {
+	"None", "A+B/2", "A-B/2", "Swap"
+};
+
+static const struct soc_enum adc_swap_enum =
+	SOC_ENUM_SINGLE(CS42L56_MISC_ADC_CTL, 3,
+			ARRAY_SIZE(adc_swap_text), adc_swap_text);
+
+static const char * const pgaa_mux_text[] = {
+	"AIN1A", "AIN2A", "AIN3A"};
+
+static const struct soc_enum pgaa_mux_enum =
+	SOC_ENUM_SINGLE(CS42L56_PGAA_MUX_VOLUME, 0,
+			      ARRAY_SIZE(pgaa_mux_text),
+			      pgaa_mux_text);
+
+static const struct snd_kcontrol_new pgaa_mux =
+	SOC_DAPM_ENUM("Route", pgaa_mux_enum);
+
+static const char * const pgab_mux_text[] = {
+	"AIN1B", "AIN2B", "AIN3B"};
+
+static const struct soc_enum pgab_mux_enum =
+	SOC_ENUM_SINGLE(CS42L56_PGAB_MUX_VOLUME, 0,
+			      ARRAY_SIZE(pgab_mux_text),
+			      pgab_mux_text);
+
+static const struct snd_kcontrol_new pgab_mux =
+	SOC_DAPM_ENUM("Route", pgab_mux_enum);
+
+static const char * const adca_mux_text[] = {
+	"PGAA", "AIN1A", "AIN2A", "AIN3A"};
+
+static const struct soc_enum adca_mux_enum =
+	SOC_ENUM_SINGLE(CS42L56_AIN_REFCFG_ADC_MUX, 0,
+			      ARRAY_SIZE(adca_mux_text),
+			      adca_mux_text);
+
+static const struct snd_kcontrol_new adca_mux =
+	SOC_DAPM_ENUM("Route", adca_mux_enum);
+
+static const char * const adcb_mux_text[] = {
+	"PGAB", "AIN1B", "AIN2B", "AIN3B"};
+
+static const struct soc_enum adcb_mux_enum =
+	SOC_ENUM_SINGLE(CS42L56_AIN_REFCFG_ADC_MUX, 2,
+			      ARRAY_SIZE(adcb_mux_text),
+			      adcb_mux_text);
+
+static const struct snd_kcontrol_new adcb_mux =
+	SOC_DAPM_ENUM("Route", adcb_mux_enum);
+
+static const char * const left_swap_text[] = {
+	"Left", "LR 2", "Right"};
+
+static const char * const right_swap_text[] = {
+	"Right", "LR 2", "Left"};
+
+static const unsigned int swap_values[] = { 0, 1, 3 };
+
+static const struct soc_enum adca_swap_enum =
+	SOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 0, 3,
+			      ARRAY_SIZE(left_swap_text),
+			      left_swap_text,
+			      swap_values);
+
+static const struct soc_enum pcma_swap_enum =
+	SOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 4, 3,
+			      ARRAY_SIZE(left_swap_text),
+			      left_swap_text,
+			      swap_values);
+
+static const struct soc_enum adcb_swap_enum =
+	SOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 2, 3,
+			      ARRAY_SIZE(right_swap_text),
+			      right_swap_text,
+			      swap_values);
+
+static const struct soc_enum pcmb_swap_enum =
+	SOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 6, 3,
+			      ARRAY_SIZE(right_swap_text),
+			      right_swap_text,
+			      swap_values);
+
+static const struct snd_kcontrol_new hpa_switch =
+	SOC_DAPM_SINGLE("Switch", CS42L56_PWRCTL_2, 6, 1, 1);
+
+static const struct snd_kcontrol_new hpb_switch =
+	SOC_DAPM_SINGLE("Switch", CS42L56_PWRCTL_2, 4, 1, 1);
+
+static const struct snd_kcontrol_new loa_switch =
+	SOC_DAPM_SINGLE("Switch", CS42L56_PWRCTL_2, 2, 1, 1);
+
+static const struct snd_kcontrol_new lob_switch =
+	SOC_DAPM_SINGLE("Switch", CS42L56_PWRCTL_2, 0, 1, 1);
+
+static const char * const hploa_input_text[] = {
+	"DACA", "PGAA"};
+
+static const struct soc_enum lineouta_input_enum =
+	SOC_ENUM_SINGLE(CS42L56_AMUTE_HPLO_MUX, 2,
+			      ARRAY_SIZE(hploa_input_text),
+			      hploa_input_text);
+
+static const struct snd_kcontrol_new lineouta_input =
+	SOC_DAPM_ENUM("Route", lineouta_input_enum);
+
+static const struct soc_enum hpa_input_enum =
+	SOC_ENUM_SINGLE(CS42L56_AMUTE_HPLO_MUX, 0,
+			      ARRAY_SIZE(hploa_input_text),
+			      hploa_input_text);
+
+static const struct snd_kcontrol_new hpa_input =
+	SOC_DAPM_ENUM("Route", hpa_input_enum);
+
+static const char * const hplob_input_text[] = {
+	"DACB", "PGAB"};
+
+static const struct soc_enum lineoutb_input_enum =
+	SOC_ENUM_SINGLE(CS42L56_AMUTE_HPLO_MUX, 3,
+			      ARRAY_SIZE(hplob_input_text),
+			      hplob_input_text);
+
+static const struct snd_kcontrol_new lineoutb_input =
+	SOC_DAPM_ENUM("Route", lineoutb_input_enum);
+
+static const struct soc_enum hpb_input_enum =
+	SOC_ENUM_SINGLE(CS42L56_AMUTE_HPLO_MUX, 1,
+			      ARRAY_SIZE(hplob_input_text),
+			      hplob_input_text);
+
+static const struct snd_kcontrol_new hpb_input =
+	SOC_DAPM_ENUM("Route", hpb_input_enum);
+
+static const char * const dig_mux_text[] = {
+	"ADC", "DSP"};
+
+static const struct soc_enum dig_mux_enum =
+	SOC_ENUM_SINGLE(CS42L56_MISC_CTL, 7,
+			      ARRAY_SIZE(dig_mux_text),
+			      dig_mux_text);
+
+static const struct snd_kcontrol_new dig_mux =
+	SOC_DAPM_ENUM("Route", dig_mux_enum);
+
+static const char * const hpf_freq_text[] = {
+	"1.8Hz", "119Hz", "236Hz", "464Hz"
+};
+
+static const struct soc_enum hpfa_freq_enum =
+	SOC_ENUM_SINGLE(CS42L56_HPF_CTL, 0,
+			ARRAY_SIZE(hpf_freq_text), hpf_freq_text);
+
+static const struct soc_enum hpfb_freq_enum =
+	SOC_ENUM_SINGLE(CS42L56_HPF_CTL, 2,
+			ARRAY_SIZE(hpf_freq_text), hpf_freq_text);
+
+static const char * const ng_delay_text[] = {
+	"50ms", "100ms", "150ms", "200ms"
+};
+
+static const struct soc_enum ng_delay_enum =
+	SOC_ENUM_SINGLE(CS42L56_NOISE_GATE_CTL, 0,
+			ARRAY_SIZE(ng_delay_text), ng_delay_text);
+
+static const struct snd_kcontrol_new cs42l56_snd_controls[] = {
+
+	SOC_DOUBLE_R_SX_TLV("Master Volume", CS42L56_MASTER_A_VOLUME,
+			      CS42L56_MASTER_B_VOLUME, 0, 0x34, 0xfd, adv_tlv),
+	SOC_DOUBLE("Master Mute Switch", CS42L56_DSP_MUTE_CTL, 0, 1, 1, 1),
+
+	SOC_DOUBLE_R_SX_TLV("ADC Mixer Volume", CS42L56_ADCA_MIX_VOLUME,
+			      CS42L56_ADCB_MIX_VOLUME, 0, 0x88, 0xa9, hl_tlv),
+	SOC_DOUBLE("ADC Mixer Mute Switch", CS42L56_DSP_MUTE_CTL, 6, 7, 1, 1),
+
+	SOC_DOUBLE_R_SX_TLV("PCM Mixer Volume", CS42L56_PCMA_MIX_VOLUME,
+			      CS42L56_PCMB_MIX_VOLUME, 0, 0x88, 0xa9, hl_tlv),
+	SOC_DOUBLE("PCM Mixer Mute Switch", CS42L56_DSP_MUTE_CTL, 4, 5, 1, 1),
+
+	SOC_SINGLE_TLV("Analog Advisory Volume",
+			  CS42L56_ANAINPUT_ADV_VOLUME, 0, 0x00, 1, adv_tlv),
+	SOC_SINGLE_TLV("Digital Advisory Volume",
+			  CS42L56_DIGINPUT_ADV_VOLUME, 0, 0x00, 1, adv_tlv),
+
+	SOC_DOUBLE_R_SX_TLV("PGA Volume", CS42L56_PGAA_MUX_VOLUME,
+			      CS42L56_PGAB_MUX_VOLUME, 0, 0x34, 0xfd, pga_tlv),
+	SOC_DOUBLE_R_TLV("ADC Volume", CS42L56_ADCA_ATTENUATOR,
+			      CS42L56_ADCB_ATTENUATOR, 0, 0x00, 1, adc_tlv),
+	SOC_DOUBLE("ADC Mute Switch", CS42L56_MISC_ADC_CTL, 2, 3, 1, 1),
+	SOC_DOUBLE("ADC Boost Switch", CS42L56_GAIN_BIAS_CTL, 3, 2, 1, 1),
+
+	SOC_DOUBLE_R_SX_TLV("Headphone Volume", CS42L56_HPA_VOLUME,
+			      CS42L56_HPA_VOLUME, 0, 0x44, 0x55, hl_tlv),
+	SOC_DOUBLE_R_SX_TLV("LineOut Volume", CS42L56_LOA_VOLUME,
+			      CS42L56_LOA_VOLUME, 0, 0x44, 0x55, hl_tlv),
+
+	SOC_SINGLE_TLV("Bass Shelving Volume", CS42L56_TONE_CTL,
+			0, 0x00, 1, tone_tlv),
+	SOC_SINGLE_TLV("Treble Shelving Volume", CS42L56_TONE_CTL,
+			4, 0x00, 1, tone_tlv),
+
+	SOC_DOUBLE_TLV("PGA Preamp Volume", CS42L56_GAIN_BIAS_CTL,
+			4, 6, 0x02, 1, preamp_tlv),
+
+	SOC_SINGLE("DSP Switch", CS42L56_PLAYBACK_CTL, 7, 1, 1),
+	SOC_SINGLE("Gang Playback Switch", CS42L56_PLAYBACK_CTL, 4, 1, 1),
+	SOC_SINGLE("Gang ADC Switch", CS42L56_MISC_ADC_CTL, 7, 1, 1),
+	SOC_SINGLE("Gang PGA Switch", CS42L56_MISC_ADC_CTL, 6, 1, 1),
+
+	SOC_SINGLE("PCMA Invert", CS42L56_PLAYBACK_CTL, 2, 1, 1),
+	SOC_SINGLE("PCMB Invert", CS42L56_PLAYBACK_CTL, 3, 1, 1),
+	SOC_SINGLE("ADCA Invert", CS42L56_MISC_ADC_CTL, 2, 1, 1),
+	SOC_SINGLE("ADCB Invert", CS42L56_MISC_ADC_CTL, 3, 1, 1),
+
+	SOC_ENUM("PCMA Swap", pcma_swap_enum),
+	SOC_ENUM("PCMB Swap", pcmb_swap_enum),
+	SOC_ENUM("ADCA Swap", adca_swap_enum),
+	SOC_ENUM("ADCB Swap", adcb_swap_enum),
+
+	SOC_DOUBLE("HPF Switch", CS42L56_HPF_CTL, 5, 7, 1, 1),
+	SOC_DOUBLE("HPF Freeze Switch", CS42L56_HPF_CTL, 4, 6, 1, 1),
+	SOC_ENUM("HPFA Corner Freq", hpfa_freq_enum),
+	SOC_ENUM("HPFB Corner Freq", hpfb_freq_enum),
+
+	SOC_SINGLE("Analog Soft Ramp", CS42L56_MISC_CTL, 4, 1, 1),
+	SOC_DOUBLE("Analog Soft Ramp Disable", CS42L56_ALC_LIM_SFT_ZC,
+		7, 5, 1, 1),
+	SOC_SINGLE("Analog Zero Cross", CS42L56_MISC_CTL, 3, 1, 1),
+	SOC_DOUBLE("Analog Zero Cross Disable", CS42L56_ALC_LIM_SFT_ZC,
+		6, 4, 1, 1),
+	SOC_SINGLE("Digital Soft Ramp", CS42L56_MISC_CTL, 2, 1, 1),
+	SOC_SINGLE("Digital Soft Ramp Disable", CS42L56_ALC_LIM_SFT_ZC,
+		3, 1, 1),
+
+	SOC_SINGLE("HL Deemphasis", CS42L56_PLAYBACK_CTL, 6, 1, 1),
+
+	SOC_SINGLE("ALC Switch", CS42L56_ALC_EN_ATTACK_RATE, 6, 1, 1),
+	SOC_SINGLE("ALC Limit All Switch", CS42L56_ALC_RELEASE_RATE, 7, 1, 1),
+	SOC_SINGLE_RANGE("ALC Attack", CS42L56_ALC_EN_ATTACK_RATE,
+			0, 0, 0x3f, 0),
+	SOC_SINGLE_RANGE("ALC Release", CS42L56_ALC_RELEASE_RATE,
+			0, 0x3f, 0, 0),
+	SOC_SINGLE_TLV("ALC MAX", CS42L56_ALC_THRESHOLD,
+			5, 0x07, 1, alc_tlv),
+	SOC_SINGLE_TLV("ALC MIN", CS42L56_ALC_THRESHOLD,
+			2, 0x07, 1, alc_tlv),
+
+	SOC_SINGLE("Limiter Switch", CS42L56_LIM_CTL_RELEASE_RATE, 7, 1, 1),
+	SOC_SINGLE("Limit All Switch", CS42L56_LIM_CTL_RELEASE_RATE, 6, 1, 1),
+	SOC_SINGLE_RANGE("Limiter Attack", CS42L56_LIM_ATTACK_RATE,
+			0, 0, 0x3f, 0),
+	SOC_SINGLE_RANGE("Limiter Release", CS42L56_LIM_CTL_RELEASE_RATE,
+			0, 0x3f, 0, 0),
+	SOC_SINGLE_TLV("Limiter MAX", CS42L56_LIM_THRESHOLD_CTL,
+			5, 0x07, 1, alc_tlv),
+	SOC_SINGLE_TLV("Limiter Cushion", CS42L56_ALC_THRESHOLD,
+			2, 0x07, 1, alc_tlv),
+
+	SOC_SINGLE("NG Switch", CS42L56_NOISE_GATE_CTL, 6, 1, 1),
+	SOC_SINGLE("NG All Switch", CS42L56_NOISE_GATE_CTL, 7, 1, 1),
+	SOC_SINGLE("NG Boost Switch", CS42L56_NOISE_GATE_CTL, 5, 1, 1),
+	SOC_SINGLE_TLV("NG Unboost Threshold", CS42L56_NOISE_GATE_CTL,
+			2, 0x07, 1, ngnb_tlv),
+	SOC_SINGLE_TLV("NG Boost Threshold", CS42L56_NOISE_GATE_CTL,
+			2, 0x07, 1, ngb_tlv),
+	SOC_ENUM("NG Delay", ng_delay_enum),
+
+	SOC_ENUM("Beep Config", beep_config_enum),
+	SOC_ENUM("Beep Pitch", beep_pitch_enum),
+	SOC_ENUM("Beep on Time", beep_ontime_enum),
+	SOC_ENUM("Beep off Time", beep_offtime_enum),
+	SOC_SINGLE_SX_TLV("Beep Volume", CS42L56_BEEP_FREQ_OFFTIME,
+			0, 0x07, 0x23, beep_tlv),
+	SOC_SINGLE("Beep Tone Ctl Switch", CS42L56_BEEP_TONE_CFG, 0, 1, 1),
+	SOC_ENUM("Beep Treble Corner Freq", beep_treble_enum),
+	SOC_ENUM("Beep Bass Corner Freq", beep_bass_enum),
+
+};
+
+static const struct snd_soc_dapm_widget cs42l56_dapm_widgets[] = {
+
+	SND_SOC_DAPM_SIGGEN("Beep"),
+	SND_SOC_DAPM_SUPPLY("VBUF", CS42L56_PWRCTL_1, 5, 1, NULL, 0),
+	SND_SOC_DAPM_MICBIAS("MIC1 Bias", CS42L56_PWRCTL_1, 4, 1),
+	SND_SOC_DAPM_SUPPLY("Charge Pump", CS42L56_PWRCTL_1, 3, 1, NULL, 0),
+
+	SND_SOC_DAPM_INPUT("AIN1A"),
+	SND_SOC_DAPM_INPUT("AIN2A"),
+	SND_SOC_DAPM_INPUT("AIN1B"),
+	SND_SOC_DAPM_INPUT("AIN2B"),
+	SND_SOC_DAPM_INPUT("AIN3A"),
+	SND_SOC_DAPM_INPUT("AIN3B"),
+
+	SND_SOC_DAPM_AIF_OUT("SDOUT", NULL,  0,
+			SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_AIF_IN("SDIN", NULL,  0,
+			SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_MUX("Digital Output Mux", SND_SOC_NOPM,
+			 0, 0, &dig_mux),
+
+	SND_SOC_DAPM_PGA("PGAA", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("PGAB", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_MUX("PGAA Input Mux",
+			SND_SOC_NOPM, 0, 0, &pgaa_mux),
+	SND_SOC_DAPM_MUX("PGAB Input Mux",
+			SND_SOC_NOPM, 0, 0, &pgab_mux),
+
+	SND_SOC_DAPM_MUX("ADCA Mux", SND_SOC_NOPM,
+			 0, 0, &adca_mux),
+	SND_SOC_DAPM_MUX("ADCB Mux", SND_SOC_NOPM,
+			 0, 0, &adcb_mux),
+
+	SND_SOC_DAPM_ADC("ADCA", NULL, CS42L56_PWRCTL_1, 1, 1),
+	SND_SOC_DAPM_ADC("ADCB", NULL, CS42L56_PWRCTL_1, 2, 1),
+
+	SND_SOC_DAPM_DAC("DACA", NULL, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_DAC("DACB", NULL, SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_OUTPUT("HPA"),
+	SND_SOC_DAPM_OUTPUT("LOA"),
+	SND_SOC_DAPM_OUTPUT("HPB"),
+	SND_SOC_DAPM_OUTPUT("LOB"),
+
+	SND_SOC_DAPM_SWITCH("Headphone Right",
+			    CS42L56_PWRCTL_2, 4, 1, &hpb_switch),
+	SND_SOC_DAPM_SWITCH("Headphone Left",
+			    CS42L56_PWRCTL_2, 6, 1, &hpa_switch),
+
+	SND_SOC_DAPM_SWITCH("Lineout Right",
+			    CS42L56_PWRCTL_2, 0, 1, &lob_switch),
+	SND_SOC_DAPM_SWITCH("Lineout Left",
+			    CS42L56_PWRCTL_2, 2, 1, &loa_switch),
+
+	SND_SOC_DAPM_MUX("LINEOUTA Input Mux", SND_SOC_NOPM,
+			 0, 0, &lineouta_input),
+	SND_SOC_DAPM_MUX("LINEOUTB Input Mux", SND_SOC_NOPM,
+			 0, 0, &lineoutb_input),
+	SND_SOC_DAPM_MUX("HPA Input Mux", SND_SOC_NOPM,
+			 0, 0, &hpa_input),
+	SND_SOC_DAPM_MUX("HPB Input Mux", SND_SOC_NOPM,
+			 0, 0, &hpb_input),
+
+};
+
+static const struct snd_soc_dapm_route cs42l56_audio_map[] = {
+
+	{"HiFi Capture", "DSP", "Digital Output Mux"},
+	{"HiFi Capture", "ADC", "Digital Output Mux"},
+
+	{"Digital Output Mux", NULL, "ADCA"},
+	{"Digital Output Mux", NULL, "ADCB"},
+
+	{"ADCB", NULL, "ADCB Mux"},
+	{"ADCA", NULL, "ADCA Mux"},
+
+	{"ADCA Mux", NULL, "AIN3A"},
+	{"ADCA Mux", NULL, "AIN2A"},
+	{"ADCA Mux", NULL, "AIN1A"},
+	{"ADCA Mux", NULL, "PGAA"},
+	{"ADCB Mux", NULL, "AIN3B"},
+	{"ADCB Mux", NULL, "AIN2B"},
+	{"ADCB Mux", NULL, "AIN1B"},
+	{"ADCB Mux", NULL, "PGAB"},
+
+	{"PGAA", "AIN1A", "PGAA Input Mux"},
+	{"PGAA", "AIN2A", "PGAA Input Mux"},
+	{"PGAA", "AIN3A", "PGAA Input Mux"},
+	{"PGAB", "AIN1B", "PGAB Input Mux"},
+	{"PGAB", "AIN2B", "PGAB Input Mux"},
+	{"PGAB", "AIN3B", "PGAB Input Mux"},
+
+	{"PGAA Input Mux", NULL, "AIN1A"},
+	{"PGAA Input Mux", NULL, "AIN2A"},
+	{"PGAA Input Mux", NULL, "AIN3A"},
+	{"PGAB Input Mux", NULL, "AIN1B"},
+	{"PGAB Input Mux", NULL, "AIN2B"},
+	{"PGAB Input Mux", NULL, "AIN3B"},
+
+	{"LOB", NULL, "Lineout Right"},
+	{"LOA", NULL, "Lineout Left"},
+
+	{"Lineout Right", "Switch", "LINEOUTB Input Mux"},
+	{"Lineout Left", "Switch", "LINEOUTA Input Mux"},
+
+	{"LINEOUTA Input Mux", "PGAA", "PGAA"},
+	{"LINEOUTB Input Mux", "PGAB", "PGAB"},
+	{"LINEOUTA Input Mux", "DACA", "DACA"},
+	{"LINEOUTB Input Mux", "DACB", "DACB"},
+
+	{"HPA", NULL, "Headphone Left"},
+	{"HPB", NULL, "Headphone Right"},
+
+	{"Headphone Right", "Switch", "HPB Input Mux"},
+	{"Headphone Left", "Switch", "HPA Input Mux"},
+
+	{"HPA Input Mux", "PGAA", "PGAA"},
+	{"HPB Input Mux", "PGAB", "PGAB"},
+	{"HPA Input Mux", "DACA", "DACA"},
+	{"HPB Input Mux", "DACB", "DACB"},
+
+	{"DACB", NULL, "HiFi Playback"},
+	{"DACA", NULL, "HiFi Playback"},
+
+};
+
+struct cs42l56_clk_para {
+	u32 mclk;
+	u32 srate;
+	u8 ratio;
+};
+
+static const struct cs42l56_clk_para clk_ratio_table[] = {
+	/* 8k */
+	{ 6000000, 8000, CS42L56_MCLK_LRCLK_768 },
+	{ 6144000, 8000, CS42L56_MCLK_LRCLK_750 },
+	{ 12000000, 8000, CS42L56_MCLK_LRCLK_768 },
+	{ 12288000, 8000, CS42L56_MCLK_LRCLK_750 },
+	{ 24000000, 8000, CS42L56_MCLK_LRCLK_768 },
+	{ 24576000, 8000, CS42L56_MCLK_LRCLK_750 },
+	/* 11.025k */
+	{ 5644800, 11025, CS42L56_MCLK_LRCLK_512},
+	{ 11289600, 11025, CS42L56_MCLK_LRCLK_512},
+	{ 22579200, 11025, CS42L56_MCLK_LRCLK_512 },
+	/* 11.0294k */
+	{ 6000000, 110294, CS42L56_MCLK_LRCLK_544 },
+	{ 12000000, 110294, CS42L56_MCLK_LRCLK_544 },
+	{ 24000000, 110294, CS42L56_MCLK_LRCLK_544 },
+	/* 12k */
+	{ 6000000, 12000, CS42L56_MCLK_LRCLK_500 },
+	{ 6144000, 12000, CS42L56_MCLK_LRCLK_512 },
+	{ 12000000, 12000, CS42L56_MCLK_LRCLK_500 },
+	{ 12288000, 12000, CS42L56_MCLK_LRCLK_512 },
+	{ 24000000, 12000, CS42L56_MCLK_LRCLK_500 },
+	{ 24576000, 12000, CS42L56_MCLK_LRCLK_512 },
+	/* 16k */
+	{ 6000000, 16000, CS42L56_MCLK_LRCLK_375 },
+	{ 6144000, 16000, CS42L56_MCLK_LRCLK_384 },
+	{ 12000000, 16000, CS42L56_MCLK_LRCLK_375 },
+	{ 12288000, 16000, CS42L56_MCLK_LRCLK_384 },
+	{ 24000000, 16000, CS42L56_MCLK_LRCLK_375 },
+	{ 24576000, 16000, CS42L56_MCLK_LRCLK_384 },
+	/* 22.050k */
+	{ 5644800, 22050, CS42L56_MCLK_LRCLK_256 },
+	{ 11289600, 22050, CS42L56_MCLK_LRCLK_256 },
+	{ 22579200, 22050, CS42L56_MCLK_LRCLK_256 },
+	/* 22.0588k */
+	{ 6000000, 220588, CS42L56_MCLK_LRCLK_272 },
+	{ 12000000, 220588, CS42L56_MCLK_LRCLK_272 },
+	{ 24000000, 220588, CS42L56_MCLK_LRCLK_272 },
+	/* 24k */
+	{ 6000000, 24000, CS42L56_MCLK_LRCLK_250 },
+	{ 6144000, 24000, CS42L56_MCLK_LRCLK_256 },
+	{ 12000000, 24000, CS42L56_MCLK_LRCLK_250 },
+	{ 12288000, 24000, CS42L56_MCLK_LRCLK_256 },
+	{ 24000000, 24000, CS42L56_MCLK_LRCLK_250 },
+	{ 24576000, 24000, CS42L56_MCLK_LRCLK_256 },
+	/* 32k */
+	{ 6000000, 32000, CS42L56_MCLK_LRCLK_187P5 },
+	{ 6144000, 32000, CS42L56_MCLK_LRCLK_192 },
+	{ 12000000, 32000, CS42L56_MCLK_LRCLK_187P5 },
+	{ 12288000, 32000, CS42L56_MCLK_LRCLK_192 },
+	{ 24000000, 32000, CS42L56_MCLK_LRCLK_187P5 },
+	{ 24576000, 32000, CS42L56_MCLK_LRCLK_192 },
+	/* 44.118k */
+	{ 6000000, 44118, CS42L56_MCLK_LRCLK_136 },
+	{ 12000000, 44118, CS42L56_MCLK_LRCLK_136 },
+	{ 24000000, 44118, CS42L56_MCLK_LRCLK_136 },
+	/* 44.1k */
+	{ 5644800, 44100, CS42L56_MCLK_LRCLK_128 },
+	{ 11289600, 44100, CS42L56_MCLK_LRCLK_128 },
+	{ 22579200, 44100, CS42L56_MCLK_LRCLK_128 },
+	/* 48k */
+	{ 6000000, 48000, CS42L56_MCLK_LRCLK_125 },
+	{ 6144000, 48000, CS42L56_MCLK_LRCLK_128 },
+	{ 12000000, 48000, CS42L56_MCLK_LRCLK_125 },
+	{ 12288000, 48000, CS42L56_MCLK_LRCLK_128 },
+	{ 24000000, 48000, CS42L56_MCLK_LRCLK_125 },
+	{ 24576000, 48000, CS42L56_MCLK_LRCLK_128 },
+};
+
+static int cs42l56_get_mclk_ratio(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(clk_ratio_table); i++) {
+		if (clk_ratio_table[i].mclk == mclk &&
+		    clk_ratio_table[i].srate == rate)
+			return clk_ratio_table[i].ratio;
+	}
+	return -EINVAL;
+}
+
+static int cs42l56_set_sysclk(struct snd_soc_dai *codec_dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+
+	switch (freq) {
+	case CS42L56_MCLK_5P6448MHZ:
+	case CS42L56_MCLK_6MHZ:
+	case CS42L56_MCLK_6P144MHZ:
+		cs42l56->mclk_div2 = 0;
+		cs42l56->mclk_prediv = 0;
+		break;
+	case CS42L56_MCLK_11P2896MHZ:
+	case CS42L56_MCLK_12MHZ:
+	case CS42L56_MCLK_12P288MHZ:
+		cs42l56->mclk_div2 = 1;
+		cs42l56->mclk_prediv = 0;
+		break;
+	case CS42L56_MCLK_22P5792MHZ:
+	case CS42L56_MCLK_24MHZ:
+	case CS42L56_MCLK_24P576MHZ:
+		cs42l56->mclk_div2 = 1;
+		cs42l56->mclk_prediv = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	cs42l56->mclk = freq;
+
+	snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+			    CS42L56_MCLK_PREDIV_MASK,
+				cs42l56->mclk_prediv);
+	snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+			    CS42L56_MCLK_DIV2_MASK,
+				cs42l56->mclk_div2);
+
+	return 0;
+}
+
+static int cs42l56_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		cs42l56->iface = CS42L56_MASTER_MODE;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		cs42l56->iface = CS42L56_SLAVE_MODE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	 /* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		cs42l56->iface_fmt = CS42L56_DIG_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		cs42l56->iface_fmt = CS42L56_DIG_FMT_LEFT_J;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* sclk inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		cs42l56->iface_inv = 0;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		cs42l56->iface_inv = CS42L56_SCLK_INV;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+			    CS42L56_MS_MODE_MASK, cs42l56->iface);
+	snd_soc_update_bits(codec, CS42L56_SERIAL_FMT,
+			    CS42L56_DIG_FMT_MASK, cs42l56->iface_fmt);
+	snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+			    CS42L56_SCLK_INV_MASK, cs42l56->iface_inv);
+	return 0;
+}
+
+static int cs42l56_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	if (mute) {
+		/* Hit the DSP Mixer first */
+		snd_soc_update_bits(codec, CS42L56_DSP_MUTE_CTL,
+				    CS42L56_ADCAMIX_MUTE_MASK |
+				CS42L56_ADCBMIX_MUTE_MASK |
+				CS42L56_PCMAMIX_MUTE_MASK |
+				CS42L56_PCMBMIX_MUTE_MASK |
+				CS42L56_MSTB_MUTE_MASK |
+				CS42L56_MSTA_MUTE_MASK,
+				CS42L56_MUTE);
+		/* Mute ADC's */
+		snd_soc_update_bits(codec, CS42L56_MISC_ADC_CTL,
+				CS42L56_ADCA_MUTE_MASK |
+				CS42L56_ADCB_MUTE_MASK,
+				CS42L56_MUTE);
+		/* HP And LO */
+		snd_soc_update_bits(codec, CS42L56_HPA_VOLUME,
+				CS42L56_HP_MUTE_MASK,
+				CS42L56_MUTE);
+		snd_soc_update_bits(codec, CS42L56_HPB_VOLUME,
+				CS42L56_HP_MUTE_MASK,
+				CS42L56_MUTE);
+		snd_soc_update_bits(codec, CS42L56_LOA_VOLUME,
+				CS42L56_LO_MUTE_MASK,
+				CS42L56_MUTE);
+		snd_soc_update_bits(codec, CS42L56_LOB_VOLUME,
+				CS42L56_LO_MUTE_MASK,
+				CS42L56_MUTE);
+
+
+	} else {
+		snd_soc_update_bits(codec, CS42L56_DSP_MUTE_CTL,
+				    CS42L56_ADCAMIX_MUTE_MASK |
+				CS42L56_ADCBMIX_MUTE_MASK |
+				CS42L56_PCMAMIX_MUTE_MASK |
+				CS42L56_PCMBMIX_MUTE_MASK |
+				CS42L56_MSTB_MUTE_MASK |
+				CS42L56_MSTA_MUTE_MASK,
+				CS42L56_UNMUTE);
+		snd_soc_update_bits(codec, CS42L56_MISC_ADC_CTL,
+				CS42L56_ADCA_MUTE_MASK |
+				CS42L56_ADCB_MUTE_MASK,
+				CS42L56_UNMUTE);
+		snd_soc_update_bits(codec, CS42L56_HPA_VOLUME,
+				CS42L56_HP_MUTE_MASK,
+				CS42L56_UNMUTE);
+		snd_soc_update_bits(codec, CS42L56_HPB_VOLUME,
+				CS42L56_HP_MUTE_MASK,
+				CS42L56_UNMUTE);
+		snd_soc_update_bits(codec, CS42L56_LOA_VOLUME,
+				CS42L56_LO_MUTE_MASK,
+				CS42L56_UNMUTE);
+		snd_soc_update_bits(codec, CS42L56_LOB_VOLUME,
+				CS42L56_LO_MUTE_MASK,
+				CS42L56_UNMUTE);
+	}
+	return 0;
+}
+
+static int cs42l56_pcm_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params,
+				     struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	int ratio;
+
+	ratio = cs42l56_get_mclk_ratio(cs42l56->mclk, params_rate(params));
+	if (ratio >= 0) {
+		snd_soc_update_bits(codec, CS42L56_CLKCTL_2,
+				    CS42L56_CLK_RATIO_MASK, ratio);
+	} else {
+		dev_err(codec->dev, "unsupported mclk/sclk/lrclk ratio\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cs42l56_set_bias_level(struct snd_soc_codec *codec,
+					enum snd_soc_bias_level level)
+{
+	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+				    CS42L56_MCLK_DIS_MASK, 0);
+		snd_soc_update_bits(codec, CS42L56_PWRCTL_1,
+				    CS42L56_PDN_ALL_MASK, 0);
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			regcache_cache_only(cs42l56->regmap, false);
+			regcache_sync(cs42l56->regmap);
+			ret = regulator_bulk_enable(ARRAY_SIZE(cs42l56->supplies),
+						    cs42l56->supplies);
+			if (ret != 0) {
+				dev_err(cs42l56->dev,
+					"Failed to enable regulators: %d\n",
+					ret);
+				return ret;
+			}
+		}
+		snd_soc_update_bits(codec, CS42L56_PWRCTL_1,
+				    CS42L56_PDN_ALL_MASK, 1);
+		break;
+	case SND_SOC_BIAS_OFF:
+		snd_soc_update_bits(codec, CS42L56_PWRCTL_1,
+				    CS42L56_PDN_ALL_MASK, 1);
+		snd_soc_update_bits(codec, CS42L56_CLKCTL_1,
+				    CS42L56_MCLK_DIS_MASK, 1);
+		regcache_cache_only(cs42l56->regmap, true);
+		regulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),
+						    cs42l56->supplies);
+		break;
+	}
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+#define CS42L56_RATES (SNDRV_PCM_RATE_8000_48000)
+
+#define CS42L56_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE | \
+			SNDRV_PCM_FMTBIT_S32_LE)
+
+
+static struct snd_soc_dai_ops cs42l56_ops = {
+	.hw_params	= cs42l56_pcm_hw_params,
+	.digital_mute	= cs42l56_digital_mute,
+	.set_fmt	= cs42l56_set_dai_fmt,
+	.set_sysclk	= cs42l56_set_sysclk,
+};
+
+static struct snd_soc_dai_driver cs42l56_dai = {
+		.name = "cs42l56",
+		.playback = {
+			.stream_name = "HiFi Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = CS42L56_RATES,
+			.formats = CS42L56_FORMATS,
+		},
+		.capture = {
+			.stream_name = "HiFi Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = CS42L56_RATES,
+			.formats = CS42L56_FORMATS,
+		},
+		.ops = &cs42l56_ops,
+};
+
+static int cs42l56_suspend(struct snd_soc_codec *codec)
+{
+	cs42l56_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	return 0;
+}
+
+static int cs42l56_resume(struct snd_soc_codec *codec)
+{
+	cs42l56_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return 0;
+}
+
+static int beep_freq[] = {
+	261, 522, 585, 667, 706, 774, 889, 1000,
+	1043, 1200, 1333, 1412, 1600, 1714, 2000, 2182
+};
+
+static void cs42l56_beep_work(struct work_struct *work)
+{
+	struct cs42l56_private *cs42l56 =
+		container_of(work, struct cs42l56_private, beep_work);
+	struct snd_soc_codec *codec = cs42l56->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	int i;
+	int val = 0;
+	int best = 0;
+
+	if (cs42l56->beep_rate) {
+		for (i = 0; i < ARRAY_SIZE(beep_freq); i++) {
+			if (abs(cs42l56->beep_rate - beep_freq[i]) <
+			    abs(cs42l56->beep_rate - beep_freq[best]))
+				best = i;
+		}
+
+		dev_dbg(codec->dev, "Set beep rate %dHz for requested %dHz\n",
+			beep_freq[best], cs42l56->beep_rate);
+
+		val = (best << CS42L56_BEEP_RATE_SHIFT);
+
+		snd_soc_dapm_enable_pin(dapm, "Beep");
+	} else {
+		dev_dbg(codec->dev, "Disabling beep\n");
+		snd_soc_dapm_disable_pin(dapm, "Beep");
+	}
+
+	snd_soc_update_bits(codec, CS42L56_BEEP_FREQ_ONTIME,
+			    CS42L56_BEEP_FREQ_MASK, val);
+
+	snd_soc_dapm_sync(dapm);
+}
+
+/* For usability define a way of injecting beep events for the device -
+ * many systems will not have a keyboard.
+ */
+static int cs42l56_beep_event(struct input_dev *dev, unsigned int type,
+			     unsigned int code, int hz)
+{
+	struct snd_soc_codec *codec = input_get_drvdata(dev);
+	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "Beep event %x %x\n", code, hz);
+
+	switch (code) {
+	case SND_BELL:
+		if (hz)
+			hz = 261;
+	case SND_TONE:
+		break;
+	default:
+		return -1;
+	}
+
+	/* Kick the beep from a workqueue */
+	cs42l56->beep_rate = hz;
+	schedule_work(&cs42l56->beep_work);
+	return 0;
+}
+
+static ssize_t cs42l56_beep_set(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct cs42l56_private *cs42l56 = dev_get_drvdata(dev);
+	long int time;
+	int ret;
+
+	ret = kstrtol(buf, 10, &time);
+	if (ret != 0)
+		return ret;
+
+	input_event(cs42l56->beep, EV_SND, SND_TONE, time);
+
+	return count;
+}
+
+static DEVICE_ATTR(beep, 0200, NULL, cs42l56_beep_set);
+
+static void cs42l56_init_beep(struct snd_soc_codec *codec)
+{
+	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	cs42l56->beep = devm_input_allocate_device(codec->dev);
+	if (!cs42l56->beep) {
+		dev_err(codec->dev, "Failed to allocate beep device\n");
+		return;
+	}
+
+	INIT_WORK(&cs42l56->beep_work, cs42l56_beep_work);
+	cs42l56->beep_rate = 0;
+
+	cs42l56->beep->name = "CS42L56 Beep Generator";
+	cs42l56->beep->phys = dev_name(codec->dev);
+	cs42l56->beep->id.bustype = BUS_I2C;
+
+	cs42l56->beep->evbit[0] = BIT_MASK(EV_SND);
+	cs42l56->beep->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);
+	cs42l56->beep->event = cs42l56_beep_event;
+	cs42l56->beep->dev.parent = codec->dev;
+	input_set_drvdata(cs42l56->beep, codec);
+
+	ret = input_register_device(cs42l56->beep);
+	if (ret != 0) {
+		cs42l56->beep = NULL;
+		dev_err(codec->dev, "Failed to register beep device\n");
+	}
+
+	ret = device_create_file(codec->dev, &dev_attr_beep);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to create keyclick file: %d\n",
+			ret);
+	}
+}
+
+static void cs42l56_free_beep(struct snd_soc_codec *codec)
+{
+	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+
+	device_remove_file(codec->dev, &dev_attr_beep);
+	cancel_work_sync(&cs42l56->beep_work);
+	cs42l56->beep = NULL;
+
+	snd_soc_update_bits(codec, CS42L56_BEEP_TONE_CFG,
+			    CS42L56_BEEP_EN_MASK, 0);
+}
+
+static int cs42l56_probe(struct snd_soc_codec *codec)
+{
+	cs42l56_init_beep(codec);
+
+	cs42l56_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return 0;
+}
+
+static int cs42l56_remove(struct snd_soc_codec *codec)
+{
+	struct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);
+
+	cs42l56_free_beep(codec);
+	cs42l56_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	regulator_bulk_free(ARRAY_SIZE(cs42l56->supplies), cs42l56->supplies);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_cs42l56 = {
+	.probe = cs42l56_probe,
+	.remove = cs42l56_remove,
+	.suspend = cs42l56_suspend,
+	.resume = cs42l56_resume,
+	.set_bias_level = cs42l56_set_bias_level,
+
+	.dapm_widgets = cs42l56_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(cs42l56_dapm_widgets),
+	.dapm_routes = cs42l56_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(cs42l56_audio_map),
+
+	.controls = cs42l56_snd_controls,
+	.num_controls = ARRAY_SIZE(cs42l56_snd_controls),
+};
+
+static struct regmap_config cs42l56_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = CS42L56_MAX_REGISTER,
+	.reg_defaults = cs42l56_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(cs42l56_reg_defaults),
+	.readable_reg = cs42l56_readable_register,
+	.volatile_reg = cs42l56_volatile_register,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int cs42l56_handle_of_data(struct i2c_client *i2c_client,
+				    struct cs42l56_platform_data *pdata)
+{
+	struct device_node *np = i2c_client->dev.of_node;
+	u32 val32;
+
+	if (of_property_read_bool(np, "cirrus,ain1a-reference-cfg"))
+		pdata->ain1a_ref_cfg = true;
+
+	if (of_property_read_bool(np, "cirrus,ain2a-reference-cfg"))
+		pdata->ain2a_ref_cfg = true;
+
+	if (of_property_read_bool(np, "cirrus,ain1b-reference-cfg"))
+		pdata->ain1b_ref_cfg = true;
+
+	if (of_property_read_bool(np, "cirrus,ain2b-reference-cfg"))
+		pdata->ain2b_ref_cfg = true;
+
+	if (of_property_read_u32(np, "cirrus,micbias-lvl", &val32) >= 0)
+		pdata->micbias_lvl = val32;
+
+	if (of_property_read_u32(np, "cirrus,chgfreq-divisor", &val32) >= 0)
+		pdata->chgfreq = val32;
+
+	if (of_property_read_u32(np, "cirrus,adaptive-pwr-cfg", &val32) >= 0)
+		pdata->adaptive_pwr = val32;
+
+	if (of_property_read_u32(np, "cirrus,hpf-left-freq", &val32) >= 0)
+		pdata->hpfa_freq = val32;
+
+	if (of_property_read_u32(np, "cirrus,hpf-left-freq", &val32) >= 0)
+		pdata->hpfb_freq = val32;
+
+	pdata->gpio_nreset = of_get_named_gpio(np, "cirrus,gpio-nreset", 0);
+
+	return 0;
+}
+
+static int cs42l56_i2c_probe(struct i2c_client *i2c_client,
+			     const struct i2c_device_id *id)
+{
+	struct cs42l56_private *cs42l56;
+	struct cs42l56_platform_data *pdata =
+		dev_get_platdata(&i2c_client->dev);
+	int ret, i;
+	unsigned int devid = 0;
+	unsigned int alpha_rev, metal_rev;
+	unsigned int reg;
+
+	cs42l56 = devm_kzalloc(&i2c_client->dev,
+			       sizeof(struct cs42l56_private),
+			       GFP_KERNEL);
+	if (cs42l56 == NULL)
+		return -ENOMEM;
+	cs42l56->dev = &i2c_client->dev;
+
+	cs42l56->regmap = devm_regmap_init_i2c(i2c_client, &cs42l56_regmap);
+	if (IS_ERR(cs42l56->regmap)) {
+		ret = PTR_ERR(cs42l56->regmap);
+		dev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);
+		return ret;
+	}
+
+	if (pdata) {
+		cs42l56->pdata = *pdata;
+	} else {
+		pdata = devm_kzalloc(&i2c_client->dev,
+				     sizeof(struct cs42l56_platform_data),
+				     GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&i2c_client->dev,
+				"could not allocate pdata\n");
+			return -ENOMEM;
+		}
+		if (i2c_client->dev.of_node) {
+			ret = cs42l56_handle_of_data(i2c_client,
+						     &cs42l56->pdata);
+			if (ret != 0)
+				return ret;
+		}
+		cs42l56->pdata = *pdata;
+	}
+
+	if (cs42l56->pdata.gpio_nreset) {
+		ret = gpio_request_one(cs42l56->pdata.gpio_nreset,
+				       GPIOF_OUT_INIT_HIGH, "CS42L56 /RST");
+		if (ret < 0) {
+			dev_err(&i2c_client->dev,
+				"Failed to request /RST %d: %d\n",
+				cs42l56->pdata.gpio_nreset, ret);
+			return ret;
+		}
+		gpio_set_value_cansleep(cs42l56->pdata.gpio_nreset, 0);
+		gpio_set_value_cansleep(cs42l56->pdata.gpio_nreset, 1);
+	}
+
+
+	i2c_set_clientdata(i2c_client, cs42l56);
+
+	for (i = 0; i < ARRAY_SIZE(cs42l56->supplies); i++)
+		cs42l56->supplies[i].supply = cs42l56_supply_names[i];
+
+	ret = devm_regulator_bulk_get(&i2c_client->dev,
+				      ARRAY_SIZE(cs42l56->supplies),
+				      cs42l56->supplies);
+	if (ret != 0) {
+		dev_err(&i2c_client->dev,
+			"Failed to request supplies: %d\n", ret);
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(cs42l56->supplies),
+				    cs42l56->supplies);
+	if (ret != 0) {
+		dev_err(&i2c_client->dev,
+			"Failed to enable supplies: %d\n", ret);
+		return ret;
+	}
+
+	regcache_cache_bypass(cs42l56->regmap, true);
+
+	ret = regmap_read(cs42l56->regmap, CS42L56_CHIP_ID_1, &reg);
+	devid = reg & CS42L56_CHIP_ID_MASK;
+	if (devid != CS42L56_DEVID) {
+		dev_err(&i2c_client->dev,
+			"CS42L56 Device ID (%X). Expected %X\n",
+			devid, CS42L56_DEVID);
+		goto err_enable;
+	}
+	alpha_rev = reg & CS42L56_AREV_MASK;
+	metal_rev = reg & CS42L56_MTLREV_MASK;
+
+	dev_info(&i2c_client->dev, "Cirrus Logic CS42L56 ");
+	dev_info(&i2c_client->dev, "Alpha Rev %X Metal Rev %X\n",
+		 alpha_rev, metal_rev);
+
+	regcache_cache_bypass(cs42l56->regmap, false);
+
+	if (cs42l56->pdata.ain1a_ref_cfg)
+		regmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,
+				   CS42L56_AIN1A_REF_MASK, 1);
+
+	if (cs42l56->pdata.ain1b_ref_cfg)
+		regmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,
+				   CS42L56_AIN1B_REF_MASK, 1);
+
+	if (cs42l56->pdata.ain2a_ref_cfg)
+		regmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,
+				   CS42L56_AIN2A_REF_MASK, 1);
+
+	if (cs42l56->pdata.ain2b_ref_cfg)
+		regmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,
+				   CS42L56_AIN2B_REF_MASK, 1);
+
+	if (cs42l56->pdata.micbias_lvl)
+		regmap_update_bits(cs42l56->regmap, CS42L56_GAIN_BIAS_CTL,
+				   CS42L56_MIC_BIAS_MASK,
+				cs42l56->pdata.micbias_lvl);
+
+	if (cs42l56->pdata.chgfreq)
+		regmap_update_bits(cs42l56->regmap, CS42L56_CLASSH_CTL,
+				   CS42L56_CHRG_FREQ_MASK,
+				cs42l56->pdata.chgfreq);
+
+	if (cs42l56->pdata.hpfb_freq)
+		regmap_update_bits(cs42l56->regmap, CS42L56_HPF_CTL,
+				   CS42L56_HPFB_FREQ_MASK,
+				cs42l56->pdata.hpfb_freq);
+
+	if (cs42l56->pdata.hpfa_freq)
+		regmap_update_bits(cs42l56->regmap, CS42L56_HPF_CTL,
+				   CS42L56_HPFA_FREQ_MASK,
+				cs42l56->pdata.hpfa_freq);
+
+	if (cs42l56->pdata.adaptive_pwr)
+		regmap_update_bits(cs42l56->regmap, CS42L56_CLASSH_CTL,
+				   CS42L56_ADAPT_PWR_MASK,
+				cs42l56->pdata.adaptive_pwr);
+
+	ret =  snd_soc_register_codec(&i2c_client->dev,
+			&soc_codec_dev_cs42l56, &cs42l56_dai, 1);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+
+err_enable:
+	regulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),
+			       cs42l56->supplies);
+	return ret;
+}
+
+static int cs42l56_i2c_remove(struct i2c_client *client)
+{
+	struct cs42l56_private *cs42l56 = i2c_get_clientdata(client);
+
+	snd_soc_unregister_codec(&client->dev);
+	regulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),
+			       cs42l56->supplies);
+	return 0;
+}
+
+static const struct of_device_id cs42l56_of_match[] = {
+	{ .compatible = "cirrus,cs42l56", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cs42l56_of_match);
+
+
+static const struct i2c_device_id cs42l56_id[] = {
+	{ "cs42l56", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, cs42l56_id);
+
+static struct i2c_driver cs42l56_i2c_driver = {
+	.driver = {
+		.name = "cs42l56",
+		.owner = THIS_MODULE,
+		.of_match_table = cs42l56_of_match,
+	},
+	.id_table = cs42l56_id,
+	.probe =    cs42l56_i2c_probe,
+	.remove =   cs42l56_i2c_remove,
+};
+
+module_i2c_driver(cs42l56_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC CS42L56 driver");
+MODULE_AUTHOR("Brian Austin, Cirrus Logic Inc, <brian.austin@cirrus.com>");
+MODULE_LICENSE("GPL");
