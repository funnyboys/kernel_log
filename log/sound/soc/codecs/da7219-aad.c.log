commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index e0964b20a389..4f2a96e9fd45 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * da7219-aad.c - Dialog DA7219 ALSA SoC AAD Driver
  *
  * Copyright (c) 2015 Dialog Semiconductor Ltd.
  *
  * Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 
 #include <linux/module.h>

commit 123c3def3bc5ea9958b8191d8139f610ed972d18
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Jan 4 20:02:46 2019 -0600

    ASoC: da7219: fix endianness issues
    
    Reported by Sparse.
    
    da7219.c:440:44: warning: cast to restricted __le16
    da7219.c:461:13: warning: incorrect type in assignment (different base types)
    da7219.c:461:13:    expected unsigned short [unsigned] [usertype] val
    da7219.c:461:13:    got restricted __le16 [usertype] <noident>
    da7219.c:1451:16: warning: incorrect type in assignment (different base types)
    da7219.c:1451:16:    expected unsigned short [unsigned] [usertype] offset
    da7219.c:1451:16:    got restricted __le16 [usertype] <noident>
    
    da7219-aad.c:150:37: warning: incorrect type in assignment (different base types)
    da7219-aad.c:150:37:    expected unsigned short [unsigned] [usertype] tonegen_freq_hptest
    da7219-aad.c:150:37:    got restricted __le16 [usertype] <noident>
    da7219-aad.c:157:37: warning: incorrect type in assignment (different base types)
    da7219-aad.c:157:37:    expected unsigned short [unsigned] [usertype] tonegen_freq_hptest
    da7219-aad.c:157:37:    got restricted __le16 [usertype] <noident>
    
    Cc: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index 2c7d5088e6f2..e0964b20a389 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -117,7 +117,7 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 
-	u16 tonegen_freq_hptest;
+	__le16 tonegen_freq_hptest;
 	u8 pll_srm_sts, pll_ctrl, gain_ramp_ctrl, accdet_cfg8;
 	int report = 0, ret = 0;
 

commit 17c81d2f5a59929c73a2a19fd49fe0b068fda76f
Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
Date:   Thu Aug 9 10:48:50 2018 +0100

    ASoC: da7219: Add delays to capture path to remove DC offset noise
    
    On some platforms it has been noted that a pop noise can be
    witnessed when capturing audio, mainly for first time after a
    headset jack has been inserted. This is due to a DC offset in the
    Mic PGA and so to avoid this delays are required when powering
    up the capture path.
    
    This commit rectifies the problem by adding delays post Mic PGA and
    post Mixin PGA. The post Mic PGA delay is determined based on
    Mic Bias voltage, and is only applied the first time after a
    headset jack is inserted.
    
    Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index a49ab751a036..2c7d5088e6f2 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -59,6 +59,7 @@ static void da7219_aad_btn_det_work(struct work_struct *work)
 		container_of(work, struct da7219_aad_priv, btn_det_work);
 	struct snd_soc_component *component = da7219_aad->component;
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 	u8 statusa, micbias_ctrl;
 	bool micbias_up = false;
 	int retries = 0;
@@ -86,6 +87,8 @@ static void da7219_aad_btn_det_work(struct work_struct *work)
 	if (retries >= DA7219_AAD_MICBIAS_CHK_RETRIES)
 		dev_warn(component->dev, "Mic bias status check timed out");
 
+	da7219->micbias_on_event = true;
+
 	/*
 	 * Mic bias pulse required to enable mic, must be done before enabling
 	 * button detection to prevent erroneous button readings.
@@ -439,6 +442,8 @@ static irqreturn_t da7219_aad_irq_thread(int irq, void *data)
 			snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,
 					    DA7219_BUTTON_CONFIG_MASK, 0);
 
+			da7219->micbias_on_event = false;
+
 			/* Disable mic bias */
 			snd_soc_dapm_disable_pin(dapm, "Mic Bias");
 			snd_soc_dapm_sync(dapm);

commit 4510112217116d97df02121d3e1442858efb4897
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 29 04:36:54 2018 +0000

    ASoC: hdac_hdmi/nau8825/rt286/rt298/rt5663/da7219: replace codec to component
    
    Now we can replace Codec to Component. Let's do it.
    
    Because intal/rockchip boards are using multi-codecs in 1 driver,
    we need to update these all related drivers in same time.
    Otherwise compile error/warning happen
    
    Note:
    
    hdac_hdmi
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 1      ->      .idle_bias_on = 0
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    nau8825
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 0      ->      .idle_bias_on = 1
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    rt286
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 1      ->      .idle_bias_on = 0
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    rt298
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 1      ->      .idle_bias_on = 0
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    rt5663
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 1      ->      .idle_bias_on = 0
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    da7219
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 0      ->      .idle_bias_on = 1
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index 1d1d10dd92ae..a49ab751a036 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -32,9 +32,9 @@
  * Detection control
  */
 
-void da7219_aad_jack_det(struct snd_soc_codec *codec, struct snd_soc_jack *jack)
+void da7219_aad_jack_det(struct snd_soc_component *component, struct snd_soc_jack *jack)
 {
-	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 
 	da7219->aad->jack = jack;
 	da7219->aad->jack_inserted = false;
@@ -43,7 +43,7 @@ void da7219_aad_jack_det(struct snd_soc_codec *codec, struct snd_soc_jack *jack)
 	snd_soc_jack_report(jack, 0, DA7219_AAD_REPORT_ALL_MASK);
 
 	/* Enable/Disable jack detection */
-	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+	snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,
 			    DA7219_ACCDET_EN_MASK,
 			    (jack ? DA7219_ACCDET_EN_MASK : 0));
 }
@@ -57,17 +57,17 @@ static void da7219_aad_btn_det_work(struct work_struct *work)
 {
 	struct da7219_aad_priv *da7219_aad =
 		container_of(work, struct da7219_aad_priv, btn_det_work);
-	struct snd_soc_codec *codec = da7219_aad->codec;
-	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	struct snd_soc_component *component = da7219_aad->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	u8 statusa, micbias_ctrl;
 	bool micbias_up = false;
 	int retries = 0;
 
 	/* Drive headphones/lineout */
-	snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+	snd_soc_component_update_bits(component, DA7219_HP_L_CTRL,
 			    DA7219_HP_L_AMP_OE_MASK,
 			    DA7219_HP_L_AMP_OE_MASK);
-	snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+	snd_soc_component_update_bits(component, DA7219_HP_R_CTRL,
 			    DA7219_HP_R_AMP_OE_MASK,
 			    DA7219_HP_R_AMP_OE_MASK);
 
@@ -76,7 +76,7 @@ static void da7219_aad_btn_det_work(struct work_struct *work)
 	snd_soc_dapm_sync(dapm);
 
 	do {
-		statusa = snd_soc_read(codec, DA7219_ACCDET_STATUS_A);
+		statusa = snd_soc_component_read32(component, DA7219_ACCDET_STATUS_A);
 		if (statusa & DA7219_MICBIAS_UP_STS_MASK)
 			micbias_up = true;
 		else if (retries++ < DA7219_AAD_MICBIAS_CHK_RETRIES)
@@ -84,7 +84,7 @@ static void da7219_aad_btn_det_work(struct work_struct *work)
 	} while ((!micbias_up) && (retries < DA7219_AAD_MICBIAS_CHK_RETRIES));
 
 	if (retries >= DA7219_AAD_MICBIAS_CHK_RETRIES)
-		dev_warn(codec->dev, "Mic bias status check timed out");
+		dev_warn(component->dev, "Mic bias status check timed out");
 
 	/*
 	 * Mic bias pulse required to enable mic, must be done before enabling
@@ -92,16 +92,16 @@ static void da7219_aad_btn_det_work(struct work_struct *work)
 	 */
 	if (da7219_aad->micbias_pulse_lvl && da7219_aad->micbias_pulse_time) {
 		/* Pulse higher level voltage */
-		micbias_ctrl = snd_soc_read(codec, DA7219_MICBIAS_CTRL);
-		snd_soc_update_bits(codec, DA7219_MICBIAS_CTRL,
+		micbias_ctrl = snd_soc_component_read32(component, DA7219_MICBIAS_CTRL);
+		snd_soc_component_update_bits(component, DA7219_MICBIAS_CTRL,
 				    DA7219_MICBIAS1_LEVEL_MASK,
 				    da7219_aad->micbias_pulse_lvl);
 		msleep(da7219_aad->micbias_pulse_time);
-		snd_soc_write(codec, DA7219_MICBIAS_CTRL, micbias_ctrl);
+		snd_soc_component_write(component, DA7219_MICBIAS_CTRL, micbias_ctrl);
 
 	}
 
-	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+	snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,
 			    DA7219_BUTTON_CONFIG_MASK,
 			    da7219_aad->btn_cfg);
 }
@@ -110,9 +110,9 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 {
 	struct da7219_aad_priv *da7219_aad =
 		container_of(work, struct da7219_aad_priv, hptest_work);
-	struct snd_soc_codec *codec = da7219_aad->codec;
-	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
-	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = da7219_aad->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 
 	u16 tonegen_freq_hptest;
 	u8 pll_srm_sts, pll_ctrl, gain_ramp_ctrl, accdet_cfg8;
@@ -127,7 +127,7 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	if (da7219->mclk) {
 		ret = clk_prepare_enable(da7219->mclk);
 		if (ret) {
-			dev_err(codec->dev, "Failed to enable mclk - %d\n", ret);
+			dev_err(component->dev, "Failed to enable mclk - %d\n", ret);
 			mutex_unlock(&da7219->pll_lock);
 			mutex_unlock(&da7219->ctrl_lock);
 			snd_soc_dapm_mutex_unlock(dapm);
@@ -142,90 +142,90 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	 * If MCLK is present, but PLL is not enabled then we enable it here to
 	 * ensure a consistent detection procedure.
 	 */
-	pll_srm_sts = snd_soc_read(codec, DA7219_PLL_SRM_STS);
+	pll_srm_sts = snd_soc_component_read32(component, DA7219_PLL_SRM_STS);
 	if (pll_srm_sts & DA7219_PLL_SRM_STS_MCLK) {
 		tonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ);
 
-		pll_ctrl = snd_soc_read(codec, DA7219_PLL_CTRL);
+		pll_ctrl = snd_soc_component_read32(component, DA7219_PLL_CTRL);
 		if ((pll_ctrl & DA7219_PLL_MODE_MASK) == DA7219_PLL_MODE_BYPASS)
-			da7219_set_pll(codec, DA7219_SYSCLK_PLL,
+			da7219_set_pll(component, DA7219_SYSCLK_PLL,
 				       DA7219_PLL_FREQ_OUT_98304);
 	} else {
 		tonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ_INT_OSC);
 	}
 
 	/* Ensure gain ramping at fastest rate */
-	gain_ramp_ctrl = snd_soc_read(codec, DA7219_GAIN_RAMP_CTRL);
-	snd_soc_write(codec, DA7219_GAIN_RAMP_CTRL, DA7219_GAIN_RAMP_RATE_X8);
+	gain_ramp_ctrl = snd_soc_component_read32(component, DA7219_GAIN_RAMP_CTRL);
+	snd_soc_component_write(component, DA7219_GAIN_RAMP_CTRL, DA7219_GAIN_RAMP_RATE_X8);
 
 	/* Bypass cache so it saves current settings */
 	regcache_cache_bypass(da7219->regmap, true);
 
 	/* Make sure Tone Generator is disabled */
-	snd_soc_write(codec, DA7219_TONE_GEN_CFG1, 0);
+	snd_soc_component_write(component, DA7219_TONE_GEN_CFG1, 0);
 
 	/* Enable HPTest block, 1KOhms check */
-	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_8,
+	snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_8,
 			    DA7219_HPTEST_EN_MASK | DA7219_HPTEST_RES_SEL_MASK,
 			    DA7219_HPTEST_EN_MASK |
 			    DA7219_HPTEST_RES_SEL_1KOHMS);
 
 	/* Set gains to 0db */
-	snd_soc_write(codec, DA7219_DAC_L_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);
-	snd_soc_write(codec, DA7219_DAC_R_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);
-	snd_soc_write(codec, DA7219_HP_L_GAIN, DA7219_HP_AMP_GAIN_0DB);
-	snd_soc_write(codec, DA7219_HP_R_GAIN, DA7219_HP_AMP_GAIN_0DB);
+	snd_soc_component_write(component, DA7219_DAC_L_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);
+	snd_soc_component_write(component, DA7219_DAC_R_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);
+	snd_soc_component_write(component, DA7219_HP_L_GAIN, DA7219_HP_AMP_GAIN_0DB);
+	snd_soc_component_write(component, DA7219_HP_R_GAIN, DA7219_HP_AMP_GAIN_0DB);
 
 	/* Disable DAC filters, EQs and soft mute */
-	snd_soc_update_bits(codec, DA7219_DAC_FILTERS1, DA7219_HPF_MODE_MASK,
+	snd_soc_component_update_bits(component, DA7219_DAC_FILTERS1, DA7219_HPF_MODE_MASK,
 			    0);
-	snd_soc_update_bits(codec, DA7219_DAC_FILTERS4, DA7219_DAC_EQ_EN_MASK,
+	snd_soc_component_update_bits(component, DA7219_DAC_FILTERS4, DA7219_DAC_EQ_EN_MASK,
 			    0);
-	snd_soc_update_bits(codec, DA7219_DAC_FILTERS5,
+	snd_soc_component_update_bits(component, DA7219_DAC_FILTERS5,
 			    DA7219_DAC_SOFTMUTE_EN_MASK, 0);
 
 	/* Enable HP left & right paths */
-	snd_soc_update_bits(codec, DA7219_CP_CTRL, DA7219_CP_EN_MASK,
+	snd_soc_component_update_bits(component, DA7219_CP_CTRL, DA7219_CP_EN_MASK,
 			    DA7219_CP_EN_MASK);
-	snd_soc_update_bits(codec, DA7219_DIG_ROUTING_DAC,
+	snd_soc_component_update_bits(component, DA7219_DIG_ROUTING_DAC,
 			    DA7219_DAC_L_SRC_MASK | DA7219_DAC_R_SRC_MASK,
 			    DA7219_DAC_L_SRC_TONEGEN |
 			    DA7219_DAC_R_SRC_TONEGEN);
-	snd_soc_update_bits(codec, DA7219_DAC_L_CTRL,
+	snd_soc_component_update_bits(component, DA7219_DAC_L_CTRL,
 			    DA7219_DAC_L_EN_MASK | DA7219_DAC_L_MUTE_EN_MASK,
 			    DA7219_DAC_L_EN_MASK);
-	snd_soc_update_bits(codec, DA7219_DAC_R_CTRL,
+	snd_soc_component_update_bits(component, DA7219_DAC_R_CTRL,
 			    DA7219_DAC_R_EN_MASK | DA7219_DAC_R_MUTE_EN_MASK,
 			    DA7219_DAC_R_EN_MASK);
-	snd_soc_update_bits(codec, DA7219_MIXOUT_L_SELECT,
+	snd_soc_component_update_bits(component, DA7219_MIXOUT_L_SELECT,
 			    DA7219_MIXOUT_L_MIX_SELECT_MASK,
 			    DA7219_MIXOUT_L_MIX_SELECT_MASK);
-	snd_soc_update_bits(codec, DA7219_MIXOUT_R_SELECT,
+	snd_soc_component_update_bits(component, DA7219_MIXOUT_R_SELECT,
 			    DA7219_MIXOUT_R_MIX_SELECT_MASK,
 			    DA7219_MIXOUT_R_MIX_SELECT_MASK);
-	snd_soc_update_bits(codec, DA7219_DROUTING_ST_OUTFILT_1L,
+	snd_soc_component_update_bits(component, DA7219_DROUTING_ST_OUTFILT_1L,
 			    DA7219_OUTFILT_ST_1L_SRC_MASK,
 			    DA7219_DMIX_ST_SRC_OUTFILT1L);
-	snd_soc_update_bits(codec, DA7219_DROUTING_ST_OUTFILT_1R,
+	snd_soc_component_update_bits(component, DA7219_DROUTING_ST_OUTFILT_1R,
 			    DA7219_OUTFILT_ST_1R_SRC_MASK,
 			    DA7219_DMIX_ST_SRC_OUTFILT1R);
-	snd_soc_update_bits(codec, DA7219_MIXOUT_L_CTRL,
+	snd_soc_component_update_bits(component, DA7219_MIXOUT_L_CTRL,
 			    DA7219_MIXOUT_L_AMP_EN_MASK,
 			    DA7219_MIXOUT_L_AMP_EN_MASK);
-	snd_soc_update_bits(codec, DA7219_MIXOUT_R_CTRL,
+	snd_soc_component_update_bits(component, DA7219_MIXOUT_R_CTRL,
 			    DA7219_MIXOUT_R_AMP_EN_MASK,
 			    DA7219_MIXOUT_R_AMP_EN_MASK);
-	snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+	snd_soc_component_update_bits(component, DA7219_HP_L_CTRL,
 			    DA7219_HP_L_AMP_OE_MASK | DA7219_HP_L_AMP_EN_MASK,
 			    DA7219_HP_L_AMP_OE_MASK | DA7219_HP_L_AMP_EN_MASK);
-	snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+	snd_soc_component_update_bits(component, DA7219_HP_R_CTRL,
 			    DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK,
 			    DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK);
 	msleep(DA7219_SETTLING_DELAY);
-	snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+	snd_soc_component_update_bits(component, DA7219_HP_L_CTRL,
 			    DA7219_HP_L_AMP_MUTE_EN_MASK |
 			    DA7219_HP_L_AMP_MIN_GAIN_EN_MASK, 0);
-	snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+	snd_soc_component_update_bits(component, DA7219_HP_R_CTRL,
 			    DA7219_HP_R_AMP_MUTE_EN_MASK |
 			    DA7219_HP_R_AMP_MIN_GAIN_EN_MASK, 0);
 
@@ -237,26 +237,26 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 		msleep(DA7219_AAD_HPTEST_INT_OSC_PATH_DELAY);
 
 	/* Configure & start Tone Generator */
-	snd_soc_write(codec, DA7219_TONE_GEN_ON_PER, DA7219_BEEP_ON_PER_MASK);
+	snd_soc_component_write(component, DA7219_TONE_GEN_ON_PER, DA7219_BEEP_ON_PER_MASK);
 	regmap_raw_write(da7219->regmap, DA7219_TONE_GEN_FREQ1_L,
 			 &tonegen_freq_hptest, sizeof(tonegen_freq_hptest));
-	snd_soc_update_bits(codec, DA7219_TONE_GEN_CFG2,
+	snd_soc_component_update_bits(component, DA7219_TONE_GEN_CFG2,
 			    DA7219_SWG_SEL_MASK | DA7219_TONE_GEN_GAIN_MASK,
 			    DA7219_SWG_SEL_SRAMP |
 			    DA7219_TONE_GEN_GAIN_MINUS_15DB);
-	snd_soc_write(codec, DA7219_TONE_GEN_CFG1, DA7219_START_STOPN_MASK);
+	snd_soc_component_write(component, DA7219_TONE_GEN_CFG1, DA7219_START_STOPN_MASK);
 
 	msleep(DA7219_AAD_HPTEST_PERIOD);
 
 	/* Grab comparator reading */
-	accdet_cfg8 = snd_soc_read(codec, DA7219_ACCDET_CONFIG_8);
+	accdet_cfg8 = snd_soc_component_read32(component, DA7219_ACCDET_CONFIG_8);
 	if (accdet_cfg8 & DA7219_HPTEST_COMP_MASK)
 		report |= SND_JACK_HEADPHONE;
 	else
 		report |= SND_JACK_LINEOUT;
 
 	/* Stop tone generator */
-	snd_soc_write(codec, DA7219_TONE_GEN_CFG1, 0);
+	snd_soc_component_write(component, DA7219_TONE_GEN_CFG1, 0);
 
 	msleep(DA7219_AAD_HPTEST_PERIOD);
 
@@ -294,7 +294,7 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	regcache_cache_bypass(da7219->regmap, false);
 
 	/* Disable HPTest block */
-	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_8,
+	snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_8,
 			    DA7219_HPTEST_EN_MASK, 0);
 
 	/*
@@ -305,18 +305,18 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 		msleep(DA7219_AAD_HPTEST_INT_OSC_PATH_DELAY);
 
 	/* Restore gain ramping rate */
-	snd_soc_write(codec, DA7219_GAIN_RAMP_CTRL, gain_ramp_ctrl);
+	snd_soc_component_write(component, DA7219_GAIN_RAMP_CTRL, gain_ramp_ctrl);
 
 	/* Drive Headphones/lineout */
-	snd_soc_update_bits(codec, DA7219_HP_L_CTRL, DA7219_HP_L_AMP_OE_MASK,
+	snd_soc_component_update_bits(component, DA7219_HP_L_CTRL, DA7219_HP_L_AMP_OE_MASK,
 			    DA7219_HP_L_AMP_OE_MASK);
-	snd_soc_update_bits(codec, DA7219_HP_R_CTRL, DA7219_HP_R_AMP_OE_MASK,
+	snd_soc_component_update_bits(component, DA7219_HP_R_CTRL, DA7219_HP_R_AMP_OE_MASK,
 			    DA7219_HP_R_AMP_OE_MASK);
 
 	/* Restore PLL to previous configuration, if re-configured */
 	if ((pll_srm_sts & DA7219_PLL_SRM_STS_MCLK) &&
 	    ((pll_ctrl & DA7219_PLL_MODE_MASK) == DA7219_PLL_MODE_BYPASS))
-		da7219_set_pll(codec, DA7219_SYSCLK_MCLK, 0);
+		da7219_set_pll(component, DA7219_SYSCLK_MCLK, 0);
 
 	/* Remove MCLK, if previously enabled */
 	if (da7219->mclk)
@@ -343,9 +343,9 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 static irqreturn_t da7219_aad_irq_thread(int irq, void *data)
 {
 	struct da7219_aad_priv *da7219_aad = data;
-	struct snd_soc_codec *codec = da7219_aad->codec;
-	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
-	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = da7219_aad->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 	u8 events[DA7219_AAD_IRQ_REG_MAX];
 	u8 statusa;
 	int i, report = 0, mask = 0;
@@ -358,13 +358,13 @@ static irqreturn_t da7219_aad_irq_thread(int irq, void *data)
 		return IRQ_NONE;
 
 	/* Read status register for jack insertion & type status */
-	statusa = snd_soc_read(codec, DA7219_ACCDET_STATUS_A);
+	statusa = snd_soc_component_read32(component, DA7219_ACCDET_STATUS_A);
 
 	/* Clear events */
 	regmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_EVENT_A,
 			  events, DA7219_AAD_IRQ_REG_MAX);
 
-	dev_dbg(codec->dev, "IRQ events = 0x%x|0x%x, status = 0x%x\n",
+	dev_dbg(component->dev, "IRQ events = 0x%x|0x%x, status = 0x%x\n",
 		events[DA7219_AAD_IRQ_REG_A], events[DA7219_AAD_IRQ_REG_B],
 		statusa);
 
@@ -430,13 +430,13 @@ static irqreturn_t da7219_aad_irq_thread(int irq, void *data)
 			da7219_aad->jack_inserted = false;
 
 			/* Un-drive headphones/lineout */
-			snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+			snd_soc_component_update_bits(component, DA7219_HP_R_CTRL,
 					    DA7219_HP_R_AMP_OE_MASK, 0);
-			snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+			snd_soc_component_update_bits(component, DA7219_HP_L_CTRL,
 					    DA7219_HP_L_AMP_OE_MASK, 0);
 
 			/* Ensure button detection disabled */
-			snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+			snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,
 					    DA7219_BUTTON_CONFIG_MASK, 0);
 
 			/* Disable mic bias */
@@ -459,7 +459,7 @@ static irqreturn_t da7219_aad_irq_thread(int irq, void *data)
  */
 
 static enum da7219_aad_micbias_pulse_lvl
-	da7219_aad_fw_micbias_pulse_lvl(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_micbias_pulse_lvl(struct snd_soc_component *component, u32 val)
 {
 	switch (val) {
 	case 2800:
@@ -467,13 +467,13 @@ static enum da7219_aad_micbias_pulse_lvl
 	case 2900:
 		return DA7219_AAD_MICBIAS_PULSE_LVL_2_9V;
 	default:
-		dev_warn(codec->dev, "Invalid micbias pulse level");
+		dev_warn(component->dev, "Invalid micbias pulse level");
 		return DA7219_AAD_MICBIAS_PULSE_LVL_OFF;
 	}
 }
 
 static enum da7219_aad_btn_cfg
-	da7219_aad_fw_btn_cfg(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_btn_cfg(struct snd_soc_component *component, u32 val)
 {
 	switch (val) {
 	case 2:
@@ -491,13 +491,13 @@ static enum da7219_aad_btn_cfg
 	case 500:
 		return DA7219_AAD_BTN_CFG_500MS;
 	default:
-		dev_warn(codec->dev, "Invalid button config");
+		dev_warn(component->dev, "Invalid button config");
 		return DA7219_AAD_BTN_CFG_10MS;
 	}
 }
 
 static enum da7219_aad_mic_det_thr
-	da7219_aad_fw_mic_det_thr(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_mic_det_thr(struct snd_soc_component *component, u32 val)
 {
 	switch (val) {
 	case 200:
@@ -509,13 +509,13 @@ static enum da7219_aad_mic_det_thr
 	case 1000:
 		return DA7219_AAD_MIC_DET_THR_1000_OHMS;
 	default:
-		dev_warn(codec->dev, "Invalid mic detect threshold");
+		dev_warn(component->dev, "Invalid mic detect threshold");
 		return DA7219_AAD_MIC_DET_THR_500_OHMS;
 	}
 }
 
 static enum da7219_aad_jack_ins_deb
-	da7219_aad_fw_jack_ins_deb(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_jack_ins_deb(struct snd_soc_component *component, u32 val)
 {
 	switch (val) {
 	case 5:
@@ -535,13 +535,13 @@ static enum da7219_aad_jack_ins_deb
 	case 1000:
 		return DA7219_AAD_JACK_INS_DEB_1S;
 	default:
-		dev_warn(codec->dev, "Invalid jack insert debounce");
+		dev_warn(component->dev, "Invalid jack insert debounce");
 		return DA7219_AAD_JACK_INS_DEB_20MS;
 	}
 }
 
 static enum da7219_aad_jack_det_rate
-	da7219_aad_fw_jack_det_rate(struct snd_soc_codec *codec, const char *str)
+	da7219_aad_fw_jack_det_rate(struct snd_soc_component *component, const char *str)
 {
 	if (!strcmp(str, "32ms_64ms")) {
 		return DA7219_AAD_JACK_DET_RATE_32_64MS;
@@ -552,13 +552,13 @@ static enum da7219_aad_jack_det_rate
 	} else if (!strcmp(str, "256ms_512ms")) {
 		return DA7219_AAD_JACK_DET_RATE_256_512MS;
 	} else {
-		dev_warn(codec->dev, "Invalid jack detect rate");
+		dev_warn(component->dev, "Invalid jack detect rate");
 		return DA7219_AAD_JACK_DET_RATE_256_512MS;
 	}
 }
 
 static enum da7219_aad_jack_rem_deb
-	da7219_aad_fw_jack_rem_deb(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_jack_rem_deb(struct snd_soc_component *component, u32 val)
 {
 	switch (val) {
 	case 1:
@@ -570,13 +570,13 @@ static enum da7219_aad_jack_rem_deb
 	case 20:
 		return DA7219_AAD_JACK_REM_DEB_20MS;
 	default:
-		dev_warn(codec->dev, "Invalid jack removal debounce");
+		dev_warn(component->dev, "Invalid jack removal debounce");
 		return DA7219_AAD_JACK_REM_DEB_1MS;
 	}
 }
 
 static enum da7219_aad_btn_avg
-	da7219_aad_fw_btn_avg(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_btn_avg(struct snd_soc_component *component, u32 val)
 {
 	switch (val) {
 	case 1:
@@ -588,13 +588,13 @@ static enum da7219_aad_btn_avg
 	case 8:
 		return DA7219_AAD_BTN_AVG_8;
 	default:
-		dev_warn(codec->dev, "Invalid button average value");
+		dev_warn(component->dev, "Invalid button average value");
 		return DA7219_AAD_BTN_AVG_2;
 	}
 }
 
 static enum da7219_aad_adc_1bit_rpt
-	da7219_aad_fw_adc_1bit_rpt(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_adc_1bit_rpt(struct snd_soc_component *component, u32 val)
 {
 	switch (val) {
 	case 1:
@@ -606,14 +606,14 @@ static enum da7219_aad_adc_1bit_rpt
 	case 8:
 		return DA7219_AAD_ADC_1BIT_RPT_8;
 	default:
-		dev_warn(codec->dev, "Invalid ADC 1-bit repeat value");
+		dev_warn(component->dev, "Invalid ADC 1-bit repeat value");
 		return DA7219_AAD_ADC_1BIT_RPT_1;
 	}
 }
 
-static struct da7219_aad_pdata *da7219_aad_fw_to_pdata(struct snd_soc_codec *codec)
+static struct da7219_aad_pdata *da7219_aad_fw_to_pdata(struct snd_soc_component *component)
 {
-	struct device *dev = codec->dev;
+	struct device *dev = component->dev;
 	struct i2c_client *i2c = to_i2c_client(dev);
 	struct fwnode_handle *aad_np;
 	struct da7219_aad_pdata *aad_pdata;
@@ -624,7 +624,7 @@ static struct da7219_aad_pdata *da7219_aad_fw_to_pdata(struct snd_soc_codec *cod
 	if (!aad_np)
 		return NULL;
 
-	aad_pdata = devm_kzalloc(codec->dev, sizeof(*aad_pdata), GFP_KERNEL);
+	aad_pdata = devm_kzalloc(dev, sizeof(*aad_pdata), GFP_KERNEL);
 	if (!aad_pdata)
 		return NULL;
 
@@ -633,7 +633,7 @@ static struct da7219_aad_pdata *da7219_aad_fw_to_pdata(struct snd_soc_codec *cod
 	if (fwnode_property_read_u32(aad_np, "dlg,micbias-pulse-lvl",
 				     &fw_val32) >= 0)
 		aad_pdata->micbias_pulse_lvl =
-			da7219_aad_fw_micbias_pulse_lvl(codec, fw_val32);
+			da7219_aad_fw_micbias_pulse_lvl(component, fw_val32);
 	else
 		aad_pdata->micbias_pulse_lvl = DA7219_AAD_MICBIAS_PULSE_LVL_OFF;
 
@@ -642,31 +642,31 @@ static struct da7219_aad_pdata *da7219_aad_fw_to_pdata(struct snd_soc_codec *cod
 		aad_pdata->micbias_pulse_time = fw_val32;
 
 	if (fwnode_property_read_u32(aad_np, "dlg,btn-cfg", &fw_val32) >= 0)
-		aad_pdata->btn_cfg = da7219_aad_fw_btn_cfg(codec, fw_val32);
+		aad_pdata->btn_cfg = da7219_aad_fw_btn_cfg(component, fw_val32);
 	else
 		aad_pdata->btn_cfg = DA7219_AAD_BTN_CFG_10MS;
 
 	if (fwnode_property_read_u32(aad_np, "dlg,mic-det-thr", &fw_val32) >= 0)
 		aad_pdata->mic_det_thr =
-			da7219_aad_fw_mic_det_thr(codec, fw_val32);
+			da7219_aad_fw_mic_det_thr(component, fw_val32);
 	else
 		aad_pdata->mic_det_thr = DA7219_AAD_MIC_DET_THR_500_OHMS;
 
 	if (fwnode_property_read_u32(aad_np, "dlg,jack-ins-deb", &fw_val32) >= 0)
 		aad_pdata->jack_ins_deb =
-			da7219_aad_fw_jack_ins_deb(codec, fw_val32);
+			da7219_aad_fw_jack_ins_deb(component, fw_val32);
 	else
 		aad_pdata->jack_ins_deb = DA7219_AAD_JACK_INS_DEB_20MS;
 
 	if (!fwnode_property_read_string(aad_np, "dlg,jack-det-rate", &fw_str))
 		aad_pdata->jack_det_rate =
-			da7219_aad_fw_jack_det_rate(codec, fw_str);
+			da7219_aad_fw_jack_det_rate(component, fw_str);
 	else
 		aad_pdata->jack_det_rate = DA7219_AAD_JACK_DET_RATE_256_512MS;
 
 	if (fwnode_property_read_u32(aad_np, "dlg,jack-rem-deb", &fw_val32) >= 0)
 		aad_pdata->jack_rem_deb =
-			da7219_aad_fw_jack_rem_deb(codec, fw_val32);
+			da7219_aad_fw_jack_rem_deb(component, fw_val32);
 	else
 		aad_pdata->jack_rem_deb = DA7219_AAD_JACK_REM_DEB_1MS;
 
@@ -691,22 +691,22 @@ static struct da7219_aad_pdata *da7219_aad_fw_to_pdata(struct snd_soc_codec *cod
 		aad_pdata->c_mic_btn_thr = 0x3E;
 
 	if (fwnode_property_read_u32(aad_np, "dlg,btn-avg", &fw_val32) >= 0)
-		aad_pdata->btn_avg = da7219_aad_fw_btn_avg(codec, fw_val32);
+		aad_pdata->btn_avg = da7219_aad_fw_btn_avg(component, fw_val32);
 	else
 		aad_pdata->btn_avg = DA7219_AAD_BTN_AVG_2;
 
 	if (fwnode_property_read_u32(aad_np, "dlg,adc-1bit-rpt", &fw_val32) >= 0)
 		aad_pdata->adc_1bit_rpt =
-			da7219_aad_fw_adc_1bit_rpt(codec, fw_val32);
+			da7219_aad_fw_adc_1bit_rpt(component, fw_val32);
 	else
 		aad_pdata->adc_1bit_rpt = DA7219_AAD_ADC_1BIT_RPT_1;
 
 	return aad_pdata;
 }
 
-static void da7219_aad_handle_pdata(struct snd_soc_codec *codec)
+static void da7219_aad_handle_pdata(struct snd_soc_component *component)
 {
-	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 	struct da7219_aad_priv *da7219_aad = da7219->aad;
 	struct da7219_pdata *pdata = da7219->pdata;
 
@@ -752,7 +752,7 @@ static void da7219_aad_handle_pdata(struct snd_soc_codec *codec)
 				DA7219_MIC_DET_THRESH_SHIFT);
 			mask |= DA7219_MIC_DET_THRESH_MASK;
 		}
-		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1, mask, cfg);
+		snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1, mask, cfg);
 
 		cfg = 0;
 		mask = 0;
@@ -787,15 +787,15 @@ static void da7219_aad_handle_pdata(struct snd_soc_codec *codec)
 				DA7219_JACKDET_REM_DEB_SHIFT);
 			mask |= DA7219_JACKDET_REM_DEB_MASK;
 		}
-		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_2, mask, cfg);
+		snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_2, mask, cfg);
 
-		snd_soc_write(codec, DA7219_ACCDET_CONFIG_3,
+		snd_soc_component_write(component, DA7219_ACCDET_CONFIG_3,
 			      aad_pdata->a_d_btn_thr);
-		snd_soc_write(codec, DA7219_ACCDET_CONFIG_4,
+		snd_soc_component_write(component, DA7219_ACCDET_CONFIG_4,
 			      aad_pdata->d_b_btn_thr);
-		snd_soc_write(codec, DA7219_ACCDET_CONFIG_5,
+		snd_soc_component_write(component, DA7219_ACCDET_CONFIG_5,
 			      aad_pdata->b_c_btn_thr);
-		snd_soc_write(codec, DA7219_ACCDET_CONFIG_6,
+		snd_soc_component_write(component, DA7219_ACCDET_CONFIG_6,
 			      aad_pdata->c_mic_btn_thr);
 
 		cfg = 0;
@@ -818,7 +818,7 @@ static void da7219_aad_handle_pdata(struct snd_soc_codec *codec)
 			       DA7219_ADC_1_BIT_REPEAT_SHIFT);
 			mask |= DA7219_ADC_1_BIT_REPEAT_MASK;
 		}
-		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_7, mask, cfg);
+		snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_7, mask, cfg);
 	}
 }
 
@@ -827,16 +827,16 @@ static void da7219_aad_handle_pdata(struct snd_soc_codec *codec)
  * Suspend/Resume
  */
 
-void da7219_aad_suspend(struct snd_soc_codec *codec)
+void da7219_aad_suspend(struct snd_soc_component *component)
 {
-	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 	struct da7219_aad_priv *da7219_aad = da7219->aad;
-	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	u8 micbias_ctrl;
 
 	if (da7219_aad->jack) {
 		/* Disable jack detection during suspend */
-		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+		snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,
 				    DA7219_ACCDET_EN_MASK, 0);
 
 		/*
@@ -846,7 +846,7 @@ void da7219_aad_suspend(struct snd_soc_codec *codec)
 		 * suspend then this will be dealt with through the IRQ handler.
 		 */
 		if (da7219_aad->jack_inserted) {
-			micbias_ctrl = snd_soc_read(codec, DA7219_MICBIAS_CTRL);
+			micbias_ctrl = snd_soc_component_read32(component, DA7219_MICBIAS_CTRL);
 			if (micbias_ctrl & DA7219_MICBIAS1_EN_MASK) {
 				snd_soc_dapm_disable_pin(dapm, "Mic Bias");
 				snd_soc_dapm_sync(dapm);
@@ -856,11 +856,11 @@ void da7219_aad_suspend(struct snd_soc_codec *codec)
 	}
 }
 
-void da7219_aad_resume(struct snd_soc_codec *codec)
+void da7219_aad_resume(struct snd_soc_component *component)
 {
-	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 	struct da7219_aad_priv *da7219_aad = da7219->aad;
-	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 
 	if (da7219_aad->jack) {
 		/* Re-enable micbias if previously enabled for 4-pole jack */
@@ -872,7 +872,7 @@ void da7219_aad_resume(struct snd_soc_codec *codec)
 		}
 
 		/* Re-enable jack detection */
-		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+		snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,
 				    DA7219_ACCDET_EN_MASK,
 				    DA7219_ACCDET_EN_MASK);
 	}
@@ -883,28 +883,28 @@ void da7219_aad_resume(struct snd_soc_codec *codec)
  * Init/Exit
  */
 
-int da7219_aad_init(struct snd_soc_codec *codec)
+int da7219_aad_init(struct snd_soc_component *component)
 {
-	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 	struct da7219_aad_priv *da7219_aad;
 	u8 mask[DA7219_AAD_IRQ_REG_MAX];
 	int ret;
 
-	da7219_aad = devm_kzalloc(codec->dev, sizeof(*da7219_aad), GFP_KERNEL);
+	da7219_aad = devm_kzalloc(component->dev, sizeof(*da7219_aad), GFP_KERNEL);
 	if (!da7219_aad)
 		return -ENOMEM;
 
 	da7219->aad = da7219_aad;
-	da7219_aad->codec = codec;
+	da7219_aad->component = component;
 
 	/* Handle any DT/ACPI/platform data */
 	if (da7219->pdata && !da7219->pdata->aad_pdata)
-		da7219->pdata->aad_pdata = da7219_aad_fw_to_pdata(codec);
+		da7219->pdata->aad_pdata = da7219_aad_fw_to_pdata(component);
 
-	da7219_aad_handle_pdata(codec);
+	da7219_aad_handle_pdata(component);
 
 	/* Disable button detection */
-	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+	snd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,
 			    DA7219_BUTTON_CONFIG_MASK, 0);
 
 	INIT_WORK(&da7219_aad->btn_det_work, da7219_aad_btn_det_work);
@@ -915,7 +915,7 @@ int da7219_aad_init(struct snd_soc_codec *codec)
 				   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
 				   "da7219-aad", da7219_aad);
 	if (ret) {
-		dev_err(codec->dev, "Failed to request IRQ: %d\n", ret);
+		dev_err(component->dev, "Failed to request IRQ: %d\n", ret);
 		return ret;
 	}
 
@@ -928,9 +928,9 @@ int da7219_aad_init(struct snd_soc_codec *codec)
 }
 EXPORT_SYMBOL_GPL(da7219_aad_init);
 
-void da7219_aad_exit(struct snd_soc_codec *codec)
+void da7219_aad_exit(struct snd_soc_component *component)
 {
-	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 	struct da7219_aad_priv *da7219_aad = da7219->aad;
 	u8 mask[DA7219_AAD_IRQ_REG_MAX];
 

commit 2a0c2189d8170d52da64543cbf955f0908c15e70
Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
Date:   Mon Jun 19 10:56:33 2017 +0100

    ASoC: da7219: Fix HP detection procedure for all MCLK frequencies
    
    Currently when HP detection procedure runs for certain MCLK
    frequencies, when PLL is bypassed, the procedure will incorrectly
    report Lineout instead of Headphones due to timing incosistencies.
    To avoid this problem, the PLL is temporarily enabled (if currently
    bypassed and MCLK present) to provide consistent timings for the
    procedure, regardless of MCLK frequency.
    
    Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Acked-by: Sathyanarayana Nujella <sathyanarayana.nujella@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index 6274d79c1353..1d1d10dd92ae 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -115,19 +115,21 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
 
 	u16 tonegen_freq_hptest;
-	u8 pll_srm_sts, gain_ramp_ctrl, accdet_cfg8;
+	u8 pll_srm_sts, pll_ctrl, gain_ramp_ctrl, accdet_cfg8;
 	int report = 0, ret = 0;
 
-	/* Lock DAPM and any Kcontrols that are affected by this test */
+	/* Lock DAPM, Kcontrols affected by this test and the PLL */
 	snd_soc_dapm_mutex_lock(dapm);
-	mutex_lock(&da7219->lock);
+	mutex_lock(&da7219->ctrl_lock);
+	mutex_lock(&da7219->pll_lock);
 
 	/* Ensure MCLK is available for HP test procedure */
 	if (da7219->mclk) {
 		ret = clk_prepare_enable(da7219->mclk);
 		if (ret) {
 			dev_err(codec->dev, "Failed to enable mclk - %d\n", ret);
-			mutex_unlock(&da7219->lock);
+			mutex_unlock(&da7219->pll_lock);
+			mutex_unlock(&da7219->ctrl_lock);
 			snd_soc_dapm_mutex_unlock(dapm);
 			return;
 		}
@@ -136,12 +138,21 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	/*
 	 * If MCLK not present, then we're using the internal oscillator and
 	 * require different frequency settings to achieve the same result.
+	 *
+	 * If MCLK is present, but PLL is not enabled then we enable it here to
+	 * ensure a consistent detection procedure.
 	 */
 	pll_srm_sts = snd_soc_read(codec, DA7219_PLL_SRM_STS);
-	if (pll_srm_sts & DA7219_PLL_SRM_STS_MCLK)
+	if (pll_srm_sts & DA7219_PLL_SRM_STS_MCLK) {
 		tonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ);
-	else
+
+		pll_ctrl = snd_soc_read(codec, DA7219_PLL_CTRL);
+		if ((pll_ctrl & DA7219_PLL_MODE_MASK) == DA7219_PLL_MODE_BYPASS)
+			da7219_set_pll(codec, DA7219_SYSCLK_PLL,
+				       DA7219_PLL_FREQ_OUT_98304);
+	} else {
 		tonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ_INT_OSC);
+	}
 
 	/* Ensure gain ramping at fastest rate */
 	gain_ramp_ctrl = snd_soc_read(codec, DA7219_GAIN_RAMP_CTRL);
@@ -302,11 +313,17 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	snd_soc_update_bits(codec, DA7219_HP_R_CTRL, DA7219_HP_R_AMP_OE_MASK,
 			    DA7219_HP_R_AMP_OE_MASK);
 
+	/* Restore PLL to previous configuration, if re-configured */
+	if ((pll_srm_sts & DA7219_PLL_SRM_STS_MCLK) &&
+	    ((pll_ctrl & DA7219_PLL_MODE_MASK) == DA7219_PLL_MODE_BYPASS))
+		da7219_set_pll(codec, DA7219_SYSCLK_MCLK, 0);
+
 	/* Remove MCLK, if previously enabled */
 	if (da7219->mclk)
 		clk_disable_unprepare(da7219->mclk);
 
-	mutex_unlock(&da7219->lock);
+	mutex_unlock(&da7219->pll_lock);
+	mutex_unlock(&da7219->ctrl_lock);
 	snd_soc_dapm_mutex_unlock(dapm);
 
 	/*

commit 86834511c2acd23e214d5739e9ea58e31b975d1f
Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
Date:   Mon Oct 3 11:21:01 2016 +0100

    ASoC: da7219: Improve pop/click performance for sensitive HPs
    
    Currently on some headsets slight pops can be heard during DAPM
    power-up/down. This can also be witnessed during the HP detect
    procedure. This patch addresses the issue by adjusting DAPM power
    sequencing slightly, the introduction of delays and use of
    minimum HP gain to avoid such noise artefacts.
    
    Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index 2b8914dd5990..6274d79c1353 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -204,10 +204,19 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	snd_soc_update_bits(codec, DA7219_MIXOUT_R_CTRL,
 			    DA7219_MIXOUT_R_AMP_EN_MASK,
 			    DA7219_MIXOUT_R_AMP_EN_MASK);
-	snd_soc_write(codec, DA7219_HP_L_CTRL,
-		      DA7219_HP_L_AMP_OE_MASK | DA7219_HP_L_AMP_EN_MASK);
-	snd_soc_write(codec, DA7219_HP_R_CTRL,
-		      DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+			    DA7219_HP_L_AMP_OE_MASK | DA7219_HP_L_AMP_EN_MASK,
+			    DA7219_HP_L_AMP_OE_MASK | DA7219_HP_L_AMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+			    DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK,
+			    DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK);
+	msleep(DA7219_SETTLING_DELAY);
+	snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+			    DA7219_HP_L_AMP_MUTE_EN_MASK |
+			    DA7219_HP_L_AMP_MIN_GAIN_EN_MASK, 0);
+	snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+			    DA7219_HP_R_AMP_MUTE_EN_MASK |
+			    DA7219_HP_R_AMP_MIN_GAIN_EN_MASK, 0);
 
 	/*
 	 * If we're running from the internal oscillator then give audio paths
@@ -244,6 +253,7 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	regcache_mark_dirty(da7219->regmap);
 	regcache_sync_region(da7219->regmap, DA7219_HP_L_CTRL,
 			     DA7219_HP_R_CTRL);
+	msleep(DA7219_SETTLING_DELAY);
 	regcache_sync_region(da7219->regmap, DA7219_MIXOUT_L_CTRL,
 			     DA7219_MIXOUT_R_CTRL);
 	regcache_sync_region(da7219->regmap, DA7219_DROUTING_ST_OUTFILT_1L,

commit bb0c35fcaf8f2ad3383dd43ca8abf5203cd06cc3
Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
Date:   Mon Sep 26 14:29:21 2016 +0100

    ASoC: da7219: Disable AAD if codec is not a wake-up source
    
    Currently if AAD is enabled in the device, during system suspend
    the feature remains, regardless of whether the codec is a wake-up
    source or not. This means some additional power is being used
    which is unnecessary, and can causes issues with some platforms'
    IRQ handlers where state changes during system suspend aren't
    captured.
    
    This patch updates the driver to disable AAD during suspend, if
    we're not a wake-up source, and then re-enables this on resume.
    
    Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index fc27dab3d6ba..2b8914dd5990 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -796,6 +796,62 @@ static void da7219_aad_handle_pdata(struct snd_soc_codec *codec)
 }
 
 
+/*
+ * Suspend/Resume
+ */
+
+void da7219_aad_suspend(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_aad_priv *da7219_aad = da7219->aad;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	u8 micbias_ctrl;
+
+	if (da7219_aad->jack) {
+		/* Disable jack detection during suspend */
+		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+				    DA7219_ACCDET_EN_MASK, 0);
+
+		/*
+		 * If we have a 4-pole jack inserted, then micbias will be
+		 * enabled. We can disable micbias here, and keep a note to
+		 * re-enable it on resume. If jack removal occurred during
+		 * suspend then this will be dealt with through the IRQ handler.
+		 */
+		if (da7219_aad->jack_inserted) {
+			micbias_ctrl = snd_soc_read(codec, DA7219_MICBIAS_CTRL);
+			if (micbias_ctrl & DA7219_MICBIAS1_EN_MASK) {
+				snd_soc_dapm_disable_pin(dapm, "Mic Bias");
+				snd_soc_dapm_sync(dapm);
+				da7219_aad->micbias_resume_enable = true;
+			}
+		}
+	}
+}
+
+void da7219_aad_resume(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_aad_priv *da7219_aad = da7219->aad;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+
+	if (da7219_aad->jack) {
+		/* Re-enable micbias if previously enabled for 4-pole jack */
+		if (da7219_aad->jack_inserted &&
+		    da7219_aad->micbias_resume_enable) {
+			snd_soc_dapm_force_enable_pin(dapm, "Mic Bias");
+			snd_soc_dapm_sync(dapm);
+			da7219_aad->micbias_resume_enable = false;
+		}
+
+		/* Re-enable jack detection */
+		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+				    DA7219_ACCDET_EN_MASK,
+				    DA7219_ACCDET_EN_MASK);
+	}
+}
+
+
 /*
  * Init/Exit
  */

commit 6a0b87c6e7f664aff8957e0889f9f82e5ee27f65
Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
Date:   Mon Sep 12 16:46:50 2016 +0100

    ASoC: da7219: Support HP detect procedure when MCLK not present
    
    Currently the driver code assumes that MCLK will be present during
    the procedure, or if it has control of MCLK then it can make sure
    it's enabled. Some platforms however do not provide MCLK to the
    driver in this way, and will not leave MCLK enabled when Codec is
    in STANDBY state.
    
    This patch adds support for the HP detect procedure when running
    from the device's internal oscillator, to ensure all platforms
    can make use of this feature correctly.
    
    Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index 4e369a1c5d88..fc27dab3d6ba 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -115,7 +115,7 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
 
 	u16 tonegen_freq_hptest;
-	u8 accdet_cfg8;
+	u8 pll_srm_sts, gain_ramp_ctrl, accdet_cfg8;
 	int report = 0, ret = 0;
 
 	/* Lock DAPM and any Kcontrols that are affected by this test */
@@ -133,6 +133,20 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 		}
 	}
 
+	/*
+	 * If MCLK not present, then we're using the internal oscillator and
+	 * require different frequency settings to achieve the same result.
+	 */
+	pll_srm_sts = snd_soc_read(codec, DA7219_PLL_SRM_STS);
+	if (pll_srm_sts & DA7219_PLL_SRM_STS_MCLK)
+		tonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ);
+	else
+		tonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ_INT_OSC);
+
+	/* Ensure gain ramping at fastest rate */
+	gain_ramp_ctrl = snd_soc_read(codec, DA7219_GAIN_RAMP_CTRL);
+	snd_soc_write(codec, DA7219_GAIN_RAMP_CTRL, DA7219_GAIN_RAMP_RATE_X8);
+
 	/* Bypass cache so it saves current settings */
 	regcache_cache_bypass(da7219->regmap, true);
 
@@ -195,9 +209,15 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	snd_soc_write(codec, DA7219_HP_R_CTRL,
 		      DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK);
 
+	/*
+	 * If we're running from the internal oscillator then give audio paths
+	 * time to settle before running test.
+	 */
+	if (!(pll_srm_sts & DA7219_PLL_SRM_STS_MCLK))
+		msleep(DA7219_AAD_HPTEST_INT_OSC_PATH_DELAY);
+
 	/* Configure & start Tone Generator */
 	snd_soc_write(codec, DA7219_TONE_GEN_ON_PER, DA7219_BEEP_ON_PER_MASK);
-	tonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ);
 	regmap_raw_write(da7219->regmap, DA7219_TONE_GEN_FREQ1_L,
 			 &tonegen_freq_hptest, sizeof(tonegen_freq_hptest));
 	snd_soc_update_bits(codec, DA7219_TONE_GEN_CFG2,
@@ -256,6 +276,16 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_8,
 			    DA7219_HPTEST_EN_MASK, 0);
 
+	/*
+	 * If we're running from the internal oscillator then give audio paths
+	 * time to settle before allowing headphones to be driven as required.
+	 */
+	if (!(pll_srm_sts & DA7219_PLL_SRM_STS_MCLK))
+		msleep(DA7219_AAD_HPTEST_INT_OSC_PATH_DELAY);
+
+	/* Restore gain ramping rate */
+	snd_soc_write(codec, DA7219_GAIN_RAMP_CTRL, gain_ramp_ctrl);
+
 	/* Drive Headphones/lineout */
 	snd_soc_update_bits(codec, DA7219_HP_L_CTRL, DA7219_HP_L_AMP_OE_MASK,
 			    DA7219_HP_L_AMP_OE_MASK);

commit 40585391fc88d6d66dc479efccba973426c004ab
Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
Date:   Fri Jul 29 14:46:54 2016 +0100

    ASoC: da7219: Make more efficient use of MCLK within driver
    
    Currently, if the driver has control of MCLK then it remains
    enabled as long as the codec is in STANDBY or above. The MCLK is
    only really required in STANDBY when a 3-pole jack is inserted
    and the HP detect procedure is required to run.
    
    This patch updates the code to enable/disable the MCLK when moving
    between the STANDBY and PREPARE bias level, and when a 3-pole jack
    is inserted and HP detection is required, thus saving power at all
    other times.
    
    Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index f0057cd223a4..4e369a1c5d88 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -13,6 +13,7 @@
 
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <linux/i2c.h>
 #include <linux/property.h>
 #include <linux/pm_wakeirq.h>
@@ -115,12 +116,23 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 
 	u16 tonegen_freq_hptest;
 	u8 accdet_cfg8;
-	int report = 0;
+	int report = 0, ret = 0;
 
 	/* Lock DAPM and any Kcontrols that are affected by this test */
 	snd_soc_dapm_mutex_lock(dapm);
 	mutex_lock(&da7219->lock);
 
+	/* Ensure MCLK is available for HP test procedure */
+	if (da7219->mclk) {
+		ret = clk_prepare_enable(da7219->mclk);
+		if (ret) {
+			dev_err(codec->dev, "Failed to enable mclk - %d\n", ret);
+			mutex_unlock(&da7219->lock);
+			snd_soc_dapm_mutex_unlock(dapm);
+			return;
+		}
+	}
+
 	/* Bypass cache so it saves current settings */
 	regcache_cache_bypass(da7219->regmap, true);
 
@@ -250,6 +262,10 @@ static void da7219_aad_hptest_work(struct work_struct *work)
 	snd_soc_update_bits(codec, DA7219_HP_R_CTRL, DA7219_HP_R_AMP_OE_MASK,
 			    DA7219_HP_R_AMP_OE_MASK);
 
+	/* Remove MCLK, if previously enabled */
+	if (da7219->mclk)
+		clk_disable_unprepare(da7219->mclk);
+
 	mutex_unlock(&da7219->lock);
 	snd_soc_dapm_mutex_unlock(dapm);
 

commit a01b89336f7a2f3ee1f98a89ba78c88f5547dc70
Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
Date:   Tue Jun 21 18:50:21 2016 +0100

    ASoC: da7219: Convert driver to use generic device/fwnode functions
    
    This change converts the driver from using the of_* functions to using
    the device_* and fwnode_* functions for accssing FW related data.
    
    Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Acked-by: Sathyanarayana Nujella <sathyanarayana.nujella@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
index 9459593eef13..f0057cd223a4 100644
--- a/sound/soc/codecs/da7219-aad.c
+++ b/sound/soc/codecs/da7219-aad.c
@@ -13,8 +13,8 @@
 
 #include <linux/module.h>
 #include <linux/platform_device.h>
-#include <linux/of_device.h>
-#include <linux/of_irq.h>
+#include <linux/i2c.h>
+#include <linux/property.h>
 #include <linux/pm_wakeirq.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
@@ -382,11 +382,11 @@ static irqreturn_t da7219_aad_irq_thread(int irq, void *data)
 }
 
 /*
- * DT to pdata conversion
+ * DT/ACPI to pdata conversion
  */
 
 static enum da7219_aad_micbias_pulse_lvl
-	da7219_aad_of_micbias_pulse_lvl(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_micbias_pulse_lvl(struct snd_soc_codec *codec, u32 val)
 {
 	switch (val) {
 	case 2800:
@@ -400,7 +400,7 @@ static enum da7219_aad_micbias_pulse_lvl
 }
 
 static enum da7219_aad_btn_cfg
-	da7219_aad_of_btn_cfg(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_btn_cfg(struct snd_soc_codec *codec, u32 val)
 {
 	switch (val) {
 	case 2:
@@ -424,7 +424,7 @@ static enum da7219_aad_btn_cfg
 }
 
 static enum da7219_aad_mic_det_thr
-	da7219_aad_of_mic_det_thr(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_mic_det_thr(struct snd_soc_codec *codec, u32 val)
 {
 	switch (val) {
 	case 200:
@@ -442,7 +442,7 @@ static enum da7219_aad_mic_det_thr
 }
 
 static enum da7219_aad_jack_ins_deb
-	da7219_aad_of_jack_ins_deb(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_jack_ins_deb(struct snd_soc_codec *codec, u32 val)
 {
 	switch (val) {
 	case 5:
@@ -468,7 +468,7 @@ static enum da7219_aad_jack_ins_deb
 }
 
 static enum da7219_aad_jack_det_rate
-	da7219_aad_of_jack_det_rate(struct snd_soc_codec *codec, const char *str)
+	da7219_aad_fw_jack_det_rate(struct snd_soc_codec *codec, const char *str)
 {
 	if (!strcmp(str, "32ms_64ms")) {
 		return DA7219_AAD_JACK_DET_RATE_32_64MS;
@@ -485,7 +485,7 @@ static enum da7219_aad_jack_det_rate
 }
 
 static enum da7219_aad_jack_rem_deb
-	da7219_aad_of_jack_rem_deb(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_jack_rem_deb(struct snd_soc_codec *codec, u32 val)
 {
 	switch (val) {
 	case 1:
@@ -503,7 +503,7 @@ static enum da7219_aad_jack_rem_deb
 }
 
 static enum da7219_aad_btn_avg
-	da7219_aad_of_btn_avg(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_btn_avg(struct snd_soc_codec *codec, u32 val)
 {
 	switch (val) {
 	case 1:
@@ -521,7 +521,7 @@ static enum da7219_aad_btn_avg
 }
 
 static enum da7219_aad_adc_1bit_rpt
-	da7219_aad_of_adc_1bit_rpt(struct snd_soc_codec *codec, u32 val)
+	da7219_aad_fw_adc_1bit_rpt(struct snd_soc_codec *codec, u32 val)
 {
 	switch (val) {
 	case 1:
@@ -538,97 +538,96 @@ static enum da7219_aad_adc_1bit_rpt
 	}
 }
 
-static struct da7219_aad_pdata *da7219_aad_of_to_pdata(struct snd_soc_codec *codec)
+static struct da7219_aad_pdata *da7219_aad_fw_to_pdata(struct snd_soc_codec *codec)
 {
-	struct device_node *np = codec->dev->of_node;
-	struct device_node *aad_np = of_find_node_by_name(np, "da7219_aad");
+	struct device *dev = codec->dev;
+	struct i2c_client *i2c = to_i2c_client(dev);
+	struct fwnode_handle *aad_np;
 	struct da7219_aad_pdata *aad_pdata;
-	const char *of_str;
-	u32 of_val32;
+	const char *fw_str;
+	u32 fw_val32;
 
+	aad_np = device_get_named_child_node(dev, "da7219_aad");
 	if (!aad_np)
 		return NULL;
 
 	aad_pdata = devm_kzalloc(codec->dev, sizeof(*aad_pdata), GFP_KERNEL);
 	if (!aad_pdata)
-		goto out;
+		return NULL;
 
-	aad_pdata->irq = irq_of_parse_and_map(np, 0);
+	aad_pdata->irq = i2c->irq;
 
-	if (of_property_read_u32(aad_np, "dlg,micbias-pulse-lvl",
-				 &of_val32) >= 0)
+	if (fwnode_property_read_u32(aad_np, "dlg,micbias-pulse-lvl",
+				     &fw_val32) >= 0)
 		aad_pdata->micbias_pulse_lvl =
-			da7219_aad_of_micbias_pulse_lvl(codec, of_val32);
+			da7219_aad_fw_micbias_pulse_lvl(codec, fw_val32);
 	else
 		aad_pdata->micbias_pulse_lvl = DA7219_AAD_MICBIAS_PULSE_LVL_OFF;
 
-	if (of_property_read_u32(aad_np, "dlg,micbias-pulse-time",
-				 &of_val32) >= 0)
-		aad_pdata->micbias_pulse_time = of_val32;
+	if (fwnode_property_read_u32(aad_np, "dlg,micbias-pulse-time",
+				     &fw_val32) >= 0)
+		aad_pdata->micbias_pulse_time = fw_val32;
 
-	if (of_property_read_u32(aad_np, "dlg,btn-cfg", &of_val32) >= 0)
-		aad_pdata->btn_cfg = da7219_aad_of_btn_cfg(codec, of_val32);
+	if (fwnode_property_read_u32(aad_np, "dlg,btn-cfg", &fw_val32) >= 0)
+		aad_pdata->btn_cfg = da7219_aad_fw_btn_cfg(codec, fw_val32);
 	else
 		aad_pdata->btn_cfg = DA7219_AAD_BTN_CFG_10MS;
 
-	if (of_property_read_u32(aad_np, "dlg,mic-det-thr", &of_val32) >= 0)
+	if (fwnode_property_read_u32(aad_np, "dlg,mic-det-thr", &fw_val32) >= 0)
 		aad_pdata->mic_det_thr =
-			da7219_aad_of_mic_det_thr(codec, of_val32);
+			da7219_aad_fw_mic_det_thr(codec, fw_val32);
 	else
 		aad_pdata->mic_det_thr = DA7219_AAD_MIC_DET_THR_500_OHMS;
 
-	if (of_property_read_u32(aad_np, "dlg,jack-ins-deb", &of_val32) >= 0)
+	if (fwnode_property_read_u32(aad_np, "dlg,jack-ins-deb", &fw_val32) >= 0)
 		aad_pdata->jack_ins_deb =
-			da7219_aad_of_jack_ins_deb(codec, of_val32);
+			da7219_aad_fw_jack_ins_deb(codec, fw_val32);
 	else
 		aad_pdata->jack_ins_deb = DA7219_AAD_JACK_INS_DEB_20MS;
 
-	if (!of_property_read_string(aad_np, "dlg,jack-det-rate", &of_str))
+	if (!fwnode_property_read_string(aad_np, "dlg,jack-det-rate", &fw_str))
 		aad_pdata->jack_det_rate =
-			da7219_aad_of_jack_det_rate(codec, of_str);
+			da7219_aad_fw_jack_det_rate(codec, fw_str);
 	else
 		aad_pdata->jack_det_rate = DA7219_AAD_JACK_DET_RATE_256_512MS;
 
-	if (of_property_read_u32(aad_np, "dlg,jack-rem-deb", &of_val32) >= 0)
+	if (fwnode_property_read_u32(aad_np, "dlg,jack-rem-deb", &fw_val32) >= 0)
 		aad_pdata->jack_rem_deb =
-			da7219_aad_of_jack_rem_deb(codec, of_val32);
+			da7219_aad_fw_jack_rem_deb(codec, fw_val32);
 	else
 		aad_pdata->jack_rem_deb = DA7219_AAD_JACK_REM_DEB_1MS;
 
-	if (of_property_read_u32(aad_np, "dlg,a-d-btn-thr", &of_val32) >= 0)
-		aad_pdata->a_d_btn_thr = (u8) of_val32;
+	if (fwnode_property_read_u32(aad_np, "dlg,a-d-btn-thr", &fw_val32) >= 0)
+		aad_pdata->a_d_btn_thr = (u8) fw_val32;
 	else
 		aad_pdata->a_d_btn_thr = 0xA;
 
-	if (of_property_read_u32(aad_np, "dlg,d-b-btn-thr", &of_val32) >= 0)
-		aad_pdata->d_b_btn_thr = (u8) of_val32;
+	if (fwnode_property_read_u32(aad_np, "dlg,d-b-btn-thr", &fw_val32) >= 0)
+		aad_pdata->d_b_btn_thr = (u8) fw_val32;
 	else
 		aad_pdata->d_b_btn_thr = 0x16;
 
-	if (of_property_read_u32(aad_np, "dlg,b-c-btn-thr", &of_val32) >= 0)
-		aad_pdata->b_c_btn_thr = (u8) of_val32;
+	if (fwnode_property_read_u32(aad_np, "dlg,b-c-btn-thr", &fw_val32) >= 0)
+		aad_pdata->b_c_btn_thr = (u8) fw_val32;
 	else
 		aad_pdata->b_c_btn_thr = 0x21;
 
-	if (of_property_read_u32(aad_np, "dlg,c-mic-btn-thr", &of_val32) >= 0)
-		aad_pdata->c_mic_btn_thr = (u8) of_val32;
+	if (fwnode_property_read_u32(aad_np, "dlg,c-mic-btn-thr", &fw_val32) >= 0)
+		aad_pdata->c_mic_btn_thr = (u8) fw_val32;
 	else
 		aad_pdata->c_mic_btn_thr = 0x3E;
 
-	if (of_property_read_u32(aad_np, "dlg,btn-avg", &of_val32) >= 0)
-		aad_pdata->btn_avg = da7219_aad_of_btn_avg(codec, of_val32);
+	if (fwnode_property_read_u32(aad_np, "dlg,btn-avg", &fw_val32) >= 0)
+		aad_pdata->btn_avg = da7219_aad_fw_btn_avg(codec, fw_val32);
 	else
 		aad_pdata->btn_avg = DA7219_AAD_BTN_AVG_2;
 
-	if (of_property_read_u32(aad_np, "dlg,adc-1bit-rpt", &of_val32) >= 0)
+	if (fwnode_property_read_u32(aad_np, "dlg,adc-1bit-rpt", &fw_val32) >= 0)
 		aad_pdata->adc_1bit_rpt =
-			da7219_aad_of_adc_1bit_rpt(codec, of_val32);
+			da7219_aad_fw_adc_1bit_rpt(codec, fw_val32);
 	else
 		aad_pdata->adc_1bit_rpt = DA7219_AAD_ADC_1BIT_RPT_1;
 
-out:
-	of_node_put(aad_np);
-
 	return aad_pdata;
 }
 
@@ -769,9 +768,9 @@ int da7219_aad_init(struct snd_soc_codec *codec)
 	da7219->aad = da7219_aad;
 	da7219_aad->codec = codec;
 
-	/* Handle any DT/platform data */
-	if ((codec->dev->of_node) && (da7219->pdata))
-		da7219->pdata->aad_pdata = da7219_aad_of_to_pdata(codec);
+	/* Handle any DT/ACPI/platform data */
+	if (da7219->pdata && !da7219->pdata->aad_pdata)
+		da7219->pdata->aad_pdata = da7219_aad_fw_to_pdata(codec);
 
 	da7219_aad_handle_pdata(codec);
 

commit 6d817c0e9fd7536be76690bfdee88e8a81c16f7d
Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
Date:   Tue Sep 29 16:44:01 2015 +0100

    ASoC: codecs: Add da7219 codec driver
    
    This adds support for the DA7219 audio codec with built-in advanced
    accessory detect features.
    
    Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/da7219-aad.c b/sound/soc/codecs/da7219-aad.c
new file mode 100644
index 000000000000..9459593eef13
--- /dev/null
+++ b/sound/soc/codecs/da7219-aad.c
@@ -0,0 +1,823 @@
+/*
+ * da7219-aad.c - Dialog DA7219 ALSA SoC AAD Driver
+ *
+ * Copyright (c) 2015 Dialog Semiconductor Ltd.
+ *
+ * Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/pm_wakeirq.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/da7219.h>
+
+#include "da7219.h"
+#include "da7219-aad.h"
+
+
+/*
+ * Detection control
+ */
+
+void da7219_aad_jack_det(struct snd_soc_codec *codec, struct snd_soc_jack *jack)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+	da7219->aad->jack = jack;
+	da7219->aad->jack_inserted = false;
+
+	/* Send an initial empty report */
+	snd_soc_jack_report(jack, 0, DA7219_AAD_REPORT_ALL_MASK);
+
+	/* Enable/Disable jack detection */
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+			    DA7219_ACCDET_EN_MASK,
+			    (jack ? DA7219_ACCDET_EN_MASK : 0));
+}
+EXPORT_SYMBOL_GPL(da7219_aad_jack_det);
+
+/*
+ * Button/HPTest work
+ */
+
+static void da7219_aad_btn_det_work(struct work_struct *work)
+{
+	struct da7219_aad_priv *da7219_aad =
+		container_of(work, struct da7219_aad_priv, btn_det_work);
+	struct snd_soc_codec *codec = da7219_aad->codec;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	u8 statusa, micbias_ctrl;
+	bool micbias_up = false;
+	int retries = 0;
+
+	/* Drive headphones/lineout */
+	snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+			    DA7219_HP_L_AMP_OE_MASK,
+			    DA7219_HP_L_AMP_OE_MASK);
+	snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+			    DA7219_HP_R_AMP_OE_MASK,
+			    DA7219_HP_R_AMP_OE_MASK);
+
+	/* Make sure mic bias is up */
+	snd_soc_dapm_force_enable_pin(dapm, "Mic Bias");
+	snd_soc_dapm_sync(dapm);
+
+	do {
+		statusa = snd_soc_read(codec, DA7219_ACCDET_STATUS_A);
+		if (statusa & DA7219_MICBIAS_UP_STS_MASK)
+			micbias_up = true;
+		else if (retries++ < DA7219_AAD_MICBIAS_CHK_RETRIES)
+			msleep(DA7219_AAD_MICBIAS_CHK_DELAY);
+	} while ((!micbias_up) && (retries < DA7219_AAD_MICBIAS_CHK_RETRIES));
+
+	if (retries >= DA7219_AAD_MICBIAS_CHK_RETRIES)
+		dev_warn(codec->dev, "Mic bias status check timed out");
+
+	/*
+	 * Mic bias pulse required to enable mic, must be done before enabling
+	 * button detection to prevent erroneous button readings.
+	 */
+	if (da7219_aad->micbias_pulse_lvl && da7219_aad->micbias_pulse_time) {
+		/* Pulse higher level voltage */
+		micbias_ctrl = snd_soc_read(codec, DA7219_MICBIAS_CTRL);
+		snd_soc_update_bits(codec, DA7219_MICBIAS_CTRL,
+				    DA7219_MICBIAS1_LEVEL_MASK,
+				    da7219_aad->micbias_pulse_lvl);
+		msleep(da7219_aad->micbias_pulse_time);
+		snd_soc_write(codec, DA7219_MICBIAS_CTRL, micbias_ctrl);
+
+	}
+
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+			    DA7219_BUTTON_CONFIG_MASK,
+			    da7219_aad->btn_cfg);
+}
+
+static void da7219_aad_hptest_work(struct work_struct *work)
+{
+	struct da7219_aad_priv *da7219_aad =
+		container_of(work, struct da7219_aad_priv, hptest_work);
+	struct snd_soc_codec *codec = da7219_aad->codec;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+
+	u16 tonegen_freq_hptest;
+	u8 accdet_cfg8;
+	int report = 0;
+
+	/* Lock DAPM and any Kcontrols that are affected by this test */
+	snd_soc_dapm_mutex_lock(dapm);
+	mutex_lock(&da7219->lock);
+
+	/* Bypass cache so it saves current settings */
+	regcache_cache_bypass(da7219->regmap, true);
+
+	/* Make sure Tone Generator is disabled */
+	snd_soc_write(codec, DA7219_TONE_GEN_CFG1, 0);
+
+	/* Enable HPTest block, 1KOhms check */
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_8,
+			    DA7219_HPTEST_EN_MASK | DA7219_HPTEST_RES_SEL_MASK,
+			    DA7219_HPTEST_EN_MASK |
+			    DA7219_HPTEST_RES_SEL_1KOHMS);
+
+	/* Set gains to 0db */
+	snd_soc_write(codec, DA7219_DAC_L_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);
+	snd_soc_write(codec, DA7219_DAC_R_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);
+	snd_soc_write(codec, DA7219_HP_L_GAIN, DA7219_HP_AMP_GAIN_0DB);
+	snd_soc_write(codec, DA7219_HP_R_GAIN, DA7219_HP_AMP_GAIN_0DB);
+
+	/* Disable DAC filters, EQs and soft mute */
+	snd_soc_update_bits(codec, DA7219_DAC_FILTERS1, DA7219_HPF_MODE_MASK,
+			    0);
+	snd_soc_update_bits(codec, DA7219_DAC_FILTERS4, DA7219_DAC_EQ_EN_MASK,
+			    0);
+	snd_soc_update_bits(codec, DA7219_DAC_FILTERS5,
+			    DA7219_DAC_SOFTMUTE_EN_MASK, 0);
+
+	/* Enable HP left & right paths */
+	snd_soc_update_bits(codec, DA7219_CP_CTRL, DA7219_CP_EN_MASK,
+			    DA7219_CP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_DIG_ROUTING_DAC,
+			    DA7219_DAC_L_SRC_MASK | DA7219_DAC_R_SRC_MASK,
+			    DA7219_DAC_L_SRC_TONEGEN |
+			    DA7219_DAC_R_SRC_TONEGEN);
+	snd_soc_update_bits(codec, DA7219_DAC_L_CTRL,
+			    DA7219_DAC_L_EN_MASK | DA7219_DAC_L_MUTE_EN_MASK,
+			    DA7219_DAC_L_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_DAC_R_CTRL,
+			    DA7219_DAC_R_EN_MASK | DA7219_DAC_R_MUTE_EN_MASK,
+			    DA7219_DAC_R_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_MIXOUT_L_SELECT,
+			    DA7219_MIXOUT_L_MIX_SELECT_MASK,
+			    DA7219_MIXOUT_L_MIX_SELECT_MASK);
+	snd_soc_update_bits(codec, DA7219_MIXOUT_R_SELECT,
+			    DA7219_MIXOUT_R_MIX_SELECT_MASK,
+			    DA7219_MIXOUT_R_MIX_SELECT_MASK);
+	snd_soc_update_bits(codec, DA7219_DROUTING_ST_OUTFILT_1L,
+			    DA7219_OUTFILT_ST_1L_SRC_MASK,
+			    DA7219_DMIX_ST_SRC_OUTFILT1L);
+	snd_soc_update_bits(codec, DA7219_DROUTING_ST_OUTFILT_1R,
+			    DA7219_OUTFILT_ST_1R_SRC_MASK,
+			    DA7219_DMIX_ST_SRC_OUTFILT1R);
+	snd_soc_update_bits(codec, DA7219_MIXOUT_L_CTRL,
+			    DA7219_MIXOUT_L_AMP_EN_MASK,
+			    DA7219_MIXOUT_L_AMP_EN_MASK);
+	snd_soc_update_bits(codec, DA7219_MIXOUT_R_CTRL,
+			    DA7219_MIXOUT_R_AMP_EN_MASK,
+			    DA7219_MIXOUT_R_AMP_EN_MASK);
+	snd_soc_write(codec, DA7219_HP_L_CTRL,
+		      DA7219_HP_L_AMP_OE_MASK | DA7219_HP_L_AMP_EN_MASK);
+	snd_soc_write(codec, DA7219_HP_R_CTRL,
+		      DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK);
+
+	/* Configure & start Tone Generator */
+	snd_soc_write(codec, DA7219_TONE_GEN_ON_PER, DA7219_BEEP_ON_PER_MASK);
+	tonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ);
+	regmap_raw_write(da7219->regmap, DA7219_TONE_GEN_FREQ1_L,
+			 &tonegen_freq_hptest, sizeof(tonegen_freq_hptest));
+	snd_soc_update_bits(codec, DA7219_TONE_GEN_CFG2,
+			    DA7219_SWG_SEL_MASK | DA7219_TONE_GEN_GAIN_MASK,
+			    DA7219_SWG_SEL_SRAMP |
+			    DA7219_TONE_GEN_GAIN_MINUS_15DB);
+	snd_soc_write(codec, DA7219_TONE_GEN_CFG1, DA7219_START_STOPN_MASK);
+
+	msleep(DA7219_AAD_HPTEST_PERIOD);
+
+	/* Grab comparator reading */
+	accdet_cfg8 = snd_soc_read(codec, DA7219_ACCDET_CONFIG_8);
+	if (accdet_cfg8 & DA7219_HPTEST_COMP_MASK)
+		report |= SND_JACK_HEADPHONE;
+	else
+		report |= SND_JACK_LINEOUT;
+
+	/* Stop tone generator */
+	snd_soc_write(codec, DA7219_TONE_GEN_CFG1, 0);
+
+	msleep(DA7219_AAD_HPTEST_PERIOD);
+
+	/* Restore original settings from cache */
+	regcache_mark_dirty(da7219->regmap);
+	regcache_sync_region(da7219->regmap, DA7219_HP_L_CTRL,
+			     DA7219_HP_R_CTRL);
+	regcache_sync_region(da7219->regmap, DA7219_MIXOUT_L_CTRL,
+			     DA7219_MIXOUT_R_CTRL);
+	regcache_sync_region(da7219->regmap, DA7219_DROUTING_ST_OUTFILT_1L,
+			     DA7219_DROUTING_ST_OUTFILT_1R);
+	regcache_sync_region(da7219->regmap, DA7219_MIXOUT_L_SELECT,
+			     DA7219_MIXOUT_R_SELECT);
+	regcache_sync_region(da7219->regmap, DA7219_DAC_L_CTRL,
+			     DA7219_DAC_R_CTRL);
+	regcache_sync_region(da7219->regmap, DA7219_DIG_ROUTING_DAC,
+			     DA7219_DIG_ROUTING_DAC);
+	regcache_sync_region(da7219->regmap, DA7219_CP_CTRL, DA7219_CP_CTRL);
+	regcache_sync_region(da7219->regmap, DA7219_DAC_FILTERS5,
+			     DA7219_DAC_FILTERS5);
+	regcache_sync_region(da7219->regmap, DA7219_DAC_FILTERS4,
+			     DA7219_DAC_FILTERS1);
+	regcache_sync_region(da7219->regmap, DA7219_HP_L_GAIN,
+			     DA7219_HP_R_GAIN);
+	regcache_sync_region(da7219->regmap, DA7219_DAC_L_GAIN,
+			     DA7219_DAC_R_GAIN);
+	regcache_sync_region(da7219->regmap, DA7219_TONE_GEN_ON_PER,
+			     DA7219_TONE_GEN_ON_PER);
+	regcache_sync_region(da7219->regmap, DA7219_TONE_GEN_FREQ1_L,
+			     DA7219_TONE_GEN_FREQ1_U);
+	regcache_sync_region(da7219->regmap, DA7219_TONE_GEN_CFG1,
+			     DA7219_TONE_GEN_CFG2);
+
+	regcache_cache_bypass(da7219->regmap, false);
+
+	/* Disable HPTest block */
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_8,
+			    DA7219_HPTEST_EN_MASK, 0);
+
+	/* Drive Headphones/lineout */
+	snd_soc_update_bits(codec, DA7219_HP_L_CTRL, DA7219_HP_L_AMP_OE_MASK,
+			    DA7219_HP_L_AMP_OE_MASK);
+	snd_soc_update_bits(codec, DA7219_HP_R_CTRL, DA7219_HP_R_AMP_OE_MASK,
+			    DA7219_HP_R_AMP_OE_MASK);
+
+	mutex_unlock(&da7219->lock);
+	snd_soc_dapm_mutex_unlock(dapm);
+
+	/*
+	 * Only send report if jack hasn't been removed during process,
+	 * otherwise it's invalid and we drop it.
+	 */
+	if (da7219_aad->jack_inserted)
+		snd_soc_jack_report(da7219_aad->jack, report,
+				    SND_JACK_HEADSET | SND_JACK_LINEOUT);
+}
+
+
+/*
+ * IRQ
+ */
+
+static irqreturn_t da7219_aad_irq_thread(int irq, void *data)
+{
+	struct da7219_aad_priv *da7219_aad = data;
+	struct snd_soc_codec *codec = da7219_aad->codec;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	u8 events[DA7219_AAD_IRQ_REG_MAX];
+	u8 statusa;
+	int i, report = 0, mask = 0;
+
+	/* Read current IRQ events */
+	regmap_bulk_read(da7219->regmap, DA7219_ACCDET_IRQ_EVENT_A,
+			 events, DA7219_AAD_IRQ_REG_MAX);
+
+	if (!events[DA7219_AAD_IRQ_REG_A] && !events[DA7219_AAD_IRQ_REG_B])
+		return IRQ_NONE;
+
+	/* Read status register for jack insertion & type status */
+	statusa = snd_soc_read(codec, DA7219_ACCDET_STATUS_A);
+
+	/* Clear events */
+	regmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_EVENT_A,
+			  events, DA7219_AAD_IRQ_REG_MAX);
+
+	dev_dbg(codec->dev, "IRQ events = 0x%x|0x%x, status = 0x%x\n",
+		events[DA7219_AAD_IRQ_REG_A], events[DA7219_AAD_IRQ_REG_B],
+		statusa);
+
+	if (statusa & DA7219_JACK_INSERTION_STS_MASK) {
+		/* Jack Insertion */
+		if (events[DA7219_AAD_IRQ_REG_A] &
+		    DA7219_E_JACK_INSERTED_MASK) {
+			report |= SND_JACK_MECHANICAL;
+			mask |= SND_JACK_MECHANICAL;
+			da7219_aad->jack_inserted = true;
+		}
+
+		/* Jack type detection */
+		if (events[DA7219_AAD_IRQ_REG_A] &
+		    DA7219_E_JACK_DETECT_COMPLETE_MASK) {
+			/*
+			 * If 4-pole, then enable button detection, else perform
+			 * HP impedance test to determine output type to report.
+			 *
+			 * We schedule work here as the tasks themselves can
+			 * take time to complete, and in particular for hptest
+			 * we want to be able to check if the jack was removed
+			 * during the procedure as this will invalidate the
+			 * result. By doing this as work, the IRQ thread can
+			 * handle a removal, and we can check at the end of
+			 * hptest if we have a valid result or not.
+			 */
+			if (statusa & DA7219_JACK_TYPE_STS_MASK) {
+				report |= SND_JACK_HEADSET;
+				mask |=	SND_JACK_HEADSET | SND_JACK_LINEOUT;
+				schedule_work(&da7219_aad->btn_det_work);
+			} else {
+				schedule_work(&da7219_aad->hptest_work);
+			}
+		}
+
+		/* Button support for 4-pole jack */
+		if (statusa & DA7219_JACK_TYPE_STS_MASK) {
+			for (i = 0; i < DA7219_AAD_MAX_BUTTONS; ++i) {
+				/* Button Press */
+				if (events[DA7219_AAD_IRQ_REG_B] &
+				    (DA7219_E_BUTTON_A_PRESSED_MASK << i)) {
+					report |= SND_JACK_BTN_0 >> i;
+					mask |= SND_JACK_BTN_0 >> i;
+				}
+			}
+			snd_soc_jack_report(da7219_aad->jack, report, mask);
+
+			for (i = 0; i < DA7219_AAD_MAX_BUTTONS; ++i) {
+				/* Button Release */
+				if (events[DA7219_AAD_IRQ_REG_B] &
+				    (DA7219_E_BUTTON_A_RELEASED_MASK >> i)) {
+					report &= ~(SND_JACK_BTN_0 >> i);
+					mask |= SND_JACK_BTN_0 >> i;
+				}
+			}
+		}
+	} else {
+		/* Jack removal */
+		if (events[DA7219_AAD_IRQ_REG_A] & DA7219_E_JACK_REMOVED_MASK) {
+			report = 0;
+			mask |= DA7219_AAD_REPORT_ALL_MASK;
+			da7219_aad->jack_inserted = false;
+
+			/* Un-drive headphones/lineout */
+			snd_soc_update_bits(codec, DA7219_HP_R_CTRL,
+					    DA7219_HP_R_AMP_OE_MASK, 0);
+			snd_soc_update_bits(codec, DA7219_HP_L_CTRL,
+					    DA7219_HP_L_AMP_OE_MASK, 0);
+
+			/* Ensure button detection disabled */
+			snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+					    DA7219_BUTTON_CONFIG_MASK, 0);
+
+			/* Disable mic bias */
+			snd_soc_dapm_disable_pin(dapm, "Mic Bias");
+			snd_soc_dapm_sync(dapm);
+
+			/* Cancel any pending work */
+			cancel_work_sync(&da7219_aad->btn_det_work);
+			cancel_work_sync(&da7219_aad->hptest_work);
+		}
+	}
+
+	snd_soc_jack_report(da7219_aad->jack, report, mask);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * DT to pdata conversion
+ */
+
+static enum da7219_aad_micbias_pulse_lvl
+	da7219_aad_of_micbias_pulse_lvl(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 2800:
+		return DA7219_AAD_MICBIAS_PULSE_LVL_2_8V;
+	case 2900:
+		return DA7219_AAD_MICBIAS_PULSE_LVL_2_9V;
+	default:
+		dev_warn(codec->dev, "Invalid micbias pulse level");
+		return DA7219_AAD_MICBIAS_PULSE_LVL_OFF;
+	}
+}
+
+static enum da7219_aad_btn_cfg
+	da7219_aad_of_btn_cfg(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 2:
+		return DA7219_AAD_BTN_CFG_2MS;
+	case 5:
+		return DA7219_AAD_BTN_CFG_5MS;
+	case 10:
+		return DA7219_AAD_BTN_CFG_10MS;
+	case 50:
+		return DA7219_AAD_BTN_CFG_50MS;
+	case 100:
+		return DA7219_AAD_BTN_CFG_100MS;
+	case 200:
+		return DA7219_AAD_BTN_CFG_200MS;
+	case 500:
+		return DA7219_AAD_BTN_CFG_500MS;
+	default:
+		dev_warn(codec->dev, "Invalid button config");
+		return DA7219_AAD_BTN_CFG_10MS;
+	}
+}
+
+static enum da7219_aad_mic_det_thr
+	da7219_aad_of_mic_det_thr(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 200:
+		return DA7219_AAD_MIC_DET_THR_200_OHMS;
+	case 500:
+		return DA7219_AAD_MIC_DET_THR_500_OHMS;
+	case 750:
+		return DA7219_AAD_MIC_DET_THR_750_OHMS;
+	case 1000:
+		return DA7219_AAD_MIC_DET_THR_1000_OHMS;
+	default:
+		dev_warn(codec->dev, "Invalid mic detect threshold");
+		return DA7219_AAD_MIC_DET_THR_500_OHMS;
+	}
+}
+
+static enum da7219_aad_jack_ins_deb
+	da7219_aad_of_jack_ins_deb(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 5:
+		return DA7219_AAD_JACK_INS_DEB_5MS;
+	case 10:
+		return DA7219_AAD_JACK_INS_DEB_10MS;
+	case 20:
+		return DA7219_AAD_JACK_INS_DEB_20MS;
+	case 50:
+		return DA7219_AAD_JACK_INS_DEB_50MS;
+	case 100:
+		return DA7219_AAD_JACK_INS_DEB_100MS;
+	case 200:
+		return DA7219_AAD_JACK_INS_DEB_200MS;
+	case 500:
+		return DA7219_AAD_JACK_INS_DEB_500MS;
+	case 1000:
+		return DA7219_AAD_JACK_INS_DEB_1S;
+	default:
+		dev_warn(codec->dev, "Invalid jack insert debounce");
+		return DA7219_AAD_JACK_INS_DEB_20MS;
+	}
+}
+
+static enum da7219_aad_jack_det_rate
+	da7219_aad_of_jack_det_rate(struct snd_soc_codec *codec, const char *str)
+{
+	if (!strcmp(str, "32ms_64ms")) {
+		return DA7219_AAD_JACK_DET_RATE_32_64MS;
+	} else if (!strcmp(str, "64ms_128ms")) {
+		return DA7219_AAD_JACK_DET_RATE_64_128MS;
+	} else if (!strcmp(str, "128ms_256ms")) {
+		return DA7219_AAD_JACK_DET_RATE_128_256MS;
+	} else if (!strcmp(str, "256ms_512ms")) {
+		return DA7219_AAD_JACK_DET_RATE_256_512MS;
+	} else {
+		dev_warn(codec->dev, "Invalid jack detect rate");
+		return DA7219_AAD_JACK_DET_RATE_256_512MS;
+	}
+}
+
+static enum da7219_aad_jack_rem_deb
+	da7219_aad_of_jack_rem_deb(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 1:
+		return DA7219_AAD_JACK_REM_DEB_1MS;
+	case 5:
+		return DA7219_AAD_JACK_REM_DEB_5MS;
+	case 10:
+		return DA7219_AAD_JACK_REM_DEB_10MS;
+	case 20:
+		return DA7219_AAD_JACK_REM_DEB_20MS;
+	default:
+		dev_warn(codec->dev, "Invalid jack removal debounce");
+		return DA7219_AAD_JACK_REM_DEB_1MS;
+	}
+}
+
+static enum da7219_aad_btn_avg
+	da7219_aad_of_btn_avg(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 1:
+		return DA7219_AAD_BTN_AVG_1;
+	case 2:
+		return DA7219_AAD_BTN_AVG_2;
+	case 4:
+		return DA7219_AAD_BTN_AVG_4;
+	case 8:
+		return DA7219_AAD_BTN_AVG_8;
+	default:
+		dev_warn(codec->dev, "Invalid button average value");
+		return DA7219_AAD_BTN_AVG_2;
+	}
+}
+
+static enum da7219_aad_adc_1bit_rpt
+	da7219_aad_of_adc_1bit_rpt(struct snd_soc_codec *codec, u32 val)
+{
+	switch (val) {
+	case 1:
+		return DA7219_AAD_ADC_1BIT_RPT_1;
+	case 2:
+		return DA7219_AAD_ADC_1BIT_RPT_2;
+	case 4:
+		return DA7219_AAD_ADC_1BIT_RPT_4;
+	case 8:
+		return DA7219_AAD_ADC_1BIT_RPT_8;
+	default:
+		dev_warn(codec->dev, "Invalid ADC 1-bit repeat value");
+		return DA7219_AAD_ADC_1BIT_RPT_1;
+	}
+}
+
+static struct da7219_aad_pdata *da7219_aad_of_to_pdata(struct snd_soc_codec *codec)
+{
+	struct device_node *np = codec->dev->of_node;
+	struct device_node *aad_np = of_find_node_by_name(np, "da7219_aad");
+	struct da7219_aad_pdata *aad_pdata;
+	const char *of_str;
+	u32 of_val32;
+
+	if (!aad_np)
+		return NULL;
+
+	aad_pdata = devm_kzalloc(codec->dev, sizeof(*aad_pdata), GFP_KERNEL);
+	if (!aad_pdata)
+		goto out;
+
+	aad_pdata->irq = irq_of_parse_and_map(np, 0);
+
+	if (of_property_read_u32(aad_np, "dlg,micbias-pulse-lvl",
+				 &of_val32) >= 0)
+		aad_pdata->micbias_pulse_lvl =
+			da7219_aad_of_micbias_pulse_lvl(codec, of_val32);
+	else
+		aad_pdata->micbias_pulse_lvl = DA7219_AAD_MICBIAS_PULSE_LVL_OFF;
+
+	if (of_property_read_u32(aad_np, "dlg,micbias-pulse-time",
+				 &of_val32) >= 0)
+		aad_pdata->micbias_pulse_time = of_val32;
+
+	if (of_property_read_u32(aad_np, "dlg,btn-cfg", &of_val32) >= 0)
+		aad_pdata->btn_cfg = da7219_aad_of_btn_cfg(codec, of_val32);
+	else
+		aad_pdata->btn_cfg = DA7219_AAD_BTN_CFG_10MS;
+
+	if (of_property_read_u32(aad_np, "dlg,mic-det-thr", &of_val32) >= 0)
+		aad_pdata->mic_det_thr =
+			da7219_aad_of_mic_det_thr(codec, of_val32);
+	else
+		aad_pdata->mic_det_thr = DA7219_AAD_MIC_DET_THR_500_OHMS;
+
+	if (of_property_read_u32(aad_np, "dlg,jack-ins-deb", &of_val32) >= 0)
+		aad_pdata->jack_ins_deb =
+			da7219_aad_of_jack_ins_deb(codec, of_val32);
+	else
+		aad_pdata->jack_ins_deb = DA7219_AAD_JACK_INS_DEB_20MS;
+
+	if (!of_property_read_string(aad_np, "dlg,jack-det-rate", &of_str))
+		aad_pdata->jack_det_rate =
+			da7219_aad_of_jack_det_rate(codec, of_str);
+	else
+		aad_pdata->jack_det_rate = DA7219_AAD_JACK_DET_RATE_256_512MS;
+
+	if (of_property_read_u32(aad_np, "dlg,jack-rem-deb", &of_val32) >= 0)
+		aad_pdata->jack_rem_deb =
+			da7219_aad_of_jack_rem_deb(codec, of_val32);
+	else
+		aad_pdata->jack_rem_deb = DA7219_AAD_JACK_REM_DEB_1MS;
+
+	if (of_property_read_u32(aad_np, "dlg,a-d-btn-thr", &of_val32) >= 0)
+		aad_pdata->a_d_btn_thr = (u8) of_val32;
+	else
+		aad_pdata->a_d_btn_thr = 0xA;
+
+	if (of_property_read_u32(aad_np, "dlg,d-b-btn-thr", &of_val32) >= 0)
+		aad_pdata->d_b_btn_thr = (u8) of_val32;
+	else
+		aad_pdata->d_b_btn_thr = 0x16;
+
+	if (of_property_read_u32(aad_np, "dlg,b-c-btn-thr", &of_val32) >= 0)
+		aad_pdata->b_c_btn_thr = (u8) of_val32;
+	else
+		aad_pdata->b_c_btn_thr = 0x21;
+
+	if (of_property_read_u32(aad_np, "dlg,c-mic-btn-thr", &of_val32) >= 0)
+		aad_pdata->c_mic_btn_thr = (u8) of_val32;
+	else
+		aad_pdata->c_mic_btn_thr = 0x3E;
+
+	if (of_property_read_u32(aad_np, "dlg,btn-avg", &of_val32) >= 0)
+		aad_pdata->btn_avg = da7219_aad_of_btn_avg(codec, of_val32);
+	else
+		aad_pdata->btn_avg = DA7219_AAD_BTN_AVG_2;
+
+	if (of_property_read_u32(aad_np, "dlg,adc-1bit-rpt", &of_val32) >= 0)
+		aad_pdata->adc_1bit_rpt =
+			da7219_aad_of_adc_1bit_rpt(codec, of_val32);
+	else
+		aad_pdata->adc_1bit_rpt = DA7219_AAD_ADC_1BIT_RPT_1;
+
+out:
+	of_node_put(aad_np);
+
+	return aad_pdata;
+}
+
+static void da7219_aad_handle_pdata(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_aad_priv *da7219_aad = da7219->aad;
+	struct da7219_pdata *pdata = da7219->pdata;
+
+	if ((pdata) && (pdata->aad_pdata)) {
+		struct da7219_aad_pdata *aad_pdata = pdata->aad_pdata;
+		u8 cfg, mask;
+
+		da7219_aad->irq = aad_pdata->irq;
+
+		switch (aad_pdata->micbias_pulse_lvl) {
+		case DA7219_AAD_MICBIAS_PULSE_LVL_2_8V:
+		case DA7219_AAD_MICBIAS_PULSE_LVL_2_9V:
+			da7219_aad->micbias_pulse_lvl =
+				(aad_pdata->micbias_pulse_lvl <<
+				 DA7219_MICBIAS1_LEVEL_SHIFT);
+			break;
+		default:
+			break;
+		}
+
+		da7219_aad->micbias_pulse_time = aad_pdata->micbias_pulse_time;
+
+		switch (aad_pdata->btn_cfg) {
+		case DA7219_AAD_BTN_CFG_2MS:
+		case DA7219_AAD_BTN_CFG_5MS:
+		case DA7219_AAD_BTN_CFG_10MS:
+		case DA7219_AAD_BTN_CFG_50MS:
+		case DA7219_AAD_BTN_CFG_100MS:
+		case DA7219_AAD_BTN_CFG_200MS:
+		case DA7219_AAD_BTN_CFG_500MS:
+			da7219_aad->btn_cfg  = (aad_pdata->btn_cfg <<
+						DA7219_BUTTON_CONFIG_SHIFT);
+		}
+
+		cfg = 0;
+		mask = 0;
+		switch (aad_pdata->mic_det_thr) {
+		case DA7219_AAD_MIC_DET_THR_200_OHMS:
+		case DA7219_AAD_MIC_DET_THR_500_OHMS:
+		case DA7219_AAD_MIC_DET_THR_750_OHMS:
+		case DA7219_AAD_MIC_DET_THR_1000_OHMS:
+			cfg |= (aad_pdata->mic_det_thr <<
+				DA7219_MIC_DET_THRESH_SHIFT);
+			mask |= DA7219_MIC_DET_THRESH_MASK;
+		}
+		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1, mask, cfg);
+
+		cfg = 0;
+		mask = 0;
+		switch (aad_pdata->jack_ins_deb) {
+		case DA7219_AAD_JACK_INS_DEB_5MS:
+		case DA7219_AAD_JACK_INS_DEB_10MS:
+		case DA7219_AAD_JACK_INS_DEB_20MS:
+		case DA7219_AAD_JACK_INS_DEB_50MS:
+		case DA7219_AAD_JACK_INS_DEB_100MS:
+		case DA7219_AAD_JACK_INS_DEB_200MS:
+		case DA7219_AAD_JACK_INS_DEB_500MS:
+		case DA7219_AAD_JACK_INS_DEB_1S:
+			cfg |= (aad_pdata->jack_ins_deb <<
+				DA7219_JACKDET_DEBOUNCE_SHIFT);
+			mask |= DA7219_JACKDET_DEBOUNCE_MASK;
+		}
+		switch (aad_pdata->jack_det_rate) {
+		case DA7219_AAD_JACK_DET_RATE_32_64MS:
+		case DA7219_AAD_JACK_DET_RATE_64_128MS:
+		case DA7219_AAD_JACK_DET_RATE_128_256MS:
+		case DA7219_AAD_JACK_DET_RATE_256_512MS:
+			cfg |= (aad_pdata->jack_det_rate <<
+				DA7219_JACK_DETECT_RATE_SHIFT);
+			mask |= DA7219_JACK_DETECT_RATE_MASK;
+		}
+		switch (aad_pdata->jack_rem_deb) {
+		case DA7219_AAD_JACK_REM_DEB_1MS:
+		case DA7219_AAD_JACK_REM_DEB_5MS:
+		case DA7219_AAD_JACK_REM_DEB_10MS:
+		case DA7219_AAD_JACK_REM_DEB_20MS:
+			cfg |= (aad_pdata->jack_rem_deb <<
+				DA7219_JACKDET_REM_DEB_SHIFT);
+			mask |= DA7219_JACKDET_REM_DEB_MASK;
+		}
+		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_2, mask, cfg);
+
+		snd_soc_write(codec, DA7219_ACCDET_CONFIG_3,
+			      aad_pdata->a_d_btn_thr);
+		snd_soc_write(codec, DA7219_ACCDET_CONFIG_4,
+			      aad_pdata->d_b_btn_thr);
+		snd_soc_write(codec, DA7219_ACCDET_CONFIG_5,
+			      aad_pdata->b_c_btn_thr);
+		snd_soc_write(codec, DA7219_ACCDET_CONFIG_6,
+			      aad_pdata->c_mic_btn_thr);
+
+		cfg = 0;
+		mask = 0;
+		switch (aad_pdata->btn_avg) {
+		case DA7219_AAD_BTN_AVG_1:
+		case DA7219_AAD_BTN_AVG_2:
+		case DA7219_AAD_BTN_AVG_4:
+		case DA7219_AAD_BTN_AVG_8:
+			cfg |= (aad_pdata->btn_avg <<
+				DA7219_BUTTON_AVERAGE_SHIFT);
+			mask |= DA7219_BUTTON_AVERAGE_MASK;
+		}
+		switch (aad_pdata->adc_1bit_rpt) {
+		case DA7219_AAD_ADC_1BIT_RPT_1:
+		case DA7219_AAD_ADC_1BIT_RPT_2:
+		case DA7219_AAD_ADC_1BIT_RPT_4:
+		case DA7219_AAD_ADC_1BIT_RPT_8:
+			cfg |= (aad_pdata->adc_1bit_rpt <<
+			       DA7219_ADC_1_BIT_REPEAT_SHIFT);
+			mask |= DA7219_ADC_1_BIT_REPEAT_MASK;
+		}
+		snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_7, mask, cfg);
+	}
+}
+
+
+/*
+ * Init/Exit
+ */
+
+int da7219_aad_init(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_aad_priv *da7219_aad;
+	u8 mask[DA7219_AAD_IRQ_REG_MAX];
+	int ret;
+
+	da7219_aad = devm_kzalloc(codec->dev, sizeof(*da7219_aad), GFP_KERNEL);
+	if (!da7219_aad)
+		return -ENOMEM;
+
+	da7219->aad = da7219_aad;
+	da7219_aad->codec = codec;
+
+	/* Handle any DT/platform data */
+	if ((codec->dev->of_node) && (da7219->pdata))
+		da7219->pdata->aad_pdata = da7219_aad_of_to_pdata(codec);
+
+	da7219_aad_handle_pdata(codec);
+
+	/* Disable button detection */
+	snd_soc_update_bits(codec, DA7219_ACCDET_CONFIG_1,
+			    DA7219_BUTTON_CONFIG_MASK, 0);
+
+	INIT_WORK(&da7219_aad->btn_det_work, da7219_aad_btn_det_work);
+	INIT_WORK(&da7219_aad->hptest_work, da7219_aad_hptest_work);
+
+	ret = request_threaded_irq(da7219_aad->irq, NULL,
+				   da7219_aad_irq_thread,
+				   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+				   "da7219-aad", da7219_aad);
+	if (ret) {
+		dev_err(codec->dev, "Failed to request IRQ: %d\n", ret);
+		return ret;
+	}
+
+	/* Unmask AAD IRQs */
+	memset(mask, 0, DA7219_AAD_IRQ_REG_MAX);
+	regmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_MASK_A,
+			  &mask, DA7219_AAD_IRQ_REG_MAX);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(da7219_aad_init);
+
+void da7219_aad_exit(struct snd_soc_codec *codec)
+{
+	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
+	struct da7219_aad_priv *da7219_aad = da7219->aad;
+	u8 mask[DA7219_AAD_IRQ_REG_MAX];
+
+	/* Mask off AAD IRQs */
+	memset(mask, DA7219_BYTE_MASK, DA7219_AAD_IRQ_REG_MAX);
+	regmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_MASK_A,
+			  mask, DA7219_AAD_IRQ_REG_MAX);
+
+	free_irq(da7219_aad->irq, da7219_aad);
+
+	cancel_work_sync(&da7219_aad->btn_det_work);
+	cancel_work_sync(&da7219_aad->hptest_work);
+}
+EXPORT_SYMBOL_GPL(da7219_aad_exit);
+
+MODULE_DESCRIPTION("ASoC DA7219 AAD Driver");
+MODULE_AUTHOR("Adam Thomson <Adam.Thomson.Opensource@diasemi.com>");
+MODULE_LICENSE("GPL");
