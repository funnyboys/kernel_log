commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 61cc18e35efb..71fede9224c4 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -1,14 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * max9877.c  --  amp driver for max9877
  *
  * Copyright (C) 2009 Samsung Electronics Co.Ltd
  * Author: Joonyoung Shim <jy0922.shim@samsung.com>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
  */
 
 #include <linux/module.h>

commit 428157c1e8c9eaf0029430ae82ec0df8578de46b
Merge: 0a5ff077572d 82cf77a1bd61 9425e9d8c77d f57ddcdfa146 2e45a25f9cb6 1a3232d2f61d
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:57:34 2015 +0100

    Merge remote-tracking branches 'asoc/topic/tas2552', 'asoc/topic/tas5086', 'asoc/topic/tegra', 'asoc/topic/tlv' and 'asoc/topic/topology' into asoc-next

commit d6e3bb7aca7fbd092f1a19991526c095e59f8531
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Aug 2 17:19:46 2015 +0200

    ASoC: max9877: Replace TLV_DB_RANGE_HEAD with DECLARE_TLV_DB_RANGE
    
    DECLARE_TLV_DB_RANGE() has the advantage over using TLV_DB_RANGE_HEAD()
    that it automatically calculates the number of items in the TLV and is
    hence less prone to manual error.
    
    Generate using the following coccinelle script
    
    // <smpl>
    @@
    declarer name DECLARE_TLV_DB_RANGE;
    identifier tlv;
    constant x;
    @@
    -unsigned int tlv[] = {
    -       TLV_DB_RANGE_HEAD(x),
    +DECLARE_TLV_DB_RANGE(tlv,
            ...
    -};
    +);
    // </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 29549cdbf4c1..9aac52d884a2 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -30,19 +30,17 @@ static struct reg_default max9877_regs[] = {
 	{ 4, 0x49 },
 };
 
-static const unsigned int max9877_pgain_tlv[] = {
-	TLV_DB_RANGE_HEAD(2),
+static const DECLARE_TLV_DB_RANGE(max9877_pgain_tlv,
 	0, 1, TLV_DB_SCALE_ITEM(0, 900, 0),
-	2, 2, TLV_DB_SCALE_ITEM(2000, 0, 0),
-};
+	2, 2, TLV_DB_SCALE_ITEM(2000, 0, 0)
+);
 
-static const unsigned int max9877_output_tlv[] = {
-	TLV_DB_RANGE_HEAD(4),
+static const DECLARE_TLV_DB_RANGE(max9877_output_tlv,
 	0, 7, TLV_DB_SCALE_ITEM(-7900, 400, 1),
 	8, 15, TLV_DB_SCALE_ITEM(-4700, 300, 0),
 	16, 23, TLV_DB_SCALE_ITEM(-2300, 200, 0),
-	24, 31, TLV_DB_SCALE_ITEM(-700, 100, 0),
-};
+	24, 31, TLV_DB_SCALE_ITEM(-700, 100, 0)
+);
 
 static const char *max9877_out_mode[] = {
 	"INA -> SPK",

commit 623436af42ef2b37fee8f6058a85f4664bd32c74
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Jul 16 21:22:50 2015 +0200

    ASoC: max9877: Convert to component
    
    The driver does not use any CODEC specific constructs anymore. Convert it
    to snd_soc_component.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index b469e1c82ea2..fb448dde018d 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -121,7 +121,7 @@ static const struct snd_soc_dapm_route max9877_dapm_routes[] = {
 	{ "HPR", NULL, "SHDN" },
 };
 
-static const struct snd_soc_codec_driver max9877_codec = {
+static const struct snd_soc_component_driver max9877_component_driver = {
 	.controls = max9877_controls,
 	.num_controls = ARRAY_SIZE(max9877_controls),
 
@@ -154,14 +154,8 @@ static int max9877_i2c_probe(struct i2c_client *client,
 	for (i = 0; i < ARRAY_SIZE(max9877_regs); i++)
 		regmap_write(regmap, max9877_regs[i].reg, max9877_regs[i].def);
 
-	return snd_soc_register_codec(&client->dev, &max9877_codec, NULL, 0);
-}
-
-static int max9877_i2c_remove(struct i2c_client *client)
-{
-	snd_soc_unregister_codec(&client->dev);
-
-	return 0;
+	return devm_snd_soc_register_component(&client->dev,
+			&max9877_component_driver, NULL, 0);
 }
 
 static const struct i2c_device_id max9877_i2c_id[] = {
@@ -175,7 +169,6 @@ static struct i2c_driver max9877_i2c_driver = {
 		.name = "max9877",
 	},
 	.probe = max9877_i2c_probe,
-	.remove = max9877_i2c_remove,
 	.id_table = max9877_i2c_id,
 };
 

commit df2e268226e2e3d79980a5dddfd683126f79ddb4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Jul 16 21:22:49 2015 +0200

    ASoC: max9877: Make driver global regmap struct local
    
    Use a stack local variable to handle function local state rather than a
    global static variable. The later has a potential for race conditions if
    the probe function runs for two devices concurrently.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index e1df06fab756..b469e1c82ea2 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -20,8 +20,6 @@
 
 #include "max9877.h"
 
-static struct regmap *regmap;
-
 static const struct reg_default max9877_regs[] = {
 	{ 0, 0x40 },
 	{ 1, 0x00 },
@@ -145,6 +143,7 @@ static const struct regmap_config max9877_regmap = {
 static int max9877_i2c_probe(struct i2c_client *client,
 			     const struct i2c_device_id *id)
 {
+	struct regmap *regmap;
 	int i;
 
 	regmap = devm_regmap_init_i2c(client, &max9877_regmap);

commit 7d9fb377a747025232fe4e8d17e54ff8032aba27
Merge: 1c07a4de5baa c418a84a8c8f
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jul 16 21:35:01 2015 +0100

    Merge branches 'topic/owner' and 'topic/reg-default' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-max9877

commit 1c07a4de5baad76585f7ffb86b5b0bc34c33e8a6
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Wed Jul 15 13:21:44 2015 +0900

    ASoC: drivers: Drop owner assignment from i2c_driver
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 29549cdbf4c1..7692623ad5c3 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -174,7 +174,6 @@ MODULE_DEVICE_TABLE(i2c, max9877_i2c_id);
 static struct i2c_driver max9877_i2c_driver = {
 	.driver = {
 		.name = "max9877",
-		.owner = THIS_MODULE,
 	},
 	.probe = max9877_i2c_probe,
 	.remove = max9877_i2c_remove,

commit c418a84a8c8f98b1a0f30cd68d0cdf40d77aed01
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Jul 5 17:48:29 2015 +0800

    ASoC: Constify reg_default tables
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Peter Rosin <peda@axentia.se>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 29549cdbf4c1..8df99fb69ab1 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -22,7 +22,7 @@
 
 static struct regmap *regmap;
 
-static struct reg_default max9877_regs[] = {
+static const struct reg_default max9877_regs[] = {
 	{ 0, 0x40 },
 	{ 1, 0x00 },
 	{ 2, 0x00 },

commit 5cf9da8aacbfaed72ada8c195859f49d5d7f5f6c
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Aug 13 13:32:03 2013 +0100

    ASoC: max9877: Add basic DAPM support
    
    This does not fully map the power control available within the device
    but it provides the hooks for routing signals through the device and
    allows automatic management of the device low power mode.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 8505b401d3c4..29549cdbf4c1 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -87,15 +87,50 @@ static const struct snd_kcontrol_new max9877_controls[] = {
 		   MAX9877_INPUT_MODE, 6, 1, 0),
 	SOC_SINGLE("MAX9877 Bypass Mode Switch",
 		   MAX9877_OUTPUT_MODE, 6, 1, 0),
-	SOC_SINGLE("MAX9877 Shutdown Mode Switch",
-		   MAX9877_OUTPUT_MODE, 7, 1, 1),
 	SOC_ENUM("MAX9877 Output Mode", max9877_enum[0]),
 	SOC_ENUM("MAX9877 Oscillator Mode", max9877_enum[1]),
 };
 
+static const struct snd_soc_dapm_widget max9877_dapm_widgets[] = {
+SND_SOC_DAPM_INPUT("INA1"),
+SND_SOC_DAPM_INPUT("INA2"),
+SND_SOC_DAPM_INPUT("INB1"),
+SND_SOC_DAPM_INPUT("INB2"),
+SND_SOC_DAPM_INPUT("RXIN+"),
+SND_SOC_DAPM_INPUT("RXIN-"),
+
+SND_SOC_DAPM_PGA("SHDN", MAX9877_OUTPUT_MODE, 7, 1, NULL, 0),
+
+SND_SOC_DAPM_OUTPUT("OUT+"),
+SND_SOC_DAPM_OUTPUT("OUT-"),
+SND_SOC_DAPM_OUTPUT("HPL"),
+SND_SOC_DAPM_OUTPUT("HPR"),
+};
+
+static const struct snd_soc_dapm_route max9877_dapm_routes[] = {
+	{ "SHDN", NULL, "INA1" },
+	{ "SHDN", NULL, "INA2" },
+	{ "SHDN", NULL, "INB1" },
+	{ "SHDN", NULL, "INB2" },
+
+	{ "OUT+", NULL, "RXIN+" },
+	{ "OUT+", NULL, "SHDN" },
+
+	{ "OUT-", NULL, "SHDN" },
+	{ "OUT-", NULL, "RXIN-" },
+
+	{ "HPL", NULL, "SHDN" },
+	{ "HPR", NULL, "SHDN" },
+};
+
 static const struct snd_soc_codec_driver max9877_codec = {
 	.controls = max9877_controls,
 	.num_controls = ARRAY_SIZE(max9877_controls),
+
+	.dapm_widgets = max9877_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(max9877_dapm_widgets),
+	.dapm_routes = max9877_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(max9877_dapm_routes),
 };
 
 static const struct regmap_config max9877_regmap = {

commit d76a96174b31bd916c1dfaa81a3db82fc8c54b91
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Aug 13 13:20:15 2013 +0100

    ASoC: max9877: Convert to standard CODEC driver
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 7e2fe5023fb2..8505b401d3c4 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -30,189 +30,6 @@ static struct reg_default max9877_regs[] = {
 	{ 4, 0x49 },
 };
 
-static int max9877_get_reg(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int mask = mc->max;
-	unsigned int invert = mc->invert;
-	unsigned int val;
-	int ret;
-
-	ret = regmap_read(regmap, reg, &val);
-	if (ret != 0)
-		return ret;
-
-	ucontrol->value.integer.value[0] = (val >> shift) & mask;
-
-	if (invert)
-		ucontrol->value.integer.value[0] =
-			mask - ucontrol->value.integer.value[0];
-
-	return 0;
-}
-
-static int max9877_set_reg(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int mask = mc->max;
-	unsigned int invert = mc->invert;
-	unsigned int val = (ucontrol->value.integer.value[0] & mask);
-	bool change;
-	int ret;
-
-	if (invert)
-		val = mask - val;
-
-	ret = regmap_update_bits_check(regmap, reg, mask << shift,
-				       val << shift, &change);
-	if (ret != 0)
-		return ret;
-
-	if (change)
-		return 1;
-	else
-		return 0;
-}
-
-static int max9877_get_2reg(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int mask = mc->max;
-	unsigned int val;
-	int ret;
-
-	ret = regmap_read(regmap, reg, &val);
-	if (ret != 0)
-		return ret;
-	ucontrol->value.integer.value[0] = (val >> shift) & mask;
-
-	ret = regmap_read(regmap, reg2, &val);
-	if (ret != 0)
-		return ret;
-	ucontrol->value.integer.value[1] = (val >> shift) & mask;
-
-	return 0;
-}
-
-static int max9877_set_2reg(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int mask = mc->max;
-	unsigned int val = (ucontrol->value.integer.value[0] & mask);
-	unsigned int val2 = (ucontrol->value.integer.value[1] & mask);
-	bool change1, change2;
-	int ret;
-
-	ret = regmap_update_bits_check(regmap, reg, mask << shift,
-				       val << shift, &change1);
-	if (ret != 0)
-		return ret;
-
-	ret = regmap_update_bits_check(regmap, reg2, mask << shift,
-				       val2 << shift, &change2);
-	if (ret != 0)
-		return ret;
-
-	if (change1 || change2)
-		return 1;
-	else
-		return 0;
-}
-
-static int max9877_get_out_mode(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	unsigned int val;
-	int ret;
-
-	ret = regmap_read(regmap, MAX9877_OUTPUT_MODE, &val);
-	if (ret != 0)
-		return ret;
-
-	val &= MAX9877_OUTMODE_MASK;
-	if (val)
-		val--;
-
-	ucontrol->value.integer.value[0] = val;
-
-	return 0;
-}
-
-static int max9877_set_out_mode(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	unsigned int val;
-	bool change;
-	int ret;
-
-	val = ucontrol->value.integer.value[0] + 1;
-
-	ret = regmap_update_bits_check(regmap, MAX9877_OUTPUT_MODE,
-				       MAX9877_OUTMODE_MASK, val, &change);
-	if (ret != 0)
-		return ret;
-
-	if (change)
-		return 1;
-	else
-		return 0;
-}
-
-static int max9877_get_osc_mode(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	unsigned int val;
-	int ret;
-
-	ret = regmap_read(regmap, MAX9877_OUTPUT_MODE, &val);
-	if (ret != 0)
-		return ret;
-
-	val &= MAX9877_OSC_MASK;
-	val >>= MAX9877_OSC_OFFSET;
-
-	ucontrol->value.integer.value[0] = val;
-
-	return 0;
-}
-
-static int max9877_set_osc_mode(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	unsigned int val;
-	bool change;
-	int ret;
-
-	val = ucontrol->value.integer.value[0] << MAX9877_OSC_OFFSET;
-	ret = regmap_update_bits_check(regmap, MAX9877_OUTPUT_MODE,
-				       MAX9877_OSC_MASK, val, &change);
-	if (ret != 0)
-		return ret;
-
-	if (change)
-		return 1;
-	else
-		return 0;
-}
-
 static const unsigned int max9877_pgain_tlv[] = {
 	TLV_DB_RANGE_HEAD(2),
 	0, 1, TLV_DB_SCALE_ITEM(0, 900, 0),
@@ -246,51 +63,40 @@ static const char *max9877_osc_mode[] = {
 };
 
 static const struct soc_enum max9877_enum[] = {
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(max9877_out_mode), max9877_out_mode),
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(max9877_osc_mode), max9877_osc_mode),
+	SOC_ENUM_SINGLE(MAX9877_OUTPUT_MODE, 0, ARRAY_SIZE(max9877_out_mode),
+			max9877_out_mode),
+	SOC_ENUM_SINGLE(MAX9877_OUTPUT_MODE, MAX9877_OSC_OFFSET,
+			ARRAY_SIZE(max9877_osc_mode), max9877_osc_mode),
 };
 
 static const struct snd_kcontrol_new max9877_controls[] = {
-	SOC_SINGLE_EXT_TLV("MAX9877 PGAINA Playback Volume",
-			MAX9877_INPUT_MODE, 0, 2, 0,
-			max9877_get_reg, max9877_set_reg, max9877_pgain_tlv),
-	SOC_SINGLE_EXT_TLV("MAX9877 PGAINB Playback Volume",
-			MAX9877_INPUT_MODE, 2, 2, 0,
-			max9877_get_reg, max9877_set_reg, max9877_pgain_tlv),
-	SOC_SINGLE_EXT_TLV("MAX9877 Amp Speaker Playback Volume",
-			MAX9877_SPK_VOLUME, 0, 31, 0,
-			max9877_get_reg, max9877_set_reg, max9877_output_tlv),
-	SOC_DOUBLE_R_EXT_TLV("MAX9877 Amp HP Playback Volume",
-			MAX9877_HPL_VOLUME, MAX9877_HPR_VOLUME, 0, 31, 0,
-			max9877_get_2reg, max9877_set_2reg, max9877_output_tlv),
-	SOC_SINGLE_EXT("MAX9877 INB Stereo Switch",
-			MAX9877_INPUT_MODE, 4, 1, 1,
-			max9877_get_reg, max9877_set_reg),
-	SOC_SINGLE_EXT("MAX9877 INA Stereo Switch",
-			MAX9877_INPUT_MODE, 5, 1, 1,
-			max9877_get_reg, max9877_set_reg),
-	SOC_SINGLE_EXT("MAX9877 Zero-crossing detection Switch",
-			MAX9877_INPUT_MODE, 6, 1, 0,
-			max9877_get_reg, max9877_set_reg),
-	SOC_SINGLE_EXT("MAX9877 Bypass Mode Switch",
-			MAX9877_OUTPUT_MODE, 6, 1, 0,
-			max9877_get_reg, max9877_set_reg),
-	SOC_SINGLE_EXT("MAX9877 Shutdown Mode Switch",
-			MAX9877_OUTPUT_MODE, 7, 1, 1,
-			max9877_get_reg, max9877_set_reg),
-	SOC_ENUM_EXT("MAX9877 Output Mode", max9877_enum[0],
-			max9877_get_out_mode, max9877_set_out_mode),
-	SOC_ENUM_EXT("MAX9877 Oscillator Mode", max9877_enum[1],
-			max9877_get_osc_mode, max9877_set_osc_mode),
+	SOC_SINGLE_TLV("MAX9877 PGAINA Playback Volume",
+		       MAX9877_INPUT_MODE, 0, 2, 0, max9877_pgain_tlv),
+	SOC_SINGLE_TLV("MAX9877 PGAINB Playback Volume",
+		       MAX9877_INPUT_MODE, 2, 2, 0, max9877_pgain_tlv),
+	SOC_SINGLE_TLV("MAX9877 Amp Speaker Playback Volume",
+		       MAX9877_SPK_VOLUME, 0, 31, 0, max9877_output_tlv),
+	SOC_DOUBLE_R_TLV("MAX9877 Amp HP Playback Volume",
+			 MAX9877_HPL_VOLUME, MAX9877_HPR_VOLUME, 0, 31, 0,
+			 max9877_output_tlv),
+	SOC_SINGLE("MAX9877 INB Stereo Switch",
+		   MAX9877_INPUT_MODE, 4, 1, 1),
+	SOC_SINGLE("MAX9877 INA Stereo Switch",
+		   MAX9877_INPUT_MODE, 5, 1, 1),
+	SOC_SINGLE("MAX9877 Zero-crossing detection Switch",
+		   MAX9877_INPUT_MODE, 6, 1, 0),
+	SOC_SINGLE("MAX9877 Bypass Mode Switch",
+		   MAX9877_OUTPUT_MODE, 6, 1, 0),
+	SOC_SINGLE("MAX9877 Shutdown Mode Switch",
+		   MAX9877_OUTPUT_MODE, 7, 1, 1),
+	SOC_ENUM("MAX9877 Output Mode", max9877_enum[0]),
+	SOC_ENUM("MAX9877 Oscillator Mode", max9877_enum[1]),
 };
 
-/* This function is called from ASoC machine driver */
-int max9877_add_controls(struct snd_soc_codec *codec)
-{
-	return snd_soc_add_codec_controls(codec, max9877_controls,
-			ARRAY_SIZE(max9877_controls));
-}
-EXPORT_SYMBOL_GPL(max9877_add_controls);
+static const struct snd_soc_codec_driver max9877_codec = {
+	.controls = max9877_controls,
+	.num_controls = ARRAY_SIZE(max9877_controls),
+};
 
 static const struct regmap_config max9877_regmap = {
 	.reg_bits = 8,
@@ -314,12 +120,12 @@ static int max9877_i2c_probe(struct i2c_client *client,
 	for (i = 0; i < ARRAY_SIZE(max9877_regs); i++)
 		regmap_write(regmap, max9877_regs[i].reg, max9877_regs[i].def);
 
-	return 0;
+	return snd_soc_register_codec(&client->dev, &max9877_codec, NULL, 0);
 }
 
 static int max9877_i2c_remove(struct i2c_client *client)
 {
-	regmap = NULL;
+	snd_soc_unregister_codec(&client->dev);
 
 	return 0;
 }

commit 997288e3824e4c6a7ab4ca4f580fe35e138d62e8
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Aug 13 13:10:19 2013 +0100

    ASoC: max9877: Convert to use regmap API
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 6b6c74cd83e2..7e2fe5023fb2 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -14,27 +14,21 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/i2c.h>
+#include <linux/regmap.h>
 #include <sound/soc.h>
 #include <sound/tlv.h>
 
 #include "max9877.h"
 
-static struct i2c_client *i2c;
+static struct regmap *regmap;
 
-static u8 max9877_regs[5] = { 0x40, 0x00, 0x00, 0x00, 0x49 };
-
-static void max9877_write_regs(void)
-{
-	unsigned int i;
-	u8 data[6];
-
-	data[0] = MAX9877_INPUT_MODE;
-	for (i = 0; i < ARRAY_SIZE(max9877_regs); i++)
-		data[i + 1] = max9877_regs[i];
-
-	if (i2c_master_send(i2c, data, 6) != 6)
-		dev_err(&i2c->dev, "i2c write failed\n");
-}
+static struct reg_default max9877_regs[] = {
+	{ 0, 0x40 },
+	{ 1, 0x00 },
+	{ 2, 0x00 },
+	{ 3, 0x00 },
+	{ 4, 0x49 },
+};
 
 static int max9877_get_reg(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
@@ -45,8 +39,14 @@ static int max9877_get_reg(struct snd_kcontrol *kcontrol,
 	unsigned int shift = mc->shift;
 	unsigned int mask = mc->max;
 	unsigned int invert = mc->invert;
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(regmap, reg, &val);
+	if (ret != 0)
+		return ret;
 
-	ucontrol->value.integer.value[0] = (max9877_regs[reg] >> shift) & mask;
+	ucontrol->value.integer.value[0] = (val >> shift) & mask;
 
 	if (invert)
 		ucontrol->value.integer.value[0] =
@@ -65,18 +65,21 @@ static int max9877_set_reg(struct snd_kcontrol *kcontrol,
 	unsigned int mask = mc->max;
 	unsigned int invert = mc->invert;
 	unsigned int val = (ucontrol->value.integer.value[0] & mask);
+	bool change;
+	int ret;
 
 	if (invert)
 		val = mask - val;
 
-	if (((max9877_regs[reg] >> shift) & mask) == val)
-		return 0;
-
-	max9877_regs[reg] &= ~(mask << shift);
-	max9877_regs[reg] |= val << shift;
-	max9877_write_regs();
+	ret = regmap_update_bits_check(regmap, reg, mask << shift,
+				       val << shift, &change);
+	if (ret != 0)
+		return ret;
 
-	return 1;
+	if (change)
+		return 1;
+	else
+		return 0;
 }
 
 static int max9877_get_2reg(struct snd_kcontrol *kcontrol,
@@ -88,9 +91,18 @@ static int max9877_get_2reg(struct snd_kcontrol *kcontrol,
 	unsigned int reg2 = mc->rreg;
 	unsigned int shift = mc->shift;
 	unsigned int mask = mc->max;
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(regmap, reg, &val);
+	if (ret != 0)
+		return ret;
+	ucontrol->value.integer.value[0] = (val >> shift) & mask;
 
-	ucontrol->value.integer.value[0] = (max9877_regs[reg] >> shift) & mask;
-	ucontrol->value.integer.value[1] = (max9877_regs[reg2] >> shift) & mask;
+	ret = regmap_read(regmap, reg2, &val);
+	if (ret != 0)
+		return ret;
+	ucontrol->value.integer.value[1] = (val >> shift) & mask;
 
 	return 0;
 }
@@ -106,77 +118,99 @@ static int max9877_set_2reg(struct snd_kcontrol *kcontrol,
 	unsigned int mask = mc->max;
 	unsigned int val = (ucontrol->value.integer.value[0] & mask);
 	unsigned int val2 = (ucontrol->value.integer.value[1] & mask);
-	unsigned int change = 0;
-
-	if (((max9877_regs[reg] >> shift) & mask) != val)
-		change = 1;
-
-	if (((max9877_regs[reg2] >> shift) & mask) != val2)
-		change = 1;
-
-	if (change) {
-		max9877_regs[reg] &= ~(mask << shift);
-		max9877_regs[reg] |= val << shift;
-		max9877_regs[reg2] &= ~(mask << shift);
-		max9877_regs[reg2] |= val2 << shift;
-		max9877_write_regs();
-	}
-
-	return change;
+	bool change1, change2;
+	int ret;
+
+	ret = regmap_update_bits_check(regmap, reg, mask << shift,
+				       val << shift, &change1);
+	if (ret != 0)
+		return ret;
+
+	ret = regmap_update_bits_check(regmap, reg2, mask << shift,
+				       val2 << shift, &change2);
+	if (ret != 0)
+		return ret;
+
+	if (change1 || change2)
+		return 1;
+	else
+		return 0;
 }
 
 static int max9877_get_out_mode(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
-	u8 value = max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OUTMODE_MASK;
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(regmap, MAX9877_OUTPUT_MODE, &val);
+	if (ret != 0)
+		return ret;
+
+	val &= MAX9877_OUTMODE_MASK;
+	if (val)
+		val--;
 
-	if (value)
-		value -= 1;
+	ucontrol->value.integer.value[0] = val;
 
-	ucontrol->value.integer.value[0] = value;
 	return 0;
 }
 
 static int max9877_set_out_mode(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
-	u8 value = ucontrol->value.integer.value[0];
+	unsigned int val;
+	bool change;
+	int ret;
 
-	value += 1;
+	val = ucontrol->value.integer.value[0] + 1;
 
-	if ((max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OUTMODE_MASK) == value)
-		return 0;
+	ret = regmap_update_bits_check(regmap, MAX9877_OUTPUT_MODE,
+				       MAX9877_OUTMODE_MASK, val, &change);
+	if (ret != 0)
+		return ret;
 
-	max9877_regs[MAX9877_OUTPUT_MODE] &= ~MAX9877_OUTMODE_MASK;
-	max9877_regs[MAX9877_OUTPUT_MODE] |= value;
-	max9877_write_regs();
-	return 1;
+	if (change)
+		return 1;
+	else
+		return 0;
 }
 
 static int max9877_get_osc_mode(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
-	u8 value = (max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OSC_MASK);
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(regmap, MAX9877_OUTPUT_MODE, &val);
+	if (ret != 0)
+		return ret;
+
+	val &= MAX9877_OSC_MASK;
+	val >>= MAX9877_OSC_OFFSET;
 
-	value = value >> MAX9877_OSC_OFFSET;
+	ucontrol->value.integer.value[0] = val;
 
-	ucontrol->value.integer.value[0] = value;
 	return 0;
 }
 
 static int max9877_set_osc_mode(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
-	u8 value = ucontrol->value.integer.value[0];
-
-	value = value << MAX9877_OSC_OFFSET;
-	if ((max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OSC_MASK) == value)
+	unsigned int val;
+	bool change;
+	int ret;
+
+	val = ucontrol->value.integer.value[0] << MAX9877_OSC_OFFSET;
+	ret = regmap_update_bits_check(regmap, MAX9877_OUTPUT_MODE,
+				       MAX9877_OSC_MASK, val, &change);
+	if (ret != 0)
+		return ret;
+
+	if (change)
+		return 1;
+	else
 		return 0;
-
-	max9877_regs[MAX9877_OUTPUT_MODE] &= ~MAX9877_OSC_MASK;
-	max9877_regs[MAX9877_OUTPUT_MODE] |= value;
-	max9877_write_regs();
-	return 1;
 }
 
 static const unsigned int max9877_pgain_tlv[] = {
@@ -258,19 +292,34 @@ int max9877_add_controls(struct snd_soc_codec *codec)
 }
 EXPORT_SYMBOL_GPL(max9877_add_controls);
 
+static const struct regmap_config max9877_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.reg_defaults = max9877_regs,
+	.num_reg_defaults = ARRAY_SIZE(max9877_regs),
+	.cache_type = REGCACHE_RBTREE,
+};
+
 static int max9877_i2c_probe(struct i2c_client *client,
 			     const struct i2c_device_id *id)
 {
-	i2c = client;
+	int i;
+
+	regmap = devm_regmap_init_i2c(client, &max9877_regmap);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
 
-	max9877_write_regs();
+	/* Ensure the device is in reset state */
+	for (i = 0; i < ARRAY_SIZE(max9877_regs); i++)
+		regmap_write(regmap, max9877_regs[i].reg, max9877_regs[i].def);
 
 	return 0;
 }
 
 static int max9877_i2c_remove(struct i2c_client *client)
 {
-	i2c = NULL;
+	regmap = NULL;
 
 	return 0;
 }

commit 7a79e94e973639da7bf1b8242d504f9db9e5e848
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Dec 7 09:26:37 2012 -0500

    ASoC: codecs: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index d15e5943c85e..6b6c74cd83e2 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -258,8 +258,8 @@ int max9877_add_controls(struct snd_soc_codec *codec)
 }
 EXPORT_SYMBOL_GPL(max9877_add_controls);
 
-static int __devinit max9877_i2c_probe(struct i2c_client *client,
-		const struct i2c_device_id *id)
+static int max9877_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
 {
 	i2c = client;
 
@@ -268,7 +268,7 @@ static int __devinit max9877_i2c_probe(struct i2c_client *client,
 	return 0;
 }
 
-static __devexit int max9877_i2c_remove(struct i2c_client *client)
+static int max9877_i2c_remove(struct i2c_client *client)
 {
 	i2c = NULL;
 
@@ -287,7 +287,7 @@ static struct i2c_driver max9877_i2c_driver = {
 		.owner = THIS_MODULE,
 	},
 	.probe = max9877_i2c_probe,
-	.remove = __devexit_p(max9877_i2c_remove),
+	.remove = max9877_i2c_remove,
 	.id_table = max9877_i2c_id,
 };
 

commit a3627e9c0a22283cb1f73fa1170f70fe604315d9
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Aug 6 17:25:35 2012 +0530

    ASoC: max9877: Use module_i2c_driver
    
    module_i2c_driver makes the code simpler by eliminating module_init
    and module_exit calls.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 3a2ba3d8fd6d..d15e5943c85e 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -291,17 +291,7 @@ static struct i2c_driver max9877_i2c_driver = {
 	.id_table = max9877_i2c_id,
 };
 
-static int __init max9877_init(void)
-{
-	return i2c_add_driver(&max9877_i2c_driver);
-}
-module_init(max9877_init);
-
-static void __exit max9877_exit(void)
-{
-	i2c_del_driver(&max9877_i2c_driver);
-}
-module_exit(max9877_exit);
+module_i2c_driver(max9877_i2c_driver);
 
 MODULE_DESCRIPTION("ASoC MAX9877 amp driver");
 MODULE_AUTHOR("Joonyoung Shim <jy0922.shim@samsung.com>");

commit 022658beab5581ecc1d325d60857f2fc464da22f
Author: Liam Girdwood <lrg@ti.com>
Date:   Fri Feb 3 17:43:09 2012 +0000

    ASoC: core: Add support for DAI and machine kcontrols.
    
    Currently ASoC can only add kcontrols using codec and platform component device
    handles. It's also desirable to add kcontrols for DAIs (i.e. McBSP) and for
    SoC card machine drivers too. This allows the kcontrol to have a direct handle to
    the parent ASoC component DAI/SoC Card/Platform/Codec device and hence easily
    get it's private data.
    
    This change makes snd_soc_add_controls() static and wraps it in the folowing
    calls (card and dai are new) :-
    
    snd_soc_add_card_controls()
    snd_soc_add_codec_controls()
    snd_soc_add_dai_controls()
    snd_soc_add_platform_controls()
    
    This patch also does a lot of small mechanical changes in individual codec drivers
    to replace snd_soc_add_controls() with snd_soc_add_codec_controls().
    
    It also updates the McBSP DAI driver to use snd_soc_add_dai_controls().
    
    Finally, it updates the existing machine drivers that register controls to either :-
    
    1) Use snd_soc_add_card_controls() where no direct codec control is required.
    2) Use snd_soc_add_codec_controls() where there is direct codec control.
    
    In the case of 1) above we also update the machine drivers to get the correct
    component data pointers from the kcontrol (rather than getting the machine pointer
    via the codec pointer).
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index dcf6f2a1600a..3a2ba3d8fd6d 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -253,7 +253,7 @@ static const struct snd_kcontrol_new max9877_controls[] = {
 /* This function is called from ASoC machine driver */
 int max9877_add_controls(struct snd_soc_codec *codec)
 {
-	return snd_soc_add_controls(codec, max9877_controls,
+	return snd_soc_add_codec_controls(codec, max9877_controls,
 			ARRAY_SIZE(max9877_controls));
 }
 EXPORT_SYMBOL_GPL(max9877_add_controls);

commit 5c4b2aa3fd1dc30af098de5dec766a817621ace2
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Nov 22 14:47:44 2011 +0800

    ASoC: max9877: Update register if either val or val2 is changed
    
    In the case of ((max9877_regs[reg] >> shift) & mask) != val
    but ((max9877_regs[reg2] >> shift) & mask) == val2,
    current code does not update the registers.
    
    Fix the logic to update registers if either val or val2 is changed.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 9e7e964a5fa3..dcf6f2a1600a 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -106,13 +106,13 @@ static int max9877_set_2reg(struct snd_kcontrol *kcontrol,
 	unsigned int mask = mc->max;
 	unsigned int val = (ucontrol->value.integer.value[0] & mask);
 	unsigned int val2 = (ucontrol->value.integer.value[1] & mask);
-	unsigned int change = 1;
+	unsigned int change = 0;
 
-	if (((max9877_regs[reg] >> shift) & mask) == val)
-		change = 0;
+	if (((max9877_regs[reg] >> shift) & mask) != val)
+		change = 1;
 
-	if (((max9877_regs[reg2] >> shift) & mask) == val2)
-		change = 0;
+	if (((max9877_regs[reg2] >> shift) & mask) != val2)
+		change = 1;
 
 	if (change) {
 		max9877_regs[reg] &= ~(mask << shift);

commit a7569afa8b79ca9272b0d7544335bc05b5b721d6
Author: Joonyoung Shim <jy0922.shim@samsung.com>
Date:   Thu Jul 23 17:33:17 2009 +0900

    ASoC: MAX9877: fix write operation for register
    
    The MAX9877 needs an address of start register when we write values to
    registers through i2c_master_send(), but the code for this was missed in
    max9877_write_regs().
    
    If the value of control is 0 in the max9877_set_out_mode(), the value is
    not increased to 1, but actually the value to write to the register
    should be 1.
    And the register bits for out_mode and osc_mode should be cleared before
    writing.
    
    Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index a1f1119e1b7a..9e7e964a5fa3 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -25,7 +25,14 @@ static u8 max9877_regs[5] = { 0x40, 0x00, 0x00, 0x00, 0x49 };
 
 static void max9877_write_regs(void)
 {
-	if (i2c_master_send(i2c, max9877_regs, 5) != 5)
+	unsigned int i;
+	u8 data[6];
+
+	data[0] = MAX9877_INPUT_MODE;
+	for (i = 0; i < ARRAY_SIZE(max9877_regs); i++)
+		data[i + 1] = max9877_regs[i];
+
+	if (i2c_master_send(i2c, data, 6) != 6)
 		dev_err(&i2c->dev, "i2c write failed\n");
 }
 
@@ -135,12 +142,12 @@ static int max9877_set_out_mode(struct snd_kcontrol *kcontrol,
 {
 	u8 value = ucontrol->value.integer.value[0];
 
-	if (value)
-		value += 1;
+	value += 1;
 
 	if ((max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OUTMODE_MASK) == value)
 		return 0;
 
+	max9877_regs[MAX9877_OUTPUT_MODE] &= ~MAX9877_OUTMODE_MASK;
 	max9877_regs[MAX9877_OUTPUT_MODE] |= value;
 	max9877_write_regs();
 	return 1;
@@ -166,6 +173,7 @@ static int max9877_set_osc_mode(struct snd_kcontrol *kcontrol,
 	if ((max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OSC_MASK) == value)
 		return 0;
 
+	max9877_regs[MAX9877_OUTPUT_MODE] &= ~MAX9877_OSC_MASK;
 	max9877_regs[MAX9877_OUTPUT_MODE] |= value;
 	max9877_write_regs();
 	return 1;

commit e458a48f8776d624d05246471501c6086adb1d7a
Author: Joonyoung Shim <jy0922.shim@samsung.com>
Date:   Wed Jul 22 14:09:08 2009 +0900

    ASoC: MAX9877: separate callback functions
    
    The callback function to control register was used by whole controls in
    MAX9877 driver, but this causes using many if statement for double
    register control or invert.
    So, the callback function for double register control is separate
    differently, and the code for invert is added in the callback function.
    
    Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
index 7df9a7c0208b..a1f1119e1b7a 100644
--- a/sound/soc/codecs/max9877.c
+++ b/sound/soc/codecs/max9877.c
@@ -34,16 +34,16 @@ static int max9877_get_reg(struct snd_kcontrol *kcontrol,
 {
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	int reg = mc->reg;
-	int reg2 = mc->rreg;
-	int shift = mc->shift;
-	int mask = mc->max;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = mc->max;
+	unsigned int invert = mc->invert;
 
 	ucontrol->value.integer.value[0] = (max9877_regs[reg] >> shift) & mask;
 
-	if (reg2)
-		ucontrol->value.integer.value[1] =
-			(max9877_regs[reg2] >> shift) & mask;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
 
 	return 0;
 }
@@ -53,39 +53,69 @@ static int max9877_set_reg(struct snd_kcontrol *kcontrol,
 {
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	int reg = mc->reg;
-	int reg2 = mc->rreg;
-	int shift = mc->shift;
-	int mask = mc->max;
-	int change = 1;
-	int change2 = 1;
-	int ret = 0;
-
-	if (((max9877_regs[reg] >> shift) & mask) ==
-			ucontrol->value.integer.value[0])
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = mc->max;
+	unsigned int invert = mc->invert;
+	unsigned int val = (ucontrol->value.integer.value[0] & mask);
+
+	if (invert)
+		val = mask - val;
+
+	if (((max9877_regs[reg] >> shift) & mask) == val)
+		return 0;
+
+	max9877_regs[reg] &= ~(mask << shift);
+	max9877_regs[reg] |= val << shift;
+	max9877_write_regs();
+
+	return 1;
+}
+
+static int max9877_get_2reg(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = mc->max;
+
+	ucontrol->value.integer.value[0] = (max9877_regs[reg] >> shift) & mask;
+	ucontrol->value.integer.value[1] = (max9877_regs[reg2] >> shift) & mask;
+
+	return 0;
+}
+
+static int max9877_set_2reg(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = mc->max;
+	unsigned int val = (ucontrol->value.integer.value[0] & mask);
+	unsigned int val2 = (ucontrol->value.integer.value[1] & mask);
+	unsigned int change = 1;
+
+	if (((max9877_regs[reg] >> shift) & mask) == val)
 		change = 0;
 
-	if (reg2)
-		if (((max9877_regs[reg2] >> shift) & mask) ==
-				ucontrol->value.integer.value[1])
-			change2 = 0;
+	if (((max9877_regs[reg2] >> shift) & mask) == val2)
+		change = 0;
 
 	if (change) {
 		max9877_regs[reg] &= ~(mask << shift);
-		max9877_regs[reg] |= ucontrol->value.integer.value[0] << shift;
-		ret = change;
-	}
-
-	if (reg2 && change2) {
+		max9877_regs[reg] |= val << shift;
 		max9877_regs[reg2] &= ~(mask << shift);
-		max9877_regs[reg2] |= ucontrol->value.integer.value[1] << shift;
-		ret = change2;
-	}
-
-	if (ret)
+		max9877_regs[reg2] |= val2 << shift;
 		max9877_write_regs();
+	}
 
-	return ret;
+	return change;
 }
 
 static int max9877_get_out_mode(struct snd_kcontrol *kcontrol,
@@ -190,7 +220,7 @@ static const struct snd_kcontrol_new max9877_controls[] = {
 			max9877_get_reg, max9877_set_reg, max9877_output_tlv),
 	SOC_DOUBLE_R_EXT_TLV("MAX9877 Amp HP Playback Volume",
 			MAX9877_HPL_VOLUME, MAX9877_HPR_VOLUME, 0, 31, 0,
-			max9877_get_reg, max9877_set_reg, max9877_output_tlv),
+			max9877_get_2reg, max9877_set_2reg, max9877_output_tlv),
 	SOC_SINGLE_EXT("MAX9877 INB Stereo Switch",
 			MAX9877_INPUT_MODE, 4, 1, 1,
 			max9877_get_reg, max9877_set_reg),

commit 9db9ed977d4f1a317f5f4d467d43025fa27223d8
Author: Joonyoung Shim <jy0922.shim@samsung.com>
Date:   Wed Jul 15 20:34:00 2009 +0900

    ASoC: MAX9877: add MAX9877 amp driver
    
    The MAX9877 combines a high-efficiency Class D audio power amplifier
    with a stereo Class AB capacitor-less DirectDrive headphone amplifier.
    
    The max9877_add_controls() is called to register the MAX9877 specific
    controls on machine specific init() of the machine driver.
    
    The datasheet for the MAX9877 can find at the following url:
    http://datasheets.maxim-ic.com/en/ds/MAX9877.pdf
    
    [Slight edit to sort the ALL_CODECS entries -- broonie.]
    
    Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max9877.c b/sound/soc/codecs/max9877.c
new file mode 100644
index 000000000000..7df9a7c0208b
--- /dev/null
+++ b/sound/soc/codecs/max9877.c
@@ -0,0 +1,270 @@
+/*
+ * max9877.c  --  amp driver for max9877
+ *
+ * Copyright (C) 2009 Samsung Electronics Co.Ltd
+ * Author: Joonyoung Shim <jy0922.shim@samsung.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "max9877.h"
+
+static struct i2c_client *i2c;
+
+static u8 max9877_regs[5] = { 0x40, 0x00, 0x00, 0x00, 0x49 };
+
+static void max9877_write_regs(void)
+{
+	if (i2c_master_send(i2c, max9877_regs, 5) != 5)
+		dev_err(&i2c->dev, "i2c write failed\n");
+}
+
+static int max9877_get_reg(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int reg = mc->reg;
+	int reg2 = mc->rreg;
+	int shift = mc->shift;
+	int mask = mc->max;
+
+	ucontrol->value.integer.value[0] = (max9877_regs[reg] >> shift) & mask;
+
+	if (reg2)
+		ucontrol->value.integer.value[1] =
+			(max9877_regs[reg2] >> shift) & mask;
+
+	return 0;
+}
+
+static int max9877_set_reg(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int reg = mc->reg;
+	int reg2 = mc->rreg;
+	int shift = mc->shift;
+	int mask = mc->max;
+	int change = 1;
+	int change2 = 1;
+	int ret = 0;
+
+	if (((max9877_regs[reg] >> shift) & mask) ==
+			ucontrol->value.integer.value[0])
+		change = 0;
+
+	if (reg2)
+		if (((max9877_regs[reg2] >> shift) & mask) ==
+				ucontrol->value.integer.value[1])
+			change2 = 0;
+
+	if (change) {
+		max9877_regs[reg] &= ~(mask << shift);
+		max9877_regs[reg] |= ucontrol->value.integer.value[0] << shift;
+		ret = change;
+	}
+
+	if (reg2 && change2) {
+		max9877_regs[reg2] &= ~(mask << shift);
+		max9877_regs[reg2] |= ucontrol->value.integer.value[1] << shift;
+		ret = change2;
+	}
+
+	if (ret)
+		max9877_write_regs();
+
+	return ret;
+}
+
+static int max9877_get_out_mode(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	u8 value = max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OUTMODE_MASK;
+
+	if (value)
+		value -= 1;
+
+	ucontrol->value.integer.value[0] = value;
+	return 0;
+}
+
+static int max9877_set_out_mode(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	u8 value = ucontrol->value.integer.value[0];
+
+	if (value)
+		value += 1;
+
+	if ((max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OUTMODE_MASK) == value)
+		return 0;
+
+	max9877_regs[MAX9877_OUTPUT_MODE] |= value;
+	max9877_write_regs();
+	return 1;
+}
+
+static int max9877_get_osc_mode(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	u8 value = (max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OSC_MASK);
+
+	value = value >> MAX9877_OSC_OFFSET;
+
+	ucontrol->value.integer.value[0] = value;
+	return 0;
+}
+
+static int max9877_set_osc_mode(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	u8 value = ucontrol->value.integer.value[0];
+
+	value = value << MAX9877_OSC_OFFSET;
+	if ((max9877_regs[MAX9877_OUTPUT_MODE] & MAX9877_OSC_MASK) == value)
+		return 0;
+
+	max9877_regs[MAX9877_OUTPUT_MODE] |= value;
+	max9877_write_regs();
+	return 1;
+}
+
+static const unsigned int max9877_pgain_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 1, TLV_DB_SCALE_ITEM(0, 900, 0),
+	2, 2, TLV_DB_SCALE_ITEM(2000, 0, 0),
+};
+
+static const unsigned int max9877_output_tlv[] = {
+	TLV_DB_RANGE_HEAD(4),
+	0, 7, TLV_DB_SCALE_ITEM(-7900, 400, 1),
+	8, 15, TLV_DB_SCALE_ITEM(-4700, 300, 0),
+	16, 23, TLV_DB_SCALE_ITEM(-2300, 200, 0),
+	24, 31, TLV_DB_SCALE_ITEM(-700, 100, 0),
+};
+
+static const char *max9877_out_mode[] = {
+	"INA -> SPK",
+	"INA -> HP",
+	"INA -> SPK and HP",
+	"INB -> SPK",
+	"INB -> HP",
+	"INB -> SPK and HP",
+	"INA + INB -> SPK",
+	"INA + INB -> HP",
+	"INA + INB -> SPK and HP",
+};
+
+static const char *max9877_osc_mode[] = {
+	"1176KHz",
+	"1100KHz",
+	"700KHz",
+};
+
+static const struct soc_enum max9877_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(max9877_out_mode), max9877_out_mode),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(max9877_osc_mode), max9877_osc_mode),
+};
+
+static const struct snd_kcontrol_new max9877_controls[] = {
+	SOC_SINGLE_EXT_TLV("MAX9877 PGAINA Playback Volume",
+			MAX9877_INPUT_MODE, 0, 2, 0,
+			max9877_get_reg, max9877_set_reg, max9877_pgain_tlv),
+	SOC_SINGLE_EXT_TLV("MAX9877 PGAINB Playback Volume",
+			MAX9877_INPUT_MODE, 2, 2, 0,
+			max9877_get_reg, max9877_set_reg, max9877_pgain_tlv),
+	SOC_SINGLE_EXT_TLV("MAX9877 Amp Speaker Playback Volume",
+			MAX9877_SPK_VOLUME, 0, 31, 0,
+			max9877_get_reg, max9877_set_reg, max9877_output_tlv),
+	SOC_DOUBLE_R_EXT_TLV("MAX9877 Amp HP Playback Volume",
+			MAX9877_HPL_VOLUME, MAX9877_HPR_VOLUME, 0, 31, 0,
+			max9877_get_reg, max9877_set_reg, max9877_output_tlv),
+	SOC_SINGLE_EXT("MAX9877 INB Stereo Switch",
+			MAX9877_INPUT_MODE, 4, 1, 1,
+			max9877_get_reg, max9877_set_reg),
+	SOC_SINGLE_EXT("MAX9877 INA Stereo Switch",
+			MAX9877_INPUT_MODE, 5, 1, 1,
+			max9877_get_reg, max9877_set_reg),
+	SOC_SINGLE_EXT("MAX9877 Zero-crossing detection Switch",
+			MAX9877_INPUT_MODE, 6, 1, 0,
+			max9877_get_reg, max9877_set_reg),
+	SOC_SINGLE_EXT("MAX9877 Bypass Mode Switch",
+			MAX9877_OUTPUT_MODE, 6, 1, 0,
+			max9877_get_reg, max9877_set_reg),
+	SOC_SINGLE_EXT("MAX9877 Shutdown Mode Switch",
+			MAX9877_OUTPUT_MODE, 7, 1, 1,
+			max9877_get_reg, max9877_set_reg),
+	SOC_ENUM_EXT("MAX9877 Output Mode", max9877_enum[0],
+			max9877_get_out_mode, max9877_set_out_mode),
+	SOC_ENUM_EXT("MAX9877 Oscillator Mode", max9877_enum[1],
+			max9877_get_osc_mode, max9877_set_osc_mode),
+};
+
+/* This function is called from ASoC machine driver */
+int max9877_add_controls(struct snd_soc_codec *codec)
+{
+	return snd_soc_add_controls(codec, max9877_controls,
+			ARRAY_SIZE(max9877_controls));
+}
+EXPORT_SYMBOL_GPL(max9877_add_controls);
+
+static int __devinit max9877_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	i2c = client;
+
+	max9877_write_regs();
+
+	return 0;
+}
+
+static __devexit int max9877_i2c_remove(struct i2c_client *client)
+{
+	i2c = NULL;
+
+	return 0;
+}
+
+static const struct i2c_device_id max9877_i2c_id[] = {
+	{ "max9877", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max9877_i2c_id);
+
+static struct i2c_driver max9877_i2c_driver = {
+	.driver = {
+		.name = "max9877",
+		.owner = THIS_MODULE,
+	},
+	.probe = max9877_i2c_probe,
+	.remove = __devexit_p(max9877_i2c_remove),
+	.id_table = max9877_i2c_id,
+};
+
+static int __init max9877_init(void)
+{
+	return i2c_add_driver(&max9877_i2c_driver);
+}
+module_init(max9877_init);
+
+static void __exit max9877_exit(void)
+{
+	i2c_del_driver(&max9877_i2c_driver);
+}
+module_exit(max9877_exit);
+
+MODULE_DESCRIPTION("ASoC MAX9877 amp driver");
+MODULE_AUTHOR("Joonyoung Shim <jy0922.shim@samsung.com>");
+MODULE_LICENSE("GPL");
