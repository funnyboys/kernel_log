commit 5e518eddd11e8f71aaffc954dc7ee9572fc59808
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri May 15 09:47:11 2020 +0900

    ASoC: codecs: use snd_soc_xxx_active()
    
    We have snd_soc_dai/dai_stream/component_active() macro
    This patch uses it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87wo5e58j4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 032adc14562d..e2cc1ad8cb0a 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2039,7 +2039,7 @@ static int max98090_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (!max98090->master && dai->active == 1)
+		if (!max98090->master && snd_soc_dai_active(dai) == 1)
 			queue_delayed_work(system_power_efficient_wq,
 					   &max98090->pll_det_enable_work,
 					   msecs_to_jiffies(10));
@@ -2047,7 +2047,7 @@ static int max98090_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (!max98090->master && dai->active == 1)
+		if (!max98090->master && snd_soc_dai_active(dai) == 1)
 			schedule_work(&max98090->pll_det_disable_work);
 		break;
 	default:
@@ -2109,7 +2109,7 @@ static void max98090_pll_work(struct max98090_priv *max98090)
 	unsigned int pll;
 	int i;
 
-	if (!snd_soc_component_is_active(component))
+	if (!snd_soc_component_active(component))
 		return;
 
 	dev_info_ratelimited(component->dev, "PLL unlocked\n");

commit 4b8a1ca4628343829f373bf0d4e087fe50c451e5
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Fri Feb 14 18:57:42 2020 +0800

    ASoC: max98090: revert invalid fix for handling SHDN
    
    Reverts commit 62d5ae4cafb7 ("ASoC: max98090: save and restore
    SHDN when changing sensitive registers").
    
    A critical side-effect was observed: when keep playing something,
    the recorded sound has chance to break (clipping).
    
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20200214105744.82258-2-tzungbi@google.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 5bc2c6411b33..032adc14562d 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -5,150 +5,24 @@
  * Copyright 2011-2012 Maxim Integrated Products
  */
 
-#include <linux/acpi.h>
-#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
-#include <linux/mutex.h>
 #include <linux/of.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
+#include <linux/acpi.h>
+#include <linux/clk.h>
 #include <sound/jack.h>
-#include <sound/max98090.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/tlv.h>
+#include <sound/max98090.h>
 #include "max98090.h"
 
-static void max98090_shdn_save_locked(struct max98090_priv *max98090)
-{
-	int shdn = 0;
-
-	/* saved_shdn, saved_count, SHDN are protected by card->dapm_mutex */
-	regmap_read(max98090->regmap, M98090_REG_DEVICE_SHUTDOWN, &shdn);
-	max98090->saved_shdn |= shdn;
-	++max98090->saved_count;
-
-	if (shdn)
-		regmap_write(max98090->regmap, M98090_REG_DEVICE_SHUTDOWN, 0x0);
-}
-
-static void max98090_shdn_restore_locked(struct max98090_priv *max98090)
-{
-	/* saved_shdn, saved_count, SHDN are protected by card->dapm_mutex */
-	if (--max98090->saved_count == 0) {
-		if (max98090->saved_shdn) {
-			regmap_write(max98090->regmap,
-				     M98090_REG_DEVICE_SHUTDOWN,
-				     M98090_SHDNN_MASK);
-			max98090->saved_shdn = 0;
-		}
-	}
-}
-
-static void max98090_shdn_save(struct max98090_priv *max98090)
-{
-	mutex_lock_nested(&max98090->component->card->dapm_mutex,
-			  SND_SOC_DAPM_CLASS_RUNTIME);
-	max98090_shdn_save_locked(max98090);
-}
-
-static void max98090_shdn_restore(struct max98090_priv *max98090)
-{
-	max98090_shdn_restore_locked(max98090);
-	mutex_unlock(&max98090->component->card->dapm_mutex);
-}
-
-static int max98090_put_volsw(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component =
-		snd_soc_kcontrol_component(kcontrol);
-	struct max98090_priv *max98090 =
-		snd_soc_component_get_drvdata(component);
-	int ret;
-
-	max98090_shdn_save(max98090);
-	ret = snd_soc_put_volsw(kcontrol, ucontrol);
-	max98090_shdn_restore(max98090);
-
-	return ret;
-}
-
-static int max98090_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component =
-		snd_soc_dapm_kcontrol_component(kcontrol);
-	struct max98090_priv *max98090 =
-		snd_soc_component_get_drvdata(component);
-	int ret;
-
-	max98090_shdn_save(max98090);
-	ret = snd_soc_dapm_put_enum_double_locked(kcontrol, ucontrol);
-	max98090_shdn_restore(max98090);
-
-	return ret;
-}
-
-static int max98090_put_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component =
-		snd_soc_kcontrol_component(kcontrol);
-	struct max98090_priv *max98090 =
-		snd_soc_component_get_drvdata(component);
-	int ret;
-
-	max98090_shdn_save(max98090);
-	ret = snd_soc_put_enum_double(kcontrol, ucontrol);
-	max98090_shdn_restore(max98090);
-
-	return ret;
-}
-
-static int max98090_bytes_put(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component =
-		snd_soc_kcontrol_component(kcontrol);
-	struct max98090_priv *max98090 =
-		snd_soc_component_get_drvdata(component);
-	int ret;
-
-	max98090_shdn_save(max98090);
-	ret = snd_soc_bytes_put(kcontrol, ucontrol);
-	max98090_shdn_restore(max98090);
-
-	return ret;
-}
-
-static int max98090_dapm_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_component *component =
-		snd_soc_dapm_to_component(w->dapm);
-	struct max98090_priv *max98090 =
-		snd_soc_component_get_drvdata(component);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-	case SND_SOC_DAPM_PRE_PMD:
-		max98090_shdn_save_locked(max98090);
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-	case SND_SOC_DAPM_POST_PMD:
-		max98090_shdn_restore_locked(max98090);
-		break;
-	}
-
-	return 0;
-}
-
 /* Allows for sparsely populated register maps */
 static const struct reg_default max98090_reg[] = {
 	{ 0x00, 0x00 }, /* 00 Software Reset */
@@ -632,13 +506,10 @@ static SOC_ENUM_SINGLE_DECL(max98090_adchp_enum,
 			    max98090_pwr_perf_text);
 
 static const struct snd_kcontrol_new max98090_snd_controls[] = {
-	SOC_ENUM_EXT("MIC Bias VCM Bandgap", max98090_vcmbandgap_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_ENUM("MIC Bias VCM Bandgap", max98090_vcmbandgap_enum),
 
-	SOC_SINGLE_EXT("DMIC MIC Comp Filter Config",
-		M98090_REG_DIGITAL_MIC_CONFIG,
-		M98090_DMIC_COMP_SHIFT, M98090_DMIC_COMP_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_SINGLE("DMIC MIC Comp Filter Config", M98090_REG_DIGITAL_MIC_CONFIG,
+		M98090_DMIC_COMP_SHIFT, M98090_DMIC_COMP_NUM - 1, 0),
 
 	SOC_SINGLE_EXT_TLV("MIC1 Boost Volume",
 		M98090_REG_MIC1_INPUT_LEVEL, M98090_MIC_PA1EN_SHIFT,
@@ -693,34 +564,24 @@ static const struct snd_kcontrol_new max98090_snd_controls[] = {
 		M98090_AVR_SHIFT, M98090_AVR_NUM - 1, 1,
 		max98090_av_tlv),
 
-	SOC_ENUM_EXT("ADC Oversampling Rate", max98090_osr128_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
-	SOC_SINGLE_EXT("ADC Quantizer Dither", M98090_REG_ADC_CONTROL,
-		M98090_ADCDITHER_SHIFT, M98090_ADCDITHER_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
-	SOC_ENUM_EXT("ADC High Performance Mode", max98090_adchp_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
-
-	SOC_SINGLE_EXT("DAC Mono Mode", M98090_REG_IO_CONFIGURATION,
-		M98090_DMONO_SHIFT, M98090_DMONO_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
-	SOC_SINGLE_EXT("SDIN Mode", M98090_REG_IO_CONFIGURATION,
-		M98090_SDIEN_SHIFT, M98090_SDIEN_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
-	SOC_SINGLE_EXT("SDOUT Mode", M98090_REG_IO_CONFIGURATION,
-		M98090_SDOEN_SHIFT, M98090_SDOEN_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
-	SOC_SINGLE_EXT("SDOUT Hi-Z Mode", M98090_REG_IO_CONFIGURATION,
-		M98090_HIZOFF_SHIFT, M98090_HIZOFF_NUM - 1, 1,
-		snd_soc_get_volsw, max98090_put_volsw),
-	SOC_ENUM_EXT("Filter Mode", max98090_mode_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
-	SOC_SINGLE_EXT("Record Path DC Blocking", M98090_REG_FILTER_CONFIG,
-		M98090_AHPF_SHIFT, M98090_AHPF_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
-	SOC_SINGLE_EXT("Playback Path DC Blocking", M98090_REG_FILTER_CONFIG,
-		M98090_DHPF_SHIFT, M98090_DHPF_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_ENUM("ADC Oversampling Rate", max98090_osr128_enum),
+	SOC_SINGLE("ADC Quantizer Dither", M98090_REG_ADC_CONTROL,
+		M98090_ADCDITHER_SHIFT, M98090_ADCDITHER_NUM - 1, 0),
+	SOC_ENUM("ADC High Performance Mode", max98090_adchp_enum),
+
+	SOC_SINGLE("DAC Mono Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_DMONO_SHIFT, M98090_DMONO_NUM - 1, 0),
+	SOC_SINGLE("SDIN Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_SDIEN_SHIFT, M98090_SDIEN_NUM - 1, 0),
+	SOC_SINGLE("SDOUT Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_SDOEN_SHIFT, M98090_SDOEN_NUM - 1, 0),
+	SOC_SINGLE("SDOUT Hi-Z Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_HIZOFF_SHIFT, M98090_HIZOFF_NUM - 1, 1),
+	SOC_ENUM("Filter Mode", max98090_mode_enum),
+	SOC_SINGLE("Record Path DC Blocking", M98090_REG_FILTER_CONFIG,
+		M98090_AHPF_SHIFT, M98090_AHPF_NUM - 1, 0),
+	SOC_SINGLE("Playback Path DC Blocking", M98090_REG_FILTER_CONFIG,
+		M98090_DHPF_SHIFT, M98090_DHPF_NUM - 1, 0),
 	SOC_SINGLE_TLV("Digital BQ Volume", M98090_REG_ADC_BIQUAD_LEVEL,
 		M98090_AVBQ_SHIFT, M98090_AVBQ_NUM - 1, 1, max98090_dv_tlv),
 	SOC_SINGLE_EXT_TLV("Digital Sidetone Volume",
@@ -733,17 +594,13 @@ static const struct snd_kcontrol_new max98090_snd_controls[] = {
 	SOC_SINGLE_TLV("Digital Volume", M98090_REG_DAI_PLAYBACK_LEVEL,
 		M98090_DV_SHIFT, M98090_DV_NUM - 1, 1,
 		max98090_dv_tlv),
-	SND_SOC_BYTES_E("EQ Coefficients", M98090_REG_EQUALIZER_BASE, 105,
-		snd_soc_bytes_get, max98090_bytes_put),
-	SOC_SINGLE_EXT("Digital EQ 3 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_EQ3BANDEN_SHIFT, M98090_EQ3BANDEN_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
-	SOC_SINGLE_EXT("Digital EQ 5 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_EQ5BANDEN_SHIFT, M98090_EQ5BANDEN_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
-	SOC_SINGLE_EXT("Digital EQ 7 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_EQ7BANDEN_SHIFT, M98090_EQ7BANDEN_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
+	SND_SOC_BYTES("EQ Coefficients", M98090_REG_EQUALIZER_BASE, 105),
+	SOC_SINGLE("Digital EQ 3 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_EQ3BANDEN_SHIFT, M98090_EQ3BANDEN_NUM - 1, 0),
+	SOC_SINGLE("Digital EQ 5 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_EQ5BANDEN_SHIFT, M98090_EQ5BANDEN_NUM - 1, 0),
+	SOC_SINGLE("Digital EQ 7 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_EQ7BANDEN_SHIFT, M98090_EQ7BANDEN_NUM - 1, 0),
 	SOC_SINGLE("Digital EQ Clipping Detection", M98090_REG_DAI_PLAYBACK_LEVEL_EQ,
 		M98090_EQCLPN_SHIFT, M98090_EQCLPN_NUM - 1,
 		1),
@@ -751,34 +608,25 @@ static const struct snd_kcontrol_new max98090_snd_controls[] = {
 		M98090_DVEQ_SHIFT, M98090_DVEQ_NUM - 1, 1,
 		max98090_dv_tlv),
 
-	SOC_SINGLE_EXT("ALC Enable", M98090_REG_DRC_TIMING,
-		M98090_DRCEN_SHIFT, M98090_DRCEN_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
-	SOC_ENUM_EXT("ALC Attack Time", max98090_drcatk_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
-	SOC_ENUM_EXT("ALC Release Time", max98090_drcrls_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_SINGLE("ALC Enable", M98090_REG_DRC_TIMING,
+		M98090_DRCEN_SHIFT, M98090_DRCEN_NUM - 1, 0),
+	SOC_ENUM("ALC Attack Time", max98090_drcatk_enum),
+	SOC_ENUM("ALC Release Time", max98090_drcrls_enum),
 	SOC_SINGLE_TLV("ALC Make Up Volume", M98090_REG_DRC_GAIN,
 		M98090_DRCG_SHIFT, M98090_DRCG_NUM - 1, 0,
 		max98090_alcmakeup_tlv),
-	SOC_ENUM_EXT("ALC Compression Ratio", max98090_alccmp_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
-	SOC_ENUM_EXT("ALC Expansion Ratio", max98090_drcexp_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
-	SOC_SINGLE_EXT_TLV("ALC Compression Threshold Volume",
+	SOC_ENUM("ALC Compression Ratio", max98090_alccmp_enum),
+	SOC_ENUM("ALC Expansion Ratio", max98090_drcexp_enum),
+	SOC_SINGLE_TLV("ALC Compression Threshold Volume",
 		M98090_REG_DRC_COMPRESSOR, M98090_DRCTHC_SHIFT,
-		M98090_DRCTHC_NUM - 1, 1,
-		snd_soc_get_volsw, max98090_put_volsw, max98090_alccomp_tlv),
-	SOC_SINGLE_EXT_TLV("ALC Expansion Threshold Volume",
+		M98090_DRCTHC_NUM - 1, 1, max98090_alccomp_tlv),
+	SOC_SINGLE_TLV("ALC Expansion Threshold Volume",
 		M98090_REG_DRC_EXPANDER, M98090_DRCTHE_SHIFT,
-		M98090_DRCTHE_NUM - 1, 1,
-		snd_soc_get_volsw, max98090_put_volsw, max98090_drcexp_tlv),
+		M98090_DRCTHE_NUM - 1, 1, max98090_drcexp_tlv),
 
-	SOC_ENUM_EXT("DAC HP Playback Performance Mode",
-		max98090_dac_perfmode_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
-	SOC_ENUM_EXT("DAC High Performance Mode", max98090_dachp_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_ENUM("DAC HP Playback Performance Mode",
+		max98090_dac_perfmode_enum),
+	SOC_ENUM("DAC High Performance Mode", max98090_dachp_enum),
 
 	SOC_SINGLE_TLV("Headphone Left Mixer Volume",
 		M98090_REG_HP_CONTROL, M98090_MIXHPLG_SHIFT,
@@ -836,12 +684,9 @@ static const struct snd_kcontrol_new max98090_snd_controls[] = {
 	SOC_SINGLE("Volume Adjustment Smoothing", M98090_REG_LEVEL_CONTROL,
 		M98090_VSENN_SHIFT, M98090_VSENN_NUM - 1, 1),
 
-	SND_SOC_BYTES_E("Biquad Coefficients",
-		M98090_REG_RECORD_BIQUAD_BASE, 15,
-		snd_soc_bytes_get, max98090_bytes_put),
-	SOC_SINGLE_EXT("Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_ADCBQEN_SHIFT, M98090_ADCBQEN_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
+	SND_SOC_BYTES("Biquad Coefficients", M98090_REG_RECORD_BIQUAD_BASE, 15),
+	SOC_SINGLE("Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_ADCBQEN_SHIFT, M98090_ADCBQEN_NUM - 1, 0),
 };
 
 static const struct snd_kcontrol_new max98091_snd_controls[] = {
@@ -850,12 +695,10 @@ static const struct snd_kcontrol_new max98091_snd_controls[] = {
 		M98090_DMIC34_ZEROPAD_SHIFT,
 		M98090_DMIC34_ZEROPAD_NUM - 1, 0),
 
-	SOC_ENUM_EXT("Filter DMIC34 Mode", max98090_filter_dmic34mode_enum,
-		snd_soc_get_enum_double, max98090_put_enum_double),
-	SOC_SINGLE_EXT("DMIC34 DC Blocking", M98090_REG_FILTER_CONFIG,
+	SOC_ENUM("Filter DMIC34 Mode", max98090_filter_dmic34mode_enum),
+	SOC_SINGLE("DMIC34 DC Blocking", M98090_REG_FILTER_CONFIG,
 		M98090_FLT_DMIC34HPF_SHIFT,
-		M98090_FLT_DMIC34HPF_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
+		M98090_FLT_DMIC34HPF_NUM - 1, 0),
 
 	SOC_SINGLE_TLV("DMIC3 Boost Volume", M98090_REG_DMIC3_VOLUME,
 		M98090_DMIC_AV3G_SHIFT, M98090_DMIC_AV3G_NUM - 1, 0,
@@ -873,9 +716,8 @@ static const struct snd_kcontrol_new max98091_snd_controls[] = {
 
 	SND_SOC_BYTES("DMIC34 Biquad Coefficients",
 		M98090_REG_DMIC34_BIQUAD_BASE, 15),
-	SOC_SINGLE_EXT("DMIC34 Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_DMIC34BQEN_SHIFT, M98090_DMIC34BQEN_NUM - 1, 0,
-		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_SINGLE("DMIC34 Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_DMIC34BQEN_SHIFT, M98090_DMIC34BQEN_NUM - 1, 0),
 
 	SOC_SINGLE_TLV("DMIC34 BQ PreAttenuation Volume",
 		M98090_REG_DMIC34_BQ_PREATTEN, M98090_AV34BQ_SHIFT,
@@ -929,6 +771,19 @@ static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 	return 0;
 }
 
+static int max98090_shdn_event(struct snd_soc_dapm_widget *w,
+				 struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
+
+	if (event & SND_SOC_DAPM_POST_PMU)
+		max98090->shdn_pending = true;
+
+	return 0;
+
+}
+
 static const char *mic1_mux_text[] = { "IN12", "IN56" };
 
 static SOC_ENUM_SINGLE_DECL(mic1_mux_enum,
@@ -1029,14 +884,10 @@ static SOC_ENUM_SINGLE_DECL(ltenr_mux_enum,
 			    lten_mux_text);
 
 static const struct snd_kcontrol_new max98090_ltenl_mux =
-	SOC_DAPM_ENUM_EXT("LTENL Mux", ltenl_mux_enum,
-			  snd_soc_dapm_get_enum_double,
-			  max98090_dapm_put_enum_double);
+	SOC_DAPM_ENUM("LTENL Mux", ltenl_mux_enum);
 
 static const struct snd_kcontrol_new max98090_ltenr_mux =
-	SOC_DAPM_ENUM_EXT("LTENR Mux", ltenr_mux_enum,
-			  snd_soc_dapm_get_enum_double,
-			  max98090_dapm_put_enum_double);
+	SOC_DAPM_ENUM("LTENR Mux", ltenr_mux_enum);
 
 static const char *lben_mux_text[] = { "Normal", "Loopback" };
 
@@ -1051,14 +902,10 @@ static SOC_ENUM_SINGLE_DECL(lbenr_mux_enum,
 			    lben_mux_text);
 
 static const struct snd_kcontrol_new max98090_lbenl_mux =
-	SOC_DAPM_ENUM_EXT("LBENL Mux", lbenl_mux_enum,
-			  snd_soc_dapm_get_enum_double,
-			  max98090_dapm_put_enum_double);
+	SOC_DAPM_ENUM("LBENL Mux", lbenl_mux_enum);
 
 static const struct snd_kcontrol_new max98090_lbenr_mux =
-	SOC_DAPM_ENUM_EXT("LBENR Mux", lbenr_mux_enum,
-			  snd_soc_dapm_get_enum_double,
-			  max98090_dapm_put_enum_double);
+	SOC_DAPM_ENUM("LBENR Mux", lbenr_mux_enum);
 
 static const char *stenl_mux_text[] = { "Normal", "Sidetone Left" };
 
@@ -1225,25 +1072,21 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 	SND_SOC_DAPM_INPUT("IN56"),
 
 	SND_SOC_DAPM_SUPPLY("MICBIAS", M98090_REG_INPUT_ENABLE,
-		M98090_MBEN_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		M98090_MBEN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SHDN", M98090_REG_DEVICE_SHUTDOWN,
 		M98090_SHDNN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SDIEN", M98090_REG_IO_CONFIGURATION,
-		M98090_SDIEN_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		M98090_SDIEN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SDOEN", M98090_REG_IO_CONFIGURATION,
-		M98090_SDOEN_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		M98090_SDOEN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("DMICL_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		M98090_DIGMICL_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		 M98090_DIGMICL_SHIFT, 0, max98090_shdn_event,
+			SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("DMICR_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		M98090_DIGMICR_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		 M98090_DIGMICR_SHIFT, 0, max98090_shdn_event,
+			 SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("AHPF", M98090_REG_FILTER_CONFIG,
-		M98090_AHPF_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		M98090_AHPF_SHIFT, 0, NULL, 0),
 
 /*
  * Note: Sysclk and misc power supplies are taken care of by SHDN
@@ -1273,12 +1116,10 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 		&max98090_lineb_mixer_controls[0],
 		ARRAY_SIZE(max98090_lineb_mixer_controls)),
 
-	SND_SOC_DAPM_PGA_E("LINEA Input", M98090_REG_INPUT_ENABLE,
-		M98090_LINEAEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-	SND_SOC_DAPM_PGA_E("LINEB Input", M98090_REG_INPUT_ENABLE,
-		M98090_LINEBEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+	SND_SOC_DAPM_PGA("LINEA Input", M98090_REG_INPUT_ENABLE,
+		M98090_LINEAEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("LINEB Input", M98090_REG_INPUT_ENABLE,
+		M98090_LINEBEN_SHIFT, 0, NULL, 0),
 
 	SND_SOC_DAPM_MIXER("Left ADC Mixer", SND_SOC_NOPM, 0, 0,
 		&max98090_left_adc_mixer_controls[0],
@@ -1289,11 +1130,11 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 		ARRAY_SIZE(max98090_right_adc_mixer_controls)),
 
 	SND_SOC_DAPM_ADC_E("ADCL", NULL, M98090_REG_INPUT_ENABLE,
-		M98090_ADLEN_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		M98090_ADLEN_SHIFT, 0, max98090_shdn_event,
+		SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_ADC_E("ADCR", NULL, M98090_REG_INPUT_ENABLE,
-		M98090_ADREN_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		M98090_ADREN_SHIFT, 0, max98090_shdn_event,
+		SND_SOC_DAPM_POST_PMU),
 
 	SND_SOC_DAPM_AIF_OUT("AIFOUTL", "HiFi Capture", 0,
 		SND_SOC_NOPM, 0, 0),
@@ -1321,12 +1162,10 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 	SND_SOC_DAPM_AIF_IN("AIFINL", "HiFi Playback", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_IN("AIFINR", "HiFi Playback", 1, SND_SOC_NOPM, 0, 0),
 
-	SND_SOC_DAPM_DAC_E("DACL", NULL, M98090_REG_OUTPUT_ENABLE,
-		M98090_DALEN_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-	SND_SOC_DAPM_DAC_E("DACR", NULL, M98090_REG_OUTPUT_ENABLE,
-		M98090_DAREN_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+	SND_SOC_DAPM_DAC("DACL", NULL, M98090_REG_OUTPUT_ENABLE,
+		M98090_DALEN_SHIFT, 0),
+	SND_SOC_DAPM_DAC("DACR", NULL, M98090_REG_OUTPUT_ENABLE,
+		M98090_DAREN_SHIFT, 0),
 
 	SND_SOC_DAPM_MIXER("Left Headphone Mixer", SND_SOC_NOPM, 0, 0,
 		&max98090_left_hp_mixer_controls[0],
@@ -1361,26 +1200,20 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 	SND_SOC_DAPM_MUX("MIXHPRSEL Mux", SND_SOC_NOPM, 0, 0,
 		&max98090_mixhprsel_mux),
 
-	SND_SOC_DAPM_PGA_E("HP Left Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_HPLEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-	SND_SOC_DAPM_PGA_E("HP Right Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_HPREN_SHIFT, 0, NULL, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-
-	SND_SOC_DAPM_PGA_E("SPK Left Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_SPLEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-	SND_SOC_DAPM_PGA_E("SPK Right Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_SPREN_SHIFT, 0, NULL, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-
-	SND_SOC_DAPM_PGA_E("RCV Left Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_RCVLEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
-	SND_SOC_DAPM_PGA_E("RCV Right Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_RCVREN_SHIFT, 0, NULL, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+	SND_SOC_DAPM_PGA("HP Left Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_HPLEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HP Right Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_HPREN_SHIFT, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("SPK Left Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_SPLEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("SPK Right Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_SPREN_SHIFT, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("RCV Left Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_RCVLEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("RCV Right Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_RCVREN_SHIFT, 0, NULL, 0),
 
 	SND_SOC_DAPM_OUTPUT("HPL"),
 	SND_SOC_DAPM_OUTPUT("HPR"),
@@ -1395,11 +1228,9 @@ static const struct snd_soc_dapm_widget max98091_dapm_widgets[] = {
 	SND_SOC_DAPM_INPUT("DMIC4"),
 
 	SND_SOC_DAPM_SUPPLY("DMIC3_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		M98090_DIGMIC3_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		 M98090_DIGMIC3_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("DMIC4_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		M98090_DIGMIC4_SHIFT, 0, max98090_dapm_event,
-		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+		 M98090_DIGMIC4_SHIFT, 0, NULL, 0),
 };
 
 static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
@@ -1670,11 +1501,6 @@ static void max98090_configure_bclk(struct snd_soc_component *component)
 		return;
 	}
 
-	/*
-	 * Master mode: no need to save and restore SHDN for the following
-	 * sensitive registers.
-	 */
-
 	/* Check for supported PCLK to LRCLK ratios */
 	for (i = 0; i < ARRAY_SIZE(pclk_rates); i++) {
 		if ((pclk_rates[i] == max98090->sysclk) &&
@@ -1761,14 +1587,12 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 		switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 		case SND_SOC_DAIFMT_CBS_CFS:
 			/* Set to slave mode PLL - MAS mode off */
-			max98090_shdn_save(max98090);
 			snd_soc_component_write(component,
 				M98090_REG_CLOCK_RATIO_NI_MSB, 0x00);
 			snd_soc_component_write(component,
 				M98090_REG_CLOCK_RATIO_NI_LSB, 0x00);
 			snd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,
 				M98090_USE_M1_MASK, 0);
-			max98090_shdn_restore(max98090);
 			max98090->master = false;
 			break;
 		case SND_SOC_DAIFMT_CBM_CFM:
@@ -1794,9 +1618,7 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 			dev_err(component->dev, "DAI clock mode unsupported");
 			return -EINVAL;
 		}
-		max98090_shdn_save(max98090);
 		snd_soc_component_write(component, M98090_REG_MASTER_MODE, regval);
-		max98090_shdn_restore(max98090);
 
 		regval = 0;
 		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
@@ -1841,10 +1663,8 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 		if (max98090->tdm_slots > 1)
 			regval ^= M98090_BCI_MASK;
 
-		max98090_shdn_save(max98090);
 		snd_soc_component_write(component,
 			M98090_REG_INTERFACE_FORMAT, regval);
-		max98090_shdn_restore(max98090);
 	}
 
 	return 0;
@@ -1856,7 +1676,6 @@ static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
 	struct snd_soc_component *component = codec_dai->component;
 	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	struct max98090_cdata *cdata;
-
 	cdata = &max98090->dai[0];
 
 	if (slots < 0 || slots > 4)
@@ -1866,7 +1685,6 @@ static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
 	max98090->tdm_width = slot_width;
 
 	if (max98090->tdm_slots > 1) {
-		max98090_shdn_save(max98090);
 		/* SLOTL SLOTR SLOTDLY */
 		snd_soc_component_write(component, M98090_REG_TDM_FORMAT,
 			0 << M98090_TDM_SLOTL_SHIFT |
@@ -1877,7 +1695,6 @@ static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
 		snd_soc_component_update_bits(component, M98090_REG_TDM_CONTROL,
 			M98090_TDM_MASK,
 			M98090_TDM_MASK);
-		max98090_shdn_restore(max98090);
 	}
 
 	/*
@@ -2077,7 +1894,6 @@ static int max98090_configure_dmic(struct max98090_priv *max98090,
 	dmic_freq = dmic_table[pclk_index].settings[micclk_index].freq;
 	dmic_comp = dmic_table[pclk_index].settings[micclk_index].comp[i];
 
-	max98090_shdn_save(max98090);
 	regmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_ENABLE,
 			   M98090_MICCLK_MASK,
 			   micclk_index << M98090_MICCLK_SHIFT);
@@ -2086,7 +1902,6 @@ static int max98090_configure_dmic(struct max98090_priv *max98090,
 			   M98090_DMIC_COMP_MASK | M98090_DMIC_FREQ_MASK,
 			   dmic_comp << M98090_DMIC_COMP_SHIFT |
 			   dmic_freq << M98090_DMIC_FREQ_SHIFT);
-	max98090_shdn_restore(max98090);
 
 	return 0;
 }
@@ -2123,10 +1938,8 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 
 	switch (params_width(params)) {
 	case 16:
-		max98090_shdn_save(max98090);
 		snd_soc_component_update_bits(component, M98090_REG_INTERFACE_FORMAT,
 			M98090_WS_MASK, 0);
-		max98090_shdn_restore(max98090);
 		break;
 	default:
 		return -EINVAL;
@@ -2137,7 +1950,6 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 
 	cdata->rate = max98090->lrclk;
 
-	max98090_shdn_save(max98090);
 	/* Update filter mode */
 	if (max98090->lrclk < 24000)
 		snd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,
@@ -2153,7 +1965,6 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 	else
 		snd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,
 			M98090_DHF_MASK, M98090_DHF_MASK);
-	max98090_shdn_restore(max98090);
 
 	max98090_configure_dmic(max98090, max98090->dmic_freq, max98090->pclk,
 				max98090->lrclk);
@@ -2184,7 +1995,6 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 	 *		 0x02 (when master clk is 20MHz to 40MHz)..
 	 *		 0x03 (when master clk is 40MHz to 60MHz)..
 	 */
-	max98090_shdn_save(max98090);
 	if ((freq >= 10000000) && (freq <= 20000000)) {
 		snd_soc_component_write(component, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV1);
@@ -2199,10 +2009,8 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 		max98090->pclk = freq >> 2;
 	} else {
 		dev_err(component->dev, "Invalid master clock frequency\n");
-		max98090_shdn_restore(max98090);
 		return -EINVAL;
 	}
-	max98090_shdn_restore(max98090);
 
 	max98090->sysclk = freq;
 
@@ -2314,12 +2122,10 @@ static void max98090_pll_work(struct max98090_priv *max98090)
 	 */
 
 	/* Toggle shutdown OFF then ON */
-	mutex_lock(&component->card->dapm_mutex);
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, 0);
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, M98090_SHDNN_MASK);
-	mutex_unlock(&component->card->dapm_mutex);
 
 	for (i = 0; i < 10; ++i) {
 		/* Give PLL time to lock */
@@ -2642,12 +2448,7 @@ static int max98090_probe(struct snd_soc_component *component)
 	 */
 	snd_soc_component_read32(component, M98090_REG_DEVICE_STATUS);
 
-	/*
-	 * SHDN should be 0 at the point, no need to save/restore for the
-	 * following registers.
-	 *
-	 * High Performance is default
-	 */
+	/* High Performance is default */
 	snd_soc_component_update_bits(component, M98090_REG_DAC_CONTROL,
 		M98090_DACHP_MASK,
 		1 << M98090_DACHP_SHIFT);
@@ -2658,12 +2459,7 @@ static int max98090_probe(struct snd_soc_component *component)
 		M98090_ADCHP_MASK,
 		1 << M98090_ADCHP_SHIFT);
 
-	/*
-	 * SHDN should be 0 at the point, no need to save/restore for the
-	 * following registers.
-	 *
-	 * Turn on VCM bandgap reference
-	 */
+	/* Turn on VCM bandgap reference */
 	snd_soc_component_write(component, M98090_REG_BIAS_CONTROL,
 		M98090_VCM_MODE_MASK);
 
@@ -2695,9 +2491,25 @@ static void max98090_remove(struct snd_soc_component *component)
 	max98090->component = NULL;
 }
 
+static void max98090_seq_notifier(struct snd_soc_component *component,
+	enum snd_soc_dapm_type event, int subseq)
+{
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
+
+	if (max98090->shdn_pending) {
+		snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, 0);
+		msleep(40);
+		snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+		max98090->shdn_pending = false;
+	}
+}
+
 static const struct snd_soc_component_driver soc_component_dev_max98090 = {
 	.probe			= max98090_probe,
 	.remove			= max98090_remove,
+	.seq_notifier		= max98090_seq_notifier,
 	.set_bias_level		= max98090_set_bias_level,
 	.idle_bias_on		= 1,
 	.use_pmdown_time	= 1,

commit 3a6adf3263f43593c0df66a62ffed9daea562bfd
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Jan 23 14:40:46 2020 +0100

    ASoC: max98090: silence lockdep warning
    
    Commit 08df0d9a00f7 ("ASoC: max98090: revert "ASoC: max98090: fix lockdep
    warning"") provided a good rationale for removing separate lock for the
    SHDN register access. However it restored the lockdep warning during the
    system boot. To silence the lockdep warning, mark the mutex taken in the
    max98090_shdn_save() function with the lockdep class dedicated for the
    runtime DAPM operations: SND_SOC_DAPM_CLASS_RUNTIME. This finally fixes
    the following lockdep warning observed on Exynos4412-based Odroid U3
    board:
    
    ======================================================
    WARNING: possible circular locking dependency detected
    5.5.0-rc7-next-20200123 #7329 Not tainted
    ------------------------------------------------------
    alsactl/1105 is trying to acquire lock:
    ed4f7cf4 (&card->dapm_mutex){+.+.}, at: max98090_shdn_save+0x1c/0x28
    
    but task is already holding lock:
    edb8d49c (&card->controls_rwsem){++++}, at: snd_ctl_ioctl+0xcc/0xbb8
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&card->controls_rwsem){++++}:
           snd_ctl_add_replace+0x3c/0x84
           dapm_create_or_share_kcontrol+0x24c/0x2e0
           snd_soc_dapm_new_widgets+0x308/0x594
           snd_soc_bind_card+0x834/0xa94
           devm_snd_soc_register_card+0x34/0x6c
           odroid_audio_probe+0x288/0x34c
           platform_drv_probe+0x6c/0xa4
           really_probe+0x200/0x48c
           driver_probe_device+0x78/0x1f8
           bus_for_each_drv+0x74/0xb8
           __device_attach+0xd4/0x16c
           bus_probe_device+0x88/0x90
           deferred_probe_work_func+0x3c/0xd0
           process_one_work+0x230/0x7bc
           worker_thread+0x44/0x524
           kthread+0x130/0x164
           ret_from_fork+0x14/0x20
           0x0
    
    -> #0 (&card->dapm_mutex){+.+.}:
           lock_acquire+0xe8/0x270
           __mutex_lock+0x9c/0xb18
           mutex_lock_nested+0x1c/0x24
           max98090_shdn_save+0x1c/0x28
           max98090_put_enum_double+0x20/0x40
           snd_ctl_ioctl+0x190/0xbb8
           ksys_ioctl+0x484/0xb10
           ret_fast_syscall+0x0/0x28
           0xbede0564
    
    other info that might help us debug this:
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(&card->controls_rwsem);
                                   lock(&card->dapm_mutex);
                                   lock(&card->controls_rwsem);
      lock(&card->dapm_mutex);
    
     *** DEADLOCK ***
    
    1 lock held by alsactl/1105:
     #0: edb8d49c (&card->controls_rwsem){++++}, at: snd_ctl_ioctl+0xcc/0xbb8
    
    stack backtrace:
    CPU: 2 PID: 1105 Comm: alsactl Not tainted 5.5.0-rc7-next-20200123 #7329
    Hardware name: Samsung Exynos (Flattened Device Tree)
    [<c01126f0>] (unwind_backtrace) from [<c010e1e8>] (show_stack+0x10/0x14)
    [<c010e1e8>] (show_stack) from [<c0b5234c>] (dump_stack+0xb4/0xe0)
    [<c0b5234c>] (dump_stack) from [<c018a610>] (check_noncircular+0x1ec/0x208)
    [<c018a610>] (check_noncircular) from [<c018ca2c>] (__lock_acquire+0x1210/0x25ec)
    [<c018ca2c>] (__lock_acquire) from [<c018e728>] (lock_acquire+0xe8/0x270)
    [<c018e728>] (lock_acquire) from [<c0b71928>] (__mutex_lock+0x9c/0xb18)
    [<c0b71928>] (__mutex_lock) from [<c0b723c0>] (mutex_lock_nested+0x1c/0x24)
    [<c0b723c0>] (mutex_lock_nested) from [<c086097c>] (max98090_shdn_save+0x1c/0x28)
    [<c086097c>] (max98090_shdn_save) from [<c08613f8>] (max98090_put_enum_double+0x20/0x40)
    [<c08613f8>] (max98090_put_enum_double) from [<c0833f20>] (snd_ctl_ioctl+0x190/0xbb8)
    [<c0833f20>] (snd_ctl_ioctl) from [<c02cae14>] (ksys_ioctl+0x484/0xb10)
    [<c02cae14>] (ksys_ioctl) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    Exception stack(0xed331fa8 to 0xed331ff0)
    ...
    
    Fixes: 08df0d9a00f7 ("ASoC: max98090: revert "ASoC: max98090: fix lockdep warning"")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20200123134046.9769-1-m.szyprowski@samsung.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 0313e1183167..5bc2c6411b33 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -52,7 +52,8 @@ static void max98090_shdn_restore_locked(struct max98090_priv *max98090)
 
 static void max98090_shdn_save(struct max98090_priv *max98090)
 {
-	mutex_lock(&max98090->component->card->dapm_mutex);
+	mutex_lock_nested(&max98090->component->card->dapm_mutex,
+			  SND_SOC_DAPM_CLASS_RUNTIME);
 	max98090_shdn_save_locked(max98090);
 }
 

commit 294b7380ffe88d4a0626af1fee5843a3db0c913c
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Fri Jan 17 15:38:14 2020 +0800

    ASoC: max98090: fix deadlock in max98090_dapm_put_enum_double()
    
    Commit 62d5ae4cafb7 ("ASoC: max98090: save and restore SHDN when
    changing sensitive registers SHDN bit") uses dapm_mutex to protect SHDN
    bit.  However, snd_soc_dapm_put_enum_double() in
    max98090_dapm_put_enum_double() acquires the dapm_mutex again which
    cause a deadlock.
    
    Use snd_soc_dapm_put_enum_double_locked() instead to fix the deadlock.
    
    Fixes: 62d5ae4cafb7 ("ASoC: max98090: save and restore SHDN when changing sensitive registers SHDN bit")
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20200117073814.82441-4-tzungbi@google.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index c01ce4a3f86d..0313e1183167 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -88,7 +88,7 @@ static int max98090_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
 	int ret;
 
 	max98090_shdn_save(max98090);
-	ret = snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+	ret = snd_soc_dapm_put_enum_double_locked(kcontrol, ucontrol);
 	max98090_shdn_restore(max98090);
 
 	return ret;

commit 08df0d9a00f7ca07511614dd3b137fadd2de56fc
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Fri Jan 17 15:38:12 2020 +0800

    ASoC: max98090: revert "ASoC: max98090: fix lockdep warning"
    
    Commit 2dc98af62c32 ("ASoC: max98090: fix lockdep warning") introduced
    a helpful-less small lock: shdn_lock.  Reverts the commit.
    
    Reasons:
    
    1. Lockdep should not be happy by either the original or current code.
    From lockdep's point of view, there is a lock inversion anyway.
    
    Let d = dapm_mutex, c = controls_rwsem, s = shdn_lock,
    
    From the reported calling stack: lock acquisition order of
    snd_soc_register_card() is: d -> c.
    > snd_ctl_add_replace+0x3c/0x84
    > dapm_create_or_share_kcontrol+0x24c/0x2e0
    > snd_soc_dapm_new_widgets+0x308/0x594
    > snd_soc_bind_card+0x80c/0xad4
    > devm_snd_soc_register_card+0x34/0x6c
    
    If calling snd_soc_dapm_put_enum_double() in kcontrol's put (e.g.
    SOC_DAPM_ENUM_EXT), lock acquisition order is: c -> d.  Note that,
    snd_soc_dapm_put_enum_double() acquires d.
    
    The possible lock inversion is always there if registering sound card
    and putting mixer control happen at the same time.  In fact, it never
    happens because the control device don't show up to the userspace until
    the sound card build success.
    
    Commit 2dc98af62c32 ("ASoC: max98090: fix lockdep warning") changes the
    order to: c -> s -> d.  The lock inversion is still there.
    
    2. Commit 62d5ae4cafb7 ("ASoC: max98090: save and restore SHDN when
    changing sensitive registers SHDN bit") designed to use dapm_mutex to
    protect SHDN bit.  Use a separate lock breaks the protection.
    
    DAPM changes SHDN bit automatically when it finds the path.  Thus, any
    code wants to change the SHDN bit, need to acquire the dapm_mutex first.
    
    > SND_SOC_DAPM_SUPPLY("SHDN", M98090_REG_DEVICE_SHUTDOWN,
    >        M98090_SHDNN_SHIFT, 0, NULL, 0),
    
    Fixes: 2dc98af62c32 ("ASoC: max98090: fix lockdep warning")
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20200117073814.82441-2-tzungbi@google.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 454cb8e5b0a1..c01ce4a3f86d 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -52,14 +52,14 @@ static void max98090_shdn_restore_locked(struct max98090_priv *max98090)
 
 static void max98090_shdn_save(struct max98090_priv *max98090)
 {
-	mutex_lock(&max98090->shdn_lock);
+	mutex_lock(&max98090->component->card->dapm_mutex);
 	max98090_shdn_save_locked(max98090);
 }
 
 static void max98090_shdn_restore(struct max98090_priv *max98090)
 {
 	max98090_shdn_restore_locked(max98090);
-	mutex_unlock(&max98090->shdn_lock);
+	mutex_unlock(&max98090->component->card->dapm_mutex);
 }
 
 static int max98090_put_volsw(struct snd_kcontrol *kcontrol,
@@ -2313,12 +2313,12 @@ static void max98090_pll_work(struct max98090_priv *max98090)
 	 */
 
 	/* Toggle shutdown OFF then ON */
-	mutex_lock(&max98090->shdn_lock);
+	mutex_lock(&component->card->dapm_mutex);
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, 0);
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, M98090_SHDNN_MASK);
-	mutex_unlock(&max98090->shdn_lock);
+	mutex_unlock(&component->card->dapm_mutex);
 
 	for (i = 0; i < 10; ++i) {
 		/* Give PLL time to lock */
@@ -2731,8 +2731,6 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 	if (max98090 == NULL)
 		return -ENOMEM;
 
-	mutex_init(&max98090->shdn_lock);
-
 	if (ACPI_HANDLE(&i2c->dev)) {
 		acpi_id = acpi_match_device(i2c->dev.driver->acpi_match_table,
 					    &i2c->dev);

commit a84188eced6109983af54f9435a26d21eac3f8cc
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 10 13:24:02 2020 +0000

    ASoC: max98090: Drop incorrectly applied duplicate commit
    
    This reverts commit 4e93c1294f4b051 (ASoC: max98090: fix incorrect
    helper in max98090_dapm_put_enum_double()) which was misapplied.
    
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index ba0e3ba162f8..454cb8e5b0a1 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -98,7 +98,7 @@ static int max98090_put_enum_double(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_component *component =
-		snd_soc_dapm_kcontrol_component(kcontrol);
+		snd_soc_kcontrol_component(kcontrol);
 	struct max98090_priv *max98090 =
 		snd_soc_component_get_drvdata(component);
 	int ret;

commit 2dc98af62c32ff6c8b9a32365346c5c407e291a8
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Jan 8 12:50:07 2020 +0100

    ASoC: max98090: fix lockdep warning
    
    Commit 62d5ae4cafb7 ("ASoC: max98090: save and restore SHDN when changing
    sensitive registers") extended the code for handling many controls by
    adding a custom put function to them. That new custom put function
    properly handles relations between codec's hardware registers. However
    they used card->dapm_mutex to properly serialize those operations. This
    in turn triggers a lockdep warning about possible circular dependency.
    Fix this by introducing a separate mutex only for serializing the SHDN
    hardware register related operations.
    
    This fixes the following lockdep warning observed on Exynos4412-based
    Odroid U3 board:
    ======================================================
    WARNING: possible circular locking dependency detected
    5.5.0-rc5-next-20200107 #166 Not tainted
    ------------------------------------------------------
    alsactl/1104 is trying to acquire lock:
    ed0d50f4 (&card->dapm_mutex){+.+.}, at: max98090_shdn_save+0x1c/0x28
    
    but task is already holding lock:
    edb4b49c (&card->controls_rwsem){++++}, at: snd_ctl_ioctl+0xcc/0xbb8
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&card->controls_rwsem){++++}:
           snd_ctl_add_replace+0x3c/0x84
           dapm_create_or_share_kcontrol+0x24c/0x2e0
           snd_soc_dapm_new_widgets+0x308/0x594
           snd_soc_bind_card+0x80c/0xad4
           devm_snd_soc_register_card+0x34/0x6c
           odroid_audio_probe+0x288/0x34c
           platform_drv_probe+0x6c/0xa4
           really_probe+0x200/0x490
           driver_probe_device+0x78/0x1f8
           bus_for_each_drv+0x74/0xb8
           __device_attach+0xd4/0x16c
           bus_probe_device+0x88/0x90
           deferred_probe_work_func+0x3c/0xd0
           process_one_work+0x22c/0x7c4
           worker_thread+0x44/0x524
           kthread+0x130/0x164
           ret_from_fork+0x14/0x20
           0x0
    
    -> #0 (&card->dapm_mutex){+.+.}:
           lock_acquire+0xe8/0x270
           __mutex_lock+0x9c/0xb18
           mutex_lock_nested+0x1c/0x24
           max98090_shdn_save+0x1c/0x28
           max98090_put_enum_double+0x20/0x40
           snd_ctl_ioctl+0x190/0xbb8
           ksys_ioctl+0x470/0xaf8
           ret_fast_syscall+0x0/0x28
           0xbefaa564
    
    other info that might help us debug this:
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(&card->controls_rwsem);
                                   lock(&card->dapm_mutex);
                                   lock(&card->controls_rwsem);
      lock(&card->dapm_mutex);
    
     *** DEADLOCK ***
    
    1 lock held by alsactl/1104:
     #0: edb4b49c (&card->controls_rwsem){++++}, at: snd_ctl_ioctl+0xcc/0xbb8
    
    stack backtrace:
    CPU: 0 PID: 1104 Comm: alsactl Not tainted 5.5.0-rc5-next-20200107 #166
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    (unwind_backtrace) from [<c010e180>] (show_stack+0x10/0x14)
    (show_stack) from [<c0b2a09c>] (dump_stack+0xb4/0xe0)
    (dump_stack) from [<c018a1c0>] (check_noncircular+0x1ec/0x208)
    (check_noncircular) from [<c018c5dc>] (__lock_acquire+0x1210/0x25ec)
    (__lock_acquire) from [<c018e2d8>] (lock_acquire+0xe8/0x270)
    (lock_acquire) from [<c0b49678>] (__mutex_lock+0x9c/0xb18)
    (__mutex_lock) from [<c0b4a110>] (mutex_lock_nested+0x1c/0x24)
    (mutex_lock_nested) from [<c0839b3c>] (max98090_shdn_save+0x1c/0x28)
    (max98090_shdn_save) from [<c083a5b8>] (max98090_put_enum_double+0x20/0x40)
    (max98090_put_enum_double) from [<c080d0e8>] (snd_ctl_ioctl+0x190/0xbb8)
    (snd_ctl_ioctl) from [<c02cafec>] (ksys_ioctl+0x470/0xaf8)
    (ksys_ioctl) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    ...
    
    Fixes: 62d5ae4cafb7 ("ASoC: max98090: save and restore SHDN when changing sensitive registers")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200108115007.31095-2-m.szyprowski@samsung.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index ede03663cbed..ba0e3ba162f8 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -52,14 +52,14 @@ static void max98090_shdn_restore_locked(struct max98090_priv *max98090)
 
 static void max98090_shdn_save(struct max98090_priv *max98090)
 {
-	mutex_lock(&max98090->component->card->dapm_mutex);
+	mutex_lock(&max98090->shdn_lock);
 	max98090_shdn_save_locked(max98090);
 }
 
 static void max98090_shdn_restore(struct max98090_priv *max98090)
 {
 	max98090_shdn_restore_locked(max98090);
-	mutex_unlock(&max98090->component->card->dapm_mutex);
+	mutex_unlock(&max98090->shdn_lock);
 }
 
 static int max98090_put_volsw(struct snd_kcontrol *kcontrol,
@@ -2313,12 +2313,12 @@ static void max98090_pll_work(struct max98090_priv *max98090)
 	 */
 
 	/* Toggle shutdown OFF then ON */
-	mutex_lock(&component->card->dapm_mutex);
+	mutex_lock(&max98090->shdn_lock);
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, 0);
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, M98090_SHDNN_MASK);
-	mutex_unlock(&component->card->dapm_mutex);
+	mutex_unlock(&max98090->shdn_lock);
 
 	for (i = 0; i < 10; ++i) {
 		/* Give PLL time to lock */
@@ -2731,6 +2731,8 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 	if (max98090 == NULL)
 		return -ENOMEM;
 
+	mutex_init(&max98090->shdn_lock);
+
 	if (ACPI_HANDLE(&i2c->dev)) {
 		acpi_id = acpi_match_device(i2c->dev.driver->acpi_match_table,
 					    &i2c->dev);

commit 4e93c1294f4b051d574d6bc59755d2863286990e
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Jan 8 12:50:06 2020 +0100

    ASoC: max98090: fix incorrect helper in max98090_dapm_put_enum_double()
    
    Commit 62d5ae4cafb7 ("ASoC: max98090: save and restore SHDN when changing
    sensitive registers") extended the code for handling "LTENL Mux", "LTENR
    Mux", "LBENL Mux" and "LBENR Mux" controls by adding a custom
    max98090_dapm_put_enum_double() function to them. However that function
    used incorrect helper to get its component object. Fix this by using the
    proper snd_soc_dapm_* helper.
    
    This fixes the following NULL pointer exception observed on
    Exynos4412-based Odroid U3 board:
    8<--- cut here ---
    Unable to handle kernel NULL pointer dereference at virtual address 000000b0
    pgd = (ptrval)
    [000000b0] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    Modules linked in:
    CPU: 0 PID: 1104 Comm: alsactl Not tainted 5.5.0-rc5-next-20200107 #166
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    PC is at __mutex_lock+0x54/0xb18
    LR is at ___might_sleep+0x3c/0x2e0
    ...
    Process alsactl (pid: 1104, stack limit = 0x(ptrval))
    ...
    [<c0b49630>] (__mutex_lock) from [<c0b4a110>] (mutex_lock_nested+0x1c/0x24)
    [<c0b4a110>] (mutex_lock_nested) from [<c0839b3c>] (max98090_shdn_save+0x1c/0x28)
    [<c0839b3c>] (max98090_shdn_save) from [<c083a4f8>] (max98090_dapm_put_enum_double+0x20/0x40)
    [<c083a4f8>] (max98090_dapm_put_enum_double) from [<c080d0e8>] (snd_ctl_ioctl+0x190/0xbb8)
    [<c080d0e8>] (snd_ctl_ioctl) from [<c02cafec>] (ksys_ioctl+0x470/0xaf8)
    [<c02cafec>] (ksys_ioctl) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    ...
    ---[ end trace 0e93f0580f4b9241 ]---
    
    Fixes: 62d5ae4cafb7 ("ASoC: max98090: save and restore SHDN when changing sensitive registers")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20200108115007.31095-1-m.szyprowski@samsung.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index c01ce4a3f86d..ede03663cbed 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -98,7 +98,7 @@ static int max98090_put_enum_double(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_component *component =
-		snd_soc_kcontrol_component(kcontrol);
+		snd_soc_dapm_kcontrol_component(kcontrol);
 	struct max98090_priv *max98090 =
 		snd_soc_component_get_drvdata(component);
 	int ret;

commit 1d7b051891722a36ee0b228bc940dd245f161ab1
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Jan 8 12:50:06 2020 +0100

    ASoC: max98090: fix incorrect helper in max98090_dapm_put_enum_double()
    
    Commit 62d5ae4cafb7 ("ASoC: max98090: save and restore SHDN when changing
    sensitive registers") extended the code for handling "LTENL Mux", "LTENR
    Mux", "LBENL Mux" and "LBENR Mux" controls by adding a custom
    max98090_dapm_put_enum_double() function to them. However that function
    used incorrect helper to get its component object. Fix this by using the
    proper snd_soc_dapm_* helper.
    
    This fixes the following NULL pointer exception observed on
    Exynos4412-based Odroid U3 board:
    8<--- cut here ---
    Unable to handle kernel NULL pointer dereference at virtual address 000000b0
    pgd = (ptrval)
    [000000b0] *pgd=00000000
    Internal error: Oops: 5 [#1] PREEMPT SMP ARM
    Modules linked in:
    CPU: 0 PID: 1104 Comm: alsactl Not tainted 5.5.0-rc5-next-20200107 #166
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    PC is at __mutex_lock+0x54/0xb18
    LR is at ___might_sleep+0x3c/0x2e0
    ...
    Process alsactl (pid: 1104, stack limit = 0x(ptrval))
    ...
    [<c0b49630>] (__mutex_lock) from [<c0b4a110>] (mutex_lock_nested+0x1c/0x24)
    [<c0b4a110>] (mutex_lock_nested) from [<c0839b3c>] (max98090_shdn_save+0x1c/0x28)
    [<c0839b3c>] (max98090_shdn_save) from [<c083a4f8>] (max98090_dapm_put_enum_double+0x20/0x40)
    [<c083a4f8>] (max98090_dapm_put_enum_double) from [<c080d0e8>] (snd_ctl_ioctl+0x190/0xbb8)
    [<c080d0e8>] (snd_ctl_ioctl) from [<c02cafec>] (ksys_ioctl+0x470/0xaf8)
    [<c02cafec>] (ksys_ioctl) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    ...
    ---[ end trace 0e93f0580f4b9241 ]---
    
    Fixes: 62d5ae4cafb7 ("ASoC: max98090: save and restore SHDN when changing sensitive registers")
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20200108115007.31095-1-m.szyprowski@samsung.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 4c7b16d557e2..c01ce4a3f86d 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -82,7 +82,7 @@ static int max98090_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_component *component =
-		snd_soc_kcontrol_component(kcontrol);
+		snd_soc_dapm_kcontrol_component(kcontrol);
 	struct max98090_priv *max98090 =
 		snd_soc_component_get_drvdata(component);
 	int ret;

commit d24a70636b8b2b41bf983e89bbaaaf301bb80de4
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Dec 19 12:51:40 2019 +0000

    ASoC: max98090: Remove empty suspend function
    
    The suspend function is empty so can be removed.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Reviewed-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20191219125140.47689-1-broonie@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index da23810f958e..4c7b16d557e2 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2838,17 +2838,12 @@ static int max98090_resume(struct device *dev)
 
 	return 0;
 }
-
-static int max98090_suspend(struct device *dev)
-{
-	return 0;
-}
 #endif
 
 static const struct dev_pm_ops max98090_pm = {
 	SET_RUNTIME_PM_OPS(max98090_runtime_suspend,
 		max98090_runtime_resume, NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(max98090_suspend, max98090_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(NULL, max98090_resume)
 };
 
 static const struct i2c_device_id max98090_i2c_id[] = {

commit 2acf6ce2c25fb71a56ad35fcb9a63c19b20a4f4e
Merge: 2aae447a4c10 4e64ba3fd181
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Dec 10 13:27:14 2019 +0000

    Merge branch 'for-5.5' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-5.6

commit 62d5ae4cafb7ffeeec6ba2dd1814cafeeea7dd8f
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Thu Nov 28 23:19:08 2019 +0800

    ASoC: max98090: save and restore SHDN when changing sensitive registers
    
    According to the datasheet, there are some registers can only be changed
    when SHDN is 0.  Changing these settings during SHDN = 1 can compromise
    device stability and performance specifications.
    
    Saves SHDN before writing to these sensitive registers and restores SHDN
    afterward.
    
    Here is the register list codec driver of max98090 wants to change:
    M98090_REG_QUICK_SYSTEM_CLOCK           0x04
    M98090_REG_QUICK_SAMPLE_RATE            0x05
    M98090_REG_DAI_INTERFACE                0x06
    M98090_REG_DAC_PATH                     0x07
    M98090_REG_MIC_DIRECT_TO_ADC            0x08
    M98090_REG_LINE_TO_ADC                  0x09
    M98090_REG_ANALOG_MIC_LOOP              0x0A
    M98090_REG_ANALOG_LINE_LOOP             0x0B
    M98090_REG_SYSTEM_CLOCK                 0x1B
    M98090_REG_CLOCK_MODE                   0x1C
    M98090_REG_CLOCK_RATIO_NI_MSB           0x1D
    M98090_REG_CLOCK_RATIO_NI_LSB           0x1E
    M98090_REG_CLOCK_RATIO_MI_MSB           0x1F
    M98090_REG_CLOCK_RATIO_MI_LSB           0x20
    M98090_REG_MASTER_MODE                  0x21
    M98090_REG_INTERFACE_FORMAT             0x22
    M98090_REG_TDM_CONTROL                  0x23
    M98090_REG_TDM_FORMAT                   0x24
    M98090_REG_IO_CONFIGURATION             0x25
    M98090_REG_FILTER_CONFIG                0x26
    M98090_REG_INPUT_ENABLE                 0x3E
    M98090_REG_OUTPUT_ENABLE                0x3F
    M98090_REG_BIAS_CONTROL                 0x42
    M98090_REG_DAC_CONTROL                  0x43
    M98090_REG_ADC_CONTROL                  0x44
    M98090_REG_DRC_TIMING                   0x33
    M98090_REG_DRC_COMPRESSOR               0x34
    M98090_REG_DRC_EXPANDER                 0x35
    M98090_REG_DSP_FILTER_ENABLE            0x41
    M98090_REG_EQUALIZER_BASE               0x46
    M98090_REG_RECORD_BIQUAD_BASE           0xAF
    M98090_REG_DIGITAL_MIC_ENABLE           0x13
    M98090_REG_DIGITAL_MIC_CONFIG           0x14
    
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20191128151908.180871-1-tzungbi@google.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f6bf4cfbea23..be1fc8a4aee9 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -5,24 +5,149 @@
  * Copyright 2011-2012 Maxim Integrated Products
  */
 
+#include <linux/acpi.h>
+#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/of.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
-#include <linux/acpi.h>
-#include <linux/clk.h>
 #include <sound/jack.h>
+#include <sound/max98090.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/tlv.h>
-#include <sound/max98090.h>
 #include "max98090.h"
 
+static void max98090_shdn_save_locked(struct max98090_priv *max98090)
+{
+	int shdn = 0;
+
+	/* saved_shdn, saved_count, SHDN are protected by card->dapm_mutex */
+	regmap_read(max98090->regmap, M98090_REG_DEVICE_SHUTDOWN, &shdn);
+	max98090->saved_shdn |= shdn;
+	++max98090->saved_count;
+
+	if (shdn)
+		regmap_write(max98090->regmap, M98090_REG_DEVICE_SHUTDOWN, 0x0);
+}
+
+static void max98090_shdn_restore_locked(struct max98090_priv *max98090)
+{
+	/* saved_shdn, saved_count, SHDN are protected by card->dapm_mutex */
+	if (--max98090->saved_count == 0) {
+		if (max98090->saved_shdn) {
+			regmap_write(max98090->regmap,
+				     M98090_REG_DEVICE_SHUTDOWN,
+				     M98090_SHDNN_MASK);
+			max98090->saved_shdn = 0;
+		}
+	}
+}
+
+static void max98090_shdn_save(struct max98090_priv *max98090)
+{
+	mutex_lock(&max98090->component->card->dapm_mutex);
+	max98090_shdn_save_locked(max98090);
+}
+
+static void max98090_shdn_restore(struct max98090_priv *max98090)
+{
+	max98090_shdn_restore_locked(max98090);
+	mutex_unlock(&max98090->component->card->dapm_mutex);
+}
+
+static int max98090_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct max98090_priv *max98090 =
+		snd_soc_component_get_drvdata(component);
+	int ret;
+
+	max98090_shdn_save(max98090);
+	ret = snd_soc_put_volsw(kcontrol, ucontrol);
+	max98090_shdn_restore(max98090);
+
+	return ret;
+}
+
+static int max98090_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct max98090_priv *max98090 =
+		snd_soc_component_get_drvdata(component);
+	int ret;
+
+	max98090_shdn_save(max98090);
+	ret = snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+	max98090_shdn_restore(max98090);
+
+	return ret;
+}
+
+static int max98090_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct max98090_priv *max98090 =
+		snd_soc_component_get_drvdata(component);
+	int ret;
+
+	max98090_shdn_save(max98090);
+	ret = snd_soc_put_enum_double(kcontrol, ucontrol);
+	max98090_shdn_restore(max98090);
+
+	return ret;
+}
+
+static int max98090_bytes_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct max98090_priv *max98090 =
+		snd_soc_component_get_drvdata(component);
+	int ret;
+
+	max98090_shdn_save(max98090);
+	ret = snd_soc_bytes_put(kcontrol, ucontrol);
+	max98090_shdn_restore(max98090);
+
+	return ret;
+}
+
+static int max98090_dapm_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component =
+		snd_soc_dapm_to_component(w->dapm);
+	struct max98090_priv *max98090 =
+		snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+	case SND_SOC_DAPM_PRE_PMD:
+		max98090_shdn_save_locked(max98090);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+	case SND_SOC_DAPM_POST_PMD:
+		max98090_shdn_restore_locked(max98090);
+		break;
+	}
+
+	return 0;
+}
+
 /* Allows for sparsely populated register maps */
 static const struct reg_default max98090_reg[] = {
 	{ 0x00, 0x00 }, /* 00 Software Reset */
@@ -506,10 +631,13 @@ static SOC_ENUM_SINGLE_DECL(max98090_adchp_enum,
 			    max98090_pwr_perf_text);
 
 static const struct snd_kcontrol_new max98090_snd_controls[] = {
-	SOC_ENUM("MIC Bias VCM Bandgap", max98090_vcmbandgap_enum),
+	SOC_ENUM_EXT("MIC Bias VCM Bandgap", max98090_vcmbandgap_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
 
-	SOC_SINGLE("DMIC MIC Comp Filter Config", M98090_REG_DIGITAL_MIC_CONFIG,
-		M98090_DMIC_COMP_SHIFT, M98090_DMIC_COMP_NUM - 1, 0),
+	SOC_SINGLE_EXT("DMIC MIC Comp Filter Config",
+		M98090_REG_DIGITAL_MIC_CONFIG,
+		M98090_DMIC_COMP_SHIFT, M98090_DMIC_COMP_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
 
 	SOC_SINGLE_EXT_TLV("MIC1 Boost Volume",
 		M98090_REG_MIC1_INPUT_LEVEL, M98090_MIC_PA1EN_SHIFT,
@@ -564,24 +692,34 @@ static const struct snd_kcontrol_new max98090_snd_controls[] = {
 		M98090_AVR_SHIFT, M98090_AVR_NUM - 1, 1,
 		max98090_av_tlv),
 
-	SOC_ENUM("ADC Oversampling Rate", max98090_osr128_enum),
-	SOC_SINGLE("ADC Quantizer Dither", M98090_REG_ADC_CONTROL,
-		M98090_ADCDITHER_SHIFT, M98090_ADCDITHER_NUM - 1, 0),
-	SOC_ENUM("ADC High Performance Mode", max98090_adchp_enum),
-
-	SOC_SINGLE("DAC Mono Mode", M98090_REG_IO_CONFIGURATION,
-		M98090_DMONO_SHIFT, M98090_DMONO_NUM - 1, 0),
-	SOC_SINGLE("SDIN Mode", M98090_REG_IO_CONFIGURATION,
-		M98090_SDIEN_SHIFT, M98090_SDIEN_NUM - 1, 0),
-	SOC_SINGLE("SDOUT Mode", M98090_REG_IO_CONFIGURATION,
-		M98090_SDOEN_SHIFT, M98090_SDOEN_NUM - 1, 0),
-	SOC_SINGLE("SDOUT Hi-Z Mode", M98090_REG_IO_CONFIGURATION,
-		M98090_HIZOFF_SHIFT, M98090_HIZOFF_NUM - 1, 1),
-	SOC_ENUM("Filter Mode", max98090_mode_enum),
-	SOC_SINGLE("Record Path DC Blocking", M98090_REG_FILTER_CONFIG,
-		M98090_AHPF_SHIFT, M98090_AHPF_NUM - 1, 0),
-	SOC_SINGLE("Playback Path DC Blocking", M98090_REG_FILTER_CONFIG,
-		M98090_DHPF_SHIFT, M98090_DHPF_NUM - 1, 0),
+	SOC_ENUM_EXT("ADC Oversampling Rate", max98090_osr128_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_SINGLE_EXT("ADC Quantizer Dither", M98090_REG_ADC_CONTROL,
+		M98090_ADCDITHER_SHIFT, M98090_ADCDITHER_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_ENUM_EXT("ADC High Performance Mode", max98090_adchp_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
+
+	SOC_SINGLE_EXT("DAC Mono Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_DMONO_SHIFT, M98090_DMONO_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_SINGLE_EXT("SDIN Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_SDIEN_SHIFT, M98090_SDIEN_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_SINGLE_EXT("SDOUT Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_SDOEN_SHIFT, M98090_SDOEN_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_SINGLE_EXT("SDOUT Hi-Z Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_HIZOFF_SHIFT, M98090_HIZOFF_NUM - 1, 1,
+		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_ENUM_EXT("Filter Mode", max98090_mode_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_SINGLE_EXT("Record Path DC Blocking", M98090_REG_FILTER_CONFIG,
+		M98090_AHPF_SHIFT, M98090_AHPF_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_SINGLE_EXT("Playback Path DC Blocking", M98090_REG_FILTER_CONFIG,
+		M98090_DHPF_SHIFT, M98090_DHPF_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
 	SOC_SINGLE_TLV("Digital BQ Volume", M98090_REG_ADC_BIQUAD_LEVEL,
 		M98090_AVBQ_SHIFT, M98090_AVBQ_NUM - 1, 1, max98090_dv_tlv),
 	SOC_SINGLE_EXT_TLV("Digital Sidetone Volume",
@@ -594,13 +732,17 @@ static const struct snd_kcontrol_new max98090_snd_controls[] = {
 	SOC_SINGLE_TLV("Digital Volume", M98090_REG_DAI_PLAYBACK_LEVEL,
 		M98090_DV_SHIFT, M98090_DV_NUM - 1, 1,
 		max98090_dv_tlv),
-	SND_SOC_BYTES("EQ Coefficients", M98090_REG_EQUALIZER_BASE, 105),
-	SOC_SINGLE("Digital EQ 3 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_EQ3BANDEN_SHIFT, M98090_EQ3BANDEN_NUM - 1, 0),
-	SOC_SINGLE("Digital EQ 5 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_EQ5BANDEN_SHIFT, M98090_EQ5BANDEN_NUM - 1, 0),
-	SOC_SINGLE("Digital EQ 7 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_EQ7BANDEN_SHIFT, M98090_EQ7BANDEN_NUM - 1, 0),
+	SND_SOC_BYTES_E("EQ Coefficients", M98090_REG_EQUALIZER_BASE, 105,
+		snd_soc_bytes_get, max98090_bytes_put),
+	SOC_SINGLE_EXT("Digital EQ 3 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_EQ3BANDEN_SHIFT, M98090_EQ3BANDEN_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_SINGLE_EXT("Digital EQ 5 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_EQ5BANDEN_SHIFT, M98090_EQ5BANDEN_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_SINGLE_EXT("Digital EQ 7 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_EQ7BANDEN_SHIFT, M98090_EQ7BANDEN_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
 	SOC_SINGLE("Digital EQ Clipping Detection", M98090_REG_DAI_PLAYBACK_LEVEL_EQ,
 		M98090_EQCLPN_SHIFT, M98090_EQCLPN_NUM - 1,
 		1),
@@ -608,25 +750,34 @@ static const struct snd_kcontrol_new max98090_snd_controls[] = {
 		M98090_DVEQ_SHIFT, M98090_DVEQ_NUM - 1, 1,
 		max98090_dv_tlv),
 
-	SOC_SINGLE("ALC Enable", M98090_REG_DRC_TIMING,
-		M98090_DRCEN_SHIFT, M98090_DRCEN_NUM - 1, 0),
-	SOC_ENUM("ALC Attack Time", max98090_drcatk_enum),
-	SOC_ENUM("ALC Release Time", max98090_drcrls_enum),
+	SOC_SINGLE_EXT("ALC Enable", M98090_REG_DRC_TIMING,
+		M98090_DRCEN_SHIFT, M98090_DRCEN_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
+	SOC_ENUM_EXT("ALC Attack Time", max98090_drcatk_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_ENUM_EXT("ALC Release Time", max98090_drcrls_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
 	SOC_SINGLE_TLV("ALC Make Up Volume", M98090_REG_DRC_GAIN,
 		M98090_DRCG_SHIFT, M98090_DRCG_NUM - 1, 0,
 		max98090_alcmakeup_tlv),
-	SOC_ENUM("ALC Compression Ratio", max98090_alccmp_enum),
-	SOC_ENUM("ALC Expansion Ratio", max98090_drcexp_enum),
-	SOC_SINGLE_TLV("ALC Compression Threshold Volume",
+	SOC_ENUM_EXT("ALC Compression Ratio", max98090_alccmp_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_ENUM_EXT("ALC Expansion Ratio", max98090_drcexp_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_SINGLE_EXT_TLV("ALC Compression Threshold Volume",
 		M98090_REG_DRC_COMPRESSOR, M98090_DRCTHC_SHIFT,
-		M98090_DRCTHC_NUM - 1, 1, max98090_alccomp_tlv),
-	SOC_SINGLE_TLV("ALC Expansion Threshold Volume",
+		M98090_DRCTHC_NUM - 1, 1,
+		snd_soc_get_volsw, max98090_put_volsw, max98090_alccomp_tlv),
+	SOC_SINGLE_EXT_TLV("ALC Expansion Threshold Volume",
 		M98090_REG_DRC_EXPANDER, M98090_DRCTHE_SHIFT,
-		M98090_DRCTHE_NUM - 1, 1, max98090_drcexp_tlv),
+		M98090_DRCTHE_NUM - 1, 1,
+		snd_soc_get_volsw, max98090_put_volsw, max98090_drcexp_tlv),
 
-	SOC_ENUM("DAC HP Playback Performance Mode",
-		max98090_dac_perfmode_enum),
-	SOC_ENUM("DAC High Performance Mode", max98090_dachp_enum),
+	SOC_ENUM_EXT("DAC HP Playback Performance Mode",
+		max98090_dac_perfmode_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_ENUM_EXT("DAC High Performance Mode", max98090_dachp_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
 
 	SOC_SINGLE_TLV("Headphone Left Mixer Volume",
 		M98090_REG_HP_CONTROL, M98090_MIXHPLG_SHIFT,
@@ -684,9 +835,12 @@ static const struct snd_kcontrol_new max98090_snd_controls[] = {
 	SOC_SINGLE("Volume Adjustment Smoothing", M98090_REG_LEVEL_CONTROL,
 		M98090_VSENN_SHIFT, M98090_VSENN_NUM - 1, 1),
 
-	SND_SOC_BYTES("Biquad Coefficients", M98090_REG_RECORD_BIQUAD_BASE, 15),
-	SOC_SINGLE("Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_ADCBQEN_SHIFT, M98090_ADCBQEN_NUM - 1, 0),
+	SND_SOC_BYTES_E("Biquad Coefficients",
+		M98090_REG_RECORD_BIQUAD_BASE, 15,
+		snd_soc_bytes_get, max98090_bytes_put),
+	SOC_SINGLE_EXT("Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_ADCBQEN_SHIFT, M98090_ADCBQEN_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
 };
 
 static const struct snd_kcontrol_new max98091_snd_controls[] = {
@@ -695,10 +849,12 @@ static const struct snd_kcontrol_new max98091_snd_controls[] = {
 		M98090_DMIC34_ZEROPAD_SHIFT,
 		M98090_DMIC34_ZEROPAD_NUM - 1, 0),
 
-	SOC_ENUM("Filter DMIC34 Mode", max98090_filter_dmic34mode_enum),
-	SOC_SINGLE("DMIC34 DC Blocking", M98090_REG_FILTER_CONFIG,
+	SOC_ENUM_EXT("Filter DMIC34 Mode", max98090_filter_dmic34mode_enum,
+		snd_soc_get_enum_double, max98090_put_enum_double),
+	SOC_SINGLE_EXT("DMIC34 DC Blocking", M98090_REG_FILTER_CONFIG,
 		M98090_FLT_DMIC34HPF_SHIFT,
-		M98090_FLT_DMIC34HPF_NUM - 1, 0),
+		M98090_FLT_DMIC34HPF_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
 
 	SOC_SINGLE_TLV("DMIC3 Boost Volume", M98090_REG_DMIC3_VOLUME,
 		M98090_DMIC_AV3G_SHIFT, M98090_DMIC_AV3G_NUM - 1, 0,
@@ -716,8 +872,9 @@ static const struct snd_kcontrol_new max98091_snd_controls[] = {
 
 	SND_SOC_BYTES("DMIC34 Biquad Coefficients",
 		M98090_REG_DMIC34_BIQUAD_BASE, 15),
-	SOC_SINGLE("DMIC34 Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
-		M98090_DMIC34BQEN_SHIFT, M98090_DMIC34BQEN_NUM - 1, 0),
+	SOC_SINGLE_EXT("DMIC34 Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_DMIC34BQEN_SHIFT, M98090_DMIC34BQEN_NUM - 1, 0,
+		snd_soc_get_volsw, max98090_put_volsw),
 
 	SOC_SINGLE_TLV("DMIC34 BQ PreAttenuation Volume",
 		M98090_REG_DMIC34_BQ_PREATTEN, M98090_AV34BQ_SHIFT,
@@ -771,19 +928,6 @@ static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 	return 0;
 }
 
-static int max98090_shdn_event(struct snd_soc_dapm_widget *w,
-				 struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
-	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
-
-	if (event & SND_SOC_DAPM_POST_PMU)
-		max98090->shdn_pending = true;
-
-	return 0;
-
-}
-
 static const char *mic1_mux_text[] = { "IN12", "IN56" };
 
 static SOC_ENUM_SINGLE_DECL(mic1_mux_enum,
@@ -884,10 +1028,14 @@ static SOC_ENUM_SINGLE_DECL(ltenr_mux_enum,
 			    lten_mux_text);
 
 static const struct snd_kcontrol_new max98090_ltenl_mux =
-	SOC_DAPM_ENUM("LTENL Mux", ltenl_mux_enum);
+	SOC_DAPM_ENUM_EXT("LTENL Mux", ltenl_mux_enum,
+			  snd_soc_dapm_get_enum_double,
+			  max98090_dapm_put_enum_double);
 
 static const struct snd_kcontrol_new max98090_ltenr_mux =
-	SOC_DAPM_ENUM("LTENR Mux", ltenr_mux_enum);
+	SOC_DAPM_ENUM_EXT("LTENR Mux", ltenr_mux_enum,
+			  snd_soc_dapm_get_enum_double,
+			  max98090_dapm_put_enum_double);
 
 static const char *lben_mux_text[] = { "Normal", "Loopback" };
 
@@ -902,10 +1050,14 @@ static SOC_ENUM_SINGLE_DECL(lbenr_mux_enum,
 			    lben_mux_text);
 
 static const struct snd_kcontrol_new max98090_lbenl_mux =
-	SOC_DAPM_ENUM("LBENL Mux", lbenl_mux_enum);
+	SOC_DAPM_ENUM_EXT("LBENL Mux", lbenl_mux_enum,
+			  snd_soc_dapm_get_enum_double,
+			  max98090_dapm_put_enum_double);
 
 static const struct snd_kcontrol_new max98090_lbenr_mux =
-	SOC_DAPM_ENUM("LBENR Mux", lbenr_mux_enum);
+	SOC_DAPM_ENUM_EXT("LBENR Mux", lbenr_mux_enum,
+			  snd_soc_dapm_get_enum_double,
+			  max98090_dapm_put_enum_double);
 
 static const char *stenl_mux_text[] = { "Normal", "Sidetone Left" };
 
@@ -1072,21 +1224,25 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 	SND_SOC_DAPM_INPUT("IN56"),
 
 	SND_SOC_DAPM_SUPPLY("MICBIAS", M98090_REG_INPUT_ENABLE,
-		M98090_MBEN_SHIFT, 0, NULL, 0),
+		M98090_MBEN_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 	SND_SOC_DAPM_SUPPLY("SHDN", M98090_REG_DEVICE_SHUTDOWN,
 		M98090_SHDNN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SDIEN", M98090_REG_IO_CONFIGURATION,
-		M98090_SDIEN_SHIFT, 0, NULL, 0),
+		M98090_SDIEN_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 	SND_SOC_DAPM_SUPPLY("SDOEN", M98090_REG_IO_CONFIGURATION,
-		M98090_SDOEN_SHIFT, 0, NULL, 0),
+		M98090_SDOEN_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 	SND_SOC_DAPM_SUPPLY("DMICL_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMICL_SHIFT, 0, max98090_shdn_event,
-			SND_SOC_DAPM_POST_PMU),
+		M98090_DIGMICL_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 	SND_SOC_DAPM_SUPPLY("DMICR_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMICR_SHIFT, 0, max98090_shdn_event,
-			 SND_SOC_DAPM_POST_PMU),
+		M98090_DIGMICR_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 	SND_SOC_DAPM_SUPPLY("AHPF", M98090_REG_FILTER_CONFIG,
-		M98090_AHPF_SHIFT, 0, NULL, 0),
+		M98090_AHPF_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 
 /*
  * Note: Sysclk and misc power supplies are taken care of by SHDN
@@ -1116,10 +1272,12 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 		&max98090_lineb_mixer_controls[0],
 		ARRAY_SIZE(max98090_lineb_mixer_controls)),
 
-	SND_SOC_DAPM_PGA("LINEA Input", M98090_REG_INPUT_ENABLE,
-		M98090_LINEAEN_SHIFT, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("LINEB Input", M98090_REG_INPUT_ENABLE,
-		M98090_LINEBEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA_E("LINEA Input", M98090_REG_INPUT_ENABLE,
+		M98090_LINEAEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+	SND_SOC_DAPM_PGA_E("LINEB Input", M98090_REG_INPUT_ENABLE,
+		M98090_LINEBEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 
 	SND_SOC_DAPM_MIXER("Left ADC Mixer", SND_SOC_NOPM, 0, 0,
 		&max98090_left_adc_mixer_controls[0],
@@ -1130,11 +1288,11 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 		ARRAY_SIZE(max98090_right_adc_mixer_controls)),
 
 	SND_SOC_DAPM_ADC_E("ADCL", NULL, M98090_REG_INPUT_ENABLE,
-		M98090_ADLEN_SHIFT, 0, max98090_shdn_event,
-		SND_SOC_DAPM_POST_PMU),
+		M98090_ADLEN_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 	SND_SOC_DAPM_ADC_E("ADCR", NULL, M98090_REG_INPUT_ENABLE,
-		M98090_ADREN_SHIFT, 0, max98090_shdn_event,
-		SND_SOC_DAPM_POST_PMU),
+		M98090_ADREN_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 
 	SND_SOC_DAPM_AIF_OUT("AIFOUTL", "HiFi Capture", 0,
 		SND_SOC_NOPM, 0, 0),
@@ -1162,10 +1320,12 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 	SND_SOC_DAPM_AIF_IN("AIFINL", "HiFi Playback", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_IN("AIFINR", "HiFi Playback", 1, SND_SOC_NOPM, 0, 0),
 
-	SND_SOC_DAPM_DAC("DACL", NULL, M98090_REG_OUTPUT_ENABLE,
-		M98090_DALEN_SHIFT, 0),
-	SND_SOC_DAPM_DAC("DACR", NULL, M98090_REG_OUTPUT_ENABLE,
-		M98090_DAREN_SHIFT, 0),
+	SND_SOC_DAPM_DAC_E("DACL", NULL, M98090_REG_OUTPUT_ENABLE,
+		M98090_DALEN_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+	SND_SOC_DAPM_DAC_E("DACR", NULL, M98090_REG_OUTPUT_ENABLE,
+		M98090_DAREN_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 
 	SND_SOC_DAPM_MIXER("Left Headphone Mixer", SND_SOC_NOPM, 0, 0,
 		&max98090_left_hp_mixer_controls[0],
@@ -1200,20 +1360,26 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 	SND_SOC_DAPM_MUX("MIXHPRSEL Mux", SND_SOC_NOPM, 0, 0,
 		&max98090_mixhprsel_mux),
 
-	SND_SOC_DAPM_PGA("HP Left Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_HPLEN_SHIFT, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("HP Right Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_HPREN_SHIFT, 0, NULL, 0),
-
-	SND_SOC_DAPM_PGA("SPK Left Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_SPLEN_SHIFT, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("SPK Right Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_SPREN_SHIFT, 0, NULL, 0),
-
-	SND_SOC_DAPM_PGA("RCV Left Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_RCVLEN_SHIFT, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("RCV Right Out", M98090_REG_OUTPUT_ENABLE,
-		M98090_RCVREN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA_E("HP Left Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_HPLEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+	SND_SOC_DAPM_PGA_E("HP Right Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_HPREN_SHIFT, 0, NULL, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+
+	SND_SOC_DAPM_PGA_E("SPK Left Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_SPLEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+	SND_SOC_DAPM_PGA_E("SPK Right Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_SPREN_SHIFT, 0, NULL, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+
+	SND_SOC_DAPM_PGA_E("RCV Left Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_RCVLEN_SHIFT, 0, NULL, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
+	SND_SOC_DAPM_PGA_E("RCV Right Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_RCVREN_SHIFT, 0, NULL, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 
 	SND_SOC_DAPM_OUTPUT("HPL"),
 	SND_SOC_DAPM_OUTPUT("HPR"),
@@ -1228,9 +1394,11 @@ static const struct snd_soc_dapm_widget max98091_dapm_widgets[] = {
 	SND_SOC_DAPM_INPUT("DMIC4"),
 
 	SND_SOC_DAPM_SUPPLY("DMIC3_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMIC3_SHIFT, 0, NULL, 0),
+		M98090_DIGMIC3_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 	SND_SOC_DAPM_SUPPLY("DMIC4_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMIC4_SHIFT, 0, NULL, 0),
+		M98090_DIGMIC4_SHIFT, 0, max98090_dapm_event,
+		SND_SOC_DAPM_PRE_POST_PMU | SND_SOC_DAPM_PRE_POST_PMD),
 };
 
 static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
@@ -1501,6 +1669,11 @@ static void max98090_configure_bclk(struct snd_soc_component *component)
 		return;
 	}
 
+	/*
+	 * Master mode: no need to save and restore SHDN for the following
+	 * sensitive registers.
+	 */
+
 	/* Check for supported PCLK to LRCLK ratios */
 	for (i = 0; i < ARRAY_SIZE(pclk_rates); i++) {
 		if ((pclk_rates[i] == max98090->sysclk) &&
@@ -1587,12 +1760,14 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 		switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 		case SND_SOC_DAIFMT_CBS_CFS:
 			/* Set to slave mode PLL - MAS mode off */
+			max98090_shdn_save(max98090);
 			snd_soc_component_write(component,
 				M98090_REG_CLOCK_RATIO_NI_MSB, 0x00);
 			snd_soc_component_write(component,
 				M98090_REG_CLOCK_RATIO_NI_LSB, 0x00);
 			snd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,
 				M98090_USE_M1_MASK, 0);
+			max98090_shdn_restore(max98090);
 			max98090->master = false;
 			break;
 		case SND_SOC_DAIFMT_CBM_CFM:
@@ -1618,7 +1793,9 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 			dev_err(component->dev, "DAI clock mode unsupported");
 			return -EINVAL;
 		}
+		max98090_shdn_save(max98090);
 		snd_soc_component_write(component, M98090_REG_MASTER_MODE, regval);
+		max98090_shdn_restore(max98090);
 
 		regval = 0;
 		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
@@ -1663,8 +1840,10 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 		if (max98090->tdm_slots > 1)
 			regval ^= M98090_BCI_MASK;
 
+		max98090_shdn_save(max98090);
 		snd_soc_component_write(component,
 			M98090_REG_INTERFACE_FORMAT, regval);
+		max98090_shdn_restore(max98090);
 	}
 
 	return 0;
@@ -1676,6 +1855,7 @@ static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
 	struct snd_soc_component *component = codec_dai->component;
 	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	struct max98090_cdata *cdata;
+
 	cdata = &max98090->dai[0];
 
 	if (slots < 0 || slots > 4)
@@ -1685,6 +1865,7 @@ static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
 	max98090->tdm_width = slot_width;
 
 	if (max98090->tdm_slots > 1) {
+		max98090_shdn_save(max98090);
 		/* SLOTL SLOTR SLOTDLY */
 		snd_soc_component_write(component, M98090_REG_TDM_FORMAT,
 			0 << M98090_TDM_SLOTL_SHIFT |
@@ -1695,6 +1876,7 @@ static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
 		snd_soc_component_update_bits(component, M98090_REG_TDM_CONTROL,
 			M98090_TDM_MASK,
 			M98090_TDM_MASK);
+		max98090_shdn_restore(max98090);
 	}
 
 	/*
@@ -1894,6 +2076,7 @@ static int max98090_configure_dmic(struct max98090_priv *max98090,
 	dmic_freq = dmic_table[pclk_index].settings[micclk_index].freq;
 	dmic_comp = dmic_table[pclk_index].settings[micclk_index].comp[i];
 
+	max98090_shdn_save(max98090);
 	regmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_ENABLE,
 			   M98090_MICCLK_MASK,
 			   micclk_index << M98090_MICCLK_SHIFT);
@@ -1902,6 +2085,7 @@ static int max98090_configure_dmic(struct max98090_priv *max98090,
 			   M98090_DMIC_COMP_MASK | M98090_DMIC_FREQ_MASK,
 			   dmic_comp << M98090_DMIC_COMP_SHIFT |
 			   dmic_freq << M98090_DMIC_FREQ_SHIFT);
+	max98090_shdn_restore(max98090);
 
 	return 0;
 }
@@ -1938,8 +2122,10 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 
 	switch (params_width(params)) {
 	case 16:
+		max98090_shdn_save(max98090);
 		snd_soc_component_update_bits(component, M98090_REG_INTERFACE_FORMAT,
 			M98090_WS_MASK, 0);
+		max98090_shdn_restore(max98090);
 		break;
 	default:
 		return -EINVAL;
@@ -1950,6 +2136,7 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 
 	cdata->rate = max98090->lrclk;
 
+	max98090_shdn_save(max98090);
 	/* Update filter mode */
 	if (max98090->lrclk < 24000)
 		snd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,
@@ -1965,6 +2152,7 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 	else
 		snd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,
 			M98090_DHF_MASK, M98090_DHF_MASK);
+	max98090_shdn_restore(max98090);
 
 	max98090_configure_dmic(max98090, max98090->dmic_freq, max98090->pclk,
 				max98090->lrclk);
@@ -1995,6 +2183,7 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 	 *		 0x02 (when master clk is 20MHz to 40MHz)..
 	 *		 0x03 (when master clk is 40MHz to 60MHz)..
 	 */
+	max98090_shdn_save(max98090);
 	if ((freq >= 10000000) && (freq <= 20000000)) {
 		snd_soc_component_write(component, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV1);
@@ -2009,8 +2198,10 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 		max98090->pclk = freq >> 2;
 	} else {
 		dev_err(component->dev, "Invalid master clock frequency\n");
+		max98090_shdn_restore(max98090);
 		return -EINVAL;
 	}
+	max98090_shdn_restore(max98090);
 
 	max98090->sysclk = freq;
 
@@ -2115,11 +2306,13 @@ static void max98090_pll_work(struct work_struct *work)
 	dev_info_ratelimited(component->dev, "PLL unlocked\n");
 
 	/* Toggle shutdown OFF then ON */
+	mutex_lock(&component->card->dapm_mutex);
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, 0);
 	msleep(10);
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+	mutex_unlock(&component->card->dapm_mutex);
 
 	/* Give PLL time to lock */
 	msleep(10);
@@ -2435,7 +2628,12 @@ static int max98090_probe(struct snd_soc_component *component)
 	 */
 	snd_soc_component_read32(component, M98090_REG_DEVICE_STATUS);
 
-	/* High Performance is default */
+	/*
+	 * SHDN should be 0 at the point, no need to save/restore for the
+	 * following registers.
+	 *
+	 * High Performance is default
+	 */
 	snd_soc_component_update_bits(component, M98090_REG_DAC_CONTROL,
 		M98090_DACHP_MASK,
 		1 << M98090_DACHP_SHIFT);
@@ -2446,7 +2644,12 @@ static int max98090_probe(struct snd_soc_component *component)
 		M98090_ADCHP_MASK,
 		1 << M98090_ADCHP_SHIFT);
 
-	/* Turn on VCM bandgap reference */
+	/*
+	 * SHDN should be 0 at the point, no need to save/restore for the
+	 * following registers.
+	 *
+	 * Turn on VCM bandgap reference
+	 */
 	snd_soc_component_write(component, M98090_REG_BIAS_CONTROL,
 		M98090_VCM_MODE_MASK);
 
@@ -2479,25 +2682,9 @@ static void max98090_remove(struct snd_soc_component *component)
 	max98090->component = NULL;
 }
 
-static void max98090_seq_notifier(struct snd_soc_component *component,
-	enum snd_soc_dapm_type event, int subseq)
-{
-	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
-
-	if (max98090->shdn_pending) {
-		snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
-				M98090_SHDNN_MASK, 0);
-		msleep(40);
-		snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
-				M98090_SHDNN_MASK, M98090_SHDNN_MASK);
-		max98090->shdn_pending = false;
-	}
-}
-
 static const struct snd_soc_component_driver soc_component_dev_max98090 = {
 	.probe			= max98090_probe,
 	.remove			= max98090_remove,
-	.seq_notifier		= max98090_seq_notifier,
 	.set_bias_level		= max98090_set_bias_level,
 	.idle_bias_on		= 1,
 	.use_pmdown_time	= 1,

commit 45dfbf56975994822cce00b7475732a49f8aefed
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Fri Nov 22 15:31:14 2019 +0800

    ASoC: max98090: fix possible race conditions
    
    max98090_interrupt() and max98090_pll_work() run in 2 different threads.
    There are 2 possible races:
    
    Note: M98090_REG_DEVICE_STATUS = 0x01.
    Note: ULK == 0, PLL is locked; ULK == 1, PLL is unlocked.
    
    max98090_interrupt      max98090_pll_work
    ----------------------------------------------
    schedule max98090_pll_work
                            restart max98090 codec
    receive ULK INT
                            assert ULK == 0
    schedule max98090_pll_work (1).
    
    In the case (1), the PLL is locked but max98090_interrupt unnecessarily
    schedules another max98090_pll_work.
    
    max98090_interrupt      max98090_pll_work      max98090 codec
    ----------------------------------------------------------------------
                                                   ULK = 1
    receive ULK INT
    read 0x01
                                                   ULK = 0 (clear on read)
    schedule max98090_pll_work
                            restart max98090 codec
                                                   ULK = 1
    receive ULK INT
    read 0x01
                                                   ULK = 0 (clear on read)
                            read 0x01
                            assert ULK == 0 (2).
    
    In the case (2), both max98090_interrupt and max98090_pll_work read
    the same clear-on-read register.  max98090_pll_work would falsely
    thought PLL is locked.
    Note: the case (2) race is introduced by the previous commit ("ASoC:
    max98090: exit workaround earlier if PLL is locked") to check the status
    and exit the loop earlier in max98090_pll_work.
    
    There are 2 possible solution options:
    A. turn off ULK interrupt before scheduling max98090_pll_work; and turn
    on again before exiting max98090_pll_work.
    B. remove the second thread of execution.
    
    Option A cannot fix the case (2) race because it still has 2 threads
    access the same clear-on-read register simultaneously.  Although we
    could suppose the register is volatile and read the status via I2C could
    be much slower than the hardware raises the bits.
    
    Option B introduces a maximum 10~12 msec penalty delay in the interrupt
    handler.  However, it could only punish the jack detection by extra
    10~12 msec.
    
    Adopts option B which is the better solution overall.
    
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20191122073114.219945-4-tzungbi@google.com
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f531e5a11bdd..e46b6ada13b1 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2103,10 +2103,8 @@ static void max98090_pll_det_disable_work(struct work_struct *work)
 			    M98090_IULK_MASK, 0);
 }
 
-static void max98090_pll_work(struct work_struct *work)
+static void max98090_pll_work(struct max98090_priv *max98090)
 {
-	struct max98090_priv *max98090 =
-		container_of(work, struct max98090_priv, pll_work);
 	struct snd_soc_component *component = max98090->component;
 	unsigned int pll;
 	int i;
@@ -2275,7 +2273,7 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
 
 	if (active & M98090_ULK_MASK) {
 		dev_dbg(component->dev, "M98090_ULK_MASK\n");
-		schedule_work(&max98090->pll_work);
+		max98090_pll_work(max98090);
 	}
 
 	if (active & M98090_JDET_MASK) {
@@ -2438,7 +2436,6 @@ static int max98090_probe(struct snd_soc_component *component)
 			  max98090_pll_det_enable_work);
 	INIT_WORK(&max98090->pll_det_disable_work,
 		  max98090_pll_det_disable_work);
-	INIT_WORK(&max98090->pll_work, max98090_pll_work);
 
 	/* Enable jack detection */
 	snd_soc_component_write(component, M98090_REG_JACK_DETECT,
@@ -2491,7 +2488,6 @@ static void max98090_remove(struct snd_soc_component *component)
 	cancel_delayed_work_sync(&max98090->jack_work);
 	cancel_delayed_work_sync(&max98090->pll_det_enable_work);
 	cancel_work_sync(&max98090->pll_det_disable_work);
-	cancel_work_sync(&max98090->pll_work);
 	max98090->component = NULL;
 }
 

commit 6f49919d11690a9b5614445ba30fde18083fdd63
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Fri Nov 22 15:31:13 2019 +0800

    ASoC: max98090: exit workaround earlier if PLL is locked
    
    According to the datasheet, PLL lock time typically takes 2 msec and
    at most takes 7 msec.
    
    Check the lock status every 1 msec and exit the workaround if PLL is
    locked.
    
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20191122073114.219945-3-tzungbi@google.com
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 12cb87c0d463..f531e5a11bdd 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2108,6 +2108,8 @@ static void max98090_pll_work(struct work_struct *work)
 	struct max98090_priv *max98090 =
 		container_of(work, struct max98090_priv, pll_work);
 	struct snd_soc_component *component = max98090->component;
+	unsigned int pll;
+	int i;
 
 	if (!snd_soc_component_is_active(component))
 		return;
@@ -2127,8 +2129,16 @@ static void max98090_pll_work(struct work_struct *work)
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, M98090_SHDNN_MASK);
 
-	/* Give PLL time to lock */
-	msleep(10);
+	for (i = 0; i < 10; ++i) {
+		/* Give PLL time to lock */
+		usleep_range(1000, 1200);
+
+		/* Check lock status */
+		pll = snd_soc_component_read32(
+				component, M98090_REG_DEVICE_STATUS);
+		if (!(pll & M98090_ULK_MASK))
+			break;
+	}
 }
 
 static void max98090_jack_work(struct work_struct *work)

commit acb874a7c049ec49d8fc66c893170fb42c01bdf7
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Fri Nov 22 15:31:12 2019 +0800

    ASoC: max98090: remove msleep in PLL unlocked workaround
    
    It was observed Baytrail-based chromebooks could cause continuous PLL
    unlocked when using playback stream and capture stream simultaneously.
    Specifically, starting a capture stream after started a playback stream.
    As a result, the audio data could corrupt or turn completely silent.
    
    As the datasheet suggested, the maximum PLL lock time should be 7 msec.
    The workaround resets the codec softly by toggling SHDN off and on if
    PLL failed to lock for 10 msec.  Notably, there is no suggested hold
    time for SHDN off.
    
    On Baytrail-based chromebooks, it would easily happen continuous PLL
    unlocked if there is a 10 msec delay between SHDN off and on.  Removes
    the msleep().
    
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Link: https://lore.kernel.org/r/20191122073114.219945-2-tzungbi@google.com
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f6bf4cfbea23..12cb87c0d463 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2114,10 +2114,16 @@ static void max98090_pll_work(struct work_struct *work)
 
 	dev_info_ratelimited(component->dev, "PLL unlocked\n");
 
+	/*
+	 * As the datasheet suggested, the maximum PLL lock time should be
+	 * 7 msec.  The workaround resets the codec softly by toggling SHDN
+	 * off and on if PLL failed to lock for 10 msec.  Notably, there is
+	 * no suggested hold time for SHDN off.
+	 */
+
 	/* Toggle shutdown OFF then ON */
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, 0);
-	msleep(10);
 	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, M98090_SHDNN_MASK);
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index ada8c25e643d..f6bf4cfbea23 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * max98090.c -- MAX98090 ALSA SoC Audio driver
  *
  * Copyright 2011-2012 Maxim Integrated Products
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/delay.h>

commit 5628c8979642a076f91ee86c3bae5ad251639af0
Author: Yu-Hsuan Hsu <yuhsuan@chromium.org>
Date:   Tue Jun 4 18:49:09 2019 +0800

    ASoC: max98090: remove 24-bit format support if RJ is 0
    
    The supported formats are S16_LE and S24_LE now. However, by datasheet
    of max98090, S24_LE is only supported when it is in the right justified
    mode. We should remove 24-bit format if it is not in that mode to avoid
    triggering error.
    
    Signed-off-by: Yu-Hsuan Hsu <yuhsuan@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 7619ea31ab50..ada8c25e643d 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1909,6 +1909,21 @@ static int max98090_configure_dmic(struct max98090_priv *max98090,
 	return 0;
 }
 
+static int max98090_dai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
+	unsigned int fmt = max98090->dai_fmt;
+
+	/* Remove 24-bit format support if it is not in right justified mode. */
+	if ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_RIGHT_J) {
+		substream->runtime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE;
+		snd_pcm_hw_constraint_msbits(substream->runtime, 0, 16, 16);
+	}
+	return 0;
+}
+
 static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 				   struct snd_pcm_hw_params *params,
 				   struct snd_soc_dai *dai)
@@ -2316,6 +2331,7 @@ EXPORT_SYMBOL_GPL(max98090_mic_detect);
 #define MAX98090_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
 
 static const struct snd_soc_dai_ops max98090_dai_ops = {
+	.startup = max98090_dai_startup,
 	.set_sysclk = max98090_dai_set_sysclk,
 	.set_fmt = max98090_dai_set_fmt,
 	.set_tdm_slot = max98090_set_tdm_slot,

commit ecb2795c08bc825ebd604997e5be440b060c5b18
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Wed May 1 15:29:38 2019 +0100

    ASoC: max98090: Fix restore of DAPM Muxes
    
    The max98090 driver defines 3 DAPM muxes; one for the right line output
    (LINMOD Mux), one for the left headphone mixer source (MIXHPLSEL Mux)
    and one for the right headphone mixer source (MIXHPRSEL Mux). The same
    bit is used for the mux as well as the DAPM enable, and although the mux
    can be correctly configured, after playback has completed, the mux will
    be reset during the disable phase. This is preventing the state of these
    muxes from being saved and restored correctly on system reboot. Fix this
    by marking these muxes as SND_SOC_NOPM.
    
    Note this has been verified this on the Tegra124 Nyan Big which features
    the MAX98090 codec.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 30c242c38d99..7619ea31ab50 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1194,14 +1194,14 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 		&max98090_right_rcv_mixer_controls[0],
 		ARRAY_SIZE(max98090_right_rcv_mixer_controls)),
 
-	SND_SOC_DAPM_MUX("LINMOD Mux", M98090_REG_LOUTR_MIXER,
-		M98090_LINMOD_SHIFT, 0, &max98090_linmod_mux),
+	SND_SOC_DAPM_MUX("LINMOD Mux", SND_SOC_NOPM, 0, 0,
+		&max98090_linmod_mux),
 
-	SND_SOC_DAPM_MUX("MIXHPLSEL Mux", M98090_REG_HP_CONTROL,
-		M98090_MIXHPLSEL_SHIFT, 0, &max98090_mixhplsel_mux),
+	SND_SOC_DAPM_MUX("MIXHPLSEL Mux", SND_SOC_NOPM, 0, 0,
+		&max98090_mixhplsel_mux),
 
-	SND_SOC_DAPM_MUX("MIXHPRSEL Mux", M98090_REG_HP_CONTROL,
-		M98090_MIXHPRSEL_SHIFT, 0, &max98090_mixhprsel_mux),
+	SND_SOC_DAPM_MUX("MIXHPRSEL Mux", SND_SOC_NOPM, 0, 0,
+		&max98090_mixhprsel_mux),
 
 	SND_SOC_DAPM_PGA("HP Left Out", M98090_REG_OUTPUT_ENABLE,
 		M98090_HPLEN_SHIFT, 0, NULL, 0),

commit 97d8f6b71f56865e52d472247fe728700ef7128d
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Jan 4 20:02:30 2019 -0600

    ASoC: max98090: remove unused constant variables
    
    Fix warnings with W=1
    
    If these variables are useful then this driver should be modified to
    expose them.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index c97f21836c66..30c242c38d99 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -314,9 +314,6 @@ static const DECLARE_TLV_DB_SCALE(max98090_av_tlv, -1200, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_dvg_tlv, 0, 600, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_dv_tlv, -1500, 100, 0);
 
-static const DECLARE_TLV_DB_SCALE(max98090_sidetone_tlv, -6050, 200, 0);
-
-static const DECLARE_TLV_DB_SCALE(max98090_alc_tlv, -1500, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_alcmakeup_tlv, 0, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_alccomp_tlv, -3100, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_drcexp_tlv, -6600, 100, 0);
@@ -817,18 +814,6 @@ static SOC_ENUM_SINGLE_VIRT_DECL(dmic_mux_enum, dmic_mux_text);
 static const struct snd_kcontrol_new max98090_dmic_mux =
 	SOC_DAPM_ENUM("DMIC Mux", dmic_mux_enum);
 
-static const char *max98090_micpre_text[] = { "Off", "On" };
-
-static SOC_ENUM_SINGLE_DECL(max98090_pa1en_enum,
-			    M98090_REG_MIC1_INPUT_LEVEL,
-			    M98090_MIC_PA1EN_SHIFT,
-			    max98090_micpre_text);
-
-static SOC_ENUM_SINGLE_DECL(max98090_pa2en_enum,
-			    M98090_REG_MIC2_INPUT_LEVEL,
-			    M98090_MIC_PA2EN_SHIFT,
-			    max98090_micpre_text);
-
 /* LINEA mixer switch */
 static const struct snd_kcontrol_new max98090_linea_mixer_controls[] = {
 	SOC_DAPM_SINGLE("IN1 Switch", M98090_REG_LINE_INPUT_CONFIG,

commit 4c66b9d165e0994b9be1ff3233037e614fae22af
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 29 04:05:59 2018 +0000

    ASoC: max98090: replace codec to component
    
    Now we can replace Codec to Component. Let's do it.
    
    Note:
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 0      ->      .idle_bias_on = 1
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f5075d1f79e6..c97f21836c66 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -284,7 +284,7 @@ static int max98090_reset(struct max98090_priv *max98090)
 	ret = regmap_write(max98090->regmap, M98090_REG_SOFTWARE_RESET,
 		M98090_SWRESET_MASK);
 	if (ret < 0) {
-		dev_err(max98090->codec->dev,
+		dev_err(max98090->component->dev,
 			"Failed to reset codec: %d\n", ret);
 		return ret;
 	}
@@ -354,12 +354,12 @@ static const DECLARE_TLV_DB_RANGE(max98090_rcv_lout_tlv,
 static int max98090_get_enab_tlv(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	unsigned int mask = (1 << fls(mc->max)) - 1;
-	unsigned int val = snd_soc_read(codec, mc->reg);
+	unsigned int val = snd_soc_component_read32(component, mc->reg);
 	unsigned int *select;
 
 	switch (mc->reg) {
@@ -394,13 +394,13 @@ static int max98090_get_enab_tlv(struct snd_kcontrol *kcontrol,
 static int max98090_put_enab_tlv(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	unsigned int mask = (1 << fls(mc->max)) - 1;
 	unsigned int sel = ucontrol->value.integer.value[0];
-	unsigned int val = snd_soc_read(codec, mc->reg);
+	unsigned int val = snd_soc_component_read32(component, mc->reg);
 	unsigned int *select;
 
 	switch (mc->reg) {
@@ -429,7 +429,7 @@ static int max98090_put_enab_tlv(struct snd_kcontrol *kcontrol,
 		sel = val;
 	}
 
-	snd_soc_update_bits(codec, mc->reg,
+	snd_soc_component_update_bits(component, mc->reg,
 		mask << mc->shift,
 		sel << mc->shift);
 
@@ -733,10 +733,10 @@ static const struct snd_kcontrol_new max98091_snd_controls[] = {
 static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 				 struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 
-	unsigned int val = snd_soc_read(codec, w->reg);
+	unsigned int val = snd_soc_component_read32(component, w->reg);
 
 	if (w->reg == M98090_REG_MIC1_INPUT_LEVEL)
 		val = (val & M98090_MIC_PA1EN_MASK) >> M98090_MIC_PA1EN_SHIFT;
@@ -768,10 +768,10 @@ static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 	}
 
 	if (w->reg == M98090_REG_MIC1_INPUT_LEVEL)
-		snd_soc_update_bits(codec, w->reg, M98090_MIC_PA1EN_MASK,
+		snd_soc_component_update_bits(component, w->reg, M98090_MIC_PA1EN_MASK,
 			val << M98090_MIC_PA1EN_SHIFT);
 	else
-		snd_soc_update_bits(codec, w->reg, M98090_MIC_PA2EN_MASK,
+		snd_soc_component_update_bits(component, w->reg, M98090_MIC_PA2EN_MASK,
 			val << M98090_MIC_PA2EN_SHIFT);
 
 	return 0;
@@ -780,8 +780,8 @@ static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 static int max98090_shdn_event(struct snd_soc_dapm_widget *w,
 				 struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 
 	if (event & SND_SOC_DAPM_POST_PMU)
 		max98090->shdn_pending = true;
@@ -1441,16 +1441,16 @@ static const struct snd_soc_dapm_route max98091_dapm_routes[] = {
 	{"DMIC4", NULL, "AHPF"},
 };
 
-static int max98090_add_widgets(struct snd_soc_codec *codec)
+static int max98090_add_widgets(struct snd_soc_component *component)
 {
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
-	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 
-	snd_soc_add_codec_controls(codec, max98090_snd_controls,
+	snd_soc_add_component_controls(component, max98090_snd_controls,
 		ARRAY_SIZE(max98090_snd_controls));
 
 	if (max98090->devtype == MAX98091) {
-		snd_soc_add_codec_controls(codec, max98091_snd_controls,
+		snd_soc_add_component_controls(component, max98091_snd_controls,
 			ARRAY_SIZE(max98091_snd_controls));
 	}
 
@@ -1497,24 +1497,24 @@ static const unsigned long long mi_value[] = {
 	8125, 1625, 1500, 25
 };
 
-static void max98090_configure_bclk(struct snd_soc_codec *codec)
+static void max98090_configure_bclk(struct snd_soc_component *component)
 {
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	unsigned long long ni;
 	int i;
 
 	if (!max98090->sysclk) {
-		dev_err(codec->dev, "No SYSCLK configured\n");
+		dev_err(component->dev, "No SYSCLK configured\n");
 		return;
 	}
 
 	if (!max98090->bclk || !max98090->lrclk) {
-		dev_err(codec->dev, "No audio clocks configured\n");
+		dev_err(component->dev, "No audio clocks configured\n");
 		return;
 	}
 
 	/* Skip configuration when operating as slave */
-	if (!(snd_soc_read(codec, M98090_REG_MASTER_MODE) &
+	if (!(snd_soc_component_read32(component, M98090_REG_MASTER_MODE) &
 		M98090_MAS_MASK)) {
 		return;
 	}
@@ -1523,14 +1523,14 @@ static void max98090_configure_bclk(struct snd_soc_codec *codec)
 	for (i = 0; i < ARRAY_SIZE(pclk_rates); i++) {
 		if ((pclk_rates[i] == max98090->sysclk) &&
 			(lrclk_rates[i] == max98090->lrclk)) {
-			dev_dbg(codec->dev,
+			dev_dbg(component->dev,
 				"Found supported PCLK to LRCLK rates 0x%x\n",
 				i + 0x8);
 
-			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+			snd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,
 				M98090_FREQ_MASK,
 				(i + 0x8) << M98090_FREQ_SHIFT);
-			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+			snd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,
 				M98090_USE_M1_MASK, 0);
 			return;
 		}
@@ -1540,24 +1540,24 @@ static void max98090_configure_bclk(struct snd_soc_codec *codec)
 	for (i = 0; i < ARRAY_SIZE(user_pclk_rates); i++) {
 		if ((user_pclk_rates[i] == max98090->sysclk) &&
 			(user_lrclk_rates[i] == max98090->lrclk)) {
-			dev_dbg(codec->dev,
+			dev_dbg(component->dev,
 				"Found user supported PCLK to LRCLK rates\n");
-			dev_dbg(codec->dev, "i %d ni %lld mi %lld\n",
+			dev_dbg(component->dev, "i %d ni %lld mi %lld\n",
 				i, ni_value[i], mi_value[i]);
 
-			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+			snd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,
 				M98090_FREQ_MASK, 0);
-			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+			snd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,
 				M98090_USE_M1_MASK,
 					1 << M98090_USE_M1_SHIFT);
 
-			snd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_MSB,
+			snd_soc_component_write(component, M98090_REG_CLOCK_RATIO_NI_MSB,
 				(ni_value[i] >> 8) & 0x7F);
-			snd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_LSB,
+			snd_soc_component_write(component, M98090_REG_CLOCK_RATIO_NI_LSB,
 				ni_value[i] & 0xFF);
-			snd_soc_write(codec, M98090_REG_CLOCK_RATIO_MI_MSB,
+			snd_soc_component_write(component, M98090_REG_CLOCK_RATIO_MI_MSB,
 				(mi_value[i] >> 8) & 0x7F);
-			snd_soc_write(codec, M98090_REG_CLOCK_RATIO_MI_LSB,
+			snd_soc_component_write(component, M98090_REG_CLOCK_RATIO_MI_LSB,
 				mi_value[i] & 0xFF);
 
 			return;
@@ -1567,9 +1567,9 @@ static void max98090_configure_bclk(struct snd_soc_codec *codec)
 	/*
 	 * Calculate based on MI = 65536 (not as good as either method above)
 	 */
-	snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+	snd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,
 		M98090_FREQ_MASK, 0);
-	snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+	snd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,
 		M98090_USE_M1_MASK, 0);
 
 	/*
@@ -1580,18 +1580,18 @@ static void max98090_configure_bclk(struct snd_soc_codec *codec)
 	ni = 65536ULL * (max98090->lrclk < 50000 ? 96ULL : 48ULL)
 			* (unsigned long long int)max98090->lrclk;
 	do_div(ni, (unsigned long long int)max98090->sysclk);
-	dev_info(codec->dev, "No better method found\n");
-	dev_info(codec->dev, "Calculating ni %lld with mi 65536\n", ni);
-	snd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_MSB,
+	dev_info(component->dev, "No better method found\n");
+	dev_info(component->dev, "Calculating ni %lld with mi 65536\n", ni);
+	snd_soc_component_write(component, M98090_REG_CLOCK_RATIO_NI_MSB,
 		(ni >> 8) & 0x7F);
-	snd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_LSB, ni & 0xFF);
+	snd_soc_component_write(component, M98090_REG_CLOCK_RATIO_NI_LSB, ni & 0xFF);
 }
 
 static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 				 unsigned int fmt)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = codec_dai->component;
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	struct max98090_cdata *cdata;
 	u8 regval;
 
@@ -1605,11 +1605,11 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 		switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 		case SND_SOC_DAIFMT_CBS_CFS:
 			/* Set to slave mode PLL - MAS mode off */
-			snd_soc_write(codec,
+			snd_soc_component_write(component,
 				M98090_REG_CLOCK_RATIO_NI_MSB, 0x00);
-			snd_soc_write(codec,
+			snd_soc_component_write(component,
 				M98090_REG_CLOCK_RATIO_NI_LSB, 0x00);
-			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+			snd_soc_component_update_bits(component, M98090_REG_CLOCK_MODE,
 				M98090_USE_M1_MASK, 0);
 			max98090->master = false;
 			break;
@@ -1633,10 +1633,10 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 		case SND_SOC_DAIFMT_CBS_CFM:
 		case SND_SOC_DAIFMT_CBM_CFS:
 		default:
-			dev_err(codec->dev, "DAI clock mode unsupported");
+			dev_err(component->dev, "DAI clock mode unsupported");
 			return -EINVAL;
 		}
-		snd_soc_write(codec, M98090_REG_MASTER_MODE, regval);
+		snd_soc_component_write(component, M98090_REG_MASTER_MODE, regval);
 
 		regval = 0;
 		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
@@ -1651,7 +1651,7 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 		case SND_SOC_DAIFMT_DSP_A:
 			/* Not supported mode */
 		default:
-			dev_err(codec->dev, "DAI format unsupported");
+			dev_err(component->dev, "DAI format unsupported");
 			return -EINVAL;
 		}
 
@@ -1668,7 +1668,7 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 			regval |= M98090_BCI_MASK|M98090_WCI_MASK;
 			break;
 		default:
-			dev_err(codec->dev, "DAI invert mode unsupported");
+			dev_err(component->dev, "DAI invert mode unsupported");
 			return -EINVAL;
 		}
 
@@ -1681,7 +1681,7 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 		if (max98090->tdm_slots > 1)
 			regval ^= M98090_BCI_MASK;
 
-		snd_soc_write(codec,
+		snd_soc_component_write(component,
 			M98090_REG_INTERFACE_FORMAT, regval);
 	}
 
@@ -1691,8 +1691,8 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
 	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = codec_dai->component;
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	struct max98090_cdata *cdata;
 	cdata = &max98090->dai[0];
 
@@ -1704,13 +1704,13 @@ static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
 
 	if (max98090->tdm_slots > 1) {
 		/* SLOTL SLOTR SLOTDLY */
-		snd_soc_write(codec, M98090_REG_TDM_FORMAT,
+		snd_soc_component_write(component, M98090_REG_TDM_FORMAT,
 			0 << M98090_TDM_SLOTL_SHIFT |
 			1 << M98090_TDM_SLOTR_SHIFT |
 			0 << M98090_TDM_SLOTDLY_SHIFT);
 
 		/* FSW TDM */
-		snd_soc_update_bits(codec, M98090_REG_TDM_CONTROL,
+		snd_soc_component_update_bits(component, M98090_REG_TDM_CONTROL,
 			M98090_TDM_MASK,
 			M98090_TDM_MASK);
 	}
@@ -1724,10 +1724,10 @@ static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
 	return 0;
 }
 
-static int max98090_set_bias_level(struct snd_soc_codec *codec,
+static int max98090_set_bias_level(struct snd_soc_component *component,
 				   enum snd_soc_bias_level level)
 {
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	int ret;
 
 	switch (level) {
@@ -1745,7 +1745,7 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 		if (IS_ERR(max98090->mclk))
 			break;
 
-		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_ON) {
+		if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_ON) {
 			clk_disable_unprepare(max98090->mclk);
 		} else {
 			ret = clk_prepare_enable(max98090->mclk);
@@ -1755,10 +1755,10 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 		break;
 
 	case SND_SOC_BIAS_STANDBY:
-		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
+		if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {
 			ret = regcache_sync(max98090->regmap);
 			if (ret != 0) {
-				dev_err(codec->dev,
+				dev_err(component->dev,
 					"Failed to sync cache: %d\n", ret);
 				return ret;
 			}
@@ -1767,7 +1767,7 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 
 	case SND_SOC_BIAS_OFF:
 		/* Set internal pull-up to lowest power mode */
-		snd_soc_update_bits(codec, M98090_REG_JACK_DETECT,
+		snd_soc_component_update_bits(component, M98090_REG_JACK_DETECT,
 			M98090_JDWK_MASK, M98090_JDWK_MASK);
 		regcache_mark_dirty(max98090->regmap);
 		break;
@@ -1928,8 +1928,8 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 				   struct snd_pcm_hw_params *params,
 				   struct snd_soc_dai *dai)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	struct max98090_cdata *cdata;
 
 	cdata = &max98090->dai[0];
@@ -1941,7 +1941,7 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 
 	switch (params_width(params)) {
 	case 16:
-		snd_soc_update_bits(codec, M98090_REG_INTERFACE_FORMAT,
+		snd_soc_component_update_bits(component, M98090_REG_INTERFACE_FORMAT,
 			M98090_WS_MASK, 0);
 		break;
 	default:
@@ -1949,24 +1949,24 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	if (max98090->master)
-		max98090_configure_bclk(codec);
+		max98090_configure_bclk(component);
 
 	cdata->rate = max98090->lrclk;
 
 	/* Update filter mode */
 	if (max98090->lrclk < 24000)
-		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
+		snd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,
 			M98090_MODE_MASK, 0);
 	else
-		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
+		snd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,
 			M98090_MODE_MASK, M98090_MODE_MASK);
 
 	/* Update sample rate mode */
 	if (max98090->lrclk < 50000)
-		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
+		snd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,
 			M98090_DHF_MASK, 0);
 	else
-		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
+		snd_soc_component_update_bits(component, M98090_REG_FILTER_CONFIG,
 			M98090_DHF_MASK, M98090_DHF_MASK);
 
 	max98090_configure_dmic(max98090, max98090->dmic_freq, max98090->pclk,
@@ -1981,8 +1981,8 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 				   int clk_id, unsigned int freq, int dir)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 
 	/* Requested clock frequency is already setup */
 	if (freq == max98090->sysclk)
@@ -1999,19 +1999,19 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 	 *		 0x03 (when master clk is 40MHz to 60MHz)..
 	 */
 	if ((freq >= 10000000) && (freq <= 20000000)) {
-		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
+		snd_soc_component_write(component, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV1);
 		max98090->pclk = freq;
 	} else if ((freq > 20000000) && (freq <= 40000000)) {
-		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
+		snd_soc_component_write(component, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV2);
 		max98090->pclk = freq >> 1;
 	} else if ((freq > 40000000) && (freq <= 60000000)) {
-		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
+		snd_soc_component_write(component, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV4);
 		max98090->pclk = freq >> 2;
 	} else {
-		dev_err(codec->dev, "Invalid master clock frequency\n");
+		dev_err(component->dev, "Invalid master clock frequency\n");
 		return -EINVAL;
 	}
 
@@ -2022,11 +2022,11 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 
 static int max98090_dai_digital_mute(struct snd_soc_dai *codec_dai, int mute)
 {
-	struct snd_soc_codec *codec = codec_dai->codec;
+	struct snd_soc_component *component = codec_dai->component;
 	int regval;
 
 	regval = mute ? M98090_DVM_MASK : 0;
-	snd_soc_update_bits(codec, M98090_REG_DAI_PLAYBACK_LEVEL,
+	snd_soc_component_update_bits(component, M98090_REG_DAI_PLAYBACK_LEVEL,
 		M98090_DVM_MASK, regval);
 
 	return 0;
@@ -2035,8 +2035,8 @@ static int max98090_dai_digital_mute(struct snd_soc_dai *codec_dai, int mute)
 static int max98090_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 				struct snd_soc_dai *dai)
 {
-	struct snd_soc_codec *codec = dai->codec;
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_component *component = dai->component;
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -2065,7 +2065,7 @@ static void max98090_pll_det_enable_work(struct work_struct *work)
 	struct max98090_priv *max98090 =
 		container_of(work, struct max98090_priv,
 			     pll_det_enable_work.work);
-	struct snd_soc_codec *codec = max98090->codec;
+	struct snd_soc_component *component = max98090->component;
 	unsigned int status, mask;
 
 	/*
@@ -2088,7 +2088,7 @@ static void max98090_pll_det_enable_work(struct work_struct *work)
 				   msecs_to_jiffies(100));
 
 	/* Enable PLL unlock interrupt */
-	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+	snd_soc_component_update_bits(component, M98090_REG_INTERRUPT_S,
 			    M98090_IULK_MASK,
 			    1 << M98090_IULK_SHIFT);
 }
@@ -2097,12 +2097,12 @@ static void max98090_pll_det_disable_work(struct work_struct *work)
 {
 	struct max98090_priv *max98090 =
 		container_of(work, struct max98090_priv, pll_det_disable_work);
-	struct snd_soc_codec *codec = max98090->codec;
+	struct snd_soc_component *component = max98090->component;
 
 	cancel_delayed_work_sync(&max98090->pll_det_enable_work);
 
 	/* Disable PLL unlock interrupt */
-	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+	snd_soc_component_update_bits(component, M98090_REG_INTERRUPT_S,
 			    M98090_IULK_MASK, 0);
 }
 
@@ -2110,18 +2110,18 @@ static void max98090_pll_work(struct work_struct *work)
 {
 	struct max98090_priv *max98090 =
 		container_of(work, struct max98090_priv, pll_work);
-	struct snd_soc_codec *codec = max98090->codec;
+	struct snd_soc_component *component = max98090->component;
 
-	if (!snd_soc_codec_is_active(codec))
+	if (!snd_soc_component_is_active(component))
 		return;
 
-	dev_info_ratelimited(codec->dev, "PLL unlocked\n");
+	dev_info_ratelimited(component->dev, "PLL unlocked\n");
 
 	/* Toggle shutdown OFF then ON */
-	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, 0);
 	msleep(10);
-	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+	snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 			    M98090_SHDNN_MASK, M98090_SHDNN_MASK);
 
 	/* Give PLL time to lock */
@@ -2133,7 +2133,7 @@ static void max98090_jack_work(struct work_struct *work)
 	struct max98090_priv *max98090 = container_of(work,
 		struct max98090_priv,
 		jack_work.work);
-	struct snd_soc_codec *codec = max98090->codec;
+	struct snd_soc_component *component = max98090->component;
 	int status = 0;
 	int reg;
 
@@ -2141,25 +2141,25 @@ static void max98090_jack_work(struct work_struct *work)
 	if (max98090->jack_state == M98090_JACK_STATE_NO_HEADSET) {
 
 		/* Strong pull up allows mic detection */
-		snd_soc_update_bits(codec, M98090_REG_JACK_DETECT,
+		snd_soc_component_update_bits(component, M98090_REG_JACK_DETECT,
 			M98090_JDWK_MASK, 0);
 
 		msleep(50);
 
-		reg = snd_soc_read(codec, M98090_REG_JACK_STATUS);
+		reg = snd_soc_component_read32(component, M98090_REG_JACK_STATUS);
 
 		/* Weak pull up allows only insertion detection */
-		snd_soc_update_bits(codec, M98090_REG_JACK_DETECT,
+		snd_soc_component_update_bits(component, M98090_REG_JACK_DETECT,
 			M98090_JDWK_MASK, M98090_JDWK_MASK);
 	} else {
-		reg = snd_soc_read(codec, M98090_REG_JACK_STATUS);
+		reg = snd_soc_component_read32(component, M98090_REG_JACK_STATUS);
 	}
 
-	reg = snd_soc_read(codec, M98090_REG_JACK_STATUS);
+	reg = snd_soc_component_read32(component, M98090_REG_JACK_STATUS);
 
 	switch (reg & (M98090_LSNS_MASK | M98090_JKSNS_MASK)) {
 		case M98090_LSNS_MASK | M98090_JKSNS_MASK:
-			dev_dbg(codec->dev, "No Headset Detected\n");
+			dev_dbg(component->dev, "No Headset Detected\n");
 
 			max98090->jack_state = M98090_JACK_STATE_NO_HEADSET;
 
@@ -2171,7 +2171,7 @@ static void max98090_jack_work(struct work_struct *work)
 			if (max98090->jack_state ==
 				M98090_JACK_STATE_HEADSET) {
 
-				dev_dbg(codec->dev,
+				dev_dbg(component->dev,
 					"Headset Button Down Detected\n");
 
 				/*
@@ -2188,7 +2188,7 @@ static void max98090_jack_work(struct work_struct *work)
 			/* Line is reported as Headphone */
 			/* Nokia Headset is reported as Headphone */
 			/* Mono Headphone is reported as Headphone */
-			dev_dbg(codec->dev, "Headphone Detected\n");
+			dev_dbg(component->dev, "Headphone Detected\n");
 
 			max98090->jack_state = M98090_JACK_STATE_HEADPHONE;
 
@@ -2197,7 +2197,7 @@ static void max98090_jack_work(struct work_struct *work)
 			break;
 
 		case M98090_JKSNS_MASK:
-			dev_dbg(codec->dev, "Headset Detected\n");
+			dev_dbg(component->dev, "Headset Detected\n");
 
 			max98090->jack_state = M98090_JACK_STATE_HEADSET;
 
@@ -2206,7 +2206,7 @@ static void max98090_jack_work(struct work_struct *work)
 			break;
 
 		default:
-			dev_dbg(codec->dev, "Unrecognized Jack Status\n");
+			dev_dbg(component->dev, "Unrecognized Jack Status\n");
 			break;
 	}
 
@@ -2217,21 +2217,21 @@ static void max98090_jack_work(struct work_struct *work)
 static irqreturn_t max98090_interrupt(int irq, void *data)
 {
 	struct max98090_priv *max98090 = data;
-	struct snd_soc_codec *codec = max98090->codec;
+	struct snd_soc_component *component = max98090->component;
 	int ret;
 	unsigned int mask;
 	unsigned int active;
 
 	/* Treat interrupt before codec is initialized as spurious */
-	if (codec == NULL)
+	if (component == NULL)
 		return IRQ_NONE;
 
-	dev_dbg(codec->dev, "***** max98090_interrupt *****\n");
+	dev_dbg(component->dev, "***** max98090_interrupt *****\n");
 
 	ret = regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);
 
 	if (ret != 0) {
-		dev_err(codec->dev,
+		dev_err(component->dev,
 			"failed to read M98090_REG_INTERRUPT_S: %d\n",
 			ret);
 		return IRQ_NONE;
@@ -2240,13 +2240,13 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
 	ret = regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &active);
 
 	if (ret != 0) {
-		dev_err(codec->dev,
+		dev_err(component->dev,
 			"failed to read M98090_REG_DEVICE_STATUS: %d\n",
 			ret);
 		return IRQ_NONE;
 	}
 
-	dev_dbg(codec->dev, "active=0x%02x mask=0x%02x -> active=0x%02x\n",
+	dev_dbg(component->dev, "active=0x%02x mask=0x%02x -> active=0x%02x\n",
 		active, mask, active & mask);
 
 	active &= mask;
@@ -2255,20 +2255,20 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
 		return IRQ_NONE;
 
 	if (active & M98090_CLD_MASK)
-		dev_err(codec->dev, "M98090_CLD_MASK\n");
+		dev_err(component->dev, "M98090_CLD_MASK\n");
 
 	if (active & M98090_SLD_MASK)
-		dev_dbg(codec->dev, "M98090_SLD_MASK\n");
+		dev_dbg(component->dev, "M98090_SLD_MASK\n");
 
 	if (active & M98090_ULK_MASK) {
-		dev_dbg(codec->dev, "M98090_ULK_MASK\n");
+		dev_dbg(component->dev, "M98090_ULK_MASK\n");
 		schedule_work(&max98090->pll_work);
 	}
 
 	if (active & M98090_JDET_MASK) {
-		dev_dbg(codec->dev, "M98090_JDET_MASK\n");
+		dev_dbg(component->dev, "M98090_JDET_MASK\n");
 
-		pm_wakeup_event(codec->dev, 100);
+		pm_wakeup_event(component->dev, 100);
 
 		queue_delayed_work(system_power_efficient_wq,
 				   &max98090->jack_work,
@@ -2276,10 +2276,10 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
 	}
 
 	if (active & M98090_DRCACT_MASK)
-		dev_dbg(codec->dev, "M98090_DRCACT_MASK\n");
+		dev_dbg(component->dev, "M98090_DRCACT_MASK\n");
 
 	if (active & M98090_DRCCLP_MASK)
-		dev_err(codec->dev, "M98090_DRCCLP_MASK\n");
+		dev_err(component->dev, "M98090_DRCCLP_MASK\n");
 
 	return IRQ_HANDLED;
 }
@@ -2287,7 +2287,7 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
 /**
  * max98090_mic_detect - Enable microphone detection via the MAX98090 IRQ
  *
- * @codec:  MAX98090 codec
+ * @component:  MAX98090 component
  * @jack:   jack to report detection events on
  *
  * Enable microphone detection via IRQ on the MAX98090.  If GPIOs are
@@ -2297,20 +2297,20 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
  *
  * If no jack is supplied detection will be disabled.
  */
-int max98090_mic_detect(struct snd_soc_codec *codec,
+int max98090_mic_detect(struct snd_soc_component *component,
 	struct snd_soc_jack *jack)
 {
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 
-	dev_dbg(codec->dev, "max98090_mic_detect\n");
+	dev_dbg(component->dev, "max98090_mic_detect\n");
 
 	max98090->jack = jack;
 	if (jack) {
-		snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+		snd_soc_component_update_bits(component, M98090_REG_INTERRUPT_S,
 			M98090_IJDET_MASK,
 			1 << M98090_IJDET_SHIFT);
 	} else {
-		snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+		snd_soc_component_update_bits(component, M98090_REG_INTERRUPT_S,
 			M98090_IJDET_MASK,
 			0);
 	}
@@ -2360,22 +2360,22 @@ static struct snd_soc_dai_driver max98090_dai[] = {
 }
 };
 
-static int max98090_probe(struct snd_soc_codec *codec)
+static int max98090_probe(struct snd_soc_component *component)
 {
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 	struct max98090_cdata *cdata;
 	enum max98090_type devtype;
 	int ret = 0;
 	int err;
 	unsigned int micbias;
 
-	dev_dbg(codec->dev, "max98090_probe\n");
+	dev_dbg(component->dev, "max98090_probe\n");
 
-	max98090->mclk = devm_clk_get(codec->dev, "mclk");
+	max98090->mclk = devm_clk_get(component->dev, "mclk");
 	if (PTR_ERR(max98090->mclk) == -EPROBE_DEFER)
 		return -EPROBE_DEFER;
 
-	max98090->codec = codec;
+	max98090->component = component;
 
 	/* Reset the codec, the DSP core, and disable all interrupts */
 	max98090_reset(max98090);
@@ -2394,26 +2394,26 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	max98090->pa1en = 0;
 	max98090->pa2en = 0;
 
-	ret = snd_soc_read(codec, M98090_REG_REVISION_ID);
+	ret = snd_soc_component_read32(component, M98090_REG_REVISION_ID);
 	if (ret < 0) {
-		dev_err(codec->dev, "Failed to read device revision: %d\n",
+		dev_err(component->dev, "Failed to read device revision: %d\n",
 			ret);
 		goto err_access;
 	}
 
 	if ((ret >= M98090_REVA) && (ret <= M98090_REVA + 0x0f)) {
 		devtype = MAX98090;
-		dev_info(codec->dev, "MAX98090 REVID=0x%02x\n", ret);
+		dev_info(component->dev, "MAX98090 REVID=0x%02x\n", ret);
 	} else if ((ret >= M98091_REVA) && (ret <= M98091_REVA + 0x0f)) {
 		devtype = MAX98091;
-		dev_info(codec->dev, "MAX98091 REVID=0x%02x\n", ret);
+		dev_info(component->dev, "MAX98091 REVID=0x%02x\n", ret);
 	} else {
 		devtype = MAX98090;
-		dev_err(codec->dev, "Unrecognized revision 0x%02x\n", ret);
+		dev_err(component->dev, "Unrecognized revision 0x%02x\n", ret);
 	}
 
 	if (max98090->devtype != devtype) {
-		dev_warn(codec->dev, "Mismatch in DT specified CODEC type.\n");
+		dev_warn(component->dev, "Mismatch in DT specified CODEC type.\n");
 		max98090->devtype = devtype;
 	}
 
@@ -2427,7 +2427,7 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	INIT_WORK(&max98090->pll_work, max98090_pll_work);
 
 	/* Enable jack detection */
-	snd_soc_write(codec, M98090_REG_JACK_DETECT,
+	snd_soc_component_write(component, M98090_REG_JACK_DETECT,
 		M98090_JDETEN_MASK | M98090_JDEB_25MS);
 
 	/*
@@ -2435,75 +2435,76 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	 * An old interrupt ocurring prior to installing the ISR
 	 * can keep a new interrupt from generating a trigger.
 	 */
-	snd_soc_read(codec, M98090_REG_DEVICE_STATUS);
+	snd_soc_component_read32(component, M98090_REG_DEVICE_STATUS);
 
 	/* High Performance is default */
-	snd_soc_update_bits(codec, M98090_REG_DAC_CONTROL,
+	snd_soc_component_update_bits(component, M98090_REG_DAC_CONTROL,
 		M98090_DACHP_MASK,
 		1 << M98090_DACHP_SHIFT);
-	snd_soc_update_bits(codec, M98090_REG_DAC_CONTROL,
+	snd_soc_component_update_bits(component, M98090_REG_DAC_CONTROL,
 		M98090_PERFMODE_MASK,
 		0 << M98090_PERFMODE_SHIFT);
-	snd_soc_update_bits(codec, M98090_REG_ADC_CONTROL,
+	snd_soc_component_update_bits(component, M98090_REG_ADC_CONTROL,
 		M98090_ADCHP_MASK,
 		1 << M98090_ADCHP_SHIFT);
 
 	/* Turn on VCM bandgap reference */
-	snd_soc_write(codec, M98090_REG_BIAS_CONTROL,
+	snd_soc_component_write(component, M98090_REG_BIAS_CONTROL,
 		M98090_VCM_MODE_MASK);
 
-	err = device_property_read_u32(codec->dev, "maxim,micbias", &micbias);
+	err = device_property_read_u32(component->dev, "maxim,micbias", &micbias);
 	if (err) {
 		micbias = M98090_MBVSEL_2V8;
-		dev_info(codec->dev, "use default 2.8v micbias\n");
+		dev_info(component->dev, "use default 2.8v micbias\n");
 	} else if (micbias > M98090_MBVSEL_2V8) {
-		dev_err(codec->dev, "micbias out of range 0x%x\n", micbias);
+		dev_err(component->dev, "micbias out of range 0x%x\n", micbias);
 		micbias = M98090_MBVSEL_2V8;
 	}
 
-	snd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,
+	snd_soc_component_update_bits(component, M98090_REG_MIC_BIAS_VOLTAGE,
 		M98090_MBVSEL_MASK, micbias);
 
-	max98090_add_widgets(codec);
+	max98090_add_widgets(component);
 
 err_access:
 	return ret;
 }
 
-static int max98090_remove(struct snd_soc_codec *codec)
+static void max98090_remove(struct snd_soc_component *component)
 {
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 
 	cancel_delayed_work_sync(&max98090->jack_work);
 	cancel_delayed_work_sync(&max98090->pll_det_enable_work);
 	cancel_work_sync(&max98090->pll_det_disable_work);
 	cancel_work_sync(&max98090->pll_work);
-	max98090->codec = NULL;
-
-	return 0;
+	max98090->component = NULL;
 }
 
-static void max98090_seq_notifier(struct snd_soc_dapm_context *dapm,
+static void max98090_seq_notifier(struct snd_soc_component *component,
 	enum snd_soc_dapm_type event, int subseq)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(dapm);
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_priv *max98090 = snd_soc_component_get_drvdata(component);
 
 	if (max98090->shdn_pending) {
-		snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+		snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 				M98090_SHDNN_MASK, 0);
 		msleep(40);
-		snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+		snd_soc_component_update_bits(component, M98090_REG_DEVICE_SHUTDOWN,
 				M98090_SHDNN_MASK, M98090_SHDNN_MASK);
 		max98090->shdn_pending = false;
 	}
 }
 
-static const struct snd_soc_codec_driver soc_codec_dev_max98090 = {
-	.probe   = max98090_probe,
-	.remove  = max98090_remove,
-	.seq_notifier = max98090_seq_notifier,
-	.set_bias_level = max98090_set_bias_level,
+static const struct snd_soc_component_driver soc_component_dev_max98090 = {
+	.probe			= max98090_probe,
+	.remove			= max98090_remove,
+	.seq_notifier		= max98090_seq_notifier,
+	.set_bias_level		= max98090_set_bias_level,
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
 };
 
 static const struct regmap_config max98090_regmap = {
@@ -2570,8 +2571,8 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 		return ret;
 	}
 
-	ret = snd_soc_register_codec(&i2c->dev,
-			&soc_codec_dev_max98090, max98090_dai,
+	ret = devm_snd_soc_register_component(&i2c->dev,
+			&soc_component_dev_max98090, max98090_dai,
 			ARRAY_SIZE(max98090_dai));
 err_enable:
 	return ret;
@@ -2595,7 +2596,7 @@ static void max98090_i2c_shutdown(struct i2c_client *i2c)
 static int max98090_i2c_remove(struct i2c_client *client)
 {
 	max98090_i2c_shutdown(client);
-	snd_soc_unregister_codec(&client->dev);
+
 	return 0;
 }
 

commit d10a7d3e2af98e639e74c64185f910915a560f07
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Sep 8 00:13:03 2017 -0500

    ASoC: max98090: reduce verbosity on PLL unlock
    
    'commit b8a3ee820f7b ("ASoC: max98090: Add recovery for PLL lock failure")'
    enabled a workaround PLL unlocked issues, but generates annoying
    dev_info "PLL unlocked" messages at a 10ms rate, usually on startup.
    
    Move to dev_info_ratelimited. This issue doesn't seem to impact audio
    functionality.  This trace is commented out in the GalliumOS patches,
    it's better to keep it to check on potential quality issues
    
    Tested on Lenovo 100s (Baytrail Chromebook)
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Acked-By: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 13bcfb1ef9b4..f5075d1f79e6 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2115,7 +2115,7 @@ static void max98090_pll_work(struct work_struct *work)
 	if (!snd_soc_codec_is_active(codec))
 		return;
 
-	dev_info(codec->dev, "PLL unlocked\n");
+	dev_info_ratelimited(codec->dev, "PLL unlocked\n");
 
 	/* Toggle shutdown OFF then ON */
 	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,

commit a180ba45b1cf630b3bd5912ce235b2ee16606b8e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Thu Aug 3 21:30:19 2017 +0530

    ASoC: codecs: add const to snd_soc_codec_driver structures
    
    Declare snd_soc_codec_driver structures as const as they are only passed
    as an argument to the function snd_soc_register_codec. This argument is
    of type const, so declare the structures with this property as const.
    In file codecs/sn95031.c, snd_soc_codec_driver structure is also used in
    a copy operation along with getting passed to snd_soc_register_codec.
    So, it can be made const too.
    Done using Coccinelle:
    
    @match disable optional_qualifier@
    identifier s;
    position p;
    @@
    static struct snd_soc_codec_driver s@p={...};
    
    @good1@
    identifier match.s;
    position p;
    @@
    snd_soc_register_codec(...,&s@p,...)
    
    @bad@
    identifier match.s;
    position p!={match.p,good1.p};
    @@
    s@p
    
    @depends on !bad disable optional_qualifier@
    identifier match.s;
    @@
    static
    +const
    struct snd_soc_codec_driver s={...};
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 66828480d484..13bcfb1ef9b4 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2499,7 +2499,7 @@ static void max98090_seq_notifier(struct snd_soc_dapm_context *dapm,
 	}
 }
 
-static struct snd_soc_codec_driver soc_codec_dev_max98090 = {
+static const struct snd_soc_codec_driver soc_codec_dev_max98090 = {
 	.probe   = max98090_probe,
 	.remove  = max98090_remove,
 	.seq_notifier = max98090_seq_notifier,

commit 1c445a42c48754bb5f821478517ef1b9f861217a
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Dec 8 23:01:29 2016 +0530

    ASoC: max98090: remove superflous check for 'micbias'
    
    In max98090_probe(), code checks for micbias being out of range. The
    'micbias' variable in unsigned and checked against M98090_MBVSEL_2V2 which
    is zero, so remove this check.
    
    sound/soc/codecs/max98090.c: In function max98090_probe:
    sound/soc/codecs/max98090.c:2459:2: warning: comparison of unsigned expression < 0 is always false [-Wtype-limits]
      } else if (micbias < M98090_MBVSEL_2V2 || micbias > M98090_MBVSEL_2V8) {
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 584aab83e478..66828480d484 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2456,7 +2456,7 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	if (err) {
 		micbias = M98090_MBVSEL_2V8;
 		dev_info(codec->dev, "use default 2.8v micbias\n");
-	} else if (micbias < M98090_MBVSEL_2V2 || micbias > M98090_MBVSEL_2V8) {
+	} else if (micbias > M98090_MBVSEL_2V8) {
 		dev_err(codec->dev, "micbias out of range 0x%x\n", micbias);
 		micbias = M98090_MBVSEL_2V8;
 	}

commit 428157c1e8c9eaf0029430ae82ec0df8578de46b
Merge: 0a5ff077572d 82cf77a1bd61 9425e9d8c77d f57ddcdfa146 2e45a25f9cb6 1a3232d2f61d
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:57:34 2015 +0100

    Merge remote-tracking branches 'asoc/topic/tas2552', 'asoc/topic/tas5086', 'asoc/topic/tegra', 'asoc/topic/tlv' and 'asoc/topic/topology' into asoc-next

commit 1d1ed2c23e6fac1c9a11df846536553754ac9780
Merge: 373e515d6550 62d6d47cb8bd 5549ce82e29c 4ab0c591c148 623436af42ef 6eb1c2a63d04
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:54:57 2015 +0100

    Merge remote-tracking branches 'asoc/topic/max98090', 'asoc/topic/max98095', 'asoc/topic/max98357a', 'asoc/topic/max9877' and 'asoc/topic/max98925' into asoc-next

commit b18fec9fe42846784e1744e6bd6c754751e1d172
Merge: 48997b9c03a8 647930475587 c17633081a0d 80deaf09cb3f 4caae9546d2c
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:52:59 2015 +0100

    Merge remote-tracking branches 'asoc/topic/const', 'asoc/topic/cs35l32', 'asoc/topic/cs4265' and 'asoc/topic/cs42l52' into asoc-next

commit 28becbd59c89cccf26b7539684105437fa77210e
Merge: cb42e0f709a7 dbe71b9d86ee
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:52:16 2015 +0100

    Merge remote-tracking branch 'asoc/topic/ssm4567' into asoc-next

commit e5b94083d0996b4c69674c8a5563c2eb272557ba
Author: Fang, Yang A <yang.a.fang@intel.com>
Date:   Fri Aug 7 14:08:15 2015 -0700

    ASoC: max98090: Fix sequencing when starting additional routes
    
    Enforce correct device sequencing when configuring a new
    audio route when there is an existing active audio route(s).
    
    This patch fixed recording noise issue while playback is active.
    
    We have some registers which require the device to be in full shutdown
    or to enter full shutdown before the register settings will take effect.
    Currently the driver is not shutting down the device when a new audio
    route is created. If a new audio route is made active while there is
    already an active audio route, then the required register sequencing is
    violated. A hardware shutdown toggle when creating a new audio route
    corrects the sequencing error. The device must remain in hardware
    shutdown for 40ms to allow the internal hardware core to fully shutdown.
    
    Signed-off-by: Fang, Yang A <yang.a.fang@intel.com>
    Signed-off-by: Sathyanarayana Nujella <sathyanarayana.nujella@intel.com>
    Acked-by: Anish Kumar <anish.kumar@maximintegrated.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 78268f0514e9..2a4c2e12972a 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -850,6 +850,19 @@ static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 	return 0;
 }
 
+static int max98090_shdn_event(struct snd_soc_dapm_widget *w,
+				 struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	if (event & SND_SOC_DAPM_POST_PMU)
+		max98090->shdn_pending = true;
+
+	return 0;
+
+}
+
 static const char *mic1_mux_text[] = { "IN12", "IN56" };
 
 static SOC_ENUM_SINGLE_DECL(mic1_mux_enum,
@@ -1158,9 +1171,11 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 	SND_SOC_DAPM_SUPPLY("SDOEN", M98090_REG_IO_CONFIGURATION,
 		M98090_SDOEN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("DMICL_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMICL_SHIFT, 0, NULL, 0),
+		 M98090_DIGMICL_SHIFT, 0, max98090_shdn_event,
+			SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("DMICR_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMICR_SHIFT, 0, NULL, 0),
+		 M98090_DIGMICR_SHIFT, 0, max98090_shdn_event,
+			 SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("AHPF", M98090_REG_FILTER_CONFIG,
 		M98090_AHPF_SHIFT, 0, NULL, 0),
 
@@ -1205,10 +1220,12 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 		&max98090_right_adc_mixer_controls[0],
 		ARRAY_SIZE(max98090_right_adc_mixer_controls)),
 
-	SND_SOC_DAPM_ADC("ADCL", NULL, M98090_REG_INPUT_ENABLE,
-		M98090_ADLEN_SHIFT, 0),
-	SND_SOC_DAPM_ADC("ADCR", NULL, M98090_REG_INPUT_ENABLE,
-		M98090_ADREN_SHIFT, 0),
+	SND_SOC_DAPM_ADC_E("ADCL", NULL, M98090_REG_INPUT_ENABLE,
+		M98090_ADLEN_SHIFT, 0, max98090_shdn_event,
+		SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_ADC_E("ADCR", NULL, M98090_REG_INPUT_ENABLE,
+		M98090_ADREN_SHIFT, 0, max98090_shdn_event,
+		SND_SOC_DAPM_POST_PMU),
 
 	SND_SOC_DAPM_AIF_OUT("AIFOUTL", "HiFi Capture", 0,
 		SND_SOC_NOPM, 0, 0),
@@ -2536,9 +2553,26 @@ static int max98090_remove(struct snd_soc_codec *codec)
 	return 0;
 }
 
+static void max98090_seq_notifier(struct snd_soc_dapm_context *dapm,
+	enum snd_soc_dapm_type event, int subseq)
+{
+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(dapm);
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	if (max98090->shdn_pending) {
+		snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, 0);
+		msleep(40);
+		snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+		max98090->shdn_pending = false;
+	}
+}
+
 static struct snd_soc_codec_driver soc_codec_dev_max98090 = {
 	.probe   = max98090_probe,
 	.remove  = max98090_remove,
+	.seq_notifier = max98090_seq_notifier,
 	.set_bias_level = max98090_set_bias_level,
 };
 

commit 8896bc3e089b39d077c7afbf785166aac28e5151
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Aug 2 17:19:43 2015 +0200

    ASoC: max98090: Replace TLV_DB_RANGE_HEAD with DECLARE_TLV_DB_RANGE
    
    DECLARE_TLV_DB_RANGE() has the advantage over using TLV_DB_RANGE_HEAD()
    that it automatically calculates the number of items in the TLV and is
    hence less prone to manual error.
    
    Generate using the following coccinelle script
    
    // <smpl>
    @@
    declarer name DECLARE_TLV_DB_RANGE;
    identifier tlv;
    constant x;
    @@
    -unsigned int tlv[] = {
    -       TLV_DB_RANGE_HEAD(x),
    +DECLARE_TLV_DB_RANGE(tlv,
            ...
    -};
    +);
    // </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 78268f0514e9..cf8789fc769b 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -360,22 +360,20 @@ static int max98090_reset(struct max98090_priv *max98090)
 	return ret;
 }
 
-static const unsigned int max98090_micboost_tlv[] = {
-	TLV_DB_RANGE_HEAD(2),
+static const DECLARE_TLV_DB_RANGE(max98090_micboost_tlv,
 	0, 1, TLV_DB_SCALE_ITEM(0, 2000, 0),
-	2, 2, TLV_DB_SCALE_ITEM(3000, 0, 0),
-};
+	2, 2, TLV_DB_SCALE_ITEM(3000, 0, 0)
+);
 
 static const DECLARE_TLV_DB_SCALE(max98090_mic_tlv, 0, 100, 0);
 
 static const DECLARE_TLV_DB_SCALE(max98090_line_single_ended_tlv,
 	-600, 600, 0);
 
-static const unsigned int max98090_line_tlv[] = {
-	TLV_DB_RANGE_HEAD(2),
+static const DECLARE_TLV_DB_RANGE(max98090_line_tlv,
 	0, 3, TLV_DB_SCALE_ITEM(-600, 300, 0),
-	4, 5, TLV_DB_SCALE_ITEM(1400, 600, 0),
-};
+	4, 5, TLV_DB_SCALE_ITEM(1400, 600, 0)
+);
 
 static const DECLARE_TLV_DB_SCALE(max98090_avg_tlv, 0, 600, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_av_tlv, -1200, 100, 0);
@@ -391,38 +389,34 @@ static const DECLARE_TLV_DB_SCALE(max98090_alccomp_tlv, -3100, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_drcexp_tlv, -6600, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_sdg_tlv, 50, 200, 0);
 
-static const unsigned int max98090_mixout_tlv[] = {
-	TLV_DB_RANGE_HEAD(2),
+static const DECLARE_TLV_DB_RANGE(max98090_mixout_tlv,
 	0, 1, TLV_DB_SCALE_ITEM(-1200, 250, 0),
-	2, 3, TLV_DB_SCALE_ITEM(-600, 600, 0),
-};
+	2, 3, TLV_DB_SCALE_ITEM(-600, 600, 0)
+);
 
-static const unsigned int max98090_hp_tlv[] = {
-	TLV_DB_RANGE_HEAD(5),
+static const DECLARE_TLV_DB_RANGE(max98090_hp_tlv,
 	0, 6, TLV_DB_SCALE_ITEM(-6700, 400, 0),
 	7, 14, TLV_DB_SCALE_ITEM(-4000, 300, 0),
 	15, 21, TLV_DB_SCALE_ITEM(-1700, 200, 0),
 	22, 27, TLV_DB_SCALE_ITEM(-400, 100, 0),
-	28, 31, TLV_DB_SCALE_ITEM(150, 50, 0),
-};
+	28, 31, TLV_DB_SCALE_ITEM(150, 50, 0)
+);
 
-static const unsigned int max98090_spk_tlv[] = {
-	TLV_DB_RANGE_HEAD(5),
+static const DECLARE_TLV_DB_RANGE(max98090_spk_tlv,
 	0, 4, TLV_DB_SCALE_ITEM(-4800, 400, 0),
 	5, 10, TLV_DB_SCALE_ITEM(-2900, 300, 0),
 	11, 14, TLV_DB_SCALE_ITEM(-1200, 200, 0),
 	15, 29, TLV_DB_SCALE_ITEM(-500, 100, 0),
-	30, 39, TLV_DB_SCALE_ITEM(950, 50, 0),
-};
+	30, 39, TLV_DB_SCALE_ITEM(950, 50, 0)
+);
 
-static const unsigned int max98090_rcv_lout_tlv[] = {
-	TLV_DB_RANGE_HEAD(5),
+static const DECLARE_TLV_DB_RANGE(max98090_rcv_lout_tlv,
 	0, 6, TLV_DB_SCALE_ITEM(-6200, 400, 0),
 	7, 14, TLV_DB_SCALE_ITEM(-3500, 300, 0),
 	15, 21, TLV_DB_SCALE_ITEM(-1200, 200, 0),
 	22, 27, TLV_DB_SCALE_ITEM(100, 100, 0),
-	28, 31, TLV_DB_SCALE_ITEM(650, 50, 0),
-};
+	28, 31, TLV_DB_SCALE_ITEM(650, 50, 0)
+);
 
 static int max98090_get_enab_tlv(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)

commit 62d6d47cb8bd5ace08a90a1cd78f6908e9f9c2d3
Author: Axel Lin <axel.lin@ingics.com>
Date:   Mon Jul 27 09:39:43 2015 +0800

    ASoC: max98090: Simplify max98090_readable_register implementation
    
    The readable registers are in consecutive ranges:
            0x01 ~ 0x03, 0x0D ~ 0xD1, 0xFF
    So simplify the implementation by specifying a range of consecutive values
    in a single case label.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 1697340c3842..17ab597a4b51 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -267,75 +267,8 @@ static bool max98090_volatile_register(struct device *dev, unsigned int reg)
 static bool max98090_readable_register(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
-	case M98090_REG_DEVICE_STATUS:
-	case M98090_REG_JACK_STATUS:
-	case M98090_REG_INTERRUPT_S:
-	case M98090_REG_RESERVED:
-	case M98090_REG_LINE_INPUT_CONFIG:
-	case M98090_REG_LINE_INPUT_LEVEL:
-	case M98090_REG_INPUT_MODE:
-	case M98090_REG_MIC1_INPUT_LEVEL:
-	case M98090_REG_MIC2_INPUT_LEVEL:
-	case M98090_REG_MIC_BIAS_VOLTAGE:
-	case M98090_REG_DIGITAL_MIC_ENABLE:
-	case M98090_REG_DIGITAL_MIC_CONFIG:
-	case M98090_REG_LEFT_ADC_MIXER:
-	case M98090_REG_RIGHT_ADC_MIXER:
-	case M98090_REG_LEFT_ADC_LEVEL:
-	case M98090_REG_RIGHT_ADC_LEVEL:
-	case M98090_REG_ADC_BIQUAD_LEVEL:
-	case M98090_REG_ADC_SIDETONE:
-	case M98090_REG_SYSTEM_CLOCK:
-	case M98090_REG_CLOCK_MODE:
-	case M98090_REG_CLOCK_RATIO_NI_MSB:
-	case M98090_REG_CLOCK_RATIO_NI_LSB:
-	case M98090_REG_CLOCK_RATIO_MI_MSB:
-	case M98090_REG_CLOCK_RATIO_MI_LSB:
-	case M98090_REG_MASTER_MODE:
-	case M98090_REG_INTERFACE_FORMAT:
-	case M98090_REG_TDM_CONTROL:
-	case M98090_REG_TDM_FORMAT:
-	case M98090_REG_IO_CONFIGURATION:
-	case M98090_REG_FILTER_CONFIG:
-	case M98090_REG_DAI_PLAYBACK_LEVEL:
-	case M98090_REG_DAI_PLAYBACK_LEVEL_EQ:
-	case M98090_REG_LEFT_HP_MIXER:
-	case M98090_REG_RIGHT_HP_MIXER:
-	case M98090_REG_HP_CONTROL:
-	case M98090_REG_LEFT_HP_VOLUME:
-	case M98090_REG_RIGHT_HP_VOLUME:
-	case M98090_REG_LEFT_SPK_MIXER:
-	case M98090_REG_RIGHT_SPK_MIXER:
-	case M98090_REG_SPK_CONTROL:
-	case M98090_REG_LEFT_SPK_VOLUME:
-	case M98090_REG_RIGHT_SPK_VOLUME:
-	case M98090_REG_DRC_TIMING:
-	case M98090_REG_DRC_COMPRESSOR:
-	case M98090_REG_DRC_EXPANDER:
-	case M98090_REG_DRC_GAIN:
-	case M98090_REG_RCV_LOUTL_MIXER:
-	case M98090_REG_RCV_LOUTL_CONTROL:
-	case M98090_REG_RCV_LOUTL_VOLUME:
-	case M98090_REG_LOUTR_MIXER:
-	case M98090_REG_LOUTR_CONTROL:
-	case M98090_REG_LOUTR_VOLUME:
-	case M98090_REG_JACK_DETECT:
-	case M98090_REG_INPUT_ENABLE:
-	case M98090_REG_OUTPUT_ENABLE:
-	case M98090_REG_LEVEL_CONTROL:
-	case M98090_REG_DSP_FILTER_ENABLE:
-	case M98090_REG_BIAS_CONTROL:
-	case M98090_REG_DAC_CONTROL:
-	case M98090_REG_ADC_CONTROL:
-	case M98090_REG_DEVICE_SHUTDOWN:
-	case M98090_REG_EQUALIZER_BASE ... M98090_REG_EQUALIZER_BASE + 0x68:
-	case M98090_REG_RECORD_BIQUAD_BASE ... M98090_REG_RECORD_BIQUAD_BASE + 0x0E:
-	case M98090_REG_DMIC3_VOLUME:
-	case M98090_REG_DMIC4_VOLUME:
-	case M98090_REG_DMIC34_BQ_PREATTEN:
-	case M98090_REG_RECORD_TDM_SLOT:
-	case M98090_REG_SAMPLE_RATE:
-	case M98090_REG_DMIC34_BIQUAD_BASE ... M98090_REG_DMIC34_BIQUAD_BASE + 0x0E:
+	case M98090_REG_DEVICE_STATUS ... M98090_REG_INTERRUPT_S:
+	case M98090_REG_LINE_INPUT_CONFIG ... 0xD1:
 	case M98090_REG_REVISION_ID:
 		return true;
 	default:

commit 1c07a4de5baad76585f7ffb86b5b0bc34c33e8a6
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Wed Jul 15 13:21:44 2015 +0900

    ASoC: drivers: Drop owner assignment from i2c_driver
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 78268f0514e9..c9db085e6cf1 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2714,7 +2714,6 @@ MODULE_DEVICE_TABLE(acpi, max98090_acpi_match);
 static struct i2c_driver max98090_i2c_driver = {
 	.driver = {
 		.name = "max98090",
-		.owner = THIS_MODULE,
 		.pm = &max98090_pm,
 		.of_match_table = of_match_ptr(max98090_of_match),
 		.acpi_match_table = ACPI_PTR(max98090_acpi_match),

commit 64793047558781330a1d13b159a2bc9385bdf97f
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Jul 15 15:38:14 2015 +0800

    ASoC: Constify snd_soc_dai_ops variables
    
    The snd_soc_dai_ops variables are not modified after initialization in
    these drivers, so make them const.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 78268f0514e9..b1b436f05ebe 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2383,7 +2383,7 @@ EXPORT_SYMBOL_GPL(max98090_mic_detect);
 #define MAX98090_RATES SNDRV_PCM_RATE_8000_96000
 #define MAX98090_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
 
-static struct snd_soc_dai_ops max98090_dai_ops = {
+static const struct snd_soc_dai_ops max98090_dai_ops = {
 	.set_sysclk = max98090_dai_set_sysclk,
 	.set_fmt = max98090_dai_set_fmt,
 	.set_tdm_slot = max98090_set_tdm_slot,

commit 9acc7f08716b98730e1ead7e785fb0f3ad3a2d07
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sat Jun 20 15:55:50 2015 -0300

    ASoC: max98090: Check for clk_prepare_enable() error
    
    clk_prepare_enable() may fail, so we should better check its return value
    and propagate it in the case of error.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 78268f0514e9..1697340c3842 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1801,10 +1801,13 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 		if (IS_ERR(max98090->mclk))
 			break;
 
-		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_ON)
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_ON) {
 			clk_disable_unprepare(max98090->mclk);
-		else
-			clk_prepare_enable(max98090->mclk);
+		} else {
+			ret = clk_prepare_enable(max98090->mclk);
+			if (ret)
+				return ret;
+		}
 		break;
 
 	case SND_SOC_BIAS_STANDBY:

commit dacdd369113cb7ba91b8e70b09456ca6cdcc2184
Merge: 1cdf4f6113d2 e85dae7048dc 8610d09a40c1
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jun 22 10:24:30 2015 +0100

    Merge remote-tracking branches 'asoc/topic/intel' and 'asoc/topic/max98090' into asoc-next

commit 8610d09a40c10dea55dada151cf85cce253f511c
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sat Jun 13 14:25:13 2015 +0200

    ASoC: max98090: Constify ACPI device ids and register defaults
    
    Constify the ACPI device ID array and the register map, no need to have
    them writable at runtime.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 9d80c68abdd5..f7b3577ada85 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -27,7 +27,7 @@
 #include "max98090.h"
 
 /* Allows for sparsely populated register maps */
-static struct reg_default max98090_reg[] = {
+static const struct reg_default max98090_reg[] = {
 	{ 0x00, 0x00 }, /* 00 Software Reset */
 	{ 0x03, 0x04 }, /* 03 Interrupt Masks */
 	{ 0x04, 0x00 }, /* 04 System Clock Quick */
@@ -2707,7 +2707,7 @@ static const struct of_device_id max98090_of_match[] = {
 MODULE_DEVICE_TABLE(of, max98090_of_match);
 
 #ifdef CONFIG_ACPI
-static struct acpi_device_id max98090_acpi_match[] = {
+static const struct acpi_device_id max98090_acpi_match[] = {
 	{ "193C9890", MAX98090 },
 	{ }
 };

commit f36795a60d8231b25e969f74c951294ccff52816
Merge: eb2d8ec37fad 0a8ba6eeb650 40579e0b8858 859c34bd3cab 08a1e646bdc1 bb13f0e08d16
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jun 5 18:54:55 2015 +0100

    Merge remote-tracking branches 'asoc/topic/gpiod-flags', 'asoc/topic/gtm601', 'asoc/topic/intel', 'asoc/topic/lm3857' and 'asoc/topic/max98090' into asoc-next

commit bb13f0e08d16a6a303aab786b2aaf2ca76747cfb
Author: Fang, Yang A <yang.a.fang@intel.com>
Date:   Fri May 29 11:56:10 2015 -0700

    ASoC: max98090: read micbias from device property
    
    This patch reads max98090 micbias from acpi or dt
    
    Signed-off-by: Fang, Yang A <yang.a.fang@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 3e33ef2acf3c..9d80c68abdd5 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2422,6 +2422,8 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	struct max98090_cdata *cdata;
 	enum max98090_type devtype;
 	int ret = 0;
+	int err;
+	unsigned int micbias;
 
 	dev_dbg(codec->dev, "max98090_probe\n");
 
@@ -2506,8 +2508,17 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	snd_soc_write(codec, M98090_REG_BIAS_CONTROL,
 		M98090_VCM_MODE_MASK);
 
+	err = device_property_read_u32(codec->dev, "maxim,micbias", &micbias);
+	if (err) {
+		micbias = M98090_MBVSEL_2V8;
+		dev_info(codec->dev, "use default 2.8v micbias\n");
+	} else if (micbias < M98090_MBVSEL_2V2 || micbias > M98090_MBVSEL_2V8) {
+		dev_err(codec->dev, "micbias out of range 0x%x\n", micbias);
+		micbias = M98090_MBVSEL_2V8;
+	}
+
 	snd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,
-		M98090_MBVSEL_MASK, M98090_MBVSEL_2V8);
+		M98090_MBVSEL_MASK, micbias);
 
 	max98090_add_widgets(codec);
 

commit 29ca43bc548e1b0060c8426b98a2ce9601cd5a17
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu May 14 11:20:01 2015 +0200

    ASoC: max98090: Replace direct snd_soc_codec dapm field access
    
    The dapm field of the snd_soc_codec struct is eventually going to be
    removed, in preparation for this replace all manual access to
    codec->dapm.bias_level with snd_soc_codec_get_bias_level() and all other
    manual access to codec->dapm with snd_soc_codec_get_dapm().
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 5a0bd8a0c9e9..c2306268cab8 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1500,7 +1500,7 @@ static const struct snd_soc_dapm_route max98091_dapm_routes[] = {
 static int max98090_add_widgets(struct snd_soc_codec *codec)
 {
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
 
 	snd_soc_add_codec_controls(codec, max98090_snd_controls,
 		ARRAY_SIZE(max98090_snd_controls));
@@ -1798,16 +1798,17 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 		 * away from ON. Disable the clock in that case, otherwise
 		 * enable it.
 		 */
-		if (!IS_ERR(max98090->mclk)) {
-			if (codec->dapm.bias_level == SND_SOC_BIAS_ON)
-				clk_disable_unprepare(max98090->mclk);
-			else
-				clk_prepare_enable(max98090->mclk);
-		}
+		if (IS_ERR(max98090->mclk))
+			break;
+
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_ON)
+			clk_disable_unprepare(max98090->mclk);
+		else
+			clk_prepare_enable(max98090->mclk);
 		break;
 
 	case SND_SOC_BIAS_STANDBY:
-		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {
 			ret = regcache_sync(max98090->regmap);
 			if (ret != 0) {
 				dev_err(codec->dev,

commit b0b80c8075add488ca2632393670da31b174195d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu May 14 11:20:00 2015 +0200

    ASoC: max98090: Remove unnecessary snd_soc_dapm_sync()
    
    max98090_jack_work() doesn't modify the DAPM graph other than what's done
    in snd_soc_jack_report(). snd_soc_jack_report() already calls
    snd_soc_dapm_sync() internally, so there is no need to call it manually
    and can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index c5736b2f7c76..5a0bd8a0c9e9 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2186,7 +2186,6 @@ static void max98090_jack_work(struct work_struct *work)
 		struct max98090_priv,
 		jack_work.work);
 	struct snd_soc_codec *codec = max98090->codec;
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	int status = 0;
 	int reg;
 
@@ -2265,8 +2264,6 @@ static void max98090_jack_work(struct work_struct *work)
 
 	snd_soc_jack_report(max98090->jack, status,
 			    SND_JACK_HEADSET | SND_JACK_BTN_0);
-
-	snd_soc_dapm_sync(dapm);
 }
 
 static irqreturn_t max98090_interrupt(int irq, void *data)

commit f4bf8d770b58862c2af9d17adc2fee05bef8f2c0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 27 22:13:25 2015 +0200

    ASoC: Move bias level update to the core
    
    All drivers have the same line at the end of the set_bias_level callback to
    update the bias_level state. Move this update into
    snd_soc_dapm_force_bias_level() and remove them from the drivers.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 3e33ef2acf3c..c5736b2f7c76 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1824,7 +1824,6 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 		regcache_mark_dirty(max98090->regmap);
 		break;
 	}
-	codec->dapm.bias_level = level;
 	return 0;
 }
 

commit c6b424fee7511407107403d3a7c50e0756ae282e
Author: Caesar Wang <wxt@rock-chips.com>
Date:   Wed Apr 8 19:05:56 2015 +0800

    ASoC: max98090: add shutdown callback for max98090
    
    To fix pop noise when shutdown,the pop noise during shutdown
    is the pmic cutoff power of codec without any notice.
    
    Signed-off-by: jay.xu <xjq@rock-chips.com>
    Signed-off-by: zhengxing <zhengxing@rock-chips.com>
    Signed-off-by: Caesar Wang <wxt@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index b112b1c2c394..3e33ef2acf3c 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2605,8 +2605,24 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 	return ret;
 }
 
+static void max98090_i2c_shutdown(struct i2c_client *i2c)
+{
+	struct max98090_priv *max98090 = dev_get_drvdata(&i2c->dev);
+
+	/*
+	 * Enable volume smoothing, disable zero cross.  This will cause
+	 * a quick 40ms ramp to mute on shutdown.
+	 */
+	regmap_write(max98090->regmap,
+		M98090_REG_LEVEL_CONTROL, M98090_VSENN_MASK);
+	regmap_write(max98090->regmap,
+		M98090_REG_DEVICE_SHUTDOWN, 0x00);
+	msleep(40);
+}
+
 static int max98090_i2c_remove(struct i2c_client *client)
 {
+	max98090_i2c_shutdown(client);
 	snd_soc_unregister_codec(&client->dev);
 	return 0;
 }
@@ -2696,6 +2712,7 @@ static struct i2c_driver max98090_i2c_driver = {
 		.acpi_match_table = ACPI_PTR(max98090_acpi_match),
 	},
 	.probe  = max98090_i2c_probe,
+	.shutdown = max98090_i2c_shutdown,
 	.remove = max98090_i2c_remove,
 	.id_table = max98090_i2c_id,
 };

commit c0f486fde3f353232c1cc2fd4d62783ac782a467
Merge: 385336e321c4 2ec1c17cadd0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 18 20:28:33 2014 -0800

    Merge tag 'pm+acpi-3.19-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI and power management updates from Rafael Wysocki:
     "These are regression fixes (leds-gpio, ACPI backlight driver,
      operating performance points library, ACPI device enumeration
      messages, cpupower tool), other bug fixes (ACPI EC driver, ACPI device
      PM), some cleanups in the operating performance points (OPP)
      framework, continuation of CONFIG_PM_RUNTIME elimination, a couple of
      minor intel_pstate driver changes, a new MAINTAINERS entry for it and
      an ACPI fan driver change needed for better support of thermal
      management in user space.
    
      Specifics:
    
       - Fix a regression in leds-gpio introduced by a recent commit that
         inadvertently changed the name of one of the properties used by the
         driver (Fabio Estevam).
    
       - Fix a regression in the ACPI backlight driver introduced by a
         recent fix that missed one special case that had to be taken into
         account (Aaron Lu).
    
       - Drop the level of some new kernel messages from the ACPI core
         introduced by a recent commit to KERN_DEBUG which they should have
         used from the start and drop some other unuseful KERN_ERR messages
         printed by ACPI (Rafael J Wysocki).
    
       - Revert an incorrect commit modifying the cpupower tool (Prarit
         Bhargava).
    
       - Fix two regressions introduced by recent commits in the OPP library
         and clean up some existing minor issues in that code (Viresh
         Kumar).
    
       - Continue to replace CONFIG_PM_RUNTIME with CONFIG_PM throughout the
         tree (or drop it where that can be done) in order to make it
         possible to eliminate CONFIG_PM_RUNTIME (Rafael J Wysocki, Ulf
         Hansson, Ludovic Desroches).
    
         There will be one more "CONFIG_PM_RUNTIME removal" batch after this
         one, because some new uses of it have been introduced during the
         current merge window, but that should be sufficient to finally get
         rid of it.
    
       - Make the ACPI EC driver more robust against race conditions related
         to GPE handler installation failures (Lv Zheng).
    
       - Prevent the ACPI device PM core code from attempting to disable
         GPEs that it has not enabled which confuses ACPICA and makes it
         report errors unnecessarily (Rafael J Wysocki).
    
       - Add a "force" command line switch to the intel_pstate driver to
         make it possible to override the blacklisting of some systems in
         that driver if needed (Ethan Zhao).
    
       - Improve intel_pstate code documentation and add a MAINTAINERS entry
         for it (Kristen Carlson Accardi).
    
       - Make the ACPI fan driver create cooling device interfaces witn
         names that reflect the IDs of the ACPI device objects they are
         associated with, except for "generic" ACPI fans (PNP ID "PNP0C0B").
    
         That's necessary for user space thermal management tools to be able
         to connect the fans with the parts of the system they are supposed
         to be cooling properly.  From Srinivas Pandruvada"
    
    * tag 'pm+acpi-3.19-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (32 commits)
      MAINTAINERS: add entry for intel_pstate
      ACPI / video: update the skip case for acpi_video_device_in_dod()
      power / PM: Eliminate CONFIG_PM_RUNTIME
      NFC / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      SCSI / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      ACPI / EC: Fix unexpected ec_remove_handlers() invocations
      Revert "tools: cpupower: fix return checks for sysfs_get_idlestate_count()"
      tracing / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      x86 / PM: Replace CONFIG_PM_RUNTIME in io_apic.c
      PM: Remove the SET_PM_RUNTIME_PM_OPS() macro
      mmc: atmel-mci: use SET_RUNTIME_PM_OPS() macro
      PM / Kconfig: Replace PM_RUNTIME with PM in dependencies
      ARM / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      sound / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      phy / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      video / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      tty / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      spi: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      ACPI / PM: Do not disable wakeup GPEs that have not been enabled
      ACPI / utils: Drop error messages from acpi_evaluate_reference()
      ...

commit 641d334b29429f1d191b4bb4295f7a259b1660cc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Dec 13 00:42:18 2014 +0100

    sound / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so #ifdef blocks
    depending on CONFIG_PM_RUNTIME may now be changed to depend on
    CONFIG_PM.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM everywhere under sound/.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Nicolin Chen <nicoleotsuka@gmail.com>
    Acked-by: Brian Austin <brian.austin@cirrus.com>
    Acked-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 1229554f1464..88a65da3c53c 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2492,7 +2492,7 @@ static int max98090_i2c_remove(struct i2c_client *client)
 	return 0;
 }
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 static int max98090_runtime_resume(struct device *dev)
 {
 	struct max98090_priv *max98090 = dev_get_drvdata(dev);

commit 41967b775e14a123131a842edd46f284e3642816
Merge: addaeea9ee19 0b5155bbca8b 24445f8c5eae 0db5dc943e76 46804120c59b 1679b532870f
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 8 13:12:02 2014 +0000

    Merge remote-tracking branches 'asoc/topic/max98088', 'asoc/topic/max98090', 'asoc/topic/max98095', 'asoc/topic/max9850' and 'asoc/topic/mop500' into asoc-next

commit 418382f29d99f1faffdd6636f378da41b44815db
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Nov 24 15:32:37 2014 +0200

    ASoC: max98090: Fix right sidetone connection
    
    It is right not left sidetone which goes to "DACR".
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 20b50e46a9e8..34ed9a91f392 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1398,7 +1398,7 @@ static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
 	{"STENR Mux", "Sidetone Right", "ADCR"},
 	{"STENR Mux", "Sidetone Right", "DMICR"},
 	{"DACL", NULL, "STENL Mux"},
-	{"DACR", NULL, "STENL Mux"},
+	{"DACR", NULL, "STENR Mux"},
 
 	{"AIFINL", NULL, "SHDN"},
 	{"AIFINR", NULL, "SHDN"},

commit 48826ee590da03e9882922edf96d8d27bdfe9552
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Nov 24 15:32:36 2014 +0200

    ASoC: max98090: Fix ill-defined sidetone route
    
    Commit 5fe5b767dc6f ("ASoC: dapm: Do not pretend to support controls for non
    mixer/mux widgets") revealed ill-defined control in a route between
    "STENL Mux" and DACs in max98090.c:
    
    max98090 i2c-193C9890:00: Control not supported for path STENL Mux -> [NULL] -> DACL
    max98090 i2c-193C9890:00: ASoC: no dapm match for STENL Mux --> NULL --> DACL
    max98090 i2c-193C9890:00: ASoC: Failed to add route STENL Mux -> NULL -> DACL
    max98090 i2c-193C9890:00: Control not supported for path STENL Mux -> [NULL] -> DACR
    max98090 i2c-193C9890:00: ASoC: no dapm match for STENL Mux --> NULL --> DACR
    max98090 i2c-193C9890:00: ASoC: Failed to add route STENL Mux -> NULL -> DACR
    
    Since there is no control between "STENL Mux" and DACs the control name must
    be NULL not "NULL".
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 994d02c1fb69..20b50e46a9e8 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1397,8 +1397,8 @@ static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
 	{"STENL Mux", "Sidetone Left", "DMICL"},
 	{"STENR Mux", "Sidetone Right", "ADCR"},
 	{"STENR Mux", "Sidetone Right", "DMICR"},
-	{"DACL", "NULL", "STENL Mux"},
-	{"DACR", "NULL", "STENL Mux"},
+	{"DACL", NULL, "STENL Mux"},
+	{"DACR", NULL, "STENL Mux"},
 
 	{"AIFINL", NULL, "SHDN"},
 	{"AIFINR", NULL, "SHDN"},

commit 4cf703a7bca4c29d06028821db60f253390a84a7
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Nov 24 15:32:35 2014 +0200

    ASoC: max98090: Fix digital microphone
    
    Commit e409dfbfccf9 ("ASoC: dapm: Add a few supply widget sanity checks")
    broke digital microphone support in max98090.c:
    
    max98090 i2c-193C9890:00: Conditional paths are not supported for supply widgets (DMICL_ENA -> [DMIC] -> DMIC Mux)
    max98090 i2c-193C9890:00: ASoC: no dapm match for DMICL_ENA --> DMIC --> DMIC Mux
    max98090 i2c-193C9890:00: ASoC: Failed to add route DMICL_ENA -> DMIC -> DMIC Mux
    max98090 i2c-193C9890:00: Conditional paths are not supported for supply widgets (DMICR_ENA -> [DMIC] -> DMIC Mux)
    max98090 i2c-193C9890:00: ASoC: no dapm match for DMICR_ENA --> DMIC --> DMIC Mux
    max98090 i2c-193C9890:00: ASoC: Failed to add route DMICR_ENA -> DMIC -> DMIC Mux
    
    Problem is partially caused by commit f69e3caa9e18 ("ASoC: max98090: Enable
    both DMIC channels also when using mono configuration") which connects
    "DMICL_ENA" and "DMICR_ENA" supply widgets to "DMIC Mux".
    
    Fix the breakage by reverting f69e3caa9e18 and then by adding additional
    "DMICR_ENA" to "DMICL" and "DMICL_ENA" to "DMICR" cross-connections. This
    disconnects these supply widgets from the mux and makes sure that both DMIC
    data channels are still enabled together.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 1229554f1464..994d02c1fb69 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1311,6 +1311,10 @@ static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
 	{"MIC1 Input", NULL, "MIC1"},
 	{"MIC2 Input", NULL, "MIC2"},
 
+	{"DMICL", NULL, "DMICL_ENA"},
+	{"DMICL", NULL, "DMICR_ENA"},
+	{"DMICR", NULL, "DMICL_ENA"},
+	{"DMICR", NULL, "DMICR_ENA"},
 	{"DMICL", NULL, "AHPF"},
 	{"DMICR", NULL, "AHPF"},
 
@@ -1368,8 +1372,6 @@ static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
 	{"DMIC Mux", "ADC", "ADCR"},
 	{"DMIC Mux", "DMIC", "DMICL"},
 	{"DMIC Mux", "DMIC", "DMICR"},
-	{"DMIC Mux", "DMIC", "DMICL_ENA"},
-	{"DMIC Mux", "DMIC", "DMICR_ENA"},
 
 	{"LBENL Mux", "Normal", "DMIC Mux"},
 	{"LBENL Mux", "Loopback", "LTENL Mux"},

commit 24445f8c5eae926e402335bbe0292f09b1deb7a7
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Nov 20 21:21:54 2014 +0100

    ASoC: max98090: Replace w->codec snd_soc_dapm_to_codec(w->dapm)
    
    The codec field of the snd_soc_widget struct is eventually going to be
    removed, use snd_soc_dapm_to_codec(w->dapm) instead.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index a65861cf0a44..2ad381c4ec57 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -806,7 +806,7 @@ static const struct snd_kcontrol_new max98091_snd_controls[] = {
 static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 				 struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = w->codec;
+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 
 	unsigned int val = snd_soc_read(codec, w->reg);

commit defcd98b16461e123cb4a6cb6ef24a1d0085c1b2
Author: Dylan Reid <dgreid@chromium.org>
Date:   Mon Nov 3 10:28:57 2014 -0800

    ASoC: max98090: Different comp tables for different pclks
    
    In addtion expand the table to handle other values of sysclk.  Instead
    of making the table 3D, expand it to a more descriptive struct.  The
    divisors are specified in Table 19 of the 98090 data sheet version
    0p94.
    
    The dmic frequency was previously assumed.  Instead make it explicit
    and configurable through device tree.  This now handles independently
    set pclk and dmic frequency.
    
    Based on downstream work by Ralph Birt.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 1229554f1464..a65861cf0a44 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1826,27 +1826,155 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 	return 0;
 }
 
-static const int comp_pclk_rates[] = {
-	11289600, 12288000, 12000000, 13000000, 19200000
-};
-
-static const int dmic_micclk[] = {
-	2, 2, 2, 2, 4, 2
-};
+static const int dmic_divisors[] = { 2, 3, 4, 5, 6, 8 };
 
 static const int comp_lrclk_rates[] = {
 	8000, 16000, 32000, 44100, 48000, 96000
 };
 
-static const int dmic_comp[6][6] = {
-	{7, 8, 3, 3, 3, 3},
-	{7, 8, 3, 3, 3, 3},
-	{7, 8, 3, 3, 3, 3},
-	{7, 8, 3, 1, 1, 1},
-	{7, 8, 3, 1, 2, 2},
-	{7, 8, 3, 3, 3, 3}
+struct dmic_table {
+	int pclk;
+	struct {
+		int freq;
+		int comp[6]; /* One each for 8, 16, 32, 44.1, 48, and 96 kHz */
+	} settings[6]; /* One for each dmic divisor. */
 };
 
+static const struct dmic_table dmic_table[] = { /* One for each pclk freq. */
+	{
+		.pclk = 11289600,
+		.settings = {
+			{ .freq = 2, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ .freq = 1, .comp = { 7, 8, 2, 2, 2, 2 } },
+			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ .freq = 0, .comp = { 7, 8, 6, 6, 6, 6 } },
+			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+		},
+	},
+	{
+		.pclk = 12000000,
+		.settings = {
+			{ .freq = 2, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ .freq = 1, .comp = { 7, 8, 2, 2, 2, 2 } },
+			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ .freq = 0, .comp = { 7, 8, 5, 5, 6, 6 } },
+			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+		}
+	},
+	{
+		.pclk = 12288000,
+		.settings = {
+			{ .freq = 2, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ .freq = 1, .comp = { 7, 8, 2, 2, 2, 2 } },
+			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ .freq = 0, .comp = { 7, 8, 6, 6, 6, 6 } },
+			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+		}
+	},
+	{
+		.pclk = 13000000,
+		.settings = {
+			{ .freq = 2, .comp = { 7, 8, 1, 1, 1, 1 } },
+			{ .freq = 1, .comp = { 7, 8, 0, 0, 0, 0 } },
+			{ .freq = 0, .comp = { 7, 8, 1, 1, 1, 1 } },
+			{ .freq = 0, .comp = { 7, 8, 4, 4, 5, 5 } },
+			{ .freq = 0, .comp = { 7, 8, 1, 1, 1, 1 } },
+			{ .freq = 0, .comp = { 7, 8, 1, 1, 1, 1 } },
+		}
+	},
+	{
+		.pclk = 19200000,
+		.settings = {
+			{ .freq = 2, .comp = { 0, 0, 0, 0, 0, 0 } },
+			{ .freq = 1, .comp = { 7, 8, 1, 1, 1, 1 } },
+			{ .freq = 0, .comp = { 7, 8, 5, 5, 6, 6 } },
+			{ .freq = 0, .comp = { 7, 8, 2, 2, 3, 3 } },
+			{ .freq = 0, .comp = { 7, 8, 1, 1, 2, 2 } },
+			{ .freq = 0, .comp = { 7, 8, 5, 5, 6, 6 } },
+		}
+	},
+};
+
+static int max98090_find_divisor(int target_freq, int pclk)
+{
+	int current_diff = INT_MAX;
+	int test_diff = INT_MAX;
+	int divisor_index = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dmic_divisors); i++) {
+		test_diff = abs(target_freq - (pclk / dmic_divisors[i]));
+		if (test_diff < current_diff) {
+			current_diff = test_diff;
+			divisor_index = i;
+		}
+	}
+
+	return divisor_index;
+}
+
+static int max98090_find_closest_pclk(int pclk)
+{
+	int m1;
+	int m2;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dmic_table); i++) {
+		if (pclk == dmic_table[i].pclk)
+			return i;
+		if (pclk < dmic_table[i].pclk) {
+			if (i == 0)
+				return i;
+			m1 = pclk - dmic_table[i-1].pclk;
+			m2 = dmic_table[i].pclk - pclk;
+			if (m1 < m2)
+				return i - 1;
+			else
+				return i;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static int max98090_configure_dmic(struct max98090_priv *max98090,
+				   int target_dmic_clk, int pclk, int fs)
+{
+	int micclk_index;
+	int pclk_index;
+	int dmic_freq;
+	int dmic_comp;
+	int i;
+
+	pclk_index = max98090_find_closest_pclk(pclk);
+	if (pclk_index < 0)
+		return pclk_index;
+
+	micclk_index = max98090_find_divisor(target_dmic_clk, pclk);
+
+	for (i = 0; i < ARRAY_SIZE(comp_lrclk_rates) - 1; i++) {
+		if (fs <= (comp_lrclk_rates[i] + comp_lrclk_rates[i+1]) / 2)
+			break;
+	}
+
+	dmic_freq = dmic_table[pclk_index].settings[micclk_index].freq;
+	dmic_comp = dmic_table[pclk_index].settings[micclk_index].comp[i];
+
+	regmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_ENABLE,
+			   M98090_MICCLK_MASK,
+			   micclk_index << M98090_MICCLK_SHIFT);
+
+	regmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_CONFIG,
+			   M98090_DMIC_COMP_MASK | M98090_DMIC_FREQ_MASK,
+			   dmic_comp << M98090_DMIC_COMP_SHIFT |
+			   dmic_freq << M98090_DMIC_FREQ_SHIFT);
+
+	return 0;
+}
+
 static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 				   struct snd_pcm_hw_params *params,
 				   struct snd_soc_dai *dai)
@@ -1854,7 +1982,6 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_codec *codec = dai->codec;
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	struct max98090_cdata *cdata;
-	int i, j;
 
 	cdata = &max98090->dai[0];
 	max98090->bclk = snd_soc_params_to_bclk(params);
@@ -1893,27 +2020,8 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
 			M98090_DHF_MASK, M98090_DHF_MASK);
 
-	/* Check for supported PCLK to LRCLK ratios */
-	for (j = 0; j < ARRAY_SIZE(comp_pclk_rates); j++) {
-		if (comp_pclk_rates[j] == max98090->sysclk) {
-			break;
-		}
-	}
-
-	for (i = 0; i < ARRAY_SIZE(comp_lrclk_rates) - 1; i++) {
-		if (max98090->lrclk <= (comp_lrclk_rates[i] +
-			comp_lrclk_rates[i + 1]) / 2) {
-			break;
-		}
-	}
-
-	snd_soc_update_bits(codec, M98090_REG_DIGITAL_MIC_ENABLE,
-			M98090_MICCLK_MASK,
-			dmic_micclk[j] << M98090_MICCLK_SHIFT);
-
-	snd_soc_update_bits(codec, M98090_REG_DIGITAL_MIC_CONFIG,
-			M98090_DMIC_COMP_MASK,
-			dmic_comp[j][i] << M98090_DMIC_COMP_SHIFT);
+	max98090_configure_dmic(max98090, max98090->dmic_freq, max98090->pclk,
+				max98090->lrclk);
 
 	return 0;
 }
@@ -1944,12 +2052,15 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 	if ((freq >= 10000000) && (freq <= 20000000)) {
 		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV1);
+		max98090->pclk = freq;
 	} else if ((freq > 20000000) && (freq <= 40000000)) {
 		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV2);
+		max98090->pclk = freq >> 1;
 	} else if ((freq > 40000000) && (freq <= 60000000)) {
 		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV4);
+		max98090->pclk = freq >> 2;
 	} else {
 		dev_err(codec->dev, "Invalid master clock frequency\n");
 		return -EINVAL;
@@ -2324,6 +2435,7 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	/* Initialize private data */
 
 	max98090->sysclk = (unsigned)-1;
+	max98090->pclk = (unsigned)-1;
 	max98090->master = false;
 
 	cdata = &max98090->dai[0];
@@ -2463,6 +2575,11 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 	i2c_set_clientdata(i2c, max98090);
 	max98090->pdata = i2c->dev.platform_data;
 
+	ret = of_property_read_u32(i2c->dev.of_node, "maxim,dmic-freq",
+				   &max98090->dmic_freq);
+	if (ret < 0)
+		max98090->dmic_freq = MAX98090_DEFAULT_DMIC_FREQ;
+
 	max98090->regmap = devm_regmap_init_i2c(i2c, &max98090_regmap);
 	if (IS_ERR(max98090->regmap)) {
 		ret = PTR_ERR(max98090->regmap);

commit ece509c10985ba93ccc8c68f808a9e767250041c
Author: Dylan Reid <dgreid@chromium.org>
Date:   Mon Nov 3 10:28:56 2014 -0800

    ASoC: max98090: Correct pclk divisor settings
    
    The Baytrail-based chromebooks have a 20MHz mclk, the code was setting
    the divisor incorrectly in this case.  According to the 98090
    datasheet, the divisor should be set to DIV1 for 10 <= mclk <= 20.
    Correct this and the surrounding clock ranges as well to match the
    datasheet.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index d519294f57c7..1229554f1464 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1941,13 +1941,13 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 	 *		 0x02 (when master clk is 20MHz to 40MHz)..
 	 *		 0x03 (when master clk is 40MHz to 60MHz)..
 	 */
-	if ((freq >= 10000000) && (freq < 20000000)) {
+	if ((freq >= 10000000) && (freq <= 20000000)) {
 		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV1);
-	} else if ((freq >= 20000000) && (freq < 40000000)) {
+	} else if ((freq > 20000000) && (freq <= 40000000)) {
 		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV2);
-	} else if ((freq >= 40000000) && (freq < 60000000)) {
+	} else if ((freq > 40000000) && (freq <= 60000000)) {
 		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
 			M98090_PSCLK_DIV4);
 	} else {

commit 9568eaec6c16f909e806a3920699376ec147d8fa
Merge: 57b027f697c9 99632d107785 3b40a80216e9 a493b6a637e9 a577483b6906
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Oct 6 12:49:02 2014 +0100

    Merge remote-tracking branches 'asoc/topic/max98090', 'asoc/topic/rockchip', 'asoc/topic/rsnd' and 'asoc/topic/rt286' into asoc-next

commit f69e3caa9e1855737bf1e99e1fe4488e33d74bfe
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Sep 26 16:25:37 2014 +0300

    ASoC: max98090: Enable both DMIC channels also when using mono configuration
    
    According to MAX98090 specification "Digital microphone clock (DMC) is
    enabled once both data channels are enabled.". Therefore both digital
    microphone data channels must be enabled also when using mono microphone
    configuration.
    
    Fix this by moving "DMICL_ENA" and "DMICR_ENA" supply widgets from "DMICL"
    and "DMICR" inputs to "DMIC Mux" in order to enable both data channels
    whenever there is active mono or stereo digital microphone input path.
    
    Use of "DMICL" and "DMICR" inputs are retained for informative source and in
    case the driver would find use for exact digital microphone configuration in
    the future.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f1543653a699..7e111865946a 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1311,8 +1311,6 @@ static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
 	{"MIC1 Input", NULL, "MIC1"},
 	{"MIC2 Input", NULL, "MIC2"},
 
-	{"DMICL", NULL, "DMICL_ENA"},
-	{"DMICR", NULL, "DMICR_ENA"},
 	{"DMICL", NULL, "AHPF"},
 	{"DMICR", NULL, "AHPF"},
 
@@ -1370,6 +1368,8 @@ static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
 	{"DMIC Mux", "ADC", "ADCR"},
 	{"DMIC Mux", "DMIC", "DMICL"},
 	{"DMIC Mux", "DMIC", "DMICR"},
+	{"DMIC Mux", "DMIC", "DMICL_ENA"},
+	{"DMIC Mux", "DMIC", "DMICR_ENA"},
 
 	{"LBENL Mux", "Normal", "DMIC Mux"},
 	{"LBENL Mux", "Loopback", "LTENL Mux"},

commit 3256ff6e5117c493ec20e96aad9f0a20d656d561
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Sep 19 14:48:19 2014 +0300

    ASoC: max98090: Remove structure member extmic_mux from private data
    
    There is no other use for extmic_mux than setting it to zero so remove it.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 3e27de1f473b..f2a3f30a5d9f 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2333,7 +2333,6 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	max98090->lin_state = 0;
 	max98090->pa1en = 0;
 	max98090->pa2en = 0;
-	max98090->extmic_mux = 0;
 
 	ret = snd_soc_read(codec, M98090_REG_REVISION_ID);
 	if (ret < 0) {

commit ced1933db67087554abf22bcb285eb6873380b10
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Sep 19 14:48:18 2014 +0300

    ASoC: max98090: Remove structure member irq from private data
    
    struct max98090_priv member irq is now used only locally in
    max98090_i2c_probe() and can be removed.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index fe77df6a76c2..3e27de1f473b 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2463,7 +2463,6 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 	max98090->devtype = driver_data;
 	i2c_set_clientdata(i2c, max98090);
 	max98090->pdata = i2c->dev.platform_data;
-	max98090->irq = i2c->irq;
 
 	max98090->regmap = devm_regmap_init_i2c(i2c, &max98090_regmap);
 	if (IS_ERR(max98090->regmap)) {
@@ -2472,7 +2471,7 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 		goto err_enable;
 	}
 
-	ret = devm_request_threaded_irq(&i2c->dev, max98090->irq, NULL,
+	ret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,
 		max98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 		"max98090_interrupt", max98090);
 	if (ret < 0) {

commit 7a7f0ba03d521ac2d36c9015278bc35657b3dcc9
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Sep 19 14:48:17 2014 +0300

    ASoC: max98090: Move interrupt request from codec probe to i2c probe
    
    Keep MAX98090 interrupt requested after i2c device probing as long as the
    driver is loaded. This fixes the issue where subsequent codec probe
    max98090_probe() call fails in interrupt request since interrupt wasn't
    freed over codec remove-reprobe cycle.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f1543653a699..fe77df6a76c2 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2159,12 +2159,16 @@ static void max98090_jack_work(struct work_struct *work)
 
 static irqreturn_t max98090_interrupt(int irq, void *data)
 {
-	struct snd_soc_codec *codec = data;
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_priv *max98090 = data;
+	struct snd_soc_codec *codec = max98090->codec;
 	int ret;
 	unsigned int mask;
 	unsigned int active;
 
+	/* Treat interrupt before codec is initialized as spurious */
+	if (codec == NULL)
+		return IRQ_NONE;
+
 	dev_dbg(codec->dev, "***** max98090_interrupt *****\n");
 
 	ret = regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);
@@ -2367,17 +2371,6 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	snd_soc_write(codec, M98090_REG_JACK_DETECT,
 		M98090_JDETEN_MASK | M98090_JDEB_25MS);
 
-	/* Register for interrupts */
-	dev_dbg(codec->dev, "irq = %d\n", max98090->irq);
-
-	ret = devm_request_threaded_irq(codec->dev, max98090->irq, NULL,
-		max98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-		"max98090_interrupt", codec);
-	if (ret < 0) {
-		dev_err(codec->dev, "request_irq failed: %d\n",
-			ret);
-	}
-
 	/*
 	 * Clear any old interrupts.
 	 * An old interrupt ocurring prior to installing the ISR
@@ -2417,6 +2410,7 @@ static int max98090_remove(struct snd_soc_codec *codec)
 	cancel_delayed_work_sync(&max98090->pll_det_enable_work);
 	cancel_work_sync(&max98090->pll_det_disable_work);
 	cancel_work_sync(&max98090->pll_work);
+	max98090->codec = NULL;
 
 	return 0;
 }
@@ -2478,6 +2472,15 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 		goto err_enable;
 	}
 
+	ret = devm_request_threaded_irq(&i2c->dev, max98090->irq, NULL,
+		max98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+		"max98090_interrupt", max98090);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "request_irq failed: %d\n",
+			ret);
+		return ret;
+	}
+
 	ret = snd_soc_register_codec(&i2c->dev,
 			&soc_codec_dev_max98090, max98090_dai,
 			ARRAY_SIZE(max98090_dai));

commit b8a3ee820f7b0802c9b90a9f3426dbda54e93d09
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Wed Sep 3 15:42:48 2014 +0300

    ASoC: max98090: Add recovery for PLL lock failure
    
    All MAX98090 input clocks MCLK, LRCLK and BCLK must be running and stable
    before powering on the codec in slave mode. Otherwise the PLL may not lock
    to LRCLK causing silence in playback and capture. How often that happens is
    somewhat hardware and clock configuration specific.
    
    Now if wanting to follow strictly this clocks must be active before
    powering the codec on requirement we should have a notification from DAI
    driver to codec driver when clocks are activated and take codec out of
    shutdown only after that. Plus take care of possible active bypass paths.
    
    However, when PLL unlock occurs, MAX98090 asserts the PLL Unlock Flag which
    can be configured as an IRQ source. This allows to workaround around the
    issue by toggling the codec power shortly in case of PLL lock failure.
    
    In order to prevent needlessly toggling codec power in case of short PLL
    unlocks at the beginning of stream this patch implements delayed activation
    for PLL unlock interrupt. Then workaround is run only when the PLL doesn't
    lock at all.
    
    Power toggling workaround for PLL unlock comes originally from
    Liam Girdwood <liam.r.girdwood@linux.intel.com> and delayed activation from
    me.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 4a063fa88526..f1543653a699 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1972,6 +1972,102 @@ static int max98090_dai_digital_mute(struct snd_soc_dai *codec_dai, int mute)
 	return 0;
 }
 
+static int max98090_dai_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!max98090->master && dai->active == 1)
+			queue_delayed_work(system_power_efficient_wq,
+					   &max98090->pll_det_enable_work,
+					   msecs_to_jiffies(10));
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (!max98090->master && dai->active == 1)
+			schedule_work(&max98090->pll_det_disable_work);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static void max98090_pll_det_enable_work(struct work_struct *work)
+{
+	struct max98090_priv *max98090 =
+		container_of(work, struct max98090_priv,
+			     pll_det_enable_work.work);
+	struct snd_soc_codec *codec = max98090->codec;
+	unsigned int status, mask;
+
+	/*
+	 * Clear status register in order to clear possibly already occurred
+	 * PLL unlock. If PLL hasn't still locked, the status will be set
+	 * again and PLL unlock interrupt will occur.
+	 * Note this will clear all status bits
+	 */
+	regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &status);
+
+	/*
+	 * Queue jack work in case jack state has just changed but handler
+	 * hasn't run yet
+	 */
+	regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);
+	status &= mask;
+	if (status & M98090_JDET_MASK)
+		queue_delayed_work(system_power_efficient_wq,
+				   &max98090->jack_work,
+				   msecs_to_jiffies(100));
+
+	/* Enable PLL unlock interrupt */
+	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+			    M98090_IULK_MASK,
+			    1 << M98090_IULK_SHIFT);
+}
+
+static void max98090_pll_det_disable_work(struct work_struct *work)
+{
+	struct max98090_priv *max98090 =
+		container_of(work, struct max98090_priv, pll_det_disable_work);
+	struct snd_soc_codec *codec = max98090->codec;
+
+	cancel_delayed_work_sync(&max98090->pll_det_enable_work);
+
+	/* Disable PLL unlock interrupt */
+	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+			    M98090_IULK_MASK, 0);
+}
+
+static void max98090_pll_work(struct work_struct *work)
+{
+	struct max98090_priv *max98090 =
+		container_of(work, struct max98090_priv, pll_work);
+	struct snd_soc_codec *codec = max98090->codec;
+
+	if (!snd_soc_codec_is_active(codec))
+		return;
+
+	dev_info(codec->dev, "PLL unlocked\n");
+
+	/* Toggle shutdown OFF then ON */
+	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+			    M98090_SHDNN_MASK, 0);
+	msleep(10);
+	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+			    M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+
+	/* Give PLL time to lock */
+	msleep(10);
+}
+
 static void max98090_jack_work(struct work_struct *work)
 {
 	struct max98090_priv *max98090 = container_of(work,
@@ -2103,8 +2199,10 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
 	if (active & M98090_SLD_MASK)
 		dev_dbg(codec->dev, "M98090_SLD_MASK\n");
 
-	if (active & M98090_ULK_MASK)
-		dev_err(codec->dev, "M98090_ULK_MASK\n");
+	if (active & M98090_ULK_MASK) {
+		dev_dbg(codec->dev, "M98090_ULK_MASK\n");
+		schedule_work(&max98090->pll_work);
+	}
 
 	if (active & M98090_JDET_MASK) {
 		dev_dbg(codec->dev, "M98090_JDET_MASK\n");
@@ -2177,6 +2275,7 @@ static struct snd_soc_dai_ops max98090_dai_ops = {
 	.set_tdm_slot = max98090_set_tdm_slot,
 	.hw_params = max98090_dai_hw_params,
 	.digital_mute = max98090_dai_digital_mute,
+	.trigger = max98090_dai_trigger,
 };
 
 static struct snd_soc_dai_driver max98090_dai[] = {
@@ -2258,6 +2357,11 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	max98090->jack_state = M98090_JACK_STATE_NO_HEADSET;
 
 	INIT_DELAYED_WORK(&max98090->jack_work, max98090_jack_work);
+	INIT_DELAYED_WORK(&max98090->pll_det_enable_work,
+			  max98090_pll_det_enable_work);
+	INIT_WORK(&max98090->pll_det_disable_work,
+		  max98090_pll_det_disable_work);
+	INIT_WORK(&max98090->pll_work, max98090_pll_work);
 
 	/* Enable jack detection */
 	snd_soc_write(codec, M98090_REG_JACK_DETECT,
@@ -2310,6 +2414,9 @@ static int max98090_remove(struct snd_soc_codec *codec)
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 
 	cancel_delayed_work_sync(&max98090->jack_work);
+	cancel_delayed_work_sync(&max98090->pll_det_enable_work);
+	cancel_work_sync(&max98090->pll_det_disable_work);
+	cancel_work_sync(&max98090->pll_work);
 
 	return 0;
 }

commit a6ce305207d2339e174ef49879c217ed7df2d594
Merge: e7177999dc0f d6e08617cb0f 6145dfc6d96a 121eb444135c a28d167fbbef
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Aug 4 16:31:45 2014 +0100

    Merge remote-tracking branches 'asoc/topic/intel', 'asoc/topic/kirkwood', 'asoc/topic/max98090' and 'asoc/topic/mc13783' into asoc-next

commit 121eb444135c25701051eb849e7ccf0dd412382b
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jul 7 15:18:19 2014 +0200

    ASoC: max98090: Fix build warning
    
    The max98090_{suspend,resume}() functions are used for system sleep and
    therefore need to be guarded by CONFIG_PM_SLEEP rather than CONFIG_PM.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 0e59e5117e43..6816578ea8f7 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2408,7 +2408,7 @@ static int max98090_runtime_suspend(struct device *dev)
 }
 #endif
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int max98090_resume(struct device *dev)
 {
 	struct max98090_priv *max98090 = dev_get_drvdata(dev);

commit eba843201a8e5824c5e6e539db6cd1a6ba84f145
Author: Tushar Behera <tushar.b@samsung.com>
Date:   Fri Jul 4 14:42:17 2014 +0530

    ASoC: max98090: Remove redundant max98090_handle_pdata()
    
    max98090_handle_pdata() is not doing anything other than printing
    a message if pdata is not valid. This can be removed.
    
    Signed-off-by: Tushar Behera <tushar.b@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 2c2c5b22f60f..0e59e5117e43 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2200,17 +2200,6 @@ static struct snd_soc_dai_driver max98090_dai[] = {
 }
 };
 
-static void max98090_handle_pdata(struct snd_soc_codec *codec)
-{
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
-	struct max98090_pdata *pdata = max98090->pdata;
-
-	if (!pdata) {
-		dev_err(codec->dev, "No platform data\n");
-		return;
-	}
-}
-
 static int max98090_probe(struct snd_soc_codec *codec)
 {
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
@@ -2310,8 +2299,6 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	snd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,
 		M98090_MBVSEL_MASK, M98090_MBVSEL_2V8);
 
-	max98090_handle_pdata(codec);
-
 	max98090_add_widgets(codec);
 
 err_access:

commit 978b641f9563019a24032d5dee8a75963cd248ff
Author: Tushar Behera <tushar.b@samsung.com>
Date:   Fri Jul 4 14:42:16 2014 +0530

    ASoC: max98090: Add check for CODEC type
    
    CODEC type (MAX98090/MAX98091) can be specified from device-tree file,
    it can also be obtained from the CODEC during runtime.
    
    Add an explicit check to figure out if both are matching, else print
    a message warning about the same.
    
    Signed-off-by: Tushar Behera <tushar.b@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index c00b36872dfe..2c2c5b22f60f 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2215,6 +2215,7 @@ static int max98090_probe(struct snd_soc_codec *codec)
 {
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	struct max98090_cdata *cdata;
+	enum max98090_type devtype;
 	int ret = 0;
 
 	dev_dbg(codec->dev, "max98090_probe\n");
@@ -2250,16 +2251,21 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	}
 
 	if ((ret >= M98090_REVA) && (ret <= M98090_REVA + 0x0f)) {
-		max98090->devtype = MAX98090;
+		devtype = MAX98090;
 		dev_info(codec->dev, "MAX98090 REVID=0x%02x\n", ret);
 	} else if ((ret >= M98091_REVA) && (ret <= M98091_REVA + 0x0f)) {
-		max98090->devtype = MAX98091;
+		devtype = MAX98091;
 		dev_info(codec->dev, "MAX98091 REVID=0x%02x\n", ret);
 	} else {
-		max98090->devtype = MAX98090;
+		devtype = MAX98090;
 		dev_err(codec->dev, "Unrecognized revision 0x%02x\n", ret);
 	}
 
+	if (max98090->devtype != devtype) {
+		dev_warn(codec->dev, "Mismatch in DT specified CODEC type.\n");
+		max98090->devtype = devtype;
+	}
+
 	max98090->jack_state = M98090_JACK_STATE_NO_HEADSET;
 
 	INIT_DELAYED_WORK(&max98090->jack_work, max98090_jack_work);

commit 053e69d57cc6253b19ea661f929c8c1b6a907bff
Author: Wonjoon Lee <woojoo.lee@samsung.com>
Date:   Fri Jun 20 13:33:15 2014 +0530

    ASoC: max98090: Add max98091 compatible string
    
    The MAX98091 CODEC is the same as MAX98090 CODEC, but with an extra
    microphone. Existing driver for MAX98090 CODEC already has support
    for MAX98091 CODEC. Adding proper compatible string so that MAX98091
    CODEC can be specified from device tree.
    
    Signed-off-by: Wonjoon Lee <woojoo.lee@samsung.com>
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Tushar Behera <tushar.b@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 3aec3ae78fe0..c00b36872dfe 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2447,12 +2447,14 @@ static const struct dev_pm_ops max98090_pm = {
 
 static const struct i2c_device_id max98090_i2c_id[] = {
 	{ "max98090", MAX98090 },
+	{ "max98091", MAX98091 },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, max98090_i2c_id);
 
 static const struct of_device_id max98090_of_match[] = {
 	{ .compatible = "maxim,max98090", },
+	{ .compatible = "maxim,max98091", },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, max98090_of_match);

commit 6c49a986957bc5fe39b29166cb7fad573dc242ba
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Jun 19 09:44:26 2014 +0300

    ASoC: max98090: Remove needless defines and line feeds
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f5fccc7a8e89..3aec3ae78fe0 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -26,10 +26,6 @@
 #include <sound/max98090.h>
 #include "max98090.h"
 
-#define DEBUG
-#define EXTMIC_METHOD
-#define EXTMIC_METHOD_TEST
-
 /* Allows for sparsely populated register maps */
 static struct reg_default max98090_reg[] = {
 	{ 0x00, 0x00 }, /* 00 Software Reset */
@@ -820,7 +816,6 @@ static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 	else
 		val = (val & M98090_MIC_PA2EN_MASK) >> M98090_MIC_PA2EN_SHIFT;
 
-
 	if (val >= 1) {
 		if (w->reg == M98090_REG_MIC1_INPUT_LEVEL) {
 			max98090->pa1en = val - 1; /* Update for volatile */
@@ -1140,7 +1135,6 @@ static const struct snd_kcontrol_new max98090_mixhprsel_mux =
 	SOC_DAPM_ENUM("MIXHPRSEL Mux", mixhprsel_mux_enum);
 
 static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
-
 	SND_SOC_DAPM_INPUT("MIC1"),
 	SND_SOC_DAPM_INPUT("MIC2"),
 	SND_SOC_DAPM_INPUT("DMICL"),
@@ -1304,7 +1298,6 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 };
 
 static const struct snd_soc_dapm_widget max98091_dapm_widgets[] = {
-
 	SND_SOC_DAPM_INPUT("DMIC3"),
 	SND_SOC_DAPM_INPUT("DMIC4"),
 
@@ -1315,7 +1308,6 @@ static const struct snd_soc_dapm_widget max98091_dapm_widgets[] = {
 };
 
 static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
-
 	{"MIC1 Input", NULL, "MIC1"},
 	{"MIC2 Input", NULL, "MIC2"},
 
@@ -1493,17 +1485,14 @@ static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
 	{"SPKR", NULL, "SPK Right Out"},
 	{"RCVL", NULL, "RCV Left Out"},
 	{"RCVR", NULL, "RCV Right Out"},
-
 };
 
 static const struct snd_soc_dapm_route max98091_dapm_routes[] = {
-
 	/* DMIC inputs */
 	{"DMIC3", NULL, "DMIC3_ENA"},
 	{"DMIC4", NULL, "DMIC4_ENA"},
 	{"DMIC3", NULL, "AHPF"},
 	{"DMIC4", NULL, "AHPF"},
-
 };
 
 static int max98090_add_widgets(struct snd_soc_codec *codec)
@@ -1531,7 +1520,6 @@ static int max98090_add_widgets(struct snd_soc_codec *codec)
 
 		snd_soc_dapm_add_routes(dapm, max98091_dapm_routes,
 			ARRAY_SIZE(max98091_dapm_routes));
-
 	}
 
 	return 0;
@@ -2221,7 +2209,6 @@ static void max98090_handle_pdata(struct snd_soc_codec *codec)
 		dev_err(codec->dev, "No platform data\n");
 		return;
 	}
-
 }
 
 static int max98090_probe(struct snd_soc_codec *codec)

commit 4adeb0ccf86a5af1825bbfe290dee9e60a5ab870
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Jun 19 09:32:05 2014 +0300

    ASoC: max98090: Fix missing free_irq
    
    max98090.c doesn't free the threaded interrupt it requests. This causes
    an oops when doing "cat /proc/interrupts" after snd-soc-max98090.ko is
    unloaded.
    
    Fix this by requesting the interrupt by using devm_request_threaded_irq().
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Cc: Stable <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f5fccc7a8e89..d97f1ce7ff7d 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2284,7 +2284,7 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	/* Register for interrupts */
 	dev_dbg(codec->dev, "irq = %d\n", max98090->irq);
 
-	ret = request_threaded_irq(max98090->irq, NULL,
+	ret = devm_request_threaded_irq(codec->dev, max98090->irq, NULL,
 		max98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 		"max98090_interrupt", codec);
 	if (ret < 0) {

commit b12a1906be48d1d020e1e20550b93417c7c3d767
Merge: 9713d5d0c4d8 b10ab7b838bd e3048c3d2be5
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Jun 3 10:39:52 2014 +0100

    Merge remote-tracking branches 'asoc/topic/max98090' and 'asoc/topic/max98095' into asoc-next

commit b10ab7b838bdd86031aececcb386dc253ef3466f
Author: Tushar Behera <tushar.behera@linaro.org>
Date:   Mon May 26 13:58:21 2014 +0530

    ASoC: max98090: Add master clock handling
    
    If master clock is provided through device tree, then update
    the master clock frequency during set_sysclk.
    
    Documentation has been updated to reflect the change.
    
    Signed-off-by: Tushar Behera <tushar.behera@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 4ee1f88760c4..8857be798f3b 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -16,6 +16,7 @@
 #include <linux/regmap.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
+#include <linux/clk.h>
 #include <sound/jack.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -1798,6 +1799,19 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 		break;
 
 	case SND_SOC_BIAS_PREPARE:
+		/*
+		 * SND_SOC_BIAS_PREPARE is called while preparing for a
+		 * transition to ON or away from ON. If current bias_level
+		 * is SND_SOC_BIAS_ON, then it is preparing for a transition
+		 * away from ON. Disable the clock in that case, otherwise
+		 * enable it.
+		 */
+		if (!IS_ERR(max98090->mclk)) {
+			if (codec->dapm.bias_level == SND_SOC_BIAS_ON)
+				clk_disable_unprepare(max98090->mclk);
+			else
+				clk_prepare_enable(max98090->mclk);
+		}
 		break;
 
 	case SND_SOC_BIAS_STANDBY:
@@ -1927,6 +1941,11 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 	if (freq == max98090->sysclk)
 		return 0;
 
+	if (!IS_ERR(max98090->mclk)) {
+		freq = clk_round_rate(max98090->mclk, freq);
+		clk_set_rate(max98090->mclk, freq);
+	}
+
 	/* Setup clocks for slave mode, and using the PLL
 	 * PSCLK = 0x01 (when master clk is 10MHz to 20MHz)
 	 *		 0x02 (when master clk is 20MHz to 40MHz)..
@@ -2211,6 +2230,10 @@ static int max98090_probe(struct snd_soc_codec *codec)
 
 	dev_dbg(codec->dev, "max98090_probe\n");
 
+	max98090->mclk = devm_clk_get(codec->dev, "mclk");
+	if (PTR_ERR(max98090->mclk) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
 	max98090->codec = codec;
 
 	/* Reset the codec, the DSP core, and disable all interrupts */

commit 2c81a10ae6c6aaef68f8b92b4fc8037d1dfe0d9e
Author: Chen Zhen <zhen1.chen@samsung.com>
Date:   Thu May 22 13:21:43 2014 +0200

    ASoC: max98090: Add NI/MI values for user pclk 19.2 MHz
    
    This patch adds the clock divisor and multiplier NI, MI values for audio
    sampling frequencies 44100 and 48000 Hz and PCLK 19.2 MHz. This is useful
    for the Odroid X2/U2 boards when the codec works in master mode and its
    MCLK clock is fed from the I2S CDCLK output.
    
    Signed-off-by: Chen Zhen <zhen1.chen@samsung.com>
    [s.nawrocki@samsung.com: edited the commit description]
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index c88bf821b86f..4ee1f88760c4 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1545,19 +1545,19 @@ static const int lrclk_rates[] = {
 };
 
 static const int user_pclk_rates[] = {
-	13000000, 13000000
+	13000000, 13000000, 19200000, 19200000,
 };
 
 static const int user_lrclk_rates[] = {
-	44100, 48000
+	44100, 48000, 44100, 48000,
 };
 
 static const unsigned long long ni_value[] = {
-	3528, 768
+	3528, 768, 441, 8
 };
 
 static const unsigned long long mi_value[] = {
-	8125, 1625
+	8125, 1625, 1500, 25
 };
 
 static void max98090_configure_bclk(struct snd_soc_codec *codec)

commit 6630f30ed5e4d7f9fae9c7d63364225790765aef
Merge: 3a6a489fd869 ee5e4534f7b3 2fa190ce33bd 0aa2a15a7b5c a735d992c2e7 c4839c87f508 780aaeff9681 7b4a469e583f
Author: Mark Brown <broonie@linaro.org>
Date:   Thu May 22 00:23:54 2014 +0100

    Merge remote-tracking branches 'asoc/topic/headers', 'asoc/topic/intel', 'asoc/topic/jz4740', 'asoc/topic/max98090', 'asoc/topic/max98095', 'asoc/topic/mc13783' and 'asoc/topic/multicodec' into asoc-next

commit e3ac3f2510e5adb62eb4296d3fd0fac5441b2037
Merge: 566d4eeff85a 9de98da2a753
Author: Mark Brown <broonie@linaro.org>
Date:   Thu May 22 00:23:44 2014 +0100

    Merge remote-tracking branch 'asoc/topic/enum' into asoc-next

commit 0f4019e6f4da4e0bcefd38f78d61fe5d0565b3cc
Merge: 228704bbdd5e 4da533932ded
Author: Mark Brown <broonie@linaro.org>
Date:   Thu May 22 00:23:41 2014 +0100

    Merge remote-tracking branch 'asoc/topic/component' into asoc-next

commit a735d992c2e71e230b798518b7fe954fdbc2dc8c
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri May 16 16:55:24 2014 +0300

    ASoC: max98090: Move microphone bias voltage setting to probe function
    
    Microphone bias level configuration register can configure voltage between
    2.2 V and 2.8 V but doesn't manage is voltage on or off. Microphone bias
    on/off state is controlled by "MICBIAS" DAPM widget.
    
    Therefore there is no need to update bias voltage conditionally depending on
    jack state each time when codec goes to SND_SOC_BIAS_ON state and setting
    can be moved to max98090_probe() as driver currently doesn't support other
    levels than 2.8 V.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index d36cd154db55..c88bf821b86f 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1795,13 +1795,6 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
-		if (max98090->jack_state == M98090_JACK_STATE_HEADSET) {
-			/*
-			 * Set to normal bias level.
-			 */
-			snd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,
-				M98090_MBVSEL_MASK, M98090_MBVSEL_2V8);
-		}
 		break;
 
 	case SND_SOC_BIAS_PREPARE:
@@ -2296,6 +2289,9 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	snd_soc_write(codec, M98090_REG_BIAS_CONTROL,
 		M98090_VCM_MODE_MASK);
 
+	snd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,
+		M98090_MBVSEL_MASK, M98090_MBVSEL_2V8);
+
 	max98090_handle_pdata(codec);
 
 	max98090_add_widgets(codec);

commit 541423dde415e9cecdb0bf17657b3bd7e1666dd2
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri May 16 16:55:23 2014 +0300

    ASoC: max98090: Make sure we configure BCLK in one place
    
    BCL is being configured in two places producing a warning message.
    Make sure we only configure BCLK once and when we are master.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index aba6ed24c82e..d36cd154db55 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1674,6 +1674,7 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 				M98090_REG_CLOCK_RATIO_NI_LSB, 0x00);
 			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
 				M98090_USE_M1_MASK, 0);
+			max98090->master = false;
 			break;
 		case SND_SOC_DAIFMT_CBM_CFM:
 			/* Set to master mode */
@@ -1690,6 +1691,7 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 				regval |= M98090_MAS_MASK |
 					M98090_BSEL_32;
 			}
+			max98090->master = true;
 			break;
 		case SND_SOC_DAIFMT_CBS_CFM:
 		case SND_SOC_DAIFMT_CBM_CFS:
@@ -1873,7 +1875,8 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	max98090_configure_bclk(codec);
+	if (max98090->master)
+		max98090_configure_bclk(codec);
 
 	cdata->rate = max98090->lrclk;
 
@@ -1952,8 +1955,6 @@ static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
 
 	max98090->sysclk = freq;
 
-	max98090_configure_bclk(codec);
-
 	return 0;
 }
 
@@ -2225,6 +2226,7 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	/* Initialize private data */
 
 	max98090->sysclk = (unsigned)-1;
+	max98090->master = false;
 
 	cdata = &max98090->dai[0];
 	cdata->rate = (unsigned)-1;

commit 70f29d388915723ce03eee74a649f170e4c9f1e0
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri May 16 16:55:25 2014 +0300

    ASoC: max98090: Add ACPI probing support
    
    Add ACPI ID for MAX98090 and ACPI 5 I2C device probing support.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f7b0b37aa858..aba6ed24c82e 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -15,6 +15,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
+#include <linux/acpi.h>
 #include <sound/jack.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -2329,9 +2330,11 @@ static const struct regmap_config max98090_regmap = {
 };
 
 static int max98090_i2c_probe(struct i2c_client *i2c,
-				 const struct i2c_device_id *id)
+				 const struct i2c_device_id *i2c_id)
 {
 	struct max98090_priv *max98090;
+	const struct acpi_device_id *acpi_id;
+	kernel_ulong_t driver_data = 0;
 	int ret;
 
 	pr_debug("max98090_i2c_probe\n");
@@ -2341,7 +2344,19 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 	if (max98090 == NULL)
 		return -ENOMEM;
 
-	max98090->devtype = id->driver_data;
+	if (ACPI_HANDLE(&i2c->dev)) {
+		acpi_id = acpi_match_device(i2c->dev.driver->acpi_match_table,
+					    &i2c->dev);
+		if (!acpi_id) {
+			dev_err(&i2c->dev, "No driver data\n");
+			return -EINVAL;
+		}
+		driver_data = acpi_id->driver_data;
+	} else if (i2c_id) {
+		driver_data = i2c_id->driver_data;
+	}
+
+	max98090->devtype = driver_data;
 	i2c_set_clientdata(i2c, max98090);
 	max98090->pdata = i2c->dev.platform_data;
 	max98090->irq = i2c->irq;
@@ -2405,12 +2420,21 @@ static const struct of_device_id max98090_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, max98090_of_match);
 
+#ifdef CONFIG_ACPI
+static struct acpi_device_id max98090_acpi_match[] = {
+	{ "193C9890", MAX98090 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, max98090_acpi_match);
+#endif
+
 static struct i2c_driver max98090_i2c_driver = {
 	.driver = {
 		.name = "max98090",
 		.owner = THIS_MODULE,
 		.pm = &max98090_pm,
 		.of_match_table = of_match_ptr(max98090_of_match),
+		.acpi_match_table = ACPI_PTR(max98090_acpi_match),
 	},
 	.probe  = max98090_i2c_probe,
 	.remove = max98090_i2c_remove,

commit f1c0bc9145f8abf0217fd71c09ff8c1e7f0671dd
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri May 16 16:55:22 2014 +0300

    ASoC: max98090: Mark cache as dirty prior to restoring
    
    Make sure the cache is fully flushed at resume time.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 2888f632564a..c58dce473e55 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2398,6 +2398,8 @@ static int max98090_resume(struct device *dev)
 	struct max98090_priv *max98090 = dev_get_drvdata(dev);
 	unsigned int status;
 
+	regcache_mark_dirty(max98090->regmap);
+
 	max98090_reset(max98090);
 
 	/* clear IRQ status */

commit 46b0e97dcfdbb179b9992b6aec3eabb6095d8745
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri May 16 16:55:21 2014 +0300

    ASoC: max98090: Reset codec on resume
    
    Make sure we reset codec and clear any IRQs on resume. This matches
    the init sequence in probe.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index be86094817eb..2888f632564a 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2392,9 +2392,32 @@ static int max98090_runtime_suspend(struct device *dev)
 }
 #endif
 
+#ifdef CONFIG_PM
+static int max98090_resume(struct device *dev)
+{
+	struct max98090_priv *max98090 = dev_get_drvdata(dev);
+	unsigned int status;
+
+	max98090_reset(max98090);
+
+	/* clear IRQ status */
+	regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &status);
+
+	regcache_sync(max98090->regmap);
+
+	return 0;
+}
+
+static int max98090_suspend(struct device *dev)
+{
+	return 0;
+}
+#endif
+
 static const struct dev_pm_ops max98090_pm = {
 	SET_RUNTIME_PM_OPS(max98090_runtime_suspend,
 		max98090_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(max98090_suspend, max98090_resume)
 };
 
 static const struct i2c_device_id max98090_i2c_id[] = {

commit 25b4ab430f8e166c9b63f4db28e7e812d5a59396
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri May 16 16:55:20 2014 +0300

    ASoC: max98090: Fix reset at resume time
    
    Reset needs to wait 20ms before other codec IO is performed. This wait
    was not being performed. Fix this by making sure the reset register is not
    restored with the cache, but use the manual reset method in resume with
    the wait.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 7980784d1e33..be86094817eb 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -255,6 +255,7 @@ static struct reg_default max98090_reg[] = {
 static bool max98090_volatile_register(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
+	case M98090_REG_SOFTWARE_RESET:
 	case M98090_REG_DEVICE_STATUS:
 	case M98090_REG_JACK_STATUS:
 	case M98090_REG_REVISION_ID:
@@ -2374,6 +2375,8 @@ static int max98090_runtime_resume(struct device *dev)
 
 	regcache_cache_only(max98090->regmap, false);
 
+	max98090_reset(max98090);
+
 	regcache_sync(max98090->regmap);
 
 	return 0;

commit 729af1ce6c8796808079b5ef44b302108374264a
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri May 16 16:55:19 2014 +0300

    ASoC: max98090: Fix digital sidetone gain TLV
    
    TLV for digital sidetone volume is wrong, this fix matches it to the
    datasheet.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f7b0b37aa858..7980784d1e33 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -389,6 +389,7 @@ static const DECLARE_TLV_DB_SCALE(max98090_alc_tlv, -1500, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_alcmakeup_tlv, 0, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_alccomp_tlv, -3100, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_drcexp_tlv, -6600, 100, 0);
+static const DECLARE_TLV_DB_SCALE(max98090_sdg_tlv, 50, 200, 0);
 
 static const unsigned int max98090_mixout_tlv[] = {
 	TLV_DB_RANGE_HEAD(2),
@@ -665,7 +666,7 @@ static const struct snd_kcontrol_new max98090_snd_controls[] = {
 	SOC_SINGLE_EXT_TLV("Digital Sidetone Volume",
 		M98090_REG_ADC_SIDETONE, M98090_DVST_SHIFT,
 		M98090_DVST_NUM - 1, 1, max98090_get_enab_tlv,
-		max98090_put_enab_tlv, max98090_micboost_tlv),
+		max98090_put_enab_tlv, max98090_sdg_tlv),
 	SOC_SINGLE_TLV("Digital Coarse Volume", M98090_REG_DAI_PLAYBACK_LEVEL,
 		M98090_DVG_SHIFT, M98090_DVG_NUM - 1, 0,
 		max98090_dvg_tlv),

commit aae1137b998a1a4508a2f2b27604351a5ced2427
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 14 21:30:59 2014 +0200

    ASoC: max98090: Replace usage deprecated MUX/ENUM macros
    
    SND_SOC_DAPM_VIRT_MUX and SOC_DAPM_ENUM_VIRT are deprecated and merely an alias
    for SND_SOC_DAPM_MUX and SOC_DAPM_ENUM. Replace the deprecated macros so we can
    eventually remove their definition.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f7b0b37aa858..1fd31efa6664 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -875,7 +875,7 @@ static const char *dmic_mux_text[] = { "ADC", "DMIC" };
 static SOC_ENUM_SINGLE_VIRT_DECL(dmic_mux_enum, dmic_mux_text);
 
 static const struct snd_kcontrol_new max98090_dmic_mux =
-	SOC_DAPM_ENUM_VIRT("DMIC Mux", dmic_mux_enum);
+	SOC_DAPM_ENUM("DMIC Mux", dmic_mux_enum);
 
 static const char *max98090_micpre_text[] = { "Off", "On" };
 
@@ -1175,8 +1175,7 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 	SND_SOC_DAPM_MUX("MIC2 Mux", SND_SOC_NOPM,
 		0, 0, &max98090_mic2_mux),
 
-	SND_SOC_DAPM_VIRT_MUX("DMIC Mux", SND_SOC_NOPM,
-		0, 0, &max98090_dmic_mux),
+	SND_SOC_DAPM_MUX("DMIC Mux", SND_SOC_NOPM, 0, 0, &max98090_dmic_mux),
 
 	SND_SOC_DAPM_PGA_E("MIC1 Input", M98090_REG_MIC1_INPUT_LEVEL,
 		M98090_MIC_PA1EN_SHIFT, 0, NULL, 0, max98090_micinput_event,

commit 6e1f29d4ef1c13ab87fe785fe6e1213d57232a31
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri Apr 4 11:29:10 2014 +0530

    ASoC: max98090: Include of.h
    
    of_match_ptr is defined in of.h. Include it explicitly.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f7b0b37aa858..4959e762f88a 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -11,6 +11,7 @@
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
+#include <linux/of.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>

commit ea53bf77d147e7e560ac007fdaa30fb98c37c712
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Mar 18 09:02:04 2014 +0100

    ASoC: Add snd_soc_kcontrol_codec() helper function
    
    For CODEC controls snd_kcontrol_chip() currently returns a pointer to the
    CODEC that registered the control. With the upcoming consolidation of
    platform and CODEC controls this will change. Prepare for this by introducing
    the snd_soc_kcontrol_codec() helper function that will hide the implementation
    details of how the CODEC for a control can be obtained. This will allow us to
    change this easily in the future.
    
    The patch also updates all CODEC drivers to use the new helper function.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index f7b0b37aa858..49d12387ac2f 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -426,7 +426,7 @@ static const unsigned int max98090_rcv_lout_tlv[] = {
 static int max98090_get_enab_tlv(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
@@ -466,7 +466,7 @@ static int max98090_get_enab_tlv(struct snd_kcontrol *kcontrol,
 static int max98090_put_enab_tlv(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;

commit bfef92bb97b48d0ab5a543e2e7de09b6b014603e
Merge: 30659894f379 c31b0cb1f1a1 a14bf88749c5 06b4b813058f 05b0006734f2 74ddd8c40d8a ef33bc3217c7 3567de676b60 2951f93f431a
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Apr 8 21:22:11 2014 +0100

    Merge remote-tracking branches 'asoc/fix/alc5632', 'asoc/fix/cs42l52', 'asoc/fix/cs42xxx8', 'asoc/fix/da732x', 'asoc/fix/davinci', 'asoc/fix/fsl-sai', 'asoc/fix/fsl-ssi' and 'asoc/fix/max98090' into asoc-linus

commit 2951f93f431a2fc8956a3b13882dc07cb5b8b2b9
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Mar 31 12:38:18 2014 -0600

    ASoC: max98090: add an of_match table
    
    Add a device tree match table. This serves to make the driver's support
    of device tree more explicit. Perhaps the fallback for DT matching to
    using the i2c_device_id table will go away one day, since it fails in
    face of devices from different vendors with the same name.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 361862d4fa65..83a773c11ddb 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2406,11 +2406,18 @@ static const struct i2c_device_id max98090_i2c_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, max98090_i2c_id);
 
+static const struct of_device_id max98090_of_match[] = {
+	{ .compatible = "maxim,max98090", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, max98090_of_match);
+
 static struct i2c_driver max98090_i2c_driver = {
 	.driver = {
 		.name = "max98090",
 		.owner = THIS_MODULE,
 		.pm = &max98090_pm,
+		.of_match_table = of_match_ptr(max98090_of_match),
 	},
 	.probe  = max98090_i2c_probe,
 	.remove = max98090_i2c_remove,

commit 980aac20877e428406959391e6cb6b8dc3243ad2
Merge: cca1b08ff699 e585ca342dbb 7f0af4ae8611
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 23 14:00:55 2014 +0000

    Merge remote-tracking branches 'asoc/topic/max98090' and 'asoc/topic/omap' into asoc-next

commit e585ca342dbbfe7102985d9ed4eae3f9e1d77ced
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Mar 14 09:33:36 2014 +0100

    ASoC: max98090: Remove unused control_data field
    
    The driver assigns a value to the control_data field of the driver's state
    struct, but never reads it again. Which means it is unused and can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index c7b9e901bdac..361862d4fa65 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2350,7 +2350,6 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 
 	max98090->devtype = id->driver_data;
 	i2c_set_clientdata(i2c, max98090);
-	max98090->control_data = i2c;
 	max98090->pdata = i2c->dev.platform_data;
 	max98090->irq = i2c->irq;
 

commit 2620954d64f6f067b785faf03738b637f3473ca7
Merge: 8b3272bffe58 a32c17b87c17
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Mar 13 14:19:21 2014 +0000

    Merge remote-tracking branch 'asoc/topic/io' into asoc-next

commit b8f861586c9c2433b22f81e933845cb8aaa18d9e
Merge: 53a2c4db8cf2 6af5263ceaff
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Mar 12 23:03:59 2014 +0000

    Merge remote-tracking branch 'asoc/topic/enum' into asoc-next

commit 5d6be5aa6becc750c5c2aa0ef8f7209ce19aa328
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Tue Mar 11 12:43:20 2014 +0800

    ASoC: codec: Simplify ASoC probe code.
    
    For some CODEC drivers like who act as the MFDs children are ignored
    by this patch.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 51f9b3d16b41..4ac3b67b2006 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2195,14 +2195,6 @@ static int max98090_probe(struct snd_soc_codec *codec)
 
 	max98090->codec = codec;
 
-	codec->control_data = max98090->regmap;
-
-	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);
-	if (ret != 0) {
-		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
-		return ret;
-	}
-
 	/* Reset the codec, the DSP core, and disable all interrupts */
 	max98090_reset(max98090);
 

commit ba513116403bc93072dd54a1f89dacdb4d89fcab
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Feb 28 08:31:07 2014 +0100

    ASoC: max98090: Use SOC_ENUM_SINGLE_VIRT_DECL()
    
    For the upcoming consolidation for MUXs and virtual MUXs we need to mark virtual
    enums as such.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index c7b9e901bdac..1686ade2a429 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -871,7 +871,7 @@ static const struct snd_kcontrol_new max98090_mic2_mux =
 
 static const char *dmic_mux_text[] = { "ADC", "DMIC" };
 
-static SOC_ENUM_SINGLE_EXT_DECL(dmic_mux_enum, dmic_mux_text);
+static SOC_ENUM_SINGLE_VIRT_DECL(dmic_mux_enum, dmic_mux_text);
 
 static const struct snd_kcontrol_new max98090_dmic_mux =
 	SOC_DAPM_ENUM_VIRT("DMIC Mux", dmic_mux_enum);

commit 2907cbcc120e0c388df499fcb1be7d093ade3993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 18 10:14:13 2014 +0100

    ASoC: max98090: Use SOC_ENUM_SINGLE_DECL()
    
    Just replace with the helper macro.  No functional change at all.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 51f9b3d16b41..c7b9e901bdac 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -512,65 +512,75 @@ static const char *max98090_perf_pwr_text[] =
 static const char *max98090_pwr_perf_text[] =
 	{ "Low Power", "High Performance" };
 
-static const struct soc_enum max98090_vcmbandgap_enum =
-	SOC_ENUM_SINGLE(M98090_REG_BIAS_CONTROL, M98090_VCM_MODE_SHIFT,
-		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
+static SOC_ENUM_SINGLE_DECL(max98090_vcmbandgap_enum,
+			    M98090_REG_BIAS_CONTROL,
+			    M98090_VCM_MODE_SHIFT,
+			    max98090_pwr_perf_text);
 
 static const char *max98090_osr128_text[] = { "64*fs", "128*fs" };
 
-static const struct soc_enum max98090_osr128_enum =
-	SOC_ENUM_SINGLE(M98090_REG_ADC_CONTROL, M98090_OSR128_SHIFT,
-		ARRAY_SIZE(max98090_osr128_text), max98090_osr128_text);
+static SOC_ENUM_SINGLE_DECL(max98090_osr128_enum,
+			    M98090_REG_ADC_CONTROL,
+			    M98090_OSR128_SHIFT,
+			    max98090_osr128_text);
 
 static const char *max98090_mode_text[] = { "Voice", "Music" };
 
-static const struct soc_enum max98090_mode_enum =
-	SOC_ENUM_SINGLE(M98090_REG_FILTER_CONFIG, M98090_MODE_SHIFT,
-		ARRAY_SIZE(max98090_mode_text), max98090_mode_text);
+static SOC_ENUM_SINGLE_DECL(max98090_mode_enum,
+			    M98090_REG_FILTER_CONFIG,
+			    M98090_MODE_SHIFT,
+			    max98090_mode_text);
 
-static const struct soc_enum max98090_filter_dmic34mode_enum =
-	SOC_ENUM_SINGLE(M98090_REG_FILTER_CONFIG,
-		M98090_FLT_DMIC34MODE_SHIFT,
-		ARRAY_SIZE(max98090_mode_text), max98090_mode_text);
+static SOC_ENUM_SINGLE_DECL(max98090_filter_dmic34mode_enum,
+			    M98090_REG_FILTER_CONFIG,
+			    M98090_FLT_DMIC34MODE_SHIFT,
+			    max98090_mode_text);
 
 static const char *max98090_drcatk_text[] =
 	{ "0.5ms", "1ms", "5ms", "10ms", "25ms", "50ms", "100ms", "200ms" };
 
-static const struct soc_enum max98090_drcatk_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DRC_TIMING, M98090_DRCATK_SHIFT,
-		ARRAY_SIZE(max98090_drcatk_text), max98090_drcatk_text);
+static SOC_ENUM_SINGLE_DECL(max98090_drcatk_enum,
+			    M98090_REG_DRC_TIMING,
+			    M98090_DRCATK_SHIFT,
+			    max98090_drcatk_text);
 
 static const char *max98090_drcrls_text[] =
 	{ "8s", "4s", "2s", "1s", "0.5s", "0.25s", "0.125s", "0.0625s" };
 
-static const struct soc_enum max98090_drcrls_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DRC_TIMING, M98090_DRCRLS_SHIFT,
-		ARRAY_SIZE(max98090_drcrls_text), max98090_drcrls_text);
+static SOC_ENUM_SINGLE_DECL(max98090_drcrls_enum,
+			    M98090_REG_DRC_TIMING,
+			    M98090_DRCRLS_SHIFT,
+			    max98090_drcrls_text);
 
 static const char *max98090_alccmp_text[] =
 	{ "1:1", "1:1.5", "1:2", "1:4", "1:INF" };
 
-static const struct soc_enum max98090_alccmp_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DRC_COMPRESSOR, M98090_DRCCMP_SHIFT,
-		ARRAY_SIZE(max98090_alccmp_text), max98090_alccmp_text);
+static SOC_ENUM_SINGLE_DECL(max98090_alccmp_enum,
+			    M98090_REG_DRC_COMPRESSOR,
+			    M98090_DRCCMP_SHIFT,
+			    max98090_alccmp_text);
 
 static const char *max98090_drcexp_text[] = { "1:1", "2:1", "3:1" };
 
-static const struct soc_enum max98090_drcexp_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DRC_EXPANDER, M98090_DRCEXP_SHIFT,
-		ARRAY_SIZE(max98090_drcexp_text), max98090_drcexp_text);
+static SOC_ENUM_SINGLE_DECL(max98090_drcexp_enum,
+			    M98090_REG_DRC_EXPANDER,
+			    M98090_DRCEXP_SHIFT,
+			    max98090_drcexp_text);
 
-static const struct soc_enum max98090_dac_perfmode_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DAC_CONTROL, M98090_PERFMODE_SHIFT,
-		ARRAY_SIZE(max98090_perf_pwr_text), max98090_perf_pwr_text);
+static SOC_ENUM_SINGLE_DECL(max98090_dac_perfmode_enum,
+			    M98090_REG_DAC_CONTROL,
+			    M98090_PERFMODE_SHIFT,
+			    max98090_perf_pwr_text);
 
-static const struct soc_enum max98090_dachp_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DAC_CONTROL, M98090_DACHP_SHIFT,
-		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
+static SOC_ENUM_SINGLE_DECL(max98090_dachp_enum,
+			    M98090_REG_DAC_CONTROL,
+			    M98090_DACHP_SHIFT,
+			    max98090_pwr_perf_text);
 
-static const struct soc_enum max98090_adchp_enum =
-	SOC_ENUM_SINGLE(M98090_REG_ADC_CONTROL, M98090_ADCHP_SHIFT,
-		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
+static SOC_ENUM_SINGLE_DECL(max98090_adchp_enum,
+			    M98090_REG_ADC_CONTROL,
+			    M98090_ADCHP_SHIFT,
+			    max98090_pwr_perf_text);
 
 static const struct snd_kcontrol_new max98090_snd_controls[] = {
 	SOC_ENUM("MIC Bias VCM Bandgap", max98090_vcmbandgap_enum),
@@ -841,39 +851,42 @@ static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 
 static const char *mic1_mux_text[] = { "IN12", "IN56" };
 
-static const struct soc_enum mic1_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_INPUT_MODE, M98090_EXTMIC1_SHIFT,
-		ARRAY_SIZE(mic1_mux_text), mic1_mux_text);
+static SOC_ENUM_SINGLE_DECL(mic1_mux_enum,
+			    M98090_REG_INPUT_MODE,
+			    M98090_EXTMIC1_SHIFT,
+			    mic1_mux_text);
 
 static const struct snd_kcontrol_new max98090_mic1_mux =
 	SOC_DAPM_ENUM("MIC1 Mux", mic1_mux_enum);
 
 static const char *mic2_mux_text[] = { "IN34", "IN56" };
 
-static const struct soc_enum mic2_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_INPUT_MODE, M98090_EXTMIC2_SHIFT,
-		ARRAY_SIZE(mic2_mux_text), mic2_mux_text);
+static SOC_ENUM_SINGLE_DECL(mic2_mux_enum,
+			    M98090_REG_INPUT_MODE,
+			    M98090_EXTMIC2_SHIFT,
+			    mic2_mux_text);
 
 static const struct snd_kcontrol_new max98090_mic2_mux =
 	SOC_DAPM_ENUM("MIC2 Mux", mic2_mux_enum);
 
 static const char *dmic_mux_text[] = { "ADC", "DMIC" };
 
-static const struct soc_enum dmic_mux_enum =
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(dmic_mux_text), dmic_mux_text);
+static SOC_ENUM_SINGLE_EXT_DECL(dmic_mux_enum, dmic_mux_text);
 
 static const struct snd_kcontrol_new max98090_dmic_mux =
 	SOC_DAPM_ENUM_VIRT("DMIC Mux", dmic_mux_enum);
 
 static const char *max98090_micpre_text[] = { "Off", "On" };
 
-static const struct soc_enum max98090_pa1en_enum =
-	SOC_ENUM_SINGLE(M98090_REG_MIC1_INPUT_LEVEL, M98090_MIC_PA1EN_SHIFT,
-		ARRAY_SIZE(max98090_micpre_text), max98090_micpre_text);
+static SOC_ENUM_SINGLE_DECL(max98090_pa1en_enum,
+			    M98090_REG_MIC1_INPUT_LEVEL,
+			    M98090_MIC_PA1EN_SHIFT,
+			    max98090_micpre_text);
 
-static const struct soc_enum max98090_pa2en_enum =
-	SOC_ENUM_SINGLE(M98090_REG_MIC2_INPUT_LEVEL, M98090_MIC_PA2EN_SHIFT,
-		ARRAY_SIZE(max98090_micpre_text), max98090_micpre_text);
+static SOC_ENUM_SINGLE_DECL(max98090_pa2en_enum,
+			    M98090_REG_MIC2_INPUT_LEVEL,
+			    M98090_MIC_PA2EN_SHIFT,
+			    max98090_micpre_text);
 
 /* LINEA mixer switch */
 static const struct snd_kcontrol_new max98090_linea_mixer_controls[] = {
@@ -937,13 +950,15 @@ static const struct snd_kcontrol_new max98090_right_adc_mixer_controls[] = {
 
 static const char *lten_mux_text[] = { "Normal", "Loopthrough" };
 
-static const struct soc_enum ltenl_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LTEN_SHIFT,
-		ARRAY_SIZE(lten_mux_text), lten_mux_text);
+static SOC_ENUM_SINGLE_DECL(ltenl_mux_enum,
+			    M98090_REG_IO_CONFIGURATION,
+			    M98090_LTEN_SHIFT,
+			    lten_mux_text);
 
-static const struct soc_enum ltenr_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LTEN_SHIFT,
-		ARRAY_SIZE(lten_mux_text), lten_mux_text);
+static SOC_ENUM_SINGLE_DECL(ltenr_mux_enum,
+			    M98090_REG_IO_CONFIGURATION,
+			    M98090_LTEN_SHIFT,
+			    lten_mux_text);
 
 static const struct snd_kcontrol_new max98090_ltenl_mux =
 	SOC_DAPM_ENUM("LTENL Mux", ltenl_mux_enum);
@@ -953,13 +968,15 @@ static const struct snd_kcontrol_new max98090_ltenr_mux =
 
 static const char *lben_mux_text[] = { "Normal", "Loopback" };
 
-static const struct soc_enum lbenl_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LBEN_SHIFT,
-		ARRAY_SIZE(lben_mux_text), lben_mux_text);
+static SOC_ENUM_SINGLE_DECL(lbenl_mux_enum,
+			    M98090_REG_IO_CONFIGURATION,
+			    M98090_LBEN_SHIFT,
+			    lben_mux_text);
 
-static const struct soc_enum lbenr_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LBEN_SHIFT,
-		ARRAY_SIZE(lben_mux_text), lben_mux_text);
+static SOC_ENUM_SINGLE_DECL(lbenr_mux_enum,
+			    M98090_REG_IO_CONFIGURATION,
+			    M98090_LBEN_SHIFT,
+			    lben_mux_text);
 
 static const struct snd_kcontrol_new max98090_lbenl_mux =
 	SOC_DAPM_ENUM("LBENL Mux", lbenl_mux_enum);
@@ -971,13 +988,15 @@ static const char *stenl_mux_text[] = { "Normal", "Sidetone Left" };
 
 static const char *stenr_mux_text[] = { "Normal", "Sidetone Right" };
 
-static const struct soc_enum stenl_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_ADC_SIDETONE, M98090_DSTSL_SHIFT,
-		ARRAY_SIZE(stenl_mux_text), stenl_mux_text);
+static SOC_ENUM_SINGLE_DECL(stenl_mux_enum,
+			    M98090_REG_ADC_SIDETONE,
+			    M98090_DSTSL_SHIFT,
+			    stenl_mux_text);
 
-static const struct soc_enum stenr_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_ADC_SIDETONE, M98090_DSTSR_SHIFT,
-		ARRAY_SIZE(stenr_mux_text), stenr_mux_text);
+static SOC_ENUM_SINGLE_DECL(stenr_mux_enum,
+			    M98090_REG_ADC_SIDETONE,
+			    M98090_DSTSR_SHIFT,
+			    stenr_mux_text);
 
 static const struct snd_kcontrol_new max98090_stenl_mux =
 	SOC_DAPM_ENUM("STENL Mux", stenl_mux_enum);
@@ -1085,9 +1104,10 @@ static const struct snd_kcontrol_new max98090_right_rcv_mixer_controls[] = {
 
 static const char *linmod_mux_text[] = { "Left Only", "Left and Right" };
 
-static const struct soc_enum linmod_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_LOUTR_MIXER, M98090_LINMOD_SHIFT,
-		ARRAY_SIZE(linmod_mux_text), linmod_mux_text);
+static SOC_ENUM_SINGLE_DECL(linmod_mux_enum,
+			    M98090_REG_LOUTR_MIXER,
+			    M98090_LINMOD_SHIFT,
+			    linmod_mux_text);
 
 static const struct snd_kcontrol_new max98090_linmod_mux =
 	SOC_DAPM_ENUM("LINMOD Mux", linmod_mux_enum);
@@ -1097,16 +1117,18 @@ static const char *mixhpsel_mux_text[] = { "DAC Only", "HP Mixer" };
 /*
  * This is a mux as it selects the HP output, but to DAPM it is a Mixer enable
  */
-static const struct soc_enum mixhplsel_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_HP_CONTROL, M98090_MIXHPLSEL_SHIFT,
-		ARRAY_SIZE(mixhpsel_mux_text), mixhpsel_mux_text);
+static SOC_ENUM_SINGLE_DECL(mixhplsel_mux_enum,
+			    M98090_REG_HP_CONTROL,
+			    M98090_MIXHPLSEL_SHIFT,
+			    mixhpsel_mux_text);
 
 static const struct snd_kcontrol_new max98090_mixhplsel_mux =
 	SOC_DAPM_ENUM("MIXHPLSEL Mux", mixhplsel_mux_enum);
 
-static const struct soc_enum mixhprsel_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_HP_CONTROL, M98090_MIXHPRSEL_SHIFT,
-		ARRAY_SIZE(mixhpsel_mux_text), mixhpsel_mux_text);
+static SOC_ENUM_SINGLE_DECL(mixhprsel_mux_enum,
+			    M98090_REG_HP_CONTROL,
+			    M98090_MIXHPRSEL_SHIFT,
+			    mixhpsel_mux_text);
 
 static const struct snd_kcontrol_new max98090_mixhprsel_mux =
 	SOC_DAPM_ENUM("MIXHPRSEL Mux", mixhprsel_mux_enum);

commit e126a646f77fdd66978785cb0a3a5e46b07aee2e
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Feb 13 16:54:24 2014 -0700

    ASoC: max98090: make REVISION_ID readable
    
    The REVISION_ID register is not currently marked readable. snd_soc_read()
    refuses to read the register, and hence probe() fails.
    
    Fixes: d4807ad2c4c0 ("regmap: Check readable regs in _regmap_read")
    [exposed the bug, by checking for readability]
    Fixes: 685e42154dcf ("ASoC: Replace max98090 Device Driver")
    [left out this register from the readable list]
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 149b57f6334b..9f714ea86613 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -336,6 +336,7 @@ static bool max98090_readable_register(struct device *dev, unsigned int reg)
 	case M98090_REG_RECORD_TDM_SLOT:
 	case M98090_REG_SAMPLE_RATE:
 	case M98090_REG_DMIC34_BIQUAD_BASE ... M98090_REG_DMIC34_BIQUAD_BASE + 0x0E:
+	case M98090_REG_REVISION_ID:
 		return true;
 	default:
 		return false;

commit c42c8922c46d33ed769e99618bdfba06866a0c72
Author: Dylan Reid <dgreid@chromium.org>
Date:   Wed Feb 12 10:24:54 2014 -0800

    ASoC: max98090: sync regcache on entering STANDBY
    
    Sync regcache when entering STANDBY from OFF.  ON isn't entered with
    OFF as the current state, so the registers were not being re-synced
    after suspend/resume.
    
    The 98088 and 98095 already call regcache_sync from STANDBY.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 51f9b3d16b41..149b57f6334b 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1769,16 +1769,6 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
-		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
-			ret = regcache_sync(max98090->regmap);
-
-			if (ret != 0) {
-				dev_err(codec->dev,
-					"Failed to sync cache: %d\n", ret);
-				return ret;
-			}
-		}
-
 		if (max98090->jack_state == M98090_JACK_STATE_HEADSET) {
 			/*
 			 * Set to normal bias level.
@@ -1792,6 +1782,16 @@ static int max98090_set_bias_level(struct snd_soc_codec *codec,
 		break;
 
 	case SND_SOC_BIAS_STANDBY:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			ret = regcache_sync(max98090->regmap);
+			if (ret != 0) {
+				dev_err(codec->dev,
+					"Failed to sync cache: %d\n", ret);
+				return ret;
+			}
+		}
+		break;
+
 	case SND_SOC_BIAS_OFF:
 		/* Set internal pull-up to lowest power mode */
 		snd_soc_update_bits(codec, M98090_REG_JACK_DETECT,

commit 7821afc4865e976c55403bdb13d798a133efc815
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Jan 8 20:39:30 2014 +0000

    ASoC: max98090: Use params_width() rather than memory format
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 0569a4c3ae00..51f9b3d16b41 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1840,8 +1840,8 @@ static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
 
 	max98090->lrclk = params_rate(params);
 
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S16_LE:
+	switch (params_width(params)) {
+	case 16:
 		snd_soc_update_bits(codec, M98090_REG_INTERFACE_FORMAT,
 			M98090_WS_MASK, 0);
 		break;

commit 2df7c6aad63f432befe51ac3144a96b37fa5b4ba
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jul 18 22:43:00 2013 +0100

    ASoC: max98090: Use power efficient workqueue
    
    None of the delayed work the driver schedules has particularly short delays
    and it is not performance sensitive so let the scheduler run it wherever
    is most efficient rather than in a per CPU workqueue by using the system
    power efficient workqueue.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index ad5313f98f28..0569a4c3ae00 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2084,8 +2084,9 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
 
 		pm_wakeup_event(codec->dev, 100);
 
-		schedule_delayed_work(&max98090->jack_work,
-			msecs_to_jiffies(100));
+		queue_delayed_work(system_power_efficient_wq,
+				   &max98090->jack_work,
+				   msecs_to_jiffies(100));
 	}
 
 	if (active & M98090_DRCACT_MASK)
@@ -2132,8 +2133,9 @@ int max98090_mic_detect(struct snd_soc_codec *codec,
 	snd_soc_jack_report(max98090->jack, 0,
 			    SND_JACK_HEADSET | SND_JACK_BTN_0);
 
-	schedule_delayed_work(&max98090->jack_work,
-		msecs_to_jiffies(100));
+	queue_delayed_work(system_power_efficient_wq,
+			   &max98090->jack_work,
+			   msecs_to_jiffies(100));
 
 	return 0;
 }

commit ff868b229657d5a2e449df7b1e2cc465ec86991d
Merge: 65027372763b 3722dc8ebf04
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jun 17 17:20:23 2013 +0100

    Merge remote-tracking branch 'asoc/topic/max98090' into asoc-next

commit 3722dc8ebf041aedb1075078bd6728a38539a2aa
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Jun 5 19:33:03 2013 +0100

    ASoC: max98090: Guard runtime PM callbacks
    
    Otherwise the functions will be defined but unreferenced when runtime PM
    is disabled, generating warnings.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index cbb272b1f73d..3854d2209676 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2350,6 +2350,7 @@ static int max98090_i2c_remove(struct i2c_client *client)
 	return 0;
 }
 
+#ifdef CONFIG_PM_RUNTIME
 static int max98090_runtime_resume(struct device *dev)
 {
 	struct max98090_priv *max98090 = dev_get_drvdata(dev);
@@ -2369,6 +2370,7 @@ static int max98090_runtime_suspend(struct device *dev)
 
 	return 0;
 }
+#endif
 
 static const struct dev_pm_ops max98090_pm = {
 	SET_RUNTIME_PM_OPS(max98090_runtime_suspend,

commit 3d15aacbb802af72b4ff0c3ba576536cdb3bace0
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Sun May 19 22:58:07 2013 -0700

    ASoC: max98090: request IRQF_ONESHOT interrupt
    
    request_threaded_irq() rejects calls which both do not specify a handler
    (indicating that the primary IRQ handler should be used) and do not set
    IRQF_ONESHOT because the combination is unsafe with level-triggered
    interrupts.  It is safe in this case, though, since max98090 IRQs are
    edge-triggered and the interrupts aren't ACK'ed until the codec's IRQ
    status register is read.  Because of this, an IRQF_ONESHOT interrupt
    doesn't really make a difference, but request one anyway in order to make
    request_threaded_irq() happy.
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index ce0d36412c97..8d14a76c7249 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2233,7 +2233,7 @@ static int max98090_probe(struct snd_soc_codec *codec)
 	dev_dbg(codec->dev, "irq = %d\n", max98090->irq);
 
 	ret = request_threaded_irq(max98090->irq, NULL,
-		max98090_interrupt, IRQF_TRIGGER_FALLING,
+		max98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 		"max98090_interrupt", codec);
 	if (ret < 0) {
 		dev_err(codec->dev, "request_irq failed: %d\n",

commit fd5f940f82cdc0132438a96559b27dd7fd574875
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Thu May 16 12:03:54 2013 -0700

    ASoC: max98090: add digital mic mux to record path
    
    The max98090 driver currently treats the digital mic enable as a supply
    on the record path, causing the digital mic enable to always be turned on
    when attempting to record.  This is incorrect, however, since the digital
    mic enable is also a mux control where 0 selects the ADC output as input
    to the record-path DSP and 1 selects the digital mic.  This patch adds
    a virtual DMIC mux to the reocrd path so that we can switch between the
    ADC and the digital mic for recording.
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index ce0d36412c97..cbb272b1f73d 100644
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -857,6 +857,14 @@ static const struct soc_enum mic2_mux_enum =
 static const struct snd_kcontrol_new max98090_mic2_mux =
 	SOC_DAPM_ENUM("MIC2 Mux", mic2_mux_enum);
 
+static const char *dmic_mux_text[] = { "ADC", "DMIC" };
+
+static const struct soc_enum dmic_mux_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(dmic_mux_text), dmic_mux_text);
+
+static const struct snd_kcontrol_new max98090_dmic_mux =
+	SOC_DAPM_ENUM_VIRT("DMIC Mux", dmic_mux_enum);
+
 static const char *max98090_micpre_text[] = { "Off", "On" };
 
 static const struct soc_enum max98090_pa1en_enum =
@@ -1144,6 +1152,9 @@ static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
 	SND_SOC_DAPM_MUX("MIC2 Mux", SND_SOC_NOPM,
 		0, 0, &max98090_mic2_mux),
 
+	SND_SOC_DAPM_VIRT_MUX("DMIC Mux", SND_SOC_NOPM,
+		0, 0, &max98090_dmic_mux),
+
 	SND_SOC_DAPM_PGA_E("MIC1 Input", M98090_REG_MIC1_INPUT_LEVEL,
 		M98090_MIC_PA1EN_SHIFT, 0, NULL, 0, max98090_micinput_event,
 		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
@@ -1336,11 +1347,14 @@ static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
 	{"ADCL", NULL, "SHDN"},
 	{"ADCR", NULL, "SHDN"},
 
-	{"LBENL Mux", "Normal", "ADCL"},
-	{"LBENL Mux", "Normal", "DMICL"},
+	{"DMIC Mux", "ADC", "ADCL"},
+	{"DMIC Mux", "ADC", "ADCR"},
+	{"DMIC Mux", "DMIC", "DMICL"},
+	{"DMIC Mux", "DMIC", "DMICR"},
+
+	{"LBENL Mux", "Normal", "DMIC Mux"},
 	{"LBENL Mux", "Loopback", "LTENL Mux"},
-	{"LBENR Mux", "Normal", "ADCR"},
-	{"LBENR Mux", "Normal", "DMICR"},
+	{"LBENR Mux", "Normal", "DMIC Mux"},
 	{"LBENR Mux", "Loopback", "LTENR Mux"},
 
 	{"AIFOUTL", NULL, "LBENL Mux"},

commit 8c7df02167854288e20f76915348ffdc9a11e5c2
Merge: 406554fe8d77 959b6250dbf8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Apr 12 13:57:12 2013 +0100

    Merge remote-tracking branch 'asoc/topic/max98090' into asoc-next

commit 4480764f57ba494e3f64003e13223c0b5ec6a2ca
Author: Joe Perches <joe@perches.com>
Date:   Tue Mar 19 14:58:43 2013 -0700

    ASoC:: max98090: Remove executable bit
    
    Source files shouldn't have the executable bit set.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
old mode 100755
new mode 100644

commit 959b6250dbf8398e3c63544f771ff1682a09987e
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Thu Feb 21 12:25:00 2013 +0530

    ASoC: max98090: Remove unnecessary braces
    
    Braces are not required for single line statements.
    Silences the following checkpatch warnings:
    WARNING: braces {} are not necessary for single statement blocks.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 89f83f8e56b2..ce0d36412c97 100755
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -1701,9 +1701,8 @@ static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
 		 * seen for the case of TDM mode. The remaining cases have
 		 * normal logic.
 		 */
-		if (max98090->tdm_slots > 1) {
+		if (max98090->tdm_slots > 1)
 			regval ^= M98090_BCI_MASK;
-		}
 
 		snd_soc_write(codec,
 			M98090_REG_INTERFACE_FORMAT, regval);
@@ -2057,17 +2056,14 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
 	if (!active)
 		return IRQ_NONE;
 
-	if (active & M98090_CLD_MASK) {
+	if (active & M98090_CLD_MASK)
 		dev_err(codec->dev, "M98090_CLD_MASK\n");
-	}
 
-	if (active & M98090_SLD_MASK) {
+	if (active & M98090_SLD_MASK)
 		dev_dbg(codec->dev, "M98090_SLD_MASK\n");
-	}
 
-	if (active & M98090_ULK_MASK) {
+	if (active & M98090_ULK_MASK)
 		dev_err(codec->dev, "M98090_ULK_MASK\n");
-	}
 
 	if (active & M98090_JDET_MASK) {
 		dev_dbg(codec->dev, "M98090_JDET_MASK\n");
@@ -2078,13 +2074,11 @@ static irqreturn_t max98090_interrupt(int irq, void *data)
 			msecs_to_jiffies(100));
 	}
 
-	if (active & M98090_DRCACT_MASK) {
+	if (active & M98090_DRCACT_MASK)
 		dev_dbg(codec->dev, "M98090_DRCACT_MASK\n");
-	}
 
-	if (active & M98090_DRCCLP_MASK) {
+	if (active & M98090_DRCCLP_MASK)
 		dev_err(codec->dev, "M98090_DRCCLP_MASK\n");
-	}
 
 	return IRQ_HANDLED;
 }

commit 4ca74feb6ceb3031e8cf9ef88dedb3ebb984a59a
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Thu Feb 21 12:24:59 2013 +0530

    ASoC: max98090: Fix checkpatch errors related to spacing
    
    Fixes the following type of checkpatch errors:
    ERROR: "foo * bar" should be "foo *bar"
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 1cf017f2f587..89f83f8e56b2 100755
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -507,16 +507,16 @@ static int max98090_put_enab_tlv(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static const char * max98090_perf_pwr_text[] =
+static const char *max98090_perf_pwr_text[] =
 	{ "High Performance", "Low Power" };
-static const char * max98090_pwr_perf_text[] =
+static const char *max98090_pwr_perf_text[] =
 	{ "Low Power", "High Performance" };
 
 static const struct soc_enum max98090_vcmbandgap_enum =
 	SOC_ENUM_SINGLE(M98090_REG_BIAS_CONTROL, M98090_VCM_MODE_SHIFT,
 		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
 
-static const char * max98090_osr128_text[] = { "64*fs", "128*fs" };
+static const char *max98090_osr128_text[] = { "64*fs", "128*fs" };
 
 static const struct soc_enum max98090_osr128_enum =
 	SOC_ENUM_SINGLE(M98090_REG_ADC_CONTROL, M98090_OSR128_SHIFT,
@@ -533,28 +533,28 @@ static const struct soc_enum max98090_filter_dmic34mode_enum =
 		M98090_FLT_DMIC34MODE_SHIFT,
 		ARRAY_SIZE(max98090_mode_text), max98090_mode_text);
 
-static const char * max98090_drcatk_text[] =
+static const char *max98090_drcatk_text[] =
 	{ "0.5ms", "1ms", "5ms", "10ms", "25ms", "50ms", "100ms", "200ms" };
 
 static const struct soc_enum max98090_drcatk_enum =
 	SOC_ENUM_SINGLE(M98090_REG_DRC_TIMING, M98090_DRCATK_SHIFT,
 		ARRAY_SIZE(max98090_drcatk_text), max98090_drcatk_text);
 
-static const char * max98090_drcrls_text[] =
+static const char *max98090_drcrls_text[] =
 	{ "8s", "4s", "2s", "1s", "0.5s", "0.25s", "0.125s", "0.0625s" };
 
 static const struct soc_enum max98090_drcrls_enum =
 	SOC_ENUM_SINGLE(M98090_REG_DRC_TIMING, M98090_DRCRLS_SHIFT,
 		ARRAY_SIZE(max98090_drcrls_text), max98090_drcrls_text);
 
-static const char * max98090_alccmp_text[] =
+static const char *max98090_alccmp_text[] =
 	{ "1:1", "1:1.5", "1:2", "1:4", "1:INF" };
 
 static const struct soc_enum max98090_alccmp_enum =
 	SOC_ENUM_SINGLE(M98090_REG_DRC_COMPRESSOR, M98090_DRCCMP_SHIFT,
 		ARRAY_SIZE(max98090_alccmp_text), max98090_alccmp_text);
 
-static const char * max98090_drcexp_text[] = { "1:1", "2:1", "3:1" };
+static const char *max98090_drcexp_text[] = { "1:1", "2:1", "3:1" };
 
 static const struct soc_enum max98090_drcexp_enum =
 	SOC_ENUM_SINGLE(M98090_REG_DRC_EXPANDER, M98090_DRCEXP_SHIFT,
@@ -857,7 +857,7 @@ static const struct soc_enum mic2_mux_enum =
 static const struct snd_kcontrol_new max98090_mic2_mux =
 	SOC_DAPM_ENUM("MIC2 Mux", mic2_mux_enum);
 
-static const char * max98090_micpre_text[] = { "Off", "On" };
+static const char *max98090_micpre_text[] = { "Off", "On" };
 
 static const struct soc_enum max98090_pa1en_enum =
 	SOC_ENUM_SINGLE(M98090_REG_MIC1_INPUT_LEVEL, M98090_MIC_PA1EN_SHIFT,

commit 3e12af7e139275e5822383e210c86e0ff1ea185c
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Feb 18 17:02:12 2013 +0530

    ASoC: max98090: Make struct dev_pm_ops const
    
    Silences the following checkpatch warning:
    WARNING: struct dev_pm_ops should normally be const.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index fef370e03305..1cf017f2f587 100755
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2362,7 +2362,7 @@ static int max98090_runtime_suspend(struct device *dev)
 	return 0;
 }
 
-static struct dev_pm_ops max98090_pm = {
+static const struct dev_pm_ops max98090_pm = {
 	SET_RUNTIME_PM_OPS(max98090_runtime_suspend,
 		max98090_runtime_resume, NULL)
 };

commit a3a6cc84652d82ff795c519c6187d37baa1d9697
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Feb 18 17:02:11 2013 +0530

    ASoC: max98090: Convert to devm_regmap_init_i2c()
    
    devm_regmap_init_i2c() is device managed and makes error
    handling and code cleanup simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index 9ea73aa71198..fef370e03305 100755
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -2322,7 +2322,7 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 	max98090->pdata = i2c->dev.platform_data;
 	max98090->irq = i2c->irq;
 
-	max98090->regmap = regmap_init_i2c(i2c, &max98090_regmap);
+	max98090->regmap = devm_regmap_init_i2c(i2c, &max98090_regmap);
 	if (IS_ERR(max98090->regmap)) {
 		ret = PTR_ERR(max98090->regmap);
 		dev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);
@@ -2332,18 +2332,13 @@ static int max98090_i2c_probe(struct i2c_client *i2c,
 	ret = snd_soc_register_codec(&i2c->dev,
 			&soc_codec_dev_max98090, max98090_dai,
 			ARRAY_SIZE(max98090_dai));
-	if (ret < 0)
-		regmap_exit(max98090->regmap);
-
 err_enable:
 	return ret;
 }
 
 static int max98090_i2c_remove(struct i2c_client *client)
 {
-	struct max98090_priv *max98090 = dev_get_drvdata(&client->dev);
 	snd_soc_unregister_codec(&client->dev);
-	regmap_exit(max98090->regmap);
 	return 0;
 }
 

commit f314cbe84fd81082a286af685c59c2dc4048bc77
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Feb 18 17:02:10 2013 +0530

    ASoC: max98090: Remove unneeded version.h header include
    
    version.h header file inclusion is not required as detected by versioncheck.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
index fc176044994d..9ea73aa71198 100755
--- a/sound/soc/codecs/max98090.c
+++ b/sound/soc/codecs/max98090.c
@@ -23,8 +23,6 @@
 #include <sound/max98090.h>
 #include "max98090.h"
 
-#include <linux/version.h>
-
 #define DEBUG
 #define EXTMIC_METHOD
 #define EXTMIC_METHOD_TEST

commit 685e42154dcf3f6c0a52c115bd15e3d28ad8621b
Author: Jerry Wong <jerry.wong@maximintegrated.com>
Date:   Wed Feb 6 11:06:37 2013 -0800

    ASoC: Replace max98090 Device Driver
    
    This patch completes the replacement of the existing max98090 driver,
    by installing a more complete driver.
    
    Signed-off-by: Jerry Wong <jerry.wong@maximintegrated.com>
    Tested-by: Matthew Mowdy <matthew.mowdy@maximintegrated.com>
    Reviewed-by: Ralph Birt <ralph.birt@maximintegrated.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
new file mode 100755
index 000000000000..fc176044994d
--- /dev/null
+++ b/sound/soc/codecs/max98090.c
@@ -0,0 +1,2398 @@
+/*
+ * max98090.c -- MAX98090 ALSA SoC Audio driver
+ *
+ * Copyright 2011-2012 Maxim Integrated Products
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <sound/jack.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/max98090.h>
+#include "max98090.h"
+
+#include <linux/version.h>
+
+#define DEBUG
+#define EXTMIC_METHOD
+#define EXTMIC_METHOD_TEST
+
+/* Allows for sparsely populated register maps */
+static struct reg_default max98090_reg[] = {
+	{ 0x00, 0x00 }, /* 00 Software Reset */
+	{ 0x03, 0x04 }, /* 03 Interrupt Masks */
+	{ 0x04, 0x00 }, /* 04 System Clock Quick */
+	{ 0x05, 0x00 }, /* 05 Sample Rate Quick */
+	{ 0x06, 0x00 }, /* 06 DAI Interface Quick */
+	{ 0x07, 0x00 }, /* 07 DAC Path Quick */
+	{ 0x08, 0x00 }, /* 08 Mic/Direct to ADC Quick */
+	{ 0x09, 0x00 }, /* 09 Line to ADC Quick */
+	{ 0x0A, 0x00 }, /* 0A Analog Mic Loop Quick */
+	{ 0x0B, 0x00 }, /* 0B Analog Line Loop Quick */
+	{ 0x0C, 0x00 }, /* 0C Reserved */
+	{ 0x0D, 0x00 }, /* 0D Input Config */
+	{ 0x0E, 0x1B }, /* 0E Line Input Level */
+	{ 0x0F, 0x00 }, /* 0F Line Config */
+
+	{ 0x10, 0x14 }, /* 10 Mic1 Input Level */
+	{ 0x11, 0x14 }, /* 11 Mic2 Input Level */
+	{ 0x12, 0x00 }, /* 12 Mic Bias Voltage */
+	{ 0x13, 0x00 }, /* 13 Digital Mic Config */
+	{ 0x14, 0x00 }, /* 14 Digital Mic Mode */
+	{ 0x15, 0x00 }, /* 15 Left ADC Mixer */
+	{ 0x16, 0x00 }, /* 16 Right ADC Mixer */
+	{ 0x17, 0x03 }, /* 17 Left ADC Level */
+	{ 0x18, 0x03 }, /* 18 Right ADC Level */
+	{ 0x19, 0x00 }, /* 19 ADC Biquad Level */
+	{ 0x1A, 0x00 }, /* 1A ADC Sidetone */
+	{ 0x1B, 0x00 }, /* 1B System Clock */
+	{ 0x1C, 0x00 }, /* 1C Clock Mode */
+	{ 0x1D, 0x00 }, /* 1D Any Clock 1 */
+	{ 0x1E, 0x00 }, /* 1E Any Clock 2 */
+	{ 0x1F, 0x00 }, /* 1F Any Clock 3 */
+
+	{ 0x20, 0x00 }, /* 20 Any Clock 4 */
+	{ 0x21, 0x00 }, /* 21 Master Mode */
+	{ 0x22, 0x00 }, /* 22 Interface Format */
+	{ 0x23, 0x00 }, /* 23 TDM Format 1*/
+	{ 0x24, 0x00 }, /* 24 TDM Format 2*/
+	{ 0x25, 0x00 }, /* 25 I/O Configuration */
+	{ 0x26, 0x80 }, /* 26 Filter Config */
+	{ 0x27, 0x00 }, /* 27 DAI Playback Level */
+	{ 0x28, 0x00 }, /* 28 EQ Playback Level */
+	{ 0x29, 0x00 }, /* 29 Left HP Mixer */
+	{ 0x2A, 0x00 }, /* 2A Right HP Mixer */
+	{ 0x2B, 0x00 }, /* 2B HP Control */
+	{ 0x2C, 0x1A }, /* 2C Left HP Volume */
+	{ 0x2D, 0x1A }, /* 2D Right HP Volume */
+	{ 0x2E, 0x00 }, /* 2E Left Spk Mixer */
+	{ 0x2F, 0x00 }, /* 2F Right Spk Mixer */
+
+	{ 0x30, 0x00 }, /* 30 Spk Control */
+	{ 0x31, 0x2C }, /* 31 Left Spk Volume */
+	{ 0x32, 0x2C }, /* 32 Right Spk Volume */
+	{ 0x33, 0x00 }, /* 33 ALC Timing */
+	{ 0x34, 0x00 }, /* 34 ALC Compressor */
+	{ 0x35, 0x00 }, /* 35 ALC Expander */
+	{ 0x36, 0x00 }, /* 36 ALC Gain */
+	{ 0x37, 0x00 }, /* 37 Rcv/Line OutL Mixer */
+	{ 0x38, 0x00 }, /* 38 Rcv/Line OutL Control */
+	{ 0x39, 0x15 }, /* 39 Rcv/Line OutL Volume */
+	{ 0x3A, 0x00 }, /* 3A Line OutR Mixer */
+	{ 0x3B, 0x00 }, /* 3B Line OutR Control */
+	{ 0x3C, 0x15 }, /* 3C Line OutR Volume */
+	{ 0x3D, 0x00 }, /* 3D Jack Detect */
+	{ 0x3E, 0x00 }, /* 3E Input Enable */
+	{ 0x3F, 0x00 }, /* 3F Output Enable */
+
+	{ 0x40, 0x00 }, /* 40 Level Control */
+	{ 0x41, 0x00 }, /* 41 DSP Filter Enable */
+	{ 0x42, 0x00 }, /* 42 Bias Control */
+	{ 0x43, 0x00 }, /* 43 DAC Control */
+	{ 0x44, 0x06 }, /* 44 ADC Control */
+	{ 0x45, 0x00 }, /* 45 Device Shutdown */
+	{ 0x46, 0x00 }, /* 46 Equalizer Band 1 Coefficient B0 */
+	{ 0x47, 0x00 }, /* 47 Equalizer Band 1 Coefficient B0 */
+	{ 0x48, 0x00 }, /* 48 Equalizer Band 1 Coefficient B0 */
+	{ 0x49, 0x00 }, /* 49 Equalizer Band 1 Coefficient B1 */
+	{ 0x4A, 0x00 }, /* 4A Equalizer Band 1 Coefficient B1 */
+	{ 0x4B, 0x00 }, /* 4B Equalizer Band 1 Coefficient B1 */
+	{ 0x4C, 0x00 }, /* 4C Equalizer Band 1 Coefficient B2 */
+	{ 0x4D, 0x00 }, /* 4D Equalizer Band 1 Coefficient B2 */
+	{ 0x4E, 0x00 }, /* 4E Equalizer Band 1 Coefficient B2 */
+	{ 0x4F, 0x00 }, /* 4F Equalizer Band 1 Coefficient A1 */
+
+	{ 0x50, 0x00 }, /* 50 Equalizer Band 1 Coefficient A1 */
+	{ 0x51, 0x00 }, /* 51 Equalizer Band 1 Coefficient A1 */
+	{ 0x52, 0x00 }, /* 52 Equalizer Band 1 Coefficient A2 */
+	{ 0x53, 0x00 }, /* 53 Equalizer Band 1 Coefficient A2 */
+	{ 0x54, 0x00 }, /* 54 Equalizer Band 1 Coefficient A2 */
+	{ 0x55, 0x00 }, /* 55 Equalizer Band 2 Coefficient B0 */
+	{ 0x56, 0x00 }, /* 56 Equalizer Band 2 Coefficient B0 */
+	{ 0x57, 0x00 }, /* 57 Equalizer Band 2 Coefficient B0 */
+	{ 0x58, 0x00 }, /* 58 Equalizer Band 2 Coefficient B1 */
+	{ 0x59, 0x00 }, /* 59 Equalizer Band 2 Coefficient B1 */
+	{ 0x5A, 0x00 }, /* 5A Equalizer Band 2 Coefficient B1 */
+	{ 0x5B, 0x00 }, /* 5B Equalizer Band 2 Coefficient B2 */
+	{ 0x5C, 0x00 }, /* 5C Equalizer Band 2 Coefficient B2 */
+	{ 0x5D, 0x00 }, /* 5D Equalizer Band 2 Coefficient B2 */
+	{ 0x5E, 0x00 }, /* 5E Equalizer Band 2 Coefficient A1 */
+	{ 0x5F, 0x00 }, /* 5F Equalizer Band 2 Coefficient A1 */
+
+	{ 0x60, 0x00 }, /* 60 Equalizer Band 2 Coefficient A1 */
+	{ 0x61, 0x00 }, /* 61 Equalizer Band 2 Coefficient A2 */
+	{ 0x62, 0x00 }, /* 62 Equalizer Band 2 Coefficient A2 */
+	{ 0x63, 0x00 }, /* 63 Equalizer Band 2 Coefficient A2 */
+	{ 0x64, 0x00 }, /* 64 Equalizer Band 3 Coefficient B0 */
+	{ 0x65, 0x00 }, /* 65 Equalizer Band 3 Coefficient B0 */
+	{ 0x66, 0x00 }, /* 66 Equalizer Band 3 Coefficient B0 */
+	{ 0x67, 0x00 }, /* 67 Equalizer Band 3 Coefficient B1 */
+	{ 0x68, 0x00 }, /* 68 Equalizer Band 3 Coefficient B1 */
+	{ 0x69, 0x00 }, /* 69 Equalizer Band 3 Coefficient B1 */
+	{ 0x6A, 0x00 }, /* 6A Equalizer Band 3 Coefficient B2 */
+	{ 0x6B, 0x00 }, /* 6B Equalizer Band 3 Coefficient B2 */
+	{ 0x6C, 0x00 }, /* 6C Equalizer Band 3 Coefficient B2 */
+	{ 0x6D, 0x00 }, /* 6D Equalizer Band 3 Coefficient A1 */
+	{ 0x6E, 0x00 }, /* 6E Equalizer Band 3 Coefficient A1 */
+	{ 0x6F, 0x00 }, /* 6F Equalizer Band 3 Coefficient A1 */
+
+	{ 0x70, 0x00 }, /* 70 Equalizer Band 3 Coefficient A2 */
+	{ 0x71, 0x00 }, /* 71 Equalizer Band 3 Coefficient A2 */
+	{ 0x72, 0x00 }, /* 72 Equalizer Band 3 Coefficient A2 */
+	{ 0x73, 0x00 }, /* 73 Equalizer Band 4 Coefficient B0 */
+	{ 0x74, 0x00 }, /* 74 Equalizer Band 4 Coefficient B0 */
+	{ 0x75, 0x00 }, /* 75 Equalizer Band 4 Coefficient B0 */
+	{ 0x76, 0x00 }, /* 76 Equalizer Band 4 Coefficient B1 */
+	{ 0x77, 0x00 }, /* 77 Equalizer Band 4 Coefficient B1 */
+	{ 0x78, 0x00 }, /* 78 Equalizer Band 4 Coefficient B1 */
+	{ 0x79, 0x00 }, /* 79 Equalizer Band 4 Coefficient B2 */
+	{ 0x7A, 0x00 }, /* 7A Equalizer Band 4 Coefficient B2 */
+	{ 0x7B, 0x00 }, /* 7B Equalizer Band 4 Coefficient B2 */
+	{ 0x7C, 0x00 }, /* 7C Equalizer Band 4 Coefficient A1 */
+	{ 0x7D, 0x00 }, /* 7D Equalizer Band 4 Coefficient A1 */
+	{ 0x7E, 0x00 }, /* 7E Equalizer Band 4 Coefficient A1 */
+	{ 0x7F, 0x00 }, /* 7F Equalizer Band 4 Coefficient A2 */
+
+	{ 0x80, 0x00 }, /* 80 Equalizer Band 4 Coefficient A2 */
+	{ 0x81, 0x00 }, /* 81 Equalizer Band 4 Coefficient A2 */
+	{ 0x82, 0x00 }, /* 82 Equalizer Band 5 Coefficient B0 */
+	{ 0x83, 0x00 }, /* 83 Equalizer Band 5 Coefficient B0 */
+	{ 0x84, 0x00 }, /* 84 Equalizer Band 5 Coefficient B0 */
+	{ 0x85, 0x00 }, /* 85 Equalizer Band 5 Coefficient B1 */
+	{ 0x86, 0x00 }, /* 86 Equalizer Band 5 Coefficient B1 */
+	{ 0x87, 0x00 }, /* 87 Equalizer Band 5 Coefficient B1 */
+	{ 0x88, 0x00 }, /* 88 Equalizer Band 5 Coefficient B2 */
+	{ 0x89, 0x00 }, /* 89 Equalizer Band 5 Coefficient B2 */
+	{ 0x8A, 0x00 }, /* 8A Equalizer Band 5 Coefficient B2 */
+	{ 0x8B, 0x00 }, /* 8B Equalizer Band 5 Coefficient A1 */
+	{ 0x8C, 0x00 }, /* 8C Equalizer Band 5 Coefficient A1 */
+	{ 0x8D, 0x00 }, /* 8D Equalizer Band 5 Coefficient A1 */
+	{ 0x8E, 0x00 }, /* 8E Equalizer Band 5 Coefficient A2 */
+	{ 0x8F, 0x00 }, /* 8F Equalizer Band 5 Coefficient A2 */
+
+	{ 0x90, 0x00 }, /* 90 Equalizer Band 5 Coefficient A2 */
+	{ 0x91, 0x00 }, /* 91 Equalizer Band 6 Coefficient B0 */
+	{ 0x92, 0x00 }, /* 92 Equalizer Band 6 Coefficient B0 */
+	{ 0x93, 0x00 }, /* 93 Equalizer Band 6 Coefficient B0 */
+	{ 0x94, 0x00 }, /* 94 Equalizer Band 6 Coefficient B1 */
+	{ 0x95, 0x00 }, /* 95 Equalizer Band 6 Coefficient B1 */
+	{ 0x96, 0x00 }, /* 96 Equalizer Band 6 Coefficient B1 */
+	{ 0x97, 0x00 }, /* 97 Equalizer Band 6 Coefficient B2 */
+	{ 0x98, 0x00 }, /* 98 Equalizer Band 6 Coefficient B2 */
+	{ 0x99, 0x00 }, /* 99 Equalizer Band 6 Coefficient B2 */
+	{ 0x9A, 0x00 }, /* 9A Equalizer Band 6 Coefficient A1 */
+	{ 0x9B, 0x00 }, /* 9B Equalizer Band 6 Coefficient A1 */
+	{ 0x9C, 0x00 }, /* 9C Equalizer Band 6 Coefficient A1 */
+	{ 0x9D, 0x00 }, /* 9D Equalizer Band 6 Coefficient A2 */
+	{ 0x9E, 0x00 }, /* 9E Equalizer Band 6 Coefficient A2 */
+	{ 0x9F, 0x00 }, /* 9F Equalizer Band 6 Coefficient A2 */
+
+	{ 0xA0, 0x00 }, /* A0 Equalizer Band 7 Coefficient B0 */
+	{ 0xA1, 0x00 }, /* A1 Equalizer Band 7 Coefficient B0 */
+	{ 0xA2, 0x00 }, /* A2 Equalizer Band 7 Coefficient B0 */
+	{ 0xA3, 0x00 }, /* A3 Equalizer Band 7 Coefficient B1 */
+	{ 0xA4, 0x00 }, /* A4 Equalizer Band 7 Coefficient B1 */
+	{ 0xA5, 0x00 }, /* A5 Equalizer Band 7 Coefficient B1 */
+	{ 0xA6, 0x00 }, /* A6 Equalizer Band 7 Coefficient B2 */
+	{ 0xA7, 0x00 }, /* A7 Equalizer Band 7 Coefficient B2 */
+	{ 0xA8, 0x00 }, /* A8 Equalizer Band 7 Coefficient B2 */
+	{ 0xA9, 0x00 }, /* A9 Equalizer Band 7 Coefficient A1 */
+	{ 0xAA, 0x00 }, /* AA Equalizer Band 7 Coefficient A1 */
+	{ 0xAB, 0x00 }, /* AB Equalizer Band 7 Coefficient A1 */
+	{ 0xAC, 0x00 }, /* AC Equalizer Band 7 Coefficient A2 */
+	{ 0xAD, 0x00 }, /* AD Equalizer Band 7 Coefficient A2 */
+	{ 0xAE, 0x00 }, /* AE Equalizer Band 7 Coefficient A2 */
+	{ 0xAF, 0x00 }, /* AF ADC Biquad Coefficient B0 */
+
+	{ 0xB0, 0x00 }, /* B0 ADC Biquad Coefficient B0 */
+	{ 0xB1, 0x00 }, /* B1 ADC Biquad Coefficient B0 */
+	{ 0xB2, 0x00 }, /* B2 ADC Biquad Coefficient B1 */
+	{ 0xB3, 0x00 }, /* B3 ADC Biquad Coefficient B1 */
+	{ 0xB4, 0x00 }, /* B4 ADC Biquad Coefficient B1 */
+	{ 0xB5, 0x00 }, /* B5 ADC Biquad Coefficient B2 */
+	{ 0xB6, 0x00 }, /* B6 ADC Biquad Coefficient B2 */
+	{ 0xB7, 0x00 }, /* B7 ADC Biquad Coefficient B2 */
+	{ 0xB8, 0x00 }, /* B8 ADC Biquad Coefficient A1 */
+	{ 0xB9, 0x00 }, /* B9 ADC Biquad Coefficient A1 */
+	{ 0xBA, 0x00 }, /* BA ADC Biquad Coefficient A1 */
+	{ 0xBB, 0x00 }, /* BB ADC Biquad Coefficient A2 */
+	{ 0xBC, 0x00 }, /* BC ADC Biquad Coefficient A2 */
+	{ 0xBD, 0x00 }, /* BD ADC Biquad Coefficient A2 */
+	{ 0xBE, 0x00 }, /* BE Digital Mic 3 Volume */
+	{ 0xBF, 0x00 }, /* BF Digital Mic 4 Volume */
+
+	{ 0xC0, 0x00 }, /* C0 Digital Mic 34 Biquad Pre Atten */
+	{ 0xC1, 0x00 }, /* C1 Record TDM Slot */
+	{ 0xC2, 0x00 }, /* C2 Sample Rate */
+	{ 0xC3, 0x00 }, /* C3 Digital Mic 34 Biquad Coefficient C3 */
+	{ 0xC4, 0x00 }, /* C4 Digital Mic 34 Biquad Coefficient C4 */
+	{ 0xC5, 0x00 }, /* C5 Digital Mic 34 Biquad Coefficient C5 */
+	{ 0xC6, 0x00 }, /* C6 Digital Mic 34 Biquad Coefficient C6 */
+	{ 0xC7, 0x00 }, /* C7 Digital Mic 34 Biquad Coefficient C7 */
+	{ 0xC8, 0x00 }, /* C8 Digital Mic 34 Biquad Coefficient C8 */
+	{ 0xC9, 0x00 }, /* C9 Digital Mic 34 Biquad Coefficient C9 */
+	{ 0xCA, 0x00 }, /* CA Digital Mic 34 Biquad Coefficient CA */
+	{ 0xCB, 0x00 }, /* CB Digital Mic 34 Biquad Coefficient CB */
+	{ 0xCC, 0x00 }, /* CC Digital Mic 34 Biquad Coefficient CC */
+	{ 0xCD, 0x00 }, /* CD Digital Mic 34 Biquad Coefficient CD */
+	{ 0xCE, 0x00 }, /* CE Digital Mic 34 Biquad Coefficient CE */
+	{ 0xCF, 0x00 }, /* CF Digital Mic 34 Biquad Coefficient CF */
+
+	{ 0xD0, 0x00 }, /* D0 Digital Mic 34 Biquad Coefficient D0 */
+	{ 0xD1, 0x00 }, /* D1 Digital Mic 34 Biquad Coefficient D1 */
+};
+
+static bool max98090_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case M98090_REG_DEVICE_STATUS:
+	case M98090_REG_JACK_STATUS:
+	case M98090_REG_REVISION_ID:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool max98090_readable_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case M98090_REG_DEVICE_STATUS:
+	case M98090_REG_JACK_STATUS:
+	case M98090_REG_INTERRUPT_S:
+	case M98090_REG_RESERVED:
+	case M98090_REG_LINE_INPUT_CONFIG:
+	case M98090_REG_LINE_INPUT_LEVEL:
+	case M98090_REG_INPUT_MODE:
+	case M98090_REG_MIC1_INPUT_LEVEL:
+	case M98090_REG_MIC2_INPUT_LEVEL:
+	case M98090_REG_MIC_BIAS_VOLTAGE:
+	case M98090_REG_DIGITAL_MIC_ENABLE:
+	case M98090_REG_DIGITAL_MIC_CONFIG:
+	case M98090_REG_LEFT_ADC_MIXER:
+	case M98090_REG_RIGHT_ADC_MIXER:
+	case M98090_REG_LEFT_ADC_LEVEL:
+	case M98090_REG_RIGHT_ADC_LEVEL:
+	case M98090_REG_ADC_BIQUAD_LEVEL:
+	case M98090_REG_ADC_SIDETONE:
+	case M98090_REG_SYSTEM_CLOCK:
+	case M98090_REG_CLOCK_MODE:
+	case M98090_REG_CLOCK_RATIO_NI_MSB:
+	case M98090_REG_CLOCK_RATIO_NI_LSB:
+	case M98090_REG_CLOCK_RATIO_MI_MSB:
+	case M98090_REG_CLOCK_RATIO_MI_LSB:
+	case M98090_REG_MASTER_MODE:
+	case M98090_REG_INTERFACE_FORMAT:
+	case M98090_REG_TDM_CONTROL:
+	case M98090_REG_TDM_FORMAT:
+	case M98090_REG_IO_CONFIGURATION:
+	case M98090_REG_FILTER_CONFIG:
+	case M98090_REG_DAI_PLAYBACK_LEVEL:
+	case M98090_REG_DAI_PLAYBACK_LEVEL_EQ:
+	case M98090_REG_LEFT_HP_MIXER:
+	case M98090_REG_RIGHT_HP_MIXER:
+	case M98090_REG_HP_CONTROL:
+	case M98090_REG_LEFT_HP_VOLUME:
+	case M98090_REG_RIGHT_HP_VOLUME:
+	case M98090_REG_LEFT_SPK_MIXER:
+	case M98090_REG_RIGHT_SPK_MIXER:
+	case M98090_REG_SPK_CONTROL:
+	case M98090_REG_LEFT_SPK_VOLUME:
+	case M98090_REG_RIGHT_SPK_VOLUME:
+	case M98090_REG_DRC_TIMING:
+	case M98090_REG_DRC_COMPRESSOR:
+	case M98090_REG_DRC_EXPANDER:
+	case M98090_REG_DRC_GAIN:
+	case M98090_REG_RCV_LOUTL_MIXER:
+	case M98090_REG_RCV_LOUTL_CONTROL:
+	case M98090_REG_RCV_LOUTL_VOLUME:
+	case M98090_REG_LOUTR_MIXER:
+	case M98090_REG_LOUTR_CONTROL:
+	case M98090_REG_LOUTR_VOLUME:
+	case M98090_REG_JACK_DETECT:
+	case M98090_REG_INPUT_ENABLE:
+	case M98090_REG_OUTPUT_ENABLE:
+	case M98090_REG_LEVEL_CONTROL:
+	case M98090_REG_DSP_FILTER_ENABLE:
+	case M98090_REG_BIAS_CONTROL:
+	case M98090_REG_DAC_CONTROL:
+	case M98090_REG_ADC_CONTROL:
+	case M98090_REG_DEVICE_SHUTDOWN:
+	case M98090_REG_EQUALIZER_BASE ... M98090_REG_EQUALIZER_BASE + 0x68:
+	case M98090_REG_RECORD_BIQUAD_BASE ... M98090_REG_RECORD_BIQUAD_BASE + 0x0E:
+	case M98090_REG_DMIC3_VOLUME:
+	case M98090_REG_DMIC4_VOLUME:
+	case M98090_REG_DMIC34_BQ_PREATTEN:
+	case M98090_REG_RECORD_TDM_SLOT:
+	case M98090_REG_SAMPLE_RATE:
+	case M98090_REG_DMIC34_BIQUAD_BASE ... M98090_REG_DMIC34_BIQUAD_BASE + 0x0E:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int max98090_reset(struct max98090_priv *max98090)
+{
+	int ret;
+
+	/* Reset the codec by writing to this write-only reset register */
+	ret = regmap_write(max98090->regmap, M98090_REG_SOFTWARE_RESET,
+		M98090_SWRESET_MASK);
+	if (ret < 0) {
+		dev_err(max98090->codec->dev,
+			"Failed to reset codec: %d\n", ret);
+		return ret;
+	}
+
+	msleep(20);
+	return ret;
+}
+
+static const unsigned int max98090_micboost_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 1, TLV_DB_SCALE_ITEM(0, 2000, 0),
+	2, 2, TLV_DB_SCALE_ITEM(3000, 0, 0),
+};
+
+static const DECLARE_TLV_DB_SCALE(max98090_mic_tlv, 0, 100, 0);
+
+static const DECLARE_TLV_DB_SCALE(max98090_line_single_ended_tlv,
+	-600, 600, 0);
+
+static const unsigned int max98090_line_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 3, TLV_DB_SCALE_ITEM(-600, 300, 0),
+	4, 5, TLV_DB_SCALE_ITEM(1400, 600, 0),
+};
+
+static const DECLARE_TLV_DB_SCALE(max98090_avg_tlv, 0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(max98090_av_tlv, -1200, 100, 0);
+
+static const DECLARE_TLV_DB_SCALE(max98090_dvg_tlv, 0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(max98090_dv_tlv, -1500, 100, 0);
+
+static const DECLARE_TLV_DB_SCALE(max98090_sidetone_tlv, -6050, 200, 0);
+
+static const DECLARE_TLV_DB_SCALE(max98090_alc_tlv, -1500, 100, 0);
+static const DECLARE_TLV_DB_SCALE(max98090_alcmakeup_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(max98090_alccomp_tlv, -3100, 100, 0);
+static const DECLARE_TLV_DB_SCALE(max98090_drcexp_tlv, -6600, 100, 0);
+
+static const unsigned int max98090_mixout_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 1, TLV_DB_SCALE_ITEM(-1200, 250, 0),
+	2, 3, TLV_DB_SCALE_ITEM(-600, 600, 0),
+};
+
+static const unsigned int max98090_hp_tlv[] = {
+	TLV_DB_RANGE_HEAD(5),
+	0, 6, TLV_DB_SCALE_ITEM(-6700, 400, 0),
+	7, 14, TLV_DB_SCALE_ITEM(-4000, 300, 0),
+	15, 21, TLV_DB_SCALE_ITEM(-1700, 200, 0),
+	22, 27, TLV_DB_SCALE_ITEM(-400, 100, 0),
+	28, 31, TLV_DB_SCALE_ITEM(150, 50, 0),
+};
+
+static const unsigned int max98090_spk_tlv[] = {
+	TLV_DB_RANGE_HEAD(5),
+	0, 4, TLV_DB_SCALE_ITEM(-4800, 400, 0),
+	5, 10, TLV_DB_SCALE_ITEM(-2900, 300, 0),
+	11, 14, TLV_DB_SCALE_ITEM(-1200, 200, 0),
+	15, 29, TLV_DB_SCALE_ITEM(-500, 100, 0),
+	30, 39, TLV_DB_SCALE_ITEM(950, 50, 0),
+};
+
+static const unsigned int max98090_rcv_lout_tlv[] = {
+	TLV_DB_RANGE_HEAD(5),
+	0, 6, TLV_DB_SCALE_ITEM(-6200, 400, 0),
+	7, 14, TLV_DB_SCALE_ITEM(-3500, 300, 0),
+	15, 21, TLV_DB_SCALE_ITEM(-1200, 200, 0),
+	22, 27, TLV_DB_SCALE_ITEM(100, 100, 0),
+	28, 31, TLV_DB_SCALE_ITEM(650, 50, 0),
+};
+
+static int max98090_get_enab_tlv(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int mask = (1 << fls(mc->max)) - 1;
+	unsigned int val = snd_soc_read(codec, mc->reg);
+	unsigned int *select;
+
+	switch (mc->reg) {
+	case M98090_REG_MIC1_INPUT_LEVEL:
+		select = &(max98090->pa1en);
+		break;
+	case M98090_REG_MIC2_INPUT_LEVEL:
+		select = &(max98090->pa2en);
+		break;
+	case M98090_REG_ADC_SIDETONE:
+		select = &(max98090->sidetone);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	val = (val >> mc->shift) & mask;
+
+	if (val >= 1) {
+		/* If on, return the volume */
+		val = val - 1;
+		*select = val;
+	} else {
+		/* If off, return last stored value */
+		val = *select;
+	}
+
+	ucontrol->value.integer.value[0] = val;
+	return 0;
+}
+
+static int max98090_put_enab_tlv(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int mask = (1 << fls(mc->max)) - 1;
+	unsigned int sel = ucontrol->value.integer.value[0];
+	unsigned int val = snd_soc_read(codec, mc->reg);
+	unsigned int *select;
+
+	switch (mc->reg) {
+	case M98090_REG_MIC1_INPUT_LEVEL:
+		select = &(max98090->pa1en);
+		break;
+	case M98090_REG_MIC2_INPUT_LEVEL:
+		select = &(max98090->pa2en);
+		break;
+	case M98090_REG_ADC_SIDETONE:
+		select = &(max98090->sidetone);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	val = (val >> mc->shift) & mask;
+
+	*select = sel;
+
+	/* Setting a volume is only valid if it is already On */
+	if (val >= 1) {
+		sel = sel + 1;
+	} else {
+		/* Write what was already there */
+		sel = val;
+	}
+
+	snd_soc_update_bits(codec, mc->reg,
+		mask << mc->shift,
+		sel << mc->shift);
+
+	return 0;
+}
+
+static const char * max98090_perf_pwr_text[] =
+	{ "High Performance", "Low Power" };
+static const char * max98090_pwr_perf_text[] =
+	{ "Low Power", "High Performance" };
+
+static const struct soc_enum max98090_vcmbandgap_enum =
+	SOC_ENUM_SINGLE(M98090_REG_BIAS_CONTROL, M98090_VCM_MODE_SHIFT,
+		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
+
+static const char * max98090_osr128_text[] = { "64*fs", "128*fs" };
+
+static const struct soc_enum max98090_osr128_enum =
+	SOC_ENUM_SINGLE(M98090_REG_ADC_CONTROL, M98090_OSR128_SHIFT,
+		ARRAY_SIZE(max98090_osr128_text), max98090_osr128_text);
+
+static const char *max98090_mode_text[] = { "Voice", "Music" };
+
+static const struct soc_enum max98090_mode_enum =
+	SOC_ENUM_SINGLE(M98090_REG_FILTER_CONFIG, M98090_MODE_SHIFT,
+		ARRAY_SIZE(max98090_mode_text), max98090_mode_text);
+
+static const struct soc_enum max98090_filter_dmic34mode_enum =
+	SOC_ENUM_SINGLE(M98090_REG_FILTER_CONFIG,
+		M98090_FLT_DMIC34MODE_SHIFT,
+		ARRAY_SIZE(max98090_mode_text), max98090_mode_text);
+
+static const char * max98090_drcatk_text[] =
+	{ "0.5ms", "1ms", "5ms", "10ms", "25ms", "50ms", "100ms", "200ms" };
+
+static const struct soc_enum max98090_drcatk_enum =
+	SOC_ENUM_SINGLE(M98090_REG_DRC_TIMING, M98090_DRCATK_SHIFT,
+		ARRAY_SIZE(max98090_drcatk_text), max98090_drcatk_text);
+
+static const char * max98090_drcrls_text[] =
+	{ "8s", "4s", "2s", "1s", "0.5s", "0.25s", "0.125s", "0.0625s" };
+
+static const struct soc_enum max98090_drcrls_enum =
+	SOC_ENUM_SINGLE(M98090_REG_DRC_TIMING, M98090_DRCRLS_SHIFT,
+		ARRAY_SIZE(max98090_drcrls_text), max98090_drcrls_text);
+
+static const char * max98090_alccmp_text[] =
+	{ "1:1", "1:1.5", "1:2", "1:4", "1:INF" };
+
+static const struct soc_enum max98090_alccmp_enum =
+	SOC_ENUM_SINGLE(M98090_REG_DRC_COMPRESSOR, M98090_DRCCMP_SHIFT,
+		ARRAY_SIZE(max98090_alccmp_text), max98090_alccmp_text);
+
+static const char * max98090_drcexp_text[] = { "1:1", "2:1", "3:1" };
+
+static const struct soc_enum max98090_drcexp_enum =
+	SOC_ENUM_SINGLE(M98090_REG_DRC_EXPANDER, M98090_DRCEXP_SHIFT,
+		ARRAY_SIZE(max98090_drcexp_text), max98090_drcexp_text);
+
+static const struct soc_enum max98090_dac_perfmode_enum =
+	SOC_ENUM_SINGLE(M98090_REG_DAC_CONTROL, M98090_PERFMODE_SHIFT,
+		ARRAY_SIZE(max98090_perf_pwr_text), max98090_perf_pwr_text);
+
+static const struct soc_enum max98090_dachp_enum =
+	SOC_ENUM_SINGLE(M98090_REG_DAC_CONTROL, M98090_DACHP_SHIFT,
+		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
+
+static const struct soc_enum max98090_adchp_enum =
+	SOC_ENUM_SINGLE(M98090_REG_ADC_CONTROL, M98090_ADCHP_SHIFT,
+		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
+
+static const struct snd_kcontrol_new max98090_snd_controls[] = {
+	SOC_ENUM("MIC Bias VCM Bandgap", max98090_vcmbandgap_enum),
+
+	SOC_SINGLE("DMIC MIC Comp Filter Config", M98090_REG_DIGITAL_MIC_CONFIG,
+		M98090_DMIC_COMP_SHIFT, M98090_DMIC_COMP_NUM - 1, 0),
+
+	SOC_SINGLE_EXT_TLV("MIC1 Boost Volume",
+		M98090_REG_MIC1_INPUT_LEVEL, M98090_MIC_PA1EN_SHIFT,
+		M98090_MIC_PA1EN_NUM - 1, 0, max98090_get_enab_tlv,
+		max98090_put_enab_tlv, max98090_micboost_tlv),
+
+	SOC_SINGLE_EXT_TLV("MIC2 Boost Volume",
+		M98090_REG_MIC2_INPUT_LEVEL, M98090_MIC_PA2EN_SHIFT,
+		M98090_MIC_PA2EN_NUM - 1, 0, max98090_get_enab_tlv,
+		max98090_put_enab_tlv, max98090_micboost_tlv),
+
+	SOC_SINGLE_TLV("MIC1 Volume", M98090_REG_MIC1_INPUT_LEVEL,
+		M98090_MIC_PGAM1_SHIFT, M98090_MIC_PGAM1_NUM - 1, 1,
+		max98090_mic_tlv),
+
+	SOC_SINGLE_TLV("MIC2 Volume", M98090_REG_MIC2_INPUT_LEVEL,
+		M98090_MIC_PGAM2_SHIFT, M98090_MIC_PGAM2_NUM - 1, 1,
+		max98090_mic_tlv),
+
+	SOC_SINGLE_RANGE_TLV("LINEA Single Ended Volume",
+		M98090_REG_LINE_INPUT_LEVEL, M98090_MIXG135_SHIFT, 0,
+		M98090_MIXG135_NUM - 1, 1, max98090_line_single_ended_tlv),
+
+	SOC_SINGLE_RANGE_TLV("LINEB Single Ended Volume",
+		M98090_REG_LINE_INPUT_LEVEL, M98090_MIXG246_SHIFT, 0,
+		M98090_MIXG246_NUM - 1, 1, max98090_line_single_ended_tlv),
+
+	SOC_SINGLE_RANGE_TLV("LINEA Volume", M98090_REG_LINE_INPUT_LEVEL,
+		M98090_LINAPGA_SHIFT, 0, M98090_LINAPGA_NUM - 1, 1,
+		max98090_line_tlv),
+
+	SOC_SINGLE_RANGE_TLV("LINEB Volume", M98090_REG_LINE_INPUT_LEVEL,
+		M98090_LINBPGA_SHIFT, 0, M98090_LINBPGA_NUM - 1, 1,
+		max98090_line_tlv),
+
+	SOC_SINGLE("LINEA Ext Resistor Gain Mode", M98090_REG_INPUT_MODE,
+		M98090_EXTBUFA_SHIFT, M98090_EXTBUFA_NUM - 1, 0),
+	SOC_SINGLE("LINEB Ext Resistor Gain Mode", M98090_REG_INPUT_MODE,
+		M98090_EXTBUFB_SHIFT, M98090_EXTBUFB_NUM - 1, 0),
+
+	SOC_SINGLE_TLV("ADCL Boost Volume", M98090_REG_LEFT_ADC_LEVEL,
+		M98090_AVLG_SHIFT, M98090_AVLG_NUM - 1, 0,
+		max98090_avg_tlv),
+	SOC_SINGLE_TLV("ADCR Boost Volume", M98090_REG_RIGHT_ADC_LEVEL,
+		M98090_AVRG_SHIFT, M98090_AVLG_NUM - 1, 0,
+		max98090_avg_tlv),
+
+	SOC_SINGLE_TLV("ADCL Volume", M98090_REG_LEFT_ADC_LEVEL,
+		M98090_AVL_SHIFT, M98090_AVL_NUM - 1, 1,
+		max98090_av_tlv),
+	SOC_SINGLE_TLV("ADCR Volume", M98090_REG_RIGHT_ADC_LEVEL,
+		M98090_AVR_SHIFT, M98090_AVR_NUM - 1, 1,
+		max98090_av_tlv),
+
+	SOC_ENUM("ADC Oversampling Rate", max98090_osr128_enum),
+	SOC_SINGLE("ADC Quantizer Dither", M98090_REG_ADC_CONTROL,
+		M98090_ADCDITHER_SHIFT, M98090_ADCDITHER_NUM - 1, 0),
+	SOC_ENUM("ADC High Performance Mode", max98090_adchp_enum),
+
+	SOC_SINGLE("DAC Mono Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_DMONO_SHIFT, M98090_DMONO_NUM - 1, 0),
+	SOC_SINGLE("SDIN Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_SDIEN_SHIFT, M98090_SDIEN_NUM - 1, 0),
+	SOC_SINGLE("SDOUT Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_SDOEN_SHIFT, M98090_SDOEN_NUM - 1, 0),
+	SOC_SINGLE("SDOUT Hi-Z Mode", M98090_REG_IO_CONFIGURATION,
+		M98090_HIZOFF_SHIFT, M98090_HIZOFF_NUM - 1, 1),
+	SOC_ENUM("Filter Mode", max98090_mode_enum),
+	SOC_SINGLE("Record Path DC Blocking", M98090_REG_FILTER_CONFIG,
+		M98090_AHPF_SHIFT, M98090_AHPF_NUM - 1, 0),
+	SOC_SINGLE("Playback Path DC Blocking", M98090_REG_FILTER_CONFIG,
+		M98090_DHPF_SHIFT, M98090_DHPF_NUM - 1, 0),
+	SOC_SINGLE_TLV("Digital BQ Volume", M98090_REG_ADC_BIQUAD_LEVEL,
+		M98090_AVBQ_SHIFT, M98090_AVBQ_NUM - 1, 1, max98090_dv_tlv),
+	SOC_SINGLE_EXT_TLV("Digital Sidetone Volume",
+		M98090_REG_ADC_SIDETONE, M98090_DVST_SHIFT,
+		M98090_DVST_NUM - 1, 1, max98090_get_enab_tlv,
+		max98090_put_enab_tlv, max98090_micboost_tlv),
+	SOC_SINGLE_TLV("Digital Coarse Volume", M98090_REG_DAI_PLAYBACK_LEVEL,
+		M98090_DVG_SHIFT, M98090_DVG_NUM - 1, 0,
+		max98090_dvg_tlv),
+	SOC_SINGLE_TLV("Digital Volume", M98090_REG_DAI_PLAYBACK_LEVEL,
+		M98090_DV_SHIFT, M98090_DV_NUM - 1, 1,
+		max98090_dv_tlv),
+	SND_SOC_BYTES("EQ Coefficients", M98090_REG_EQUALIZER_BASE, 105),
+	SOC_SINGLE("Digital EQ 3 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_EQ3BANDEN_SHIFT, M98090_EQ3BANDEN_NUM - 1, 0),
+	SOC_SINGLE("Digital EQ 5 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_EQ5BANDEN_SHIFT, M98090_EQ5BANDEN_NUM - 1, 0),
+	SOC_SINGLE("Digital EQ 7 Band Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_EQ7BANDEN_SHIFT, M98090_EQ7BANDEN_NUM - 1, 0),
+	SOC_SINGLE("Digital EQ Clipping Detection", M98090_REG_DAI_PLAYBACK_LEVEL_EQ,
+		M98090_EQCLPN_SHIFT, M98090_EQCLPN_NUM - 1,
+		1),
+	SOC_SINGLE_TLV("Digital EQ Volume", M98090_REG_DAI_PLAYBACK_LEVEL_EQ,
+		M98090_DVEQ_SHIFT, M98090_DVEQ_NUM - 1, 1,
+		max98090_dv_tlv),
+
+	SOC_SINGLE("ALC Enable", M98090_REG_DRC_TIMING,
+		M98090_DRCEN_SHIFT, M98090_DRCEN_NUM - 1, 0),
+	SOC_ENUM("ALC Attack Time", max98090_drcatk_enum),
+	SOC_ENUM("ALC Release Time", max98090_drcrls_enum),
+	SOC_SINGLE_TLV("ALC Make Up Volume", M98090_REG_DRC_GAIN,
+		M98090_DRCG_SHIFT, M98090_DRCG_NUM - 1, 0,
+		max98090_alcmakeup_tlv),
+	SOC_ENUM("ALC Compression Ratio", max98090_alccmp_enum),
+	SOC_ENUM("ALC Expansion Ratio", max98090_drcexp_enum),
+	SOC_SINGLE_TLV("ALC Compression Threshold Volume",
+		M98090_REG_DRC_COMPRESSOR, M98090_DRCTHC_SHIFT,
+		M98090_DRCTHC_NUM - 1, 1, max98090_alccomp_tlv),
+	SOC_SINGLE_TLV("ALC Expansion Threshold Volume",
+		M98090_REG_DRC_EXPANDER, M98090_DRCTHE_SHIFT,
+		M98090_DRCTHE_NUM - 1, 1, max98090_drcexp_tlv),
+
+	SOC_ENUM("DAC HP Playback Performance Mode",
+		max98090_dac_perfmode_enum),
+	SOC_ENUM("DAC High Performance Mode", max98090_dachp_enum),
+
+	SOC_SINGLE_TLV("Headphone Left Mixer Volume",
+		M98090_REG_HP_CONTROL, M98090_MIXHPLG_SHIFT,
+		M98090_MIXHPLG_NUM - 1, 1, max98090_mixout_tlv),
+	SOC_SINGLE_TLV("Headphone Right Mixer Volume",
+		M98090_REG_HP_CONTROL, M98090_MIXHPRG_SHIFT,
+		M98090_MIXHPRG_NUM - 1, 1, max98090_mixout_tlv),
+
+	SOC_SINGLE_TLV("Speaker Left Mixer Volume",
+		M98090_REG_SPK_CONTROL, M98090_MIXSPLG_SHIFT,
+		M98090_MIXSPLG_NUM - 1, 1, max98090_mixout_tlv),
+	SOC_SINGLE_TLV("Speaker Right Mixer Volume",
+		M98090_REG_SPK_CONTROL, M98090_MIXSPRG_SHIFT,
+		M98090_MIXSPRG_NUM - 1, 1, max98090_mixout_tlv),
+
+	SOC_SINGLE_TLV("Receiver Left Mixer Volume",
+		M98090_REG_RCV_LOUTL_CONTROL, M98090_MIXRCVLG_SHIFT,
+		M98090_MIXRCVLG_NUM - 1, 1, max98090_mixout_tlv),
+	SOC_SINGLE_TLV("Receiver Right Mixer Volume",
+		M98090_REG_LOUTR_CONTROL, M98090_MIXRCVRG_SHIFT,
+		M98090_MIXRCVRG_NUM - 1, 1, max98090_mixout_tlv),
+
+	SOC_DOUBLE_R_TLV("Headphone Volume", M98090_REG_LEFT_HP_VOLUME,
+		M98090_REG_RIGHT_HP_VOLUME, M98090_HPVOLL_SHIFT,
+		M98090_HPVOLL_NUM - 1, 0, max98090_hp_tlv),
+
+	SOC_DOUBLE_R_RANGE_TLV("Speaker Volume",
+		M98090_REG_LEFT_SPK_VOLUME, M98090_REG_RIGHT_SPK_VOLUME,
+		M98090_SPVOLL_SHIFT, 24, M98090_SPVOLL_NUM - 1 + 24,
+		0, max98090_spk_tlv),
+
+	SOC_DOUBLE_R_TLV("Receiver Volume", M98090_REG_RCV_LOUTL_VOLUME,
+		M98090_REG_LOUTR_VOLUME, M98090_RCVLVOL_SHIFT,
+		M98090_RCVLVOL_NUM - 1, 0, max98090_rcv_lout_tlv),
+
+	SOC_SINGLE("Headphone Left Switch", M98090_REG_LEFT_HP_VOLUME,
+		M98090_HPLM_SHIFT, 1, 1),
+	SOC_SINGLE("Headphone Right Switch", M98090_REG_RIGHT_HP_VOLUME,
+		M98090_HPRM_SHIFT, 1, 1),
+
+	SOC_SINGLE("Speaker Left Switch", M98090_REG_LEFT_SPK_VOLUME,
+		M98090_SPLM_SHIFT, 1, 1),
+	SOC_SINGLE("Speaker Right Switch", M98090_REG_RIGHT_SPK_VOLUME,
+		M98090_SPRM_SHIFT, 1, 1),
+
+	SOC_SINGLE("Receiver Left Switch", M98090_REG_RCV_LOUTL_VOLUME,
+		M98090_RCVLM_SHIFT, 1, 1),
+	SOC_SINGLE("Receiver Right Switch", M98090_REG_LOUTR_VOLUME,
+		M98090_RCVRM_SHIFT, 1, 1),
+
+	SOC_SINGLE("Zero-Crossing Detection", M98090_REG_LEVEL_CONTROL,
+		M98090_ZDENN_SHIFT, M98090_ZDENN_NUM - 1, 1),
+	SOC_SINGLE("Enhanced Vol Smoothing", M98090_REG_LEVEL_CONTROL,
+		M98090_VS2ENN_SHIFT, M98090_VS2ENN_NUM - 1, 1),
+	SOC_SINGLE("Volume Adjustment Smoothing", M98090_REG_LEVEL_CONTROL,
+		M98090_VSENN_SHIFT, M98090_VSENN_NUM - 1, 1),
+
+	SND_SOC_BYTES("Biquad Coefficients", M98090_REG_RECORD_BIQUAD_BASE, 15),
+	SOC_SINGLE("Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_ADCBQEN_SHIFT, M98090_ADCBQEN_NUM - 1, 0),
+};
+
+static const struct snd_kcontrol_new max98091_snd_controls[] = {
+
+	SOC_SINGLE("DMIC34 Zeropad", M98090_REG_SAMPLE_RATE,
+		M98090_DMIC34_ZEROPAD_SHIFT,
+		M98090_DMIC34_ZEROPAD_NUM - 1, 0),
+
+	SOC_ENUM("Filter DMIC34 Mode", max98090_filter_dmic34mode_enum),
+	SOC_SINGLE("DMIC34 DC Blocking", M98090_REG_FILTER_CONFIG,
+		M98090_FLT_DMIC34HPF_SHIFT,
+		M98090_FLT_DMIC34HPF_NUM - 1, 0),
+
+	SOC_SINGLE_TLV("DMIC3 Boost Volume", M98090_REG_DMIC3_VOLUME,
+		M98090_DMIC_AV3G_SHIFT, M98090_DMIC_AV3G_NUM - 1, 0,
+		max98090_avg_tlv),
+	SOC_SINGLE_TLV("DMIC4 Boost Volume", M98090_REG_DMIC4_VOLUME,
+		M98090_DMIC_AV4G_SHIFT, M98090_DMIC_AV4G_NUM - 1, 0,
+		max98090_avg_tlv),
+
+	SOC_SINGLE_TLV("DMIC3 Volume", M98090_REG_DMIC3_VOLUME,
+		M98090_DMIC_AV3_SHIFT, M98090_DMIC_AV3_NUM - 1, 1,
+		max98090_av_tlv),
+	SOC_SINGLE_TLV("DMIC4 Volume", M98090_REG_DMIC4_VOLUME,
+		M98090_DMIC_AV4_SHIFT, M98090_DMIC_AV4_NUM - 1, 1,
+		max98090_av_tlv),
+
+	SND_SOC_BYTES("DMIC34 Biquad Coefficients",
+		M98090_REG_DMIC34_BIQUAD_BASE, 15),
+	SOC_SINGLE("DMIC34 Biquad Switch", M98090_REG_DSP_FILTER_ENABLE,
+		M98090_DMIC34BQEN_SHIFT, M98090_DMIC34BQEN_NUM - 1, 0),
+
+	SOC_SINGLE_TLV("DMIC34 BQ PreAttenuation Volume",
+		M98090_REG_DMIC34_BQ_PREATTEN, M98090_AV34BQ_SHIFT,
+		M98090_AV34BQ_NUM - 1, 1, max98090_dv_tlv),
+};
+
+static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
+				 struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	unsigned int val = snd_soc_read(codec, w->reg);
+
+	if (w->reg == M98090_REG_MIC1_INPUT_LEVEL)
+		val = (val & M98090_MIC_PA1EN_MASK) >> M98090_MIC_PA1EN_SHIFT;
+	else
+		val = (val & M98090_MIC_PA2EN_MASK) >> M98090_MIC_PA2EN_SHIFT;
+
+
+	if (val >= 1) {
+		if (w->reg == M98090_REG_MIC1_INPUT_LEVEL) {
+			max98090->pa1en = val - 1; /* Update for volatile */
+		} else {
+			max98090->pa2en = val - 1; /* Update for volatile */
+		}
+	}
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		/* If turning on, set to most recently selected volume */
+		if (w->reg == M98090_REG_MIC1_INPUT_LEVEL)
+			val = max98090->pa1en + 1;
+		else
+			val = max98090->pa2en + 1;
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		/* If turning off, turn off */
+		val = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (w->reg == M98090_REG_MIC1_INPUT_LEVEL)
+		snd_soc_update_bits(codec, w->reg, M98090_MIC_PA1EN_MASK,
+			val << M98090_MIC_PA1EN_SHIFT);
+	else
+		snd_soc_update_bits(codec, w->reg, M98090_MIC_PA2EN_MASK,
+			val << M98090_MIC_PA2EN_SHIFT);
+
+	return 0;
+}
+
+static const char *mic1_mux_text[] = { "IN12", "IN56" };
+
+static const struct soc_enum mic1_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_INPUT_MODE, M98090_EXTMIC1_SHIFT,
+		ARRAY_SIZE(mic1_mux_text), mic1_mux_text);
+
+static const struct snd_kcontrol_new max98090_mic1_mux =
+	SOC_DAPM_ENUM("MIC1 Mux", mic1_mux_enum);
+
+static const char *mic2_mux_text[] = { "IN34", "IN56" };
+
+static const struct soc_enum mic2_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_INPUT_MODE, M98090_EXTMIC2_SHIFT,
+		ARRAY_SIZE(mic2_mux_text), mic2_mux_text);
+
+static const struct snd_kcontrol_new max98090_mic2_mux =
+	SOC_DAPM_ENUM("MIC2 Mux", mic2_mux_enum);
+
+static const char * max98090_micpre_text[] = { "Off", "On" };
+
+static const struct soc_enum max98090_pa1en_enum =
+	SOC_ENUM_SINGLE(M98090_REG_MIC1_INPUT_LEVEL, M98090_MIC_PA1EN_SHIFT,
+		ARRAY_SIZE(max98090_micpre_text), max98090_micpre_text);
+
+static const struct soc_enum max98090_pa2en_enum =
+	SOC_ENUM_SINGLE(M98090_REG_MIC2_INPUT_LEVEL, M98090_MIC_PA2EN_SHIFT,
+		ARRAY_SIZE(max98090_micpre_text), max98090_micpre_text);
+
+/* LINEA mixer switch */
+static const struct snd_kcontrol_new max98090_linea_mixer_controls[] = {
+	SOC_DAPM_SINGLE("IN1 Switch", M98090_REG_LINE_INPUT_CONFIG,
+		M98090_IN1SEEN_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN3 Switch", M98090_REG_LINE_INPUT_CONFIG,
+		M98090_IN3SEEN_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN5 Switch", M98090_REG_LINE_INPUT_CONFIG,
+		M98090_IN5SEEN_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN34 Switch", M98090_REG_LINE_INPUT_CONFIG,
+		M98090_IN34DIFF_SHIFT, 1, 0),
+};
+
+/* LINEB mixer switch */
+static const struct snd_kcontrol_new max98090_lineb_mixer_controls[] = {
+	SOC_DAPM_SINGLE("IN2 Switch", M98090_REG_LINE_INPUT_CONFIG,
+		M98090_IN2SEEN_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN4 Switch", M98090_REG_LINE_INPUT_CONFIG,
+		M98090_IN4SEEN_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN6 Switch", M98090_REG_LINE_INPUT_CONFIG,
+		M98090_IN6SEEN_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN56 Switch", M98090_REG_LINE_INPUT_CONFIG,
+		M98090_IN56DIFF_SHIFT, 1, 0),
+};
+
+/* Left ADC mixer switch */
+static const struct snd_kcontrol_new max98090_left_adc_mixer_controls[] = {
+	SOC_DAPM_SINGLE("IN12 Switch", M98090_REG_LEFT_ADC_MIXER,
+		M98090_MIXADL_IN12DIFF_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN34 Switch", M98090_REG_LEFT_ADC_MIXER,
+		M98090_MIXADL_IN34DIFF_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN56 Switch", M98090_REG_LEFT_ADC_MIXER,
+		M98090_MIXADL_IN65DIFF_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEA Switch", M98090_REG_LEFT_ADC_MIXER,
+		M98090_MIXADL_LINEA_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEB Switch", M98090_REG_LEFT_ADC_MIXER,
+		M98090_MIXADL_LINEB_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC1 Switch", M98090_REG_LEFT_ADC_MIXER,
+		M98090_MIXADL_MIC1_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", M98090_REG_LEFT_ADC_MIXER,
+		M98090_MIXADL_MIC2_SHIFT, 1, 0),
+};
+
+/* Right ADC mixer switch */
+static const struct snd_kcontrol_new max98090_right_adc_mixer_controls[] = {
+	SOC_DAPM_SINGLE("IN12 Switch", M98090_REG_RIGHT_ADC_MIXER,
+		M98090_MIXADR_IN12DIFF_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN34 Switch", M98090_REG_RIGHT_ADC_MIXER,
+		M98090_MIXADR_IN34DIFF_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("IN56 Switch", M98090_REG_RIGHT_ADC_MIXER,
+		M98090_MIXADR_IN65DIFF_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEA Switch", M98090_REG_RIGHT_ADC_MIXER,
+		M98090_MIXADR_LINEA_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEB Switch", M98090_REG_RIGHT_ADC_MIXER,
+		M98090_MIXADR_LINEB_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC1 Switch", M98090_REG_RIGHT_ADC_MIXER,
+		M98090_MIXADR_MIC1_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", M98090_REG_RIGHT_ADC_MIXER,
+		M98090_MIXADR_MIC2_SHIFT, 1, 0),
+};
+
+static const char *lten_mux_text[] = { "Normal", "Loopthrough" };
+
+static const struct soc_enum ltenl_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LTEN_SHIFT,
+		ARRAY_SIZE(lten_mux_text), lten_mux_text);
+
+static const struct soc_enum ltenr_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LTEN_SHIFT,
+		ARRAY_SIZE(lten_mux_text), lten_mux_text);
+
+static const struct snd_kcontrol_new max98090_ltenl_mux =
+	SOC_DAPM_ENUM("LTENL Mux", ltenl_mux_enum);
+
+static const struct snd_kcontrol_new max98090_ltenr_mux =
+	SOC_DAPM_ENUM("LTENR Mux", ltenr_mux_enum);
+
+static const char *lben_mux_text[] = { "Normal", "Loopback" };
+
+static const struct soc_enum lbenl_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LBEN_SHIFT,
+		ARRAY_SIZE(lben_mux_text), lben_mux_text);
+
+static const struct soc_enum lbenr_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LBEN_SHIFT,
+		ARRAY_SIZE(lben_mux_text), lben_mux_text);
+
+static const struct snd_kcontrol_new max98090_lbenl_mux =
+	SOC_DAPM_ENUM("LBENL Mux", lbenl_mux_enum);
+
+static const struct snd_kcontrol_new max98090_lbenr_mux =
+	SOC_DAPM_ENUM("LBENR Mux", lbenr_mux_enum);
+
+static const char *stenl_mux_text[] = { "Normal", "Sidetone Left" };
+
+static const char *stenr_mux_text[] = { "Normal", "Sidetone Right" };
+
+static const struct soc_enum stenl_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_ADC_SIDETONE, M98090_DSTSL_SHIFT,
+		ARRAY_SIZE(stenl_mux_text), stenl_mux_text);
+
+static const struct soc_enum stenr_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_ADC_SIDETONE, M98090_DSTSR_SHIFT,
+		ARRAY_SIZE(stenr_mux_text), stenr_mux_text);
+
+static const struct snd_kcontrol_new max98090_stenl_mux =
+	SOC_DAPM_ENUM("STENL Mux", stenl_mux_enum);
+
+static const struct snd_kcontrol_new max98090_stenr_mux =
+	SOC_DAPM_ENUM("STENR Mux", stenr_mux_enum);
+
+/* Left speaker mixer switch */
+static const struct
+	snd_kcontrol_new max98090_left_speaker_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left DAC Switch", M98090_REG_LEFT_SPK_MIXER,
+		M98090_MIXSPL_DACL_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("Right DAC Switch", M98090_REG_LEFT_SPK_MIXER,
+		M98090_MIXSPL_DACR_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEA Switch", M98090_REG_LEFT_SPK_MIXER,
+		M98090_MIXSPL_LINEA_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEB Switch", M98090_REG_LEFT_SPK_MIXER,
+		M98090_MIXSPL_LINEB_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC1 Switch", M98090_REG_LEFT_SPK_MIXER,
+		M98090_MIXSPL_MIC1_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", M98090_REG_LEFT_SPK_MIXER,
+		M98090_MIXSPL_MIC2_SHIFT, 1, 0),
+};
+
+/* Right speaker mixer switch */
+static const struct
+	snd_kcontrol_new max98090_right_speaker_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left DAC Switch", M98090_REG_RIGHT_SPK_MIXER,
+		M98090_MIXSPR_DACL_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("Right DAC Switch", M98090_REG_RIGHT_SPK_MIXER,
+		M98090_MIXSPR_DACR_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEA Switch", M98090_REG_RIGHT_SPK_MIXER,
+		M98090_MIXSPR_LINEA_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEB Switch", M98090_REG_RIGHT_SPK_MIXER,
+		M98090_MIXSPR_LINEB_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC1 Switch", M98090_REG_RIGHT_SPK_MIXER,
+		M98090_MIXSPR_MIC1_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", M98090_REG_RIGHT_SPK_MIXER,
+		M98090_MIXSPR_MIC2_SHIFT, 1, 0),
+};
+
+/* Left headphone mixer switch */
+static const struct snd_kcontrol_new max98090_left_hp_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left DAC Switch", M98090_REG_LEFT_HP_MIXER,
+		M98090_MIXHPL_DACL_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("Right DAC Switch", M98090_REG_LEFT_HP_MIXER,
+		M98090_MIXHPL_DACR_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEA Switch", M98090_REG_LEFT_HP_MIXER,
+		M98090_MIXHPL_LINEA_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEB Switch", M98090_REG_LEFT_HP_MIXER,
+		M98090_MIXHPL_LINEB_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC1 Switch", M98090_REG_LEFT_HP_MIXER,
+		M98090_MIXHPL_MIC1_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", M98090_REG_LEFT_HP_MIXER,
+		M98090_MIXHPL_MIC2_SHIFT, 1, 0),
+};
+
+/* Right headphone mixer switch */
+static const struct snd_kcontrol_new max98090_right_hp_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left DAC Switch", M98090_REG_RIGHT_HP_MIXER,
+		M98090_MIXHPR_DACL_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("Right DAC Switch", M98090_REG_RIGHT_HP_MIXER,
+		M98090_MIXHPR_DACR_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEA Switch", M98090_REG_RIGHT_HP_MIXER,
+		M98090_MIXHPR_LINEA_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEB Switch", M98090_REG_RIGHT_HP_MIXER,
+		M98090_MIXHPR_LINEB_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC1 Switch", M98090_REG_RIGHT_HP_MIXER,
+		M98090_MIXHPR_MIC1_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", M98090_REG_RIGHT_HP_MIXER,
+		M98090_MIXHPR_MIC2_SHIFT, 1, 0),
+};
+
+/* Left receiver mixer switch */
+static const struct snd_kcontrol_new max98090_left_rcv_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left DAC Switch", M98090_REG_RCV_LOUTL_MIXER,
+		M98090_MIXRCVL_DACL_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("Right DAC Switch", M98090_REG_RCV_LOUTL_MIXER,
+		M98090_MIXRCVL_DACR_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEA Switch", M98090_REG_RCV_LOUTL_MIXER,
+		M98090_MIXRCVL_LINEA_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEB Switch", M98090_REG_RCV_LOUTL_MIXER,
+		M98090_MIXRCVL_LINEB_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC1 Switch", M98090_REG_RCV_LOUTL_MIXER,
+		M98090_MIXRCVL_MIC1_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", M98090_REG_RCV_LOUTL_MIXER,
+		M98090_MIXRCVL_MIC2_SHIFT, 1, 0),
+};
+
+/* Right receiver mixer switch */
+static const struct snd_kcontrol_new max98090_right_rcv_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left DAC Switch", M98090_REG_LOUTR_MIXER,
+		M98090_MIXRCVR_DACL_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("Right DAC Switch", M98090_REG_LOUTR_MIXER,
+		M98090_MIXRCVR_DACR_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEA Switch", M98090_REG_LOUTR_MIXER,
+		M98090_MIXRCVR_LINEA_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("LINEB Switch", M98090_REG_LOUTR_MIXER,
+		M98090_MIXRCVR_LINEB_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC1 Switch", M98090_REG_LOUTR_MIXER,
+		M98090_MIXRCVR_MIC1_SHIFT, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", M98090_REG_LOUTR_MIXER,
+		M98090_MIXRCVR_MIC2_SHIFT, 1, 0),
+};
+
+static const char *linmod_mux_text[] = { "Left Only", "Left and Right" };
+
+static const struct soc_enum linmod_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_LOUTR_MIXER, M98090_LINMOD_SHIFT,
+		ARRAY_SIZE(linmod_mux_text), linmod_mux_text);
+
+static const struct snd_kcontrol_new max98090_linmod_mux =
+	SOC_DAPM_ENUM("LINMOD Mux", linmod_mux_enum);
+
+static const char *mixhpsel_mux_text[] = { "DAC Only", "HP Mixer" };
+
+/*
+ * This is a mux as it selects the HP output, but to DAPM it is a Mixer enable
+ */
+static const struct soc_enum mixhplsel_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_HP_CONTROL, M98090_MIXHPLSEL_SHIFT,
+		ARRAY_SIZE(mixhpsel_mux_text), mixhpsel_mux_text);
+
+static const struct snd_kcontrol_new max98090_mixhplsel_mux =
+	SOC_DAPM_ENUM("MIXHPLSEL Mux", mixhplsel_mux_enum);
+
+static const struct soc_enum mixhprsel_mux_enum =
+	SOC_ENUM_SINGLE(M98090_REG_HP_CONTROL, M98090_MIXHPRSEL_SHIFT,
+		ARRAY_SIZE(mixhpsel_mux_text), mixhpsel_mux_text);
+
+static const struct snd_kcontrol_new max98090_mixhprsel_mux =
+	SOC_DAPM_ENUM("MIXHPRSEL Mux", mixhprsel_mux_enum);
+
+static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
+
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_INPUT("MIC2"),
+	SND_SOC_DAPM_INPUT("DMICL"),
+	SND_SOC_DAPM_INPUT("DMICR"),
+	SND_SOC_DAPM_INPUT("IN1"),
+	SND_SOC_DAPM_INPUT("IN2"),
+	SND_SOC_DAPM_INPUT("IN3"),
+	SND_SOC_DAPM_INPUT("IN4"),
+	SND_SOC_DAPM_INPUT("IN5"),
+	SND_SOC_DAPM_INPUT("IN6"),
+	SND_SOC_DAPM_INPUT("IN12"),
+	SND_SOC_DAPM_INPUT("IN34"),
+	SND_SOC_DAPM_INPUT("IN56"),
+
+	SND_SOC_DAPM_SUPPLY("MICBIAS", M98090_REG_INPUT_ENABLE,
+		M98090_MBEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("SHDN", M98090_REG_DEVICE_SHUTDOWN,
+		M98090_SHDNN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("SDIEN", M98090_REG_IO_CONFIGURATION,
+		M98090_SDIEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("SDOEN", M98090_REG_IO_CONFIGURATION,
+		M98090_SDOEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("DMICL_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
+		 M98090_DIGMICL_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("DMICR_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
+		 M98090_DIGMICR_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("AHPF", M98090_REG_FILTER_CONFIG,
+		M98090_AHPF_SHIFT, 0, NULL, 0),
+
+/*
+ * Note: Sysclk and misc power supplies are taken care of by SHDN
+ */
+
+	SND_SOC_DAPM_MUX("MIC1 Mux", SND_SOC_NOPM,
+		0, 0, &max98090_mic1_mux),
+
+	SND_SOC_DAPM_MUX("MIC2 Mux", SND_SOC_NOPM,
+		0, 0, &max98090_mic2_mux),
+
+	SND_SOC_DAPM_PGA_E("MIC1 Input", M98090_REG_MIC1_INPUT_LEVEL,
+		M98090_MIC_PA1EN_SHIFT, 0, NULL, 0, max98090_micinput_event,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_PGA_E("MIC2 Input", M98090_REG_MIC2_INPUT_LEVEL,
+		M98090_MIC_PA2EN_SHIFT, 0, NULL, 0, max98090_micinput_event,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MIXER("LINEA Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_linea_mixer_controls[0],
+		ARRAY_SIZE(max98090_linea_mixer_controls)),
+
+	SND_SOC_DAPM_MIXER("LINEB Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_lineb_mixer_controls[0],
+		ARRAY_SIZE(max98090_lineb_mixer_controls)),
+
+	SND_SOC_DAPM_PGA("LINEA Input", M98090_REG_INPUT_ENABLE,
+		M98090_LINEAEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("LINEB Input", M98090_REG_INPUT_ENABLE,
+		M98090_LINEBEN_SHIFT, 0, NULL, 0),
+
+	SND_SOC_DAPM_MIXER("Left ADC Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_left_adc_mixer_controls[0],
+		ARRAY_SIZE(max98090_left_adc_mixer_controls)),
+
+	SND_SOC_DAPM_MIXER("Right ADC Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_right_adc_mixer_controls[0],
+		ARRAY_SIZE(max98090_right_adc_mixer_controls)),
+
+	SND_SOC_DAPM_ADC("ADCL", NULL, M98090_REG_INPUT_ENABLE,
+		M98090_ADLEN_SHIFT, 0),
+	SND_SOC_DAPM_ADC("ADCR", NULL, M98090_REG_INPUT_ENABLE,
+		M98090_ADREN_SHIFT, 0),
+
+	SND_SOC_DAPM_AIF_OUT("AIFOUTL", "HiFi Capture", 0,
+		SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("AIFOUTR", "HiFi Capture", 1,
+		SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_MUX("LBENL Mux", SND_SOC_NOPM,
+		0, 0, &max98090_lbenl_mux),
+
+	SND_SOC_DAPM_MUX("LBENR Mux", SND_SOC_NOPM,
+		0, 0, &max98090_lbenr_mux),
+
+	SND_SOC_DAPM_MUX("LTENL Mux", SND_SOC_NOPM,
+		0, 0, &max98090_ltenl_mux),
+
+	SND_SOC_DAPM_MUX("LTENR Mux", SND_SOC_NOPM,
+		0, 0, &max98090_ltenr_mux),
+
+	SND_SOC_DAPM_MUX("STENL Mux", SND_SOC_NOPM,
+		0, 0, &max98090_stenl_mux),
+
+	SND_SOC_DAPM_MUX("STENR Mux", SND_SOC_NOPM,
+		0, 0, &max98090_stenr_mux),
+
+	SND_SOC_DAPM_AIF_IN("AIFINL", "HiFi Playback", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("AIFINR", "HiFi Playback", 1, SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_DAC("DACL", NULL, M98090_REG_OUTPUT_ENABLE,
+		M98090_DALEN_SHIFT, 0),
+	SND_SOC_DAPM_DAC("DACR", NULL, M98090_REG_OUTPUT_ENABLE,
+		M98090_DAREN_SHIFT, 0),
+
+	SND_SOC_DAPM_MIXER("Left Headphone Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_left_hp_mixer_controls[0],
+		ARRAY_SIZE(max98090_left_hp_mixer_controls)),
+
+	SND_SOC_DAPM_MIXER("Right Headphone Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_right_hp_mixer_controls[0],
+		ARRAY_SIZE(max98090_right_hp_mixer_controls)),
+
+	SND_SOC_DAPM_MIXER("Left Speaker Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_left_speaker_mixer_controls[0],
+		ARRAY_SIZE(max98090_left_speaker_mixer_controls)),
+
+	SND_SOC_DAPM_MIXER("Right Speaker Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_right_speaker_mixer_controls[0],
+		ARRAY_SIZE(max98090_right_speaker_mixer_controls)),
+
+	SND_SOC_DAPM_MIXER("Left Receiver Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_left_rcv_mixer_controls[0],
+		ARRAY_SIZE(max98090_left_rcv_mixer_controls)),
+
+	SND_SOC_DAPM_MIXER("Right Receiver Mixer", SND_SOC_NOPM, 0, 0,
+		&max98090_right_rcv_mixer_controls[0],
+		ARRAY_SIZE(max98090_right_rcv_mixer_controls)),
+
+	SND_SOC_DAPM_MUX("LINMOD Mux", M98090_REG_LOUTR_MIXER,
+		M98090_LINMOD_SHIFT, 0, &max98090_linmod_mux),
+
+	SND_SOC_DAPM_MUX("MIXHPLSEL Mux", M98090_REG_HP_CONTROL,
+		M98090_MIXHPLSEL_SHIFT, 0, &max98090_mixhplsel_mux),
+
+	SND_SOC_DAPM_MUX("MIXHPRSEL Mux", M98090_REG_HP_CONTROL,
+		M98090_MIXHPRSEL_SHIFT, 0, &max98090_mixhprsel_mux),
+
+	SND_SOC_DAPM_PGA("HP Left Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_HPLEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HP Right Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_HPREN_SHIFT, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("SPK Left Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_SPLEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("SPK Right Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_SPREN_SHIFT, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("RCV Left Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_RCVLEN_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("RCV Right Out", M98090_REG_OUTPUT_ENABLE,
+		M98090_RCVREN_SHIFT, 0, NULL, 0),
+
+	SND_SOC_DAPM_OUTPUT("HPL"),
+	SND_SOC_DAPM_OUTPUT("HPR"),
+	SND_SOC_DAPM_OUTPUT("SPKL"),
+	SND_SOC_DAPM_OUTPUT("SPKR"),
+	SND_SOC_DAPM_OUTPUT("RCVL"),
+	SND_SOC_DAPM_OUTPUT("RCVR"),
+};
+
+static const struct snd_soc_dapm_widget max98091_dapm_widgets[] = {
+
+	SND_SOC_DAPM_INPUT("DMIC3"),
+	SND_SOC_DAPM_INPUT("DMIC4"),
+
+	SND_SOC_DAPM_SUPPLY("DMIC3_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
+		 M98090_DIGMIC3_SHIFT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("DMIC4_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
+		 M98090_DIGMIC4_SHIFT, 0, NULL, 0),
+};
+
+static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
+
+	{"MIC1 Input", NULL, "MIC1"},
+	{"MIC2 Input", NULL, "MIC2"},
+
+	{"DMICL", NULL, "DMICL_ENA"},
+	{"DMICR", NULL, "DMICR_ENA"},
+	{"DMICL", NULL, "AHPF"},
+	{"DMICR", NULL, "AHPF"},
+
+	/* MIC1 input mux */
+	{"MIC1 Mux", "IN12", "IN12"},
+	{"MIC1 Mux", "IN56", "IN56"},
+
+	/* MIC2 input mux */
+	{"MIC2 Mux", "IN34", "IN34"},
+	{"MIC2 Mux", "IN56", "IN56"},
+
+	{"MIC1 Input", NULL, "MIC1 Mux"},
+	{"MIC2 Input", NULL, "MIC2 Mux"},
+
+	/* Left ADC input mixer */
+	{"Left ADC Mixer", "IN12 Switch", "IN12"},
+	{"Left ADC Mixer", "IN34 Switch", "IN34"},
+	{"Left ADC Mixer", "IN56 Switch", "IN56"},
+	{"Left ADC Mixer", "LINEA Switch", "LINEA Input"},
+	{"Left ADC Mixer", "LINEB Switch", "LINEB Input"},
+	{"Left ADC Mixer", "MIC1 Switch", "MIC1 Input"},
+	{"Left ADC Mixer", "MIC2 Switch", "MIC2 Input"},
+
+	/* Right ADC input mixer */
+	{"Right ADC Mixer", "IN12 Switch", "IN12"},
+	{"Right ADC Mixer", "IN34 Switch", "IN34"},
+	{"Right ADC Mixer", "IN56 Switch", "IN56"},
+	{"Right ADC Mixer", "LINEA Switch", "LINEA Input"},
+	{"Right ADC Mixer", "LINEB Switch", "LINEB Input"},
+	{"Right ADC Mixer", "MIC1 Switch", "MIC1 Input"},
+	{"Right ADC Mixer", "MIC2 Switch", "MIC2 Input"},
+
+	/* Line A input mixer */
+	{"LINEA Mixer", "IN1 Switch", "IN1"},
+	{"LINEA Mixer", "IN3 Switch", "IN3"},
+	{"LINEA Mixer", "IN5 Switch", "IN5"},
+	{"LINEA Mixer", "IN34 Switch", "IN34"},
+
+	/* Line B input mixer */
+	{"LINEB Mixer", "IN2 Switch", "IN2"},
+	{"LINEB Mixer", "IN4 Switch", "IN4"},
+	{"LINEB Mixer", "IN6 Switch", "IN6"},
+	{"LINEB Mixer", "IN56 Switch", "IN56"},
+
+	{"LINEA Input", NULL, "LINEA Mixer"},
+	{"LINEB Input", NULL, "LINEB Mixer"},
+
+	/* Inputs */
+	{"ADCL", NULL, "Left ADC Mixer"},
+	{"ADCR", NULL, "Right ADC Mixer"},
+	{"ADCL", NULL, "SHDN"},
+	{"ADCR", NULL, "SHDN"},
+
+	{"LBENL Mux", "Normal", "ADCL"},
+	{"LBENL Mux", "Normal", "DMICL"},
+	{"LBENL Mux", "Loopback", "LTENL Mux"},
+	{"LBENR Mux", "Normal", "ADCR"},
+	{"LBENR Mux", "Normal", "DMICR"},
+	{"LBENR Mux", "Loopback", "LTENR Mux"},
+
+	{"AIFOUTL", NULL, "LBENL Mux"},
+	{"AIFOUTR", NULL, "LBENR Mux"},
+	{"AIFOUTL", NULL, "SHDN"},
+	{"AIFOUTR", NULL, "SHDN"},
+	{"AIFOUTL", NULL, "SDOEN"},
+	{"AIFOUTR", NULL, "SDOEN"},
+
+	{"LTENL Mux", "Normal", "AIFINL"},
+	{"LTENL Mux", "Loopthrough", "LBENL Mux"},
+	{"LTENR Mux", "Normal", "AIFINR"},
+	{"LTENR Mux", "Loopthrough", "LBENR Mux"},
+
+	{"DACL", NULL, "LTENL Mux"},
+	{"DACR", NULL, "LTENR Mux"},
+
+	{"STENL Mux", "Sidetone Left", "ADCL"},
+	{"STENL Mux", "Sidetone Left", "DMICL"},
+	{"STENR Mux", "Sidetone Right", "ADCR"},
+	{"STENR Mux", "Sidetone Right", "DMICR"},
+	{"DACL", "NULL", "STENL Mux"},
+	{"DACR", "NULL", "STENL Mux"},
+
+	{"AIFINL", NULL, "SHDN"},
+	{"AIFINR", NULL, "SHDN"},
+	{"AIFINL", NULL, "SDIEN"},
+	{"AIFINR", NULL, "SDIEN"},
+	{"DACL", NULL, "SHDN"},
+	{"DACR", NULL, "SHDN"},
+
+	/* Left headphone output mixer */
+	{"Left Headphone Mixer", "Left DAC Switch", "DACL"},
+	{"Left Headphone Mixer", "Right DAC Switch", "DACR"},
+	{"Left Headphone Mixer", "MIC1 Switch", "MIC1 Input"},
+	{"Left Headphone Mixer", "MIC2 Switch", "MIC2 Input"},
+	{"Left Headphone Mixer", "LINEA Switch", "LINEA Input"},
+	{"Left Headphone Mixer", "LINEB Switch", "LINEB Input"},
+
+	/* Right headphone output mixer */
+	{"Right Headphone Mixer", "Left DAC Switch", "DACL"},
+	{"Right Headphone Mixer", "Right DAC Switch", "DACR"},
+	{"Right Headphone Mixer", "MIC1 Switch", "MIC1 Input"},
+	{"Right Headphone Mixer", "MIC2 Switch", "MIC2 Input"},
+	{"Right Headphone Mixer", "LINEA Switch", "LINEA Input"},
+	{"Right Headphone Mixer", "LINEB Switch", "LINEB Input"},
+
+	/* Left speaker output mixer */
+	{"Left Speaker Mixer", "Left DAC Switch", "DACL"},
+	{"Left Speaker Mixer", "Right DAC Switch", "DACR"},
+	{"Left Speaker Mixer", "MIC1 Switch", "MIC1 Input"},
+	{"Left Speaker Mixer", "MIC2 Switch", "MIC2 Input"},
+	{"Left Speaker Mixer", "LINEA Switch", "LINEA Input"},
+	{"Left Speaker Mixer", "LINEB Switch", "LINEB Input"},
+
+	/* Right speaker output mixer */
+	{"Right Speaker Mixer", "Left DAC Switch", "DACL"},
+	{"Right Speaker Mixer", "Right DAC Switch", "DACR"},
+	{"Right Speaker Mixer", "MIC1 Switch", "MIC1 Input"},
+	{"Right Speaker Mixer", "MIC2 Switch", "MIC2 Input"},
+	{"Right Speaker Mixer", "LINEA Switch", "LINEA Input"},
+	{"Right Speaker Mixer", "LINEB Switch", "LINEB Input"},
+
+	/* Left Receiver output mixer */
+	{"Left Receiver Mixer", "Left DAC Switch", "DACL"},
+	{"Left Receiver Mixer", "Right DAC Switch", "DACR"},
+	{"Left Receiver Mixer", "MIC1 Switch", "MIC1 Input"},
+	{"Left Receiver Mixer", "MIC2 Switch", "MIC2 Input"},
+	{"Left Receiver Mixer", "LINEA Switch", "LINEA Input"},
+	{"Left Receiver Mixer", "LINEB Switch", "LINEB Input"},
+
+	/* Right Receiver output mixer */
+	{"Right Receiver Mixer", "Left DAC Switch", "DACL"},
+	{"Right Receiver Mixer", "Right DAC Switch", "DACR"},
+	{"Right Receiver Mixer", "MIC1 Switch", "MIC1 Input"},
+	{"Right Receiver Mixer", "MIC2 Switch", "MIC2 Input"},
+	{"Right Receiver Mixer", "LINEA Switch", "LINEA Input"},
+	{"Right Receiver Mixer", "LINEB Switch", "LINEB Input"},
+
+	{"MIXHPLSEL Mux", "HP Mixer", "Left Headphone Mixer"},
+
+	/*
+	 * Disable this for lowest power if bypassing
+	 * the DAC with an analog signal
+	 */
+	{"HP Left Out", NULL, "DACL"},
+	{"HP Left Out", NULL, "MIXHPLSEL Mux"},
+
+	{"MIXHPRSEL Mux", "HP Mixer", "Right Headphone Mixer"},
+
+	/*
+	 * Disable this for lowest power if bypassing
+	 * the DAC with an analog signal
+	 */
+	{"HP Right Out", NULL, "DACR"},
+	{"HP Right Out", NULL, "MIXHPRSEL Mux"},
+
+	{"SPK Left Out", NULL, "Left Speaker Mixer"},
+	{"SPK Right Out", NULL, "Right Speaker Mixer"},
+	{"RCV Left Out", NULL, "Left Receiver Mixer"},
+
+	{"LINMOD Mux", "Left and Right", "Right Receiver Mixer"},
+	{"LINMOD Mux", "Left Only",  "Left Receiver Mixer"},
+	{"RCV Right Out", NULL, "LINMOD Mux"},
+
+	{"HPL", NULL, "HP Left Out"},
+	{"HPR", NULL, "HP Right Out"},
+	{"SPKL", NULL, "SPK Left Out"},
+	{"SPKR", NULL, "SPK Right Out"},
+	{"RCVL", NULL, "RCV Left Out"},
+	{"RCVR", NULL, "RCV Right Out"},
+
+};
+
+static const struct snd_soc_dapm_route max98091_dapm_routes[] = {
+
+	/* DMIC inputs */
+	{"DMIC3", NULL, "DMIC3_ENA"},
+	{"DMIC4", NULL, "DMIC4_ENA"},
+	{"DMIC3", NULL, "AHPF"},
+	{"DMIC4", NULL, "AHPF"},
+
+};
+
+static int max98090_add_widgets(struct snd_soc_codec *codec)
+{
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	snd_soc_add_codec_controls(codec, max98090_snd_controls,
+		ARRAY_SIZE(max98090_snd_controls));
+
+	if (max98090->devtype == MAX98091) {
+		snd_soc_add_codec_controls(codec, max98091_snd_controls,
+			ARRAY_SIZE(max98091_snd_controls));
+	}
+
+	snd_soc_dapm_new_controls(dapm, max98090_dapm_widgets,
+		ARRAY_SIZE(max98090_dapm_widgets));
+
+	snd_soc_dapm_add_routes(dapm, max98090_dapm_routes,
+		ARRAY_SIZE(max98090_dapm_routes));
+
+	if (max98090->devtype == MAX98091) {
+		snd_soc_dapm_new_controls(dapm, max98091_dapm_widgets,
+			ARRAY_SIZE(max98091_dapm_widgets));
+
+		snd_soc_dapm_add_routes(dapm, max98091_dapm_routes,
+			ARRAY_SIZE(max98091_dapm_routes));
+
+	}
+
+	return 0;
+}
+
+static const int pclk_rates[] = {
+	12000000, 12000000, 13000000, 13000000,
+	16000000, 16000000, 19200000, 19200000
+};
+
+static const int lrclk_rates[] = {
+	8000, 16000, 8000, 16000,
+	8000, 16000, 8000, 16000
+};
+
+static const int user_pclk_rates[] = {
+	13000000, 13000000
+};
+
+static const int user_lrclk_rates[] = {
+	44100, 48000
+};
+
+static const unsigned long long ni_value[] = {
+	3528, 768
+};
+
+static const unsigned long long mi_value[] = {
+	8125, 1625
+};
+
+static void max98090_configure_bclk(struct snd_soc_codec *codec)
+{
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	unsigned long long ni;
+	int i;
+
+	if (!max98090->sysclk) {
+		dev_err(codec->dev, "No SYSCLK configured\n");
+		return;
+	}
+
+	if (!max98090->bclk || !max98090->lrclk) {
+		dev_err(codec->dev, "No audio clocks configured\n");
+		return;
+	}
+
+	/* Skip configuration when operating as slave */
+	if (!(snd_soc_read(codec, M98090_REG_MASTER_MODE) &
+		M98090_MAS_MASK)) {
+		return;
+	}
+
+	/* Check for supported PCLK to LRCLK ratios */
+	for (i = 0; i < ARRAY_SIZE(pclk_rates); i++) {
+		if ((pclk_rates[i] == max98090->sysclk) &&
+			(lrclk_rates[i] == max98090->lrclk)) {
+			dev_dbg(codec->dev,
+				"Found supported PCLK to LRCLK rates 0x%x\n",
+				i + 0x8);
+
+			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+				M98090_FREQ_MASK,
+				(i + 0x8) << M98090_FREQ_SHIFT);
+			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+				M98090_USE_M1_MASK, 0);
+			return;
+		}
+	}
+
+	/* Check for user calculated MI and NI ratios */
+	for (i = 0; i < ARRAY_SIZE(user_pclk_rates); i++) {
+		if ((user_pclk_rates[i] == max98090->sysclk) &&
+			(user_lrclk_rates[i] == max98090->lrclk)) {
+			dev_dbg(codec->dev,
+				"Found user supported PCLK to LRCLK rates\n");
+			dev_dbg(codec->dev, "i %d ni %lld mi %lld\n",
+				i, ni_value[i], mi_value[i]);
+
+			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+				M98090_FREQ_MASK, 0);
+			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+				M98090_USE_M1_MASK,
+					1 << M98090_USE_M1_SHIFT);
+
+			snd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_MSB,
+				(ni_value[i] >> 8) & 0x7F);
+			snd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_LSB,
+				ni_value[i] & 0xFF);
+			snd_soc_write(codec, M98090_REG_CLOCK_RATIO_MI_MSB,
+				(mi_value[i] >> 8) & 0x7F);
+			snd_soc_write(codec, M98090_REG_CLOCK_RATIO_MI_LSB,
+				mi_value[i] & 0xFF);
+
+			return;
+		}
+	}
+
+	/*
+	 * Calculate based on MI = 65536 (not as good as either method above)
+	 */
+	snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+		M98090_FREQ_MASK, 0);
+	snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+		M98090_USE_M1_MASK, 0);
+
+	/*
+	 * Configure NI when operating as master
+	 * Note: There is a small, but significant audio quality improvement
+	 * by calculating ni and mi.
+	 */
+	ni = 65536ULL * (max98090->lrclk < 50000 ? 96ULL : 48ULL)
+			* (unsigned long long int)max98090->lrclk;
+	do_div(ni, (unsigned long long int)max98090->sysclk);
+	dev_info(codec->dev, "No better method found\n");
+	dev_info(codec->dev, "Calculating ni %lld with mi 65536\n", ni);
+	snd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_MSB,
+		(ni >> 8) & 0x7F);
+	snd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_LSB, ni & 0xFF);
+}
+
+static int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,
+				 unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_cdata *cdata;
+	u8 regval;
+
+	max98090->dai_fmt = fmt;
+	cdata = &max98090->dai[0];
+
+	if (fmt != cdata->fmt) {
+		cdata->fmt = fmt;
+
+		regval = 0;
+		switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+		case SND_SOC_DAIFMT_CBS_CFS:
+			/* Set to slave mode PLL - MAS mode off */
+			snd_soc_write(codec,
+				M98090_REG_CLOCK_RATIO_NI_MSB, 0x00);
+			snd_soc_write(codec,
+				M98090_REG_CLOCK_RATIO_NI_LSB, 0x00);
+			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
+				M98090_USE_M1_MASK, 0);
+			break;
+		case SND_SOC_DAIFMT_CBM_CFM:
+			/* Set to master mode */
+			if (max98090->tdm_slots == 4) {
+				/* TDM */
+				regval |= M98090_MAS_MASK |
+					M98090_BSEL_64;
+			} else if (max98090->tdm_slots == 3) {
+				/* TDM */
+				regval |= M98090_MAS_MASK |
+					M98090_BSEL_48;
+			} else {
+				/* Few TDM slots, or No TDM */
+				regval |= M98090_MAS_MASK |
+					M98090_BSEL_32;
+			}
+			break;
+		case SND_SOC_DAIFMT_CBS_CFM:
+		case SND_SOC_DAIFMT_CBM_CFS:
+		default:
+			dev_err(codec->dev, "DAI clock mode unsupported");
+			return -EINVAL;
+		}
+		snd_soc_write(codec, M98090_REG_MASTER_MODE, regval);
+
+		regval = 0;
+		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:
+			regval |= M98090_DLY_MASK;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			regval |= M98090_RJ_MASK;
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+			/* Not supported mode */
+		default:
+			dev_err(codec->dev, "DAI format unsupported");
+			return -EINVAL;
+		}
+
+		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			break;
+		case SND_SOC_DAIFMT_NB_IF:
+			regval |= M98090_WCI_MASK;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			regval |= M98090_BCI_MASK;
+			break;
+		case SND_SOC_DAIFMT_IB_IF:
+			regval |= M98090_BCI_MASK|M98090_WCI_MASK;
+			break;
+		default:
+			dev_err(codec->dev, "DAI invert mode unsupported");
+			return -EINVAL;
+		}
+
+		/*
+		 * This accommodates an inverted logic in the MAX98090 chip
+		 * for Bit Clock Invert (BCI). The inverted logic is only
+		 * seen for the case of TDM mode. The remaining cases have
+		 * normal logic.
+		 */
+		if (max98090->tdm_slots > 1) {
+			regval ^= M98090_BCI_MASK;
+		}
+
+		snd_soc_write(codec,
+			M98090_REG_INTERFACE_FORMAT, regval);
+	}
+
+	return 0;
+}
+
+static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
+	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_cdata *cdata;
+	cdata = &max98090->dai[0];
+
+	if (slots < 0 || slots > 4)
+		return -EINVAL;
+
+	max98090->tdm_slots = slots;
+	max98090->tdm_width = slot_width;
+
+	if (max98090->tdm_slots > 1) {
+		/* SLOTL SLOTR SLOTDLY */
+		snd_soc_write(codec, M98090_REG_TDM_FORMAT,
+			0 << M98090_TDM_SLOTL_SHIFT |
+			1 << M98090_TDM_SLOTR_SHIFT |
+			0 << M98090_TDM_SLOTDLY_SHIFT);
+
+		/* FSW TDM */
+		snd_soc_update_bits(codec, M98090_REG_TDM_CONTROL,
+			M98090_TDM_MASK,
+			M98090_TDM_MASK);
+	}
+
+	/*
+	 * Normally advisable to set TDM first, but this permits either order
+	 */
+	cdata->fmt = 0;
+	max98090_dai_set_fmt(codec_dai, max98090->dai_fmt);
+
+	return 0;
+}
+
+static int max98090_set_bias_level(struct snd_soc_codec *codec,
+				   enum snd_soc_bias_level level)
+{
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			ret = regcache_sync(max98090->regmap);
+
+			if (ret != 0) {
+				dev_err(codec->dev,
+					"Failed to sync cache: %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (max98090->jack_state == M98090_JACK_STATE_HEADSET) {
+			/*
+			 * Set to normal bias level.
+			 */
+			snd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,
+				M98090_MBVSEL_MASK, M98090_MBVSEL_2V8);
+		}
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+	case SND_SOC_BIAS_OFF:
+		/* Set internal pull-up to lowest power mode */
+		snd_soc_update_bits(codec, M98090_REG_JACK_DETECT,
+			M98090_JDWK_MASK, M98090_JDWK_MASK);
+		regcache_mark_dirty(max98090->regmap);
+		break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static const int comp_pclk_rates[] = {
+	11289600, 12288000, 12000000, 13000000, 19200000
+};
+
+static const int dmic_micclk[] = {
+	2, 2, 2, 2, 4, 2
+};
+
+static const int comp_lrclk_rates[] = {
+	8000, 16000, 32000, 44100, 48000, 96000
+};
+
+static const int dmic_comp[6][6] = {
+	{7, 8, 3, 3, 3, 3},
+	{7, 8, 3, 3, 3, 3},
+	{7, 8, 3, 3, 3, 3},
+	{7, 8, 3, 1, 1, 1},
+	{7, 8, 3, 1, 2, 2},
+	{7, 8, 3, 3, 3, 3}
+};
+
+static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params,
+				   struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_cdata *cdata;
+	int i, j;
+
+	cdata = &max98090->dai[0];
+	max98090->bclk = snd_soc_params_to_bclk(params);
+	if (params_channels(params) == 1)
+		max98090->bclk *= 2;
+
+	max98090->lrclk = params_rate(params);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		snd_soc_update_bits(codec, M98090_REG_INTERFACE_FORMAT,
+			M98090_WS_MASK, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	max98090_configure_bclk(codec);
+
+	cdata->rate = max98090->lrclk;
+
+	/* Update filter mode */
+	if (max98090->lrclk < 24000)
+		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
+			M98090_MODE_MASK, 0);
+	else
+		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
+			M98090_MODE_MASK, M98090_MODE_MASK);
+
+	/* Update sample rate mode */
+	if (max98090->lrclk < 50000)
+		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
+			M98090_DHF_MASK, 0);
+	else
+		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
+			M98090_DHF_MASK, M98090_DHF_MASK);
+
+	/* Check for supported PCLK to LRCLK ratios */
+	for (j = 0; j < ARRAY_SIZE(comp_pclk_rates); j++) {
+		if (comp_pclk_rates[j] == max98090->sysclk) {
+			break;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(comp_lrclk_rates) - 1; i++) {
+		if (max98090->lrclk <= (comp_lrclk_rates[i] +
+			comp_lrclk_rates[i + 1]) / 2) {
+			break;
+		}
+	}
+
+	snd_soc_update_bits(codec, M98090_REG_DIGITAL_MIC_ENABLE,
+			M98090_MICCLK_MASK,
+			dmic_micclk[j] << M98090_MICCLK_SHIFT);
+
+	snd_soc_update_bits(codec, M98090_REG_DIGITAL_MIC_CONFIG,
+			M98090_DMIC_COMP_MASK,
+			dmic_comp[j][i] << M98090_DMIC_COMP_SHIFT);
+
+	return 0;
+}
+
+/*
+ * PLL / Sysclk
+ */
+static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
+				   int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	/* Requested clock frequency is already setup */
+	if (freq == max98090->sysclk)
+		return 0;
+
+	/* Setup clocks for slave mode, and using the PLL
+	 * PSCLK = 0x01 (when master clk is 10MHz to 20MHz)
+	 *		 0x02 (when master clk is 20MHz to 40MHz)..
+	 *		 0x03 (when master clk is 40MHz to 60MHz)..
+	 */
+	if ((freq >= 10000000) && (freq < 20000000)) {
+		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
+			M98090_PSCLK_DIV1);
+	} else if ((freq >= 20000000) && (freq < 40000000)) {
+		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
+			M98090_PSCLK_DIV2);
+	} else if ((freq >= 40000000) && (freq < 60000000)) {
+		snd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,
+			M98090_PSCLK_DIV4);
+	} else {
+		dev_err(codec->dev, "Invalid master clock frequency\n");
+		return -EINVAL;
+	}
+
+	max98090->sysclk = freq;
+
+	max98090_configure_bclk(codec);
+
+	return 0;
+}
+
+static int max98090_dai_digital_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	int regval;
+
+	regval = mute ? M98090_DVM_MASK : 0;
+	snd_soc_update_bits(codec, M98090_REG_DAI_PLAYBACK_LEVEL,
+		M98090_DVM_MASK, regval);
+
+	return 0;
+}
+
+static void max98090_jack_work(struct work_struct *work)
+{
+	struct max98090_priv *max98090 = container_of(work,
+		struct max98090_priv,
+		jack_work.work);
+	struct snd_soc_codec *codec = max98090->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	int status = 0;
+	int reg;
+
+	/* Read a second time */
+	if (max98090->jack_state == M98090_JACK_STATE_NO_HEADSET) {
+
+		/* Strong pull up allows mic detection */
+		snd_soc_update_bits(codec, M98090_REG_JACK_DETECT,
+			M98090_JDWK_MASK, 0);
+
+		msleep(50);
+
+		reg = snd_soc_read(codec, M98090_REG_JACK_STATUS);
+
+		/* Weak pull up allows only insertion detection */
+		snd_soc_update_bits(codec, M98090_REG_JACK_DETECT,
+			M98090_JDWK_MASK, M98090_JDWK_MASK);
+	} else {
+		reg = snd_soc_read(codec, M98090_REG_JACK_STATUS);
+	}
+
+	reg = snd_soc_read(codec, M98090_REG_JACK_STATUS);
+
+	switch (reg & (M98090_LSNS_MASK | M98090_JKSNS_MASK)) {
+		case M98090_LSNS_MASK | M98090_JKSNS_MASK:
+			dev_dbg(codec->dev, "No Headset Detected\n");
+
+			max98090->jack_state = M98090_JACK_STATE_NO_HEADSET;
+
+			status |= 0;
+
+			break;
+
+		case 0:
+			if (max98090->jack_state ==
+				M98090_JACK_STATE_HEADSET) {
+
+				dev_dbg(codec->dev,
+					"Headset Button Down Detected\n");
+
+				/*
+				 * max98090_headset_button_event(codec)
+				 * could be defined, then called here.
+				 */
+
+				status |= SND_JACK_HEADSET;
+				status |= SND_JACK_BTN_0;
+
+				break;
+			}
+
+			/* Line is reported as Headphone */
+			/* Nokia Headset is reported as Headphone */
+			/* Mono Headphone is reported as Headphone */
+			dev_dbg(codec->dev, "Headphone Detected\n");
+
+			max98090->jack_state = M98090_JACK_STATE_HEADPHONE;
+
+			status |= SND_JACK_HEADPHONE;
+
+			break;
+
+		case M98090_JKSNS_MASK:
+			dev_dbg(codec->dev, "Headset Detected\n");
+
+			max98090->jack_state = M98090_JACK_STATE_HEADSET;
+
+			status |= SND_JACK_HEADSET;
+
+			break;
+
+		default:
+			dev_dbg(codec->dev, "Unrecognized Jack Status\n");
+			break;
+	}
+
+	snd_soc_jack_report(max98090->jack, status,
+			    SND_JACK_HEADSET | SND_JACK_BTN_0);
+
+	snd_soc_dapm_sync(dapm);
+}
+
+static irqreturn_t max98090_interrupt(int irq, void *data)
+{
+	struct snd_soc_codec *codec = data;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+	unsigned int mask;
+	unsigned int active;
+
+	dev_dbg(codec->dev, "***** max98090_interrupt *****\n");
+
+	ret = regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);
+
+	if (ret != 0) {
+		dev_err(codec->dev,
+			"failed to read M98090_REG_INTERRUPT_S: %d\n",
+			ret);
+		return IRQ_NONE;
+	}
+
+	ret = regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &active);
+
+	if (ret != 0) {
+		dev_err(codec->dev,
+			"failed to read M98090_REG_DEVICE_STATUS: %d\n",
+			ret);
+		return IRQ_NONE;
+	}
+
+	dev_dbg(codec->dev, "active=0x%02x mask=0x%02x -> active=0x%02x\n",
+		active, mask, active & mask);
+
+	active &= mask;
+
+	if (!active)
+		return IRQ_NONE;
+
+	if (active & M98090_CLD_MASK) {
+		dev_err(codec->dev, "M98090_CLD_MASK\n");
+	}
+
+	if (active & M98090_SLD_MASK) {
+		dev_dbg(codec->dev, "M98090_SLD_MASK\n");
+	}
+
+	if (active & M98090_ULK_MASK) {
+		dev_err(codec->dev, "M98090_ULK_MASK\n");
+	}
+
+	if (active & M98090_JDET_MASK) {
+		dev_dbg(codec->dev, "M98090_JDET_MASK\n");
+
+		pm_wakeup_event(codec->dev, 100);
+
+		schedule_delayed_work(&max98090->jack_work,
+			msecs_to_jiffies(100));
+	}
+
+	if (active & M98090_DRCACT_MASK) {
+		dev_dbg(codec->dev, "M98090_DRCACT_MASK\n");
+	}
+
+	if (active & M98090_DRCCLP_MASK) {
+		dev_err(codec->dev, "M98090_DRCCLP_MASK\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * max98090_mic_detect - Enable microphone detection via the MAX98090 IRQ
+ *
+ * @codec:  MAX98090 codec
+ * @jack:   jack to report detection events on
+ *
+ * Enable microphone detection via IRQ on the MAX98090.  If GPIOs are
+ * being used to bring out signals to the processor then only platform
+ * data configuration is needed for MAX98090 and processor GPIOs should
+ * be configured using snd_soc_jack_add_gpios() instead.
+ *
+ * If no jack is supplied detection will be disabled.
+ */
+int max98090_mic_detect(struct snd_soc_codec *codec,
+	struct snd_soc_jack *jack)
+{
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "max98090_mic_detect\n");
+
+	max98090->jack = jack;
+	if (jack) {
+		snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+			M98090_IJDET_MASK,
+			1 << M98090_IJDET_SHIFT);
+	} else {
+		snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+			M98090_IJDET_MASK,
+			0);
+	}
+
+	/* Send an initial empty report */
+	snd_soc_jack_report(max98090->jack, 0,
+			    SND_JACK_HEADSET | SND_JACK_BTN_0);
+
+	schedule_delayed_work(&max98090->jack_work,
+		msecs_to_jiffies(100));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(max98090_mic_detect);
+
+#define MAX98090_RATES SNDRV_PCM_RATE_8000_96000
+#define MAX98090_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops max98090_dai_ops = {
+	.set_sysclk = max98090_dai_set_sysclk,
+	.set_fmt = max98090_dai_set_fmt,
+	.set_tdm_slot = max98090_set_tdm_slot,
+	.hw_params = max98090_dai_hw_params,
+	.digital_mute = max98090_dai_digital_mute,
+};
+
+static struct snd_soc_dai_driver max98090_dai[] = {
+{
+	.name = "HiFi",
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = MAX98090_RATES,
+		.formats = MAX98090_FORMATS,
+	},
+	.capture = {
+		.stream_name = "HiFi Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = MAX98090_RATES,
+		.formats = MAX98090_FORMATS,
+	},
+	 .ops = &max98090_dai_ops,
+}
+};
+
+static void max98090_handle_pdata(struct snd_soc_codec *codec)
+{
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_pdata *pdata = max98090->pdata;
+
+	if (!pdata) {
+		dev_err(codec->dev, "No platform data\n");
+		return;
+	}
+
+}
+
+static int max98090_probe(struct snd_soc_codec *codec)
+{
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_cdata *cdata;
+	int ret = 0;
+
+	dev_dbg(codec->dev, "max98090_probe\n");
+
+	max98090->codec = codec;
+
+	codec->control_data = max98090->regmap;
+
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+
+	/* Reset the codec, the DSP core, and disable all interrupts */
+	max98090_reset(max98090);
+
+	/* Initialize private data */
+
+	max98090->sysclk = (unsigned)-1;
+
+	cdata = &max98090->dai[0];
+	cdata->rate = (unsigned)-1;
+	cdata->fmt  = (unsigned)-1;
+
+	max98090->lin_state = 0;
+	max98090->pa1en = 0;
+	max98090->pa2en = 0;
+	max98090->extmic_mux = 0;
+
+	ret = snd_soc_read(codec, M98090_REG_REVISION_ID);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to read device revision: %d\n",
+			ret);
+		goto err_access;
+	}
+
+	if ((ret >= M98090_REVA) && (ret <= M98090_REVA + 0x0f)) {
+		max98090->devtype = MAX98090;
+		dev_info(codec->dev, "MAX98090 REVID=0x%02x\n", ret);
+	} else if ((ret >= M98091_REVA) && (ret <= M98091_REVA + 0x0f)) {
+		max98090->devtype = MAX98091;
+		dev_info(codec->dev, "MAX98091 REVID=0x%02x\n", ret);
+	} else {
+		max98090->devtype = MAX98090;
+		dev_err(codec->dev, "Unrecognized revision 0x%02x\n", ret);
+	}
+
+	max98090->jack_state = M98090_JACK_STATE_NO_HEADSET;
+
+	INIT_DELAYED_WORK(&max98090->jack_work, max98090_jack_work);
+
+	/* Enable jack detection */
+	snd_soc_write(codec, M98090_REG_JACK_DETECT,
+		M98090_JDETEN_MASK | M98090_JDEB_25MS);
+
+	/* Register for interrupts */
+	dev_dbg(codec->dev, "irq = %d\n", max98090->irq);
+
+	ret = request_threaded_irq(max98090->irq, NULL,
+		max98090_interrupt, IRQF_TRIGGER_FALLING,
+		"max98090_interrupt", codec);
+	if (ret < 0) {
+		dev_err(codec->dev, "request_irq failed: %d\n",
+			ret);
+	}
+
+	/*
+	 * Clear any old interrupts.
+	 * An old interrupt ocurring prior to installing the ISR
+	 * can keep a new interrupt from generating a trigger.
+	 */
+	snd_soc_read(codec, M98090_REG_DEVICE_STATUS);
+
+	/* High Performance is default */
+	snd_soc_update_bits(codec, M98090_REG_DAC_CONTROL,
+		M98090_DACHP_MASK,
+		1 << M98090_DACHP_SHIFT);
+	snd_soc_update_bits(codec, M98090_REG_DAC_CONTROL,
+		M98090_PERFMODE_MASK,
+		0 << M98090_PERFMODE_SHIFT);
+	snd_soc_update_bits(codec, M98090_REG_ADC_CONTROL,
+		M98090_ADCHP_MASK,
+		1 << M98090_ADCHP_SHIFT);
+
+	/* Turn on VCM bandgap reference */
+	snd_soc_write(codec, M98090_REG_BIAS_CONTROL,
+		M98090_VCM_MODE_MASK);
+
+	max98090_handle_pdata(codec);
+
+	max98090_add_widgets(codec);
+
+err_access:
+	return ret;
+}
+
+static int max98090_remove(struct snd_soc_codec *codec)
+{
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	cancel_delayed_work_sync(&max98090->jack_work);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_max98090 = {
+	.probe   = max98090_probe,
+	.remove  = max98090_remove,
+	.set_bias_level = max98090_set_bias_level,
+};
+
+static const struct regmap_config max98090_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = MAX98090_MAX_REGISTER,
+	.reg_defaults = max98090_reg,
+	.num_reg_defaults = ARRAY_SIZE(max98090_reg),
+	.volatile_reg = max98090_volatile_register,
+	.readable_reg = max98090_readable_register,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int max98090_i2c_probe(struct i2c_client *i2c,
+				 const struct i2c_device_id *id)
+{
+	struct max98090_priv *max98090;
+	int ret;
+
+	pr_debug("max98090_i2c_probe\n");
+
+	max98090 = devm_kzalloc(&i2c->dev, sizeof(struct max98090_priv),
+		GFP_KERNEL);
+	if (max98090 == NULL)
+		return -ENOMEM;
+
+	max98090->devtype = id->driver_data;
+	i2c_set_clientdata(i2c, max98090);
+	max98090->control_data = i2c;
+	max98090->pdata = i2c->dev.platform_data;
+	max98090->irq = i2c->irq;
+
+	max98090->regmap = regmap_init_i2c(i2c, &max98090_regmap);
+	if (IS_ERR(max98090->regmap)) {
+		ret = PTR_ERR(max98090->regmap);
+		dev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);
+		goto err_enable;
+	}
+
+	ret = snd_soc_register_codec(&i2c->dev,
+			&soc_codec_dev_max98090, max98090_dai,
+			ARRAY_SIZE(max98090_dai));
+	if (ret < 0)
+		regmap_exit(max98090->regmap);
+
+err_enable:
+	return ret;
+}
+
+static int max98090_i2c_remove(struct i2c_client *client)
+{
+	struct max98090_priv *max98090 = dev_get_drvdata(&client->dev);
+	snd_soc_unregister_codec(&client->dev);
+	regmap_exit(max98090->regmap);
+	return 0;
+}
+
+static int max98090_runtime_resume(struct device *dev)
+{
+	struct max98090_priv *max98090 = dev_get_drvdata(dev);
+
+	regcache_cache_only(max98090->regmap, false);
+
+	regcache_sync(max98090->regmap);
+
+	return 0;
+}
+
+static int max98090_runtime_suspend(struct device *dev)
+{
+	struct max98090_priv *max98090 = dev_get_drvdata(dev);
+
+	regcache_cache_only(max98090->regmap, true);
+
+	return 0;
+}
+
+static struct dev_pm_ops max98090_pm = {
+	SET_RUNTIME_PM_OPS(max98090_runtime_suspend,
+		max98090_runtime_resume, NULL)
+};
+
+static const struct i2c_device_id max98090_i2c_id[] = {
+	{ "max98090", MAX98090 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max98090_i2c_id);
+
+static struct i2c_driver max98090_i2c_driver = {
+	.driver = {
+		.name = "max98090",
+		.owner = THIS_MODULE,
+		.pm = &max98090_pm,
+	},
+	.probe  = max98090_i2c_probe,
+	.remove = max98090_i2c_remove,
+	.id_table = max98090_i2c_id,
+};
+
+module_i2c_driver(max98090_i2c_driver);
+
+MODULE_DESCRIPTION("ALSA SoC MAX98090 driver");
+MODULE_AUTHOR("Peter Hsiang, Jesse Marroqin, Jerry Wong");
+MODULE_LICENSE("GPL");

commit 7e3bb169ff20972b7c238a9fda108b94e7cb9df0
Author: Jerry Wong <jerry.wong@maximintegrated.com>
Date:   Wed Feb 6 11:02:33 2013 -0800

    ASoC: Replace max98090 Device Driver
    
    This patch removes the existing max98090 driver prior to installing a more
    complete one.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
deleted file mode 100644
index c9772ca3da4f..000000000000
--- a/sound/soc/codecs/max98090.c
+++ /dev/null
@@ -1,577 +0,0 @@
-/*
- * max98090.c -- MAX98090 ALSA SoC Audio driver
- * based on Rev0p8 datasheet
- *
- * Copyright (C) 2012 Renesas Solutions Corp.
- * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
- *
- * Based on
- *
- * max98095.c
- * Copyright 2011 Maxim Integrated Products
- *
- * https://github.com/hardkernel/linux/commit/\
- *	3417d7166b17113b3b33b0a337c74d1c7cc313df#sound/soc/codecs/max98090.c
- * Copyright 2011 Maxim Integrated Products
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/i2c.h>
-#include <linux/module.h>
-#include <linux/regmap.h>
-#include <sound/soc.h>
-#include <sound/tlv.h>
-
-/*
- *
- * MAX98090 Registers Definition
- *
- */
-
-/* RESET / STATUS / INTERRUPT REGISTERS */
-#define MAX98090_0x00_SW_RESET		0x00
-#define MAX98090_0x01_INT_STS		0x01
-#define MAX98090_0x02_JACK_STS		0x02
-#define MAX98090_0x03_INT_MASK		0x03
-
-/* QUICK SETUP REGISTERS */
-#define MAX98090_0x04_SYS_CLK		0x04
-#define MAX98090_0x05_SAMPLE_RATE	0x05
-#define MAX98090_0x06_DAI_IF		0x06
-#define MAX98090_0x07_DAC_PATH		0x07
-#define MAX98090_0x08_MIC_TO_ADC	0x08
-#define MAX98090_0x09_LINE_TO_ADC	0x09
-#define MAX98090_0x0A_ANALOG_MIC_LOOP	0x0A
-#define MAX98090_0x0B_ANALOG_LINE_LOOP	0x0B
-
-/* ANALOG INPUT CONFIGURATION REGISTERS */
-#define MAX98090_0x0D_INPUT_CONFIG	0x0D
-#define MAX98090_0x0E_LINE_IN_LVL	0x0E
-#define MAX98090_0x0F_LINI_IN_CFG	0x0F
-#define MAX98090_0x10_MIC1_IN_LVL	0x10
-#define MAX98090_0x11_MIC2_IN_LVL	0x11
-
-/* MICROPHONE CONFIGURATION REGISTERS  */
-#define MAX98090_0x12_MIC_BIAS_VOL	0x12
-#define MAX98090_0x13_DIGITAL_MIC_CFG	0x13
-#define MAX98090_0x14_DIGITAL_MIC_MODE	0x14
-
-/* ADC PATH AND CONFIGURATION REGISTERS */
-#define MAX98090_0x15_L_ADC_MIX		0x15
-#define MAX98090_0x16_R_ADC_MIX		0x16
-#define MAX98090_0x17_L_ADC_LVL		0x17
-#define MAX98090_0x18_R_ADC_LVL		0x18
-#define MAX98090_0x19_ADC_BIQUAD_LVL	0x19
-#define MAX98090_0x1A_ADC_SIDETONE	0x1A
-
-/* CLOCK CONFIGURATION REGISTERS */
-#define MAX98090_0x1B_SYS_CLK		0x1B
-#define MAX98090_0x1C_CLK_MODE		0x1C
-#define MAX98090_0x1D_ANY_CLK1		0x1D
-#define MAX98090_0x1E_ANY_CLK2		0x1E
-#define MAX98090_0x1F_ANY_CLK3		0x1F
-#define MAX98090_0x20_ANY_CLK4		0x20
-#define MAX98090_0x21_MASTER_MODE	0x21
-
-/* INTERFACE CONTROL REGISTERS */
-#define MAX98090_0x22_DAI_IF_FMT	0x22
-#define MAX98090_0x23_DAI_TDM_FMT1	0x23
-#define MAX98090_0x24_DAI_TDM_FMT2	0x24
-#define MAX98090_0x25_DAI_IO_CFG	0x25
-#define MAX98090_0x26_FILTER_CFG	0x26
-#define MAX98090_0x27_DAI_PLAYBACK_LVL	0x27
-#define MAX98090_0x28_EQ_PLAYBACK_LVL	0x28
-
-/* HEADPHONE CONTROL REGISTERS */
-#define MAX98090_0x29_L_HP_MIX		0x29
-#define MAX98090_0x2A_R_HP_MIX		0x2A
-#define MAX98090_0x2B_HP_CTR		0x2B
-#define MAX98090_0x2C_L_HP_VOL		0x2C
-#define MAX98090_0x2D_R_HP_VOL		0x2D
-
-/* SPEAKER CONFIGURATION REGISTERS */
-#define MAX98090_0x2E_L_SPK_MIX		0x2E
-#define MAX98090_0x2F_R_SPK_MIX		0x2F
-#define MAX98090_0x30_SPK_CTR		0x30
-#define MAX98090_0x31_L_SPK_VOL		0x31
-#define MAX98090_0x32_R_SPK_VOL		0x32
-
-/* ALC CONFIGURATION REGISTERS */
-#define MAX98090_0x33_ALC_TIMING	0x33
-#define MAX98090_0x34_ALC_COMPRESSOR	0x34
-#define MAX98090_0x35_ALC_EXPANDER	0x35
-#define MAX98090_0x36_ALC_GAIN		0x36
-
-/* RECEIVER AND LINE_OUTPUT REGISTERS */
-#define MAX98090_0x37_RCV_LOUT_L_MIX	0x37
-#define MAX98090_0x38_RCV_LOUT_L_CNTL	0x38
-#define MAX98090_0x39_RCV_LOUT_L_VOL	0x39
-#define MAX98090_0x3A_LOUT_R_MIX	0x3A
-#define MAX98090_0x3B_LOUT_R_CNTL	0x3B
-#define MAX98090_0x3C_LOUT_R_VOL	0x3C
-
-/* JACK DETECT AND ENABLE REGISTERS */
-#define MAX98090_0x3D_JACK_DETECT	0x3D
-#define MAX98090_0x3E_IN_ENABLE		0x3E
-#define MAX98090_0x3F_OUT_ENABLE	0x3F
-#define MAX98090_0x40_LVL_CTR		0x40
-#define MAX98090_0x41_DSP_FILTER_ENABLE	0x41
-
-/* BIAS AND POWER MODE CONFIGURATION REGISTERS */
-#define MAX98090_0x42_BIAS_CTR		0x42
-#define MAX98090_0x43_DAC_CTR		0x43
-#define MAX98090_0x44_ADC_CTR		0x44
-#define MAX98090_0x45_DEV_SHUTDOWN	0x45
-
-/* REVISION ID REGISTER */
-#define MAX98090_0xFF_REV_ID		0xFF
-
-#define MAX98090_REG_MAX_CACHED		0x45
-#define MAX98090_REG_END		0xFF
-
-/*
- *
- * MAX98090 Registers Bit Fields
- *
- */
-
-/* MAX98090_0x06_DAI_IF */
-#define MAX98090_DAI_IF_MASK		0x3F
-#define MAX98090_RJ_M			(1 << 5)
-#define MAX98090_RJ_S			(1 << 4)
-#define MAX98090_LJ_M			(1 << 3)
-#define MAX98090_LJ_S			(1 << 2)
-#define MAX98090_I2S_M			(1 << 1)
-#define MAX98090_I2S_S			(1 << 0)
-
-/* MAX98090_0x45_DEV_SHUTDOWN */
-#define MAX98090_SHDNRUN		(1 << 7)
-
-/* codec private data */
-struct max98090_priv {
-	struct regmap *regmap;
-};
-
-static const struct reg_default max98090_reg_defaults[] = {
-	/* RESET / STATUS / INTERRUPT REGISTERS */
-	{MAX98090_0x00_SW_RESET,		0x00},
-	{MAX98090_0x01_INT_STS,			0x00},
-	{MAX98090_0x02_JACK_STS,		0x00},
-	{MAX98090_0x03_INT_MASK,		0x04},
-
-	/* QUICK SETUP REGISTERS */
-	{MAX98090_0x04_SYS_CLK,			0x00},
-	{MAX98090_0x05_SAMPLE_RATE,		0x00},
-	{MAX98090_0x06_DAI_IF,			0x00},
-	{MAX98090_0x07_DAC_PATH,		0x00},
-	{MAX98090_0x08_MIC_TO_ADC,		0x00},
-	{MAX98090_0x09_LINE_TO_ADC,		0x00},
-	{MAX98090_0x0A_ANALOG_MIC_LOOP,		0x00},
-	{MAX98090_0x0B_ANALOG_LINE_LOOP,	0x00},
-
-	/* ANALOG INPUT CONFIGURATION REGISTERS */
-	{MAX98090_0x0D_INPUT_CONFIG,		0x00},
-	{MAX98090_0x0E_LINE_IN_LVL,		0x1B},
-	{MAX98090_0x0F_LINI_IN_CFG,		0x00},
-	{MAX98090_0x10_MIC1_IN_LVL,		0x11},
-	{MAX98090_0x11_MIC2_IN_LVL,		0x11},
-
-	/* MICROPHONE CONFIGURATION REGISTERS  */
-	{MAX98090_0x12_MIC_BIAS_VOL,		0x00},
-	{MAX98090_0x13_DIGITAL_MIC_CFG,		0x00},
-	{MAX98090_0x14_DIGITAL_MIC_MODE,	0x00},
-
-	/* ADC PATH AND CONFIGURATION REGISTERS */
-	{MAX98090_0x15_L_ADC_MIX,		0x00},
-	{MAX98090_0x16_R_ADC_MIX,		0x00},
-	{MAX98090_0x17_L_ADC_LVL,		0x03},
-	{MAX98090_0x18_R_ADC_LVL,		0x03},
-	{MAX98090_0x19_ADC_BIQUAD_LVL,		0x00},
-	{MAX98090_0x1A_ADC_SIDETONE,		0x00},
-
-	/* CLOCK CONFIGURATION REGISTERS */
-	{MAX98090_0x1B_SYS_CLK,			0x00},
-	{MAX98090_0x1C_CLK_MODE,		0x00},
-	{MAX98090_0x1D_ANY_CLK1,		0x00},
-	{MAX98090_0x1E_ANY_CLK2,		0x00},
-	{MAX98090_0x1F_ANY_CLK3,		0x00},
-	{MAX98090_0x20_ANY_CLK4,		0x00},
-	{MAX98090_0x21_MASTER_MODE,		0x00},
-
-	/* INTERFACE CONTROL REGISTERS */
-	{MAX98090_0x22_DAI_IF_FMT,		0x00},
-	{MAX98090_0x23_DAI_TDM_FMT1,		0x00},
-	{MAX98090_0x24_DAI_TDM_FMT2,		0x00},
-	{MAX98090_0x25_DAI_IO_CFG,		0x00},
-	{MAX98090_0x26_FILTER_CFG,		0x80},
-	{MAX98090_0x27_DAI_PLAYBACK_LVL,	0x00},
-	{MAX98090_0x28_EQ_PLAYBACK_LVL,		0x00},
-
-	/* HEADPHONE CONTROL REGISTERS */
-	{MAX98090_0x29_L_HP_MIX,		0x00},
-	{MAX98090_0x2A_R_HP_MIX,		0x00},
-	{MAX98090_0x2B_HP_CTR,			0x00},
-	{MAX98090_0x2C_L_HP_VOL,		0x1A},
-	{MAX98090_0x2D_R_HP_VOL,		0x1A},
-
-	/* SPEAKER CONFIGURATION REGISTERS */
-	{MAX98090_0x2E_L_SPK_MIX,		0x00},
-	{MAX98090_0x2F_R_SPK_MIX,		0x00},
-	{MAX98090_0x30_SPK_CTR,			0x00},
-	{MAX98090_0x31_L_SPK_VOL,		0x2C},
-	{MAX98090_0x32_R_SPK_VOL,		0x2C},
-
-	/* ALC CONFIGURATION REGISTERS */
-	{MAX98090_0x33_ALC_TIMING,		0x00},
-	{MAX98090_0x34_ALC_COMPRESSOR,		0x00},
-	{MAX98090_0x35_ALC_EXPANDER,		0x00},
-	{MAX98090_0x36_ALC_GAIN,		0x00},
-
-	/* RECEIVER AND LINE_OUTPUT REGISTERS */
-	{MAX98090_0x37_RCV_LOUT_L_MIX,		0x00},
-	{MAX98090_0x38_RCV_LOUT_L_CNTL,		0x00},
-	{MAX98090_0x39_RCV_LOUT_L_VOL,		0x15},
-	{MAX98090_0x3A_LOUT_R_MIX,		0x00},
-	{MAX98090_0x3B_LOUT_R_CNTL,		0x00},
-	{MAX98090_0x3C_LOUT_R_VOL,		0x15},
-
-	/* JACK DETECT AND ENABLE REGISTERS */
-	{MAX98090_0x3D_JACK_DETECT,		0x00},
-	{MAX98090_0x3E_IN_ENABLE,		0x00},
-	{MAX98090_0x3F_OUT_ENABLE,		0x00},
-	{MAX98090_0x40_LVL_CTR,			0x00},
-	{MAX98090_0x41_DSP_FILTER_ENABLE,	0x00},
-
-	/* BIAS AND POWER MODE CONFIGURATION REGISTERS */
-	{MAX98090_0x42_BIAS_CTR,		0x00},
-	{MAX98090_0x43_DAC_CTR,			0x00},
-	{MAX98090_0x44_ADC_CTR,			0x06},
-	{MAX98090_0x45_DEV_SHUTDOWN,		0x00},
-};
-
-static const unsigned int max98090_hp_tlv[] = {
-	TLV_DB_RANGE_HEAD(5),
-	0x0,	0x6,	TLV_DB_SCALE_ITEM(-6700, 400, 0),
-	0x7,	0xE,	TLV_DB_SCALE_ITEM(-4000, 300, 0),
-	0xF,	0x15,	TLV_DB_SCALE_ITEM(-1700, 200, 0),
-	0x16,	0x1B,	TLV_DB_SCALE_ITEM(-400, 100, 0),
-	0x1C,	0x1F,	TLV_DB_SCALE_ITEM(150, 50, 0),
-};
-
-static struct snd_kcontrol_new max98090_snd_controls[] = {
-	SOC_DOUBLE_R_TLV("Headphone Volume", MAX98090_0x2C_L_HP_VOL,
-			 MAX98090_0x2D_R_HP_VOL, 0, 31, 0, max98090_hp_tlv),
-};
-
-/* Left HeadPhone Mixer Switch */
-static struct snd_kcontrol_new max98090_left_hp_mixer_controls[] = {
-	SOC_DAPM_SINGLE("DACR Switch", MAX98090_0x29_L_HP_MIX, 1, 1, 0),
-	SOC_DAPM_SINGLE("DACL Switch", MAX98090_0x29_L_HP_MIX, 0, 1, 0),
-};
-
-/* Right HeadPhone Mixer Switch */
-static struct snd_kcontrol_new max98090_right_hp_mixer_controls[] = {
-	SOC_DAPM_SINGLE("DACR Switch", MAX98090_0x2A_R_HP_MIX, 1, 1, 0),
-	SOC_DAPM_SINGLE("DACL Switch", MAX98090_0x2A_R_HP_MIX, 0, 1, 0),
-};
-
-static struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
-	/* Output */
-	SND_SOC_DAPM_OUTPUT("HPL"),
-	SND_SOC_DAPM_OUTPUT("HPR"),
-
-	/* PGA */
-	SND_SOC_DAPM_PGA("HPL Out", MAX98090_0x3F_OUT_ENABLE, 7, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("HPR Out", MAX98090_0x3F_OUT_ENABLE, 6, 0, NULL, 0),
-
-	/* Mixer */
-	SND_SOC_DAPM_MIXER("HPL Mixer", SND_SOC_NOPM, 0, 0,
-			   max98090_left_hp_mixer_controls,
-			   ARRAY_SIZE(max98090_left_hp_mixer_controls)),
-
-	SND_SOC_DAPM_MIXER("HPR Mixer", SND_SOC_NOPM, 0, 0,
-			   max98090_right_hp_mixer_controls,
-			   ARRAY_SIZE(max98090_right_hp_mixer_controls)),
-
-	/* DAC */
-	SND_SOC_DAPM_DAC("DACL", "Hifi Playback", MAX98090_0x3F_OUT_ENABLE, 0, 0),
-	SND_SOC_DAPM_DAC("DACR", "Hifi Playback", MAX98090_0x3F_OUT_ENABLE, 1, 0),
-};
-
-static struct snd_soc_dapm_route max98090_audio_map[] = {
-	/* Output */
-	{"HPL", NULL, "HPL Out"},
-	{"HPR", NULL, "HPR Out"},
-
-	/* PGA */
-	{"HPL Out", NULL, "HPL Mixer"},
-	{"HPR Out", NULL, "HPR Mixer"},
-
-	/* Mixer*/
-	{"HPL Mixer", "DACR Switch", "DACR"},
-	{"HPL Mixer", "DACL Switch", "DACL"},
-
-	{"HPR Mixer", "DACR Switch", "DACR"},
-	{"HPR Mixer", "DACL Switch", "DACL"},
-};
-
-static bool max98090_volatile(struct device *dev, unsigned int reg)
-{
-	if ((reg == MAX98090_0x01_INT_STS)	||
-	    (reg == MAX98090_0x02_JACK_STS)	||
-	    (reg >  MAX98090_REG_MAX_CACHED))
-		return true;
-
-	return false;
-}
-
-static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params,
-		struct snd_soc_dai *dai)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	unsigned int val;
-
-	switch (params_rate(params)) {
-	case 96000:
-		val = 1 << 5;
-		break;
-	case 32000:
-		val = 1 << 4;
-		break;
-	case 48000:
-		val = 1 << 3;
-		break;
-	case 44100:
-		val = 1 << 2;
-		break;
-	case 16000:
-		val = 1 << 1;
-		break;
-	case 8000:
-		val = 1 << 0;
-		break;
-	default:
-		dev_err(codec->dev, "unsupported rate\n");
-		return -EINVAL;
-	}
-	snd_soc_update_bits(codec, MAX98090_0x05_SAMPLE_RATE, 0x03F, val);
-
-	return 0;
-}
-
-static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
-		int clk_id, unsigned int freq, int dir)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	unsigned int val;
-
-	snd_soc_update_bits(codec, MAX98090_0x45_DEV_SHUTDOWN,
-			    MAX98090_SHDNRUN, 0);
-
-	switch (freq) {
-	case 26000000:
-		val = 1 << 7;
-		break;
-	case 19200000:
-		val = 1 << 6;
-		break;
-	case 13000000:
-		val = 1 << 5;
-		break;
-	case 12288000:
-		val = 1 << 4;
-		break;
-	case 12000000:
-		val = 1 << 3;
-		break;
-	case 11289600:
-		val = 1 << 2;
-		break;
-	default:
-		dev_err(codec->dev, "Invalid master clock frequency\n");
-		return -EINVAL;
-	}
-	snd_soc_update_bits(codec, MAX98090_0x04_SYS_CLK, 0xFD, val);
-
-	snd_soc_update_bits(codec, MAX98090_0x45_DEV_SHUTDOWN,
-			    MAX98090_SHDNRUN, MAX98090_SHDNRUN);
-
-	dev_dbg(dai->dev, "sysclk is %uHz\n", freq);
-
-	return 0;
-}
-
-static int max98090_dai_set_fmt(struct snd_soc_dai *dai,
-				unsigned int fmt)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	int is_master;
-	u8 val;
-
-	/* master/slave mode */
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		is_master = 1;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		is_master = 0;
-		break;
-	default:
-		dev_err(codec->dev, "unsupported clock\n");
-		return -EINVAL;
-	}
-
-	/* format */
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_I2S:
-		val = (is_master) ? MAX98090_I2S_M : MAX98090_I2S_S;
-		break;
-	case SND_SOC_DAIFMT_RIGHT_J:
-		val = (is_master) ? MAX98090_RJ_M : MAX98090_RJ_S;
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		val = (is_master) ? MAX98090_LJ_M : MAX98090_LJ_S;
-		break;
-	default:
-		dev_err(codec->dev, "unsupported format\n");
-		return -EINVAL;
-	}
-	snd_soc_update_bits(codec, MAX98090_0x06_DAI_IF,
-			    MAX98090_DAI_IF_MASK, val);
-
-	return 0;
-}
-
-#define MAX98090_RATES SNDRV_PCM_RATE_8000_96000
-#define MAX98090_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
-
-static struct snd_soc_dai_ops max98090_dai_ops = {
-	.set_sysclk	= max98090_dai_set_sysclk,
-	.set_fmt	= max98090_dai_set_fmt,
-	.hw_params	= max98090_dai_hw_params,
-};
-
-static struct snd_soc_dai_driver max98090_dai = {
-	.name = "max98090-Hifi",
-	.playback = {
-		.stream_name	= "Playback",
-		.channels_min	= 1,
-		.channels_max	= 2,
-		.rates		= MAX98090_RATES,
-		.formats	= MAX98090_FORMATS,
-	},
-	.ops = &max98090_dai_ops,
-};
-
-static int max98090_probe(struct snd_soc_codec *codec)
-{
-	struct max98090_priv *priv = snd_soc_codec_get_drvdata(codec);
-	struct device *dev = codec->dev;
-	int ret;
-
-	codec->control_data = priv->regmap;
-	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);
-	if (ret < 0) {
-		dev_err(dev, "Failed to set cache I/O: %d\n", ret);
-		return ret;
-	}
-
-	/* Device active */
-	snd_soc_update_bits(codec, MAX98090_0x45_DEV_SHUTDOWN,
-			    MAX98090_SHDNRUN, MAX98090_SHDNRUN);
-
-	return 0;
-}
-
-static int max98090_remove(struct snd_soc_codec *codec)
-{
-	return 0;
-}
-
-static struct snd_soc_codec_driver soc_codec_dev_max98090 = {
-	.probe			= max98090_probe,
-	.remove			= max98090_remove,
-	.controls		= max98090_snd_controls,
-	.num_controls		= ARRAY_SIZE(max98090_snd_controls),
-	.dapm_widgets		= max98090_dapm_widgets,
-	.num_dapm_widgets	= ARRAY_SIZE(max98090_dapm_widgets),
-	.dapm_routes		= max98090_audio_map,
-	.num_dapm_routes	= ARRAY_SIZE(max98090_audio_map),
-};
-
-static const struct regmap_config max98090_regmap = {
-	.reg_bits		= 8,
-	.val_bits		= 8,
-	.max_register		= MAX98090_REG_END,
-	.volatile_reg		= max98090_volatile,
-	.cache_type		= REGCACHE_RBTREE,
-	.reg_defaults		= max98090_reg_defaults,
-	.num_reg_defaults	= ARRAY_SIZE(max98090_reg_defaults),
-};
-
-static int max98090_i2c_probe(struct i2c_client *i2c,
-			      const struct i2c_device_id *id)
-{
-	struct max98090_priv *priv;
-	struct device *dev = &i2c->dev;
-	unsigned int val;
-	int ret;
-
-	priv = devm_kzalloc(dev, sizeof(struct max98090_priv),
-			    GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->regmap = devm_regmap_init_i2c(i2c, &max98090_regmap);
-	if (IS_ERR(priv->regmap)) {
-		ret = PTR_ERR(priv->regmap);
-		dev_err(dev, "Failed to init regmap: %d\n", ret);
-		return ret;
-	}
-
-	i2c_set_clientdata(i2c, priv);
-
-	ret = regmap_read(priv->regmap, MAX98090_0xFF_REV_ID, &val);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read device revision: %d\n", ret);
-		return ret;
-	}
-	dev_info(dev, "revision 0x%02x\n", val);
-
-	ret = snd_soc_register_codec(dev,
-				     &soc_codec_dev_max98090,
-				     &max98090_dai, 1);
-
-	return ret;
-}
-
-static int max98090_i2c_remove(struct i2c_client *client)
-{
-	snd_soc_unregister_codec(&client->dev);
-	return 0;
-}
-
-static const struct i2c_device_id max98090_i2c_id[] = {
-	{ "max98090", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, max98090_i2c_id);
-
-static struct i2c_driver max98090_i2c_driver = {
-	.driver = {
-		.name = "max98090",
-		.owner = THIS_MODULE,
-	},
-	.probe		= max98090_i2c_probe,
-	.remove		= max98090_i2c_remove,
-	.id_table	= max98090_i2c_id,
-};
-module_i2c_driver(max98090_i2c_driver);
-
-MODULE_DESCRIPTION("ALSA SoC MAX98090 driver");
-MODULE_AUTHOR("Peter Hsiang, Kuninori Morimoto");
-MODULE_LICENSE("GPL");

commit 83f7cbc43b623d8498b2b542f0dfb9d9f67db2fd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 20 20:27:10 2012 -0800

    ASoC: Add max98090 codec driver
    
    This patch adds the max98090 codec prototype driver.
    It supports Headphone only at this point.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/codecs/max98090.c b/sound/soc/codecs/max98090.c
new file mode 100644
index 000000000000..c9772ca3da4f
--- /dev/null
+++ b/sound/soc/codecs/max98090.c
@@ -0,0 +1,577 @@
+/*
+ * max98090.c -- MAX98090 ALSA SoC Audio driver
+ * based on Rev0p8 datasheet
+ *
+ * Copyright (C) 2012 Renesas Solutions Corp.
+ * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+ *
+ * Based on
+ *
+ * max98095.c
+ * Copyright 2011 Maxim Integrated Products
+ *
+ * https://github.com/hardkernel/linux/commit/\
+ *	3417d7166b17113b3b33b0a337c74d1c7cc313df#sound/soc/codecs/max98090.c
+ * Copyright 2011 Maxim Integrated Products
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+/*
+ *
+ * MAX98090 Registers Definition
+ *
+ */
+
+/* RESET / STATUS / INTERRUPT REGISTERS */
+#define MAX98090_0x00_SW_RESET		0x00
+#define MAX98090_0x01_INT_STS		0x01
+#define MAX98090_0x02_JACK_STS		0x02
+#define MAX98090_0x03_INT_MASK		0x03
+
+/* QUICK SETUP REGISTERS */
+#define MAX98090_0x04_SYS_CLK		0x04
+#define MAX98090_0x05_SAMPLE_RATE	0x05
+#define MAX98090_0x06_DAI_IF		0x06
+#define MAX98090_0x07_DAC_PATH		0x07
+#define MAX98090_0x08_MIC_TO_ADC	0x08
+#define MAX98090_0x09_LINE_TO_ADC	0x09
+#define MAX98090_0x0A_ANALOG_MIC_LOOP	0x0A
+#define MAX98090_0x0B_ANALOG_LINE_LOOP	0x0B
+
+/* ANALOG INPUT CONFIGURATION REGISTERS */
+#define MAX98090_0x0D_INPUT_CONFIG	0x0D
+#define MAX98090_0x0E_LINE_IN_LVL	0x0E
+#define MAX98090_0x0F_LINI_IN_CFG	0x0F
+#define MAX98090_0x10_MIC1_IN_LVL	0x10
+#define MAX98090_0x11_MIC2_IN_LVL	0x11
+
+/* MICROPHONE CONFIGURATION REGISTERS  */
+#define MAX98090_0x12_MIC_BIAS_VOL	0x12
+#define MAX98090_0x13_DIGITAL_MIC_CFG	0x13
+#define MAX98090_0x14_DIGITAL_MIC_MODE	0x14
+
+/* ADC PATH AND CONFIGURATION REGISTERS */
+#define MAX98090_0x15_L_ADC_MIX		0x15
+#define MAX98090_0x16_R_ADC_MIX		0x16
+#define MAX98090_0x17_L_ADC_LVL		0x17
+#define MAX98090_0x18_R_ADC_LVL		0x18
+#define MAX98090_0x19_ADC_BIQUAD_LVL	0x19
+#define MAX98090_0x1A_ADC_SIDETONE	0x1A
+
+/* CLOCK CONFIGURATION REGISTERS */
+#define MAX98090_0x1B_SYS_CLK		0x1B
+#define MAX98090_0x1C_CLK_MODE		0x1C
+#define MAX98090_0x1D_ANY_CLK1		0x1D
+#define MAX98090_0x1E_ANY_CLK2		0x1E
+#define MAX98090_0x1F_ANY_CLK3		0x1F
+#define MAX98090_0x20_ANY_CLK4		0x20
+#define MAX98090_0x21_MASTER_MODE	0x21
+
+/* INTERFACE CONTROL REGISTERS */
+#define MAX98090_0x22_DAI_IF_FMT	0x22
+#define MAX98090_0x23_DAI_TDM_FMT1	0x23
+#define MAX98090_0x24_DAI_TDM_FMT2	0x24
+#define MAX98090_0x25_DAI_IO_CFG	0x25
+#define MAX98090_0x26_FILTER_CFG	0x26
+#define MAX98090_0x27_DAI_PLAYBACK_LVL	0x27
+#define MAX98090_0x28_EQ_PLAYBACK_LVL	0x28
+
+/* HEADPHONE CONTROL REGISTERS */
+#define MAX98090_0x29_L_HP_MIX		0x29
+#define MAX98090_0x2A_R_HP_MIX		0x2A
+#define MAX98090_0x2B_HP_CTR		0x2B
+#define MAX98090_0x2C_L_HP_VOL		0x2C
+#define MAX98090_0x2D_R_HP_VOL		0x2D
+
+/* SPEAKER CONFIGURATION REGISTERS */
+#define MAX98090_0x2E_L_SPK_MIX		0x2E
+#define MAX98090_0x2F_R_SPK_MIX		0x2F
+#define MAX98090_0x30_SPK_CTR		0x30
+#define MAX98090_0x31_L_SPK_VOL		0x31
+#define MAX98090_0x32_R_SPK_VOL		0x32
+
+/* ALC CONFIGURATION REGISTERS */
+#define MAX98090_0x33_ALC_TIMING	0x33
+#define MAX98090_0x34_ALC_COMPRESSOR	0x34
+#define MAX98090_0x35_ALC_EXPANDER	0x35
+#define MAX98090_0x36_ALC_GAIN		0x36
+
+/* RECEIVER AND LINE_OUTPUT REGISTERS */
+#define MAX98090_0x37_RCV_LOUT_L_MIX	0x37
+#define MAX98090_0x38_RCV_LOUT_L_CNTL	0x38
+#define MAX98090_0x39_RCV_LOUT_L_VOL	0x39
+#define MAX98090_0x3A_LOUT_R_MIX	0x3A
+#define MAX98090_0x3B_LOUT_R_CNTL	0x3B
+#define MAX98090_0x3C_LOUT_R_VOL	0x3C
+
+/* JACK DETECT AND ENABLE REGISTERS */
+#define MAX98090_0x3D_JACK_DETECT	0x3D
+#define MAX98090_0x3E_IN_ENABLE		0x3E
+#define MAX98090_0x3F_OUT_ENABLE	0x3F
+#define MAX98090_0x40_LVL_CTR		0x40
+#define MAX98090_0x41_DSP_FILTER_ENABLE	0x41
+
+/* BIAS AND POWER MODE CONFIGURATION REGISTERS */
+#define MAX98090_0x42_BIAS_CTR		0x42
+#define MAX98090_0x43_DAC_CTR		0x43
+#define MAX98090_0x44_ADC_CTR		0x44
+#define MAX98090_0x45_DEV_SHUTDOWN	0x45
+
+/* REVISION ID REGISTER */
+#define MAX98090_0xFF_REV_ID		0xFF
+
+#define MAX98090_REG_MAX_CACHED		0x45
+#define MAX98090_REG_END		0xFF
+
+/*
+ *
+ * MAX98090 Registers Bit Fields
+ *
+ */
+
+/* MAX98090_0x06_DAI_IF */
+#define MAX98090_DAI_IF_MASK		0x3F
+#define MAX98090_RJ_M			(1 << 5)
+#define MAX98090_RJ_S			(1 << 4)
+#define MAX98090_LJ_M			(1 << 3)
+#define MAX98090_LJ_S			(1 << 2)
+#define MAX98090_I2S_M			(1 << 1)
+#define MAX98090_I2S_S			(1 << 0)
+
+/* MAX98090_0x45_DEV_SHUTDOWN */
+#define MAX98090_SHDNRUN		(1 << 7)
+
+/* codec private data */
+struct max98090_priv {
+	struct regmap *regmap;
+};
+
+static const struct reg_default max98090_reg_defaults[] = {
+	/* RESET / STATUS / INTERRUPT REGISTERS */
+	{MAX98090_0x00_SW_RESET,		0x00},
+	{MAX98090_0x01_INT_STS,			0x00},
+	{MAX98090_0x02_JACK_STS,		0x00},
+	{MAX98090_0x03_INT_MASK,		0x04},
+
+	/* QUICK SETUP REGISTERS */
+	{MAX98090_0x04_SYS_CLK,			0x00},
+	{MAX98090_0x05_SAMPLE_RATE,		0x00},
+	{MAX98090_0x06_DAI_IF,			0x00},
+	{MAX98090_0x07_DAC_PATH,		0x00},
+	{MAX98090_0x08_MIC_TO_ADC,		0x00},
+	{MAX98090_0x09_LINE_TO_ADC,		0x00},
+	{MAX98090_0x0A_ANALOG_MIC_LOOP,		0x00},
+	{MAX98090_0x0B_ANALOG_LINE_LOOP,	0x00},
+
+	/* ANALOG INPUT CONFIGURATION REGISTERS */
+	{MAX98090_0x0D_INPUT_CONFIG,		0x00},
+	{MAX98090_0x0E_LINE_IN_LVL,		0x1B},
+	{MAX98090_0x0F_LINI_IN_CFG,		0x00},
+	{MAX98090_0x10_MIC1_IN_LVL,		0x11},
+	{MAX98090_0x11_MIC2_IN_LVL,		0x11},
+
+	/* MICROPHONE CONFIGURATION REGISTERS  */
+	{MAX98090_0x12_MIC_BIAS_VOL,		0x00},
+	{MAX98090_0x13_DIGITAL_MIC_CFG,		0x00},
+	{MAX98090_0x14_DIGITAL_MIC_MODE,	0x00},
+
+	/* ADC PATH AND CONFIGURATION REGISTERS */
+	{MAX98090_0x15_L_ADC_MIX,		0x00},
+	{MAX98090_0x16_R_ADC_MIX,		0x00},
+	{MAX98090_0x17_L_ADC_LVL,		0x03},
+	{MAX98090_0x18_R_ADC_LVL,		0x03},
+	{MAX98090_0x19_ADC_BIQUAD_LVL,		0x00},
+	{MAX98090_0x1A_ADC_SIDETONE,		0x00},
+
+	/* CLOCK CONFIGURATION REGISTERS */
+	{MAX98090_0x1B_SYS_CLK,			0x00},
+	{MAX98090_0x1C_CLK_MODE,		0x00},
+	{MAX98090_0x1D_ANY_CLK1,		0x00},
+	{MAX98090_0x1E_ANY_CLK2,		0x00},
+	{MAX98090_0x1F_ANY_CLK3,		0x00},
+	{MAX98090_0x20_ANY_CLK4,		0x00},
+	{MAX98090_0x21_MASTER_MODE,		0x00},
+
+	/* INTERFACE CONTROL REGISTERS */
+	{MAX98090_0x22_DAI_IF_FMT,		0x00},
+	{MAX98090_0x23_DAI_TDM_FMT1,		0x00},
+	{MAX98090_0x24_DAI_TDM_FMT2,		0x00},
+	{MAX98090_0x25_DAI_IO_CFG,		0x00},
+	{MAX98090_0x26_FILTER_CFG,		0x80},
+	{MAX98090_0x27_DAI_PLAYBACK_LVL,	0x00},
+	{MAX98090_0x28_EQ_PLAYBACK_LVL,		0x00},
+
+	/* HEADPHONE CONTROL REGISTERS */
+	{MAX98090_0x29_L_HP_MIX,		0x00},
+	{MAX98090_0x2A_R_HP_MIX,		0x00},
+	{MAX98090_0x2B_HP_CTR,			0x00},
+	{MAX98090_0x2C_L_HP_VOL,		0x1A},
+	{MAX98090_0x2D_R_HP_VOL,		0x1A},
+
+	/* SPEAKER CONFIGURATION REGISTERS */
+	{MAX98090_0x2E_L_SPK_MIX,		0x00},
+	{MAX98090_0x2F_R_SPK_MIX,		0x00},
+	{MAX98090_0x30_SPK_CTR,			0x00},
+	{MAX98090_0x31_L_SPK_VOL,		0x2C},
+	{MAX98090_0x32_R_SPK_VOL,		0x2C},
+
+	/* ALC CONFIGURATION REGISTERS */
+	{MAX98090_0x33_ALC_TIMING,		0x00},
+	{MAX98090_0x34_ALC_COMPRESSOR,		0x00},
+	{MAX98090_0x35_ALC_EXPANDER,		0x00},
+	{MAX98090_0x36_ALC_GAIN,		0x00},
+
+	/* RECEIVER AND LINE_OUTPUT REGISTERS */
+	{MAX98090_0x37_RCV_LOUT_L_MIX,		0x00},
+	{MAX98090_0x38_RCV_LOUT_L_CNTL,		0x00},
+	{MAX98090_0x39_RCV_LOUT_L_VOL,		0x15},
+	{MAX98090_0x3A_LOUT_R_MIX,		0x00},
+	{MAX98090_0x3B_LOUT_R_CNTL,		0x00},
+	{MAX98090_0x3C_LOUT_R_VOL,		0x15},
+
+	/* JACK DETECT AND ENABLE REGISTERS */
+	{MAX98090_0x3D_JACK_DETECT,		0x00},
+	{MAX98090_0x3E_IN_ENABLE,		0x00},
+	{MAX98090_0x3F_OUT_ENABLE,		0x00},
+	{MAX98090_0x40_LVL_CTR,			0x00},
+	{MAX98090_0x41_DSP_FILTER_ENABLE,	0x00},
+
+	/* BIAS AND POWER MODE CONFIGURATION REGISTERS */
+	{MAX98090_0x42_BIAS_CTR,		0x00},
+	{MAX98090_0x43_DAC_CTR,			0x00},
+	{MAX98090_0x44_ADC_CTR,			0x06},
+	{MAX98090_0x45_DEV_SHUTDOWN,		0x00},
+};
+
+static const unsigned int max98090_hp_tlv[] = {
+	TLV_DB_RANGE_HEAD(5),
+	0x0,	0x6,	TLV_DB_SCALE_ITEM(-6700, 400, 0),
+	0x7,	0xE,	TLV_DB_SCALE_ITEM(-4000, 300, 0),
+	0xF,	0x15,	TLV_DB_SCALE_ITEM(-1700, 200, 0),
+	0x16,	0x1B,	TLV_DB_SCALE_ITEM(-400, 100, 0),
+	0x1C,	0x1F,	TLV_DB_SCALE_ITEM(150, 50, 0),
+};
+
+static struct snd_kcontrol_new max98090_snd_controls[] = {
+	SOC_DOUBLE_R_TLV("Headphone Volume", MAX98090_0x2C_L_HP_VOL,
+			 MAX98090_0x2D_R_HP_VOL, 0, 31, 0, max98090_hp_tlv),
+};
+
+/* Left HeadPhone Mixer Switch */
+static struct snd_kcontrol_new max98090_left_hp_mixer_controls[] = {
+	SOC_DAPM_SINGLE("DACR Switch", MAX98090_0x29_L_HP_MIX, 1, 1, 0),
+	SOC_DAPM_SINGLE("DACL Switch", MAX98090_0x29_L_HP_MIX, 0, 1, 0),
+};
+
+/* Right HeadPhone Mixer Switch */
+static struct snd_kcontrol_new max98090_right_hp_mixer_controls[] = {
+	SOC_DAPM_SINGLE("DACR Switch", MAX98090_0x2A_R_HP_MIX, 1, 1, 0),
+	SOC_DAPM_SINGLE("DACL Switch", MAX98090_0x2A_R_HP_MIX, 0, 1, 0),
+};
+
+static struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
+	/* Output */
+	SND_SOC_DAPM_OUTPUT("HPL"),
+	SND_SOC_DAPM_OUTPUT("HPR"),
+
+	/* PGA */
+	SND_SOC_DAPM_PGA("HPL Out", MAX98090_0x3F_OUT_ENABLE, 7, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HPR Out", MAX98090_0x3F_OUT_ENABLE, 6, 0, NULL, 0),
+
+	/* Mixer */
+	SND_SOC_DAPM_MIXER("HPL Mixer", SND_SOC_NOPM, 0, 0,
+			   max98090_left_hp_mixer_controls,
+			   ARRAY_SIZE(max98090_left_hp_mixer_controls)),
+
+	SND_SOC_DAPM_MIXER("HPR Mixer", SND_SOC_NOPM, 0, 0,
+			   max98090_right_hp_mixer_controls,
+			   ARRAY_SIZE(max98090_right_hp_mixer_controls)),
+
+	/* DAC */
+	SND_SOC_DAPM_DAC("DACL", "Hifi Playback", MAX98090_0x3F_OUT_ENABLE, 0, 0),
+	SND_SOC_DAPM_DAC("DACR", "Hifi Playback", MAX98090_0x3F_OUT_ENABLE, 1, 0),
+};
+
+static struct snd_soc_dapm_route max98090_audio_map[] = {
+	/* Output */
+	{"HPL", NULL, "HPL Out"},
+	{"HPR", NULL, "HPR Out"},
+
+	/* PGA */
+	{"HPL Out", NULL, "HPL Mixer"},
+	{"HPR Out", NULL, "HPR Mixer"},
+
+	/* Mixer*/
+	{"HPL Mixer", "DACR Switch", "DACR"},
+	{"HPL Mixer", "DACL Switch", "DACL"},
+
+	{"HPR Mixer", "DACR Switch", "DACR"},
+	{"HPR Mixer", "DACL Switch", "DACL"},
+};
+
+static bool max98090_volatile(struct device *dev, unsigned int reg)
+{
+	if ((reg == MAX98090_0x01_INT_STS)	||
+	    (reg == MAX98090_0x02_JACK_STS)	||
+	    (reg >  MAX98090_REG_MAX_CACHED))
+		return true;
+
+	return false;
+}
+
+static int max98090_dai_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	unsigned int val;
+
+	switch (params_rate(params)) {
+	case 96000:
+		val = 1 << 5;
+		break;
+	case 32000:
+		val = 1 << 4;
+		break;
+	case 48000:
+		val = 1 << 3;
+		break;
+	case 44100:
+		val = 1 << 2;
+		break;
+	case 16000:
+		val = 1 << 1;
+		break;
+	case 8000:
+		val = 1 << 0;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported rate\n");
+		return -EINVAL;
+	}
+	snd_soc_update_bits(codec, MAX98090_0x05_SAMPLE_RATE, 0x03F, val);
+
+	return 0;
+}
+
+static int max98090_dai_set_sysclk(struct snd_soc_dai *dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	unsigned int val;
+
+	snd_soc_update_bits(codec, MAX98090_0x45_DEV_SHUTDOWN,
+			    MAX98090_SHDNRUN, 0);
+
+	switch (freq) {
+	case 26000000:
+		val = 1 << 7;
+		break;
+	case 19200000:
+		val = 1 << 6;
+		break;
+	case 13000000:
+		val = 1 << 5;
+		break;
+	case 12288000:
+		val = 1 << 4;
+		break;
+	case 12000000:
+		val = 1 << 3;
+		break;
+	case 11289600:
+		val = 1 << 2;
+		break;
+	default:
+		dev_err(codec->dev, "Invalid master clock frequency\n");
+		return -EINVAL;
+	}
+	snd_soc_update_bits(codec, MAX98090_0x04_SYS_CLK, 0xFD, val);
+
+	snd_soc_update_bits(codec, MAX98090_0x45_DEV_SHUTDOWN,
+			    MAX98090_SHDNRUN, MAX98090_SHDNRUN);
+
+	dev_dbg(dai->dev, "sysclk is %uHz\n", freq);
+
+	return 0;
+}
+
+static int max98090_dai_set_fmt(struct snd_soc_dai *dai,
+				unsigned int fmt)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	int is_master;
+	u8 val;
+
+	/* master/slave mode */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		is_master = 1;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		is_master = 0;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported clock\n");
+		return -EINVAL;
+	}
+
+	/* format */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		val = (is_master) ? MAX98090_I2S_M : MAX98090_I2S_S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		val = (is_master) ? MAX98090_RJ_M : MAX98090_RJ_S;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		val = (is_master) ? MAX98090_LJ_M : MAX98090_LJ_S;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported format\n");
+		return -EINVAL;
+	}
+	snd_soc_update_bits(codec, MAX98090_0x06_DAI_IF,
+			    MAX98090_DAI_IF_MASK, val);
+
+	return 0;
+}
+
+#define MAX98090_RATES SNDRV_PCM_RATE_8000_96000
+#define MAX98090_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops max98090_dai_ops = {
+	.set_sysclk	= max98090_dai_set_sysclk,
+	.set_fmt	= max98090_dai_set_fmt,
+	.hw_params	= max98090_dai_hw_params,
+};
+
+static struct snd_soc_dai_driver max98090_dai = {
+	.name = "max98090-Hifi",
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= MAX98090_RATES,
+		.formats	= MAX98090_FORMATS,
+	},
+	.ops = &max98090_dai_ops,
+};
+
+static int max98090_probe(struct snd_soc_codec *codec)
+{
+	struct max98090_priv *priv = snd_soc_codec_get_drvdata(codec);
+	struct device *dev = codec->dev;
+	int ret;
+
+	codec->control_data = priv->regmap;
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+
+	/* Device active */
+	snd_soc_update_bits(codec, MAX98090_0x45_DEV_SHUTDOWN,
+			    MAX98090_SHDNRUN, MAX98090_SHDNRUN);
+
+	return 0;
+}
+
+static int max98090_remove(struct snd_soc_codec *codec)
+{
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_max98090 = {
+	.probe			= max98090_probe,
+	.remove			= max98090_remove,
+	.controls		= max98090_snd_controls,
+	.num_controls		= ARRAY_SIZE(max98090_snd_controls),
+	.dapm_widgets		= max98090_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(max98090_dapm_widgets),
+	.dapm_routes		= max98090_audio_map,
+	.num_dapm_routes	= ARRAY_SIZE(max98090_audio_map),
+};
+
+static const struct regmap_config max98090_regmap = {
+	.reg_bits		= 8,
+	.val_bits		= 8,
+	.max_register		= MAX98090_REG_END,
+	.volatile_reg		= max98090_volatile,
+	.cache_type		= REGCACHE_RBTREE,
+	.reg_defaults		= max98090_reg_defaults,
+	.num_reg_defaults	= ARRAY_SIZE(max98090_reg_defaults),
+};
+
+static int max98090_i2c_probe(struct i2c_client *i2c,
+			      const struct i2c_device_id *id)
+{
+	struct max98090_priv *priv;
+	struct device *dev = &i2c->dev;
+	unsigned int val;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(struct max98090_priv),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regmap = devm_regmap_init_i2c(i2c, &max98090_regmap);
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		dev_err(dev, "Failed to init regmap: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(i2c, priv);
+
+	ret = regmap_read(priv->regmap, MAX98090_0xFF_REV_ID, &val);
+	if (ret < 0) {
+		dev_err(dev, "Failed to read device revision: %d\n", ret);
+		return ret;
+	}
+	dev_info(dev, "revision 0x%02x\n", val);
+
+	ret = snd_soc_register_codec(dev,
+				     &soc_codec_dev_max98090,
+				     &max98090_dai, 1);
+
+	return ret;
+}
+
+static int max98090_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	return 0;
+}
+
+static const struct i2c_device_id max98090_i2c_id[] = {
+	{ "max98090", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max98090_i2c_id);
+
+static struct i2c_driver max98090_i2c_driver = {
+	.driver = {
+		.name = "max98090",
+		.owner = THIS_MODULE,
+	},
+	.probe		= max98090_i2c_probe,
+	.remove		= max98090_i2c_remove,
+	.id_table	= max98090_i2c_id,
+};
+module_i2c_driver(max98090_i2c_driver);
+
+MODULE_DESCRIPTION("ALSA SoC MAX98090 driver");
+MODULE_AUTHOR("Peter Hsiang, Kuninori Morimoto");
+MODULE_LICENSE("GPL");
