commit a636cd6c422865a74ff305039ff0f85adbe3a7bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:34 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 4
    
    Based on 1 normalized pattern(s):
    
      licensed under gplv2 or later
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 118 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154040.961286471@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/sirf/sirf-audio-port.c b/sound/soc/sirf/sirf-audio-port.c
index be066de74aaa..8be2f0bc477b 100644
--- a/sound/soc/sirf/sirf-audio-port.c
+++ b/sound/soc/sirf/sirf-audio-port.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * SiRF Audio port driver
  *
  * Copyright (c) 2011 Cambridge Silicon Radio Limited, a CSR plc group company.
- *
- * Licensed under GPLv2 or later.
  */
 #include <linux/module.h>
 #include <sound/soc.h>

commit adbdba3fa1b618376363db317324c69d8ce5659c
Author: Codrut Grosu <codrut.cristian.grosu@gmail.com>
Date:   Sat Feb 25 21:59:33 2017 +0200

    ASoC: sirf: Added blank line after declarations
    
    This was reported by checkpatch.pl
    
    Signed-off-by: Codrut GROSU <codrut.cristian.grosu@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sirf/sirf-audio-port.c b/sound/soc/sirf/sirf-audio-port.c
index 3f2cce03275c..be066de74aaa 100644
--- a/sound/soc/sirf/sirf-audio-port.c
+++ b/sound/soc/sirf/sirf-audio-port.c
@@ -19,6 +19,7 @@ struct sirf_audio_port {
 static int sirf_audio_port_dai_probe(struct snd_soc_dai *dai)
 {
 	struct sirf_audio_port *port = snd_soc_dai_get_drvdata(dai);
+
 	snd_soc_dai_init_dma_data(dai, &port->playback_dma_data,
 			&port->capture_dma_data);
 	return 0;

commit 33db744abe957baa8440b7065644c1becde28dc3
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:22:14 2014 +0200

    ASoC: sirf: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/soc/sirf/sirf-audio-port.c b/sound/soc/sirf/sirf-audio-port.c
index b4afa31b2bc1..3f2cce03275c 100644
--- a/sound/soc/sirf/sirf-audio-port.c
+++ b/sound/soc/sirf/sirf-audio-port.c
@@ -74,7 +74,6 @@ MODULE_DEVICE_TABLE(of, sirf_audio_port_of_match);
 static struct platform_driver sirf_audio_port_driver = {
 	.driver = {
 		.name = "sirf-audio-port",
-		.owner = THIS_MODULE,
 		.of_match_table = sirf_audio_port_of_match,
 	},
 	.probe = sirf_audio_port_probe,

commit b87704cef258a4f44ab1386a70b7628ec3cefd36
Author: Rongjun Ying <rongjun.ying@csr.com>
Date:   Thu Mar 20 15:46:19 2014 +0800

    ASoC: sirf: Move the tx rx enable from port to codec, that will not need register sharing
    
    The port driver only used to register component and dmaengine pcm.
    
    Signed-off-by: Rongjun Ying <rongjun.ying@csr.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sirf/sirf-audio-port.c b/sound/soc/sirf/sirf-audio-port.c
index b04a53f2b4f6..b4afa31b2bc1 100644
--- a/sound/soc/sirf/sirf-audio-port.c
+++ b/sound/soc/sirf/sirf-audio-port.c
@@ -6,60 +6,15 @@
  * Licensed under GPLv2 or later.
  */
 #include <linux/module.h>
-#include <linux/io.h>
-#include <linux/regmap.h>
 #include <sound/soc.h>
 #include <sound/dmaengine_pcm.h>
 
-#include "sirf-audio-port.h"
-
 struct sirf_audio_port {
 	struct regmap *regmap;
 	struct snd_dmaengine_dai_dma_data playback_dma_data;
 	struct snd_dmaengine_dai_dma_data capture_dma_data;
 };
 
-static void sirf_audio_port_tx_enable(struct sirf_audio_port *port)
-{
-	regmap_update_bits(port->regmap, AUDIO_PORT_IC_TXFIFO_OP,
-		AUDIO_FIFO_RESET, AUDIO_FIFO_RESET);
-	regmap_write(port->regmap, AUDIO_PORT_IC_TXFIFO_INT_MSK, 0);
-	regmap_write(port->regmap, AUDIO_PORT_IC_TXFIFO_OP, 0);
-	regmap_update_bits(port->regmap, AUDIO_PORT_IC_TXFIFO_OP,
-		AUDIO_FIFO_START, AUDIO_FIFO_START);
-	regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_TX_CTRL,
-		IC_TX_ENABLE, IC_TX_ENABLE);
-}
-
-static void sirf_audio_port_tx_disable(struct sirf_audio_port *port)
-{
-	regmap_write(port->regmap, AUDIO_PORT_IC_TXFIFO_OP, 0);
-	regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_TX_CTRL,
-		IC_TX_ENABLE, ~IC_TX_ENABLE);
-}
-
-static void sirf_audio_port_rx_enable(struct sirf_audio_port *port,
-	int channels)
-{
-	regmap_update_bits(port->regmap, AUDIO_PORT_IC_RXFIFO_OP,
-		AUDIO_FIFO_RESET, AUDIO_FIFO_RESET);
-	regmap_write(port->regmap, AUDIO_PORT_IC_RXFIFO_INT_MSK, 0);
-	regmap_write(port->regmap, AUDIO_PORT_IC_RXFIFO_OP, 0);
-	regmap_update_bits(port->regmap, AUDIO_PORT_IC_RXFIFO_OP,
-		AUDIO_FIFO_START, AUDIO_FIFO_START);
-	if (channels == 1)
-		regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_RX_CTRL,
-			IC_RX_ENABLE_MONO, IC_RX_ENABLE_MONO);
-	else
-		regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_RX_CTRL,
-			IC_RX_ENABLE_STEREO, IC_RX_ENABLE_STEREO);
-}
-
-static void sirf_audio_port_rx_disable(struct sirf_audio_port *port)
-{
-	regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_RX_CTRL,
-			IC_RX_ENABLE_STEREO, ~IC_RX_ENABLE_STEREO);
-}
 
 static int sirf_audio_port_dai_probe(struct snd_soc_dai *dai)
 {
@@ -69,41 +24,6 @@ static int sirf_audio_port_dai_probe(struct snd_soc_dai *dai)
 	return 0;
 }
 
-static int sirf_audio_port_trigger(struct snd_pcm_substream *substream, int cmd,
-	struct snd_soc_dai *dai)
-{
-	struct sirf_audio_port *port = snd_soc_dai_get_drvdata(dai);
-	int playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (playback)
-			sirf_audio_port_tx_disable(port);
-		else
-			sirf_audio_port_rx_disable(port);
-		break;
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (playback)
-			sirf_audio_port_tx_enable(port);
-		else
-			sirf_audio_port_rx_enable(port,
-				substream->runtime->channels);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static const struct snd_soc_dai_ops sirf_audio_port_dai_ops = {
-	.trigger = sirf_audio_port_trigger,
-};
-
 static struct snd_soc_dai_driver sirf_audio_port_dai = {
 	.probe = sirf_audio_port_dai_probe,
 	.name = "sirf-audio-port",
@@ -120,49 +40,22 @@ static struct snd_soc_dai_driver sirf_audio_port_dai = {
 		.rates = SNDRV_PCM_RATE_48000,
 		.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	},
-	.ops = &sirf_audio_port_dai_ops,
 };
 
 static const struct snd_soc_component_driver sirf_audio_port_component = {
 	.name       = "sirf-audio-port",
 };
 
-static const struct regmap_config sirf_audio_port_regmap_config = {
-	.reg_bits = 32,
-	.reg_stride = 4,
-	.val_bits = 32,
-	.max_register = AUDIO_PORT_IC_RXFIFO_INT_MSK,
-	.cache_type = REGCACHE_NONE,
-};
-
 static int sirf_audio_port_probe(struct platform_device *pdev)
 {
 	int ret;
 	struct sirf_audio_port *port;
-	void __iomem *base;
-	struct resource *mem_res;
 
 	port = devm_kzalloc(&pdev->dev,
 			sizeof(struct sirf_audio_port), GFP_KERNEL);
 	if (!port)
 		return -ENOMEM;
 
-	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!mem_res) {
-		dev_err(&pdev->dev, "no mem resource?\n");
-		return -ENODEV;
-	}
-
-	base = devm_ioremap(&pdev->dev, mem_res->start,
-			resource_size(mem_res));
-	if (base == NULL)
-		return -ENOMEM;
-
-	port->regmap = devm_regmap_init_mmio(&pdev->dev, base,
-					    &sirf_audio_port_regmap_config);
-	if (IS_ERR(port->regmap))
-		return PTR_ERR(port->regmap);
-
 	ret = devm_snd_soc_register_component(&pdev->dev,
 			&sirf_audio_port_component, &sirf_audio_port_dai, 1);
 	if (ret)

commit a731e217df3a2ee3ef9413153ed7b45e578d8687
Author: Rongjun Ying <rongjun.ying@csr.com>
Date:   Wed Mar 5 16:34:35 2014 +0800

    ASoC: sirf: Add SiRF audio port driver is used by SiRF internal audio codec
    
    This driver is used by SIRF internal audio codec.
    Use dedicated SiRF audio port TXFIFO and RXFIFO
    Supports two DMA channels for SiRF audio port TXFIFO and RXFIFO
    The audio port like as audio bus such as i2s.
    
    Signed-off-by: Rongjun Ying <rongjun.ying@csr.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sirf/sirf-audio-port.c b/sound/soc/sirf/sirf-audio-port.c
new file mode 100644
index 000000000000..b04a53f2b4f6
--- /dev/null
+++ b/sound/soc/sirf/sirf-audio-port.c
@@ -0,0 +1,194 @@
+/*
+ * SiRF Audio port driver
+ *
+ * Copyright (c) 2011 Cambridge Silicon Radio Limited, a CSR plc group company.
+ *
+ * Licensed under GPLv2 or later.
+ */
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/regmap.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "sirf-audio-port.h"
+
+struct sirf_audio_port {
+	struct regmap *regmap;
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+};
+
+static void sirf_audio_port_tx_enable(struct sirf_audio_port *port)
+{
+	regmap_update_bits(port->regmap, AUDIO_PORT_IC_TXFIFO_OP,
+		AUDIO_FIFO_RESET, AUDIO_FIFO_RESET);
+	regmap_write(port->regmap, AUDIO_PORT_IC_TXFIFO_INT_MSK, 0);
+	regmap_write(port->regmap, AUDIO_PORT_IC_TXFIFO_OP, 0);
+	regmap_update_bits(port->regmap, AUDIO_PORT_IC_TXFIFO_OP,
+		AUDIO_FIFO_START, AUDIO_FIFO_START);
+	regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_TX_CTRL,
+		IC_TX_ENABLE, IC_TX_ENABLE);
+}
+
+static void sirf_audio_port_tx_disable(struct sirf_audio_port *port)
+{
+	regmap_write(port->regmap, AUDIO_PORT_IC_TXFIFO_OP, 0);
+	regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_TX_CTRL,
+		IC_TX_ENABLE, ~IC_TX_ENABLE);
+}
+
+static void sirf_audio_port_rx_enable(struct sirf_audio_port *port,
+	int channels)
+{
+	regmap_update_bits(port->regmap, AUDIO_PORT_IC_RXFIFO_OP,
+		AUDIO_FIFO_RESET, AUDIO_FIFO_RESET);
+	regmap_write(port->regmap, AUDIO_PORT_IC_RXFIFO_INT_MSK, 0);
+	regmap_write(port->regmap, AUDIO_PORT_IC_RXFIFO_OP, 0);
+	regmap_update_bits(port->regmap, AUDIO_PORT_IC_RXFIFO_OP,
+		AUDIO_FIFO_START, AUDIO_FIFO_START);
+	if (channels == 1)
+		regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_RX_CTRL,
+			IC_RX_ENABLE_MONO, IC_RX_ENABLE_MONO);
+	else
+		regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_RX_CTRL,
+			IC_RX_ENABLE_STEREO, IC_RX_ENABLE_STEREO);
+}
+
+static void sirf_audio_port_rx_disable(struct sirf_audio_port *port)
+{
+	regmap_update_bits(port->regmap, AUDIO_PORT_IC_CODEC_RX_CTRL,
+			IC_RX_ENABLE_STEREO, ~IC_RX_ENABLE_STEREO);
+}
+
+static int sirf_audio_port_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sirf_audio_port *port = snd_soc_dai_get_drvdata(dai);
+	snd_soc_dai_init_dma_data(dai, &port->playback_dma_data,
+			&port->capture_dma_data);
+	return 0;
+}
+
+static int sirf_audio_port_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct sirf_audio_port *port = snd_soc_dai_get_drvdata(dai);
+	int playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (playback)
+			sirf_audio_port_tx_disable(port);
+		else
+			sirf_audio_port_rx_disable(port);
+		break;
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (playback)
+			sirf_audio_port_tx_enable(port);
+		else
+			sirf_audio_port_rx_enable(port,
+				substream->runtime->channels);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sirf_audio_port_dai_ops = {
+	.trigger = sirf_audio_port_trigger,
+};
+
+static struct snd_soc_dai_driver sirf_audio_port_dai = {
+	.probe = sirf_audio_port_dai_probe,
+	.name = "sirf-audio-port",
+	.id = 0,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &sirf_audio_port_dai_ops,
+};
+
+static const struct snd_soc_component_driver sirf_audio_port_component = {
+	.name       = "sirf-audio-port",
+};
+
+static const struct regmap_config sirf_audio_port_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = AUDIO_PORT_IC_RXFIFO_INT_MSK,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int sirf_audio_port_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct sirf_audio_port *port;
+	void __iomem *base;
+	struct resource *mem_res;
+
+	port = devm_kzalloc(&pdev->dev,
+			sizeof(struct sirf_audio_port), GFP_KERNEL);
+	if (!port)
+		return -ENOMEM;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_res) {
+		dev_err(&pdev->dev, "no mem resource?\n");
+		return -ENODEV;
+	}
+
+	base = devm_ioremap(&pdev->dev, mem_res->start,
+			resource_size(mem_res));
+	if (base == NULL)
+		return -ENOMEM;
+
+	port->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					    &sirf_audio_port_regmap_config);
+	if (IS_ERR(port->regmap))
+		return PTR_ERR(port->regmap);
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+			&sirf_audio_port_component, &sirf_audio_port_dai, 1);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, port);
+	return devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+}
+
+static const struct of_device_id sirf_audio_port_of_match[] = {
+	{ .compatible = "sirf,audio-port", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sirf_audio_port_of_match);
+
+static struct platform_driver sirf_audio_port_driver = {
+	.driver = {
+		.name = "sirf-audio-port",
+		.owner = THIS_MODULE,
+		.of_match_table = sirf_audio_port_of_match,
+	},
+	.probe = sirf_audio_port_probe,
+};
+
+module_platform_driver(sirf_audio_port_driver);
+
+MODULE_DESCRIPTION("SiRF Audio Port driver");
+MODULE_AUTHOR("RongJun Ying <Rongjun.Ying@csr.com>");
+MODULE_LICENSE("GPL v2");
