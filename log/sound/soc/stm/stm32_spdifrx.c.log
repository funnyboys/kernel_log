commit 8c0b6e150c5b1e6359e4f478d9fa4aaae345979d
Merge: a23d7f4a7cf1 f25e203070e5
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 27 16:04:55 2020 +0000

    Merge branch 'for-5.6' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-5.7

commit 794df9448edb55978e50372f083aeedade1b2844
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Wed Mar 18 15:41:24 2020 +0100

    ASoC: stm32: spdifrx: manage rebind issue
    
    The commit e894efef9ac7 ("ASoC: core: add support to card rebind")
    allows to rebind the sound card after a rebind of one of its component.
    With this commit, the sound card is actually rebound,
    but may be no more functional.
    
    Corrections:
    - Call snd_dmaengine_pcm_register() before snd_soc_register_component().
    - Call snd_dmaengine_pcm_unregister() and snd_soc_unregister_component()
    explicitly from SPDFIRX driver.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20200318144125.9163-3-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 49766afdae61..ae7a0f46a6fb 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -944,6 +944,22 @@ static int stm32_spdifrx_parse_of(struct platform_device *pdev,
 	return 0;
 }
 
+static int stm32_spdifrx_remove(struct platform_device *pdev)
+{
+	struct stm32_spdifrx_data *spdifrx = platform_get_drvdata(pdev);
+
+	if (spdifrx->ctrl_chan)
+		dma_release_channel(spdifrx->ctrl_chan);
+
+	if (spdifrx->dmab)
+		snd_dma_free_pages(spdifrx->dmab);
+
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
+
+	return 0;
+}
+
 static int stm32_spdifrx_probe(struct platform_device *pdev)
 {
 	struct stm32_spdifrx_data *spdifrx;
@@ -995,25 +1011,27 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 	udelay(2);
 	reset_control_deassert(rst);
 
-	ret = devm_snd_soc_register_component(&pdev->dev,
-					      &stm32_spdifrx_component,
-					      stm32_spdifrx_dai,
-					      ARRAY_SIZE(stm32_spdifrx_dai));
-	if (ret)
-		return ret;
-
-	ret = stm32_spdifrx_dma_ctrl_register(&pdev->dev, spdifrx);
-	if (ret)
-		goto error;
-
 	pcm_config = &stm32_spdifrx_pcm_config;
-	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, pcm_config, 0);
+	ret = snd_dmaengine_pcm_register(&pdev->dev, pcm_config, 0);
 	if (ret) {
 		if (ret != -EPROBE_DEFER)
 			dev_err(&pdev->dev, "PCM DMA register error %d\n", ret);
-		goto error;
+		return ret;
 	}
 
+	ret = snd_soc_register_component(&pdev->dev,
+					 &stm32_spdifrx_component,
+					 stm32_spdifrx_dai,
+					 ARRAY_SIZE(stm32_spdifrx_dai));
+	if (ret) {
+		snd_dmaengine_pcm_unregister(&pdev->dev);
+		return ret;
+	}
+
+	ret = stm32_spdifrx_dma_ctrl_register(&pdev->dev, spdifrx);
+	if (ret)
+		goto error;
+
 	ret = regmap_read(spdifrx->regmap, STM32_SPDIFRX_IDR, &idr);
 	if (ret)
 		goto error;
@@ -1029,27 +1047,11 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 	return ret;
 
 error:
-	if (!IS_ERR(spdifrx->ctrl_chan))
-		dma_release_channel(spdifrx->ctrl_chan);
-	if (spdifrx->dmab)
-		snd_dma_free_pages(spdifrx->dmab);
+	stm32_spdifrx_remove(pdev);
 
 	return ret;
 }
 
-static int stm32_spdifrx_remove(struct platform_device *pdev)
-{
-	struct stm32_spdifrx_data *spdifrx = platform_get_drvdata(pdev);
-
-	if (spdifrx->ctrl_chan)
-		dma_release_channel(spdifrx->ctrl_chan);
-
-	if (spdifrx->dmab)
-		snd_dma_free_pages(spdifrx->dmab);
-
-	return 0;
-}
-
 MODULE_DEVICE_TABLE(of, stm32_spdifrx_ids);
 
 #ifdef CONFIG_PM_SLEEP

commit a168dae5ea14283e8992d5282237bb0d6a3e1c06
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Wed Mar 18 15:41:23 2020 +0100

    ASoC: stm32: spdifrx: fix regmap status check
    
    Release resources when exiting on error.
    
    Fixes: 1a5c0b28fc56 ("ASoC: stm32: spdifrx: manage identification registers")
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20200318144125.9163-2-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 3769d9ce5dbe..e6e75897cce8 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -1009,6 +1009,8 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 
 	if (idr == SPDIFRX_IPIDR_NUMBER) {
 		ret = regmap_read(spdifrx->regmap, STM32_SPDIFRX_VERR, &ver);
+		if (ret)
+			goto error;
 
 		dev_dbg(&pdev->dev, "SPDIFRX version: %lu.%lu registered\n",
 			FIELD_GET(SPDIFRX_VERR_MAJ_MASK, ver),

commit d49bd5ed24163a1a1c81d40e84295731ddd17b1c
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon Feb 3 11:08:13 2020 +0100

    ASoC: stm32: spdifrx: improve error management on probe deferral
    
    Do not print an error trace when deferring probe for SPDIFRX driver.
    
    Signed-off-by: Etienne Carriere <etienne.carriere@st.com>
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20200203100814.22944-6-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 9f80ddf34443..49766afdae61 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -406,7 +406,9 @@ static int stm32_spdifrx_dma_ctrl_register(struct device *dev,
 
 	spdifrx->ctrl_chan = dma_request_chan(dev, "rx-ctrl");
 	if (IS_ERR(spdifrx->ctrl_chan)) {
-		dev_err(dev, "dma_request_slave_channel failed\n");
+		if (PTR_ERR(spdifrx->ctrl_chan) != -EPROBE_DEFER)
+			dev_err(dev, "dma_request_slave_channel error %ld\n",
+				PTR_ERR(spdifrx->ctrl_chan));
 		return PTR_ERR(spdifrx->ctrl_chan);
 	}
 
@@ -929,7 +931,9 @@ static int stm32_spdifrx_parse_of(struct platform_device *pdev,
 
 	spdifrx->kclk = devm_clk_get(&pdev->dev, "kclk");
 	if (IS_ERR(spdifrx->kclk)) {
-		dev_err(&pdev->dev, "Could not get kclk\n");
+		if (PTR_ERR(spdifrx->kclk) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Could not get kclk: %ld\n",
+				PTR_ERR(spdifrx->kclk));
 		return PTR_ERR(spdifrx->kclk);
 	}
 
@@ -967,7 +971,9 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 						    spdifrx->base,
 						    spdifrx->regmap_conf);
 	if (IS_ERR(spdifrx->regmap)) {
-		dev_err(&pdev->dev, "Regmap init failed\n");
+		if (PTR_ERR(spdifrx->regmap) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Regmap init error %ld\n",
+				PTR_ERR(spdifrx->regmap));
 		return PTR_ERR(spdifrx->regmap);
 	}
 
@@ -1003,7 +1009,8 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 	pcm_config = &stm32_spdifrx_pcm_config;
 	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, pcm_config, 0);
 	if (ret) {
-		dev_err(&pdev->dev, "PCM DMA register returned %d\n", ret);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "PCM DMA register error %d\n", ret);
 		goto error;
 	}
 

commit 7889c0082e6400ae5d07345e5573548d0999b840
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon Feb 3 11:08:10 2020 +0100

    ASoC: stm32: spdifrx: manage error when getting reset controller
    
    Return an error when the SPDIFRX driver fails to get a reset controller.
    Also add an error trace, except on probe defer status.
    
    Signed-off-by: Etienne Carriere <etienne.carriere@st.com>
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20200203100814.22944-3-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 3769d9ce5dbe..9f80ddf34443 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -978,12 +978,16 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
-	if (!IS_ERR(rst)) {
-		reset_control_assert(rst);
-		udelay(2);
-		reset_control_deassert(rst);
+	rst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(rst)) {
+		if (PTR_ERR(rst) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Reset controller error %ld\n",
+				PTR_ERR(rst));
+		return PTR_ERR(rst);
 	}
+	reset_control_assert(rst);
+	udelay(2);
+	reset_control_deassert(rst);
 
 	ret = devm_snd_soc_register_component(&pdev->dev,
 					      &stm32_spdifrx_component,

commit 3b7658679d88b5628939f9bdc8e613f79cd821f9
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Wed Dec 4 16:43:33 2019 +0100

    ASoC: stm32: spdifrx: fix input pin state management
    
    Changing input state in iec capture control is not safe,
    as the pin state may be changed concurrently by ASoC
    framework.
    Remove pin state handling in iec capture control.
    
    Note: This introduces a restriction on capture control,
    when pin sleep state is defined in device tree. In this case
    channel status can be captured only when an audio stream
    capture is active.
    
    Fixes: f68c2a682d44 ("ASoC: stm32: spdifrx: add power management")
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20191204154333.7152-4-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 3cb8e6db3eeb..3769d9ce5dbe 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -12,7 +12,6 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
-#include <linux/pinctrl/consumer.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
 
@@ -484,8 +483,6 @@ static int stm32_spdifrx_get_ctrl_data(struct stm32_spdifrx_data *spdifrx)
 	memset(spdifrx->cs, 0, SPDIFRX_CS_BYTES_NB);
 	memset(spdifrx->ub, 0, SPDIFRX_UB_BYTES_NB);
 
-	pinctrl_pm_select_default_state(&spdifrx->pdev->dev);
-
 	ret = stm32_spdifrx_dma_ctrl_start(spdifrx);
 	if (ret < 0)
 		return ret;
@@ -517,7 +514,6 @@ static int stm32_spdifrx_get_ctrl_data(struct stm32_spdifrx_data *spdifrx)
 
 end:
 	clk_disable_unprepare(spdifrx->kclk);
-	pinctrl_pm_select_sleep_state(&spdifrx->pdev->dev);
 
 	return ret;
 }

commit 86e1956af4c863d653136fd6e5694adf2054dbaa
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Wed Dec 4 16:43:32 2019 +0100

    ASoC: stm32: spdifrx: fix race condition in irq handler
    
    When snd_pcm_stop() is called in interrupt routine,
    substream context may have already been released.
    Add protection on substream context.
    
    Fixes: 03e4d5d56fa5 ("ASoC: stm32: Add SPDIFRX support")
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20191204154333.7152-3-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 9c6beb610c17..3cb8e6db3eeb 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -220,6 +220,7 @@
  * @slave_config: dma slave channel runtime config pointer
  * @phys_addr: SPDIFRX registers physical base address
  * @lock: synchronization enabling lock
+ * @irq_lock: prevent race condition with IRQ on stream state
  * @cs: channel status buffer
  * @ub: user data buffer
  * @irq: SPDIFRX interrupt line
@@ -240,6 +241,7 @@ struct stm32_spdifrx_data {
 	struct dma_slave_config slave_config;
 	dma_addr_t phys_addr;
 	spinlock_t lock;  /* Sync enabling lock */
+	spinlock_t irq_lock; /* Prevent race condition on stream state */
 	unsigned char cs[SPDIFRX_CS_BYTES_NB];
 	unsigned char ub[SPDIFRX_UB_BYTES_NB];
 	int irq;
@@ -667,7 +669,6 @@ static const struct regmap_config stm32_h7_spdifrx_regmap_conf = {
 static irqreturn_t stm32_spdifrx_isr(int irq, void *devid)
 {
 	struct stm32_spdifrx_data *spdifrx = (struct stm32_spdifrx_data *)devid;
-	struct snd_pcm_substream *substream = spdifrx->substream;
 	struct platform_device *pdev = spdifrx->pdev;
 	unsigned int cr, mask, sr, imr;
 	unsigned int flags, sync_state;
@@ -747,14 +748,19 @@ static irqreturn_t stm32_spdifrx_isr(int irq, void *devid)
 			return IRQ_HANDLED;
 		}
 
-		if (substream)
-			snd_pcm_stop(substream, SNDRV_PCM_STATE_DISCONNECTED);
+		spin_lock(&spdifrx->irq_lock);
+		if (spdifrx->substream)
+			snd_pcm_stop(spdifrx->substream,
+				     SNDRV_PCM_STATE_DISCONNECTED);
+		spin_unlock(&spdifrx->irq_lock);
 
 		return IRQ_HANDLED;
 	}
 
-	if (err_xrun && substream)
-		snd_pcm_stop_xrun(substream);
+	spin_lock(&spdifrx->irq_lock);
+	if (err_xrun && spdifrx->substream)
+		snd_pcm_stop_xrun(spdifrx->substream);
+	spin_unlock(&spdifrx->irq_lock);
 
 	return IRQ_HANDLED;
 }
@@ -763,9 +769,12 @@ static int stm32_spdifrx_startup(struct snd_pcm_substream *substream,
 				 struct snd_soc_dai *cpu_dai)
 {
 	struct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
 	int ret;
 
+	spin_lock_irqsave(&spdifrx->irq_lock, flags);
 	spdifrx->substream = substream;
+	spin_unlock_irqrestore(&spdifrx->irq_lock, flags);
 
 	ret = clk_prepare_enable(spdifrx->kclk);
 	if (ret)
@@ -841,8 +850,12 @@ static void stm32_spdifrx_shutdown(struct snd_pcm_substream *substream,
 				   struct snd_soc_dai *cpu_dai)
 {
 	struct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
 
+	spin_lock_irqsave(&spdifrx->irq_lock, flags);
 	spdifrx->substream = NULL;
+	spin_unlock_irqrestore(&spdifrx->irq_lock, flags);
+
 	clk_disable_unprepare(spdifrx->kclk);
 }
 
@@ -946,6 +959,7 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 	spdifrx->pdev = pdev;
 	init_completion(&spdifrx->cs_completion);
 	spin_lock_init(&spdifrx->lock);
+	spin_lock_init(&spdifrx->irq_lock);
 
 	platform_set_drvdata(pdev, spdifrx);
 

commit 2859b1784031b5709446af8f6039c467f136e67d
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Wed Dec 4 16:43:31 2019 +0100

    ASoC: stm32: spdifrx: fix inconsistent lock state
    
    In current spdifrx driver locks may be requested as follows:
    - request lock on iec capture control, when starting synchronization.
    - request lock in interrupt context, when spdifrx stop is called
    from IRQ handler.
    
    Take lock with IRQs disabled, to avoid the possible deadlock.
    
    Lockdep report:
    [   74.278059] ================================
    [   74.282306] WARNING: inconsistent lock state
    [   74.290120] --------------------------------
    ...
    [   74.314373]        CPU0
    [   74.314377]        ----
    [   74.314381]   lock(&(&spdifrx->lock)->rlock);
    [   74.314396]   <Interrupt>
    [   74.314400]     lock(&(&spdifrx->lock)->rlock);
    
    Fixes: 03e4d5d56fa5 ("ASoC: stm32: Add SPDIFRX support")
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20191204154333.7152-2-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 3fd28ee01675..9c6beb610c17 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -320,6 +320,7 @@ static void stm32_spdifrx_dma_ctrl_stop(struct stm32_spdifrx_data *spdifrx)
 static int stm32_spdifrx_start_sync(struct stm32_spdifrx_data *spdifrx)
 {
 	int cr, cr_mask, imr, ret;
+	unsigned long flags;
 
 	/* Enable IRQs */
 	imr = SPDIFRX_IMR_IFEIE | SPDIFRX_IMR_SYNCDIE | SPDIFRX_IMR_PERRIE;
@@ -327,7 +328,7 @@ static int stm32_spdifrx_start_sync(struct stm32_spdifrx_data *spdifrx)
 	if (ret)
 		return ret;
 
-	spin_lock(&spdifrx->lock);
+	spin_lock_irqsave(&spdifrx->lock, flags);
 
 	spdifrx->refcount++;
 
@@ -362,7 +363,7 @@ static int stm32_spdifrx_start_sync(struct stm32_spdifrx_data *spdifrx)
 				"Failed to start synchronization\n");
 	}
 
-	spin_unlock(&spdifrx->lock);
+	spin_unlock_irqrestore(&spdifrx->lock, flags);
 
 	return ret;
 }
@@ -370,11 +371,12 @@ static int stm32_spdifrx_start_sync(struct stm32_spdifrx_data *spdifrx)
 static void stm32_spdifrx_stop(struct stm32_spdifrx_data *spdifrx)
 {
 	int cr, cr_mask, reg;
+	unsigned long flags;
 
-	spin_lock(&spdifrx->lock);
+	spin_lock_irqsave(&spdifrx->lock, flags);
 
 	if (--spdifrx->refcount) {
-		spin_unlock(&spdifrx->lock);
+		spin_unlock_irqrestore(&spdifrx->lock, flags);
 		return;
 	}
 
@@ -393,7 +395,7 @@ static void stm32_spdifrx_stop(struct stm32_spdifrx_data *spdifrx)
 	regmap_read(spdifrx->regmap, STM32_SPDIFRX_DR, &reg);
 	regmap_read(spdifrx->regmap, STM32_SPDIFRX_CSR, &reg);
 
-	spin_unlock(&spdifrx->lock);
+	spin_unlock_irqrestore(&spdifrx->lock, flags);
 }
 
 static int stm32_spdifrx_dma_ctrl_register(struct device *dev,

commit 0c93c291321f2ba8dc4cd3d4df74801caaa297db
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Fri Oct 11 10:48:16 2019 +0200

    ASoC: stm32: spdifrx: retry synchronization in sync state
    
    When STM32 SPDIFRX is in sync state, allow multiple
    synchro attempts, instead of exiting on first unsuccessful
    trial. This is useful when spdif signal is not immediately
    available on input. This also allows Pulseaudio to check
    iec capture device availability when no signal is present.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20191011084816.14279-1-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index cd4b235fce57..3fd28ee01675 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -351,6 +351,8 @@ static int stm32_spdifrx_start_sync(struct stm32_spdifrx_data *spdifrx)
 		     SPDIFRX_CR_CUMSK | SPDIFRX_CR_PTMSK | SPDIFRX_CR_RXSTEO;
 		cr_mask = cr;
 
+		cr |= SPDIFRX_CR_NBTRSET(SPDIFRX_NBTR_63);
+		cr_mask |= SPDIFRX_CR_NBTR_MASK;
 		cr |= SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_SYNC);
 		cr_mask |= SPDIFRX_CR_SPDIFEN_MASK;
 		ret = regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
@@ -666,7 +668,7 @@ static irqreturn_t stm32_spdifrx_isr(int irq, void *devid)
 	struct snd_pcm_substream *substream = spdifrx->substream;
 	struct platform_device *pdev = spdifrx->pdev;
 	unsigned int cr, mask, sr, imr;
-	unsigned int flags;
+	unsigned int flags, sync_state;
 	int err = 0, err_xrun = 0;
 
 	regmap_read(spdifrx->regmap, STM32_SPDIFRX_SR, &sr);
@@ -726,11 +728,23 @@ static irqreturn_t stm32_spdifrx_isr(int irq, void *devid)
 	}
 
 	if (err) {
-		/* SPDIFRX in STATE_STOP. Disable SPDIFRX to clear errors */
+		regmap_read(spdifrx->regmap, STM32_SPDIFRX_CR, &cr);
+		sync_state = FIELD_GET(SPDIFRX_CR_SPDIFEN_MASK, cr) &&
+			     SPDIFRX_SPDIFEN_SYNC;
+
+		/* SPDIFRX is in STATE_STOP. Disable SPDIFRX to clear errors */
 		cr = SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_DISABLE);
 		regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
 				   SPDIFRX_CR_SPDIFEN_MASK, cr);
 
+		/* If SPDIFRX was in STATE_SYNC, retry synchro */
+		if (sync_state) {
+			cr = SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_SYNC);
+			regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
+					   SPDIFRX_CR_SPDIFEN_MASK, cr);
+			return IRQ_HANDLED;
+		}
+
 		if (substream)
 			snd_pcm_stop(substream, SNDRV_PCM_STATE_DISCONNECTED);
 

commit cf9441adb1a35506d7606866c382b9d8614169b5
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jul 30 11:15:49 2019 -0700

    ASoC: Remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Cc: alsa-devel@alsa-project.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20190730181557.90391-50-swboyd@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index ee71b898897b..cd4b235fce57 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -909,10 +909,8 @@ static int stm32_spdifrx_parse_of(struct platform_device *pdev,
 	}
 
 	spdifrx->irq = platform_get_irq(pdev, 0);
-	if (spdifrx->irq < 0) {
-		dev_err(&pdev->dev, "No irq for node %s\n", pdev->name);
+	if (spdifrx->irq < 0)
 		return spdifrx->irq;
-	}
 
 	return 0;
 }

commit 53c8b29abe42e5601cfa0ea5962532f0cfdec8a0
Merge: e3303268f9cf 4b972a01a7da
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Jun 26 12:39:34 2019 +0100

    Merge tag 'v5.2-rc6' into asoc-5.3
    
    Linux 5.2-rc6

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 3d64200edbb5..56d79695577c 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -1,19 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * STM32 ALSA SoC Digital Audio Interface (SPDIF-rx) driver.
  *
  * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
  * Author(s): Olivier Moysan <olivier.moysan@st.com> for STMicroelectronics.
- *
- * License terms: GPL V2.0.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
- * details.
  */
 
 #include <linux/clk.h>

commit 1c7c3237c0cc4ad3c7b0df458290c8e2a652f178
Merge: bfa8130f50a6 a188339ca5a3
Author: Mark Brown <broonie@kernel.org>
Date:   Mon May 20 11:53:50 2019 +0100

    Merge tag 'v5.2-rc1' into asoc-5.3
    
    Linux 5.2-rc1

commit 1a5c0b28fc56044737f988960f3bc5fdcdba0827
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon May 6 14:44:06 2019 +0200

    ASoC: stm32: spdifrx: manage identification registers
    
    Add support of identification registers in STM32 SPDIFRX.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index b4c3d983e195..62a887ee4a03 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -16,6 +16,7 @@
  * details.
  */
 
+#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/completion.h>
 #include <linux/delay.h>
@@ -36,6 +37,9 @@
 #define STM32_SPDIFRX_DR	0x10
 #define STM32_SPDIFRX_CSR	0x14
 #define STM32_SPDIFRX_DIR	0x18
+#define STM32_SPDIFRX_VERR	0x3F4
+#define STM32_SPDIFRX_IDR	0x3F8
+#define STM32_SPDIFRX_SIDR	0x3FC
 
 /* Bit definition for SPDIF_CR register */
 #define SPDIFRX_CR_SPDIFEN_SHIFT	0
@@ -169,6 +173,18 @@
 #define SPDIFRX_SPDIFEN_SYNC	0x1
 #define SPDIFRX_SPDIFEN_ENABLE	0x3
 
+/* Bit definition for SPDIFRX_VERR register */
+#define SPDIFRX_VERR_MIN_MASK	GENMASK(3, 0)
+#define SPDIFRX_VERR_MAJ_MASK	GENMASK(7, 4)
+
+/* Bit definition for SPDIFRX_IDR register */
+#define SPDIFRX_IDR_ID_MASK	GENMASK(31, 0)
+
+/* Bit definition for SPDIFRX_SIDR register */
+#define SPDIFRX_SIDR_SID_MASK	GENMASK(31, 0)
+
+#define SPDIFRX_IPIDR_NUMBER	0x00130041
+
 #define SPDIFRX_IN1		0x1
 #define SPDIFRX_IN2		0x2
 #define SPDIFRX_IN3		0x3
@@ -607,6 +623,9 @@ static bool stm32_spdifrx_readable_reg(struct device *dev, unsigned int reg)
 	case STM32_SPDIFRX_DR:
 	case STM32_SPDIFRX_CSR:
 	case STM32_SPDIFRX_DIR:
+	case STM32_SPDIFRX_VERR:
+	case STM32_SPDIFRX_IDR:
+	case STM32_SPDIFRX_SIDR:
 		return true;
 	default:
 		return false;
@@ -642,10 +661,11 @@ static const struct regmap_config stm32_h7_spdifrx_regmap_conf = {
 	.reg_bits = 32,
 	.reg_stride = 4,
 	.val_bits = 32,
-	.max_register = STM32_SPDIFRX_DIR,
+	.max_register = STM32_SPDIFRX_SIDR,
 	.readable_reg = stm32_spdifrx_readable_reg,
 	.volatile_reg = stm32_spdifrx_volatile_reg,
 	.writeable_reg = stm32_spdifrx_writeable_reg,
+	.num_reg_defaults_raw = STM32_SPDIFRX_SIDR / sizeof(u32) + 1,
 	.fast_io = true,
 	.cache_type = REGCACHE_FLAT,
 };
@@ -911,6 +931,7 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 	struct stm32_spdifrx_data *spdifrx;
 	struct reset_control *rst;
 	const struct snd_dmaengine_pcm_config *pcm_config = NULL;
+	u32 ver, idr;
 	int ret;
 
 	spdifrx = devm_kzalloc(&pdev->dev, sizeof(*spdifrx), GFP_KERNEL);
@@ -967,7 +988,19 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 		goto error;
 	}
 
-	return 0;
+	ret = regmap_read(spdifrx->regmap, STM32_SPDIFRX_IDR, &idr);
+	if (ret)
+		goto error;
+
+	if (idr == SPDIFRX_IPIDR_NUMBER) {
+		ret = regmap_read(spdifrx->regmap, STM32_SPDIFRX_VERR, &ver);
+
+		dev_dbg(&pdev->dev, "SPDIFRX version: %lu.%lu registered\n",
+			FIELD_GET(SPDIFRX_VERR_MAJ_MASK, ver),
+			FIELD_GET(SPDIFRX_VERR_MIN_MASK, ver));
+	}
+
+	return ret;
 
 error:
 	if (!IS_ERR(spdifrx->ctrl_chan))

commit 19e42536b27121bcf6ee841b25054f8bacafd8c7
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon May 6 14:44:05 2019 +0200

    ASoC: stm32: spdifrx: change trace level on iec control
    
    Change trace level to debug to avoid spurious messages.
    Return quietly when accessing iec958 control, while no
    S/PDIF signal is available.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index aa83b50efabb..3d64200edbb5 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -496,7 +496,7 @@ static int stm32_spdifrx_get_ctrl_data(struct stm32_spdifrx_data *spdifrx)
 	if (wait_for_completion_interruptible_timeout(&spdifrx->cs_completion,
 						      msecs_to_jiffies(100))
 						      <= 0) {
-		dev_err(&spdifrx->pdev->dev, "Failed to get control data\n");
+		dev_dbg(&spdifrx->pdev->dev, "Failed to get control data\n");
 		ret = -EAGAIN;
 	}
 

commit 863137f0bc5eb2a3a65d1d29778ac65642171b17
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon May 6 14:44:04 2019 +0200

    ASoC: stm32: spdifrx: update pcm hardware constraints
    
    - Set period minimum size. Ensure at least 5ms period
    up to 48kHz/16 bits to prevent underrun/overrun.
    - Remove MDMA constraints on period maximum size and
    set period maximum to half the buffer maximum size.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index b4c3d983e195..aa83b50efabb 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -845,7 +845,8 @@ static struct snd_soc_dai_driver stm32_spdifrx_dai[] = {
 static const struct snd_pcm_hardware stm32_spdifrx_pcm_hw = {
 	.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_MMAP,
 	.buffer_bytes_max = 8 * PAGE_SIZE,
-	.period_bytes_max = 2048, /* MDMA constraint */
+	.period_bytes_min = 1024,
+	.period_bytes_max = 4 * PAGE_SIZE,
 	.periods_min = 2,
 	.periods_max = 8,
 };

commit f68c2a682d444296403d1aa6e73b3de0681fdcea
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Wed Mar 6 17:48:08 2019 +0100

    ASoC: stm32: spdifrx: add power management
    
    Add suspend and resume sleep callbacks to STM32 SPDIFRX driver,
    to support system low power modes.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 373df4f24be1..b4c3d983e195 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -21,6 +21,7 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
+#include <linux/pinctrl/consumer.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
 
@@ -471,6 +472,8 @@ static int stm32_spdifrx_get_ctrl_data(struct stm32_spdifrx_data *spdifrx)
 	memset(spdifrx->cs, 0, SPDIFRX_CS_BYTES_NB);
 	memset(spdifrx->ub, 0, SPDIFRX_UB_BYTES_NB);
 
+	pinctrl_pm_select_default_state(&spdifrx->pdev->dev);
+
 	ret = stm32_spdifrx_dma_ctrl_start(spdifrx);
 	if (ret < 0)
 		return ret;
@@ -502,6 +505,7 @@ static int stm32_spdifrx_get_ctrl_data(struct stm32_spdifrx_data *spdifrx)
 
 end:
 	clk_disable_unprepare(spdifrx->kclk);
+	pinctrl_pm_select_sleep_state(&spdifrx->pdev->dev);
 
 	return ret;
 }
@@ -611,10 +615,15 @@ static bool stm32_spdifrx_readable_reg(struct device *dev, unsigned int reg)
 
 static bool stm32_spdifrx_volatile_reg(struct device *dev, unsigned int reg)
 {
-	if (reg == STM32_SPDIFRX_DR)
+	switch (reg) {
+	case STM32_SPDIFRX_DR:
+	case STM32_SPDIFRX_CSR:
+	case STM32_SPDIFRX_SR:
+	case STM32_SPDIFRX_DIR:
 		return true;
-
-	return false;
+	default:
+		return false;
+	}
 }
 
 static bool stm32_spdifrx_writeable_reg(struct device *dev, unsigned int reg)
@@ -638,6 +647,7 @@ static const struct regmap_config stm32_h7_spdifrx_regmap_conf = {
 	.volatile_reg = stm32_spdifrx_volatile_reg,
 	.writeable_reg = stm32_spdifrx_writeable_reg,
 	.fast_io = true,
+	.cache_type = REGCACHE_FLAT,
 };
 
 static irqreturn_t stm32_spdifrx_isr(int irq, void *devid)
@@ -983,10 +993,36 @@ static int stm32_spdifrx_remove(struct platform_device *pdev)
 
 MODULE_DEVICE_TABLE(of, stm32_spdifrx_ids);
 
+#ifdef CONFIG_PM_SLEEP
+static int stm32_spdifrx_suspend(struct device *dev)
+{
+	struct stm32_spdifrx_data *spdifrx = dev_get_drvdata(dev);
+
+	regcache_cache_only(spdifrx->regmap, true);
+	regcache_mark_dirty(spdifrx->regmap);
+
+	return 0;
+}
+
+static int stm32_spdifrx_resume(struct device *dev)
+{
+	struct stm32_spdifrx_data *spdifrx = dev_get_drvdata(dev);
+
+	regcache_cache_only(spdifrx->regmap, false);
+
+	return regcache_sync(spdifrx->regmap);
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops stm32_spdifrx_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_spdifrx_suspend, stm32_spdifrx_resume)
+};
+
 static struct platform_driver stm32_spdifrx_driver = {
 	.driver = {
 		.name = "st,stm32-spdifrx",
 		.of_match_table = stm32_spdifrx_ids,
+		.pm = &stm32_spdifrx_pm_ops,
 	},
 	.probe = stm32_spdifrx_probe,
 	.remove = stm32_spdifrx_remove,

commit 037002b14b7ae217aa79b260228ba51afc516a8c
Author: olivier moysan <olivier.moysan@st.com>
Date:   Wed Jan 31 17:47:03 2018 +0100

    ASoC: stm32: spdifrx: Use default dai name
    
    Use dai name provided by framework from dev_name() function.
    
    Signed-off-by: olivier moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 42ad2ae22d21..373df4f24be1 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -819,7 +819,6 @@ static const struct snd_soc_dai_ops stm32_spdifrx_pcm_dai_ops = {
 
 static struct snd_soc_dai_driver stm32_spdifrx_dai[] = {
 	{
-		.name = "spdifrx-capture-cpu-dai",
 		.probe = stm32_spdifrx_dai_probe,
 		.capture = {
 			.stream_name = "CPU-Capture",

commit b9aa4716281247960e009dd55c38bcc4c2e4cb94
Author: olivier moysan <olivier.moysan@st.com>
Date:   Wed Jan 31 17:47:02 2018 +0100

    ASoC: stm32: spdifrx: fix typo in function name.
    
    Fix function name prefix for naming consistency.
    
    Signed-off-by: olivier moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index b9bdefcd3e10..42ad2ae22d21 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -858,8 +858,8 @@ static const struct of_device_id stm32_spdifrx_ids[] = {
 	{}
 };
 
-static int stm_spdifrx_parse_of(struct platform_device *pdev,
-				struct stm32_spdifrx_data *spdifrx)
+static int stm32_spdifrx_parse_of(struct platform_device *pdev,
+				  struct stm32_spdifrx_data *spdifrx)
 {
 	struct device_node *np = pdev->dev.of_node;
 	const struct of_device_id *of_id;
@@ -914,7 +914,7 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, spdifrx);
 
-	ret = stm_spdifrx_parse_of(pdev, spdifrx);
+	ret = stm32_spdifrx_parse_of(pdev, spdifrx);
 	if (ret)
 		return ret;
 

commit 98c8dc2fd59fdad77d26d7b0d7007776c5fbec16
Author: olivier moysan <olivier.moysan@st.com>
Date:   Mon Nov 6 16:18:53 2017 +0100

    ASoC: stm32: spdifrx: fix control DMA error management
    
    Fix DMA channel request error handling.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index d7dbe84d5eeb..b9bdefcd3e10 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -392,6 +392,12 @@ static int stm32_spdifrx_dma_ctrl_register(struct device *dev,
 {
 	int ret;
 
+	spdifrx->ctrl_chan = dma_request_chan(dev, "rx-ctrl");
+	if (IS_ERR(spdifrx->ctrl_chan)) {
+		dev_err(dev, "dma_request_slave_channel failed\n");
+		return PTR_ERR(spdifrx->ctrl_chan);
+	}
+
 	spdifrx->dmab = devm_kzalloc(dev, sizeof(struct snd_dma_buffer),
 				     GFP_KERNEL);
 	if (!spdifrx->dmab)
@@ -406,12 +412,6 @@ static int stm32_spdifrx_dma_ctrl_register(struct device *dev,
 		return ret;
 	}
 
-	spdifrx->ctrl_chan = dma_request_chan(dev, "rx-ctrl");
-	if (!spdifrx->ctrl_chan) {
-		dev_err(dev, "dma_request_slave_channel failed\n");
-		return -EINVAL;
-	}
-
 	spdifrx->slave_config.direction = DMA_DEV_TO_MEM;
 	spdifrx->slave_config.src_addr = (dma_addr_t)(spdifrx->phys_addr +
 					 STM32_SPDIFRX_CSR);
@@ -423,7 +423,6 @@ static int stm32_spdifrx_dma_ctrl_register(struct device *dev,
 				     &spdifrx->slave_config);
 	if (ret < 0) {
 		dev_err(dev, "dmaengine_slave_config returned error %d\n", ret);
-		dma_release_channel(spdifrx->ctrl_chan);
 		spdifrx->ctrl_chan = NULL;
 	}
 
@@ -962,7 +961,7 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 	return 0;
 
 error:
-	if (spdifrx->ctrl_chan)
+	if (!IS_ERR(spdifrx->ctrl_chan))
 		dma_release_channel(spdifrx->ctrl_chan);
 	if (spdifrx->dmab)
 		snd_dma_free_pages(spdifrx->dmab);

commit 9036e4acc81700a51e5f42820ba4570bea9b6f48
Author: olivier moysan <olivier.moysan@st.com>
Date:   Mon Nov 6 16:18:52 2017 +0100

    ASoC: stm32: spdifrx: fix 16 bits capture
    
    Change DMA bus width to manage properly 16 bits packed format.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 84cc5678beba..d7dbe84d5eeb 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -750,17 +750,21 @@ static int stm32_spdifrx_hw_params(struct snd_pcm_substream *substream,
 	switch (data_size) {
 	case 16:
 		fmt = SPDIFRX_DRFMT_PACKED;
-		spdifrx->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 		break;
 	case 32:
 		fmt = SPDIFRX_DRFMT_LEFT;
-		spdifrx->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 		break;
 	default:
 		dev_err(&spdifrx->pdev->dev, "Unexpected data format\n");
 		return -EINVAL;
 	}
 
+	/*
+	 * Set buswidth to 4 bytes for all data formats.
+	 * Packed format: transfer 2 x 2 bytes samples
+	 * Left format: transfer 1 x 3 bytes samples + 1 dummy byte
+	 */
+	spdifrx->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	snd_soc_dai_init_dma_data(cpu_dai, NULL, &spdifrx->dma_params);
 
 	return regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,

commit 635eac1e54d82c59f621a0f38a9bffae50f150c7
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Wed Jul 19 17:26:42 2017 +0200

    ASoC: stm32: explicitly request exclusive reset control
    
    Commit a53e35db70d1 ("reset: Ensure drivers are explicit when requesting
    reset lines") started to transition the reset control request API calls
    to explicitly state whether the driver needs exclusive or shared reset
    control behavior. Convert all drivers requesting exclusive resets to the
    explicit API call so the temporary transition helpers can be removed.
    
    No functional changes.
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: alsa-devel@alsa-project.org
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index 4e4250bdb75a..84cc5678beba 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -930,7 +930,7 @@ static int stm32_spdifrx_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	rst = devm_reset_control_get(&pdev->dev, NULL);
+	rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
 	if (!IS_ERR(rst)) {
 		reset_control_assert(rst);
 		udelay(2);

commit 03e4d5d56fa5cbd47d0a8964db3722e7977723a3
Author: olivier moysan <olivier.moysan@st.com>
Date:   Tue Jun 20 11:58:47 2017 +0200

    ASoC: stm32: Add SPDIFRX support
    
    Add SPDIFRX support to STM32.
    
    Signed-off-by: olivier moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
new file mode 100644
index 000000000000..4e4250bdb75a
--- /dev/null
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -0,0 +1,998 @@
+/*
+ * STM32 ALSA SoC Digital Audio Interface (SPDIF-rx) driver.
+ *
+ * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
+ * Author(s): Olivier Moysan <olivier.moysan@st.com> for STMicroelectronics.
+ *
+ * License terms: GPL V2.0.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ */
+
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+
+/* SPDIF-rx Register Map */
+#define STM32_SPDIFRX_CR	0x00
+#define STM32_SPDIFRX_IMR	0x04
+#define STM32_SPDIFRX_SR	0x08
+#define STM32_SPDIFRX_IFCR	0x0C
+#define STM32_SPDIFRX_DR	0x10
+#define STM32_SPDIFRX_CSR	0x14
+#define STM32_SPDIFRX_DIR	0x18
+
+/* Bit definition for SPDIF_CR register */
+#define SPDIFRX_CR_SPDIFEN_SHIFT	0
+#define SPDIFRX_CR_SPDIFEN_MASK	GENMASK(1, SPDIFRX_CR_SPDIFEN_SHIFT)
+#define SPDIFRX_CR_SPDIFENSET(x)	((x) << SPDIFRX_CR_SPDIFEN_SHIFT)
+
+#define SPDIFRX_CR_RXDMAEN	BIT(2)
+#define SPDIFRX_CR_RXSTEO	BIT(3)
+
+#define SPDIFRX_CR_DRFMT_SHIFT	4
+#define SPDIFRX_CR_DRFMT_MASK	GENMASK(5, SPDIFRX_CR_DRFMT_SHIFT)
+#define SPDIFRX_CR_DRFMTSET(x)	((x) << SPDIFRX_CR_DRFMT_SHIFT)
+
+#define SPDIFRX_CR_PMSK		BIT(6)
+#define SPDIFRX_CR_VMSK		BIT(7)
+#define SPDIFRX_CR_CUMSK	BIT(8)
+#define SPDIFRX_CR_PTMSK	BIT(9)
+#define SPDIFRX_CR_CBDMAEN	BIT(10)
+#define SPDIFRX_CR_CHSEL_SHIFT	11
+#define SPDIFRX_CR_CHSEL	BIT(SPDIFRX_CR_CHSEL_SHIFT)
+
+#define SPDIFRX_CR_NBTR_SHIFT	12
+#define SPDIFRX_CR_NBTR_MASK	GENMASK(13, SPDIFRX_CR_NBTR_SHIFT)
+#define SPDIFRX_CR_NBTRSET(x)	((x) << SPDIFRX_CR_NBTR_SHIFT)
+
+#define SPDIFRX_CR_WFA		BIT(14)
+
+#define SPDIFRX_CR_INSEL_SHIFT	16
+#define SPDIFRX_CR_INSEL_MASK	GENMASK(18, PDIFRX_CR_INSEL_SHIFT)
+#define SPDIFRX_CR_INSELSET(x)	((x) << SPDIFRX_CR_INSEL_SHIFT)
+
+#define SPDIFRX_CR_CKSEN_SHIFT	20
+#define SPDIFRX_CR_CKSEN	BIT(20)
+#define SPDIFRX_CR_CKSBKPEN	BIT(21)
+
+/* Bit definition for SPDIFRX_IMR register */
+#define SPDIFRX_IMR_RXNEI	BIT(0)
+#define SPDIFRX_IMR_CSRNEIE	BIT(1)
+#define SPDIFRX_IMR_PERRIE	BIT(2)
+#define SPDIFRX_IMR_OVRIE	BIT(3)
+#define SPDIFRX_IMR_SBLKIE	BIT(4)
+#define SPDIFRX_IMR_SYNCDIE	BIT(5)
+#define SPDIFRX_IMR_IFEIE	BIT(6)
+
+#define SPDIFRX_XIMR_MASK	GENMASK(6, 0)
+
+/* Bit definition for SPDIFRX_SR register */
+#define SPDIFRX_SR_RXNE		BIT(0)
+#define SPDIFRX_SR_CSRNE	BIT(1)
+#define SPDIFRX_SR_PERR		BIT(2)
+#define SPDIFRX_SR_OVR		BIT(3)
+#define SPDIFRX_SR_SBD		BIT(4)
+#define SPDIFRX_SR_SYNCD	BIT(5)
+#define SPDIFRX_SR_FERR		BIT(6)
+#define SPDIFRX_SR_SERR		BIT(7)
+#define SPDIFRX_SR_TERR		BIT(8)
+
+#define SPDIFRX_SR_WIDTH5_SHIFT	16
+#define SPDIFRX_SR_WIDTH5_MASK	GENMASK(30, PDIFRX_SR_WIDTH5_SHIFT)
+#define SPDIFRX_SR_WIDTH5SET(x)	((x) << SPDIFRX_SR_WIDTH5_SHIFT)
+
+/* Bit definition for SPDIFRX_IFCR register */
+#define SPDIFRX_IFCR_PERRCF	BIT(2)
+#define SPDIFRX_IFCR_OVRCF	BIT(3)
+#define SPDIFRX_IFCR_SBDCF	BIT(4)
+#define SPDIFRX_IFCR_SYNCDCF	BIT(5)
+
+#define SPDIFRX_XIFCR_MASK	GENMASK(5, 2)
+
+/* Bit definition for SPDIFRX_DR register (DRFMT = 0b00) */
+#define SPDIFRX_DR0_DR_SHIFT	0
+#define SPDIFRX_DR0_DR_MASK	GENMASK(23, SPDIFRX_DR0_DR_SHIFT)
+#define SPDIFRX_DR0_DRSET(x)	((x) << SPDIFRX_DR0_DR_SHIFT)
+
+#define SPDIFRX_DR0_PE		BIT(24)
+
+#define SPDIFRX_DR0_V		BIT(25)
+#define SPDIFRX_DR0_U		BIT(26)
+#define SPDIFRX_DR0_C		BIT(27)
+
+#define SPDIFRX_DR0_PT_SHIFT	28
+#define SPDIFRX_DR0_PT_MASK	GENMASK(29, SPDIFRX_DR0_PT_SHIFT)
+#define SPDIFRX_DR0_PTSET(x)	((x) << SPDIFRX_DR0_PT_SHIFT)
+
+/* Bit definition for SPDIFRX_DR register (DRFMT = 0b01) */
+#define  SPDIFRX_DR1_PE		BIT(0)
+#define  SPDIFRX_DR1_V		BIT(1)
+#define  SPDIFRX_DR1_U		BIT(2)
+#define  SPDIFRX_DR1_C		BIT(3)
+
+#define  SPDIFRX_DR1_PT_SHIFT	4
+#define  SPDIFRX_DR1_PT_MASK	GENMASK(5, SPDIFRX_DR1_PT_SHIFT)
+#define  SPDIFRX_DR1_PTSET(x)	((x) << SPDIFRX_DR1_PT_SHIFT)
+
+#define SPDIFRX_DR1_DR_SHIFT	8
+#define SPDIFRX_DR1_DR_MASK	GENMASK(31, SPDIFRX_DR1_DR_SHIFT)
+#define SPDIFRX_DR1_DRSET(x)	((x) << SPDIFRX_DR1_DR_SHIFT)
+
+/* Bit definition for SPDIFRX_DR register (DRFMT = 0b10) */
+#define SPDIFRX_DR1_DRNL1_SHIFT	0
+#define SPDIFRX_DR1_DRNL1_MASK	GENMASK(15, SPDIFRX_DR1_DRNL1_SHIFT)
+#define SPDIFRX_DR1_DRNL1SET(x)	((x) << SPDIFRX_DR1_DRNL1_SHIFT)
+
+#define SPDIFRX_DR1_DRNL2_SHIFT	16
+#define SPDIFRX_DR1_DRNL2_MASK	GENMASK(31, SPDIFRX_DR1_DRNL2_SHIFT)
+#define SPDIFRX_DR1_DRNL2SET(x)	((x) << SPDIFRX_DR1_DRNL2_SHIFT)
+
+/* Bit definition for SPDIFRX_CSR register */
+#define SPDIFRX_CSR_USR_SHIFT	0
+#define SPDIFRX_CSR_USR_MASK	GENMASK(15, SPDIFRX_CSR_USR_SHIFT)
+#define SPDIFRX_CSR_USRGET(x)	(((x) & SPDIFRX_CSR_USR_MASK)\
+				>> SPDIFRX_CSR_USR_SHIFT)
+
+#define SPDIFRX_CSR_CS_SHIFT	16
+#define SPDIFRX_CSR_CS_MASK	GENMASK(23, SPDIFRX_CSR_CS_SHIFT)
+#define SPDIFRX_CSR_CSGET(x)	(((x) & SPDIFRX_CSR_CS_MASK)\
+				>> SPDIFRX_CSR_CS_SHIFT)
+
+#define SPDIFRX_CSR_SOB		BIT(24)
+
+/* Bit definition for SPDIFRX_DIR register */
+#define SPDIFRX_DIR_THI_SHIFT	0
+#define SPDIFRX_DIR_THI_MASK	GENMASK(12, SPDIFRX_DIR_THI_SHIFT)
+#define SPDIFRX_DIR_THI_SET(x)	((x) << SPDIFRX_DIR_THI_SHIFT)
+
+#define SPDIFRX_DIR_TLO_SHIFT	16
+#define SPDIFRX_DIR_TLO_MASK	GENMASK(28, SPDIFRX_DIR_TLO_SHIFT)
+#define SPDIFRX_DIR_TLO_SET(x)	((x) << SPDIFRX_DIR_TLO_SHIFT)
+
+#define SPDIFRX_SPDIFEN_DISABLE	0x0
+#define SPDIFRX_SPDIFEN_SYNC	0x1
+#define SPDIFRX_SPDIFEN_ENABLE	0x3
+
+#define SPDIFRX_IN1		0x1
+#define SPDIFRX_IN2		0x2
+#define SPDIFRX_IN3		0x3
+#define SPDIFRX_IN4		0x4
+#define SPDIFRX_IN5		0x5
+#define SPDIFRX_IN6		0x6
+#define SPDIFRX_IN7		0x7
+#define SPDIFRX_IN8		0x8
+
+#define SPDIFRX_NBTR_NONE	0x0
+#define SPDIFRX_NBTR_3		0x1
+#define SPDIFRX_NBTR_15		0x2
+#define SPDIFRX_NBTR_63		0x3
+
+#define SPDIFRX_DRFMT_RIGHT	0x0
+#define SPDIFRX_DRFMT_LEFT	0x1
+#define SPDIFRX_DRFMT_PACKED	0x2
+
+/* 192 CS bits in S/PDIF frame. i.e 24 CS bytes */
+#define SPDIFRX_CS_BYTES_NB	24
+#define SPDIFRX_UB_BYTES_NB	48
+
+/*
+ * CSR register is retrieved as a 32 bits word
+ * It contains 1 channel status byte and 2 user data bytes
+ * 2 S/PDIF frames are acquired to get all CS/UB bits
+ */
+#define SPDIFRX_CSR_BUF_LENGTH	(SPDIFRX_CS_BYTES_NB * 4 * 2)
+
+/**
+ * struct stm32_spdifrx_data - private data of SPDIFRX
+ * @pdev: device data pointer
+ * @base: mmio register base virtual address
+ * @regmap: SPDIFRX register map pointer
+ * @regmap_conf: SPDIFRX register map configuration pointer
+ * @cs_completion: channel status retrieving completion
+ * @kclk: kernel clock feeding the SPDIFRX clock generator
+ * @dma_params: dma configuration data for rx channel
+ * @substream: PCM substream data pointer
+ * @dmab: dma buffer info pointer
+ * @ctrl_chan: dma channel for S/PDIF control bits
+ * @desc:dma async transaction descriptor
+ * @slave_config: dma slave channel runtime config pointer
+ * @phys_addr: SPDIFRX registers physical base address
+ * @lock: synchronization enabling lock
+ * @cs: channel status buffer
+ * @ub: user data buffer
+ * @irq: SPDIFRX interrupt line
+ * @refcount: keep count of opened DMA channels
+ */
+struct stm32_spdifrx_data {
+	struct platform_device *pdev;
+	void __iomem *base;
+	struct regmap *regmap;
+	const struct regmap_config *regmap_conf;
+	struct completion cs_completion;
+	struct clk *kclk;
+	struct snd_dmaengine_dai_dma_data dma_params;
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *dmab;
+	struct dma_chan *ctrl_chan;
+	struct dma_async_tx_descriptor *desc;
+	struct dma_slave_config slave_config;
+	dma_addr_t phys_addr;
+	spinlock_t lock;  /* Sync enabling lock */
+	unsigned char cs[SPDIFRX_CS_BYTES_NB];
+	unsigned char ub[SPDIFRX_UB_BYTES_NB];
+	int irq;
+	int refcount;
+};
+
+static void stm32_spdifrx_dma_complete(void *data)
+{
+	struct stm32_spdifrx_data *spdifrx = (struct stm32_spdifrx_data *)data;
+	struct platform_device *pdev = spdifrx->pdev;
+	u32 *p_start = (u32 *)spdifrx->dmab->area;
+	u32 *p_end = p_start + (2 * SPDIFRX_CS_BYTES_NB) - 1;
+	u32 *ptr = p_start;
+	u16 *ub_ptr = (short *)spdifrx->ub;
+	int i = 0;
+
+	regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
+			   SPDIFRX_CR_CBDMAEN,
+			   (unsigned int)~SPDIFRX_CR_CBDMAEN);
+
+	if (!spdifrx->dmab->area)
+		return;
+
+	while (ptr <= p_end) {
+		if (*ptr & SPDIFRX_CSR_SOB)
+			break;
+		ptr++;
+	}
+
+	if (ptr > p_end) {
+		dev_err(&pdev->dev, "Start of S/PDIF block not found\n");
+		return;
+	}
+
+	while (i < SPDIFRX_CS_BYTES_NB) {
+		spdifrx->cs[i] = (unsigned char)SPDIFRX_CSR_CSGET(*ptr);
+		*ub_ptr++ = SPDIFRX_CSR_USRGET(*ptr++);
+		if (ptr > p_end) {
+			dev_err(&pdev->dev, "Failed to get channel status\n");
+			return;
+		}
+		i++;
+	}
+
+	complete(&spdifrx->cs_completion);
+}
+
+static int stm32_spdifrx_dma_ctrl_start(struct stm32_spdifrx_data *spdifrx)
+{
+	dma_cookie_t cookie;
+	int err;
+
+	spdifrx->desc = dmaengine_prep_slave_single(spdifrx->ctrl_chan,
+						    spdifrx->dmab->addr,
+						    SPDIFRX_CSR_BUF_LENGTH,
+						    DMA_DEV_TO_MEM,
+						    DMA_CTRL_ACK);
+	if (!spdifrx->desc)
+		return -EINVAL;
+
+	spdifrx->desc->callback = stm32_spdifrx_dma_complete;
+	spdifrx->desc->callback_param = spdifrx;
+	cookie = dmaengine_submit(spdifrx->desc);
+	err = dma_submit_error(cookie);
+	if (err)
+		return -EINVAL;
+
+	dma_async_issue_pending(spdifrx->ctrl_chan);
+
+	return 0;
+}
+
+static void stm32_spdifrx_dma_ctrl_stop(struct stm32_spdifrx_data *spdifrx)
+{
+	dmaengine_terminate_async(spdifrx->ctrl_chan);
+}
+
+static int stm32_spdifrx_start_sync(struct stm32_spdifrx_data *spdifrx)
+{
+	int cr, cr_mask, imr, ret;
+
+	/* Enable IRQs */
+	imr = SPDIFRX_IMR_IFEIE | SPDIFRX_IMR_SYNCDIE | SPDIFRX_IMR_PERRIE;
+	ret = regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IMR, imr, imr);
+	if (ret)
+		return ret;
+
+	spin_lock(&spdifrx->lock);
+
+	spdifrx->refcount++;
+
+	regmap_read(spdifrx->regmap, STM32_SPDIFRX_CR, &cr);
+
+	if (!(cr & SPDIFRX_CR_SPDIFEN_MASK)) {
+		/*
+		 * Start sync if SPDIFRX is still in idle state.
+		 * SPDIFRX reception enabled when sync done
+		 */
+		dev_dbg(&spdifrx->pdev->dev, "start synchronization\n");
+
+		/*
+		 * SPDIFRX configuration:
+		 * Wait for activity before starting sync process. This avoid
+		 * to issue sync errors when spdif signal is missing on input.
+		 * Preamble, CS, user, validity and parity error bits not copied
+		 * to DR register.
+		 */
+		cr = SPDIFRX_CR_WFA | SPDIFRX_CR_PMSK | SPDIFRX_CR_VMSK |
+		     SPDIFRX_CR_CUMSK | SPDIFRX_CR_PTMSK | SPDIFRX_CR_RXSTEO;
+		cr_mask = cr;
+
+		cr |= SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_SYNC);
+		cr_mask |= SPDIFRX_CR_SPDIFEN_MASK;
+		ret = regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
+					 cr_mask, cr);
+		if (ret < 0)
+			dev_err(&spdifrx->pdev->dev,
+				"Failed to start synchronization\n");
+	}
+
+	spin_unlock(&spdifrx->lock);
+
+	return ret;
+}
+
+static void stm32_spdifrx_stop(struct stm32_spdifrx_data *spdifrx)
+{
+	int cr, cr_mask, reg;
+
+	spin_lock(&spdifrx->lock);
+
+	if (--spdifrx->refcount) {
+		spin_unlock(&spdifrx->lock);
+		return;
+	}
+
+	cr = SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_DISABLE);
+	cr_mask = SPDIFRX_CR_SPDIFEN_MASK | SPDIFRX_CR_RXDMAEN;
+
+	regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR, cr_mask, cr);
+
+	regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IMR,
+			   SPDIFRX_XIMR_MASK, 0);
+
+	regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IFCR,
+			   SPDIFRX_XIFCR_MASK, SPDIFRX_XIFCR_MASK);
+
+	/* dummy read to clear CSRNE and RXNE in status register */
+	regmap_read(spdifrx->regmap, STM32_SPDIFRX_DR, &reg);
+	regmap_read(spdifrx->regmap, STM32_SPDIFRX_CSR, &reg);
+
+	spin_unlock(&spdifrx->lock);
+}
+
+static int stm32_spdifrx_dma_ctrl_register(struct device *dev,
+					   struct stm32_spdifrx_data *spdifrx)
+{
+	int ret;
+
+	spdifrx->dmab = devm_kzalloc(dev, sizeof(struct snd_dma_buffer),
+				     GFP_KERNEL);
+	if (!spdifrx->dmab)
+		return -ENOMEM;
+
+	spdifrx->dmab->dev.type = SNDRV_DMA_TYPE_DEV_IRAM;
+	spdifrx->dmab->dev.dev = dev;
+	ret = snd_dma_alloc_pages(spdifrx->dmab->dev.type, dev,
+				  SPDIFRX_CSR_BUF_LENGTH, spdifrx->dmab);
+	if (ret < 0) {
+		dev_err(dev, "snd_dma_alloc_pages returned error %d\n", ret);
+		return ret;
+	}
+
+	spdifrx->ctrl_chan = dma_request_chan(dev, "rx-ctrl");
+	if (!spdifrx->ctrl_chan) {
+		dev_err(dev, "dma_request_slave_channel failed\n");
+		return -EINVAL;
+	}
+
+	spdifrx->slave_config.direction = DMA_DEV_TO_MEM;
+	spdifrx->slave_config.src_addr = (dma_addr_t)(spdifrx->phys_addr +
+					 STM32_SPDIFRX_CSR);
+	spdifrx->slave_config.dst_addr = spdifrx->dmab->addr;
+	spdifrx->slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	spdifrx->slave_config.src_maxburst = 1;
+
+	ret = dmaengine_slave_config(spdifrx->ctrl_chan,
+				     &spdifrx->slave_config);
+	if (ret < 0) {
+		dev_err(dev, "dmaengine_slave_config returned error %d\n", ret);
+		dma_release_channel(spdifrx->ctrl_chan);
+		spdifrx->ctrl_chan = NULL;
+	}
+
+	return ret;
+};
+
+static const char * const spdifrx_enum_input[] = {
+	"in0", "in1", "in2", "in3"
+};
+
+/*  By default CS bits are retrieved from channel A */
+static const char * const spdifrx_enum_cs_channel[] = {
+	"A", "B"
+};
+
+static SOC_ENUM_SINGLE_DECL(ctrl_enum_input,
+			    STM32_SPDIFRX_CR, SPDIFRX_CR_INSEL_SHIFT,
+			    spdifrx_enum_input);
+
+static SOC_ENUM_SINGLE_DECL(ctrl_enum_cs_channel,
+			    STM32_SPDIFRX_CR, SPDIFRX_CR_CHSEL_SHIFT,
+			    spdifrx_enum_cs_channel);
+
+static int stm32_spdifrx_info(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+static int stm32_spdifrx_ub_info(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+static int stm32_spdifrx_get_ctrl_data(struct stm32_spdifrx_data *spdifrx)
+{
+	int ret = 0;
+
+	memset(spdifrx->cs, 0, SPDIFRX_CS_BYTES_NB);
+	memset(spdifrx->ub, 0, SPDIFRX_UB_BYTES_NB);
+
+	ret = stm32_spdifrx_dma_ctrl_start(spdifrx);
+	if (ret < 0)
+		return ret;
+
+	ret = clk_prepare_enable(spdifrx->kclk);
+	if (ret) {
+		dev_err(&spdifrx->pdev->dev, "Enable kclk failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
+				 SPDIFRX_CR_CBDMAEN, SPDIFRX_CR_CBDMAEN);
+	if (ret < 0)
+		goto end;
+
+	ret = stm32_spdifrx_start_sync(spdifrx);
+	if (ret < 0)
+		goto end;
+
+	if (wait_for_completion_interruptible_timeout(&spdifrx->cs_completion,
+						      msecs_to_jiffies(100))
+						      <= 0) {
+		dev_err(&spdifrx->pdev->dev, "Failed to get control data\n");
+		ret = -EAGAIN;
+	}
+
+	stm32_spdifrx_stop(spdifrx);
+	stm32_spdifrx_dma_ctrl_stop(spdifrx);
+
+end:
+	clk_disable_unprepare(spdifrx->kclk);
+
+	return ret;
+}
+
+static int stm32_spdifrx_capture_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);
+
+	stm32_spdifrx_get_ctrl_data(spdifrx);
+
+	ucontrol->value.iec958.status[0] = spdifrx->cs[0];
+	ucontrol->value.iec958.status[1] = spdifrx->cs[1];
+	ucontrol->value.iec958.status[2] = spdifrx->cs[2];
+	ucontrol->value.iec958.status[3] = spdifrx->cs[3];
+	ucontrol->value.iec958.status[4] = spdifrx->cs[4];
+
+	return 0;
+}
+
+static int stm32_spdif_user_bits_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);
+
+	stm32_spdifrx_get_ctrl_data(spdifrx);
+
+	ucontrol->value.iec958.status[0] = spdifrx->ub[0];
+	ucontrol->value.iec958.status[1] = spdifrx->ub[1];
+	ucontrol->value.iec958.status[2] = spdifrx->ub[2];
+	ucontrol->value.iec958.status[3] = spdifrx->ub[3];
+	ucontrol->value.iec958.status[4] = spdifrx->ub[4];
+
+	return 0;
+}
+
+static struct snd_kcontrol_new stm32_spdifrx_iec_ctrls[] = {
+	/* Channel status control */
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", CAPTURE, DEFAULT),
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.info = stm32_spdifrx_info,
+		.get = stm32_spdifrx_capture_get,
+	},
+	/* User bits control */
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = "IEC958 User Bit Capture Default",
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			  SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.info = stm32_spdifrx_ub_info,
+		.get = stm32_spdif_user_bits_get,
+	},
+};
+
+static struct snd_kcontrol_new stm32_spdifrx_ctrls[] = {
+	SOC_ENUM("SPDIFRX input", ctrl_enum_input),
+	SOC_ENUM("SPDIFRX CS channel", ctrl_enum_cs_channel),
+};
+
+static int stm32_spdifrx_dai_register_ctrls(struct snd_soc_dai *cpu_dai)
+{
+	int ret;
+
+	ret = snd_soc_add_dai_controls(cpu_dai, stm32_spdifrx_iec_ctrls,
+				       ARRAY_SIZE(stm32_spdifrx_iec_ctrls));
+	if (ret < 0)
+		return ret;
+
+	return snd_soc_add_component_controls(cpu_dai->component,
+					      stm32_spdifrx_ctrls,
+					      ARRAY_SIZE(stm32_spdifrx_ctrls));
+}
+
+static int stm32_spdifrx_dai_probe(struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_spdifrx_data *spdifrx = dev_get_drvdata(cpu_dai->dev);
+
+	spdifrx->dma_params.addr = (dma_addr_t)(spdifrx->phys_addr +
+				   STM32_SPDIFRX_DR);
+	spdifrx->dma_params.maxburst = 1;
+
+	snd_soc_dai_init_dma_data(cpu_dai, NULL, &spdifrx->dma_params);
+
+	return stm32_spdifrx_dai_register_ctrls(cpu_dai);
+}
+
+static bool stm32_spdifrx_readable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case STM32_SPDIFRX_CR:
+	case STM32_SPDIFRX_IMR:
+	case STM32_SPDIFRX_SR:
+	case STM32_SPDIFRX_IFCR:
+	case STM32_SPDIFRX_DR:
+	case STM32_SPDIFRX_CSR:
+	case STM32_SPDIFRX_DIR:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_spdifrx_volatile_reg(struct device *dev, unsigned int reg)
+{
+	if (reg == STM32_SPDIFRX_DR)
+		return true;
+
+	return false;
+}
+
+static bool stm32_spdifrx_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case STM32_SPDIFRX_CR:
+	case STM32_SPDIFRX_IMR:
+	case STM32_SPDIFRX_IFCR:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config stm32_h7_spdifrx_regmap_conf = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = STM32_SPDIFRX_DIR,
+	.readable_reg = stm32_spdifrx_readable_reg,
+	.volatile_reg = stm32_spdifrx_volatile_reg,
+	.writeable_reg = stm32_spdifrx_writeable_reg,
+	.fast_io = true,
+};
+
+static irqreturn_t stm32_spdifrx_isr(int irq, void *devid)
+{
+	struct stm32_spdifrx_data *spdifrx = (struct stm32_spdifrx_data *)devid;
+	struct snd_pcm_substream *substream = spdifrx->substream;
+	struct platform_device *pdev = spdifrx->pdev;
+	unsigned int cr, mask, sr, imr;
+	unsigned int flags;
+	int err = 0, err_xrun = 0;
+
+	regmap_read(spdifrx->regmap, STM32_SPDIFRX_SR, &sr);
+	regmap_read(spdifrx->regmap, STM32_SPDIFRX_IMR, &imr);
+
+	mask = imr & SPDIFRX_XIMR_MASK;
+	/* SERR, TERR, FERR IRQs are generated if IFEIE is set */
+	if (mask & SPDIFRX_IMR_IFEIE)
+		mask |= (SPDIFRX_IMR_IFEIE << 1) | (SPDIFRX_IMR_IFEIE << 2);
+
+	flags = sr & mask;
+	if (!flags) {
+		dev_err(&pdev->dev, "Unexpected IRQ. rflags=%#x, imr=%#x\n",
+			sr, imr);
+		return IRQ_NONE;
+	}
+
+	/* Clear IRQs */
+	regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IFCR,
+			   SPDIFRX_XIFCR_MASK, flags);
+
+	if (flags & SPDIFRX_SR_PERR) {
+		dev_dbg(&pdev->dev, "Parity error\n");
+		err_xrun = 1;
+	}
+
+	if (flags & SPDIFRX_SR_OVR) {
+		dev_dbg(&pdev->dev, "Overrun error\n");
+		err_xrun = 1;
+	}
+
+	if (flags & SPDIFRX_SR_SBD)
+		dev_dbg(&pdev->dev, "Synchronization block detected\n");
+
+	if (flags & SPDIFRX_SR_SYNCD) {
+		dev_dbg(&pdev->dev, "Synchronization done\n");
+
+		/* Enable spdifrx */
+		cr = SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_ENABLE);
+		regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
+				   SPDIFRX_CR_SPDIFEN_MASK, cr);
+	}
+
+	if (flags & SPDIFRX_SR_FERR) {
+		dev_dbg(&pdev->dev, "Frame error\n");
+		err = 1;
+	}
+
+	if (flags & SPDIFRX_SR_SERR) {
+		dev_dbg(&pdev->dev, "Synchronization error\n");
+		err = 1;
+	}
+
+	if (flags & SPDIFRX_SR_TERR) {
+		dev_dbg(&pdev->dev, "Timeout error\n");
+		err = 1;
+	}
+
+	if (err) {
+		/* SPDIFRX in STATE_STOP. Disable SPDIFRX to clear errors */
+		cr = SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_DISABLE);
+		regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
+				   SPDIFRX_CR_SPDIFEN_MASK, cr);
+
+		if (substream)
+			snd_pcm_stop(substream, SNDRV_PCM_STATE_DISCONNECTED);
+
+		return IRQ_HANDLED;
+	}
+
+	if (err_xrun && substream)
+		snd_pcm_stop_xrun(substream);
+
+	return IRQ_HANDLED;
+}
+
+static int stm32_spdifrx_startup(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
+
+	spdifrx->substream = substream;
+
+	ret = clk_prepare_enable(spdifrx->kclk);
+	if (ret)
+		dev_err(&spdifrx->pdev->dev, "Enable kclk failed: %d\n", ret);
+
+	return ret;
+}
+
+static int stm32_spdifrx_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params,
+				   struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);
+	int data_size = params_width(params);
+	int fmt;
+
+	switch (data_size) {
+	case 16:
+		fmt = SPDIFRX_DRFMT_PACKED;
+		spdifrx->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case 32:
+		fmt = SPDIFRX_DRFMT_LEFT;
+		spdifrx->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	default:
+		dev_err(&spdifrx->pdev->dev, "Unexpected data format\n");
+		return -EINVAL;
+	}
+
+	snd_soc_dai_init_dma_data(cpu_dai, NULL, &spdifrx->dma_params);
+
+	return regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
+				  SPDIFRX_CR_DRFMT_MASK,
+				  SPDIFRX_CR_DRFMTSET(fmt));
+}
+
+static int stm32_spdifrx_trigger(struct snd_pcm_substream *substream, int cmd,
+				 struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IMR,
+				   SPDIFRX_IMR_OVRIE, SPDIFRX_IMR_OVRIE);
+
+		regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,
+				   SPDIFRX_CR_RXDMAEN, SPDIFRX_CR_RXDMAEN);
+
+		ret = stm32_spdifrx_start_sync(spdifrx);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_STOP:
+		stm32_spdifrx_stop(spdifrx);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static void stm32_spdifrx_shutdown(struct snd_pcm_substream *substream,
+				   struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);
+
+	spdifrx->substream = NULL;
+	clk_disable_unprepare(spdifrx->kclk);
+}
+
+static const struct snd_soc_dai_ops stm32_spdifrx_pcm_dai_ops = {
+	.startup	= stm32_spdifrx_startup,
+	.hw_params	= stm32_spdifrx_hw_params,
+	.trigger	= stm32_spdifrx_trigger,
+	.shutdown	= stm32_spdifrx_shutdown,
+};
+
+static struct snd_soc_dai_driver stm32_spdifrx_dai[] = {
+	{
+		.name = "spdifrx-capture-cpu-dai",
+		.probe = stm32_spdifrx_dai_probe,
+		.capture = {
+			.stream_name = "CPU-Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = SNDRV_PCM_FMTBIT_S32_LE |
+				   SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.ops = &stm32_spdifrx_pcm_dai_ops,
+	}
+};
+
+static const struct snd_pcm_hardware stm32_spdifrx_pcm_hw = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_MMAP,
+	.buffer_bytes_max = 8 * PAGE_SIZE,
+	.period_bytes_max = 2048, /* MDMA constraint */
+	.periods_min = 2,
+	.periods_max = 8,
+};
+
+static const struct snd_soc_component_driver stm32_spdifrx_component = {
+	.name = "stm32-spdifrx",
+};
+
+static const struct snd_dmaengine_pcm_config stm32_spdifrx_pcm_config = {
+	.pcm_hardware = &stm32_spdifrx_pcm_hw,
+	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+};
+
+static const struct of_device_id stm32_spdifrx_ids[] = {
+	{
+		.compatible = "st,stm32h7-spdifrx",
+		.data = &stm32_h7_spdifrx_regmap_conf
+	},
+	{}
+};
+
+static int stm_spdifrx_parse_of(struct platform_device *pdev,
+				struct stm32_spdifrx_data *spdifrx)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct resource *res;
+
+	if (!np)
+		return -ENODEV;
+
+	of_id = of_match_device(stm32_spdifrx_ids, &pdev->dev);
+	if (of_id)
+		spdifrx->regmap_conf =
+			(const struct regmap_config *)of_id->data;
+	else
+		return -EINVAL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	spdifrx->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(spdifrx->base))
+		return PTR_ERR(spdifrx->base);
+
+	spdifrx->phys_addr = res->start;
+
+	spdifrx->kclk = devm_clk_get(&pdev->dev, "kclk");
+	if (IS_ERR(spdifrx->kclk)) {
+		dev_err(&pdev->dev, "Could not get kclk\n");
+		return PTR_ERR(spdifrx->kclk);
+	}
+
+	spdifrx->irq = platform_get_irq(pdev, 0);
+	if (spdifrx->irq < 0) {
+		dev_err(&pdev->dev, "No irq for node %s\n", pdev->name);
+		return spdifrx->irq;
+	}
+
+	return 0;
+}
+
+static int stm32_spdifrx_probe(struct platform_device *pdev)
+{
+	struct stm32_spdifrx_data *spdifrx;
+	struct reset_control *rst;
+	const struct snd_dmaengine_pcm_config *pcm_config = NULL;
+	int ret;
+
+	spdifrx = devm_kzalloc(&pdev->dev, sizeof(*spdifrx), GFP_KERNEL);
+	if (!spdifrx)
+		return -ENOMEM;
+
+	spdifrx->pdev = pdev;
+	init_completion(&spdifrx->cs_completion);
+	spin_lock_init(&spdifrx->lock);
+
+	platform_set_drvdata(pdev, spdifrx);
+
+	ret = stm_spdifrx_parse_of(pdev, spdifrx);
+	if (ret)
+		return ret;
+
+	spdifrx->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "kclk",
+						    spdifrx->base,
+						    spdifrx->regmap_conf);
+	if (IS_ERR(spdifrx->regmap)) {
+		dev_err(&pdev->dev, "Regmap init failed\n");
+		return PTR_ERR(spdifrx->regmap);
+	}
+
+	ret = devm_request_irq(&pdev->dev, spdifrx->irq, stm32_spdifrx_isr, 0,
+			       dev_name(&pdev->dev), spdifrx);
+	if (ret) {
+		dev_err(&pdev->dev, "IRQ request returned %d\n", ret);
+		return ret;
+	}
+
+	rst = devm_reset_control_get(&pdev->dev, NULL);
+	if (!IS_ERR(rst)) {
+		reset_control_assert(rst);
+		udelay(2);
+		reset_control_deassert(rst);
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &stm32_spdifrx_component,
+					      stm32_spdifrx_dai,
+					      ARRAY_SIZE(stm32_spdifrx_dai));
+	if (ret)
+		return ret;
+
+	ret = stm32_spdifrx_dma_ctrl_register(&pdev->dev, spdifrx);
+	if (ret)
+		goto error;
+
+	pcm_config = &stm32_spdifrx_pcm_config;
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, pcm_config, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "PCM DMA register returned %d\n", ret);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	if (spdifrx->ctrl_chan)
+		dma_release_channel(spdifrx->ctrl_chan);
+	if (spdifrx->dmab)
+		snd_dma_free_pages(spdifrx->dmab);
+
+	return ret;
+}
+
+static int stm32_spdifrx_remove(struct platform_device *pdev)
+{
+	struct stm32_spdifrx_data *spdifrx = platform_get_drvdata(pdev);
+
+	if (spdifrx->ctrl_chan)
+		dma_release_channel(spdifrx->ctrl_chan);
+
+	if (spdifrx->dmab)
+		snd_dma_free_pages(spdifrx->dmab);
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(of, stm32_spdifrx_ids);
+
+static struct platform_driver stm32_spdifrx_driver = {
+	.driver = {
+		.name = "st,stm32-spdifrx",
+		.of_match_table = stm32_spdifrx_ids,
+	},
+	.probe = stm32_spdifrx_probe,
+	.remove = stm32_spdifrx_remove,
+};
+
+module_platform_driver(stm32_spdifrx_driver);
+
+MODULE_DESCRIPTION("STM32 Soc spdifrx Interface");
+MODULE_AUTHOR("Olivier Moysan, <olivier.moysan@st.com>");
+MODULE_ALIAS("platform:stm32-spdifrx");
+MODULE_LICENSE("GPL v2");
