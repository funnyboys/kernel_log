commit caff4ce8cc582a97b17d10b7c7f5fe8500323135
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Wed Mar 18 15:41:25 2020 +0100

    ASoC: stm32: i2s: manage rebind issue
    
    The commit e894efef9ac7 ("ASoC: core: add support to card rebind")
    allows to rebind the sound card after a rebind of one of its component.
    With this commit, the sound card is actually rebound,
    but may be no more functional.
    
    Corrections:
    - Call snd_dmaengine_pcm_register() before snd_soc_register_component().
    - Call snd_dmaengine_pcm_unregister() and snd_soc_unregister_component()
    explicitly from I2S driver.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20200318144125.9163-4-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 2478405727c3..7c4d63c33f15 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -888,6 +888,14 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 	return 0;
 }
 
+static int stm32_i2s_remove(struct platform_device *pdev)
+{
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
+
+	return 0;
+}
+
 static int stm32_i2s_probe(struct platform_device *pdev)
 {
 	struct stm32_i2s_data *i2s;
@@ -921,47 +929,56 @@ static int stm32_i2s_probe(struct platform_device *pdev)
 		return PTR_ERR(i2s->regmap);
 	}
 
-	ret = devm_snd_soc_register_component(&pdev->dev, &stm32_i2s_component,
-					      i2s->dai_drv, 1);
-	if (ret)
-		return ret;
-
-	ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
-					      &stm32_i2s_pcm_config, 0);
+	ret = snd_dmaengine_pcm_register(&pdev->dev, &stm32_i2s_pcm_config, 0);
 	if (ret) {
 		if (ret != -EPROBE_DEFER)
 			dev_err(&pdev->dev, "PCM DMA register error %d\n", ret);
 		return ret;
 	}
 
+	ret = snd_soc_register_component(&pdev->dev, &stm32_i2s_component,
+					 i2s->dai_drv, 1);
+	if (ret) {
+		snd_dmaengine_pcm_unregister(&pdev->dev);
+		return ret;
+	}
+
 	/* Set SPI/I2S in i2s mode */
 	ret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
 				 I2S_CGFR_I2SMOD, I2S_CGFR_I2SMOD);
 	if (ret)
-		return ret;
+		goto error;
 
 	ret = regmap_read(i2s->regmap, STM32_I2S_IPIDR_REG, &val);
 	if (ret)
-		return ret;
+		goto error;
 
 	if (val == I2S_IPIDR_NUMBER) {
 		ret = regmap_read(i2s->regmap, STM32_I2S_HWCFGR_REG, &val);
 		if (ret)
-			return ret;
+			goto error;
 
 		if (!FIELD_GET(I2S_HWCFGR_I2S_SUPPORT_MASK, val)) {
 			dev_err(&pdev->dev,
 				"Device does not support i2s mode\n");
-			return -EPERM;
+			ret = -EPERM;
+			goto error;
 		}
 
 		ret = regmap_read(i2s->regmap, STM32_I2S_VERR_REG, &val);
+		if (ret)
+			goto error;
 
 		dev_dbg(&pdev->dev, "I2S version: %lu.%lu registered\n",
 			FIELD_GET(I2S_VERR_MAJ_MASK, val),
 			FIELD_GET(I2S_VERR_MIN_MASK, val));
 	}
 
+	return ret;
+
+error:
+	stm32_i2s_remove(pdev);
+
 	return ret;
 }
 
@@ -998,6 +1015,7 @@ static struct platform_driver stm32_i2s_driver = {
 		.pm = &stm32_i2s_pm_ops,
 	},
 	.probe = stm32_i2s_probe,
+	.remove = stm32_i2s_remove,
 };
 
 module_platform_driver(stm32_i2s_driver);

commit 04dd656e8d506c12f5e97a24089b2991f5f00984
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon Feb 3 11:08:14 2020 +0100

    ASoC: stm32: i2s: improve error management on probe deferral
    
    Do not print an error trace when deferring probe for I2S driver.
    
    Signed-off-by: Etienne Carriere <etienne.carriere@st.com>
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20200203100814.22944-7-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index cdcc00d9a67e..2478405727c3 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -831,25 +831,33 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 	/* Get clocks */
 	i2s->pclk = devm_clk_get(&pdev->dev, "pclk");
 	if (IS_ERR(i2s->pclk)) {
-		dev_err(&pdev->dev, "Could not get pclk\n");
+		if (PTR_ERR(i2s->pclk) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Could not get pclk: %ld\n",
+				PTR_ERR(i2s->pclk));
 		return PTR_ERR(i2s->pclk);
 	}
 
 	i2s->i2sclk = devm_clk_get(&pdev->dev, "i2sclk");
 	if (IS_ERR(i2s->i2sclk)) {
-		dev_err(&pdev->dev, "Could not get i2sclk\n");
+		if (PTR_ERR(i2s->i2sclk) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Could not get i2sclk: %ld\n",
+				PTR_ERR(i2s->i2sclk));
 		return PTR_ERR(i2s->i2sclk);
 	}
 
 	i2s->x8kclk = devm_clk_get(&pdev->dev, "x8k");
 	if (IS_ERR(i2s->x8kclk)) {
-		dev_err(&pdev->dev, "missing x8k parent clock\n");
+		if (PTR_ERR(i2s->x8kclk) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Could not get x8k parent clock: %ld\n",
+				PTR_ERR(i2s->x8kclk));
 		return PTR_ERR(i2s->x8kclk);
 	}
 
 	i2s->x11kclk = devm_clk_get(&pdev->dev, "x11k");
 	if (IS_ERR(i2s->x11kclk)) {
-		dev_err(&pdev->dev, "missing x11k parent clock\n");
+		if (PTR_ERR(i2s->x11kclk) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Could not get x11k parent clock: %ld\n",
+				PTR_ERR(i2s->x11kclk));
 		return PTR_ERR(i2s->x11kclk);
 	}
 
@@ -907,7 +915,9 @@ static int stm32_i2s_probe(struct platform_device *pdev)
 	i2s->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "pclk",
 						i2s->base, i2s->regmap_conf);
 	if (IS_ERR(i2s->regmap)) {
-		dev_err(&pdev->dev, "regmap init failed\n");
+		if (PTR_ERR(i2s->regmap) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Regmap init error %ld\n",
+				PTR_ERR(i2s->regmap));
 		return PTR_ERR(i2s->regmap);
 	}
 
@@ -918,8 +928,11 @@ static int stm32_i2s_probe(struct platform_device *pdev)
 
 	ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
 					      &stm32_i2s_pcm_config, 0);
-	if (ret)
+	if (ret) {
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "PCM DMA register error %d\n", ret);
 		return ret;
+	}
 
 	/* Set SPI/I2S in i2s mode */
 	ret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,

commit 158ecc65c05314cd02fcf67fa54ebef537358e5c
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon Feb 3 11:08:11 2020 +0100

    ASoC: stm32: i2s: manage error when getting reset controller
    
    Return an error when the i2s driver fails to get a reset controller.
    Also add an error trace, except on probe defer status.
    
    Signed-off-by: Etienne Carriere <etienne.carriere@st.com>
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Link: https://lore.kernel.org/r/20200203100814.22944-4-olivier.moysan@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 3e7226a53e53..cdcc00d9a67e 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -866,12 +866,16 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 	}
 
 	/* Reset */
-	rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
-	if (!IS_ERR(rst)) {
-		reset_control_assert(rst);
-		udelay(2);
-		reset_control_deassert(rst);
+	rst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(rst)) {
+		if (PTR_ERR(rst) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Reset controller error %ld\n",
+				PTR_ERR(rst));
+		return PTR_ERR(rst);
 	}
+	reset_control_assert(rst);
+	udelay(2);
+	reset_control_deassert(rst);
 
 	return 0;
 }

commit cf9441adb1a35506d7606866c382b9d8614169b5
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jul 30 11:15:49 2019 -0700

    ASoC: Remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Cc: alsa-devel@alsa-project.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20190730181557.90391-50-swboyd@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index ba6452dab69b..3e7226a53e53 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -855,11 +855,8 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 
 	/* Get irqs */
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		if (irq != -EPROBE_DEFER)
-			dev_err(&pdev->dev, "no irq for node %s\n", pdev->name);
+	if (irq < 0)
 		return irq;
-	}
 
 	ret = devm_request_irq(&pdev->dev, irq, stm32_i2s_isr, IRQF_ONESHOT,
 			       dev_name(&pdev->dev), i2s);

commit 53c8b29abe42e5601cfa0ea5962532f0cfdec8a0
Merge: e3303268f9cf 4b972a01a7da
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Jun 26 12:39:34 2019 +0100

    Merge tag 'v5.2-rc6' into asoc-5.3
    
    Linux 5.2-rc6

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 8ee697ff1f86..01ed5e4c1cc0 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -1,19 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  STM32 ALSA SoC Digital Audio Interface (I2S) driver.
  *
  * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
  * Author(s): Olivier Moysan <olivier.moysan@st.com> for STMicroelectronics.
- *
- * License terms: GPL V2.0.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
- * details.
  */
 
 #include <linux/clk.h>

commit 1c7c3237c0cc4ad3c7b0df458290c8e2a652f178
Merge: bfa8130f50a6 a188339ca5a3
Author: Mark Brown <broonie@kernel.org>
Date:   Mon May 20 11:53:50 2019 +0100

    Merge tag 'v5.2-rc1' into asoc-5.3
    
    Linux 5.2-rc1

commit 71ed4bddde08285cd02d6d28c861ea1815d67476
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon May 6 14:54:12 2019 +0200

    ASoC: stm32: i2s: manage identification registers
    
    Add support of identification registers in STM32 I2S.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 97d5e9901a0e..9755c49ae7dc 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -16,6 +16,7 @@
  * details.
  */
 
+#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/module.h>
@@ -37,6 +38,10 @@
 #define STM32_I2S_TXDR_REG	0X20
 #define STM32_I2S_RXDR_REG	0x30
 #define STM32_I2S_CGFR_REG	0X50
+#define STM32_I2S_HWCFGR_REG	0x3F0
+#define STM32_I2S_VERR_REG	0x3F4
+#define STM32_I2S_IPIDR_REG	0x3F8
+#define STM32_I2S_SIDR_REG	0x3FC
 
 /* Bit definition for SPI2S_CR1 register */
 #define I2S_CR1_SPE		BIT(0)
@@ -143,6 +148,23 @@
 #define I2S_CGFR_ODD		BIT(I2S_CGFR_ODD_SHIFT)
 #define I2S_CGFR_MCKOE		BIT(25)
 
+/* Registers below apply to I2S version 1.1 and more */
+
+/* Bit definition for SPI_HWCFGR register */
+#define I2S_HWCFGR_I2S_SUPPORT_MASK	GENMASK(15, 12)
+
+/* Bit definition for SPI_VERR register */
+#define I2S_VERR_MIN_MASK	GENMASK(3, 0)
+#define I2S_VERR_MAJ_MASK	GENMASK(7, 4)
+
+/* Bit definition for SPI_IPIDR register */
+#define I2S_IPIDR_ID_MASK	GENMASK(31, 0)
+
+/* Bit definition for SPI_SIDR register */
+#define I2S_SIDR_ID_MASK	GENMASK(31, 0)
+
+#define I2S_IPIDR_NUMBER	0x00130022
+
 enum i2s_master_mode {
 	I2S_MS_NOT_SET,
 	I2S_MS_MASTER,
@@ -280,6 +302,10 @@ static bool stm32_i2s_readable_reg(struct device *dev, unsigned int reg)
 	case STM32_I2S_SR_REG:
 	case STM32_I2S_RXDR_REG:
 	case STM32_I2S_CGFR_REG:
+	case STM32_I2S_HWCFGR_REG:
+	case STM32_I2S_VERR_REG:
+	case STM32_I2S_IPIDR_REG:
+	case STM32_I2S_SIDR_REG:
 		return true;
 	default:
 		return false;
@@ -711,10 +737,11 @@ static const struct regmap_config stm32_h7_i2s_regmap_conf = {
 	.reg_bits = 32,
 	.reg_stride = 4,
 	.val_bits = 32,
-	.max_register = STM32_I2S_CGFR_REG,
+	.max_register = STM32_I2S_SIDR_REG,
 	.readable_reg = stm32_i2s_readable_reg,
 	.volatile_reg = stm32_i2s_volatile_reg,
 	.writeable_reg = stm32_i2s_writeable_reg,
+	.num_reg_defaults_raw = STM32_I2S_SIDR_REG / sizeof(u32) + 1,
 	.fast_io = true,
 	.cache_type = REGCACHE_FLAT,
 };
@@ -864,6 +891,7 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 static int stm32_i2s_probe(struct platform_device *pdev)
 {
 	struct stm32_i2s_data *i2s;
+	u32 val;
 	int ret;
 
 	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
@@ -902,8 +930,34 @@ static int stm32_i2s_probe(struct platform_device *pdev)
 		return ret;
 
 	/* Set SPI/I2S in i2s mode */
-	return regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
-				  I2S_CGFR_I2SMOD, I2S_CGFR_I2SMOD);
+	ret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
+				 I2S_CGFR_I2SMOD, I2S_CGFR_I2SMOD);
+	if (ret)
+		return ret;
+
+	ret = regmap_read(i2s->regmap, STM32_I2S_IPIDR_REG, &val);
+	if (ret)
+		return ret;
+
+	if (val == I2S_IPIDR_NUMBER) {
+		ret = regmap_read(i2s->regmap, STM32_I2S_HWCFGR_REG, &val);
+		if (ret)
+			return ret;
+
+		if (!FIELD_GET(I2S_HWCFGR_I2S_SUPPORT_MASK, val)) {
+			dev_err(&pdev->dev,
+				"Device does not support i2s mode\n");
+			return -EPERM;
+		}
+
+		ret = regmap_read(i2s->regmap, STM32_I2S_VERR_REG, &val);
+
+		dev_dbg(&pdev->dev, "I2S version: %lu.%lu registered\n",
+			FIELD_GET(I2S_VERR_MAJ_MASK, val),
+			FIELD_GET(I2S_VERR_MIN_MASK, val));
+	}
+
+	return ret;
 }
 
 MODULE_DEVICE_TABLE(of, stm32_i2s_ids);

commit 4fc19fffaaf87335aafaeb059a561ef91aa6031c
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon May 6 14:54:11 2019 +0200

    ASoC: stm32: i2s: update pcm hardware constraints
    
    - Set period minimum size. Ensure at least 5ms period
    up to 48kHz/16 bits to prevent underrun/overrun.
    - Remove MDMA constraints on period maximum size and
    set period maximum to half the buffer maximum size.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 97d5e9901a0e..8ee697ff1f86 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -731,7 +731,8 @@ static const struct snd_soc_dai_ops stm32_i2s_pcm_dai_ops = {
 static const struct snd_pcm_hardware stm32_i2s_pcm_hw = {
 	.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_MMAP,
 	.buffer_bytes_max = 8 * PAGE_SIZE,
-	.period_bytes_max = 2048,
+	.period_bytes_min = 1024,
+	.period_bytes_max = 4 * PAGE_SIZE,
 	.periods_min = 2,
 	.periods_max = 8,
 };

commit 93f38ef6a4b62fd57076d36d1345d69f8a328ad9
Merge: 552f2d7edd38 780f202f2bf4
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 26 11:02:03 2019 +0100

    Merge branch 'asoc-5.1' into asoc-5.2

commit 0bbf4084e0cfbbbff8673f3b9867778d5d4b1d6f
Author: Fabien Dessenne <fabien.dessenne@st.com>
Date:   Wed Apr 24 17:28:44 2019 +0200

    ASoC: stm32: i2s: return the get_irq error
    
    During probe, return the "get_irq" error value instead of -ENOENT. This
    allows the driver to be deferred probed if needed.
    
    Signed-off-by: Fabien Dessenne <fabien.dessenne@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 8968458eec62..e707d28cb203 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -845,8 +845,9 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 	/* Get irqs */
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
-		dev_err(&pdev->dev, "no irq for node %s\n", pdev->name);
-		return -ENOENT;
+		if (irq != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "no irq for node %s\n", pdev->name);
+		return irq;
 	}
 
 	ret = devm_request_irq(&pdev->dev, irq, stm32_i2s_isr, IRQF_ONESHOT,

commit 3863293a96c3e2481192b435fe0d85feed1ea47c
Merge: 4346a745df41 1c5b6a27e432
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Mar 18 14:57:27 2019 +0000

    Merge branch 'for-5.1' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-5.2

commit a39fe6e2061615496c12825d6d249fedf1974f8a
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon Mar 11 16:39:28 2019 +0100

    ASoC: stm32: i2s: fix registers declaration in regmap
    
    - Declare SR as volatile, as it is changed by hardware.
    - Remove TXDR from readable and volatile register list,
    as it is intended for write accesses only.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 47c334de6b09..8968458eec62 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -281,7 +281,6 @@ static bool stm32_i2s_readable_reg(struct device *dev, unsigned int reg)
 	case STM32_I2S_CFG2_REG:
 	case STM32_I2S_IER_REG:
 	case STM32_I2S_SR_REG:
-	case STM32_I2S_TXDR_REG:
 	case STM32_I2S_RXDR_REG:
 	case STM32_I2S_CGFR_REG:
 		return true;
@@ -293,7 +292,7 @@ static bool stm32_i2s_readable_reg(struct device *dev, unsigned int reg)
 static bool stm32_i2s_volatile_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
-	case STM32_I2S_TXDR_REG:
+	case STM32_I2S_SR_REG:
 	case STM32_I2S_RXDR_REG:
 		return true;
 	default:

commit fef050c88ce1cbec1ab9a0d981b5331a5ba40f15
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon Mar 11 16:26:30 2019 +0100

    ASoC: stm32: i2s: use default dai name
    
    Use default DAI name based on dev_name function.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 06bbbef74b3a..c18e068c1a0d 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -179,7 +179,6 @@ enum i2s_datlen {
 	I2S_I2SMOD_DATLEN_32,
 };
 
-#define STM32_I2S_DAI_NAME_SIZE		20
 #define STM32_I2S_FIFO_SIZE		16
 
 #define STM32_I2S_IS_MASTER(x)		((x)->ms_flg == I2S_MS_MASTER)
@@ -202,7 +201,6 @@ enum i2s_datlen {
  * @phys_addr: I2S registers physical base address
  * @lock_fd: lock to manage race conditions in full duplex mode
  * @irq_lock: prevent race condition with IRQ
- * @dais_name: DAI name
  * @mclk_rate: master clock frequency (Hz)
  * @fmt: DAI protocol
  * @refcount: keep count of opened streams on I2S
@@ -224,7 +222,6 @@ struct stm32_i2s_data {
 	dma_addr_t phys_addr;
 	spinlock_t lock_fd; /* Manage race conditions for full duplex */
 	spinlock_t irq_lock; /* used to prevent race condition with IRQ */
-	char dais_name[STM32_I2S_DAI_NAME_SIZE];
 	unsigned int mclk_rate;
 	unsigned int fmt;
 	int refcount;
@@ -771,12 +768,8 @@ static int stm32_i2s_dais_init(struct platform_device *pdev,
 	if (!dai_ptr)
 		return -ENOMEM;
 
-	snprintf(i2s->dais_name, STM32_I2S_DAI_NAME_SIZE,
-		 "%s", dev_name(&pdev->dev));
-
 	dai_ptr->probe = stm32_i2s_dai_probe;
 	dai_ptr->ops = &stm32_i2s_pcm_dai_ops;
-	dai_ptr->name = i2s->dais_name;
 	dai_ptr->id = 1;
 	stm32_i2s_dai_init(&dai_ptr->playback, "playback");
 	stm32_i2s_dai_init(&dai_ptr->capture, "capture");

commit c2dc8b2c114c22d7a04cf26a7c7d04faaa757143
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon Mar 11 16:26:29 2019 +0100

    ASoC: stm32: i2s: improve channel capabilities handling
    
    Use alsa snd_pcm_hw_constraint_single service to manage
    channels restriction. This provides better status on driver
    limitations, to the application.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 783b33497435..06bbbef74b3a 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -496,12 +496,6 @@ static int stm32_i2s_configure(struct snd_soc_dai *cpu_dai,
 	unsigned int fthlv;
 	int ret;
 
-	if ((params_channels(params) == 1) &&
-	    ((i2s->fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_DSP_A)) {
-		dev_err(cpu_dai->dev, "Mono mode supported only by DSP_A\n");
-		return -EINVAL;
-	}
-
 	switch (format) {
 	case 16:
 		cfgr = I2S_CGFR_DATLEN_SET(I2S_I2SMOD_DATLEN_16);
@@ -551,6 +545,10 @@ static int stm32_i2s_startup(struct snd_pcm_substream *substream,
 	i2s->substream = substream;
 	spin_unlock_irqrestore(&i2s->irq_lock, flags);
 
+	if ((i2s->fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_DSP_A)
+		snd_pcm_hw_constraint_single(substream->runtime,
+					     SNDRV_PCM_HW_PARAM_CHANNELS, 2);
+
 	ret = clk_prepare_enable(i2s->i2sclk);
 	if (ret < 0) {
 		dev_err(cpu_dai->dev, "Failed to enable clock: %d\n", ret);

commit 52e7306ca2db565edc1503a74477f3547bc9e408
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Mon Mar 11 16:26:28 2019 +0100

    ASoC: stm32: i2s: change trigger traces
    
    Update traces to log capture/playback stream start/stop.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 47c334de6b09..783b33497435 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -593,7 +593,8 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		/* Enable i2s */
-		dev_dbg(cpu_dai->dev, "start I2S\n");
+		dev_dbg(cpu_dai->dev, "start I2S %s\n",
+			playback_flg ? "playback" : "capture");
 
 		cfg1_mask = I2S_CFG1_RXDMAEN | I2S_CFG1_TXDMAEN;
 		regmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,
@@ -638,6 +639,9 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev_dbg(cpu_dai->dev, "stop I2S %s\n",
+			playback_flg ? "playback" : "capture");
+
 		if (playback_flg)
 			regmap_update_bits(i2s->regmap, STM32_I2S_IER_REG,
 					   I2S_IER_UDRIE,
@@ -654,8 +658,6 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			break;
 		}
 
-		dev_dbg(cpu_dai->dev, "stop I2S\n");
-
 		ret = regmap_update_bits(i2s->regmap, STM32_I2S_CR1_REG,
 					 I2S_CR1_SPE, 0);
 		if (ret < 0) {

commit 7b6b0049e2b70d103adf1b7d0320802f70ddceca
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Tue Feb 26 14:51:10 2019 +0100

    ASoC: stm32: i2s: skip useless write in slave mode
    
    Dummy write in capture master mode is used to gate
    bus clocks. This write is useless in slave mode
    as the clocks are not managed by slave.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 42ce87a35104..47c334de6b09 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -623,8 +623,8 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 		} else {
 			ier = I2S_IER_OVRIE;
 
-			if (i2s->refcount == 1)
-				/* dummy write to trigger capture */
+			if (STM32_I2S_IS_MASTER(i2s) && i2s->refcount == 1)
+				/* dummy write to gate bus clocks */
 				regmap_write(i2s->regmap,
 					     STM32_I2S_TXDR_REG, 0);
 		}

commit 3005decf4fe43e65d882dce838716bd6715757c1
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Tue Feb 26 14:51:09 2019 +0100

    ASoC: stm32: i2s: fix race condition in irq handler
    
    When snd_pcm_stop_xrun() is called in interrupt routine,
    substream context may have already been released.
    Add protection on substream context.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 9edb753ffa1b..42ce87a35104 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -201,6 +201,7 @@ enum i2s_datlen {
  * @base:  mmio register base virtual address
  * @phys_addr: I2S registers physical base address
  * @lock_fd: lock to manage race conditions in full duplex mode
+ * @irq_lock: prevent race condition with IRQ
  * @dais_name: DAI name
  * @mclk_rate: master clock frequency (Hz)
  * @fmt: DAI protocol
@@ -222,6 +223,7 @@ struct stm32_i2s_data {
 	void __iomem *base;
 	dma_addr_t phys_addr;
 	spinlock_t lock_fd; /* Manage race conditions for full duplex */
+	spinlock_t irq_lock; /* used to prevent race condition with IRQ */
 	char dais_name[STM32_I2S_DAI_NAME_SIZE];
 	unsigned int mclk_rate;
 	unsigned int fmt;
@@ -263,8 +265,10 @@ static irqreturn_t stm32_i2s_isr(int irq, void *devid)
 	if (flags & I2S_SR_TIFRE)
 		dev_dbg(&pdev->dev, "Frame error\n");
 
-	if (err)
+	spin_lock(&i2s->irq_lock);
+	if (err && i2s->substream)
 		snd_pcm_stop_xrun(i2s->substream);
+	spin_unlock(&i2s->irq_lock);
 
 	return IRQ_HANDLED;
 }
@@ -540,9 +544,12 @@ static int stm32_i2s_startup(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *cpu_dai)
 {
 	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
 	int ret;
 
+	spin_lock_irqsave(&i2s->irq_lock, flags);
 	i2s->substream = substream;
+	spin_unlock_irqrestore(&i2s->irq_lock, flags);
 
 	ret = clk_prepare_enable(i2s->i2sclk);
 	if (ret < 0) {
@@ -673,13 +680,16 @@ static void stm32_i2s_shutdown(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *cpu_dai)
 {
 	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
-
-	i2s->substream = NULL;
+	unsigned long flags;
 
 	regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
 			   I2S_CGFR_MCKOE, (unsigned int)~I2S_CGFR_MCKOE);
 
 	clk_disable_unprepare(i2s->i2sclk);
+
+	spin_lock_irqsave(&i2s->irq_lock, flags);
+	i2s->substream = NULL;
+	spin_unlock_irqrestore(&i2s->irq_lock, flags);
 }
 
 static int stm32_i2s_dai_probe(struct snd_soc_dai *cpu_dai)
@@ -874,6 +884,7 @@ static int stm32_i2s_probe(struct platform_device *pdev)
 	i2s->pdev = pdev;
 	i2s->ms_flg = I2S_MS_NOT_SET;
 	spin_lock_init(&i2s->lock_fd);
+	spin_lock_init(&i2s->irq_lock);
 	platform_set_drvdata(pdev, i2s);
 
 	ret = stm32_i2s_dais_init(pdev, i2s);

commit 88dce52ee9b58b627cf75f5aeb53ab5ea6340472
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Tue Feb 26 14:51:08 2019 +0100

    ASoC: stm32: i2s: remove useless callback
    
    Clocks do not need to be released on driver removal,
    as this is already managed before.
    Remove useless remove callback.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 95fffb61faa5..9edb753ffa1b 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -902,16 +902,6 @@ static int stm32_i2s_probe(struct platform_device *pdev)
 				  I2S_CGFR_I2SMOD, I2S_CGFR_I2SMOD);
 }
 
-static int stm32_i2s_remove(struct platform_device *pdev)
-{
-	struct stm32_i2s_data *i2s = platform_get_drvdata(pdev);
-
-	clk_disable_unprepare(i2s->i2sclk);
-	clk_disable_unprepare(i2s->pclk);
-
-	return 0;
-}
-
 MODULE_DEVICE_TABLE(of, stm32_i2s_ids);
 
 #ifdef CONFIG_PM_SLEEP
@@ -945,7 +935,6 @@ static struct platform_driver stm32_i2s_driver = {
 		.pm = &stm32_i2s_pm_ops,
 	},
 	.probe = stm32_i2s_probe,
-	.remove = stm32_i2s_remove,
 };
 
 module_platform_driver(stm32_i2s_driver);

commit 1ac2bd16448997d9ec01922423486e1e85535eda
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Tue Feb 26 14:51:07 2019 +0100

    ASoC: stm32: i2s: fix dma configuration
    
    DMA configuration is not balanced on start/stop.
    Move DMA configuration to trigger callback.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 7f56d7b51ba3..95fffb61faa5 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -488,7 +488,7 @@ static int stm32_i2s_configure(struct snd_soc_dai *cpu_dai,
 {
 	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
 	int format = params_width(params);
-	u32 cfgr, cfgr_mask, cfg1, cfg1_mask;
+	u32 cfgr, cfgr_mask, cfg1;
 	unsigned int fthlv;
 	int ret;
 
@@ -529,15 +529,11 @@ static int stm32_i2s_configure(struct snd_soc_dai *cpu_dai,
 	if (ret < 0)
 		return ret;
 
-	cfg1 = I2S_CFG1_RXDMAEN | I2S_CFG1_TXDMAEN;
-	cfg1_mask = cfg1;
-
 	fthlv = STM32_I2S_FIFO_SIZE * I2S_FIFO_TH_ONE_QUARTER / 4;
-	cfg1 |= I2S_CFG1_FTHVL_SET(fthlv - 1);
-	cfg1_mask |= I2S_CFG1_FTHVL_MASK;
+	cfg1 = I2S_CFG1_FTHVL_SET(fthlv - 1);
 
 	return regmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,
-				  cfg1_mask, cfg1);
+				  I2S_CFG1_FTHVL_MASK, cfg1);
 }
 
 static int stm32_i2s_startup(struct snd_pcm_substream *substream,
@@ -592,6 +588,10 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 		/* Enable i2s */
 		dev_dbg(cpu_dai->dev, "start I2S\n");
 
+		cfg1_mask = I2S_CFG1_RXDMAEN | I2S_CFG1_TXDMAEN;
+		regmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,
+				   cfg1_mask, cfg1_mask);
+
 		ret = regmap_update_bits(i2s->regmap, STM32_I2S_CR1_REG,
 					 I2S_CR1_SPE, I2S_CR1_SPE);
 		if (ret < 0) {

commit ebf629d502cf7aa138b86f36dc016faf6c8e39e3
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Tue Feb 26 14:51:06 2019 +0100

    ASoC: stm32: i2s: fix stream count management
    
    Move counter handling to trigger start section
    to manage multiple start/stop events.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 7d4c67433916..7f56d7b51ba3 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -554,10 +554,6 @@ static int stm32_i2s_startup(struct snd_pcm_substream *substream,
 		return ret;
 	}
 
-	spin_lock(&i2s->lock_fd);
-	i2s->refcount++;
-	spin_unlock(&i2s->lock_fd);
-
 	return regmap_write_bits(i2s->regmap, STM32_I2S_IFCR_REG,
 				 I2S_IFCR_MASK, I2S_IFCR_MASK);
 }
@@ -613,18 +609,19 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 		regmap_write_bits(i2s->regmap, STM32_I2S_IFCR_REG,
 				  I2S_IFCR_MASK, I2S_IFCR_MASK);
 
+		spin_lock(&i2s->lock_fd);
+		i2s->refcount++;
 		if (playback_flg) {
 			ier = I2S_IER_UDRIE;
 		} else {
 			ier = I2S_IER_OVRIE;
 
-			spin_lock(&i2s->lock_fd);
 			if (i2s->refcount == 1)
 				/* dummy write to trigger capture */
 				regmap_write(i2s->regmap,
 					     STM32_I2S_TXDR_REG, 0);
-			spin_unlock(&i2s->lock_fd);
 		}
+		spin_unlock(&i2s->lock_fd);
 
 		if (STM32_I2S_IS_SLAVE(i2s))
 			ier |= I2S_IER_TIFREIE;
@@ -649,7 +646,6 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			spin_unlock(&i2s->lock_fd);
 			break;
 		}
-		spin_unlock(&i2s->lock_fd);
 
 		dev_dbg(cpu_dai->dev, "stop I2S\n");
 
@@ -657,8 +653,10 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 					 I2S_CR1_SPE, 0);
 		if (ret < 0) {
 			dev_err(cpu_dai->dev, "Error %d disabling I2S\n", ret);
+			spin_unlock(&i2s->lock_fd);
 			return ret;
 		}
+		spin_unlock(&i2s->lock_fd);
 
 		cfg1_mask = I2S_CFG1_RXDMAEN | I2S_CFG1_TXDMAEN;
 		regmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,

commit 0c4c68d6fa1bae74d450e50823c24fcc3cd0b171
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Tue Feb 26 14:51:05 2019 +0100

    ASoC: stm32: i2s: fix 16 bit format support
    
    I2S supports 16 bits data in 32 channel length.
    However the expected driver behavior, is to
    set channel length to 16 bits when data format is 16 bits.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 339cd4715b2e..7d4c67433916 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -501,7 +501,7 @@ static int stm32_i2s_configure(struct snd_soc_dai *cpu_dai,
 	switch (format) {
 	case 16:
 		cfgr = I2S_CGFR_DATLEN_SET(I2S_I2SMOD_DATLEN_16);
-		cfgr_mask = I2S_CGFR_DATLEN_MASK;
+		cfgr_mask = I2S_CGFR_DATLEN_MASK | I2S_CGFR_CHLEN;
 		break;
 	case 32:
 		cfgr = I2S_CGFR_DATLEN_SET(I2S_I2SMOD_DATLEN_32) |

commit 8ba3c5215d69c09f5c39783ff3b78347769822ad
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Tue Feb 26 14:51:04 2019 +0100

    ASoC: stm32: i2s: fix IRQ clearing
    
    Because of regmap cache, interrupts may not be cleared
    as expected.
    Declare IFCR register as write only and make writings
    to IFCR register unconditional.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index a25919d32187..339cd4715b2e 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -247,8 +247,8 @@ static irqreturn_t stm32_i2s_isr(int irq, void *devid)
 		return IRQ_NONE;
 	}
 
-	regmap_update_bits(i2s->regmap, STM32_I2S_IFCR_REG,
-			   I2S_IFCR_MASK, flags);
+	regmap_write_bits(i2s->regmap, STM32_I2S_IFCR_REG,
+			  I2S_IFCR_MASK, flags);
 
 	if (flags & I2S_SR_OVR) {
 		dev_dbg(&pdev->dev, "Overrun\n");
@@ -277,7 +277,6 @@ static bool stm32_i2s_readable_reg(struct device *dev, unsigned int reg)
 	case STM32_I2S_CFG2_REG:
 	case STM32_I2S_IER_REG:
 	case STM32_I2S_SR_REG:
-	case STM32_I2S_IFCR_REG:
 	case STM32_I2S_TXDR_REG:
 	case STM32_I2S_RXDR_REG:
 	case STM32_I2S_CGFR_REG:
@@ -559,8 +558,8 @@ static int stm32_i2s_startup(struct snd_pcm_substream *substream,
 	i2s->refcount++;
 	spin_unlock(&i2s->lock_fd);
 
-	return regmap_update_bits(i2s->regmap, STM32_I2S_IFCR_REG,
-				  I2S_IFCR_MASK, I2S_IFCR_MASK);
+	return regmap_write_bits(i2s->regmap, STM32_I2S_IFCR_REG,
+				 I2S_IFCR_MASK, I2S_IFCR_MASK);
 }
 
 static int stm32_i2s_hw_params(struct snd_pcm_substream *substream,
@@ -611,8 +610,8 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			return ret;
 		}
 
-		regmap_update_bits(i2s->regmap, STM32_I2S_IFCR_REG,
-				   I2S_IFCR_MASK, I2S_IFCR_MASK);
+		regmap_write_bits(i2s->regmap, STM32_I2S_IFCR_REG,
+				  I2S_IFCR_MASK, I2S_IFCR_MASK);
 
 		if (playback_flg) {
 			ier = I2S_IER_UDRIE;

commit 6a68eeee0f03ab371bec7a719795f69b05be183f
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Fri Feb 8 11:49:54 2019 +0100

    SoC: stm32: i2s: manage clock power
    
    Kernel clock management:
    Enable/disable I2S kernel clock on audio stream startup/shutdown.
    
    Peripheral clock management:
    Manage I2S peripheral clock power through regmap services.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index dbe23a709d24..a25919d32187 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -545,9 +545,16 @@ static int stm32_i2s_startup(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *cpu_dai)
 {
 	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
 
 	i2s->substream = substream;
 
+	ret = clk_prepare_enable(i2s->i2sclk);
+	if (ret < 0) {
+		dev_err(cpu_dai->dev, "Failed to enable clock: %d\n", ret);
+		return ret;
+	}
+
 	spin_lock(&i2s->lock_fd);
 	i2s->refcount++;
 	spin_unlock(&i2s->lock_fd);
@@ -674,6 +681,8 @@ static void stm32_i2s_shutdown(struct snd_pcm_substream *substream,
 
 	regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
 			   I2S_CGFR_MCKOE, (unsigned int)~I2S_CGFR_MCKOE);
+
+	clk_disable_unprepare(i2s->i2sclk);
 }
 
 static int stm32_i2s_dai_probe(struct snd_soc_dai *cpu_dai)
@@ -874,49 +883,26 @@ static int stm32_i2s_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	i2s->regmap = devm_regmap_init_mmio(&pdev->dev, i2s->base,
-					    i2s->regmap_conf);
+	i2s->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "pclk",
+						i2s->base, i2s->regmap_conf);
 	if (IS_ERR(i2s->regmap)) {
 		dev_err(&pdev->dev, "regmap init failed\n");
 		return PTR_ERR(i2s->regmap);
 	}
 
-	ret = clk_prepare_enable(i2s->pclk);
-	if (ret) {
-		dev_err(&pdev->dev, "Enable pclk failed: %d\n", ret);
-		return ret;
-	}
-
-	ret = clk_prepare_enable(i2s->i2sclk);
-	if (ret) {
-		dev_err(&pdev->dev, "Enable i2sclk failed: %d\n", ret);
-		goto err_pclk_disable;
-	}
-
 	ret = devm_snd_soc_register_component(&pdev->dev, &stm32_i2s_component,
 					      i2s->dai_drv, 1);
 	if (ret)
-		goto err_clocks_disable;
+		return ret;
 
 	ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
 					      &stm32_i2s_pcm_config, 0);
 	if (ret)
-		goto err_clocks_disable;
+		return ret;
 
 	/* Set SPI/I2S in i2s mode */
-	ret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
-				 I2S_CGFR_I2SMOD, I2S_CGFR_I2SMOD);
-	if (ret)
-		goto err_clocks_disable;
-
-	return ret;
-
-err_clocks_disable:
-	clk_disable_unprepare(i2s->i2sclk);
-err_pclk_disable:
-	clk_disable_unprepare(i2s->pclk);
-
-	return ret;
+	return regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
+				  I2S_CGFR_I2SMOD, I2S_CGFR_I2SMOD);
 }
 
 static int stm32_i2s_remove(struct platform_device *pdev)

commit 307cce4a0017f94c6266050487c117660d66104e
Author: Olivier Moysan <olivier.moysan@st.com>
Date:   Fri Feb 8 11:49:53 2019 +0100

    ASoC: stm32: i2s: add power management
    
    Add suspend and resume sleep callbacks,
    to support system low power modes.
    
    Signed-off-by: Olivier Moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 6d0bf78d114d..dbe23a709d24 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -186,8 +186,9 @@ enum i2s_datlen {
 #define STM32_I2S_IS_SLAVE(x)		((x)->ms_flg == I2S_MS_SLAVE)
 
 /**
+ * struct stm32_i2s_data - private data of I2S
  * @regmap_conf: I2S register map configuration pointer
- * @egmap: I2S register map pointer
+ * @regmap: I2S register map pointer
  * @pdev: device data pointer
  * @dai_drv: DAI driver pointer
  * @dma_data_tx: dma configuration data for tx channel
@@ -596,8 +597,8 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			return ret;
 		}
 
-		ret = regmap_update_bits(i2s->regmap, STM32_I2S_CR1_REG,
-					 I2S_CR1_CSTART, I2S_CR1_CSTART);
+		ret = regmap_write_bits(i2s->regmap, STM32_I2S_CR1_REG,
+					I2S_CR1_CSTART, I2S_CR1_CSTART);
 		if (ret < 0) {
 			dev_err(cpu_dai->dev, "Error %d starting I2S\n", ret);
 			return ret;
@@ -703,6 +704,7 @@ static const struct regmap_config stm32_h7_i2s_regmap_conf = {
 	.volatile_reg = stm32_i2s_volatile_reg,
 	.writeable_reg = stm32_i2s_writeable_reg,
 	.fast_io = true,
+	.cache_type = REGCACHE_FLAT,
 };
 
 static const struct snd_soc_dai_ops stm32_i2s_pcm_dai_ops = {
@@ -929,10 +931,35 @@ static int stm32_i2s_remove(struct platform_device *pdev)
 
 MODULE_DEVICE_TABLE(of, stm32_i2s_ids);
 
+#ifdef CONFIG_PM_SLEEP
+static int stm32_i2s_suspend(struct device *dev)
+{
+	struct stm32_i2s_data *i2s = dev_get_drvdata(dev);
+
+	regcache_cache_only(i2s->regmap, true);
+	regcache_mark_dirty(i2s->regmap);
+
+	return 0;
+}
+
+static int stm32_i2s_resume(struct device *dev)
+{
+	struct stm32_i2s_data *i2s = dev_get_drvdata(dev);
+
+	regcache_cache_only(i2s->regmap, false);
+	return regcache_sync(i2s->regmap);
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops stm32_i2s_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_i2s_suspend, stm32_i2s_resume)
+};
+
 static struct platform_driver stm32_i2s_driver = {
 	.driver = {
 		.name = "st,stm32-i2s",
 		.of_match_table = stm32_i2s_ids,
+		.pm = &stm32_i2s_pm_ops,
 	},
 	.probe = stm32_i2s_probe,
 	.remove = stm32_i2s_remove,

commit 635eac1e54d82c59f621a0f38a9bffae50f150c7
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Wed Jul 19 17:26:42 2017 +0200

    ASoC: stm32: explicitly request exclusive reset control
    
    Commit a53e35db70d1 ("reset: Ensure drivers are explicit when requesting
    reset lines") started to transition the reset control request API calls
    to explicitly state whether the driver needs exclusive or shared reset
    control behavior. Convert all drivers requesting exclusive resets to the
    explicit API call so the temporary transition helpers can be removed.
    
    No functional changes.
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@st.com>
    Cc: alsa-devel@alsa-project.org
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 8052629a89df..6d0bf78d114d 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -840,7 +840,7 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 	}
 
 	/* Reset */
-	rst = devm_reset_control_get(&pdev->dev, NULL);
+	rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
 	if (!IS_ERR(rst)) {
 		reset_control_assert(rst);
 		udelay(2);

commit e7cc49b8adf25e7bae6acaeb37036ef8726b902c
Author: olivier moysan <olivier.moysan@st.com>
Date:   Thu May 18 17:19:53 2017 +0200

    ASoC: stm32: Add full duplex support to i2s
    
    This patch allows to use i2s interface either as single
    audio path (rx or tx), or bidirectional audio path.
    This patch is added separately, as the driver does not
    follow recommended use of the interface, to support this
    configuration.
    
    Signed-off-by: olivier moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index 22152a1ca733..8052629a89df 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -489,7 +489,6 @@ static int stm32_i2s_configure(struct snd_soc_dai *cpu_dai,
 	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
 	int format = params_width(params);
 	u32 cfgr, cfgr_mask, cfg1, cfg1_mask;
-	bool playback_flg = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
 	unsigned int fthlv;
 	int ret;
 
@@ -515,19 +514,13 @@ static int stm32_i2s_configure(struct snd_soc_dai *cpu_dai,
 	}
 
 	if (STM32_I2S_IS_SLAVE(i2s)) {
-		if (playback_flg)
-			cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_TX_SLAVE);
-		else
-			cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_RX_SLAVE);
+		cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_FD_SLAVE);
 
 		/* As data length is either 16 or 32 bits, fixch always set */
 		cfgr |= I2S_CGFR_FIXCH;
 		cfgr_mask |= I2S_CGFR_FIXCH;
 	} else {
-		if (playback_flg)
-			cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_TX_MASTER);
-		else
-			cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_RX_MASTER);
+		cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_FD_MASTER);
 	}
 	cfgr_mask |= I2S_CGFR_I2SCFG_MASK;
 
@@ -536,9 +529,7 @@ static int stm32_i2s_configure(struct snd_soc_dai *cpu_dai,
 	if (ret < 0)
 		return ret;
 
-	cfg1 = I2S_CFG1_RXDMAEN;
-	if (playback_flg)
-		cfg1 = I2S_CFG1_TXDMAEN;
+	cfg1 = I2S_CFG1_RXDMAEN | I2S_CFG1_TXDMAEN;
 	cfg1_mask = cfg1;
 
 	fthlv = STM32_I2S_FIFO_SIZE * I2S_FIFO_TH_ONE_QUARTER / 4;
@@ -553,32 +544,15 @@ static int stm32_i2s_startup(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *cpu_dai)
 {
 	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
-	int ret, ier;
 
 	i2s->substream = substream;
 
 	spin_lock(&i2s->lock_fd);
-	if (i2s->refcount) {
-		dev_err(cpu_dai->dev, "%s stream already started\n",
-			(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
-			"Capture" : "Playback"));
-		spin_unlock(&i2s->lock_fd);
-		return -EBUSY;
-	}
-	i2s->refcount = 1;
+	i2s->refcount++;
 	spin_unlock(&i2s->lock_fd);
 
-	ret = regmap_update_bits(i2s->regmap, STM32_I2S_IFCR_REG,
-				 I2S_IFCR_MASK, I2S_IFCR_MASK);
-	if (ret < 0)
-		return ret;
-
-	/* Enable ITs */
-	ier = I2S_IER_OVRIE | I2S_IER_UDRIE;
-	if (STM32_I2S_IS_SLAVE(i2s))
-		ier |= I2S_IER_TIFREIE;
-
-	return regmap_update_bits(i2s->regmap, STM32_I2S_IER_REG, ier, ier);
+	return regmap_update_bits(i2s->regmap, STM32_I2S_IFCR_REG,
+				  I2S_IFCR_MASK, I2S_IFCR_MASK);
 }
 
 static int stm32_i2s_hw_params(struct snd_pcm_substream *substream,
@@ -605,7 +579,7 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 {
 	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
 	bool playback_flg = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
-	u32 cfg1_mask;
+	u32 cfg1_mask, ier;
 	int ret;
 
 	switch (cmd) {
@@ -628,10 +602,48 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			dev_err(cpu_dai->dev, "Error %d starting I2S\n", ret);
 			return ret;
 		}
+
+		regmap_update_bits(i2s->regmap, STM32_I2S_IFCR_REG,
+				   I2S_IFCR_MASK, I2S_IFCR_MASK);
+
+		if (playback_flg) {
+			ier = I2S_IER_UDRIE;
+		} else {
+			ier = I2S_IER_OVRIE;
+
+			spin_lock(&i2s->lock_fd);
+			if (i2s->refcount == 1)
+				/* dummy write to trigger capture */
+				regmap_write(i2s->regmap,
+					     STM32_I2S_TXDR_REG, 0);
+			spin_unlock(&i2s->lock_fd);
+		}
+
+		if (STM32_I2S_IS_SLAVE(i2s))
+			ier |= I2S_IER_TIFREIE;
+
+		regmap_update_bits(i2s->regmap, STM32_I2S_IER_REG, ier, ier);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (playback_flg)
+			regmap_update_bits(i2s->regmap, STM32_I2S_IER_REG,
+					   I2S_IER_UDRIE,
+					   (unsigned int)~I2S_IER_UDRIE);
+		else
+			regmap_update_bits(i2s->regmap, STM32_I2S_IER_REG,
+					   I2S_IER_OVRIE,
+					   (unsigned int)~I2S_IER_OVRIE);
+
+		spin_lock(&i2s->lock_fd);
+		i2s->refcount--;
+		if (i2s->refcount) {
+			spin_unlock(&i2s->lock_fd);
+			break;
+		}
+		spin_unlock(&i2s->lock_fd);
+
 		dev_dbg(cpu_dai->dev, "stop I2S\n");
 
 		ret = regmap_update_bits(i2s->regmap, STM32_I2S_CR1_REG,
@@ -641,10 +653,7 @@ static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 			return ret;
 		}
 
-		cfg1_mask = I2S_CFG1_RXDMAEN;
-		if (playback_flg)
-			cfg1_mask = I2S_CFG1_TXDMAEN;
-
+		cfg1_mask = I2S_CFG1_RXDMAEN | I2S_CFG1_TXDMAEN;
 		regmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,
 				   cfg1_mask, 0);
 		break;
@@ -662,10 +671,6 @@ static void stm32_i2s_shutdown(struct snd_pcm_substream *substream,
 
 	i2s->substream = NULL;
 
-	spin_lock(&i2s->lock_fd);
-	i2s->refcount = 0;
-	spin_unlock(&i2s->lock_fd);
-
 	regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
 			   I2S_CGFR_MCKOE, (unsigned int)~I2S_CGFR_MCKOE);
 }

commit e4e6ec7b127c97fbfa92161d0fc69f526f603e97
Author: olivier moysan <olivier.moysan@st.com>
Date:   Thu May 18 17:19:52 2017 +0200

    ASoC: stm32: Add I2S driver
    
    Add I2S ASoC driver for STM32.
    This version of the driver supports only
    exclusive playback and capture interface.
    
    Signed-off-by: olivier moysan <olivier.moysan@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
new file mode 100644
index 000000000000..22152a1ca733
--- /dev/null
+++ b/sound/soc/stm/stm32_i2s.c
@@ -0,0 +1,941 @@
+/*
+ *  STM32 ALSA SoC Digital Audio Interface (I2S) driver.
+ *
+ * Copyright (C) 2017, STMicroelectronics - All Rights Reserved
+ * Author(s): Olivier Moysan <olivier.moysan@st.com> for STMicroelectronics.
+ *
+ * License terms: GPL V2.0.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+
+#define STM32_I2S_CR1_REG	0x0
+#define STM32_I2S_CFG1_REG	0x08
+#define STM32_I2S_CFG2_REG	0x0C
+#define STM32_I2S_IER_REG	0x10
+#define STM32_I2S_SR_REG	0x14
+#define STM32_I2S_IFCR_REG	0x18
+#define STM32_I2S_TXDR_REG	0X20
+#define STM32_I2S_RXDR_REG	0x30
+#define STM32_I2S_CGFR_REG	0X50
+
+/* Bit definition for SPI2S_CR1 register */
+#define I2S_CR1_SPE		BIT(0)
+#define I2S_CR1_CSTART		BIT(9)
+#define I2S_CR1_CSUSP		BIT(10)
+#define I2S_CR1_HDDIR		BIT(11)
+#define I2S_CR1_SSI		BIT(12)
+#define I2S_CR1_CRC33_17	BIT(13)
+#define I2S_CR1_RCRCI		BIT(14)
+#define I2S_CR1_TCRCI		BIT(15)
+
+/* Bit definition for SPI_CFG2 register */
+#define I2S_CFG2_IOSWP_SHIFT	15
+#define I2S_CFG2_IOSWP		BIT(I2S_CFG2_IOSWP_SHIFT)
+#define I2S_CFG2_LSBFRST	BIT(23)
+#define I2S_CFG2_AFCNTR		BIT(31)
+
+/* Bit definition for SPI_CFG1 register */
+#define I2S_CFG1_FTHVL_SHIFT	5
+#define I2S_CFG1_FTHVL_MASK	GENMASK(8, I2S_CFG1_FTHVL_SHIFT)
+#define I2S_CFG1_FTHVL_SET(x)	((x) << I2S_CFG1_FTHVL_SHIFT)
+
+#define I2S_CFG1_TXDMAEN	BIT(15)
+#define I2S_CFG1_RXDMAEN	BIT(14)
+
+/* Bit definition for SPI2S_IER register */
+#define I2S_IER_RXPIE		BIT(0)
+#define I2S_IER_TXPIE		BIT(1)
+#define I2S_IER_DPXPIE		BIT(2)
+#define I2S_IER_EOTIE		BIT(3)
+#define I2S_IER_TXTFIE		BIT(4)
+#define I2S_IER_UDRIE		BIT(5)
+#define I2S_IER_OVRIE		BIT(6)
+#define I2S_IER_CRCEIE		BIT(7)
+#define I2S_IER_TIFREIE		BIT(8)
+#define I2S_IER_MODFIE		BIT(9)
+#define I2S_IER_TSERFIE		BIT(10)
+
+/* Bit definition for SPI2S_SR register */
+#define I2S_SR_RXP		BIT(0)
+#define I2S_SR_TXP		BIT(1)
+#define I2S_SR_DPXP		BIT(2)
+#define I2S_SR_EOT		BIT(3)
+#define I2S_SR_TXTF		BIT(4)
+#define I2S_SR_UDR		BIT(5)
+#define I2S_SR_OVR		BIT(6)
+#define I2S_SR_CRCERR		BIT(7)
+#define I2S_SR_TIFRE		BIT(8)
+#define I2S_SR_MODF		BIT(9)
+#define I2S_SR_TSERF		BIT(10)
+#define I2S_SR_SUSP		BIT(11)
+#define I2S_SR_TXC		BIT(12)
+#define I2S_SR_RXPLVL		GENMASK(14, 13)
+#define I2S_SR_RXWNE		BIT(15)
+
+#define I2S_SR_MASK		GENMASK(15, 0)
+
+/* Bit definition for SPI_IFCR register */
+#define I2S_IFCR_EOTC		BIT(3)
+#define I2S_IFCR_TXTFC		BIT(4)
+#define I2S_IFCR_UDRC		BIT(5)
+#define I2S_IFCR_OVRC		BIT(6)
+#define I2S_IFCR_CRCEC		BIT(7)
+#define I2S_IFCR_TIFREC		BIT(8)
+#define I2S_IFCR_MODFC		BIT(9)
+#define I2S_IFCR_TSERFC		BIT(10)
+#define I2S_IFCR_SUSPC		BIT(11)
+
+#define I2S_IFCR_MASK		GENMASK(11, 3)
+
+/* Bit definition for SPI_I2SCGFR register */
+#define I2S_CGFR_I2SMOD		BIT(0)
+
+#define I2S_CGFR_I2SCFG_SHIFT	1
+#define I2S_CGFR_I2SCFG_MASK	GENMASK(3, I2S_CGFR_I2SCFG_SHIFT)
+#define I2S_CGFR_I2SCFG_SET(x)	((x) << I2S_CGFR_I2SCFG_SHIFT)
+
+#define I2S_CGFR_I2SSTD_SHIFT	4
+#define I2S_CGFR_I2SSTD_MASK	GENMASK(5, I2S_CGFR_I2SSTD_SHIFT)
+#define I2S_CGFR_I2SSTD_SET(x)	((x) << I2S_CGFR_I2SSTD_SHIFT)
+
+#define I2S_CGFR_PCMSYNC	BIT(7)
+
+#define I2S_CGFR_DATLEN_SHIFT	8
+#define I2S_CGFR_DATLEN_MASK	GENMASK(9, I2S_CGFR_DATLEN_SHIFT)
+#define I2S_CGFR_DATLEN_SET(x)	((x) << I2S_CGFR_DATLEN_SHIFT)
+
+#define I2S_CGFR_CHLEN_SHIFT	10
+#define I2S_CGFR_CHLEN		BIT(I2S_CGFR_CHLEN_SHIFT)
+#define I2S_CGFR_CKPOL		BIT(11)
+#define I2S_CGFR_FIXCH		BIT(12)
+#define I2S_CGFR_WSINV		BIT(13)
+#define I2S_CGFR_DATFMT		BIT(14)
+
+#define I2S_CGFR_I2SDIV_SHIFT	16
+#define I2S_CGFR_I2SDIV_BIT_H	23
+#define I2S_CGFR_I2SDIV_MASK	GENMASK(I2S_CGFR_I2SDIV_BIT_H,\
+				I2S_CGFR_I2SDIV_SHIFT)
+#define I2S_CGFR_I2SDIV_SET(x)	((x) << I2S_CGFR_I2SDIV_SHIFT)
+#define	I2S_CGFR_I2SDIV_MAX	((1 << (I2S_CGFR_I2SDIV_BIT_H -\
+				I2S_CGFR_I2SDIV_SHIFT)) - 1)
+
+#define I2S_CGFR_ODD_SHIFT	24
+#define I2S_CGFR_ODD		BIT(I2S_CGFR_ODD_SHIFT)
+#define I2S_CGFR_MCKOE		BIT(25)
+
+enum i2s_master_mode {
+	I2S_MS_NOT_SET,
+	I2S_MS_MASTER,
+	I2S_MS_SLAVE,
+};
+
+enum i2s_mode {
+	I2S_I2SMOD_TX_SLAVE,
+	I2S_I2SMOD_RX_SLAVE,
+	I2S_I2SMOD_TX_MASTER,
+	I2S_I2SMOD_RX_MASTER,
+	I2S_I2SMOD_FD_SLAVE,
+	I2S_I2SMOD_FD_MASTER,
+};
+
+enum i2s_fifo_th {
+	I2S_FIFO_TH_NONE,
+	I2S_FIFO_TH_ONE_QUARTER,
+	I2S_FIFO_TH_HALF,
+	I2S_FIFO_TH_THREE_QUARTER,
+	I2S_FIFO_TH_FULL,
+};
+
+enum i2s_std {
+	I2S_STD_I2S,
+	I2S_STD_LEFT_J,
+	I2S_STD_RIGHT_J,
+	I2S_STD_DSP,
+};
+
+enum i2s_datlen {
+	I2S_I2SMOD_DATLEN_16,
+	I2S_I2SMOD_DATLEN_24,
+	I2S_I2SMOD_DATLEN_32,
+};
+
+#define STM32_I2S_DAI_NAME_SIZE		20
+#define STM32_I2S_FIFO_SIZE		16
+
+#define STM32_I2S_IS_MASTER(x)		((x)->ms_flg == I2S_MS_MASTER)
+#define STM32_I2S_IS_SLAVE(x)		((x)->ms_flg == I2S_MS_SLAVE)
+
+/**
+ * @regmap_conf: I2S register map configuration pointer
+ * @egmap: I2S register map pointer
+ * @pdev: device data pointer
+ * @dai_drv: DAI driver pointer
+ * @dma_data_tx: dma configuration data for tx channel
+ * @dma_data_rx: dma configuration data for tx channel
+ * @substream: PCM substream data pointer
+ * @i2sclk: kernel clock feeding the I2S clock generator
+ * @pclk: peripheral clock driving bus interface
+ * @x8kclk: I2S parent clock for sampling frequencies multiple of 8kHz
+ * @x11kclk: I2S parent clock for sampling frequencies multiple of 11kHz
+ * @base:  mmio register base virtual address
+ * @phys_addr: I2S registers physical base address
+ * @lock_fd: lock to manage race conditions in full duplex mode
+ * @dais_name: DAI name
+ * @mclk_rate: master clock frequency (Hz)
+ * @fmt: DAI protocol
+ * @refcount: keep count of opened streams on I2S
+ * @ms_flg: master mode flag.
+ */
+struct stm32_i2s_data {
+	const struct regmap_config *regmap_conf;
+	struct regmap *regmap;
+	struct platform_device *pdev;
+	struct snd_soc_dai_driver *dai_drv;
+	struct snd_dmaengine_dai_dma_data dma_data_tx;
+	struct snd_dmaengine_dai_dma_data dma_data_rx;
+	struct snd_pcm_substream *substream;
+	struct clk *i2sclk;
+	struct clk *pclk;
+	struct clk *x8kclk;
+	struct clk *x11kclk;
+	void __iomem *base;
+	dma_addr_t phys_addr;
+	spinlock_t lock_fd; /* Manage race conditions for full duplex */
+	char dais_name[STM32_I2S_DAI_NAME_SIZE];
+	unsigned int mclk_rate;
+	unsigned int fmt;
+	int refcount;
+	int ms_flg;
+};
+
+static irqreturn_t stm32_i2s_isr(int irq, void *devid)
+{
+	struct stm32_i2s_data *i2s = (struct stm32_i2s_data *)devid;
+	struct platform_device *pdev = i2s->pdev;
+	u32 sr, ier;
+	unsigned long flags;
+	int err = 0;
+
+	regmap_read(i2s->regmap, STM32_I2S_SR_REG, &sr);
+	regmap_read(i2s->regmap, STM32_I2S_IER_REG, &ier);
+
+	flags = sr & ier;
+	if (!flags) {
+		dev_dbg(&pdev->dev, "Spurious IRQ sr=0x%08x, ier=0x%08x\n",
+			sr, ier);
+		return IRQ_NONE;
+	}
+
+	regmap_update_bits(i2s->regmap, STM32_I2S_IFCR_REG,
+			   I2S_IFCR_MASK, flags);
+
+	if (flags & I2S_SR_OVR) {
+		dev_dbg(&pdev->dev, "Overrun\n");
+		err = 1;
+	}
+
+	if (flags & I2S_SR_UDR) {
+		dev_dbg(&pdev->dev, "Underrun\n");
+		err = 1;
+	}
+
+	if (flags & I2S_SR_TIFRE)
+		dev_dbg(&pdev->dev, "Frame error\n");
+
+	if (err)
+		snd_pcm_stop_xrun(i2s->substream);
+
+	return IRQ_HANDLED;
+}
+
+static bool stm32_i2s_readable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case STM32_I2S_CR1_REG:
+	case STM32_I2S_CFG1_REG:
+	case STM32_I2S_CFG2_REG:
+	case STM32_I2S_IER_REG:
+	case STM32_I2S_SR_REG:
+	case STM32_I2S_IFCR_REG:
+	case STM32_I2S_TXDR_REG:
+	case STM32_I2S_RXDR_REG:
+	case STM32_I2S_CGFR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_i2s_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case STM32_I2S_TXDR_REG:
+	case STM32_I2S_RXDR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_i2s_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case STM32_I2S_CR1_REG:
+	case STM32_I2S_CFG1_REG:
+	case STM32_I2S_CFG2_REG:
+	case STM32_I2S_IER_REG:
+	case STM32_I2S_IFCR_REG:
+	case STM32_I2S_TXDR_REG:
+	case STM32_I2S_CGFR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int stm32_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 cgfr;
+	u32 cgfr_mask =  I2S_CGFR_I2SSTD_MASK | I2S_CGFR_CKPOL |
+			 I2S_CGFR_WSINV | I2S_CGFR_I2SCFG_MASK;
+
+	dev_dbg(cpu_dai->dev, "fmt %x\n", fmt);
+
+	/*
+	 * winv = 0 : default behavior (high/low) for all standards
+	 * ckpol = 0 for all standards.
+	 */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		cgfr = I2S_CGFR_I2SSTD_SET(I2S_STD_I2S);
+		break;
+	case SND_SOC_DAIFMT_MSB:
+		cgfr = I2S_CGFR_I2SSTD_SET(I2S_STD_LEFT_J);
+		break;
+	case SND_SOC_DAIFMT_LSB:
+		cgfr = I2S_CGFR_I2SSTD_SET(I2S_STD_RIGHT_J);
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		cgfr = I2S_CGFR_I2SSTD_SET(I2S_STD_DSP);
+		break;
+	/* DSP_B not mapped on I2S PCM long format. 1 bit offset does not fit */
+	default:
+		dev_err(cpu_dai->dev, "Unsupported protocol %#x\n",
+			fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+		return -EINVAL;
+	}
+
+	/* DAI clock strobing */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		cgfr |= I2S_CGFR_CKPOL;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		cgfr |= I2S_CGFR_WSINV;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		cgfr |= I2S_CGFR_CKPOL;
+		cgfr |= I2S_CGFR_WSINV;
+		break;
+	default:
+		dev_err(cpu_dai->dev, "Unsupported strobing %#x\n",
+			fmt & SND_SOC_DAIFMT_INV_MASK);
+		return -EINVAL;
+	}
+
+	/* DAI clock master masks */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		i2s->ms_flg = I2S_MS_SLAVE;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		i2s->ms_flg = I2S_MS_MASTER;
+		break;
+	default:
+		dev_err(cpu_dai->dev, "Unsupported mode %#x\n",
+			fmt & SND_SOC_DAIFMT_MASTER_MASK);
+		return -EINVAL;
+	}
+
+	i2s->fmt = fmt;
+	return regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
+				  cgfr_mask, cgfr);
+}
+
+static int stm32_i2s_set_sysclk(struct snd_soc_dai *cpu_dai,
+				int clk_id, unsigned int freq, int dir)
+{
+	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+
+	dev_dbg(cpu_dai->dev, "I2S MCLK frequency is %uHz\n", freq);
+
+	if ((dir == SND_SOC_CLOCK_OUT) && STM32_I2S_IS_MASTER(i2s)) {
+		i2s->mclk_rate = freq;
+
+		/* Enable master clock if master mode and mclk-fs are set */
+		return regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
+					  I2S_CGFR_MCKOE, I2S_CGFR_MCKOE);
+	}
+
+	return 0;
+}
+
+static int stm32_i2s_configure_clock(struct snd_soc_dai *cpu_dai,
+				     struct snd_pcm_hw_params *params)
+{
+	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long i2s_clock_rate;
+	unsigned int tmp, div, real_div, nb_bits, frame_len;
+	unsigned int rate = params_rate(params);
+	int ret;
+	u32 cgfr, cgfr_mask;
+	bool odd;
+
+	if (!(rate % 11025))
+		clk_set_parent(i2s->i2sclk, i2s->x11kclk);
+	else
+		clk_set_parent(i2s->i2sclk, i2s->x8kclk);
+	i2s_clock_rate = clk_get_rate(i2s->i2sclk);
+
+	/*
+	 * mckl = mclk_ratio x ws
+	 *   i2s mode : mclk_ratio = 256
+	 *   dsp mode : mclk_ratio = 128
+	 *
+	 * mclk on
+	 *   i2s mode : div = i2s_clk / (mclk_ratio * ws)
+	 *   dsp mode : div = i2s_clk / (mclk_ratio * ws)
+	 * mclk off
+	 *   i2s mode : div = i2s_clk / (nb_bits x ws)
+	 *   dsp mode : div = i2s_clk / (nb_bits x ws)
+	 */
+	if (i2s->mclk_rate) {
+		tmp = DIV_ROUND_CLOSEST(i2s_clock_rate, i2s->mclk_rate);
+	} else {
+		frame_len = 32;
+		if ((i2s->fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==
+		    SND_SOC_DAIFMT_DSP_A)
+			frame_len = 16;
+
+		/* master clock not enabled */
+		ret = regmap_read(i2s->regmap, STM32_I2S_CGFR_REG, &cgfr);
+		if (ret < 0)
+			return ret;
+
+		nb_bits = frame_len * ((cgfr & I2S_CGFR_CHLEN) + 1);
+		tmp = DIV_ROUND_CLOSEST(i2s_clock_rate, (nb_bits * rate));
+	}
+
+	/* Check the parity of the divider */
+	odd = tmp & 0x1;
+
+	/* Compute the div prescaler */
+	div = tmp >> 1;
+
+	cgfr = I2S_CGFR_I2SDIV_SET(div) | (odd << I2S_CGFR_ODD_SHIFT);
+	cgfr_mask = I2S_CGFR_I2SDIV_MASK | I2S_CGFR_ODD;
+
+	real_div = ((2 * div) + odd);
+	dev_dbg(cpu_dai->dev, "I2S clk: %ld, SCLK: %d\n",
+		i2s_clock_rate, rate);
+	dev_dbg(cpu_dai->dev, "Divider: 2*%d(div)+%d(odd) = %d\n",
+		div, odd, real_div);
+
+	if (((div == 1) && odd) || (div > I2S_CGFR_I2SDIV_MAX)) {
+		dev_err(cpu_dai->dev, "Wrong divider setting\n");
+		return -EINVAL;
+	}
+
+	if (!div && !odd)
+		dev_warn(cpu_dai->dev, "real divider forced to 1\n");
+
+	ret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
+				 cgfr_mask, cgfr);
+	if (ret < 0)
+		return ret;
+
+	/* Set bitclock and frameclock to their inactive state */
+	return regmap_update_bits(i2s->regmap, STM32_I2S_CFG2_REG,
+				  I2S_CFG2_AFCNTR, I2S_CFG2_AFCNTR);
+}
+
+static int stm32_i2s_configure(struct snd_soc_dai *cpu_dai,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_pcm_substream *substream)
+{
+	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+	int format = params_width(params);
+	u32 cfgr, cfgr_mask, cfg1, cfg1_mask;
+	bool playback_flg = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+	unsigned int fthlv;
+	int ret;
+
+	if ((params_channels(params) == 1) &&
+	    ((i2s->fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_DSP_A)) {
+		dev_err(cpu_dai->dev, "Mono mode supported only by DSP_A\n");
+		return -EINVAL;
+	}
+
+	switch (format) {
+	case 16:
+		cfgr = I2S_CGFR_DATLEN_SET(I2S_I2SMOD_DATLEN_16);
+		cfgr_mask = I2S_CGFR_DATLEN_MASK;
+		break;
+	case 32:
+		cfgr = I2S_CGFR_DATLEN_SET(I2S_I2SMOD_DATLEN_32) |
+					   I2S_CGFR_CHLEN;
+		cfgr_mask = I2S_CGFR_DATLEN_MASK | I2S_CGFR_CHLEN;
+		break;
+	default:
+		dev_err(cpu_dai->dev, "Unexpected format %d", format);
+		return -EINVAL;
+	}
+
+	if (STM32_I2S_IS_SLAVE(i2s)) {
+		if (playback_flg)
+			cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_TX_SLAVE);
+		else
+			cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_RX_SLAVE);
+
+		/* As data length is either 16 or 32 bits, fixch always set */
+		cfgr |= I2S_CGFR_FIXCH;
+		cfgr_mask |= I2S_CGFR_FIXCH;
+	} else {
+		if (playback_flg)
+			cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_TX_MASTER);
+		else
+			cfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_RX_MASTER);
+	}
+	cfgr_mask |= I2S_CGFR_I2SCFG_MASK;
+
+	ret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
+				 cfgr_mask, cfgr);
+	if (ret < 0)
+		return ret;
+
+	cfg1 = I2S_CFG1_RXDMAEN;
+	if (playback_flg)
+		cfg1 = I2S_CFG1_TXDMAEN;
+	cfg1_mask = cfg1;
+
+	fthlv = STM32_I2S_FIFO_SIZE * I2S_FIFO_TH_ONE_QUARTER / 4;
+	cfg1 |= I2S_CFG1_FTHVL_SET(fthlv - 1);
+	cfg1_mask |= I2S_CFG1_FTHVL_MASK;
+
+	return regmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,
+				  cfg1_mask, cfg1);
+}
+
+static int stm32_i2s_startup(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret, ier;
+
+	i2s->substream = substream;
+
+	spin_lock(&i2s->lock_fd);
+	if (i2s->refcount) {
+		dev_err(cpu_dai->dev, "%s stream already started\n",
+			(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+			"Capture" : "Playback"));
+		spin_unlock(&i2s->lock_fd);
+		return -EBUSY;
+	}
+	i2s->refcount = 1;
+	spin_unlock(&i2s->lock_fd);
+
+	ret = regmap_update_bits(i2s->regmap, STM32_I2S_IFCR_REG,
+				 I2S_IFCR_MASK, I2S_IFCR_MASK);
+	if (ret < 0)
+		return ret;
+
+	/* Enable ITs */
+	ier = I2S_IER_OVRIE | I2S_IER_UDRIE;
+	if (STM32_I2S_IS_SLAVE(i2s))
+		ier |= I2S_IER_TIFREIE;
+
+	return regmap_update_bits(i2s->regmap, STM32_I2S_IER_REG, ier, ier);
+}
+
+static int stm32_i2s_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
+
+	ret = stm32_i2s_configure(cpu_dai, params, substream);
+	if (ret < 0) {
+		dev_err(cpu_dai->dev, "Configuration returned error %d\n", ret);
+		return ret;
+	}
+
+	if (STM32_I2S_IS_MASTER(i2s))
+		ret = stm32_i2s_configure_clock(cpu_dai, params);
+
+	return ret;
+}
+
+static int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+			     struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+	bool playback_flg = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+	u32 cfg1_mask;
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/* Enable i2s */
+		dev_dbg(cpu_dai->dev, "start I2S\n");
+
+		ret = regmap_update_bits(i2s->regmap, STM32_I2S_CR1_REG,
+					 I2S_CR1_SPE, I2S_CR1_SPE);
+		if (ret < 0) {
+			dev_err(cpu_dai->dev, "Error %d enabling I2S\n", ret);
+			return ret;
+		}
+
+		ret = regmap_update_bits(i2s->regmap, STM32_I2S_CR1_REG,
+					 I2S_CR1_CSTART, I2S_CR1_CSTART);
+		if (ret < 0) {
+			dev_err(cpu_dai->dev, "Error %d starting I2S\n", ret);
+			return ret;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev_dbg(cpu_dai->dev, "stop I2S\n");
+
+		ret = regmap_update_bits(i2s->regmap, STM32_I2S_CR1_REG,
+					 I2S_CR1_SPE, 0);
+		if (ret < 0) {
+			dev_err(cpu_dai->dev, "Error %d disabling I2S\n", ret);
+			return ret;
+		}
+
+		cfg1_mask = I2S_CFG1_RXDMAEN;
+		if (playback_flg)
+			cfg1_mask = I2S_CFG1_TXDMAEN;
+
+		regmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,
+				   cfg1_mask, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void stm32_i2s_shutdown(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+
+	i2s->substream = NULL;
+
+	spin_lock(&i2s->lock_fd);
+	i2s->refcount = 0;
+	spin_unlock(&i2s->lock_fd);
+
+	regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
+			   I2S_CGFR_MCKOE, (unsigned int)~I2S_CGFR_MCKOE);
+}
+
+static int stm32_i2s_dai_probe(struct snd_soc_dai *cpu_dai)
+{
+	struct stm32_i2s_data *i2s = dev_get_drvdata(cpu_dai->dev);
+	struct snd_dmaengine_dai_dma_data *dma_data_tx = &i2s->dma_data_tx;
+	struct snd_dmaengine_dai_dma_data *dma_data_rx = &i2s->dma_data_rx;
+
+	/* Buswidth will be set by framework */
+	dma_data_tx->addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
+	dma_data_tx->addr = (dma_addr_t)(i2s->phys_addr) + STM32_I2S_TXDR_REG;
+	dma_data_tx->maxburst = 1;
+	dma_data_rx->addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
+	dma_data_rx->addr = (dma_addr_t)(i2s->phys_addr) + STM32_I2S_RXDR_REG;
+	dma_data_rx->maxburst = 1;
+
+	snd_soc_dai_init_dma_data(cpu_dai, dma_data_tx, dma_data_rx);
+
+	return 0;
+}
+
+static const struct regmap_config stm32_h7_i2s_regmap_conf = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = STM32_I2S_CGFR_REG,
+	.readable_reg = stm32_i2s_readable_reg,
+	.volatile_reg = stm32_i2s_volatile_reg,
+	.writeable_reg = stm32_i2s_writeable_reg,
+	.fast_io = true,
+};
+
+static const struct snd_soc_dai_ops stm32_i2s_pcm_dai_ops = {
+	.set_sysclk	= stm32_i2s_set_sysclk,
+	.set_fmt	= stm32_i2s_set_dai_fmt,
+	.startup	= stm32_i2s_startup,
+	.hw_params	= stm32_i2s_hw_params,
+	.trigger	= stm32_i2s_trigger,
+	.shutdown	= stm32_i2s_shutdown,
+};
+
+static const struct snd_pcm_hardware stm32_i2s_pcm_hw = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_MMAP,
+	.buffer_bytes_max = 8 * PAGE_SIZE,
+	.period_bytes_max = 2048,
+	.periods_min = 2,
+	.periods_max = 8,
+};
+
+static const struct snd_dmaengine_pcm_config stm32_i2s_pcm_config = {
+	.pcm_hardware	= &stm32_i2s_pcm_hw,
+	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+	.prealloc_buffer_size = PAGE_SIZE * 8,
+};
+
+static const struct snd_soc_component_driver stm32_i2s_component = {
+	.name = "stm32-i2s",
+};
+
+static void stm32_i2s_dai_init(struct snd_soc_pcm_stream *stream,
+			       char *stream_name)
+{
+	stream->stream_name = stream_name;
+	stream->channels_min = 1;
+	stream->channels_max = 2;
+	stream->rates = SNDRV_PCM_RATE_8000_192000;
+	stream->formats = SNDRV_PCM_FMTBIT_S16_LE |
+				   SNDRV_PCM_FMTBIT_S32_LE;
+}
+
+static int stm32_i2s_dais_init(struct platform_device *pdev,
+			       struct stm32_i2s_data *i2s)
+{
+	struct snd_soc_dai_driver *dai_ptr;
+
+	dai_ptr = devm_kzalloc(&pdev->dev, sizeof(struct snd_soc_dai_driver),
+			       GFP_KERNEL);
+	if (!dai_ptr)
+		return -ENOMEM;
+
+	snprintf(i2s->dais_name, STM32_I2S_DAI_NAME_SIZE,
+		 "%s", dev_name(&pdev->dev));
+
+	dai_ptr->probe = stm32_i2s_dai_probe;
+	dai_ptr->ops = &stm32_i2s_pcm_dai_ops;
+	dai_ptr->name = i2s->dais_name;
+	dai_ptr->id = 1;
+	stm32_i2s_dai_init(&dai_ptr->playback, "playback");
+	stm32_i2s_dai_init(&dai_ptr->capture, "capture");
+	i2s->dai_drv = dai_ptr;
+
+	return 0;
+}
+
+static const struct of_device_id stm32_i2s_ids[] = {
+	{
+		.compatible = "st,stm32h7-i2s",
+		.data = &stm32_h7_i2s_regmap_conf
+	},
+	{},
+};
+
+static int stm32_i2s_parse_dt(struct platform_device *pdev,
+			      struct stm32_i2s_data *i2s)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id;
+	struct reset_control *rst;
+	struct resource *res;
+	int irq, ret;
+
+	if (!np)
+		return -ENODEV;
+
+	of_id = of_match_device(stm32_i2s_ids, &pdev->dev);
+	if (of_id)
+		i2s->regmap_conf = (const struct regmap_config *)of_id->data;
+	else
+		return -EINVAL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	i2s->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(i2s->base))
+		return PTR_ERR(i2s->base);
+
+	i2s->phys_addr = res->start;
+
+	/* Get clocks */
+	i2s->pclk = devm_clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(i2s->pclk)) {
+		dev_err(&pdev->dev, "Could not get pclk\n");
+		return PTR_ERR(i2s->pclk);
+	}
+
+	i2s->i2sclk = devm_clk_get(&pdev->dev, "i2sclk");
+	if (IS_ERR(i2s->i2sclk)) {
+		dev_err(&pdev->dev, "Could not get i2sclk\n");
+		return PTR_ERR(i2s->i2sclk);
+	}
+
+	i2s->x8kclk = devm_clk_get(&pdev->dev, "x8k");
+	if (IS_ERR(i2s->x8kclk)) {
+		dev_err(&pdev->dev, "missing x8k parent clock\n");
+		return PTR_ERR(i2s->x8kclk);
+	}
+
+	i2s->x11kclk = devm_clk_get(&pdev->dev, "x11k");
+	if (IS_ERR(i2s->x11kclk)) {
+		dev_err(&pdev->dev, "missing x11k parent clock\n");
+		return PTR_ERR(i2s->x11kclk);
+	}
+
+	/* Get irqs */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "no irq for node %s\n", pdev->name);
+		return -ENOENT;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, stm32_i2s_isr, IRQF_ONESHOT,
+			       dev_name(&pdev->dev), i2s);
+	if (ret) {
+		dev_err(&pdev->dev, "irq request returned %d\n", ret);
+		return ret;
+	}
+
+	/* Reset */
+	rst = devm_reset_control_get(&pdev->dev, NULL);
+	if (!IS_ERR(rst)) {
+		reset_control_assert(rst);
+		udelay(2);
+		reset_control_deassert(rst);
+	}
+
+	return 0;
+}
+
+static int stm32_i2s_probe(struct platform_device *pdev)
+{
+	struct stm32_i2s_data *i2s;
+	int ret;
+
+	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
+	if (!i2s)
+		return -ENOMEM;
+
+	ret = stm32_i2s_parse_dt(pdev, i2s);
+	if (ret)
+		return ret;
+
+	i2s->pdev = pdev;
+	i2s->ms_flg = I2S_MS_NOT_SET;
+	spin_lock_init(&i2s->lock_fd);
+	platform_set_drvdata(pdev, i2s);
+
+	ret = stm32_i2s_dais_init(pdev, i2s);
+	if (ret)
+		return ret;
+
+	i2s->regmap = devm_regmap_init_mmio(&pdev->dev, i2s->base,
+					    i2s->regmap_conf);
+	if (IS_ERR(i2s->regmap)) {
+		dev_err(&pdev->dev, "regmap init failed\n");
+		return PTR_ERR(i2s->regmap);
+	}
+
+	ret = clk_prepare_enable(i2s->pclk);
+	if (ret) {
+		dev_err(&pdev->dev, "Enable pclk failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(i2s->i2sclk);
+	if (ret) {
+		dev_err(&pdev->dev, "Enable i2sclk failed: %d\n", ret);
+		goto err_pclk_disable;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &stm32_i2s_component,
+					      i2s->dai_drv, 1);
+	if (ret)
+		goto err_clocks_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
+					      &stm32_i2s_pcm_config, 0);
+	if (ret)
+		goto err_clocks_disable;
+
+	/* Set SPI/I2S in i2s mode */
+	ret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,
+				 I2S_CGFR_I2SMOD, I2S_CGFR_I2SMOD);
+	if (ret)
+		goto err_clocks_disable;
+
+	return ret;
+
+err_clocks_disable:
+	clk_disable_unprepare(i2s->i2sclk);
+err_pclk_disable:
+	clk_disable_unprepare(i2s->pclk);
+
+	return ret;
+}
+
+static int stm32_i2s_remove(struct platform_device *pdev)
+{
+	struct stm32_i2s_data *i2s = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(i2s->i2sclk);
+	clk_disable_unprepare(i2s->pclk);
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(of, stm32_i2s_ids);
+
+static struct platform_driver stm32_i2s_driver = {
+	.driver = {
+		.name = "st,stm32-i2s",
+		.of_match_table = stm32_i2s_ids,
+	},
+	.probe = stm32_i2s_probe,
+	.remove = stm32_i2s_remove,
+};
+
+module_platform_driver(stm32_i2s_driver);
+
+MODULE_DESCRIPTION("STM32 Soc i2s Interface");
+MODULE_AUTHOR("Olivier Moysan, <olivier.moysan@st.com>");
+MODULE_ALIAS("platform:stm32-i2s");
+MODULE_LICENSE("GPL v2");
