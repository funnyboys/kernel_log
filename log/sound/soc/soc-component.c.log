commit f1861a7c58ba1ba43c7adff6909d9a920338e4a8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 28 10:48:35 2020 +0900

    ASoC: soc-component: tidyup snd_soc_pcm_component_sync_stop()
    
    commit 1e5ddb6ba73894 ("ASoC: component: Add sync_stop PCM ops")
    added snd_soc_pcm_component_sync_stop(), but it is checking
    ioctrl instead of sync_stop. This is bug.
    This patch fixup it.
    
    Fixes: commit 1e5ddb6ba73894 ("ASoC: component: Add sync_stop PCM ops")
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/8736av7a8c.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 14e175cdeeb8..785a0385cc7f 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -451,7 +451,7 @@ int snd_soc_pcm_component_sync_stop(struct snd_pcm_substream *substream)
 	int i, ret;
 
 	for_each_rtd_components(rtd, i, component) {
-		if (component->driver->ioctl) {
+		if (component->driver->sync_stop) {
 			ret = component->driver->sync_stop(component,
 							   substream);
 			if (ret < 0)

commit 613fb50059cf19aa6acbc503a00265d9151c0b09
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 10 11:35:21 2020 +0900

    ASoC: soc-core: remove snd_soc_rtdcom_list
    
    Current ALSA SoC is using struct snd_soc_rtdcom_list to
    connecting component to rtd by using list_head.
    
            struct snd_soc_rtdcom_list {
                    struct snd_soc_component *component;
                    struct list_head list; /* rtd::component_list */
            };
    
            struct snd_soc_pcm_runtime {
                    ...
                    struct list_head component_list; /* list of connected components */
                    ...
            };
    
    The CPU/Codec/Platform component which will be connected to rtd (a)
    is indicated via dai_link at snd_soc_add_pcm_runtime()
    
            int snd_soc_add_pcm_runtime(...)
            {
                    ...
                    /* Find CPU from registered CPUs */
                    rtd->cpu_dai = snd_soc_find_dai(dai_link->cpus);
                    ...
    (a)             snd_soc_rtdcom_add(rtd, rtd->cpu_dai->component);
                    ...
    
                    /* Find CODEC from registered CODECs */
    (b)             for_each_link_codecs(dai_link, i, codec) {
                            rtd->codec_dais[i] = snd_soc_find_dai(codec);
                            ...
    (a)                     snd_soc_rtdcom_add(rtd, rtd->codec_dais[i]->component);
                    }
                    ...
    
                    /* Find PLATFORM from registered PLATFORMs */
    (b)             for_each_link_platforms(dai_link, i, platform) {
                            for_each_component(component) {
                                    ...
    (a)                             snd_soc_rtdcom_add(rtd, component);
                            }
                    }
    
            }
    
    It shows, it is possible to know how many components will be
    connected to rtd by using
    
            dai_link->num_cpus
            dai_link->num_codecs
            dai_link->num_platforms
    
    If so, we can use component pointer array instead of list_head,
    in such case, code can be more simple.
    This patch removes struct snd_soc_rtdcom_list that is only
    of temporary value, and convert to pointer array.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87a76wt4wm.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index b94680fb26fa..14e175cdeeb8 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -418,10 +418,10 @@ int snd_soc_pcm_component_pointer(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_component *component;
-	struct snd_soc_rtdcom_list *rtdcom;
+	int i;
 
 	/* FIXME: use 1st pointer */
-	for_each_rtd_components(rtd, rtdcom, component)
+	for_each_rtd_components(rtd, i, component)
 		if (component->driver->pointer)
 			return component->driver->pointer(component, substream);
 
@@ -433,10 +433,10 @@ int snd_soc_pcm_component_ioctl(struct snd_pcm_substream *substream,
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_component *component;
-	struct snd_soc_rtdcom_list *rtdcom;
+	int i;
 
 	/* FIXME: use 1st ioctl */
-	for_each_rtd_components(rtd, rtdcom, component)
+	for_each_rtd_components(rtd, i, component)
 		if (component->driver->ioctl)
 			return component->driver->ioctl(component, substream,
 							cmd, arg);
@@ -448,10 +448,9 @@ int snd_soc_pcm_component_sync_stop(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_component *component;
-	struct snd_soc_rtdcom_list *rtdcom;
-	int ret;
+	int i, ret;
 
-	for_each_rtd_components(rtd, rtdcom, component) {
+	for_each_rtd_components(rtd, i, component) {
 		if (component->driver->ioctl) {
 			ret = component->driver->sync_stop(component,
 							   substream);
@@ -468,11 +467,11 @@ int snd_soc_pcm_component_copy_user(struct snd_pcm_substream *substream,
 				    void __user *buf, unsigned long bytes)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
+	int i;
 
 	/* FIXME. it returns 1st copy now */
-	for_each_rtd_components(rtd, rtdcom, component)
+	for_each_rtd_components(rtd, i, component)
 		if (component->driver->copy_user)
 			return component->driver->copy_user(
 				component, substream, channel, pos, buf, bytes);
@@ -484,12 +483,12 @@ struct page *snd_soc_pcm_component_page(struct snd_pcm_substream *substream,
 					unsigned long offset)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
 	struct page *page;
+	int i;
 
 	/* FIXME. it returns 1st page now */
-	for_each_rtd_components(rtd, rtdcom, component) {
+	for_each_rtd_components(rtd, i, component) {
 		if (component->driver->page) {
 			page = component->driver->page(component,
 						       substream, offset);
@@ -505,11 +504,11 @@ int snd_soc_pcm_component_mmap(struct snd_pcm_substream *substream,
 			       struct vm_area_struct *vma)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
+	int i;
 
 	/* FIXME. it returns 1st mmap now */
-	for_each_rtd_components(rtd, rtdcom, component)
+	for_each_rtd_components(rtd, i, component)
 		if (component->driver->mmap)
 			return component->driver->mmap(component,
 						       substream, vma);
@@ -519,11 +518,11 @@ int snd_soc_pcm_component_mmap(struct snd_pcm_substream *substream,
 
 int snd_soc_pcm_component_new(struct snd_soc_pcm_runtime *rtd)
 {
-	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
 	int ret;
+	int i;
 
-	for_each_rtd_components(rtd, rtdcom, component) {
+	for_each_rtd_components(rtd, i, component) {
 		if (component->driver->pcm_construct) {
 			ret = component->driver->pcm_construct(component, rtd);
 			if (ret < 0)
@@ -536,13 +535,13 @@ int snd_soc_pcm_component_new(struct snd_soc_pcm_runtime *rtd)
 
 void snd_soc_pcm_component_free(struct snd_soc_pcm_runtime *rtd)
 {
-	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
+	int i;
 
 	if (!rtd->pcm)
 		return;
 
-	for_each_rtd_components(rtd, rtdcom, component)
+	for_each_rtd_components(rtd, i, component)
 		if (component->driver->pcm_destruct)
 			component->driver->pcm_destruct(component, rtd->pcm);
 }

commit 23534b197159dd07d3e02d4afd7fca3243d30bce
Merge: 320b8b0d13b8 a14bf98c045b
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 10 11:51:21 2020 +0000

    Merge branch 'for-5.5' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-5.6

commit 8e3366cad2bfe4e669bfd3758110be90b1dc75aa
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 7 08:09:56 2020 +0100

    ASoC: Fix NULL dereference at freeing
    
    When an ASoC driver with pcm_destruct component ops is freed before
    the PCM object instantiation (e.g. deferring the probe), it hits an
    Oops at snd_soc_pcm_component_free() that calls the pcm_destruct ops
    unconditionally.
    
    Fix it by adding a NULL-check of rtd->pcm before calling callbacks.
    
    Fixes: c64bfc906600 ("ASoC: soc-core: add new pcm_construct/pcm_destruct")
    Reported-by: Matthias Brugger <matthias.bgg@gmail.com>
    Tested-by: Ben Ho <ben.ho@mediatek.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20200107070956.15807-1-tiwai@suse.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 1590e805d016..6a8f26bf09ba 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -520,6 +520,9 @@ void snd_soc_pcm_component_free(struct snd_soc_pcm_runtime *rtd)
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
 
+	if (!rtd->pcm)
+		return;
+
 	for_each_rtd_components(rtd, rtdcom, component)
 		if (component->driver->pcm_destruct)
 			component->driver->pcm_destruct(component, rtd->pcm);

commit 09578eacaaa44149738267083ccc050990409f86
Merge: c6b6fc206586 8c4d2a0bfbd2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 25 14:27:33 2019 +0100

    Merge tag 'asoc-v5.5-2' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: More updates for v5.5
    
    Some more development work for v5.5.  Highlights include:
    
     - More cleanups from Morimoto-san.
     - Trigger word detection for RT5677.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 1e5ddb6ba73894e6186e6379dde870979852af6d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 21 20:07:09 2019 +0100

    ASoC: component: Add sync_stop PCM ops
    
    Add the support of the new PCM sync_stop ops in ASoC component.
    It's optional and can be NULL unless you need the sync operation.
    
    Acked-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20191121190709.29121-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 98ef0666add2..58c1320a3521 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -444,6 +444,25 @@ int snd_soc_pcm_component_ioctl(struct snd_pcm_substream *substream,
 	return snd_pcm_lib_ioctl(substream, cmd, arg);
 }
 
+int snd_soc_pcm_component_sync_stop(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component;
+	struct snd_soc_rtdcom_list *rtdcom;
+	int ret;
+
+	for_each_rtd_components(rtd, rtdcom, component) {
+		if (component->driver->ioctl) {
+			ret = component->driver->sync_stop(component,
+							   substream);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
 int snd_soc_pcm_component_copy_user(struct snd_pcm_substream *substream,
 				    int channel, unsigned long pos,
 				    void __user *buf, unsigned long bytes)

commit b2b2afbb48eac7215f951a8a462aa6837e0d495f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 18 10:50:32 2019 +0900

    ASoC: soc-component: tidyup snd_soc_pcm_component_new/free() parameter
    
    This patch uses rtd instead of pcm at snd_soc_pcm_component_new/free()
    parameter.
    This is prepare for dai_link remove bug fix on topology.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87pnhqx89j.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 98ef0666add2..1590e805d016 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -498,9 +498,8 @@ int snd_soc_pcm_component_mmap(struct snd_pcm_substream *substream,
 	return -EINVAL;
 }
 
-int snd_soc_pcm_component_new(struct snd_pcm *pcm)
+int snd_soc_pcm_component_new(struct snd_soc_pcm_runtime *rtd)
 {
-	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
 	int ret;
@@ -516,13 +515,12 @@ int snd_soc_pcm_component_new(struct snd_pcm *pcm)
 	return 0;
 }
 
-void snd_soc_pcm_component_free(struct snd_pcm *pcm)
+void snd_soc_pcm_component_free(struct snd_soc_pcm_runtime *rtd)
 {
-	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
 
 	for_each_rtd_components(rtd, rtdcom, component)
 		if (component->driver->pcm_destruct)
-			component->driver->pcm_destruct(component, pcm);
+			component->driver->pcm_destruct(component, rtd->pcm);
 }

commit 2b544dd7b43b19fb55ea4fbb3e30b60eb20b7828
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 15 12:59:31 2019 +0900

    ASoC: soc-core: add for_each_rtd_components() and replace
    
    ALSA SoC has for_each_rtdcom() which is link list for
    rtd-component which is called as rtdcom. The relationship image is like below
    
                                   rtdcom      rtdcom      rtdcom
                                   component   component   component
            rtd->component_list -> list     -> list     -> list ...
    
    Here, the pointer get via normal link list is rtdcom,
    Thus, current for_each loop is like below, and need to get
    component via rtdcom->component
    
            for_each_rtdcom(rtd, rtdcom) {
                    component = rtdcom->component;
                    ...
            }
    
    but usually, user want to get pointer from for_each_xxx is component
    directly, like below.
    
            for_each_rtd_component(rtd, rtdcom, component) {
                    ...
            }
    
    This patch expands list_for_each_entry manually, and enable to get
    component directly from for_each macro.
    Because of it, the macro becoming difficult to read,
    but macro itself becoming useful.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/878spm64m4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index debaf1f6f403..98ef0666add2 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -420,13 +420,10 @@ int snd_soc_pcm_component_pointer(struct snd_pcm_substream *substream)
 	struct snd_soc_component *component;
 	struct snd_soc_rtdcom_list *rtdcom;
 
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
-
-		/* FIXME: use 1st pointer */
+	/* FIXME: use 1st pointer */
+	for_each_rtd_components(rtd, rtdcom, component)
 		if (component->driver->pointer)
 			return component->driver->pointer(component, substream);
-	}
 
 	return 0;
 }
@@ -438,14 +435,11 @@ int snd_soc_pcm_component_ioctl(struct snd_pcm_substream *substream,
 	struct snd_soc_component *component;
 	struct snd_soc_rtdcom_list *rtdcom;
 
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
-
-		/* FIXME: use 1st ioctl */
+	/* FIXME: use 1st ioctl */
+	for_each_rtd_components(rtd, rtdcom, component)
 		if (component->driver->ioctl)
 			return component->driver->ioctl(component, substream,
 							cmd, arg);
-	}
 
 	return snd_pcm_lib_ioctl(substream, cmd, arg);
 }
@@ -458,14 +452,11 @@ int snd_soc_pcm_component_copy_user(struct snd_pcm_substream *substream,
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
 
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
-
-		/* FIXME. it returns 1st copy now */
+	/* FIXME. it returns 1st copy now */
+	for_each_rtd_components(rtd, rtdcom, component)
 		if (component->driver->copy_user)
 			return component->driver->copy_user(
 				component, substream, channel, pos, buf, bytes);
-	}
 
 	return -EINVAL;
 }
@@ -478,10 +469,8 @@ struct page *snd_soc_pcm_component_page(struct snd_pcm_substream *substream,
 	struct snd_soc_component *component;
 	struct page *page;
 
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
-
-		/* FIXME. it returns 1st page now */
+	/* FIXME. it returns 1st page now */
+	for_each_rtd_components(rtd, rtdcom, component) {
 		if (component->driver->page) {
 			page = component->driver->page(component,
 						       substream, offset);
@@ -500,14 +489,11 @@ int snd_soc_pcm_component_mmap(struct snd_pcm_substream *substream,
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
 
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
-
-		/* FIXME. it returns 1st mmap now */
+	/* FIXME. it returns 1st mmap now */
+	for_each_rtd_components(rtd, rtdcom, component)
 		if (component->driver->mmap)
 			return component->driver->mmap(component,
 						       substream, vma);
-	}
 
 	return -EINVAL;
 }
@@ -519,9 +505,7 @@ int snd_soc_pcm_component_new(struct snd_pcm *pcm)
 	struct snd_soc_component *component;
 	int ret;
 
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
-
+	for_each_rtd_components(rtd, rtdcom, component) {
 		if (component->driver->pcm_construct) {
 			ret = component->driver->pcm_construct(component, rtd);
 			if (ret < 0)
@@ -538,10 +522,7 @@ void snd_soc_pcm_component_free(struct snd_pcm *pcm)
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
 
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
-
+	for_each_rtd_components(rtd, rtdcom, component)
 		if (component->driver->pcm_destruct)
 			component->driver->pcm_destruct(component, pcm);
-	}
 }

commit e9067bb502787869dabe385727baff233024097b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:35:13 2019 +0900

    ASoC: soc-component: remove snd_pcm_ops from component driver
    
    No driver is using snd_pcm_ops on component driver.
    This patch removes it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/8736gb90by.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index d2b052ac88cd..debaf1f6f403 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -316,12 +316,6 @@ int snd_soc_component_open(struct snd_soc_component *component,
 {
 	if (component->driver->open)
 		return component->driver->open(component, substream);
-
-	/* remove me */
-	if (component->driver->ops &&
-	    component->driver->ops->open)
-		return component->driver->ops->open(substream);
-
 	return 0;
 }
 
@@ -330,12 +324,6 @@ int snd_soc_component_close(struct snd_soc_component *component,
 {
 	if (component->driver->close)
 		return component->driver->close(component, substream);
-
-	/* remove me */
-	if (component->driver->ops &&
-	    component->driver->ops->close)
-		return component->driver->ops->close(substream);
-
 	return 0;
 }
 
@@ -344,12 +332,6 @@ int snd_soc_component_prepare(struct snd_soc_component *component,
 {
 	if (component->driver->prepare)
 		return component->driver->prepare(component, substream);
-
-	/* remove me */
-	if (component->driver->ops &&
-	    component->driver->ops->prepare)
-		return component->driver->ops->prepare(substream);
-
 	return 0;
 }
 
@@ -360,12 +342,6 @@ int snd_soc_component_hw_params(struct snd_soc_component *component,
 	if (component->driver->hw_params)
 		return component->driver->hw_params(component,
 						    substream, params);
-
-	/* remove me */
-	if (component->driver->ops &&
-	    component->driver->ops->hw_params)
-		return component->driver->ops->hw_params(substream, params);
-
 	return 0;
 }
 
@@ -374,12 +350,6 @@ int snd_soc_component_hw_free(struct snd_soc_component *component,
 {
 	if (component->driver->hw_free)
 		return component->driver->hw_free(component, substream);
-
-	/* remove me */
-	if (component->driver->ops &&
-	    component->driver->ops->hw_free)
-		return component->driver->ops->hw_free(substream);
-
 	return 0;
 }
 
@@ -389,12 +359,6 @@ int snd_soc_component_trigger(struct snd_soc_component *component,
 {
 	if (component->driver->trigger)
 		return component->driver->trigger(component, substream, cmd);
-
-	/* remove me */
-	if (component->driver->ops &&
-	    component->driver->ops->trigger)
-		return component->driver->ops->trigger(substream, cmd);
-
 	return 0;
 }
 
@@ -462,11 +426,6 @@ int snd_soc_pcm_component_pointer(struct snd_pcm_substream *substream)
 		/* FIXME: use 1st pointer */
 		if (component->driver->pointer)
 			return component->driver->pointer(component, substream);
-
-		/* remove me */
-		if (component->driver->ops &&
-		    component->driver->ops->pointer)
-			return component->driver->ops->pointer(substream);
 	}
 
 	return 0;
@@ -486,12 +445,6 @@ int snd_soc_pcm_component_ioctl(struct snd_pcm_substream *substream,
 		if (component->driver->ioctl)
 			return component->driver->ioctl(component, substream,
 							cmd, arg);
-
-		/* remove me */
-		if (component->driver->ops &&
-		    component->driver->ops->ioctl)
-			return component->driver->ops->ioctl(substream,
-							     cmd, arg);
 	}
 
 	return snd_pcm_lib_ioctl(substream, cmd, arg);
@@ -512,12 +465,6 @@ int snd_soc_pcm_component_copy_user(struct snd_pcm_substream *substream,
 		if (component->driver->copy_user)
 			return component->driver->copy_user(
 				component, substream, channel, pos, buf, bytes);
-
-		/* remove me */
-		if (component->driver->ops &&
-		    component->driver->ops->copy_user)
-			return component->driver->ops->copy_user(
-				substream, channel, pos, buf, bytes);
 	}
 
 	return -EINVAL;
@@ -541,14 +488,6 @@ struct page *snd_soc_pcm_component_page(struct snd_pcm_substream *substream,
 			if (page)
 				return page;
 		}
-
-		/* remove me */
-		if (component->driver->ops &&
-		    component->driver->ops->page) {
-			page = component->driver->ops->page(substream, offset);
-			if (page)
-				return page;
-		}
 	}
 
 	return NULL;
@@ -568,11 +507,6 @@ int snd_soc_pcm_component_mmap(struct snd_pcm_substream *substream,
 		if (component->driver->mmap)
 			return component->driver->mmap(component,
 						       substream, vma);
-
-		/* remove me */
-		if (component->driver->ops &&
-		    component->driver->ops->mmap)
-			return component->driver->ops->mmap(substream, vma);
 	}
 
 	return -EINVAL;
@@ -593,13 +527,6 @@ int snd_soc_pcm_component_new(struct snd_pcm *pcm)
 			if (ret < 0)
 				return ret;
 		}
-
-		/* remove me */
-		if (component->driver->pcm_new) {
-			ret = component->driver->pcm_new(rtd);
-			if (ret < 0)
-				return ret;
-		}
 	}
 
 	return 0;
@@ -616,9 +543,5 @@ void snd_soc_pcm_component_free(struct snd_pcm *pcm)
 
 		if (component->driver->pcm_destruct)
 			component->driver->pcm_destruct(component, pcm);
-
-		/* remove me */
-		if (component->driver->pcm_free)
-			component->driver->pcm_free(pcm);
 	}
 }

commit c64bfc9066007962fca1b9b2d426b1efc171cac9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:30:59 2019 +0900

    ASoC: soc-core: add new pcm_construct/pcm_destruct
    
    Current snd_soc_component_driver has pcm_new/pcm_free, but,
    it doesn't have "component" at parameter.
    Thus, each callback can't know it is called for which component.
    Each callback currently is getting "component" by using
    snd_soc_rtdcom_lookup() with driver name.
    
    It works today, but, will not work in the future if we support multi
    CPU/Codec/Platform, because 1 rtd might have multiple same driver
    name component.
    
    To solve this issue, each callback need to be called with component.
    This patch adds new pcm_construct/pcm_destruct with "component"
    parameter.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87sgobaf3g.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 2d9cb763e63a..d2b052ac88cd 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -588,6 +588,13 @@ int snd_soc_pcm_component_new(struct snd_pcm *pcm)
 	for_each_rtdcom(rtd, rtdcom) {
 		component = rtdcom->component;
 
+		if (component->driver->pcm_construct) {
+			ret = component->driver->pcm_construct(component, rtd);
+			if (ret < 0)
+				return ret;
+		}
+
+		/* remove me */
 		if (component->driver->pcm_new) {
 			ret = component->driver->pcm_new(rtd);
 			if (ret < 0)
@@ -607,6 +614,10 @@ void snd_soc_pcm_component_free(struct snd_pcm *pcm)
 	for_each_rtdcom(rtd, rtdcom) {
 		component = rtdcom->component;
 
+		if (component->driver->pcm_destruct)
+			component->driver->pcm_destruct(component, pcm);
+
+		/* remove me */
 		if (component->driver->pcm_free)
 			component->driver->pcm_free(pcm);
 	}

commit e2cb4a14541dba3587bb78e0f62da27a0e1ad399
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:30:48 2019 +0900

    ASoC: soc-core: merge snd_pcm_ops member to component driver
    
    Current snd_soc_component_driver has snd_pcm_ops, and each driver can
    have callback via it (1).
    But, it is mainly created for ALSA, thus, it doesn't have "component"
    as parameter for ALSA SoC (1)(2).
    Thus, each callback can't know it is called for which component.
    Thus, each callback currently is getting "component" by using
    snd_soc_rtdcom_lookup() with driver name (3).
    
            --- ALSA SoC  ---
            ...
            if (component->driver->ops &&
                component->driver->ops->open)
    (1)             return component->driver->ops->open(substream);
            ...
    
            --- driver ---
    (2)     static int xxx_open(struct snd_pcm_substream *substream)
            {
                    struct snd_soc_pcm_runtime *rtd = substream->private_data;
    (3)             struct snd_soc_component *component = snd_soc_rtdcom_lookup(..);
                    ...
            }
    
    It works today, but, will not work in the future if we support multi
    CPU/Codec/Platform, because 1 rtd might have multiple components which
    have same driver name.
    
    To solve this issue, each callback needs to be called with component.
    We already have many component driver callback.
    This patch copies each snd_pcm_ops member under component driver,
    and having "component" as parameter.
    
            --- ALSA SoC  ---
            ...
            if (component->driver->open)
    =>              return component->driver->open(component, substream);
            ...
    
            --- driver ---
    =>      static int xxx_open(struct snd_soc_component *component,
                                struct snd_pcm_substream *substream)
            {
                    ...
            }
    
    *Note*
    
    Only Intel skl-pcm has .get_time_info implementation, but ALSA SoC
    framework doesn't call it so far.
    To keep its implementation, this patch keeps .get_time_info,
    but it is still not called.
    Intel guy need to support it in the future.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87tv8raf3r.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 79ffc2820ba9..2d9cb763e63a 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -314,6 +314,10 @@ void snd_soc_component_module_put(struct snd_soc_component *component,
 int snd_soc_component_open(struct snd_soc_component *component,
 			   struct snd_pcm_substream *substream)
 {
+	if (component->driver->open)
+		return component->driver->open(component, substream);
+
+	/* remove me */
 	if (component->driver->ops &&
 	    component->driver->ops->open)
 		return component->driver->ops->open(substream);
@@ -324,6 +328,10 @@ int snd_soc_component_open(struct snd_soc_component *component,
 int snd_soc_component_close(struct snd_soc_component *component,
 			    struct snd_pcm_substream *substream)
 {
+	if (component->driver->close)
+		return component->driver->close(component, substream);
+
+	/* remove me */
 	if (component->driver->ops &&
 	    component->driver->ops->close)
 		return component->driver->ops->close(substream);
@@ -334,6 +342,10 @@ int snd_soc_component_close(struct snd_soc_component *component,
 int snd_soc_component_prepare(struct snd_soc_component *component,
 			      struct snd_pcm_substream *substream)
 {
+	if (component->driver->prepare)
+		return component->driver->prepare(component, substream);
+
+	/* remove me */
 	if (component->driver->ops &&
 	    component->driver->ops->prepare)
 		return component->driver->ops->prepare(substream);
@@ -345,6 +357,11 @@ int snd_soc_component_hw_params(struct snd_soc_component *component,
 				struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params)
 {
+	if (component->driver->hw_params)
+		return component->driver->hw_params(component,
+						    substream, params);
+
+	/* remove me */
 	if (component->driver->ops &&
 	    component->driver->ops->hw_params)
 		return component->driver->ops->hw_params(substream, params);
@@ -355,6 +372,10 @@ int snd_soc_component_hw_params(struct snd_soc_component *component,
 int snd_soc_component_hw_free(struct snd_soc_component *component,
 			       struct snd_pcm_substream *substream)
 {
+	if (component->driver->hw_free)
+		return component->driver->hw_free(component, substream);
+
+	/* remove me */
 	if (component->driver->ops &&
 	    component->driver->ops->hw_free)
 		return component->driver->ops->hw_free(substream);
@@ -366,6 +387,10 @@ int snd_soc_component_trigger(struct snd_soc_component *component,
 			      struct snd_pcm_substream *substream,
 			      int cmd)
 {
+	if (component->driver->trigger)
+		return component->driver->trigger(component, substream, cmd);
+
+	/* remove me */
 	if (component->driver->ops &&
 	    component->driver->ops->trigger)
 		return component->driver->ops->trigger(substream, cmd);
@@ -435,6 +460,10 @@ int snd_soc_pcm_component_pointer(struct snd_pcm_substream *substream)
 		component = rtdcom->component;
 
 		/* FIXME: use 1st pointer */
+		if (component->driver->pointer)
+			return component->driver->pointer(component, substream);
+
+		/* remove me */
 		if (component->driver->ops &&
 		    component->driver->ops->pointer)
 			return component->driver->ops->pointer(substream);
@@ -454,6 +483,11 @@ int snd_soc_pcm_component_ioctl(struct snd_pcm_substream *substream,
 		component = rtdcom->component;
 
 		/* FIXME: use 1st ioctl */
+		if (component->driver->ioctl)
+			return component->driver->ioctl(component, substream,
+							cmd, arg);
+
+		/* remove me */
 		if (component->driver->ops &&
 		    component->driver->ops->ioctl)
 			return component->driver->ops->ioctl(substream,
@@ -475,6 +509,11 @@ int snd_soc_pcm_component_copy_user(struct snd_pcm_substream *substream,
 		component = rtdcom->component;
 
 		/* FIXME. it returns 1st copy now */
+		if (component->driver->copy_user)
+			return component->driver->copy_user(
+				component, substream, channel, pos, buf, bytes);
+
+		/* remove me */
 		if (component->driver->ops &&
 		    component->driver->ops->copy_user)
 			return component->driver->ops->copy_user(
@@ -496,6 +535,14 @@ struct page *snd_soc_pcm_component_page(struct snd_pcm_substream *substream,
 		component = rtdcom->component;
 
 		/* FIXME. it returns 1st page now */
+		if (component->driver->page) {
+			page = component->driver->page(component,
+						       substream, offset);
+			if (page)
+				return page;
+		}
+
+		/* remove me */
 		if (component->driver->ops &&
 		    component->driver->ops->page) {
 			page = component->driver->ops->page(substream, offset);
@@ -518,6 +565,11 @@ int snd_soc_pcm_component_mmap(struct snd_pcm_substream *substream,
 		component = rtdcom->component;
 
 		/* FIXME. it returns 1st mmap now */
+		if (component->driver->mmap)
+			return component->driver->mmap(component,
+						       substream, vma);
+
+		/* remove me */
 		if (component->driver->ops &&
 		    component->driver->ops->mmap)
 			return component->driver->ops->mmap(substream, vma);

commit 79776da0989733a5bac0a1e635e3a284c3f5c745
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:52:12 2019 +0900

    ASoC: soc-component: add snd_soc_pcm_component_pcm_free()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, the code nested deeply, and it makes code difficult to read,
    and is not good for encapsulation.
    
    We want to implement component related function at soc-component.c,
    but, some of them need to care whole snd_soc_pcm_runtime (= rtd)
    connected component.
    
    Let's call component related function which need to care with
    for_each_rtdcom() loop as snd_soc_pcm_component_xxx().
    This patch adds new snd_soc_pcm_component_pcm_free() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87k1c54czu.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index ff13d901bbab..79ffc2820ba9 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -545,3 +545,17 @@ int snd_soc_pcm_component_new(struct snd_pcm *pcm)
 
 	return 0;
 }
+
+void snd_soc_pcm_component_free(struct snd_pcm *pcm)
+{
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *component;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
+
+		if (component->driver->pcm_free)
+			component->driver->pcm_free(pcm);
+	}
+}

commit 7484291e9b7564af65b2581dcdebeeaf98bc86d0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:52:08 2019 +0900

    ASoC: soc-component: add snd_soc_pcm_component_pcm_new()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, the code nested deeply, and it makes code difficult to read,
    and is not good for encapsulation.
    
    We want to implement component related function at soc-component.c,
    but, some of them need to care whole snd_soc_pcm_runtime (= rtd)
    connected component.
    
    Let's call component related function which need to care with
    for_each_rtdcom() loop as snd_soc_pcm_component_xxx().
    This patch adds new snd_soc_pcm_component_pcm() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87lfwl4czy.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 2aff1b087522..ff13d901bbab 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -525,3 +525,23 @@ int snd_soc_pcm_component_mmap(struct snd_pcm_substream *substream,
 
 	return -EINVAL;
 }
+
+int snd_soc_pcm_component_new(struct snd_pcm *pcm)
+{
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *component;
+	int ret;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
+
+		if (component->driver->pcm_new) {
+			ret = component->driver->pcm_new(rtd);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}

commit 205875e1a12ef9c61e939db9ded90fe3f6352e75
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:52:04 2019 +0900

    ASoC: soc-component: add snd_soc_pcm_component_mmap()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, the code nested deeply, and it makes code difficult to read,
    and is not good for encapsulation.
    
    We want to implement component related function at soc-component.c,
    but, some of them need to care whole snd_soc_pcm_runtime (= rtd)
    connected component.
    
    Let's call component related function which need to care with
    for_each_rtdcom() loop as snd_soc_pcm_component_xxx().
    This patch adds new snd_soc_pcm_component_mmap() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87muh14d02.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index d503bc9b0850..2aff1b087522 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -506,3 +506,22 @@ struct page *snd_soc_pcm_component_page(struct snd_pcm_substream *substream,
 
 	return NULL;
 }
+
+int snd_soc_pcm_component_mmap(struct snd_pcm_substream *substream,
+			       struct vm_area_struct *vma)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *component;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
+
+		/* FIXME. it returns 1st mmap now */
+		if (component->driver->ops &&
+		    component->driver->ops->mmap)
+			return component->driver->ops->mmap(substream, vma);
+	}
+
+	return -EINVAL;
+}

commit 9c712e4f57229081e837d593fc1e4183b068a41c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:52:00 2019 +0900

    ASoC: soc-component: add snd_soc_pcm_component_page()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, the code nested deeply, and it makes code difficult to read,
    and is not good for encapsulation.
    
    We want to implement component related function at soc-component.c,
    but, some of them need to care whole snd_soc_pcm_runtime (= rtd)
    connected component.
    
    Let's call component related function which need to care with
    for_each_rtdcom() loop as snd_soc_pcm_component_xxx().
    This patch adds new snd_soc_pcm_component_page() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87o91h4d06.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 20897dce1bec..d503bc9b0850 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -483,3 +483,26 @@ int snd_soc_pcm_component_copy_user(struct snd_pcm_substream *substream,
 
 	return -EINVAL;
 }
+
+struct page *snd_soc_pcm_component_page(struct snd_pcm_substream *substream,
+					unsigned long offset)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *component;
+	struct page *page;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
+
+		/* FIXME. it returns 1st page now */
+		if (component->driver->ops &&
+		    component->driver->ops->page) {
+			page = component->driver->ops->page(substream, offset);
+			if (page)
+				return page;
+		}
+	}
+
+	return NULL;
+}

commit 82d81f5cced36e480b581ae51c595e2deb9f2d56
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:56 2019 +0900

    ASoC: soc-component: add snd_soc_pcm_component_copy_user()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, the code nested deeply, and it makes code difficult to read,
    and is not good for encapsulation.
    
    We want to implement component related function at soc-component.c,
    but, some of them need to care whole snd_soc_pcm_runtime (= rtd)
    connected component.
    
    Let's call component related function which need to care with
    for_each_rtdcom() loop as snd_soc_pcm_component_xxx().
    This patch adds new snd_soc_pcm_component_copy_user() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87pnlx4d0a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index a6c0857a9e90..20897dce1bec 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -462,3 +462,24 @@ int snd_soc_pcm_component_ioctl(struct snd_pcm_substream *substream,
 
 	return snd_pcm_lib_ioctl(substream, cmd, arg);
 }
+
+int snd_soc_pcm_component_copy_user(struct snd_pcm_substream *substream,
+				    int channel, unsigned long pos,
+				    void __user *buf, unsigned long bytes)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *component;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
+
+		/* FIXME. it returns 1st copy now */
+		if (component->driver->ops &&
+		    component->driver->ops->copy_user)
+			return component->driver->ops->copy_user(
+				substream, channel, pos, buf, bytes);
+	}
+
+	return -EINVAL;
+}

commit 96a47908d8769479f5217bf3f432ccdc06a29747
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:51 2019 +0900

    ASoC: soc-component: add snd_soc_pcm_component_ioctrl()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, the code nested deeply, and it makes code difficult to read,
    and is not good for encapsulation.
    
    We want to implement component related function at soc-component.c,
    but, some of them need to care whole snd_soc_pcm_runtime (= rtd)
    connected component.
    
    Let's call component related function which need to care with
    for_each_rtdcom() loop as snd_soc_pcm_component_xxx().
    This patch adds new snd_soc_pcm_component_ioctrl() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87r26d4d0f.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index e2053c8bf1f0..a6c0857a9e90 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -442,3 +442,23 @@ int snd_soc_pcm_component_pointer(struct snd_pcm_substream *substream)
 
 	return 0;
 }
+
+int snd_soc_pcm_component_ioctl(struct snd_pcm_substream *substream,
+				unsigned int cmd, void *arg)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component;
+	struct snd_soc_rtdcom_list *rtdcom;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
+
+		/* FIXME: use 1st ioctl */
+		if (component->driver->ops &&
+		    component->driver->ops->ioctl)
+			return component->driver->ops->ioctl(substream,
+							     cmd, arg);
+	}
+
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}

commit 0035e2565b93e0902a06320ba1716bc1ddd753b3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:47 2019 +0900

    ASoC: soc-component: add snd_soc_pcm_component_pointer()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, the code nested deeply, and it makes code difficult to read,
    and is not good for encapsulation.
    
    We want to implement component related function at soc-component.c,
    but, some of them need to care whole snd_soc_pcm_runtime (= rtd)
    connected component.
    
    Let's call component related function which need to care with
    for_each_rtdcom() loop as snd_soc_pcm_component_xxx().
    This patch adds new snd_soc_pcm_component_pointer() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87sgqt4d0j.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index cb63df6e46eb..e2053c8bf1f0 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -424,3 +424,21 @@ int snd_soc_component_of_xlate_dai_name(struct snd_soc_component *component,
 						     args, dai_name);
 	return -ENOTSUPP;
 }
+
+int snd_soc_pcm_component_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component;
+	struct snd_soc_rtdcom_list *rtdcom;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
+
+		/* FIXME: use 1st pointer */
+		if (component->driver->ops &&
+		    component->driver->ops->pointer)
+			return component->driver->ops->pointer(substream);
+	}
+
+	return 0;
+}

commit 7951b14611851bdae18e9bca18015b1d84731d0d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:43 2019 +0900

    ASoC: soc-component: move snd_soc_component_set_bias_level()
    
    Current soc-dapm / soc-core are using a long way round to call
    .set_bias_level.
    
            if (driver->set_bias_level)
                    dapm->set_bias_level = ...;
            ...
            if (dapm->set_bias_level)
                    ret = dapm->set_bias_level(...);
    
    We can directly call it via driver->set_bias_level.
    One note here is that both Card and Component have dapm,
    but, Card's dapm doesn't have dapm->component.
    We need to check it.
    
    This patch moves snd_soc_component_set_bias_level() to soc-component.c
    and updates parameters.
    dapm->set_bias_level is no longer needed
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87tvb94d0n.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index f33dda8023ec..cb63df6e46eb 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -68,6 +68,15 @@ int snd_soc_component_stream_event(struct snd_soc_component *component,
 	return 0;
 }
 
+int snd_soc_component_set_bias_level(struct snd_soc_component *component,
+				     enum snd_soc_bias_level level)
+{
+	if (component->driver->set_bias_level)
+		return component->driver->set_bias_level(component, level);
+
+	return 0;
+}
+
 int snd_soc_component_enable_pin(struct snd_soc_component *component,
 				 const char *pin)
 {

commit 8e2a990d76aced95c6f01c2d67d8835c86f0ca67
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:39 2019 +0900

    ASoC: soc-component: move snd_soc_component_stream_event()
    
    Current soc-dapm / soc-core are using a long way round to call
    .stream_event.
    
            if (driver->stream_event)
                    dapm->stream_event = ...;
            ...
            if (dapm->stream_event)
                    ret = dapm->stream_event(...);
    
    We can directly call it via driver->stream_event.
    One note here is that both Card and Component have dapm,
    but, Card's dapm doesn't have dapm->component.
    We need to check it.
    
    This patch moves snd_soc_component_stream_event() to soc-component.c
    and updates parameters.
    dapm->stream_event is no longer needed
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87v9vp4d0r.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index ca0b28b1d918..f33dda8023ec 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -59,6 +59,15 @@ void snd_soc_component_seq_notifier(struct snd_soc_component *component,
 		component->driver->seq_notifier(component, type, subseq);
 }
 
+int snd_soc_component_stream_event(struct snd_soc_component *component,
+				   int event)
+{
+	if (component->driver->stream_event)
+		return component->driver->stream_event(component, event);
+
+	return 0;
+}
+
 int snd_soc_component_enable_pin(struct snd_soc_component *component,
 				 const char *pin)
 {

commit 9d415fbf773f162a5c274e671741c6fa94b74287
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:35 2019 +0900

    ASoC: soc-component: move snd_soc_component_seq_notifier()
    
    Current soc-dapm / soc-core are using a long way round to call
    .seq_notifier.
    
            if (driver->seq_notifier)
                    dapm->seq_notifier = ...;
            ...
            if (dapm->seq_notifier)
                    ret = dapm->seq_notifier(...);
    
    We can directly call it via driver->seq_notifier.
    One note here is that both Card and Component have dapm,
    but, Card's dapm doesn't have dapm->component.
    We need to check it.
    
    This patch moves snd_soc_component_seq_notifier() to soc-component.c,
    and updates parameters.
    dapm->seq_notifier is no longer needed
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87wog54d0v.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index de1bc5196f67..ca0b28b1d918 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -52,6 +52,13 @@ int snd_soc_component_set_pll(struct snd_soc_component *component, int pll_id,
 }
 EXPORT_SYMBOL_GPL(snd_soc_component_set_pll);
 
+void snd_soc_component_seq_notifier(struct snd_soc_component *component,
+				    enum snd_soc_dapm_type type, int subseq)
+{
+	if (component->driver->seq_notifier)
+		component->driver->seq_notifier(component, type, subseq);
+}
+
 int snd_soc_component_enable_pin(struct snd_soc_component *component,
 				 const char *pin)
 {

commit a2a341752558cc67d6fe5c8ada7c16f9c3690f89
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:31 2019 +0900

    ASoC: soc-component: add snd_soc_component_of_xlate_dai_name()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_of_xlate_dai_name() and use it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87y30l4d0z.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index faf49992f661..de1bc5196f67 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -389,3 +389,13 @@ int snd_soc_component_of_xlate_dai_id(struct snd_soc_component *component,
 
 	return -ENOTSUPP;
 }
+
+int snd_soc_component_of_xlate_dai_name(struct snd_soc_component *component,
+					struct of_phandle_args *args,
+					const char **dai_name)
+{
+	if (component->driver->of_xlate_dai_name)
+		return component->driver->of_xlate_dai_name(component,
+						     args, dai_name);
+	return -ENOTSUPP;
+}

commit 2c7b1704819435d188c7697c6815f788bf9e6200
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:26 2019 +0900

    ASoC: soc-component: add snd_soc_component_of_xlate_dai_id()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_of_xlate_dai_id() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87zhl14d14.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index eba77ea2b62d..faf49992f661 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -380,3 +380,12 @@ void snd_soc_component_remove(struct snd_soc_component *component)
 	if (component->driver->remove)
 		component->driver->remove(component);
 }
+
+int snd_soc_component_of_xlate_dai_id(struct snd_soc_component *component,
+				      struct device_node *ep)
+{
+	if (component->driver->of_xlate_dai_id)
+		return component->driver->of_xlate_dai_id(component, ep);
+
+	return -ENOTSUPP;
+}

commit 03b34dd7d87ce3493cb1837c9e59c3b3aac4724f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:22 2019 +0900

    ASoC: soc-component: add snd_soc_component_remove()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_remove() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/871ryd5rlo.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index b2bfc0375193..eba77ea2b62d 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -374,3 +374,9 @@ int snd_soc_component_probe(struct snd_soc_component *component)
 
 	return 0;
 }
+
+void snd_soc_component_remove(struct snd_soc_component *component)
+{
+	if (component->driver->remove)
+		component->driver->remove(component);
+}

commit 08e837dd9e39bd3e25b1fa1a13f6ba44040e3f0d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:17 2019 +0900

    ASoC: soc-component: add snd_soc_component_probe()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_probe() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/8736it5rlt.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 0a9ca84d7ac6..b2bfc0375193 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -366,3 +366,11 @@ int snd_soc_component_is_suspended(struct snd_soc_component *component)
 {
 	return component->suspended;
 }
+
+int snd_soc_component_probe(struct snd_soc_component *component)
+{
+	if (component->driver->probe)
+		return component->driver->probe(component);
+
+	return 0;
+}

commit e40fadbcef583808c11d2e86b8ac1c652731468e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:13 2019 +0900

    ASoC: soc-component: add snd_soc_component_is_suspended()
    
    Current ALSA SoC is directly using component->xxx,
    But, it is not good for encapsulation.
    This patch adds new snd_soc_component_is_suspended() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/874l395rlx.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index cbae7672b72d..0a9ca84d7ac6 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -361,3 +361,8 @@ void snd_soc_component_resume(struct snd_soc_component *component)
 		component->driver->resume(component);
 	component->suspended = 0;
 }
+
+int snd_soc_component_is_suspended(struct snd_soc_component *component)
+{
+	return component->suspended;
+}

commit 9a840cbac77a90e8406296aaa132ebf2c84ed9e3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:08 2019 +0900

    ASoC: soc-component: add snd_soc_component_resume()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_resume() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/875znp5rm2.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index f0e63cd991c8..cbae7672b72d 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -354,3 +354,10 @@ void snd_soc_component_suspend(struct snd_soc_component *component)
 		component->driver->suspend(component);
 	component->suspended = 1;
 }
+
+void snd_soc_component_resume(struct snd_soc_component *component)
+{
+	if (component->driver->resume)
+		component->driver->resume(component);
+	component->suspended = 0;
+}

commit 66c51573b89d0a5c1089139a2f0dd029a755c37d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:50:34 2019 +0900

    ASoC: soc-component: add snd_soc_component_suspend()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_suspend() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/877e855rn0.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index cf0d20a877e6..f0e63cd991c8 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -347,3 +347,10 @@ int snd_soc_component_trigger(struct snd_soc_component *component,
 
 	return 0;
 }
+
+void snd_soc_component_suspend(struct snd_soc_component *component)
+{
+	if (component->driver->suspend)
+		component->driver->suspend(component);
+	component->suspended = 1;
+}

commit 5693d50c830272cb3c4a04d2ce4db502debd1259
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:50:29 2019 +0900

    ASoC: soc-component: add snd_soc_component_trigger()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_trigger() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/878ssl5rn5.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index e2bc34efe547..cf0d20a877e6 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -336,3 +336,14 @@ int snd_soc_component_hw_free(struct snd_soc_component *component,
 
 	return 0;
 }
+
+int snd_soc_component_trigger(struct snd_soc_component *component,
+			      struct snd_pcm_substream *substream,
+			      int cmd)
+{
+	if (component->driver->ops &&
+	    component->driver->ops->trigger)
+		return component->driver->ops->trigger(substream, cmd);
+
+	return 0;
+}

commit eae7136aa2083699c69de5890fd6c32c501952b5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:50:24 2019 +0900

    ASoC: soc-component: add snd_soc_component_hw_free()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_hw_free() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87a7d15rna.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 7b6456370da5..e2bc34efe547 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -326,3 +326,13 @@ int snd_soc_component_hw_params(struct snd_soc_component *component,
 
 	return 0;
 }
+
+int snd_soc_component_hw_free(struct snd_soc_component *component,
+			       struct snd_pcm_substream *substream)
+{
+	if (component->driver->ops &&
+	    component->driver->ops->hw_free)
+		return component->driver->ops->hw_free(substream);
+
+	return 0;
+}

commit 245c539a1206d74e8508a07550fb7c99d0817b8c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:50:19 2019 +0900

    ASoC: soc-component: add snd_soc_component_hw_params()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_hw_params() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87blxh5rnf.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index 733d7139d875..7b6456370da5 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -315,3 +315,14 @@ int snd_soc_component_prepare(struct snd_soc_component *component,
 
 	return 0;
 }
+
+int snd_soc_component_hw_params(struct snd_soc_component *component,
+				struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	if (component->driver->ops &&
+	    component->driver->ops->hw_params)
+		return component->driver->ops->hw_params(substream, params);
+
+	return 0;
+}

commit 6d53723380ed73a2ced648d6e92774b39e5af1bd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:50:13 2019 +0900

    ASoC: soc-component: add snd_soc_component_prepare()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_prepare() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87d0hx5rnm.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index cee66183470d..733d7139d875 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -305,3 +305,13 @@ int snd_soc_component_close(struct snd_soc_component *component,
 
 	return 0;
 }
+
+int snd_soc_component_prepare(struct snd_soc_component *component,
+			      struct snd_pcm_substream *substream)
+{
+	if (component->driver->ops &&
+	    component->driver->ops->prepare)
+		return component->driver->ops->prepare(substream);
+
+	return 0;
+}

commit 3672beb8cad6beb7b8c017514aef0f4f507debcf
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:50:07 2019 +0900

    ASoC: soc-component: add snd_soc_component_close()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_close() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ef2d5rnr.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index ada46f9729b2..cee66183470d 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -295,3 +295,13 @@ int snd_soc_component_open(struct snd_soc_component *component,
 
 	return 0;
 }
+
+int snd_soc_component_close(struct snd_soc_component *component,
+			    struct snd_pcm_substream *substream)
+{
+	if (component->driver->ops &&
+	    component->driver->ops->close)
+		return component->driver->ops->close(substream);
+
+	return 0;
+}

commit ae2f4849286eed48a3aa79a7b73bb5bcd0c9213b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:50:01 2019 +0900

    ASoC: soc-component: add snd_soc_component_open()
    
    Current ALSA SoC is directly using component->driver->ops->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_open() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ftmt5rnx.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index ac2d7bd5d844..ada46f9729b2 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -285,3 +285,13 @@ void snd_soc_component_module_put(struct snd_soc_component *component,
 	if (component->driver->module_get_upon_open == !!upon_open)
 		module_put(component->dev->driver->owner);
 }
+
+int snd_soc_component_open(struct snd_soc_component *component,
+			   struct snd_pcm_substream *substream)
+{
+	if (component->driver->ops &&
+	    component->driver->ops->open)
+		return component->driver->ops->open(substream);
+
+	return 0;
+}

commit 4a81e8f30d0b422b7f10562952124d719f73b071
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:49:54 2019 +0900

    ASoC: soc-component: add snd_soc_component_get/put()
    
    ALSA SoC is calling try_module_get()/module_put() based on
    component->driver->module_get_upon_open.
    To keep simple and readable code, we should create its function.
    This patch adds new snd_soc_component_get/put().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87h8795ro4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
index e19f78bfb919..ac2d7bd5d844 100644
--- a/sound/soc/soc-component.c
+++ b/sound/soc/soc-component.c
@@ -5,6 +5,7 @@
 // Copyright (C) 2019 Renesas Electronics Corp.
 // Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
 //
+#include <linux/module.h>
 #include <sound/soc.h>
 
 /**
@@ -267,3 +268,20 @@ int snd_soc_component_set_jack(struct snd_soc_component *component,
 	return -ENOTSUPP;
 }
 EXPORT_SYMBOL_GPL(snd_soc_component_set_jack);
+
+int snd_soc_component_module_get(struct snd_soc_component *component,
+				 int upon_open)
+{
+	if (component->driver->module_get_upon_open == !!upon_open &&
+	    !try_module_get(component->dev->driver->owner))
+		return -ENODEV;
+
+	return 0;
+}
+
+void snd_soc_component_module_put(struct snd_soc_component *component,
+				  int upon_open)
+{
+	if (component->driver->module_get_upon_open == !!upon_open)
+		module_put(component->dev->driver->owner);
+}

commit 4ff1fef10f353b928bcc9d56d31fda53f2c43191
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:49:48 2019 +0900

    ASoC: add soc-component.c
    
    ALSA SoC has many snd_soc_component_xxx(), but these are randomly
    located in many files. Because of it, code is difficult to read.
    This patch creates new soc-component.c, and moves existing
    snd_soc_component_xxx() into it.
    But not yet fully. We need more cleanup it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87imrp5roa.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-component.c b/sound/soc/soc-component.c
new file mode 100644
index 000000000000..e19f78bfb919
--- /dev/null
+++ b/sound/soc/soc-component.c
@@ -0,0 +1,269 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// soc-component.c
+//
+// Copyright (C) 2019 Renesas Electronics Corp.
+// Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+//
+#include <sound/soc.h>
+
+/**
+ * snd_soc_component_set_sysclk - configure COMPONENT system or master clock.
+ * @component: COMPONENT
+ * @clk_id: DAI specific clock ID
+ * @source: Source for the clock
+ * @freq: new clock frequency in Hz
+ * @dir: new clock direction - input/output.
+ *
+ * Configures the CODEC master (MCLK) or system (SYSCLK) clocking.
+ */
+int snd_soc_component_set_sysclk(struct snd_soc_component *component,
+				 int clk_id, int source, unsigned int freq,
+				 int dir)
+{
+	if (component->driver->set_sysclk)
+		return component->driver->set_sysclk(component, clk_id, source,
+						     freq, dir);
+
+	return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_set_sysclk);
+
+/*
+ * snd_soc_component_set_pll - configure component PLL.
+ * @component: COMPONENT
+ * @pll_id: DAI specific PLL ID
+ * @source: DAI specific source for the PLL
+ * @freq_in: PLL input clock frequency in Hz
+ * @freq_out: requested PLL output clock frequency in Hz
+ *
+ * Configures and enables PLL to generate output clock based on input clock.
+ */
+int snd_soc_component_set_pll(struct snd_soc_component *component, int pll_id,
+			      int source, unsigned int freq_in,
+			      unsigned int freq_out)
+{
+	if (component->driver->set_pll)
+		return component->driver->set_pll(component, pll_id, source,
+						  freq_in, freq_out);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_set_pll);
+
+int snd_soc_component_enable_pin(struct snd_soc_component *component,
+				 const char *pin)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	char *full_name;
+	int ret;
+
+	if (!component->name_prefix)
+		return snd_soc_dapm_enable_pin(dapm, pin);
+
+	full_name = kasprintf(GFP_KERNEL, "%s %s", component->name_prefix, pin);
+	if (!full_name)
+		return -ENOMEM;
+
+	ret = snd_soc_dapm_enable_pin(dapm, full_name);
+	kfree(full_name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_enable_pin);
+
+int snd_soc_component_enable_pin_unlocked(struct snd_soc_component *component,
+					  const char *pin)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	char *full_name;
+	int ret;
+
+	if (!component->name_prefix)
+		return snd_soc_dapm_enable_pin_unlocked(dapm, pin);
+
+	full_name = kasprintf(GFP_KERNEL, "%s %s", component->name_prefix, pin);
+	if (!full_name)
+		return -ENOMEM;
+
+	ret = snd_soc_dapm_enable_pin_unlocked(dapm, full_name);
+	kfree(full_name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_enable_pin_unlocked);
+
+int snd_soc_component_disable_pin(struct snd_soc_component *component,
+				  const char *pin)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	char *full_name;
+	int ret;
+
+	if (!component->name_prefix)
+		return snd_soc_dapm_disable_pin(dapm, pin);
+
+	full_name = kasprintf(GFP_KERNEL, "%s %s", component->name_prefix, pin);
+	if (!full_name)
+		return -ENOMEM;
+
+	ret = snd_soc_dapm_disable_pin(dapm, full_name);
+	kfree(full_name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_disable_pin);
+
+int snd_soc_component_disable_pin_unlocked(struct snd_soc_component *component,
+					   const char *pin)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	char *full_name;
+	int ret;
+
+	if (!component->name_prefix)
+		return snd_soc_dapm_disable_pin_unlocked(dapm, pin);
+
+	full_name = kasprintf(GFP_KERNEL, "%s %s", component->name_prefix, pin);
+	if (!full_name)
+		return -ENOMEM;
+
+	ret = snd_soc_dapm_disable_pin_unlocked(dapm, full_name);
+	kfree(full_name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_disable_pin_unlocked);
+
+int snd_soc_component_nc_pin(struct snd_soc_component *component,
+			     const char *pin)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	char *full_name;
+	int ret;
+
+	if (!component->name_prefix)
+		return snd_soc_dapm_nc_pin(dapm, pin);
+
+	full_name = kasprintf(GFP_KERNEL, "%s %s", component->name_prefix, pin);
+	if (!full_name)
+		return -ENOMEM;
+
+	ret = snd_soc_dapm_nc_pin(dapm, full_name);
+	kfree(full_name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_nc_pin);
+
+int snd_soc_component_nc_pin_unlocked(struct snd_soc_component *component,
+				      const char *pin)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	char *full_name;
+	int ret;
+
+	if (!component->name_prefix)
+		return snd_soc_dapm_nc_pin_unlocked(dapm, pin);
+
+	full_name = kasprintf(GFP_KERNEL, "%s %s", component->name_prefix, pin);
+	if (!full_name)
+		return -ENOMEM;
+
+	ret = snd_soc_dapm_nc_pin_unlocked(dapm, full_name);
+	kfree(full_name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_nc_pin_unlocked);
+
+int snd_soc_component_get_pin_status(struct snd_soc_component *component,
+				     const char *pin)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	char *full_name;
+	int ret;
+
+	if (!component->name_prefix)
+		return snd_soc_dapm_get_pin_status(dapm, pin);
+
+	full_name = kasprintf(GFP_KERNEL, "%s %s", component->name_prefix, pin);
+	if (!full_name)
+		return -ENOMEM;
+
+	ret = snd_soc_dapm_get_pin_status(dapm, full_name);
+	kfree(full_name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_get_pin_status);
+
+int snd_soc_component_force_enable_pin(struct snd_soc_component *component,
+				       const char *pin)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	char *full_name;
+	int ret;
+
+	if (!component->name_prefix)
+		return snd_soc_dapm_force_enable_pin(dapm, pin);
+
+	full_name = kasprintf(GFP_KERNEL, "%s %s", component->name_prefix, pin);
+	if (!full_name)
+		return -ENOMEM;
+
+	ret = snd_soc_dapm_force_enable_pin(dapm, full_name);
+	kfree(full_name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_force_enable_pin);
+
+int snd_soc_component_force_enable_pin_unlocked(
+	struct snd_soc_component *component,
+	const char *pin)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	char *full_name;
+	int ret;
+
+	if (!component->name_prefix)
+		return snd_soc_dapm_force_enable_pin_unlocked(dapm, pin);
+
+	full_name = kasprintf(GFP_KERNEL, "%s %s", component->name_prefix, pin);
+	if (!full_name)
+		return -ENOMEM;
+
+	ret = snd_soc_dapm_force_enable_pin_unlocked(dapm, full_name);
+	kfree(full_name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_force_enable_pin_unlocked);
+
+/**
+ * snd_soc_component_set_jack - configure component jack.
+ * @component: COMPONENTs
+ * @jack: structure to use for the jack
+ * @data: can be used if codec driver need extra data for configuring jack
+ *
+ * Configures and enables jack detection function.
+ */
+int snd_soc_component_set_jack(struct snd_soc_component *component,
+			       struct snd_soc_jack *jack, void *data)
+{
+	if (component->driver->set_jack)
+		return component->driver->set_jack(component, jack, data);
+
+	return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_set_jack);
