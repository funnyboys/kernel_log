commit f141a422159a199f4c8dedb7e0df55b3b2cf16cd
Author: Qiushi Wu <wu000273@umn.edu>
Date:   Sat Jun 13 15:51:58 2020 -0500

    ASoC: rockchip: Fix a reference count leak.
    
    Calling pm_runtime_get_sync increments the counter even in case of
    failure, causing incorrect ref count if pm_runtime_put is not called in
    error handling paths. Call pm_runtime_put if pm_runtime_get_sync fails.
    
    Fixes: fc05a5b22253 ("ASoC: rockchip: add support for pdm controller")
    Signed-off-by: Qiushi Wu <wu000273@umn.edu>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    Link: https://lore.kernel.org/r/20200613205158.27296-1-wu000273@umn.edu
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 7cd42fcfcf38..1707414cfa92 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -590,8 +590,10 @@ static int rockchip_pdm_resume(struct device *dev)
 	int ret;
 
 	ret = pm_runtime_get_sync(dev);
-	if (ret < 0)
+	if (ret < 0) {
+		pm_runtime_put(dev);
 		return ret;
+	}
 
 	ret = regcache_sync(pdm->regmap);
 

commit 9c92ab61914157664a2fbdf926df0eb937838e45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282
    
    Based on 1 normalized pattern(s):
    
      this software is licensed under the terms of the gnu general public
      license version 2 as published by the free software foundation and
      may be copied distributed and modified under those terms this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 285 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.642774971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index b9c1d8ad77c1..7cd42fcfcf38 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -1,17 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Rockchip PDM ALSA SoC Digital Audio Interface(DAI)  driver
  *
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 
 #include <linux/module.h>

commit f153bf49ddf6169544b24ef5ea26fa3eb4996b95
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 6 17:02:24 2019 +0200

    ASoC: rockchip: Fix an uninitialized variable compile warning
    
    Paper over a trivial case leading to an uninitialized variable compile
    warning:
      sound/soc/rockchip/rockchip_pdm.c:179:3: warning: ‘clk_out’ may be used uninitialized in this function [-Wmaybe-uninitialized]
    
    Fixes: 624e8e00acaf ("ASoC: rockchip: pdm: fixup pdm fractional div")
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 6c0f242db5ef..b9c1d8ad77c1 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -158,7 +158,7 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 	struct rk_pdm_dev *pdm = to_info(dai);
 	unsigned int val = 0;
 	unsigned int clk_rate, clk_div, samplerate;
-	unsigned int clk_src, clk_out;
+	unsigned int clk_src, clk_out = 0;
 	unsigned long m, n;
 	bool change;
 	int ret;

commit b126fc07328749269021ac53173f9afdd6947248
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Thu Apr 4 11:57:08 2019 +0800

    ASoC: rockchip: pdm: Mark RXFIFO_DATA as volatile and precious
    
    This patch marks RXFIFO_DATA as precious to avoid being read
    outside a call from the driver, such as regmap debugfs
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 068453596470..6c0f242db5ef 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -417,6 +417,7 @@ static bool rockchip_pdm_rd_reg(struct device *dev, unsigned int reg)
 	case PDM_INT_CLR:
 	case PDM_INT_ST:
 	case PDM_DATA_VALID:
+	case PDM_RXFIFO_DATA:
 	case PDM_VERSION:
 		return true;
 	default:
@@ -431,6 +432,17 @@ static bool rockchip_pdm_volatile_reg(struct device *dev, unsigned int reg)
 	case PDM_FIFO_CTRL:
 	case PDM_INT_CLR:
 	case PDM_INT_ST:
+	case PDM_RXFIFO_DATA:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_pdm_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case PDM_RXFIFO_DATA:
 		return true;
 	default:
 		return false;
@@ -453,6 +465,7 @@ static const struct regmap_config rockchip_pdm_regmap_config = {
 	.writeable_reg = rockchip_pdm_wr_reg,
 	.readable_reg = rockchip_pdm_rd_reg,
 	.volatile_reg = rockchip_pdm_volatile_reg,
+	.precious_reg = rockchip_pdm_precious_reg,
 	.cache_type = REGCACHE_FLAT,
 };
 

commit 54cd97cfe02e9bb93db53e7cbfa9b672bf4a5ac8
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Thu Apr 4 11:57:57 2019 +0800

    ASoC: rockchip: pdm: Correct PDM_CTRL0 reg value
    
    This patch fix the wrong reg value for rk322x/rk322xh,
    cuz there is no STORE JUSTIFIED MODE on it.
    
    on rk322x/rk322xh, the same bit means PDM_MODE/RESERVED,
    if the bit is set to RESERVED, the controller will not work.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 955cdc2b8fc5..068453596470 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -210,7 +210,9 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 	regmap_update_bits(pdm->regmap, PDM_HPF_CTRL,
 			   PDM_HPF_LE | PDM_HPF_RE, PDM_HPF_LE | PDM_HPF_RE);
 	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_CLK_EN, PDM_CLK_EN);
-	regmap_update_bits(pdm->regmap, PDM_CTRL0, PDM_MODE_MSK, PDM_MODE_LJ);
+	if (pdm->version != RK_PDM_RK3229)
+		regmap_update_bits(pdm->regmap, PDM_CTRL0,
+				   PDM_MODE_MSK, PDM_MODE_LJ);
 
 	val = 0;
 	switch (params_format(params)) {
@@ -455,7 +457,8 @@ static const struct regmap_config rockchip_pdm_regmap_config = {
 };
 
 static const struct of_device_id rockchip_pdm_match[] = {
-	{ .compatible = "rockchip,pdm", },
+	{ .compatible = "rockchip,pdm",
+	  .data = (void *)RK_PDM_RK3229 },
 	{ .compatible = "rockchip,px30-pdm",
 	  .data = (void *)RK_PDM_RK3308 },
 	{ .compatible = "rockchip,rk1808-pdm",

commit 430f5da69b9323d5e7faca95bc30e61be4fcbbbf
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Thu Apr 4 11:56:29 2019 +0800

    ASoC: rockchip: pdm: adjust waterlevel in frame unit
    
    This patch make the waterlevel more reasonable, because the pdm
    controller share the single FIFO(128 entries) with each channel.
    adjust waterlevel in frame to meet the vad or dma frames request.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 3e1c5fd5b32b..955cdc2b8fc5 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -255,8 +255,9 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 	regmap_update_bits(pdm->regmap, PDM_CTRL0,
 			   PDM_PATH_MSK | PDM_VDW_MSK,
 			   val);
+	/* all channels share the single FIFO */
 	regmap_update_bits(pdm->regmap, PDM_DMA_CTRL, PDM_DMA_RDL_MSK,
-			   PDM_DMA_RDL(16));
+			   PDM_DMA_RDL(8 * params_channels(params)));
 
 	return 0;
 }

commit 717d97879b346d56fc47a6e3fe0ad44fea9949b2
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Thu Apr 4 11:54:30 2019 +0800

    ASoC: rockchip: pdm: add compatible for rk1808
    
    This patch adds support for rk1808, the pdm controller
    is the same as rk3308.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 4f93a7454e85..3e1c5fd5b32b 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -457,6 +457,8 @@ static const struct of_device_id rockchip_pdm_match[] = {
 	{ .compatible = "rockchip,pdm", },
 	{ .compatible = "rockchip,px30-pdm",
 	  .data = (void *)RK_PDM_RK3308 },
+	{ .compatible = "rockchip,rk1808-pdm",
+	  .data = (void *)RK_PDM_RK3308 },
 	{ .compatible = "rockchip,rk3308-pdm",
 	  .data = (void *)RK_PDM_RK3308 },
 	{},

commit 624e8e00acafe3d31a7c31e67fa95ce06e324bf8
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Thu Apr 4 11:51:09 2019 +0800

    ASoC: rockchip: pdm: fixup pdm fractional div
    
    This patch adds support fractional div for rk3308.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index c50494b0ed0d..4f93a7454e85 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -17,14 +17,23 @@
 #include <linux/module.h>
 #include <linux/clk.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/pm_runtime.h>
+#include <linux/rational.h>
 #include <linux/regmap.h>
+#include <linux/reset.h>
 #include <sound/dmaengine_pcm.h>
 #include <sound/pcm_params.h>
 
 #include "rockchip_pdm.h"
 
 #define PDM_DMA_BURST_SIZE	(8) /* size * width: 8*4 = 32 bytes */
+#define PDM_SIGNOFF_CLK_RATE	(100000000)
+
+enum rk_pdm_version {
+	RK_PDM_RK3229,
+	RK_PDM_RK3308,
+};
 
 struct rk_pdm_dev {
 	struct device *dev;
@@ -32,22 +41,51 @@ struct rk_pdm_dev {
 	struct clk *hclk;
 	struct regmap *regmap;
 	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct reset_control *reset;
+	enum rk_pdm_version version;
 };
 
 struct rk_pdm_clkref {
 	unsigned int sr;
 	unsigned int clk;
+	unsigned int clk_out;
+};
+
+struct rk_pdm_ds_ratio {
+	unsigned int ratio;
+	unsigned int sr;
 };
 
 static struct rk_pdm_clkref clkref[] = {
-	{ 8000, 40960000 },
-	{ 11025, 56448000 },
-	{ 12000, 61440000 },
+	{ 8000, 40960000, 2048000 },
+	{ 11025, 56448000, 2822400 },
+	{ 12000, 61440000, 3072000 },
+	{ 8000, 98304000, 2048000 },
+	{ 12000, 98304000, 3072000 },
+};
+
+static struct rk_pdm_ds_ratio ds_ratio[] = {
+	{ 0, 192000 },
+	{ 0, 176400 },
+	{ 0, 128000 },
+	{ 1, 96000 },
+	{ 1, 88200 },
+	{ 1, 64000 },
+	{ 2, 48000 },
+	{ 2, 44100 },
+	{ 2, 32000 },
+	{ 3, 24000 },
+	{ 3, 22050 },
+	{ 3, 16000 },
+	{ 4, 12000 },
+	{ 4, 11025 },
+	{ 4, 8000 },
 };
 
-static unsigned int get_pdm_clk(unsigned int sr)
+static unsigned int get_pdm_clk(struct rk_pdm_dev *pdm, unsigned int sr,
+				unsigned int *clk_src, unsigned int *clk_out)
 {
-	unsigned int i, count, clk, div;
+	unsigned int i, count, clk, div, rate;
 
 	clk = 0;
 	if (!sr)
@@ -59,14 +97,39 @@ static unsigned int get_pdm_clk(unsigned int sr)
 			continue;
 		div = sr / clkref[i].sr;
 		if ((div & (div - 1)) == 0) {
+			*clk_out = clkref[i].clk_out;
+			rate = clk_round_rate(pdm->clk, clkref[i].clk);
+			if (rate != clkref[i].clk)
+				continue;
 			clk = clkref[i].clk;
+			*clk_src = clkref[i].clk;
 			break;
 		}
 	}
 
+	if (!clk) {
+		clk = clk_round_rate(pdm->clk, PDM_SIGNOFF_CLK_RATE);
+		*clk_src = clk;
+	}
 	return clk;
 }
 
+static unsigned int get_pdm_ds_ratio(unsigned int sr)
+{
+	unsigned int i, count, ratio;
+
+	ratio = 0;
+	if (!sr)
+		return ratio;
+
+	count = ARRAY_SIZE(ds_ratio);
+	for (i = 0; i < count; i++) {
+		if (sr == ds_ratio[i].sr)
+			ratio = ds_ratio[i].ratio;
+	}
+	return ratio;
+}
+
 static inline struct rk_pdm_dev *to_info(struct snd_soc_dai *dai)
 {
 	return snd_soc_dai_get_drvdata(dai);
@@ -95,40 +158,52 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 	struct rk_pdm_dev *pdm = to_info(dai);
 	unsigned int val = 0;
 	unsigned int clk_rate, clk_div, samplerate;
+	unsigned int clk_src, clk_out;
+	unsigned long m, n;
+	bool change;
 	int ret;
 
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return 0;
+
 	samplerate = params_rate(params);
-	clk_rate = get_pdm_clk(samplerate);
+	clk_rate = get_pdm_clk(pdm, samplerate, &clk_src, &clk_out);
 	if (!clk_rate)
 		return -EINVAL;
 
-	ret = clk_set_rate(pdm->clk, clk_rate);
+	ret = clk_set_rate(pdm->clk, clk_src);
 	if (ret)
 		return -EINVAL;
 
-	clk_div = DIV_ROUND_CLOSEST(clk_rate, samplerate);
-
-	switch (clk_div) {
-	case 320:
-		val = PDM_CLK_320FS;
-		break;
-	case 640:
-		val = PDM_CLK_640FS;
-		break;
-	case 1280:
-		val = PDM_CLK_1280FS;
-		break;
-	case 2560:
-		val = PDM_CLK_2560FS;
-		break;
-	case 5120:
-		val = PDM_CLK_5120FS;
-		break;
-	default:
-		dev_err(pdm->dev, "unsupported div: %d\n", clk_div);
-		return -EINVAL;
+	if (pdm->version == RK_PDM_RK3308) {
+		rational_best_approximation(clk_out, clk_src,
+					    GENMASK(16 - 1, 0),
+					    GENMASK(16 - 1, 0),
+					    &m, &n);
+
+		val = (m << PDM_FD_NUMERATOR_SFT) |
+			(n << PDM_FD_DENOMINATOR_SFT);
+		regmap_update_bits_check(pdm->regmap, PDM_CTRL1,
+					 PDM_FD_NUMERATOR_MSK |
+					 PDM_FD_DENOMINATOR_MSK,
+					 val, &change);
+		if (change) {
+			reset_control_assert(pdm->reset);
+			reset_control_deassert(pdm->reset);
+			rockchip_pdm_rxctrl(pdm, 0);
+		}
+		clk_div = n / m;
+		if (clk_div >= 40)
+			val = PDM_CLK_FD_RATIO_40;
+		else if (clk_div <= 35)
+			val = PDM_CLK_FD_RATIO_35;
+		else
+			return -EINVAL;
+		regmap_update_bits(pdm->regmap, PDM_CLK_CTRL,
+				   PDM_CLK_FD_RATIO_MSK,
+				   val);
 	}
-
+	val = get_pdm_ds_ratio(samplerate);
 	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_DS_RATIO_MSK, val);
 	regmap_update_bits(pdm->regmap, PDM_HPF_CTRL,
 			   PDM_HPF_CF_MSK, PDM_HPF_60HZ);
@@ -177,13 +252,11 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
-		regmap_update_bits(pdm->regmap, PDM_CTRL0,
-				   PDM_PATH_MSK | PDM_VDW_MSK,
-				   val);
-		regmap_update_bits(pdm->regmap, PDM_DMA_CTRL, PDM_DMA_RDL_MSK,
-				   PDM_DMA_RDL(16));
-	}
+	regmap_update_bits(pdm->regmap, PDM_CTRL0,
+			   PDM_PATH_MSK | PDM_VDW_MSK,
+			   val);
+	regmap_update_bits(pdm->regmap, PDM_DMA_CTRL, PDM_DMA_RDL_MSK,
+			   PDM_DMA_RDL(16));
 
 	return 0;
 }
@@ -380,8 +453,19 @@ static const struct regmap_config rockchip_pdm_regmap_config = {
 	.cache_type = REGCACHE_FLAT,
 };
 
+static const struct of_device_id rockchip_pdm_match[] = {
+	{ .compatible = "rockchip,pdm", },
+	{ .compatible = "rockchip,px30-pdm",
+	  .data = (void *)RK_PDM_RK3308 },
+	{ .compatible = "rockchip,rk3308-pdm",
+	  .data = (void *)RK_PDM_RK3308 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rockchip_pdm_match);
+
 static int rockchip_pdm_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *match;
 	struct rk_pdm_dev *pdm;
 	struct resource *res;
 	void __iomem *regs;
@@ -391,6 +475,16 @@ static int rockchip_pdm_probe(struct platform_device *pdev)
 	if (!pdm)
 		return -ENOMEM;
 
+	match = of_match_device(rockchip_pdm_match, &pdev->dev);
+	if (match)
+		pdm->version = (enum rk_pdm_version)match->data;
+
+	if (pdm->version == RK_PDM_RK3308) {
+		pdm->reset = devm_reset_control_get(&pdev->dev, "pdm-m");
+		if (IS_ERR(pdm->reset))
+			return PTR_ERR(pdm->reset);
+	}
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	regs = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(regs))
@@ -503,12 +597,6 @@ static const struct dev_pm_ops rockchip_pdm_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(rockchip_pdm_suspend, rockchip_pdm_resume)
 };
 
-static const struct of_device_id rockchip_pdm_match[] = {
-	{ .compatible = "rockchip,pdm", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, rockchip_pdm_match);
-
 static struct platform_driver rockchip_pdm_driver = {
 	.probe  = rockchip_pdm_probe,
 	.remove = rockchip_pdm_remove,

commit 072cb68a43663eacae7fe84dcbfd1a81dc692185
Merge: 252163a66a06 86a7b6ffd900
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Apr 4 15:07:34 2019 +0700

    Merge branch 'asoc-5.1' into asoc-5.2

commit 252163a66a06859f468ef1e00fa5a1f377b16eed
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Wed Apr 3 21:40:48 2019 +0800

    ASoC: rockchip: pdm: optimize clear logic
    
    There is no need to reset controller every time, do this
    once in pdm_probe.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 984d99889a65..eb5216dd7dbc 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -183,9 +183,6 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 				   val);
 		regmap_update_bits(pdm->regmap, PDM_DMA_CTRL, PDM_DMA_RDL_MSK,
 				   PDM_DMA_RDL(16));
-		regmap_update_bits(pdm->regmap, PDM_SYSCONFIG,
-				   PDM_RX_MASK | PDM_RX_CLR_MASK,
-				   PDM_RX_STOP | PDM_RX_CLR_WR);
 	}
 
 	return 0;
@@ -353,6 +350,7 @@ static bool rockchip_pdm_volatile_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
 	case PDM_SYSCONFIG:
+	case PDM_FIFO_CTRL:
 	case PDM_INT_CLR:
 	case PDM_INT_ST:
 		return true;
@@ -436,6 +434,7 @@ static int rockchip_pdm_probe(struct platform_device *pdev)
 		goto err_suspend;
 	}
 
+	rockchip_pdm_rxctrl(pdm, 0);
 	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
 	if (ret) {
 		dev_err(&pdev->dev, "could not register pcm: %d\n", ret);

commit a7980cd212cef9002fe9683f440d27609d1aae37
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Wed Apr 3 21:40:47 2019 +0800

    ASoC: rockchip: pdm: add default regs
    
    This patch add default regs value for controller.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index ba61a4b27d39..984d99889a65 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -361,11 +361,19 @@ static bool rockchip_pdm_volatile_reg(struct device *dev, unsigned int reg)
 	}
 }
 
+static const struct reg_default rockchip_pdm_reg_defaults[] = {
+	{0x04, 0x78000017},
+	{0x08, 0x0bb8ea60},
+	{0x18, 0x0000001f},
+};
+
 static const struct regmap_config rockchip_pdm_regmap_config = {
 	.reg_bits = 32,
 	.reg_stride = 4,
 	.val_bits = 32,
 	.max_register = PDM_VERSION,
+	.reg_defaults = rockchip_pdm_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rockchip_pdm_reg_defaults),
 	.writeable_reg = rockchip_pdm_wr_reg,
 	.readable_reg = rockchip_pdm_rd_reg,
 	.volatile_reg = rockchip_pdm_volatile_reg,

commit fb20de606316a446efdfb0f775a892f782165783
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Wed Apr 3 21:40:46 2019 +0800

    ASoC: rockchip: pdm: using left justified store mode
    
    This patch set left justified store mode default.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 400e29edb1c9..ba61a4b27d39 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -135,6 +135,7 @@ static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
 	regmap_update_bits(pdm->regmap, PDM_HPF_CTRL,
 			   PDM_HPF_LE | PDM_HPF_RE, PDM_HPF_LE | PDM_HPF_RE);
 	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_CLK_EN, PDM_CLK_EN);
+	regmap_update_bits(pdm->regmap, PDM_CTRL0, PDM_MODE_MSK, PDM_MODE_LJ);
 
 	val = 0;
 	switch (params_format(params)) {

commit 86a7b6ffd90095d81d9fa0d8b48955b7c83b2e2f
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Thu Apr 4 11:48:11 2019 +0800

    ASoC: rockchip: pdm: change dma burst to 8
    
    This patch decreases the transfer bursts to avoid the fifo overrun.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 8a2e3bbce3a1..d0b403a0e27b 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -24,7 +24,7 @@
 
 #include "rockchip_pdm.h"
 
-#define PDM_DMA_BURST_SIZE	(16) /* size * width: 16*4 = 64 bytes */
+#define PDM_DMA_BURST_SIZE	(8) /* size * width: 8*4 = 32 bytes */
 
 struct rk_pdm_dev {
 	struct device *dev;

commit c85064435fe7a216ec0f0238ef2b8f7cd850a450
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Wed Apr 3 21:40:45 2019 +0800

    ASoC: rockchip: pdm: fix regmap_ops hang issue
    
    This is because set_fmt ops maybe called when PD is off,
    and in such case, regmap_ops will lead system hang.
    enale PD before doing regmap_ops.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index 400e29edb1c9..8a2e3bbce3a1 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -208,7 +208,9 @@ static int rockchip_pdm_set_fmt(struct snd_soc_dai *cpu_dai,
 		return -EINVAL;
 	}
 
+	pm_runtime_get_sync(cpu_dai->dev);
 	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, mask, val);
+	pm_runtime_put(cpu_dai->dev);
 
 	return 0;
 }

commit 0966a2588779d0d44706f973c1e8ff240be43017
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Tue Aug 15 17:10:09 2017 +0200

    ASoC: rockchip: constify snd_soc_dai_ops structures
    
    These snd_soc_dai_ops structures are only stored in the ops field of
    a snd_soc_dai_driver structure, which is const.  Thus, the
    snd_soc_dai_ops structures can be const too.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
index c5ddeed97260..400e29edb1c9 100644
--- a/sound/soc/rockchip/rockchip_pdm.c
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -249,7 +249,7 @@ static int rockchip_pdm_dai_probe(struct snd_soc_dai *dai)
 	return 0;
 }
 
-static struct snd_soc_dai_ops rockchip_pdm_dai_ops = {
+static const struct snd_soc_dai_ops rockchip_pdm_dai_ops = {
 	.set_fmt = rockchip_pdm_set_fmt,
 	.trigger = rockchip_pdm_trigger,
 	.hw_params = rockchip_pdm_hw_params,

commit fc05a5b222530617d99d0e803abb262130fdb0c4
Author: Sugar Zhang <sugar.zhang@rock-chips.com>
Date:   Tue Jun 13 15:27:46 2017 +0800

    ASoC: rockchip: add support for pdm controller
    
    The Pulse Density Modulation Interface Controller (PDMC) is
    a PDM interface controller and decoder that support PDM format.
    It integrates a clock generator driving the PDM microphone
    and embeds filters which decimate the incoming bit stream to
    obtain most common audio rates.
    
    Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/rockchip/rockchip_pdm.c b/sound/soc/rockchip/rockchip_pdm.c
new file mode 100644
index 000000000000..c5ddeed97260
--- /dev/null
+++ b/sound/soc/rockchip/rockchip_pdm.c
@@ -0,0 +1,516 @@
+/*
+ * Rockchip PDM ALSA SoC Digital Audio Interface(DAI)  driver
+ *
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+
+#include "rockchip_pdm.h"
+
+#define PDM_DMA_BURST_SIZE	(16) /* size * width: 16*4 = 64 bytes */
+
+struct rk_pdm_dev {
+	struct device *dev;
+	struct clk *clk;
+	struct clk *hclk;
+	struct regmap *regmap;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+};
+
+struct rk_pdm_clkref {
+	unsigned int sr;
+	unsigned int clk;
+};
+
+static struct rk_pdm_clkref clkref[] = {
+	{ 8000, 40960000 },
+	{ 11025, 56448000 },
+	{ 12000, 61440000 },
+};
+
+static unsigned int get_pdm_clk(unsigned int sr)
+{
+	unsigned int i, count, clk, div;
+
+	clk = 0;
+	if (!sr)
+		return clk;
+
+	count = ARRAY_SIZE(clkref);
+	for (i = 0; i < count; i++) {
+		if (sr % clkref[i].sr)
+			continue;
+		div = sr / clkref[i].sr;
+		if ((div & (div - 1)) == 0) {
+			clk = clkref[i].clk;
+			break;
+		}
+	}
+
+	return clk;
+}
+
+static inline struct rk_pdm_dev *to_info(struct snd_soc_dai *dai)
+{
+	return snd_soc_dai_get_drvdata(dai);
+}
+
+static void rockchip_pdm_rxctrl(struct rk_pdm_dev *pdm, int on)
+{
+	if (on) {
+		regmap_update_bits(pdm->regmap, PDM_DMA_CTRL,
+				   PDM_DMA_RD_MSK, PDM_DMA_RD_EN);
+		regmap_update_bits(pdm->regmap, PDM_SYSCONFIG,
+				   PDM_RX_MASK, PDM_RX_START);
+	} else {
+		regmap_update_bits(pdm->regmap, PDM_DMA_CTRL,
+				   PDM_DMA_RD_MSK, PDM_DMA_RD_DIS);
+		regmap_update_bits(pdm->regmap, PDM_SYSCONFIG,
+				   PDM_RX_MASK | PDM_RX_CLR_MASK,
+				   PDM_RX_STOP | PDM_RX_CLR_WR);
+	}
+}
+
+static int rockchip_pdm_hw_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params,
+				  struct snd_soc_dai *dai)
+{
+	struct rk_pdm_dev *pdm = to_info(dai);
+	unsigned int val = 0;
+	unsigned int clk_rate, clk_div, samplerate;
+	int ret;
+
+	samplerate = params_rate(params);
+	clk_rate = get_pdm_clk(samplerate);
+	if (!clk_rate)
+		return -EINVAL;
+
+	ret = clk_set_rate(pdm->clk, clk_rate);
+	if (ret)
+		return -EINVAL;
+
+	clk_div = DIV_ROUND_CLOSEST(clk_rate, samplerate);
+
+	switch (clk_div) {
+	case 320:
+		val = PDM_CLK_320FS;
+		break;
+	case 640:
+		val = PDM_CLK_640FS;
+		break;
+	case 1280:
+		val = PDM_CLK_1280FS;
+		break;
+	case 2560:
+		val = PDM_CLK_2560FS;
+		break;
+	case 5120:
+		val = PDM_CLK_5120FS;
+		break;
+	default:
+		dev_err(pdm->dev, "unsupported div: %d\n", clk_div);
+		return -EINVAL;
+	}
+
+	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_DS_RATIO_MSK, val);
+	regmap_update_bits(pdm->regmap, PDM_HPF_CTRL,
+			   PDM_HPF_CF_MSK, PDM_HPF_60HZ);
+	regmap_update_bits(pdm->regmap, PDM_HPF_CTRL,
+			   PDM_HPF_LE | PDM_HPF_RE, PDM_HPF_LE | PDM_HPF_RE);
+	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_CLK_EN, PDM_CLK_EN);
+
+	val = 0;
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		val |= PDM_VDW(8);
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		val |= PDM_VDW(16);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		val |= PDM_VDW(20);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		val |= PDM_VDW(24);
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		val |= PDM_VDW(32);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (params_channels(params)) {
+	case 8:
+		val |= PDM_PATH3_EN;
+		/* fallthrough */
+	case 6:
+		val |= PDM_PATH2_EN;
+		/* fallthrough */
+	case 4:
+		val |= PDM_PATH1_EN;
+		/* fallthrough */
+	case 2:
+		val |= PDM_PATH0_EN;
+		break;
+	default:
+		dev_err(pdm->dev, "invalid channel: %d\n",
+			params_channels(params));
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		regmap_update_bits(pdm->regmap, PDM_CTRL0,
+				   PDM_PATH_MSK | PDM_VDW_MSK,
+				   val);
+		regmap_update_bits(pdm->regmap, PDM_DMA_CTRL, PDM_DMA_RDL_MSK,
+				   PDM_DMA_RDL(16));
+		regmap_update_bits(pdm->regmap, PDM_SYSCONFIG,
+				   PDM_RX_MASK | PDM_RX_CLR_MASK,
+				   PDM_RX_STOP | PDM_RX_CLR_WR);
+	}
+
+	return 0;
+}
+
+static int rockchip_pdm_set_fmt(struct snd_soc_dai *cpu_dai,
+				unsigned int fmt)
+{
+	struct rk_pdm_dev *pdm = to_info(cpu_dai);
+	unsigned int mask = 0, val = 0;
+
+	mask = PDM_CKP_MSK;
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		val = PDM_CKP_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		val = PDM_CKP_INVERTED;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, mask, val);
+
+	return 0;
+}
+
+static int rockchip_pdm_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	struct rk_pdm_dev *pdm = to_info(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rockchip_pdm_rxctrl(pdm, 1);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rockchip_pdm_rxctrl(pdm, 0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int rockchip_pdm_dai_probe(struct snd_soc_dai *dai)
+{
+	struct rk_pdm_dev *pdm = to_info(dai);
+
+	dai->capture_dma_data = &pdm->capture_dma_data;
+
+	return 0;
+}
+
+static struct snd_soc_dai_ops rockchip_pdm_dai_ops = {
+	.set_fmt = rockchip_pdm_set_fmt,
+	.trigger = rockchip_pdm_trigger,
+	.hw_params = rockchip_pdm_hw_params,
+};
+
+#define ROCKCHIP_PDM_RATES SNDRV_PCM_RATE_8000_192000
+#define ROCKCHIP_PDM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+			      SNDRV_PCM_FMTBIT_S20_3LE | \
+			      SNDRV_PCM_FMTBIT_S24_LE | \
+			      SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_driver rockchip_pdm_dai = {
+	.probe = rockchip_pdm_dai_probe,
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = ROCKCHIP_PDM_RATES,
+		.formats = ROCKCHIP_PDM_FORMATS,
+	},
+	.ops = &rockchip_pdm_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static const struct snd_soc_component_driver rockchip_pdm_component = {
+	.name = "rockchip-pdm",
+};
+
+static int rockchip_pdm_runtime_suspend(struct device *dev)
+{
+	struct rk_pdm_dev *pdm = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(pdm->clk);
+	clk_disable_unprepare(pdm->hclk);
+
+	return 0;
+}
+
+static int rockchip_pdm_runtime_resume(struct device *dev)
+{
+	struct rk_pdm_dev *pdm = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(pdm->clk);
+	if (ret) {
+		dev_err(pdm->dev, "clock enable failed %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pdm->hclk);
+	if (ret) {
+		dev_err(pdm->dev, "hclock enable failed %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static bool rockchip_pdm_wr_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case PDM_SYSCONFIG:
+	case PDM_CTRL0:
+	case PDM_CTRL1:
+	case PDM_CLK_CTRL:
+	case PDM_HPF_CTRL:
+	case PDM_FIFO_CTRL:
+	case PDM_DMA_CTRL:
+	case PDM_INT_EN:
+	case PDM_INT_CLR:
+	case PDM_DATA_VALID:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_pdm_rd_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case PDM_SYSCONFIG:
+	case PDM_CTRL0:
+	case PDM_CTRL1:
+	case PDM_CLK_CTRL:
+	case PDM_HPF_CTRL:
+	case PDM_FIFO_CTRL:
+	case PDM_DMA_CTRL:
+	case PDM_INT_EN:
+	case PDM_INT_CLR:
+	case PDM_INT_ST:
+	case PDM_DATA_VALID:
+	case PDM_VERSION:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_pdm_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case PDM_SYSCONFIG:
+	case PDM_INT_CLR:
+	case PDM_INT_ST:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config rockchip_pdm_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = PDM_VERSION,
+	.writeable_reg = rockchip_pdm_wr_reg,
+	.readable_reg = rockchip_pdm_rd_reg,
+	.volatile_reg = rockchip_pdm_volatile_reg,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static int rockchip_pdm_probe(struct platform_device *pdev)
+{
+	struct rk_pdm_dev *pdm;
+	struct resource *res;
+	void __iomem *regs;
+	int ret;
+
+	pdm = devm_kzalloc(&pdev->dev, sizeof(*pdm), GFP_KERNEL);
+	if (!pdm)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	pdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					    &rockchip_pdm_regmap_config);
+	if (IS_ERR(pdm->regmap))
+		return PTR_ERR(pdm->regmap);
+
+	pdm->capture_dma_data.addr = res->start + PDM_RXFIFO_DATA;
+	pdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	pdm->capture_dma_data.maxburst = PDM_DMA_BURST_SIZE;
+
+	pdm->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, pdm);
+
+	pdm->clk = devm_clk_get(&pdev->dev, "pdm_clk");
+	if (IS_ERR(pdm->clk))
+		return PTR_ERR(pdm->clk);
+
+	pdm->hclk = devm_clk_get(&pdev->dev, "pdm_hclk");
+	if (IS_ERR(pdm->hclk))
+		return PTR_ERR(pdm->hclk);
+
+	ret = clk_prepare_enable(pdm->hclk);
+	if (ret)
+		return ret;
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = rockchip_pdm_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &rockchip_pdm_component,
+					      &rockchip_pdm_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "could not register dai: %d\n", ret);
+		goto err_suspend;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "could not register pcm: %d\n", ret);
+		goto err_suspend;
+	}
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rockchip_pdm_runtime_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+
+	clk_disable_unprepare(pdm->hclk);
+
+	return ret;
+}
+
+static int rockchip_pdm_remove(struct platform_device *pdev)
+{
+	struct rk_pdm_dev *pdm = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rockchip_pdm_runtime_suspend(&pdev->dev);
+
+	clk_disable_unprepare(pdm->clk);
+	clk_disable_unprepare(pdm->hclk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_pdm_suspend(struct device *dev)
+{
+	struct rk_pdm_dev *pdm = dev_get_drvdata(dev);
+
+	regcache_mark_dirty(pdm->regmap);
+
+	return 0;
+}
+
+static int rockchip_pdm_resume(struct device *dev)
+{
+	struct rk_pdm_dev *pdm = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		return ret;
+
+	ret = regcache_sync(pdm->regmap);
+
+	pm_runtime_put(dev);
+
+	return ret;
+}
+#endif
+
+static const struct dev_pm_ops rockchip_pdm_pm_ops = {
+	SET_RUNTIME_PM_OPS(rockchip_pdm_runtime_suspend,
+			   rockchip_pdm_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_pdm_suspend, rockchip_pdm_resume)
+};
+
+static const struct of_device_id rockchip_pdm_match[] = {
+	{ .compatible = "rockchip,pdm", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rockchip_pdm_match);
+
+static struct platform_driver rockchip_pdm_driver = {
+	.probe  = rockchip_pdm_probe,
+	.remove = rockchip_pdm_remove,
+	.driver = {
+		.name = "rockchip-pdm",
+		.of_match_table = of_match_ptr(rockchip_pdm_match),
+		.pm = &rockchip_pdm_pm_ops,
+	},
+};
+
+module_platform_driver(rockchip_pdm_driver);
+
+MODULE_AUTHOR("Sugar <sugar.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip PDM Controller Driver");
+MODULE_LICENSE("GPL v2");
