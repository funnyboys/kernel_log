commit 185457632ba344d3100e6bdd8ba839b959521813
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Wed May 27 03:02:10 2020 +0000

    ASoC: mmp-sspa: Fix return value check in asoc_mmp_sspa_probe()
    
    In case of error, the function devm_ioremap() returns NULL pointer not
    ERR_PTR(). The IS_ERR() test in the return value check should be
    replaced with NULL test.
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Link: https://lore.kernel.org/r/20200527030210.124393-1-weiyongjun1@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 3e37ab625f8d..4255851c71c1 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -493,13 +493,13 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 			return -ENODEV;
 
 		sspa->rx_base = devm_ioremap(&pdev->dev, res->start, 0x30);
-		if (IS_ERR(sspa->rx_base))
-			return PTR_ERR(sspa->rx_base);
+		if (!sspa->rx_base)
+			return -ENOMEM;
 
 		sspa->tx_base = devm_ioremap(&pdev->dev,
 					     res->start + 0x80, 0x30);
-		if (IS_ERR(sspa->tx_base))
-			return PTR_ERR(sspa->tx_base);
+		if (!sspa->tx_base)
+			return -ENOMEM;
 
 		sspa->clk = devm_clk_get(&pdev->dev, NULL);
 		if (IS_ERR(sspa->clk))

commit 6ea460d52299f7febd408f2710d7c43ce505bc2c
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Wed May 20 10:35:16 2020 +0200

    ASoC: mmp-sspa: Fix the error handling in probe()
    
    If we fail after pm_runtime_enable(), we fail to undo it. Same with
    clk_prepare_enable(). Let's order them after all things that can fail.
    
    Fixes: 7d98cc648253 ("ASoC: mmp-sspa: Add support for the runtime power management")
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200520083516.2120802-1-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index b0accd49c89d..3e37ab625f8d 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -462,6 +462,7 @@ static const struct snd_soc_component_driver mmp_sspa_component = {
 static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 {
 	struct sspa_priv *sspa;
+	int ret;
 
 	sspa = devm_kzalloc(&pdev->dev,
 				sizeof(struct sspa_priv), GFP_KERNEL);
@@ -514,8 +515,6 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 			return PTR_ERR(sspa->sysclk);
 		}
 	}
-	pm_runtime_enable(&pdev->dev);
-	clk_prepare_enable(sspa->audio_clk);
 	platform_set_drvdata(pdev, sspa);
 
 	sspa->playback_dma_data.maxburst = 4;
@@ -525,16 +524,21 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	sspa->playback_dma_data.addr = 0x80 + SSPA_D;
 
 	if (pdev->dev.of_node) {
-		int ret;
-
 		ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
 						      &mmp_pcm_config, 0);
 		if (ret)
 			return ret;
 	}
 
-	return devm_snd_soc_register_component(&pdev->dev, &mmp_sspa_component,
-					       &mmp_sspa_dai, 1);
+	ret = devm_snd_soc_register_component(&pdev->dev, &mmp_sspa_component,
+					      &mmp_sspa_dai, 1);
+	if (ret)
+		return ret;
+
+	pm_runtime_enable(&pdev->dev);
+	clk_prepare_enable(sspa->audio_clk);
+
+	return 0;
 }
 
 static int asoc_mmp_sspa_remove(struct platform_device *pdev)

commit a97e384ba78fd8bf7ba8c32718424d8a7536416e
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Mon May 11 23:01:34 2020 +0200

    ASoC: mmp-sspa: Add Device Tree support
    
    This makes it possible to select CONFIG_SND_MMP_SOC_SSPA directly, as
    opposed to via CONFIG_SND_MMP_SOC, and for the driver to bind to a device
    tree node. That makes the driver useful on Device Tree based systems,
    with audio-graph-card or simple-card.
    
    The aforementioned card drivers control the master clock themselves and
    don't call the set_dai_sysclk() or set_dai_pll(), thus the respective
    handlers don't serve any purpose anymore. Instead, they return early and
    the hw_params() handler sets the appropriate bitclk itself.
    
    The register range is split into two -- for the RX block and for the TX
    block. On a MMP2 there are two pairs of them; the first one has the
    clock controller in the middle, while the second just has a hole:
    
      0xd42a0c00 - 0xd42a0c30 RX1
      0xd42a0c30 - 0xd42a0c40 Clocks
      0xd42a0c80 - 0xd42a0cb0 TX1
      0xd42a0d00 - 0xd42a0d30 RX2
      0xd42a0d80 - 0xd42a0cb0 TX2
    
    For this reason, mmp_sspa_write_reg() and mmp_sspa_read_reg() are
    replaced with direct calls to I/O routines.
    
    Tested on a MMP2-based OLPC XO-1.75 laptop with rt5631 coded, mmp_tdma DMA
    engine and MMP2 clock controller glued together with audio-graph-card.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200511210134.1224532-12-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 86277471974a..b0accd49c89d 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -28,27 +28,20 @@
  * SSPA audio private data
  */
 struct sspa_priv {
-	void __iomem *mmio_base;
+	void __iomem *tx_base;
+	void __iomem *rx_base;
+
 	struct snd_dmaengine_dai_dma_data playback_dma_data;
 	struct snd_dmaengine_dai_dma_data capture_dma_data;
 	struct clk *clk;
 	struct clk *audio_clk;
 	struct clk *sysclk;
+
 	int running_cnt;
 	u32 sp;
 	u32 ctrl;
 };
 
-static void mmp_sspa_write_reg(struct sspa_priv *sspa, u32 reg, u32 val)
-{
-	__raw_writel(val, sspa->mmio_base + reg);
-}
-
-static u32 mmp_sspa_read_reg(struct sspa_priv *sspa, u32 reg)
-{
-	return __raw_readl(sspa->mmio_base + reg);
-}
-
 static void mmp_sspa_tx_enable(struct sspa_priv *sspa)
 {
 	unsigned int sspa_sp = sspa->sp;
@@ -56,7 +49,7 @@ static void mmp_sspa_tx_enable(struct sspa_priv *sspa)
 	sspa_sp &= ~SSPA_SP_MSL;
 	sspa_sp |= SSPA_SP_S_EN;
 	sspa_sp |= SSPA_SP_WEN;
-	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+	__raw_writel(sspa_sp, sspa->tx_base + SSPA_SP);
 }
 
 static void mmp_sspa_tx_disable(struct sspa_priv *sspa)
@@ -66,7 +59,7 @@ static void mmp_sspa_tx_disable(struct sspa_priv *sspa)
 	sspa_sp &= ~SSPA_SP_MSL;
 	sspa_sp &= ~SSPA_SP_S_EN;
 	sspa_sp |= SSPA_SP_WEN;
-	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+	__raw_writel(sspa_sp, sspa->tx_base + SSPA_SP);
 }
 
 static void mmp_sspa_rx_enable(struct sspa_priv *sspa)
@@ -75,7 +68,7 @@ static void mmp_sspa_rx_enable(struct sspa_priv *sspa)
 
 	sspa_sp |= SSPA_SP_S_EN;
 	sspa_sp |= SSPA_SP_WEN;
-	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+	__raw_writel(sspa_sp, sspa->rx_base + SSPA_SP);
 }
 
 static void mmp_sspa_rx_disable(struct sspa_priv *sspa)
@@ -84,7 +77,7 @@ static void mmp_sspa_rx_disable(struct sspa_priv *sspa)
 
 	sspa_sp &= ~SSPA_SP_S_EN;
 	sspa_sp |= SSPA_SP_WEN;
-	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+	__raw_writel(sspa_sp, sspa->rx_base + SSPA_SP);
 }
 
 static int mmp_sspa_startup(struct snd_pcm_substream *substream,
@@ -105,7 +98,6 @@ static void mmp_sspa_shutdown(struct snd_pcm_substream *substream,
 
 	clk_disable_unprepare(sspa->clk);
 	clk_disable_unprepare(sspa->sysclk);
-
 }
 
 /*
@@ -115,8 +107,12 @@ static int mmp_sspa_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
 				    int clk_id, unsigned int freq, int dir)
 {
 	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(cpu_dai);
+	struct device *dev = cpu_dai->component->dev;
 	int ret = 0;
 
+	if (dev->of_node)
+		return -ENOTSUPP;
+
 	switch (clk_id) {
 	case MMP_SSPA_CLK_AUDIO:
 		ret = clk_set_rate(sspa->audio_clk, freq);
@@ -139,8 +135,12 @@ static int mmp_sspa_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,
 				 unsigned int freq_out)
 {
 	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(cpu_dai);
+	struct device *dev = cpu_dai->component->dev;
 	int ret = 0;
 
+	if (dev->of_node)
+		return -ENOTSUPP;
+
 	switch (pll_id) {
 	case MMP_SYSCLK:
 		ret = clk_set_rate(sspa->sysclk, freq_out);
@@ -213,6 +213,7 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
 	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);
+	struct device *dev = dai->component->dev;
 	u32 sspa_ctrl = sspa->ctrl;
 	int bits;
 	int bitval;
@@ -238,7 +239,7 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	if (params_channels(params) == 2)
+	if (dev->of_node || params_channels(params) == 2)
 		sspa_ctrl |= SSPA_CTL_XPH;
 
 	sspa_ctrl &= ~SSPA_CTL_XWDLEN1_MASK;
@@ -256,12 +257,17 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 	sspa->sp &= ~SSPA_TXSP_FPER_MASK;
 	sspa->sp |= SSPA_TXSP_FPER(bits * 2 - 1);
 
+	if (dev->of_node) {
+		clk_set_rate(sspa->clk, params_rate(params) *
+					params_channels(params) * bits);
+	}
+
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		mmp_sspa_write_reg(sspa, SSPA_TXCTL, sspa_ctrl);
-		mmp_sspa_write_reg(sspa, SSPA_TXFIFO_LL, 0x1);
+		__raw_writel(sspa_ctrl, sspa->tx_base + SSPA_CTL);
+		__raw_writel(0x1, sspa->tx_base + SSPA_FIFO_UL);
 	} else {
-		mmp_sspa_write_reg(sspa, SSPA_RXCTL, sspa_ctrl);
-		mmp_sspa_write_reg(sspa, SSPA_RXFIFO_UL, 0x0);
+		__raw_writel(sspa_ctrl, sspa->rx_base + SSPA_CTL);
+		__raw_writel(0x0, sspa->rx_base + SSPA_FIFO_UL);
 	}
 
 	return 0;
@@ -410,19 +416,19 @@ static int mmp_sspa_open(struct snd_soc_component *component,
 	pm_runtime_get_sync(component->dev);
 
 	/* we can only change the settings if the port is not in use */
-	if ((mmp_sspa_read_reg(sspa, SSPA_TXSP) & SSPA_SP_S_EN) ||
-	    (mmp_sspa_read_reg(sspa, SSPA_RXSP) & SSPA_SP_S_EN)) {
+	if ((__raw_readl(sspa->tx_base + SSPA_SP) & SSPA_SP_S_EN) ||
+	    (__raw_readl(sspa->rx_base + SSPA_SP) & SSPA_SP_S_EN)) {
 		dev_err(component->dev,
 			"can't change hardware dai format: stream is in use\n");
 		return -EBUSY;
 	}
 
-	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa->sp);
-	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa->sp);
+	__raw_writel(sspa->sp, sspa->tx_base + SSPA_SP);
+	__raw_writel(sspa->sp, sspa->rx_base + SSPA_SP);
 
 	sspa->sp &= ~(SSPA_SP_S_RST | SSPA_SP_FFLUSH);
-	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa->sp);
-	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa->sp);
+	__raw_writel(sspa->sp, sspa->tx_base + SSPA_SP);
+	__raw_writel(sspa->sp, sspa->rx_base + SSPA_SP);
 
 	/*
 	 * FIXME: hw issue, for the tx serial port,
@@ -431,10 +437,10 @@ static int mmp_sspa_open(struct snd_soc_component *component,
 	 * The master/slave mode has been set in the
 	 * rx port.
 	 */
-	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa->sp & ~SSPA_SP_MSL);
+	__raw_writel(sspa->sp & ~SSPA_SP_MSL, sspa->tx_base + SSPA_SP);
 
-	mmp_sspa_write_reg(sspa, SSPA_TXCTL, sspa->ctrl);
-	mmp_sspa_write_reg(sspa, SSPA_RXCTL, sspa->ctrl);
+	__raw_writel(sspa->ctrl, sspa->tx_base + SSPA_CTL);
+	__raw_writel(sspa->ctrl, sspa->rx_base + SSPA_CTL);
 
 	return 0;
 }
@@ -462,22 +468,51 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	if (!sspa)
 		return -ENOMEM;
 
-	sspa->mmio_base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(sspa->mmio_base))
-		return PTR_ERR(sspa->mmio_base);
+	if (pdev->dev.of_node) {
+		sspa->rx_base = devm_platform_ioremap_resource(pdev, 0);
+		if (IS_ERR(sspa->rx_base))
+			return PTR_ERR(sspa->rx_base);
 
-	sspa->clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(sspa->clk))
-		return PTR_ERR(sspa->clk);
+		sspa->tx_base = devm_platform_ioremap_resource(pdev, 1);
+		if (IS_ERR(sspa->tx_base))
+			return PTR_ERR(sspa->tx_base);
 
-	sspa->audio_clk = clk_get(NULL, "mmp-audio");
-	if (IS_ERR(sspa->audio_clk))
-		return PTR_ERR(sspa->audio_clk);
+		sspa->clk = devm_clk_get(&pdev->dev, "bitclk");
+		if (IS_ERR(sspa->clk))
+			return PTR_ERR(sspa->clk);
 
-	sspa->sysclk = clk_get(NULL, "mmp-sysclk");
-	if (IS_ERR(sspa->sysclk)) {
-		clk_put(sspa->audio_clk);
-		return PTR_ERR(sspa->sysclk);
+		sspa->audio_clk = devm_clk_get(&pdev->dev, "audio");
+		if (IS_ERR(sspa->audio_clk))
+			return PTR_ERR(sspa->audio_clk);
+	} else {
+		struct resource *res;
+
+		res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+		if (res == NULL)
+			return -ENODEV;
+
+		sspa->rx_base = devm_ioremap(&pdev->dev, res->start, 0x30);
+		if (IS_ERR(sspa->rx_base))
+			return PTR_ERR(sspa->rx_base);
+
+		sspa->tx_base = devm_ioremap(&pdev->dev,
+					     res->start + 0x80, 0x30);
+		if (IS_ERR(sspa->tx_base))
+			return PTR_ERR(sspa->tx_base);
+
+		sspa->clk = devm_clk_get(&pdev->dev, NULL);
+		if (IS_ERR(sspa->clk))
+			return PTR_ERR(sspa->clk);
+
+		sspa->audio_clk = clk_get(NULL, "mmp-audio");
+		if (IS_ERR(sspa->audio_clk))
+			return PTR_ERR(sspa->audio_clk);
+
+		sspa->sysclk = clk_get(NULL, "mmp-sysclk");
+		if (IS_ERR(sspa->sysclk)) {
+			clk_put(sspa->audio_clk);
+			return PTR_ERR(sspa->sysclk);
+		}
 	}
 	pm_runtime_enable(&pdev->dev);
 	clk_prepare_enable(sspa->audio_clk);
@@ -486,8 +521,8 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	sspa->playback_dma_data.maxburst = 4;
 	sspa->capture_dma_data.maxburst = 4;
 	/* You know, these addresses are actually ignored. */
-	sspa->playback_dma_data.addr = SSPA_TXD;
-	sspa->capture_dma_data.addr = SSPA_RXD;
+	sspa->capture_dma_data.addr = SSPA_D;
+	sspa->playback_dma_data.addr = 0x80 + SSPA_D;
 
 	if (pdev->dev.of_node) {
 		int ret;
@@ -508,14 +543,28 @@ static int asoc_mmp_sspa_remove(struct platform_device *pdev)
 
 	clk_disable_unprepare(sspa->audio_clk);
 	pm_runtime_disable(&pdev->dev);
+
+	if (pdev->dev.of_node)
+		return 0;
+
 	clk_put(sspa->audio_clk);
 	clk_put(sspa->sysclk);
 	return 0;
 }
 
+#ifdef CONFIG_OF
+static const struct of_device_id mmp_sspa_of_match[] = {
+	{ .compatible = "marvell,mmp-sspa" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, mmp_sspa_of_match);
+#endif
+
 static struct platform_driver asoc_mmp_sspa_driver = {
 	.driver = {
 		.name = "mmp-sspa-dai",
+		.of_match_table = of_match_ptr(mmp_sspa_of_match),
 	},
 	.probe = asoc_mmp_sspa_probe,
 	.remove = asoc_mmp_sspa_remove,

commit 39ec7e9b699910792468cf41a179d9930052e8ff
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Mon May 11 23:01:32 2020 +0200

    ASoC: mmp-sspa: Set appropriate bus format for given bit width
    
    The values set by set_dai_fmt() and hw_params() seem to be tailored only
    for 32-bit formats. Negotiate the correct ones in hw_params() callback
    instead.
    
    This was essentially copied from the OLPC kernel driver and tested to
    fix wrong audio output for non-32bit formats. The documentation is not
    available.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200511210134.1224532-10-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 9cb17c4fb0c8..86277471974a 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -191,8 +191,6 @@ static int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 
 	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 	case SND_SOC_DAIFMT_I2S:
-		sspa->sp |= SSPA_TXSP_FPER(63);
-		sspa->sp |= SSPA_SP_FWID(31);
 		sspa->ctrl |= SSPA_CTL_XDATDLY(1);
 		break;
 	default:
@@ -216,30 +214,48 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 {
 	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);
 	u32 sspa_ctrl = sspa->ctrl;
-
-	sspa_ctrl &= ~SSPA_CTL_XFRLEN1_MASK;
-	sspa_ctrl |= SSPA_CTL_XFRLEN1(params_channels(params) - 1);
-	sspa_ctrl &= ~SSPA_CTL_XWDLEN1_MASK;
-	sspa_ctrl |= SSPA_CTL_XWDLEN1(SSPA_CTL_32_BITS);
-	sspa_ctrl &= ~SSPA_CTL_XSSZ1_MASK;
+	int bits;
+	int bitval;
 
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S8:
-		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_8_BITS);
+		bits = 8;
+		bitval = SSPA_CTL_8_BITS;
 		break;
 	case SNDRV_PCM_FORMAT_S16_LE:
-		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_16_BITS);
+		bits = 16;
+		bitval = SSPA_CTL_16_BITS;
 		break;
 	case SNDRV_PCM_FORMAT_S24_3LE:
-		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_24_BITS);
+		bits = 24;
+		bitval = SSPA_CTL_24_BITS;
 		break;
 	case SNDRV_PCM_FORMAT_S32_LE:
-		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_32_BITS);
+		bits = 32;
+		bitval = SSPA_CTL_32_BITS;
 		break;
 	default:
 		return -EINVAL;
 	}
 
+	if (params_channels(params) == 2)
+		sspa_ctrl |= SSPA_CTL_XPH;
+
+	sspa_ctrl &= ~SSPA_CTL_XWDLEN1_MASK;
+	sspa_ctrl |= SSPA_CTL_XWDLEN1(bitval);
+
+	sspa_ctrl &= ~SSPA_CTL_XSSZ1_MASK;
+	sspa_ctrl |= SSPA_CTL_XSSZ1(bitval);
+
+	sspa_ctrl &= ~SSPA_CTL_XSSZ2_MASK;
+	sspa_ctrl |= SSPA_CTL_XSSZ2(bitval);
+
+	sspa->sp &= ~SSPA_SP_FWID_MASK;
+	sspa->sp |= SSPA_SP_FWID(bits - 1);
+
+	sspa->sp &= ~SSPA_TXSP_FPER_MASK;
+	sspa->sp |= SSPA_TXSP_FPER(bits * 2 - 1);
+
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		mmp_sspa_write_reg(sspa, SSPA_TXCTL, sspa_ctrl);
 		mmp_sspa_write_reg(sspa, SSPA_TXFIFO_LL, 0x1);

commit 7d98cc648253c362ebfc582b11095a0e3f001896
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Mon May 11 23:01:31 2020 +0200

    ASoC: mmp-sspa: Add support for the runtime power management
    
    Only turn on the Audio island when it's in use.
    
    This requires keeping track of control register contents instead of
    reloading them back from hardware, because they're lost when the power is
    off.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200511210134.1224532-9-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index a66e594b1072..9cb17c4fb0c8 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -13,6 +13,7 @@
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <linux/dmaengine.h>
+#include <linux/pm_runtime.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -33,8 +34,9 @@ struct sspa_priv {
 	struct clk *clk;
 	struct clk *audio_clk;
 	struct clk *sysclk;
-	int dai_fmt;
 	int running_cnt;
+	u32 sp;
+	u32 ctrl;
 };
 
 static void mmp_sspa_write_reg(struct sspa_priv *sspa, u32 reg, u32 val)
@@ -49,9 +51,9 @@ static u32 mmp_sspa_read_reg(struct sspa_priv *sspa, u32 reg)
 
 static void mmp_sspa_tx_enable(struct sspa_priv *sspa)
 {
-	unsigned int sspa_sp;
+	unsigned int sspa_sp = sspa->sp;
 
-	sspa_sp = mmp_sspa_read_reg(sspa, SSPA_TXSP);
+	sspa_sp &= ~SSPA_SP_MSL;
 	sspa_sp |= SSPA_SP_S_EN;
 	sspa_sp |= SSPA_SP_WEN;
 	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
@@ -59,9 +61,9 @@ static void mmp_sspa_tx_enable(struct sspa_priv *sspa)
 
 static void mmp_sspa_tx_disable(struct sspa_priv *sspa)
 {
-	unsigned int sspa_sp;
+	unsigned int sspa_sp = sspa->sp;
 
-	sspa_sp = mmp_sspa_read_reg(sspa, SSPA_TXSP);
+	sspa_sp &= ~SSPA_SP_MSL;
 	sspa_sp &= ~SSPA_SP_S_EN;
 	sspa_sp |= SSPA_SP_WEN;
 	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
@@ -69,9 +71,8 @@ static void mmp_sspa_tx_disable(struct sspa_priv *sspa)
 
 static void mmp_sspa_rx_enable(struct sspa_priv *sspa)
 {
-	unsigned int sspa_sp;
+	unsigned int sspa_sp = sspa->sp;
 
-	sspa_sp = mmp_sspa_read_reg(sspa, SSPA_RXSP);
 	sspa_sp |= SSPA_SP_S_EN;
 	sspa_sp |= SSPA_SP_WEN;
 	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
@@ -79,9 +80,8 @@ static void mmp_sspa_rx_enable(struct sspa_priv *sspa)
 
 static void mmp_sspa_rx_disable(struct sspa_priv *sspa)
 {
-	unsigned int sspa_sp;
+	unsigned int sspa_sp = sspa->sp;
 
-	sspa_sp = mmp_sspa_read_reg(sspa, SSPA_RXSP);
 	sspa_sp &= ~SSPA_SP_S_EN;
 	sspa_sp |= SSPA_SP_WEN;
 	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
@@ -160,35 +160,20 @@ static int mmp_sspa_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,
 }
 
 /*
- * Set up the sspa dai format. The sspa port must be inactive
- * before calling this function as the physical
- * interface format is changed.
+ * Set up the sspa dai format.
  */
 static int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 				 unsigned int fmt)
 {
 	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(cpu_dai);
-	u32 sspa_sp, sspa_ctrl;
-
-	/* check if we need to change anything at all */
-	if (sspa->dai_fmt == fmt)
-		return 0;
-
-	/* we can only change the settings if the port is not in use */
-	if ((mmp_sspa_read_reg(sspa, SSPA_TXSP) & SSPA_SP_S_EN) ||
-	    (mmp_sspa_read_reg(sspa, SSPA_RXSP) & SSPA_SP_S_EN)) {
-		dev_err(cpu_dai->dev,
-			"can't change hardware dai format: stream is in use\n");
-		return -EINVAL;
-	}
 
 	/* reset port settings */
-	sspa_sp   = SSPA_SP_WEN | SSPA_SP_S_RST | SSPA_SP_FFLUSH;
-	sspa_ctrl = 0;
+	sspa->sp   = SSPA_SP_WEN | SSPA_SP_S_RST | SSPA_SP_FFLUSH;
+	sspa->ctrl = 0;
 
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
-		sspa_sp |= SSPA_SP_MSL;
+		sspa->sp |= SSPA_SP_MSL;
 		break;
 	case SND_SOC_DAIFMT_CBM_CFM:
 		break;
@@ -198,7 +183,7 @@ static int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 
 	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
 	case SND_SOC_DAIFMT_NB_NF:
-		sspa_sp |= SSPA_SP_FSP;
+		sspa->sp |= SSPA_SP_FSP;
 		break;
 	default:
 		return -EINVAL;
@@ -206,39 +191,18 @@ static int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 
 	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 	case SND_SOC_DAIFMT_I2S:
-		sspa_sp |= SSPA_TXSP_FPER(63);
-		sspa_sp |= SSPA_SP_FWID(31);
-		sspa_ctrl |= SSPA_CTL_XDATDLY(1);
+		sspa->sp |= SSPA_TXSP_FPER(63);
+		sspa->sp |= SSPA_SP_FWID(31);
+		sspa->ctrl |= SSPA_CTL_XDATDLY(1);
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
-	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
-
-	sspa_sp &= ~(SSPA_SP_S_RST | SSPA_SP_FFLUSH);
-	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
-	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
-
-	/*
-	 * FIXME: hw issue, for the tx serial port,
-	 * can not config the master/slave mode;
-	 * so must clean this bit.
-	 * The master/slave mode has been set in the
-	 * rx port.
-	 */
-	sspa_sp &= ~SSPA_SP_MSL;
-	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
-
-	mmp_sspa_write_reg(sspa, SSPA_TXCTL, sspa_ctrl);
-	mmp_sspa_write_reg(sspa, SSPA_RXCTL, sspa_ctrl);
-
 	/* Since we are configuring the timings for the format by hand
 	 * we have to defer some things until hw_params() where we
 	 * know parameters like the sample size.
 	 */
-	sspa->dai_fmt = fmt;
 	return 0;
 }
 
@@ -251,12 +215,7 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
 	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);
-	u32 sspa_ctrl;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		sspa_ctrl = mmp_sspa_read_reg(sspa, SSPA_TXCTL);
-	else
-		sspa_ctrl = mmp_sspa_read_reg(sspa, SSPA_RXCTL);
+	u32 sspa_ctrl = sspa->ctrl;
 
 	sspa_ctrl &= ~SSPA_CTL_XFRLEN1_MASK;
 	sspa_ctrl |= SSPA_CTL_XFRLEN1(params_channels(params) - 1);
@@ -427,9 +386,55 @@ static int mmp_pcm_mmap(struct snd_soc_component *component,
 		vma->vm_end - vma->vm_start, vma->vm_page_prot);
 }
 
+static int mmp_sspa_open(struct snd_soc_component *component,
+			 struct snd_pcm_substream *substream)
+{
+	struct sspa_priv *sspa = snd_soc_component_get_drvdata(component);
+
+	pm_runtime_get_sync(component->dev);
+
+	/* we can only change the settings if the port is not in use */
+	if ((mmp_sspa_read_reg(sspa, SSPA_TXSP) & SSPA_SP_S_EN) ||
+	    (mmp_sspa_read_reg(sspa, SSPA_RXSP) & SSPA_SP_S_EN)) {
+		dev_err(component->dev,
+			"can't change hardware dai format: stream is in use\n");
+		return -EBUSY;
+	}
+
+	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa->sp);
+	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa->sp);
+
+	sspa->sp &= ~(SSPA_SP_S_RST | SSPA_SP_FFLUSH);
+	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa->sp);
+	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa->sp);
+
+	/*
+	 * FIXME: hw issue, for the tx serial port,
+	 * can not config the master/slave mode;
+	 * so must clean this bit.
+	 * The master/slave mode has been set in the
+	 * rx port.
+	 */
+	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa->sp & ~SSPA_SP_MSL);
+
+	mmp_sspa_write_reg(sspa, SSPA_TXCTL, sspa->ctrl);
+	mmp_sspa_write_reg(sspa, SSPA_RXCTL, sspa->ctrl);
+
+	return 0;
+}
+
+static int mmp_sspa_close(struct snd_soc_component *component,
+			  struct snd_pcm_substream *substream)
+{
+	pm_runtime_put_sync(component->dev);
+	return 0;
+}
+
 static const struct snd_soc_component_driver mmp_sspa_component = {
 	.name		= "mmp-sspa",
 	.mmap		= mmp_pcm_mmap,
+	.open		= mmp_sspa_open,
+	.close		= mmp_sspa_close,
 };
 
 static int asoc_mmp_sspa_probe(struct platform_device *pdev)
@@ -458,8 +463,8 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 		clk_put(sspa->audio_clk);
 		return PTR_ERR(sspa->sysclk);
 	}
+	pm_runtime_enable(&pdev->dev);
 	clk_prepare_enable(sspa->audio_clk);
-	sspa->dai_fmt = (unsigned int) -1;
 	platform_set_drvdata(pdev, sspa);
 
 	sspa->playback_dma_data.maxburst = 4;
@@ -486,6 +491,7 @@ static int asoc_mmp_sspa_remove(struct platform_device *pdev)
 	struct sspa_priv *sspa = platform_get_drvdata(pdev);
 
 	clk_disable_unprepare(sspa->audio_clk);
+	pm_runtime_disable(&pdev->dev);
 	clk_put(sspa->audio_clk);
 	clk_put(sspa->sysclk);
 	return 0;

commit 8ecdcac8792b6787ecb2341d25cb82165cf0129d
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Mon May 11 23:01:30 2020 +0200

    ASoC: mmp-sspa: Prepare/unprepare the clocks
    
    The driver enables the clocks without preparing them and disables
    without unpreparing afterwards. Fix that.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200511210134.1224532-8-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 7a706b1d2588..a66e594b1072 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -92,8 +92,8 @@ static int mmp_sspa_startup(struct snd_pcm_substream *substream,
 {
 	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);
 
-	clk_enable(sspa->sysclk);
-	clk_enable(sspa->clk);
+	clk_prepare_enable(sspa->sysclk);
+	clk_prepare_enable(sspa->clk);
 
 	return 0;
 }
@@ -103,8 +103,8 @@ static void mmp_sspa_shutdown(struct snd_pcm_substream *substream,
 {
 	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);
 
-	clk_disable(sspa->clk);
-	clk_disable(sspa->sysclk);
+	clk_disable_unprepare(sspa->clk);
+	clk_disable_unprepare(sspa->sysclk);
 
 }
 
@@ -458,7 +458,7 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 		clk_put(sspa->audio_clk);
 		return PTR_ERR(sspa->sysclk);
 	}
-	clk_enable(sspa->audio_clk);
+	clk_prepare_enable(sspa->audio_clk);
 	sspa->dai_fmt = (unsigned int) -1;
 	platform_set_drvdata(pdev, sspa);
 
@@ -485,7 +485,7 @@ static int asoc_mmp_sspa_remove(struct platform_device *pdev)
 {
 	struct sspa_priv *sspa = platform_get_drvdata(pdev);
 
-	clk_disable(sspa->audio_clk);
+	clk_disable_unprepare(sspa->audio_clk);
 	clk_put(sspa->audio_clk);
 	clk_put(sspa->sysclk);
 	return 0;

commit 3c4e89df3b45348dc0ee01a2ef1be710f7424ff7
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Mon May 11 23:01:29 2020 +0200

    ASoC: mmp-sspa: Remove the embedded struct ssp_device
    
    The "serial port" it represents is actually a SPI controller -- it's not
    clear why would the audio serial interface embed it. We're only using
    the mmio_base and clk fields.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200511210134.1224532-7-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 6e4b63d0c589..7a706b1d2588 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -11,7 +11,6 @@
 #include <linux/delay.h>
 #include <linux/clk.h>
 #include <linux/slab.h>
-#include <linux/pxa2xx_ssp.h>
 #include <linux/io.h>
 #include <linux/dmaengine.h>
 
@@ -28,26 +27,27 @@
  * SSPA audio private data
  */
 struct sspa_priv {
-	struct ssp_device *sspa;
+	void __iomem *mmio_base;
 	struct snd_dmaengine_dai_dma_data playback_dma_data;
 	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct clk *clk;
 	struct clk *audio_clk;
 	struct clk *sysclk;
 	int dai_fmt;
 	int running_cnt;
 };
 
-static void mmp_sspa_write_reg(struct ssp_device *sspa, u32 reg, u32 val)
+static void mmp_sspa_write_reg(struct sspa_priv *sspa, u32 reg, u32 val)
 {
 	__raw_writel(val, sspa->mmio_base + reg);
 }
 
-static u32 mmp_sspa_read_reg(struct ssp_device *sspa, u32 reg)
+static u32 mmp_sspa_read_reg(struct sspa_priv *sspa, u32 reg)
 {
 	return __raw_readl(sspa->mmio_base + reg);
 }
 
-static void mmp_sspa_tx_enable(struct ssp_device *sspa)
+static void mmp_sspa_tx_enable(struct sspa_priv *sspa)
 {
 	unsigned int sspa_sp;
 
@@ -57,7 +57,7 @@ static void mmp_sspa_tx_enable(struct ssp_device *sspa)
 	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
 }
 
-static void mmp_sspa_tx_disable(struct ssp_device *sspa)
+static void mmp_sspa_tx_disable(struct sspa_priv *sspa)
 {
 	unsigned int sspa_sp;
 
@@ -67,7 +67,7 @@ static void mmp_sspa_tx_disable(struct ssp_device *sspa)
 	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
 }
 
-static void mmp_sspa_rx_enable(struct ssp_device *sspa)
+static void mmp_sspa_rx_enable(struct sspa_priv *sspa)
 {
 	unsigned int sspa_sp;
 
@@ -77,7 +77,7 @@ static void mmp_sspa_rx_enable(struct ssp_device *sspa)
 	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
 }
 
-static void mmp_sspa_rx_disable(struct ssp_device *sspa)
+static void mmp_sspa_rx_disable(struct sspa_priv *sspa)
 {
 	unsigned int sspa_sp;
 
@@ -90,10 +90,10 @@ static void mmp_sspa_rx_disable(struct ssp_device *sspa)
 static int mmp_sspa_startup(struct snd_pcm_substream *substream,
 	struct snd_soc_dai *dai)
 {
-	struct sspa_priv *priv = snd_soc_dai_get_drvdata(dai);
+	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);
 
-	clk_enable(priv->sysclk);
-	clk_enable(priv->sspa->clk);
+	clk_enable(sspa->sysclk);
+	clk_enable(sspa->clk);
 
 	return 0;
 }
@@ -101,10 +101,10 @@ static int mmp_sspa_startup(struct snd_pcm_substream *substream,
 static void mmp_sspa_shutdown(struct snd_pcm_substream *substream,
 	struct snd_soc_dai *dai)
 {
-	struct sspa_priv *priv = snd_soc_dai_get_drvdata(dai);
+	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);
 
-	clk_disable(priv->sspa->clk);
-	clk_disable(priv->sysclk);
+	clk_disable(sspa->clk);
+	clk_disable(sspa->sysclk);
 
 }
 
@@ -114,12 +114,12 @@ static void mmp_sspa_shutdown(struct snd_pcm_substream *substream,
 static int mmp_sspa_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
 				    int clk_id, unsigned int freq, int dir)
 {
-	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(cpu_dai);
 	int ret = 0;
 
 	switch (clk_id) {
 	case MMP_SSPA_CLK_AUDIO:
-		ret = clk_set_rate(priv->audio_clk, freq);
+		ret = clk_set_rate(sspa->audio_clk, freq);
 		if (ret)
 			return ret;
 		break;
@@ -138,17 +138,17 @@ static int mmp_sspa_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,
 				 int source, unsigned int freq_in,
 				 unsigned int freq_out)
 {
-	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(cpu_dai);
 	int ret = 0;
 
 	switch (pll_id) {
 	case MMP_SYSCLK:
-		ret = clk_set_rate(priv->sysclk, freq_out);
+		ret = clk_set_rate(sspa->sysclk, freq_out);
 		if (ret)
 			return ret;
 		break;
 	case MMP_SSPA_CLK:
-		ret = clk_set_rate(priv->sspa->clk, freq_out);
+		ret = clk_set_rate(sspa->clk, freq_out);
 		if (ret)
 			return ret;
 		break;
@@ -167,18 +167,17 @@ static int mmp_sspa_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,
 static int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 				 unsigned int fmt)
 {
-	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(cpu_dai);
-	struct ssp_device *sspa = sspa_priv->sspa;
+	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(cpu_dai);
 	u32 sspa_sp, sspa_ctrl;
 
 	/* check if we need to change anything at all */
-	if (sspa_priv->dai_fmt == fmt)
+	if (sspa->dai_fmt == fmt)
 		return 0;
 
 	/* we can only change the settings if the port is not in use */
 	if ((mmp_sspa_read_reg(sspa, SSPA_TXSP) & SSPA_SP_S_EN) ||
 	    (mmp_sspa_read_reg(sspa, SSPA_RXSP) & SSPA_SP_S_EN)) {
-		dev_err(sspa->dev,
+		dev_err(cpu_dai->dev,
 			"can't change hardware dai format: stream is in use\n");
 		return -EINVAL;
 	}
@@ -239,7 +238,7 @@ static int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 	 * we have to defer some things until hw_params() where we
 	 * know parameters like the sample size.
 	 */
-	sspa_priv->dai_fmt = fmt;
+	sspa->dai_fmt = fmt;
 	return 0;
 }
 
@@ -251,8 +250,7 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 			       struct snd_pcm_hw_params *params,
 			       struct snd_soc_dai *dai)
 {
-	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
-	struct ssp_device *sspa = sspa_priv->sspa;
+	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);
 	u32 sspa_ctrl;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
@@ -297,8 +295,7 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 static int mmp_sspa_trigger(struct snd_pcm_substream *substream, int cmd,
 			     struct snd_soc_dai *dai)
 {
-	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
-	struct ssp_device *sspa = sspa_priv->sspa;
+	struct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);
 	int ret = 0;
 
 	switch (cmd) {
@@ -311,25 +308,25 @@ static int mmp_sspa_trigger(struct snd_pcm_substream *substream, int cmd,
 		 * enabled or not; if has been enabled by another
 		 * stream, do not enable again.
 		 */
-		if (!sspa_priv->running_cnt)
+		if (!sspa->running_cnt)
 			mmp_sspa_rx_enable(sspa);
 
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 			mmp_sspa_tx_enable(sspa);
 
-		sspa_priv->running_cnt++;
+		sspa->running_cnt++;
 		break;
 
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		sspa_priv->running_cnt--;
+		sspa->running_cnt--;
 
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 			mmp_sspa_tx_disable(sspa);
 
 		/* have no capture stream, disable rx port */
-		if (!sspa_priv->running_cnt)
+		if (!sspa->running_cnt)
 			mmp_sspa_rx_disable(sspa);
 		break;
 
@@ -342,15 +339,14 @@ static int mmp_sspa_trigger(struct snd_pcm_substream *substream, int cmd,
 
 static int mmp_sspa_probe(struct snd_soc_dai *dai)
 {
-	struct sspa_priv *priv = dev_get_drvdata(dai->dev);
+	struct sspa_priv *sspa = dev_get_drvdata(dai->dev);
 
 	snd_soc_dai_init_dma_data(dai,
-				&priv->playback_dma_data,
-				&priv->capture_dma_data);
+				&sspa->playback_dma_data,
+				&sspa->capture_dma_data);
 
-	snd_soc_dai_set_drvdata(dai, priv);
+	snd_soc_dai_set_drvdata(dai, sspa);
 	return 0;
-
 }
 
 #define MMP_SSPA_RATES SNDRV_PCM_RATE_8000_192000
@@ -438,44 +434,39 @@ static const struct snd_soc_component_driver mmp_sspa_component = {
 
 static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 {
-	struct sspa_priv *priv;
+	struct sspa_priv *sspa;
 
-	priv = devm_kzalloc(&pdev->dev,
+	sspa = devm_kzalloc(&pdev->dev,
 				sizeof(struct sspa_priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->sspa = devm_kzalloc(&pdev->dev,
-				sizeof(struct ssp_device), GFP_KERNEL);
-	if (priv->sspa == NULL)
+	if (!sspa)
 		return -ENOMEM;
 
-	priv->sspa->mmio_base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(priv->sspa->mmio_base))
-		return PTR_ERR(priv->sspa->mmio_base);
+	sspa->mmio_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(sspa->mmio_base))
+		return PTR_ERR(sspa->mmio_base);
 
-	priv->sspa->clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(priv->sspa->clk))
-		return PTR_ERR(priv->sspa->clk);
+	sspa->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(sspa->clk))
+		return PTR_ERR(sspa->clk);
 
-	priv->audio_clk = clk_get(NULL, "mmp-audio");
-	if (IS_ERR(priv->audio_clk))
-		return PTR_ERR(priv->audio_clk);
+	sspa->audio_clk = clk_get(NULL, "mmp-audio");
+	if (IS_ERR(sspa->audio_clk))
+		return PTR_ERR(sspa->audio_clk);
 
-	priv->sysclk = clk_get(NULL, "mmp-sysclk");
-	if (IS_ERR(priv->sysclk)) {
-		clk_put(priv->audio_clk);
-		return PTR_ERR(priv->sysclk);
+	sspa->sysclk = clk_get(NULL, "mmp-sysclk");
+	if (IS_ERR(sspa->sysclk)) {
+		clk_put(sspa->audio_clk);
+		return PTR_ERR(sspa->sysclk);
 	}
-	clk_enable(priv->audio_clk);
-	priv->dai_fmt = (unsigned int) -1;
-	platform_set_drvdata(pdev, priv);
+	clk_enable(sspa->audio_clk);
+	sspa->dai_fmt = (unsigned int) -1;
+	platform_set_drvdata(pdev, sspa);
 
-	priv->playback_dma_data.maxburst = 4;
-	priv->capture_dma_data.maxburst = 4;
+	sspa->playback_dma_data.maxburst = 4;
+	sspa->capture_dma_data.maxburst = 4;
 	/* You know, these addresses are actually ignored. */
-	priv->playback_dma_data.addr = SSPA_TXD;
-	priv->capture_dma_data.addr = SSPA_RXD;
+	sspa->playback_dma_data.addr = SSPA_TXD;
+	sspa->capture_dma_data.addr = SSPA_RXD;
 
 	if (pdev->dev.of_node) {
 		int ret;
@@ -492,11 +483,11 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 
 static int asoc_mmp_sspa_remove(struct platform_device *pdev)
 {
-	struct sspa_priv *priv = platform_get_drvdata(pdev);
+	struct sspa_priv *sspa = platform_get_drvdata(pdev);
 
-	clk_disable(priv->audio_clk);
-	clk_put(priv->audio_clk);
-	clk_put(priv->sysclk);
+	clk_disable(sspa->audio_clk);
+	clk_put(sspa->audio_clk);
+	clk_put(sspa->sysclk);
 	return 0;
 }
 

commit 724da05378ba7af6e273451a2c3f565a3315a9db
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Mon May 11 23:01:28 2020 +0200

    ASoC: mmp-sspa: Add support for soc-generic-dmaengine-pcm
    
    This makes the driver usable with the mmp_tdma drier via
    soc-generic-dmaengine-pcm. This is conditionalized on DT node (support
    for DT is added by a later patch).
    
    A custom mmap callback that creates a NC mapping is used instead of the
    default WC one, because with write-combining some bytes don't seem to
    make it through for reasons unknown to me.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200511210134.1224532-6-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 421ffa9fa7b1..6e4b63d0c589 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -386,8 +386,54 @@ static struct snd_soc_dai_driver mmp_sspa_dai = {
 	.ops = &mmp_sspa_dai_ops,
 };
 
+#define MMP_PCM_INFO (SNDRV_PCM_INFO_MMAP |	\
+		SNDRV_PCM_INFO_MMAP_VALID |	\
+		SNDRV_PCM_INFO_INTERLEAVED |	\
+		SNDRV_PCM_INFO_PAUSE |		\
+		SNDRV_PCM_INFO_RESUME |		\
+		SNDRV_PCM_INFO_NO_PERIOD_WAKEUP)
+
+static const struct snd_pcm_hardware mmp_pcm_hardware[] = {
+	{
+		.info			= MMP_PCM_INFO,
+		.period_bytes_min	= 1024,
+		.period_bytes_max	= 2048,
+		.periods_min		= 2,
+		.periods_max		= 32,
+		.buffer_bytes_max	= 4096,
+		.fifo_size		= 32,
+	},
+	{
+		.info			= MMP_PCM_INFO,
+		.period_bytes_min	= 1024,
+		.period_bytes_max	= 2048,
+		.periods_min		= 2,
+		.periods_max		= 32,
+		.buffer_bytes_max	= 4096,
+		.fifo_size		= 32,
+	},
+};
+
+static const struct snd_dmaengine_pcm_config mmp_pcm_config = {
+	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+	.pcm_hardware = mmp_pcm_hardware,
+	.prealloc_buffer_size = 4096,
+};
+
+static int mmp_pcm_mmap(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream,
+			struct vm_area_struct *vma)
+{
+	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	return remap_pfn_range(vma, vma->vm_start,
+		substream->dma_buffer.addr >> PAGE_SHIFT,
+		vma->vm_end - vma->vm_start, vma->vm_page_prot);
+}
+
 static const struct snd_soc_component_driver mmp_sspa_component = {
 	.name		= "mmp-sspa",
+	.mmap		= mmp_pcm_mmap,
 };
 
 static int asoc_mmp_sspa_probe(struct platform_device *pdev)
@@ -425,10 +471,21 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	priv->dai_fmt = (unsigned int) -1;
 	platform_set_drvdata(pdev, priv);
 
+	priv->playback_dma_data.maxburst = 4;
+	priv->capture_dma_data.maxburst = 4;
 	/* You know, these addresses are actually ignored. */
 	priv->playback_dma_data.addr = SSPA_TXD;
 	priv->capture_dma_data.addr = SSPA_RXD;
 
+	if (pdev->dev.of_node) {
+		int ret;
+
+		ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
+						      &mmp_pcm_config, 0);
+		if (ret)
+			return ret;
+	}
+
 	return devm_snd_soc_register_component(&pdev->dev, &mmp_sspa_component,
 					       &mmp_sspa_dai, 1);
 }

commit c9aeda1c94973f835b3d1b6c785a414caaf935c3
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Mon May 11 23:01:27 2020 +0200

    ASoC: mmp-sspa: Get rid of dma_params and phys_base
    
    This makes things simpler. There's no reason not to just embed the struct
    snd_dmaengine_dai_dma_data in struct sspa_priv and do away with an
    unnecessary kmalloc(). While at that, we can initialize the
    snd_dmaengine_dai_dma_data structures earlier.
    
    Let's also stop offsetting the source/destination of the DMA transfer by
    phys_base. Firstly, it's never set and is always zero. Secondly, the
    hardware actually ignores it, at least on a MMP2 and MMP3.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200511210134.1224532-5-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 90a9bc81be80..421ffa9fa7b1 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -29,7 +29,8 @@
  */
 struct sspa_priv {
 	struct ssp_device *sspa;
-	struct snd_dmaengine_dai_dma_data *dma_params;
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
 	struct clk *audio_clk;
 	struct clk *sysclk;
 	int dai_fmt;
@@ -250,11 +251,8 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 			       struct snd_pcm_hw_params *params,
 			       struct snd_soc_dai *dai)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
 	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
 	struct ssp_device *sspa = sspa_priv->sspa;
-	struct snd_dmaengine_dai_dma_data *dma_params;
 	u32 sspa_ctrl;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
@@ -293,11 +291,6 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 		mmp_sspa_write_reg(sspa, SSPA_RXFIFO_UL, 0x0);
 	}
 
-	dma_params = &sspa_priv->dma_params[substream->stream];
-	dma_params->addr = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
-				(sspa->phys_base + SSPA_TXD) :
-				(sspa->phys_base + SSPA_RXD);
-	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_params);
 	return 0;
 }
 
@@ -351,6 +344,10 @@ static int mmp_sspa_probe(struct snd_soc_dai *dai)
 {
 	struct sspa_priv *priv = dev_get_drvdata(dai->dev);
 
+	snd_soc_dai_init_dma_data(dai,
+				&priv->playback_dma_data,
+				&priv->capture_dma_data);
+
 	snd_soc_dai_set_drvdata(dai, priv);
 	return 0;
 
@@ -407,12 +404,6 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	if (priv->sspa == NULL)
 		return -ENOMEM;
 
-	priv->dma_params = devm_kcalloc(&pdev->dev,
-			2, sizeof(struct snd_dmaengine_dai_dma_data),
-			GFP_KERNEL);
-	if (priv->dma_params == NULL)
-		return -ENOMEM;
-
 	priv->sspa->mmio_base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->sspa->mmio_base))
 		return PTR_ERR(priv->sspa->mmio_base);
@@ -434,6 +425,10 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	priv->dai_fmt = (unsigned int) -1;
 	platform_set_drvdata(pdev, priv);
 
+	/* You know, these addresses are actually ignored. */
+	priv->playback_dma_data.addr = SSPA_TXD;
+	priv->capture_dma_data.addr = SSPA_RXD;
+
 	return devm_snd_soc_register_component(&pdev->dev, &mmp_sspa_component,
 					       &mmp_sspa_dai, 1);
 }

commit 74fcfde748b26c68a8ab2791d9d73f698f7752d1
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Mon May 11 23:01:25 2020 +0200

    ASoC: mmp-sspa: Drop S20_3LE case
    
    It does nothing, because the corresponding bit s not flipped on in .formats
    and the audio SRAM DMA engine is not able to handle 20-bit transfers
    anyway.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200511210134.1224532-3-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 1ca6afe464c4..90a9bc81be80 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -275,9 +275,6 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 	case SNDRV_PCM_FORMAT_S16_LE:
 		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_16_BITS);
 		break;
-	case SNDRV_PCM_FORMAT_S20_3LE:
-		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_20_BITS);
-		break;
 	case SNDRV_PCM_FORMAT_S24_3LE:
 		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_24_BITS);
 		break;

commit 00a1aca23e71d83454485d55b5af32c5b367c99f
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Mon May 11 23:01:24 2020 +0200

    ASoC: mmp-sspa: Flip SNDRV_PCM_FMTBIT_S24_3LE on
    
    The hw_params() callback handles the 3-byte format, not
    SNDRV_PCM_FMTBIT_S24_LE.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Link: https://lore.kernel.org/r/20200511210134.1224532-2-lkundrak@v3.sk
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 3548a2634a63..1ca6afe464c4 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -362,7 +362,7 @@ static int mmp_sspa_probe(struct snd_soc_dai *dai)
 #define MMP_SSPA_RATES SNDRV_PCM_RATE_8000_192000
 #define MMP_SSPA_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
 		SNDRV_PCM_FMTBIT_S16_LE | \
-		SNDRV_PCM_FMTBIT_S24_LE | \
+		SNDRV_PCM_FMTBIT_S24_3LE | \
 		SNDRV_PCM_FMTBIT_S32_LE)
 
 static const struct snd_soc_dai_ops mmp_sspa_dai_ops = {

commit 8d8fef280c94869a4a96c2ac77aea435516fd838
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 23 14:19:49 2020 +0900

    ASoC: pxa: use asoc_rtd_to_cpu() / asoc_rtd_to_codec() macro for DAI pointer
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87k13bir62.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index e701637a9ae9..3548a2634a63 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -251,7 +251,7 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 			       struct snd_soc_dai *dai)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
 	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
 	struct ssp_device *sspa = sspa_priv->sspa;
 	struct snd_dmaengine_dai_dma_data *dma_params;

commit 4f3d957718e7f0ac2b033dbf48c7cddecd0a8dd3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Oct 18 13:54:25 2019 +0300

    spi: pxa2xx: No need to keep pointer to platform device
    
    There is no need to keep a pointer to the platform device. Currently there are
    no users of it directly, and if there will be in the future we may restore it
    from pointer to the struct device.
    
    Convert all users at the same time.
    
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20191018105429.82782-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index e3e5425b5c62..e701637a9ae9 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -177,7 +177,7 @@ static int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
 	/* we can only change the settings if the port is not in use */
 	if ((mmp_sspa_read_reg(sspa, SSPA_TXSP) & SSPA_SP_S_EN) ||
 	    (mmp_sspa_read_reg(sspa, SSPA_RXSP) & SSPA_SP_S_EN)) {
-		dev_err(&sspa->pdev->dev,
+		dev_err(sspa->dev,
 			"can't change hardware dai format: stream is in use\n");
 		return -EINVAL;
 	}

commit 72d09322e709c5c2d7112d6a19ec9f3846d3609d
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sat Jul 27 23:07:22 2019 +0800

    ASoC: mmp-sspa: use devm_platform_ioremap_resource() to simplify code
    
    Use devm_platform_ioremap_resource() to simplify the code a bit.
    This is detected by coccinelle.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lore.kernel.org/r/20190727150738.54764-19-yuehaibing@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 72f4364b2d20..e3e5425b5c62 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -399,7 +399,6 @@ static const struct snd_soc_component_driver mmp_sspa_component = {
 static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 {
 	struct sspa_priv *priv;
-	struct resource *res;
 
 	priv = devm_kzalloc(&pdev->dev,
 				sizeof(struct sspa_priv), GFP_KERNEL);
@@ -417,8 +416,7 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	if (priv->dma_params == NULL)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	priv->sspa->mmio_base = devm_ioremap_resource(&pdev->dev, res);
+	priv->sspa->mmio_base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->sspa->mmio_base))
 		return PTR_ERR(priv->sspa->mmio_base);
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 12d4513ebe8a..72f4364b2d20 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -1,23 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * linux/sound/soc/pxa/mmp-sspa.c
  * Base on pxa2xx-ssp.c
  *
  * Copyright (C) 2011 Marvell International Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
  */
 #include <linux/init.h>
 #include <linux/module.h>

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 7c998ea4ebee..12d4513ebe8a 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -425,8 +425,8 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	if (priv->sspa == NULL)
 		return -ENOMEM;
 
-	priv->dma_params = devm_kzalloc(&pdev->dev,
-			2 * sizeof(struct snd_dmaengine_dai_dma_data),
+	priv->dma_params = devm_kcalloc(&pdev->dev,
+			2, sizeof(struct snd_dmaengine_dai_dma_data),
 			GFP_KERNEL);
 	if (priv->dma_params == NULL)
 		return -ENOMEM;

commit 8b597ff47053c9f53384a3a26dcc4c4316a375e5
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Feb 23 14:37:38 2018 +0000

    ASoC: pxa: remove duplicated bit-wise or of SNDRV_PCM_FMTBIT_S24_LE
    
    Bit pattern SNDRV_PCM_FMTBIT_S24_LE is being bit-wise or'd twice; remove
    the redundant 2nd SNDRV_PCM_FMTBIT_S24_LE
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 64b85e30c1f8..7c998ea4ebee 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -377,7 +377,6 @@ static int mmp_sspa_probe(struct snd_soc_dai *dai)
 #define MMP_SSPA_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
 		SNDRV_PCM_FMTBIT_S16_LE | \
 		SNDRV_PCM_FMTBIT_S24_LE | \
-		SNDRV_PCM_FMTBIT_S24_LE | \
 		SNDRV_PCM_FMTBIT_S32_LE)
 
 static const struct snd_soc_dai_ops mmp_sspa_dai_ops = {

commit cb7534437956650ab0dcebf7a7b4795eb904d22a
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Thu Jul 13 01:05:08 2017 -0500

    ASoC: mmp-sspa: constify snd_soc_dai_ops structure
    
    This structure is only stored in the ops field of a snd_soc_dai_driver
    structure. That field is declared const, so snd_soc_dai_ops structures
    that have this property can be declared as const also.
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 9cc35012e6e5..64b85e30c1f8 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -380,7 +380,7 @@ static int mmp_sspa_probe(struct snd_soc_dai *dai)
 		SNDRV_PCM_FMTBIT_S24_LE | \
 		SNDRV_PCM_FMTBIT_S32_LE)
 
-static struct snd_soc_dai_ops mmp_sspa_dai_ops = {
+static const struct snd_soc_dai_ops mmp_sspa_dai_ops = {
 	.startup	= mmp_sspa_startup,
 	.shutdown	= mmp_sspa_shutdown,
 	.trigger	= mmp_sspa_trigger,

commit 17339f6099154678485244cc17d700f19ece0dc0
Author: Codrut Grosu <codrut.cristian.grosu@gmail.com>
Date:   Sat Feb 25 23:06:36 2017 +0200

    ASoC: pxa: Remove unneeded return statement in void function
    
    This was reported by checkpatch.pl
    
    Signed-off-by: Codrut Grosu <codrut.cristian.grosu@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index ca8b23f8c525..9cc35012e6e5 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -119,7 +119,6 @@ static void mmp_sspa_shutdown(struct snd_pcm_substream *substream,
 	clk_disable(priv->sspa->clk);
 	clk_disable(priv->sysclk);
 
-	return;
 }
 
 /*

commit e5b7d71aa5b32180adec49a17c752e577c68f740
Author: Andrea Adami <andrea.adami@gmail.com>
Date:   Fri May 6 17:27:34 2016 +0200

    ASoC: pxa: Fix module autoload for platform drivers
    
    These platform drivers are lacking MODULE_ALIAS so module autoloading
    doesn't work. Tested on corgi and poodle with kernel 4.4.
    
    Signed-off-by: Andrea Adami <andrea.adami@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index eca60c29791a..ca8b23f8c525 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -482,3 +482,4 @@ module_platform_driver(asoc_mmp_sspa_driver);
 MODULE_AUTHOR("Leo Yan <leoy@marvell.com>");
 MODULE_DESCRIPTION("MMP SSPA SoC Interface");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:mmp-sspa-dai");

commit 08d30ecc67ee1ef222ee1b92b342b9ce51d29a39
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:22:11 2014 +0200

    ASoC: pxa: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 5bf5f1f7cac5..eca60c29791a 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -472,7 +472,6 @@ static int asoc_mmp_sspa_remove(struct platform_device *pdev)
 static struct platform_driver asoc_mmp_sspa_driver = {
 	.driver = {
 		.name = "mmp-sspa-dai",
-		.owner = THIS_MODULE,
 	},
 	.probe = asoc_mmp_sspa_probe,
 	.remove = asoc_mmp_sspa_remove,

commit 9ff50721e47ab0abb8b93159170f67262886ef0d
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Sep 17 10:32:48 2013 +0530

    ASoC: mmp-sspa: Use devm_snd_soc_register_component
    
    devm_snd_soc_register_component makes code simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 41752a5fe3b0..5bf5f1f7cac5 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -455,8 +455,8 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	priv->dai_fmt = (unsigned int) -1;
 	platform_set_drvdata(pdev, priv);
 
-	return snd_soc_register_component(&pdev->dev, &mmp_sspa_component,
-					  &mmp_sspa_dai, 1);
+	return devm_snd_soc_register_component(&pdev->dev, &mmp_sspa_component,
+					       &mmp_sspa_dai, 1);
 }
 
 static int asoc_mmp_sspa_remove(struct platform_device *pdev)
@@ -466,7 +466,6 @@ static int asoc_mmp_sspa_remove(struct platform_device *pdev)
 	clk_disable(priv->audio_clk);
 	clk_put(priv->audio_clk);
 	clk_put(priv->sysclk);
-	snd_soc_unregister_component(&pdev->dev);
 	return 0;
 }
 

commit d65a14587a9be853a887a1407db133df1fb68e29
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Aug 12 10:42:39 2013 +0200

    ASoC: pxa: use snd_dmaengine_dai_dma_data
    
    Use snd_dmaengine_dai_dma_data for passing the dma parameters from
    clients to the pxa pcm lib. This does no functional change, it's just an
    intermedia step to migrate the pxa bits over to dmaengine.
    
    The calculation of dcmd is a transition hack which will be removed again
    in a later patch. It's just there to make the transition more readable.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 1605934d525e..41752a5fe3b0 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -27,12 +27,15 @@
 #include <linux/slab.h>
 #include <linux/pxa2xx_ssp.h>
 #include <linux/io.h>
+#include <linux/dmaengine.h>
+
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/initval.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/pxa2xx-lib.h>
+#include <sound/dmaengine_pcm.h>
 #include "mmp-sspa.h"
 
 /*
@@ -40,7 +43,7 @@
  */
 struct sspa_priv {
 	struct ssp_device *sspa;
-	struct pxa2xx_pcm_dma_params *dma_params;
+	struct snd_dmaengine_dai_dma_data *dma_params;
 	struct clk *audio_clk;
 	struct clk *sysclk;
 	int dai_fmt;
@@ -266,7 +269,7 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
 	struct ssp_device *sspa = sspa_priv->sspa;
-	struct pxa2xx_pcm_dma_params *dma_params;
+	struct snd_dmaengine_dai_dma_data *dma_params;
 	u32 sspa_ctrl;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
@@ -309,7 +312,7 @@ static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	dma_params = &sspa_priv->dma_params[substream->stream];
-	dma_params->dev_addr = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+	dma_params->addr = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
 				(sspa->phys_base + SSPA_TXD) :
 				(sspa->phys_base + SSPA_RXD);
 	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_params);
@@ -425,7 +428,8 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	priv->dma_params = devm_kzalloc(&pdev->dev,
-			2 * sizeof(struct pxa2xx_pcm_dma_params), GFP_KERNEL);
+			2 * sizeof(struct snd_dmaengine_dai_dma_data),
+			GFP_KERNEL);
 	if (priv->dma_params == NULL)
 		return -ENOMEM;
 

commit 0b4fa3374172c07691dcf568e72f63fb41e82561
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Tue Jul 23 20:01:57 2013 +0200

    ASoC: pxa: don't check resource with devm_ioremap_resource
    
    devm_ioremap_resource does sanity checks on the given resource. No need to
    duplicate this in the driver.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 62142ce367c7..1605934d525e 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -430,9 +430,6 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (res == NULL)
-		return -ENOMEM;
-
 	priv->sspa->mmio_base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(priv->sspa->mmio_base))
 		return PTR_ERR(priv->sspa->mmio_base);

commit 5d9ff402152fe9421c5ed86b4f651a8c62de7c7a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue May 14 22:19:52 2013 +0200

    ASoC: mmp-sspa: Staticize non exported struct
    
    The mmp_sspa_dai struct is only used in mmp-sspa.c, so make it static.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index a64779980177..62142ce367c7 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -388,7 +388,7 @@ static struct snd_soc_dai_ops mmp_sspa_dai_ops = {
 	.set_fmt	= mmp_sspa_set_dai_fmt,
 };
 
-struct snd_soc_dai_driver mmp_sspa_dai = {
+static struct snd_soc_dai_driver mmp_sspa_dai = {
 	.probe = mmp_sspa_probe,
 	.playback = {
 		.channels_min = 1,

commit 425f3708949a54aa2f01537eeb6fae33f937279b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 21 03:34:48 2013 -0700

    ASoC: switch over to use snd_soc_register_component() on mmp sspa
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 9140c4abafbc..a64779980177 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -405,6 +405,10 @@ struct snd_soc_dai_driver mmp_sspa_dai = {
 	.ops = &mmp_sspa_dai_ops,
 };
 
+static const struct snd_soc_component_driver mmp_sspa_component = {
+	.name		= "mmp-sspa",
+};
+
 static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 {
 	struct sspa_priv *priv;
@@ -450,7 +454,8 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	priv->dai_fmt = (unsigned int) -1;
 	platform_set_drvdata(pdev, priv);
 
-	return snd_soc_register_dai(&pdev->dev, &mmp_sspa_dai);
+	return snd_soc_register_component(&pdev->dev, &mmp_sspa_component,
+					  &mmp_sspa_dai, 1);
 }
 
 static int asoc_mmp_sspa_remove(struct platform_device *pdev)
@@ -460,7 +465,7 @@ static int asoc_mmp_sspa_remove(struct platform_device *pdev)
 	clk_disable(priv->audio_clk);
 	clk_put(priv->audio_clk);
 	clk_put(priv->sysclk);
-	snd_soc_unregister_dai(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
 	return 0;
 }
 

commit b25b5aa06667b01fee8fe2648d4ea9db32c87d1a
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Jan 21 11:09:26 2013 +0100

    ASoC: Convert to devm_ioremap_resource()
    
    Convert all uses of devm_request_and_ioremap() to the newly introduced
    devm_ioremap_resource() which provides more consistent error handling.
    
    devm_ioremap_resource() provides its own error messages so all explicit
    error messages can be removed from the failure code paths.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 41c3a09b53ea..9140c4abafbc 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -429,9 +429,9 @@ static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	if (res == NULL)
 		return -ENOMEM;
 
-	priv->sspa->mmio_base = devm_request_and_ioremap(&pdev->dev, res);
-	if (priv->sspa->mmio_base == NULL)
-		return -ENODEV;
+	priv->sspa->mmio_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->sspa->mmio_base))
+		return PTR_ERR(priv->sspa->mmio_base);
 
 	priv->sspa->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(priv->sspa->clk))

commit 570f6fe1c35481a2f70f848216978a68b96dc92a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Dec 7 09:26:17 2012 -0500

    ASoC: pxa: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
index 4d6cb8a30fc8..41c3a09b53ea 100644
--- a/sound/soc/pxa/mmp-sspa.c
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -405,7 +405,7 @@ struct snd_soc_dai_driver mmp_sspa_dai = {
 	.ops = &mmp_sspa_dai_ops,
 };
 
-static __devinit int asoc_mmp_sspa_probe(struct platform_device *pdev)
+static int asoc_mmp_sspa_probe(struct platform_device *pdev)
 {
 	struct sspa_priv *priv;
 	struct resource *res;
@@ -453,7 +453,7 @@ static __devinit int asoc_mmp_sspa_probe(struct platform_device *pdev)
 	return snd_soc_register_dai(&pdev->dev, &mmp_sspa_dai);
 }
 
-static int __devexit asoc_mmp_sspa_remove(struct platform_device *pdev)
+static int asoc_mmp_sspa_remove(struct platform_device *pdev)
 {
 	struct sspa_priv *priv = platform_get_drvdata(pdev);
 
@@ -470,7 +470,7 @@ static struct platform_driver asoc_mmp_sspa_driver = {
 		.owner = THIS_MODULE,
 	},
 	.probe = asoc_mmp_sspa_probe,
-	.remove = __devexit_p(asoc_mmp_sspa_remove),
+	.remove = asoc_mmp_sspa_remove,
 };
 
 module_platform_driver(asoc_mmp_sspa_driver);

commit fa375d42f0e531b7ca4316ea9fd5444e01d585e8
Author: Zhangfei Gao <zhangfei.gao@marvell.com>
Date:   Mon Jun 11 18:04:39 2012 +0800

    ASoC: mmp: add sspa support
    
    The SSPA is a configurable multi-channel audio serial (TDM) interface.
    It's configurable at runtime to support up to 128 channels and the
    number of bits per sample: 8, 12, 16, 20, 24 and 32 bits. It also
    support stereo format: I2S, left-justified or right-justified.
    
    Signed-off-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Leo Yan <leoy@marvell.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/pxa/mmp-sspa.c b/sound/soc/pxa/mmp-sspa.c
new file mode 100644
index 000000000000..4d6cb8a30fc8
--- /dev/null
+++ b/sound/soc/pxa/mmp-sspa.c
@@ -0,0 +1,480 @@
+/*
+ * linux/sound/soc/pxa/mmp-sspa.c
+ * Base on pxa2xx-ssp.c
+ *
+ * Copyright (C) 2011 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/pxa2xx_ssp.h>
+#include <linux/io.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/pxa2xx-lib.h>
+#include "mmp-sspa.h"
+
+/*
+ * SSPA audio private data
+ */
+struct sspa_priv {
+	struct ssp_device *sspa;
+	struct pxa2xx_pcm_dma_params *dma_params;
+	struct clk *audio_clk;
+	struct clk *sysclk;
+	int dai_fmt;
+	int running_cnt;
+};
+
+static void mmp_sspa_write_reg(struct ssp_device *sspa, u32 reg, u32 val)
+{
+	__raw_writel(val, sspa->mmio_base + reg);
+}
+
+static u32 mmp_sspa_read_reg(struct ssp_device *sspa, u32 reg)
+{
+	return __raw_readl(sspa->mmio_base + reg);
+}
+
+static void mmp_sspa_tx_enable(struct ssp_device *sspa)
+{
+	unsigned int sspa_sp;
+
+	sspa_sp = mmp_sspa_read_reg(sspa, SSPA_TXSP);
+	sspa_sp |= SSPA_SP_S_EN;
+	sspa_sp |= SSPA_SP_WEN;
+	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+}
+
+static void mmp_sspa_tx_disable(struct ssp_device *sspa)
+{
+	unsigned int sspa_sp;
+
+	sspa_sp = mmp_sspa_read_reg(sspa, SSPA_TXSP);
+	sspa_sp &= ~SSPA_SP_S_EN;
+	sspa_sp |= SSPA_SP_WEN;
+	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+}
+
+static void mmp_sspa_rx_enable(struct ssp_device *sspa)
+{
+	unsigned int sspa_sp;
+
+	sspa_sp = mmp_sspa_read_reg(sspa, SSPA_RXSP);
+	sspa_sp |= SSPA_SP_S_EN;
+	sspa_sp |= SSPA_SP_WEN;
+	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+}
+
+static void mmp_sspa_rx_disable(struct ssp_device *sspa)
+{
+	unsigned int sspa_sp;
+
+	sspa_sp = mmp_sspa_read_reg(sspa, SSPA_RXSP);
+	sspa_sp &= ~SSPA_SP_S_EN;
+	sspa_sp |= SSPA_SP_WEN;
+	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+}
+
+static int mmp_sspa_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+	clk_enable(priv->sysclk);
+	clk_enable(priv->sspa->clk);
+
+	return 0;
+}
+
+static void mmp_sspa_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+	clk_disable(priv->sspa->clk);
+	clk_disable(priv->sysclk);
+
+	return;
+}
+
+/*
+ * Set the SSP ports SYSCLK.
+ */
+static int mmp_sspa_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				    int clk_id, unsigned int freq, int dir)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (clk_id) {
+	case MMP_SSPA_CLK_AUDIO:
+		ret = clk_set_rate(priv->audio_clk, freq);
+		if (ret)
+			return ret;
+		break;
+	case MMP_SSPA_CLK_PLL:
+	case MMP_SSPA_CLK_VCXO:
+		/* not support yet */
+		return -EINVAL;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mmp_sspa_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,
+				 int source, unsigned int freq_in,
+				 unsigned int freq_out)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (pll_id) {
+	case MMP_SYSCLK:
+		ret = clk_set_rate(priv->sysclk, freq_out);
+		if (ret)
+			return ret;
+		break;
+	case MMP_SSPA_CLK:
+		ret = clk_set_rate(priv->sspa->clk, freq_out);
+		if (ret)
+			return ret;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/*
+ * Set up the sspa dai format. The sspa port must be inactive
+ * before calling this function as the physical
+ * interface format is changed.
+ */
+static int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+				 unsigned int fmt)
+{
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = sspa_priv->sspa;
+	u32 sspa_sp, sspa_ctrl;
+
+	/* check if we need to change anything at all */
+	if (sspa_priv->dai_fmt == fmt)
+		return 0;
+
+	/* we can only change the settings if the port is not in use */
+	if ((mmp_sspa_read_reg(sspa, SSPA_TXSP) & SSPA_SP_S_EN) ||
+	    (mmp_sspa_read_reg(sspa, SSPA_RXSP) & SSPA_SP_S_EN)) {
+		dev_err(&sspa->pdev->dev,
+			"can't change hardware dai format: stream is in use\n");
+		return -EINVAL;
+	}
+
+	/* reset port settings */
+	sspa_sp   = SSPA_SP_WEN | SSPA_SP_S_RST | SSPA_SP_FFLUSH;
+	sspa_ctrl = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		sspa_sp |= SSPA_SP_MSL;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		sspa_sp |= SSPA_SP_FSP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		sspa_sp |= SSPA_TXSP_FPER(63);
+		sspa_sp |= SSPA_SP_FWID(31);
+		sspa_ctrl |= SSPA_CTL_XDATDLY(1);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+
+	sspa_sp &= ~(SSPA_SP_S_RST | SSPA_SP_FFLUSH);
+	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+
+	/*
+	 * FIXME: hw issue, for the tx serial port,
+	 * can not config the master/slave mode;
+	 * so must clean this bit.
+	 * The master/slave mode has been set in the
+	 * rx port.
+	 */
+	sspa_sp &= ~SSPA_SP_MSL;
+	mmp_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+
+	mmp_sspa_write_reg(sspa, SSPA_TXCTL, sspa_ctrl);
+	mmp_sspa_write_reg(sspa, SSPA_RXCTL, sspa_ctrl);
+
+	/* Since we are configuring the timings for the format by hand
+	 * we have to defer some things until hw_params() where we
+	 * know parameters like the sample size.
+	 */
+	sspa_priv->dai_fmt = fmt;
+	return 0;
+}
+
+/*
+ * Set the SSPA audio DMA parameters and sample size.
+ * Can be called multiple times by oss emulation.
+ */
+static int mmp_sspa_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
+	struct ssp_device *sspa = sspa_priv->sspa;
+	struct pxa2xx_pcm_dma_params *dma_params;
+	u32 sspa_ctrl;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		sspa_ctrl = mmp_sspa_read_reg(sspa, SSPA_TXCTL);
+	else
+		sspa_ctrl = mmp_sspa_read_reg(sspa, SSPA_RXCTL);
+
+	sspa_ctrl &= ~SSPA_CTL_XFRLEN1_MASK;
+	sspa_ctrl |= SSPA_CTL_XFRLEN1(params_channels(params) - 1);
+	sspa_ctrl &= ~SSPA_CTL_XWDLEN1_MASK;
+	sspa_ctrl |= SSPA_CTL_XWDLEN1(SSPA_CTL_32_BITS);
+	sspa_ctrl &= ~SSPA_CTL_XSSZ1_MASK;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_8_BITS);
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_16_BITS);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_20_BITS);
+		break;
+	case SNDRV_PCM_FORMAT_S24_3LE:
+		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_24_BITS);
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		sspa_ctrl |= SSPA_CTL_XSSZ1(SSPA_CTL_32_BITS);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		mmp_sspa_write_reg(sspa, SSPA_TXCTL, sspa_ctrl);
+		mmp_sspa_write_reg(sspa, SSPA_TXFIFO_LL, 0x1);
+	} else {
+		mmp_sspa_write_reg(sspa, SSPA_RXCTL, sspa_ctrl);
+		mmp_sspa_write_reg(sspa, SSPA_RXFIFO_UL, 0x0);
+	}
+
+	dma_params = &sspa_priv->dma_params[substream->stream];
+	dma_params->dev_addr = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+				(sspa->phys_base + SSPA_TXD) :
+				(sspa->phys_base + SSPA_RXD);
+	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_params);
+	return 0;
+}
+
+static int mmp_sspa_trigger(struct snd_pcm_substream *substream, int cmd,
+			     struct snd_soc_dai *dai)
+{
+	struct sspa_priv *sspa_priv = snd_soc_dai_get_drvdata(dai);
+	struct ssp_device *sspa = sspa_priv->sspa;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/*
+		 * whatever playback or capture, must enable rx.
+		 * this is a hw issue, so need check if rx has been
+		 * enabled or not; if has been enabled by another
+		 * stream, do not enable again.
+		 */
+		if (!sspa_priv->running_cnt)
+			mmp_sspa_rx_enable(sspa);
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			mmp_sspa_tx_enable(sspa);
+
+		sspa_priv->running_cnt++;
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		sspa_priv->running_cnt--;
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			mmp_sspa_tx_disable(sspa);
+
+		/* have no capture stream, disable rx port */
+		if (!sspa_priv->running_cnt)
+			mmp_sspa_rx_disable(sspa);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int mmp_sspa_probe(struct snd_soc_dai *dai)
+{
+	struct sspa_priv *priv = dev_get_drvdata(dai->dev);
+
+	snd_soc_dai_set_drvdata(dai, priv);
+	return 0;
+
+}
+
+#define MMP_SSPA_RATES SNDRV_PCM_RATE_8000_192000
+#define MMP_SSPA_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
+		SNDRV_PCM_FMTBIT_S16_LE | \
+		SNDRV_PCM_FMTBIT_S24_LE | \
+		SNDRV_PCM_FMTBIT_S24_LE | \
+		SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_ops mmp_sspa_dai_ops = {
+	.startup	= mmp_sspa_startup,
+	.shutdown	= mmp_sspa_shutdown,
+	.trigger	= mmp_sspa_trigger,
+	.hw_params	= mmp_sspa_hw_params,
+	.set_sysclk	= mmp_sspa_set_dai_sysclk,
+	.set_pll	= mmp_sspa_set_dai_pll,
+	.set_fmt	= mmp_sspa_set_dai_fmt,
+};
+
+struct snd_soc_dai_driver mmp_sspa_dai = {
+	.probe = mmp_sspa_probe,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 128,
+		.rates = MMP_SSPA_RATES,
+		.formats = MMP_SSPA_FORMATS,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = MMP_SSPA_RATES,
+		.formats = MMP_SSPA_FORMATS,
+	},
+	.ops = &mmp_sspa_dai_ops,
+};
+
+static __devinit int asoc_mmp_sspa_probe(struct platform_device *pdev)
+{
+	struct sspa_priv *priv;
+	struct resource *res;
+
+	priv = devm_kzalloc(&pdev->dev,
+				sizeof(struct sspa_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->sspa = devm_kzalloc(&pdev->dev,
+				sizeof(struct ssp_device), GFP_KERNEL);
+	if (priv->sspa == NULL)
+		return -ENOMEM;
+
+	priv->dma_params = devm_kzalloc(&pdev->dev,
+			2 * sizeof(struct pxa2xx_pcm_dma_params), GFP_KERNEL);
+	if (priv->dma_params == NULL)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		return -ENOMEM;
+
+	priv->sspa->mmio_base = devm_request_and_ioremap(&pdev->dev, res);
+	if (priv->sspa->mmio_base == NULL)
+		return -ENODEV;
+
+	priv->sspa->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->sspa->clk))
+		return PTR_ERR(priv->sspa->clk);
+
+	priv->audio_clk = clk_get(NULL, "mmp-audio");
+	if (IS_ERR(priv->audio_clk))
+		return PTR_ERR(priv->audio_clk);
+
+	priv->sysclk = clk_get(NULL, "mmp-sysclk");
+	if (IS_ERR(priv->sysclk)) {
+		clk_put(priv->audio_clk);
+		return PTR_ERR(priv->sysclk);
+	}
+	clk_enable(priv->audio_clk);
+	priv->dai_fmt = (unsigned int) -1;
+	platform_set_drvdata(pdev, priv);
+
+	return snd_soc_register_dai(&pdev->dev, &mmp_sspa_dai);
+}
+
+static int __devexit asoc_mmp_sspa_remove(struct platform_device *pdev)
+{
+	struct sspa_priv *priv = platform_get_drvdata(pdev);
+
+	clk_disable(priv->audio_clk);
+	clk_put(priv->audio_clk);
+	clk_put(priv->sysclk);
+	snd_soc_unregister_dai(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver asoc_mmp_sspa_driver = {
+	.driver = {
+		.name = "mmp-sspa-dai",
+		.owner = THIS_MODULE,
+	},
+	.probe = asoc_mmp_sspa_probe,
+	.remove = __devexit_p(asoc_mmp_sspa_remove),
+};
+
+module_platform_driver(asoc_mmp_sspa_driver);
+
+MODULE_AUTHOR("Leo Yan <leoy@marvell.com>");
+MODULE_DESCRIPTION("MMP SSPA SoC Interface");
+MODULE_LICENSE("GPL");
