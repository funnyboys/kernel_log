commit 25612477d20b522a3203707ff23575b99f639fff
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Tue Jul 7 16:04:37 2020 -0500

    ASoC: soc-dai: set dai_link dpcm_ flags with a helper
    
    Add a helper to walk through all the DAIs and set dpcm_playback and
    dpcm_capture flags based on the DAIs capabilities, and use this helper
    to avoid setting these flags arbitrarily in generic cards.
    
    The commit referenced in the Fixes tag did not introduce the
    configuration issue but will prevent the card from probing when
    detecting invalid configurations.
    
    Fixes: b73287f0b0745 ('ASoC: soc-pcm: dpcm: fix playback/capture checks')
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Reviewed-by: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
    Link: https://lore.kernel.org/r/20200707210439.115300-2-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index b05e18b63a1c..457159975b01 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -391,6 +391,44 @@ bool snd_soc_dai_stream_valid(struct snd_soc_dai *dai, int dir)
 	return stream->channels_min;
 }
 
+/*
+ * snd_soc_dai_link_set_capabilities() - set dai_link properties based on its DAIs
+ */
+void snd_soc_dai_link_set_capabilities(struct snd_soc_dai_link *dai_link)
+{
+	struct snd_soc_dai_link_component *cpu;
+	struct snd_soc_dai_link_component *codec;
+	struct snd_soc_dai *dai;
+	bool supported[SNDRV_PCM_STREAM_LAST + 1];
+	int direction;
+	int i;
+
+	for_each_pcm_streams(direction) {
+		supported[direction] = true;
+
+		for_each_link_cpus(dai_link, i, cpu) {
+			dai = snd_soc_find_dai(cpu);
+			if (!dai || !snd_soc_dai_stream_valid(dai, direction)) {
+				supported[direction] = false;
+				break;
+			}
+		}
+		if (!supported[direction])
+			continue;
+		for_each_link_codecs(dai_link, i, codec) {
+			dai = snd_soc_find_dai(codec);
+			if (!dai || !snd_soc_dai_stream_valid(dai, direction)) {
+				supported[direction] = false;
+				break;
+			}
+		}
+	}
+
+	dai_link->dpcm_playback = supported[SNDRV_PCM_STREAM_PLAYBACK];
+	dai_link->dpcm_capture  = supported[SNDRV_PCM_STREAM_CAPTURE];
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_link_set_capabilities);
+
 void snd_soc_dai_action(struct snd_soc_dai *dai,
 			int stream, int action)
 {

commit 28ff437a44fa618a14bc7402c7472b278af4c9eb
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri May 29 07:36:13 2020 -0500

    ASoC: reduce verbosity of error messages for sof-dai and sof-link
    
    Recent changes result in multiple dmesg traces such as:
    
    [ 14.410435] Audio Port: ASoC: error at snd_soc_link_startup on Audio
    Port: 1
    
    [ 14.410446] sst-mfld-platform sst-mfld-platform: ASoC: error at
    snd_soc_dai_startup on media-cpu-dai: 1
    
    These messages are not really errors, when dai and dai-link callbacks
    return the value of e.g. snd_pcm_hw_constraint_single() the result is
    "Positive if the value is changed, zero if it's not changed, or a
    negative error code"
    
    Add a simple test to skip the checks for positive returned values
    
    Suggested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20200529123613.13447-1-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 2c6ac3b0afa5..b05e18b63a1c 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -14,10 +14,14 @@
 static inline int _soc_dai_ret(struct snd_soc_dai *dai,
 			       const char *func, int ret)
 {
+	/* Positive, Zero values are not errors */
+	if (ret >= 0)
+		return ret;
+
+	/* Negative values might be errors */
 	switch (ret) {
 	case -EPROBE_DEFER:
 	case -ENOTSUPP:
-	case 0:
 		break;
 	default:
 		dev_err(dai->dev,

commit 0cbbf8a0399518e5b865f9a1320d704c1d621703
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon May 25 09:57:36 2020 +0900

    ASoC: soc-link: add snd_soc_link_be_hw_params_fixup()
    
    dai_link related function should be implemented at soc-link.c.
    This patch adds snd_soc_link_be_hw_params_fixup().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87wo503k73.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index ce4e1fd1ab79..2c6ac3b0afa5 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -8,6 +8,7 @@
 
 #include <sound/soc.h>
 #include <sound/soc-dai.h>
+#include <sound/soc-link.h>
 
 #define soc_dai_ret(dai, ret) _soc_dai_ret(dai, __func__, ret)
 static inline int _soc_dai_ret(struct snd_soc_dai *dai,
@@ -313,11 +314,9 @@ int snd_soc_dai_hw_params(struct snd_soc_dai *dai,
 	int ret = 0;
 
 	/* perform any topology hw_params fixups before DAI  */
-	if (rtd->dai_link->be_hw_params_fixup) {
-		ret = rtd->dai_link->be_hw_params_fixup(rtd, params);
-		if (ret < 0)
-			goto end;
-	}
+	ret = snd_soc_link_be_hw_params_fixup(rtd, params);
+	if (ret < 0)
+		goto end;
 
 	if (dai->driver->ops &&
 	    dai->driver->ops->hw_params)

commit 0812a08ac8d054efc6cf2895d3b0e82c8731f8e9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri May 15 09:48:02 2020 +0900

    ASoC: cleanup dai / component active code
    
    No one is using dai->active, snd_soc_component_is_active().
    Let's remove these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87imgy58hp.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 8172ff42d796..ce4e1fd1ab79 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -393,7 +393,7 @@ void snd_soc_dai_action(struct snd_soc_dai *dai,
 {
 	/* see snd_soc_dai_stream_active() */
 	dai->stream_active[stream]	+= action;
-	dai->active			+= action;
+
 	/* see snd_soc_component_active() */
 	dai->component->active		+= action;
 }

commit 5552f8d72893cea29a0074a3ea0a1a5766858fcd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri May 15 09:46:47 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_stream_active()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/874ksi6n48.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index bb771302fd6f..8172ff42d796 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -391,6 +391,7 @@ bool snd_soc_dai_stream_valid(struct snd_soc_dai *dai, int dir)
 void snd_soc_dai_action(struct snd_soc_dai *dai,
 			int stream, int action)
 {
+	/* see snd_soc_dai_stream_active() */
 	dai->stream_active[stream]	+= action;
 	dai->active			+= action;
 	/* see snd_soc_component_active() */

commit 488b2ca599f96d46d4a4d730845a247328cb6a28
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri May 15 09:46:42 2020 +0900

    ASoC: soc-component: add snd_soc_component_active()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/875zcy6n4d.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index de2981fa5372..bb771302fd6f 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -393,6 +393,7 @@ void snd_soc_dai_action(struct snd_soc_dai *dai,
 {
 	dai->stream_active[stream]	+= action;
 	dai->active			+= action;
+	/* see snd_soc_component_active() */
 	dai->component->active		+= action;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_action);

commit efffd9b344adbf813e3ae6f6136df80000bf2833
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri May 15 09:46:37 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_active()
    
    Current snd_soc_dai_action() is updating
    dai->stream_active for Playback/Capture (A),
    dai->active        for DAI (B)
    
            void snd_soc_dai_action(struct snd_soc_dai *dai,
                                    int stream, int action)
            {
    (A)             dai->stream_active[stream]      += action;
    (B)             dai->active                     += action;
                    dai->component->active          += action;
            }
    
    But, these are very verbose, because we can calculate
    DAI active from stream_active.
    
    This patch adds snd_soc_dai_active() which calculate
    DAI active from DAI stream_active.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/877dxe6n4i.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 3208f244c1b8..de2981fa5372 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -397,6 +397,18 @@ void snd_soc_dai_action(struct snd_soc_dai *dai,
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_action);
 
+int snd_soc_dai_active(struct snd_soc_dai *dai)
+{
+	int stream, active;
+
+	active = 0;
+	for_each_pcm_streams(stream)
+		active += dai->stream_active[stream];
+
+	return active;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_active);
+
 int snd_soc_pcm_dai_probe(struct snd_soc_pcm_runtime *rtd, int order)
 {
 	struct snd_soc_dai *dai;

commit dc82910682ef06d5e5a81b4b359945b6f669ee3b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri May 15 09:46:27 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_action()
    
    snd_soc_runtime_action() updates DAI's xxx_active.
    We should update these in the same time, and
    it can be implemented at soc-dai.c.
    This patch adds snd_soc_dai_action() for it.
    This is prepare for xxx_active cleanup.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87a72a6n4s.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 8e5fe012aa1d..3208f244c1b8 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -388,6 +388,15 @@ bool snd_soc_dai_stream_valid(struct snd_soc_dai *dai, int dir)
 	return stream->channels_min;
 }
 
+void snd_soc_dai_action(struct snd_soc_dai *dai,
+			int stream, int action)
+{
+	dai->stream_active[stream]	+= action;
+	dai->active			+= action;
+	dai->component->active		+= action;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_action);
+
 int snd_soc_pcm_dai_probe(struct snd_soc_pcm_runtime *rtd, int order)
 {
 	struct snd_soc_dai *dai;

commit 94d7281993a7933bf60ea733eeb8a8bad429bf1c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:59 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_compr_get_metadata()
    
    dai related function should be implemented at soc-dai.c.
    This patch adds snd_soc_dai_compr_get_metadata().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87eesdssi8.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 88990792fe49..8e5fe012aa1d 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -609,3 +609,17 @@ int snd_soc_dai_compr_set_metadata(struct snd_soc_dai *dai,
 	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_compr_set_metadata);
+
+int snd_soc_dai_compr_get_metadata(struct snd_soc_dai *dai,
+				   struct snd_compr_stream *cstream,
+				   struct snd_compr_metadata *metadata)
+{
+	int ret = 0;
+
+	if (dai->driver->cops &&
+	    dai->driver->cops->get_metadata)
+		ret = dai->driver->cops->get_metadata(cstream, metadata, dai);
+
+	return soc_dai_ret(dai, ret);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_compr_get_metadata);

commit 88b3a7dfe999b3e28f65be69787a1fd97b742b4f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:54 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_compr_set_metadata()
    
    dai related function should be implemented at soc-dai.c.
    This patch adds snd_soc_dai_compr_set_metadata().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87ftctssid.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 89fcf194c45e..88990792fe49 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -595,3 +595,17 @@ int snd_soc_dai_compr_pointer(struct snd_soc_dai *dai,
 	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_compr_pointer);
+
+int snd_soc_dai_compr_set_metadata(struct snd_soc_dai *dai,
+				   struct snd_compr_stream *cstream,
+				   struct snd_compr_metadata *metadata)
+{
+	int ret = 0;
+
+	if (dai->driver->cops &&
+	    dai->driver->cops->set_metadata)
+		ret = dai->driver->cops->set_metadata(cstream, metadata, dai);
+
+	return soc_dai_ret(dai, ret);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_compr_set_metadata);

commit ed38cc5909e72e30815f72e73cba34a3dbbb5494
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:49 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_compr_pointer()
    
    dai related function should be implemented at soc-dai.c.
    This patch adds snd_soc_dai_compr_pointer().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87h7x9ssii.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index bf52ecb26c0e..89fcf194c45e 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -581,3 +581,17 @@ int snd_soc_dai_compr_ack(struct snd_soc_dai *dai,
 	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_compr_ack);
+
+int snd_soc_dai_compr_pointer(struct snd_soc_dai *dai,
+			      struct snd_compr_stream *cstream,
+			      struct snd_compr_tstamp *tstamp)
+{
+	int ret = 0;
+
+	if (dai->driver->cops &&
+	    dai->driver->cops->pointer)
+		ret = dai->driver->cops->pointer(cstream, tstamp, dai);
+
+	return soc_dai_ret(dai, ret);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_compr_pointer);

commit 53294353a05ceaa6a107e8c1c300af63c89c8e50
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:45 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_compr_ack()
    
    dai related function should be implemented at soc-dai.c.
    This patch adds snd_soc_dai_compr_ack().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87imhpssim.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index c06e510855f2..bf52ecb26c0e 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -567,3 +567,17 @@ int snd_soc_dai_compr_get_params(struct snd_soc_dai *dai,
 	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_compr_get_params);
+
+int snd_soc_dai_compr_ack(struct snd_soc_dai *dai,
+			  struct snd_compr_stream *cstream,
+			  size_t bytes)
+{
+	int ret = 0;
+
+	if (dai->driver->cops &&
+	    dai->driver->cops->ack)
+		ret = dai->driver->cops->ack(cstream, bytes, dai);
+
+	return soc_dai_ret(dai, ret);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_compr_ack);

commit adbef5432666e20616263792d13cab80d57d9d5f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:40 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_compr_get_params()
    
    dai related function should be implemented at soc-dai.c.
    This patch adds snd_soc_dai_compr_get_params().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87k125ssir.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 44e754f03947..c06e510855f2 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -553,3 +553,17 @@ int snd_soc_dai_compr_set_params(struct snd_soc_dai *dai,
 	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_compr_set_params);
+
+int snd_soc_dai_compr_get_params(struct snd_soc_dai *dai,
+				 struct snd_compr_stream *cstream,
+				 struct snd_codec *params)
+{
+	int ret = 0;
+
+	if (dai->driver->cops &&
+	    dai->driver->cops->get_params)
+		ret = dai->driver->cops->get_params(cstream, params, dai);
+
+	return soc_dai_ret(dai, ret);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_compr_get_params);

commit 8dfedafb5c711b5a13c938e06e8143540f773ecf
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:36 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_compr_set_params()
    
    dai related function should be implemented at soc-dai.c.
    This patch adds snd_soc_dai_compr_set_params().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87lfmlssiv.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 844b52528174..44e754f03947 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -539,3 +539,17 @@ int snd_soc_dai_compr_trigger(struct snd_soc_dai *dai,
 	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_compr_trigger);
+
+int snd_soc_dai_compr_set_params(struct snd_soc_dai *dai,
+				 struct snd_compr_stream *cstream,
+				 struct snd_compr_params *params)
+{
+	int ret = 0;
+
+	if (dai->driver->cops &&
+	    dai->driver->cops->set_params)
+		ret = dai->driver->cops->set_params(cstream, params, dai);
+
+	return soc_dai_ret(dai, ret);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_compr_set_params);

commit eb08411bdf48cff69f7226c86a97fba1ef5045e6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:32 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_compr_trigger()
    
    dai related function should be implemented at soc-dai.c.
    This patch adds snd_soc_dai_compr_trigger().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87mu71ssiz.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index d5cb8b0853a7..844b52528174 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -526,3 +526,16 @@ void snd_soc_dai_compr_shutdown(struct snd_soc_dai *dai,
 		dai->driver->cops->shutdown(cstream, dai);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_compr_shutdown);
+
+int snd_soc_dai_compr_trigger(struct snd_soc_dai *dai,
+			      struct snd_compr_stream *cstream, int cmd)
+{
+	int ret = 0;
+
+	if (dai->driver->cops &&
+	    dai->driver->cops->trigger)
+		ret = dai->driver->cops->trigger(cstream, cmd, dai);
+
+	return soc_dai_ret(dai, ret);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_compr_trigger);

commit 2b25f81d43b764142699a430da0ca57ffcb33cc2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:28 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_compr_shutdown()
    
    dai related function should be implemented at soc-dai.c.
    This patch adds snd_soc_dai_compr_shutdown().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87o8rhssj3.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 5c88f80b781d..d5cb8b0853a7 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -517,3 +517,12 @@ int snd_soc_dai_compr_startup(struct snd_soc_dai *dai,
 	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_compr_startup);
+
+void snd_soc_dai_compr_shutdown(struct snd_soc_dai *dai,
+				struct snd_compr_stream *cstream)
+{
+	if (dai->driver->cops &&
+	    dai->driver->cops->shutdown)
+		dai->driver->cops->shutdown(cstream, dai);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_compr_shutdown);

commit b5ae4ccea5ab15adcde64f4474b36e4a630434ec
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:24 2020 +0900

    ASoC: soc-dai: add snd_soc_dai_compr_start()
    
    dai related function should be implemented at soc-dai.c.
    This patch adds snd_soc_dai_compr_start().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87pnbxssj7.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 2bc452fe02ff..5c88f80b781d 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -504,3 +504,16 @@ int snd_soc_pcm_dai_bespoke_trigger(struct snd_pcm_substream *substream,
 
 	return 0;
 }
+
+int snd_soc_dai_compr_startup(struct snd_soc_dai *dai,
+			      struct snd_compr_stream *cstream)
+{
+	int ret = 0;
+
+	if (dai->driver->cops &&
+	    dai->driver->cops->startup)
+		ret = dai->driver->cops->startup(cstream, dai);
+
+	return soc_dai_ret(dai, ret);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_compr_startup);

commit 7eaa313bdec3f2326c9cdacec88fd484a36c423b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:20 2020 +0900

    ASoC: soc-dai: add snd_soc_pcm_dai_remove()
    
    We have 2 type of component functions
    snd_soc_dai_xxx()     is focusing to dai itself,
    snd_soc_pcm_dai_xxx() is focusing to rtd related dai.
    
    Now we can update snd_soc_dai_remove() to
    snd_soc_pcm_dai_remove(). This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87r1wdssjc.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 48f5eb5ef387..2bc452fe02ff 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -366,16 +366,6 @@ snd_pcm_sframes_t snd_soc_dai_delay(struct snd_soc_dai *dai,
 	return delay;
 }
 
-int snd_soc_dai_remove(struct snd_soc_dai *dai)
-{
-	int ret = 0;
-
-	if (dai->driver->remove)
-		ret = dai->driver->remove(dai);
-
-	return soc_dai_ret(dai, ret);
-}
-
 int snd_soc_dai_compress_new(struct snd_soc_dai *dai,
 			     struct snd_soc_pcm_runtime *rtd, int num)
 {
@@ -420,6 +410,28 @@ int snd_soc_pcm_dai_probe(struct snd_soc_pcm_runtime *rtd, int order)
 	return 0;
 }
 
+int snd_soc_pcm_dai_remove(struct snd_soc_pcm_runtime *rtd, int order)
+{
+	struct snd_soc_dai *dai;
+	int i, r, ret = 0;
+
+	for_each_rtd_dais(rtd, i, dai) {
+		if (dai->driver->remove_order != order)
+			continue;
+
+		if (dai->probed &&
+		    dai->driver->remove) {
+			r = dai->driver->remove(dai);
+			if (r < 0)
+				ret = r; /* use last error */
+		}
+
+		dai->probed = 0;
+	}
+
+	return ret;
+}
+
 int snd_soc_pcm_dai_new(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_dai *dai;

commit 51801aeafdc9c1d55e5e71e58a1bbbd2583328fa
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:15 2020 +0900

    ASoC: soc-dai: add snd_soc_pcm_dai_probe()
    
    We have 2 type of component functions
    snd_soc_dai_xxx()     is focusing to dai itself,
    snd_soc_pcm_dai_xxx() is focusing to rtd related dai.
    
    Now we can update snd_soc_dai_probe() to
    snd_soc_pcm_dai_probe(). This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87sggtssjg.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 226c51b9089c..48f5eb5ef387 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -366,16 +366,6 @@ snd_pcm_sframes_t snd_soc_dai_delay(struct snd_soc_dai *dai,
 	return delay;
 }
 
-int snd_soc_dai_probe(struct snd_soc_dai *dai)
-{
-	int ret = 0;
-
-	if (dai->driver->probe)
-		ret = dai->driver->probe(dai);
-
-	return soc_dai_ret(dai, ret);
-}
-
 int snd_soc_dai_remove(struct snd_soc_dai *dai)
 {
 	int ret = 0;
@@ -408,6 +398,28 @@ bool snd_soc_dai_stream_valid(struct snd_soc_dai *dai, int dir)
 	return stream->channels_min;
 }
 
+int snd_soc_pcm_dai_probe(struct snd_soc_pcm_runtime *rtd, int order)
+{
+	struct snd_soc_dai *dai;
+	int i;
+
+	for_each_rtd_dais(rtd, i, dai) {
+		if (dai->driver->probe_order != order)
+			continue;
+
+		if (dai->driver->probe) {
+			int ret = dai->driver->probe(dai);
+
+			if (ret < 0)
+				return soc_dai_ret(dai, ret);
+		}
+
+		dai->probed = 1;
+	}
+
+	return 0;
+}
+
 int snd_soc_pcm_dai_new(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_dai *dai;

commit 30819358ae73326269ba61597be47d5036e05b08
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:09 2020 +0900

    ASoC: soc-dai: add snd_soc_pcm_dai_bespoke_trigger()
    
    We have 2 type of component functions
    snd_soc_dai_xxx()     is focusing to dai itself,
    snd_soc_pcm_dai_xxx() is focusing to rtd related dai.
    
    Now we can update soc_pcm_bespoke_trigger() to
    snd_soc_pcm_dai_bespoke_trigger(). This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87tv19ssjm.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 29587d7e75ca..226c51b9089c 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -354,19 +354,6 @@ void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
 		dai->driver->ops->shutdown(substream, dai);
 }
 
-int snd_soc_dai_bespoke_trigger(struct snd_soc_dai *dai,
-				struct snd_pcm_substream *substream,
-				int cmd)
-{
-	int ret = 0;
-
-	if (dai->driver->ops &&
-	    dai->driver->ops->bespoke_trigger)
-		ret = dai->driver->ops->bespoke_trigger(substream, cmd, dai);
-
-	return soc_dai_ret(dai, ret);
-}
-
 snd_pcm_sframes_t snd_soc_dai_delay(struct snd_soc_dai *dai,
 				    struct snd_pcm_substream *substream)
 {
@@ -473,3 +460,23 @@ int snd_soc_pcm_dai_trigger(struct snd_pcm_substream *substream,
 
 	return 0;
 }
+
+int snd_soc_pcm_dai_bespoke_trigger(struct snd_pcm_substream *substream,
+				    int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *dai;
+	int i, ret;
+
+	for_each_rtd_dais(rtd, i, dai) {
+		if (dai->driver->ops &&
+		    dai->driver->ops->bespoke_trigger) {
+			ret = dai->driver->ops->bespoke_trigger(substream,
+								cmd, dai);
+			if (ret < 0)
+				return soc_dai_ret(dai, ret);
+		}
+	}
+
+	return 0;
+}

commit 42f2472d4689c00d742b6690aa6579966f0b2f83
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:04 2020 +0900

    ASoC: soc-dai: add snd_soc_pcm_dai_trigger()
    
    We have 2 type of component functions
    snd_soc_dai_xxx()     is focusing to dai itself,
    snd_soc_pcm_dai_xxx() is focusing to rtd related dai.
    
    Now we can update snd_soc_dai_trigger() to
    snd_soc_pcm_dai_trigger(). This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87v9lpssjr.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 1a9cfdcfc736..29587d7e75ca 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -354,19 +354,6 @@ void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
 		dai->driver->ops->shutdown(substream, dai);
 }
 
-int snd_soc_dai_trigger(struct snd_soc_dai *dai,
-			struct snd_pcm_substream *substream,
-			int cmd)
-{
-	int ret = 0;
-
-	if (dai->driver->ops &&
-	    dai->driver->ops->trigger)
-		ret = dai->driver->ops->trigger(substream, cmd, dai);
-
-	return ret;
-}
-
 int snd_soc_dai_bespoke_trigger(struct snd_soc_dai *dai,
 				struct snd_pcm_substream *substream,
 				int cmd)
@@ -467,3 +454,22 @@ int snd_soc_pcm_dai_prepare(struct snd_pcm_substream *substream)
 
 	return 0;
 }
+
+int snd_soc_pcm_dai_trigger(struct snd_pcm_substream *substream,
+			    int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *dai;
+	int i, ret;
+
+	for_each_rtd_dais(rtd, i, dai) {
+		if (dai->driver->ops &&
+		    dai->driver->ops->trigger) {
+			ret = dai->driver->ops->trigger(substream, cmd, dai);
+			if (ret < 0)
+				return soc_dai_ret(dai, ret);
+		}
+	}
+
+	return 0;
+}

commit d108c7fd0b776d5b48acd15f6f52b1bb8255a69e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:14:53 2020 +0900

    ASoC: soc-dai: add snd_soc_pcm_dai_prepare()
    
    We have 2 type of component functions
    snd_soc_dai_xxx()     is focusing to dai itself,
    snd_soc_pcm_dai_xxx() is focusing to rtd related dai.
    
    Now we can update snd_soc_dai_prepare() to
    snd_soc_pcm_dai_prepare(). This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87wo65ssk2.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 1b45e6e114ad..1a9cfdcfc736 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -354,18 +354,6 @@ void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
 		dai->driver->ops->shutdown(substream, dai);
 }
 
-int snd_soc_dai_prepare(struct snd_soc_dai *dai,
-			struct snd_pcm_substream *substream)
-{
-	int ret = 0;
-
-	if (dai->driver->ops &&
-	    dai->driver->ops->prepare)
-		ret = dai->driver->ops->prepare(substream, dai);
-
-	return soc_dai_ret(dai, ret);
-}
-
 int snd_soc_dai_trigger(struct snd_soc_dai *dai,
 			struct snd_pcm_substream *substream,
 			int cmd)
@@ -461,3 +449,21 @@ int snd_soc_pcm_dai_new(struct snd_soc_pcm_runtime *rtd)
 
 	return 0;
 }
+
+int snd_soc_pcm_dai_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *dai;
+	int i, ret;
+
+	for_each_rtd_dais(rtd, i, dai) {
+		if (dai->driver->ops &&
+		    dai->driver->ops->prepare) {
+			ret = dai->driver->ops->prepare(substream, dai);
+			if (ret < 0)
+				return soc_dai_ret(dai, ret);
+		}
+	}
+
+	return 0;
+}

commit 0b73ba550cdd95b0fdca5da0040c29ae5d25ae5d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:14:48 2020 +0900

    ASoC: soc-dai: add snd_soc_pcm_dai_new()
    
    We have 2 type of component functions
    snd_soc_dai_xxx()     is focusing to dai itself,
    snd_soc_pcm_dai_xxx() is focusing to rtd related dai.
    
    Now we can update soc_dai_pcm_new() to
    snd_soc_pcm_dai_new(). This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87y2qlssk7.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 93e03c9ec164..1b45e6e114ad 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -445,3 +445,19 @@ bool snd_soc_dai_stream_valid(struct snd_soc_dai *dai, int dir)
 	/* If the codec specifies any channels at all, it supports the stream */
 	return stream->channels_min;
 }
+
+int snd_soc_pcm_dai_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *dai;
+	int i, ret = 0;
+
+	for_each_rtd_dais(rtd, i, dai) {
+		if (dai->driver->pcm_new) {
+			ret = dai->driver->pcm_new(rtd, dai);
+			if (ret < 0)
+				return soc_dai_ret(dai, ret);
+		}
+	}
+
+	return 0;
+}

commit 479914ed779d408273fb3cac4c061dbe695f17cb
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:14:43 2020 +0900

    ASoC: soc-dai: don't overwide dai->driver->ops
    
    Current ASoC overwrites null_dai_ops to dai->driver->ops if it
    was NULL. But, we can remove it if framework always checks
    dai->driver->ops when it uses DAI callbacks.
    This patch do it, and removes null_dai_ops.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87zhb1sskc.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index d591b3bd8b99..93e03c9ec164 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -41,7 +41,8 @@ int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 {
 	int ret;
 
-	if (dai->driver->ops->set_sysclk)
+	if (dai->driver->ops &&
+	    dai->driver->ops->set_sysclk)
 		ret = dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
 	else
 		ret = snd_soc_component_set_sysclk(dai->component, clk_id, 0,
@@ -66,7 +67,8 @@ int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
 {
 	int ret = -EINVAL;
 
-	if (dai->driver->ops->set_clkdiv)
+	if (dai->driver->ops &&
+	    dai->driver->ops->set_clkdiv)
 		ret = dai->driver->ops->set_clkdiv(dai, div_id, div);
 
 	return soc_dai_ret(dai, ret);
@@ -88,7 +90,8 @@ int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
 {
 	int ret;
 
-	if (dai->driver->ops->set_pll)
+	if (dai->driver->ops &&
+	    dai->driver->ops->set_pll)
 		ret = dai->driver->ops->set_pll(dai, pll_id, source,
 						freq_in, freq_out);
 	else
@@ -110,7 +113,8 @@ int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
 {
 	int ret = -EINVAL;
 
-	if (dai->driver->ops->set_bclk_ratio)
+	if (dai->driver->ops &&
+	    dai->driver->ops->set_bclk_ratio)
 		ret = dai->driver->ops->set_bclk_ratio(dai, ratio);
 
 	return soc_dai_ret(dai, ret);
@@ -128,7 +132,8 @@ int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
 	int ret = -ENOTSUPP;
 
-	if (dai->driver->ops->set_fmt)
+	if (dai->driver->ops &&
+	    dai->driver->ops->set_fmt)
 		ret = dai->driver->ops->set_fmt(dai, fmt);
 
 	return soc_dai_ret(dai, ret);
@@ -188,7 +193,8 @@ int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 {
 	int ret = -ENOTSUPP;
 
-	if (dai->driver->ops->xlate_tdm_slot_mask)
+	if (dai->driver->ops &&
+	    dai->driver->ops->xlate_tdm_slot_mask)
 		dai->driver->ops->xlate_tdm_slot_mask(slots,
 						      &tx_mask, &rx_mask);
 	else
@@ -197,7 +203,8 @@ int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	dai->tx_mask = tx_mask;
 	dai->rx_mask = rx_mask;
 
-	if (dai->driver->ops->set_tdm_slot)
+	if (dai->driver->ops &&
+	    dai->driver->ops->set_tdm_slot)
 		ret = dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
 						      slots, slot_width);
 	return soc_dai_ret(dai, ret);
@@ -222,7 +229,8 @@ int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,
 {
 	int ret = -ENOTSUPP;
 
-	if (dai->driver->ops->set_channel_map)
+	if (dai->driver->ops &&
+	    dai->driver->ops->set_channel_map)
 		ret = dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,
 							rx_num, rx_slot);
 	return soc_dai_ret(dai, ret);
@@ -245,7 +253,8 @@ int snd_soc_dai_get_channel_map(struct snd_soc_dai *dai,
 {
 	int ret = -ENOTSUPP;
 
-	if (dai->driver->ops->get_channel_map)
+	if (dai->driver->ops &&
+	    dai->driver->ops->get_channel_map)
 		ret = dai->driver->ops->get_channel_map(dai, tx_num, tx_slot,
 							rx_num, rx_slot);
 	return soc_dai_ret(dai, ret);
@@ -263,7 +272,8 @@ int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
 {
 	int ret = -EINVAL;
 
-	if (dai->driver->ops->set_tristate)
+	if (dai->driver->ops &&
+	    dai->driver->ops->set_tristate)
 		ret = dai->driver->ops->set_tristate(dai, tristate);
 
 	return soc_dai_ret(dai, ret);
@@ -283,9 +293,11 @@ int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
 {
 	int ret = -ENOTSUPP;
 
-	if (dai->driver->ops->mute_stream)
+	if (dai->driver->ops &&
+	    dai->driver->ops->mute_stream)
 		ret = dai->driver->ops->mute_stream(dai, mute, direction);
 	else if (direction == SNDRV_PCM_STREAM_PLAYBACK &&
+		 dai->driver->ops &&
 		 dai->driver->ops->digital_mute)
 		ret = dai->driver->ops->digital_mute(dai, mute);
 
@@ -307,7 +319,8 @@ int snd_soc_dai_hw_params(struct snd_soc_dai *dai,
 			goto end;
 	}
 
-	if (dai->driver->ops->hw_params)
+	if (dai->driver->ops &&
+	    dai->driver->ops->hw_params)
 		ret = dai->driver->ops->hw_params(substream, params, dai);
 end:
 	return soc_dai_ret(dai, ret);
@@ -316,7 +329,8 @@ int snd_soc_dai_hw_params(struct snd_soc_dai *dai,
 void snd_soc_dai_hw_free(struct snd_soc_dai *dai,
 			 struct snd_pcm_substream *substream)
 {
-	if (dai->driver->ops->hw_free)
+	if (dai->driver->ops &&
+	    dai->driver->ops->hw_free)
 		dai->driver->ops->hw_free(substream, dai);
 }
 
@@ -325,7 +339,8 @@ int snd_soc_dai_startup(struct snd_soc_dai *dai,
 {
 	int ret = 0;
 
-	if (dai->driver->ops->startup)
+	if (dai->driver->ops &&
+	    dai->driver->ops->startup)
 		ret = dai->driver->ops->startup(substream, dai);
 
 	return soc_dai_ret(dai, ret);
@@ -334,7 +349,8 @@ int snd_soc_dai_startup(struct snd_soc_dai *dai,
 void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
 			 struct snd_pcm_substream *substream)
 {
-	if (dai->driver->ops->shutdown)
+	if (dai->driver->ops &&
+	    dai->driver->ops->shutdown)
 		dai->driver->ops->shutdown(substream, dai);
 }
 
@@ -343,7 +359,8 @@ int snd_soc_dai_prepare(struct snd_soc_dai *dai,
 {
 	int ret = 0;
 
-	if (dai->driver->ops->prepare)
+	if (dai->driver->ops &&
+	    dai->driver->ops->prepare)
 		ret = dai->driver->ops->prepare(substream, dai);
 
 	return soc_dai_ret(dai, ret);
@@ -355,7 +372,8 @@ int snd_soc_dai_trigger(struct snd_soc_dai *dai,
 {
 	int ret = 0;
 
-	if (dai->driver->ops->trigger)
+	if (dai->driver->ops &&
+	    dai->driver->ops->trigger)
 		ret = dai->driver->ops->trigger(substream, cmd, dai);
 
 	return ret;
@@ -367,7 +385,8 @@ int snd_soc_dai_bespoke_trigger(struct snd_soc_dai *dai,
 {
 	int ret = 0;
 
-	if (dai->driver->ops->bespoke_trigger)
+	if (dai->driver->ops &&
+	    dai->driver->ops->bespoke_trigger)
 		ret = dai->driver->ops->bespoke_trigger(substream, cmd, dai);
 
 	return soc_dai_ret(dai, ret);
@@ -378,7 +397,8 @@ snd_pcm_sframes_t snd_soc_dai_delay(struct snd_soc_dai *dai,
 {
 	int delay = 0;
 
-	if (dai->driver->ops->delay)
+	if (dai->driver->ops &&
+	    dai->driver->ops->delay)
 		delay = dai->driver->ops->delay(substream, dai);
 
 	return delay;

commit aa7b8230d4c3d0e691604dc908887904f52f2ab8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:14:38 2020 +0900

    ASoC: soc-dai: add soc_dai_err()
    
    At soc-dai.c, it is good idea to indicate error function and
    its component name if there was error.
    This patch adds soc_dai_err() for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/871rodu74x.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 31c41559034b..d591b3bd8b99 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -9,6 +9,24 @@
 #include <sound/soc.h>
 #include <sound/soc-dai.h>
 
+#define soc_dai_ret(dai, ret) _soc_dai_ret(dai, __func__, ret)
+static inline int _soc_dai_ret(struct snd_soc_dai *dai,
+			       const char *func, int ret)
+{
+	switch (ret) {
+	case -EPROBE_DEFER:
+	case -ENOTSUPP:
+	case 0:
+		break;
+	default:
+		dev_err(dai->dev,
+			"ASoC: error at %s on %s: %d\n",
+			func, dai->name, ret);
+	}
+
+	return ret;
+}
+
 /**
  * snd_soc_dai_set_sysclk - configure DAI system or master clock.
  * @dai: DAI
@@ -21,11 +39,15 @@
 int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 			   unsigned int freq, int dir)
 {
+	int ret;
+
 	if (dai->driver->ops->set_sysclk)
-		return dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
+		ret = dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
+	else
+		ret = snd_soc_component_set_sysclk(dai->component, clk_id, 0,
+						   freq, dir);
 
-	return snd_soc_component_set_sysclk(dai->component, clk_id, 0,
-					    freq, dir);
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 
@@ -42,10 +64,12 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
 			   int div_id, int div)
 {
+	int ret = -EINVAL;
+
 	if (dai->driver->ops->set_clkdiv)
-		return dai->driver->ops->set_clkdiv(dai, div_id, div);
-	else
-		return -EINVAL;
+		ret = dai->driver->ops->set_clkdiv(dai, div_id, div);
+
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
 
@@ -62,12 +86,16 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
 			unsigned int freq_in, unsigned int freq_out)
 {
+	int ret;
+
 	if (dai->driver->ops->set_pll)
-		return dai->driver->ops->set_pll(dai, pll_id, source,
-						 freq_in, freq_out);
+		ret = dai->driver->ops->set_pll(dai, pll_id, source,
+						freq_in, freq_out);
+	else
+		ret = snd_soc_component_set_pll(dai->component, pll_id, source,
+						freq_in, freq_out);
 
-	return snd_soc_component_set_pll(dai->component, pll_id, source,
-					 freq_in, freq_out);
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
 
@@ -80,10 +108,12 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
  */
 int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
 {
+	int ret = -EINVAL;
+
 	if (dai->driver->ops->set_bclk_ratio)
-		return dai->driver->ops->set_bclk_ratio(dai, ratio);
-	else
-		return -EINVAL;
+		ret = dai->driver->ops->set_bclk_ratio(dai, ratio);
+
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
 
@@ -96,9 +126,12 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
  */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	if (dai->driver->ops->set_fmt == NULL)
-		return -ENOTSUPP;
-	return dai->driver->ops->set_fmt(dai, fmt);
+	int ret = -ENOTSUPP;
+
+	if (dai->driver->ops->set_fmt)
+		ret = dai->driver->ops->set_fmt(dai, fmt);
+
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 
@@ -153,6 +186,8 @@ int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 			     unsigned int tx_mask, unsigned int rx_mask,
 			     int slots, int slot_width)
 {
+	int ret = -ENOTSUPP;
+
 	if (dai->driver->ops->xlate_tdm_slot_mask)
 		dai->driver->ops->xlate_tdm_slot_mask(slots,
 						      &tx_mask, &rx_mask);
@@ -163,10 +198,9 @@ int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	dai->rx_mask = rx_mask;
 
 	if (dai->driver->ops->set_tdm_slot)
-		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
+		ret = dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
 						      slots, slot_width);
-	else
-		return -ENOTSUPP;
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
 
@@ -186,11 +220,12 @@ int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,
 				unsigned int tx_num, unsigned int *tx_slot,
 				unsigned int rx_num, unsigned int *rx_slot)
 {
+	int ret = -ENOTSUPP;
+
 	if (dai->driver->ops->set_channel_map)
-		return dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,
-							 rx_num, rx_slot);
-	else
-		return -ENOTSUPP;
+		ret = dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,
+							rx_num, rx_slot);
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);
 
@@ -208,11 +243,12 @@ int snd_soc_dai_get_channel_map(struct snd_soc_dai *dai,
 				unsigned int *tx_num, unsigned int *tx_slot,
 				unsigned int *rx_num, unsigned int *rx_slot)
 {
+	int ret = -ENOTSUPP;
+
 	if (dai->driver->ops->get_channel_map)
-		return dai->driver->ops->get_channel_map(dai, tx_num, tx_slot,
-							 rx_num, rx_slot);
-	else
-		return -ENOTSUPP;
+		ret = dai->driver->ops->get_channel_map(dai, tx_num, tx_slot,
+							rx_num, rx_slot);
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_get_channel_map);
 
@@ -225,10 +261,12 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_get_channel_map);
  */
 int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
 {
+	int ret = -EINVAL;
+
 	if (dai->driver->ops->set_tristate)
-		return dai->driver->ops->set_tristate(dai, tristate);
-	else
-		return -EINVAL;
+		ret = dai->driver->ops->set_tristate(dai, tristate);
+
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
 
@@ -243,13 +281,15 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
 int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
 			     int direction)
 {
+	int ret = -ENOTSUPP;
+
 	if (dai->driver->ops->mute_stream)
-		return dai->driver->ops->mute_stream(dai, mute, direction);
+		ret = dai->driver->ops->mute_stream(dai, mute, direction);
 	else if (direction == SNDRV_PCM_STREAM_PLAYBACK &&
 		 dai->driver->ops->digital_mute)
-		return dai->driver->ops->digital_mute(dai, mute);
-	else
-		return -ENOTSUPP;
+		ret = dai->driver->ops->digital_mute(dai, mute);
+
+	return soc_dai_ret(dai, ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 
@@ -258,29 +298,19 @@ int snd_soc_dai_hw_params(struct snd_soc_dai *dai,
 			  struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	int ret;
+	int ret = 0;
 
 	/* perform any topology hw_params fixups before DAI  */
 	if (rtd->dai_link->be_hw_params_fixup) {
 		ret = rtd->dai_link->be_hw_params_fixup(rtd, params);
-		if (ret < 0) {
-			dev_err(rtd->dev,
-				"ASoC: hw_params topology fixup failed %d\n",
-				ret);
-			return ret;
-		}
+		if (ret < 0)
+			goto end;
 	}
 
-	if (dai->driver->ops->hw_params) {
+	if (dai->driver->ops->hw_params)
 		ret = dai->driver->ops->hw_params(substream, params, dai);
-		if (ret < 0) {
-			dev_err(dai->dev, "ASoC: can't set %s hw params: %d\n",
-				dai->name, ret);
-			return ret;
-		}
-	}
-
-	return 0;
+end:
+	return soc_dai_ret(dai, ret);
 }
 
 void snd_soc_dai_hw_free(struct snd_soc_dai *dai,
@@ -298,7 +328,7 @@ int snd_soc_dai_startup(struct snd_soc_dai *dai,
 	if (dai->driver->ops->startup)
 		ret = dai->driver->ops->startup(substream, dai);
 
-	return ret;
+	return soc_dai_ret(dai, ret);
 }
 
 void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
@@ -316,7 +346,7 @@ int snd_soc_dai_prepare(struct snd_soc_dai *dai,
 	if (dai->driver->ops->prepare)
 		ret = dai->driver->ops->prepare(substream, dai);
 
-	return ret;
+	return soc_dai_ret(dai, ret);
 }
 
 int snd_soc_dai_trigger(struct snd_soc_dai *dai,
@@ -340,7 +370,7 @@ int snd_soc_dai_bespoke_trigger(struct snd_soc_dai *dai,
 	if (dai->driver->ops->bespoke_trigger)
 		ret = dai->driver->ops->bespoke_trigger(substream, cmd, dai);
 
-	return ret;
+	return soc_dai_ret(dai, ret);
 }
 
 snd_pcm_sframes_t snd_soc_dai_delay(struct snd_soc_dai *dai,
@@ -356,24 +386,31 @@ snd_pcm_sframes_t snd_soc_dai_delay(struct snd_soc_dai *dai,
 
 int snd_soc_dai_probe(struct snd_soc_dai *dai)
 {
+	int ret = 0;
+
 	if (dai->driver->probe)
-		return dai->driver->probe(dai);
-	return 0;
+		ret = dai->driver->probe(dai);
+
+	return soc_dai_ret(dai, ret);
 }
 
 int snd_soc_dai_remove(struct snd_soc_dai *dai)
 {
+	int ret = 0;
+
 	if (dai->driver->remove)
-		return dai->driver->remove(dai);
-	return 0;
+		ret = dai->driver->remove(dai);
+
+	return soc_dai_ret(dai, ret);
 }
 
 int snd_soc_dai_compress_new(struct snd_soc_dai *dai,
 			     struct snd_soc_pcm_runtime *rtd, int num)
 {
+	int ret = -ENOTSUPP;
 	if (dai->driver->compress_new)
-		return dai->driver->compress_new(rtd, num);
-	return -ENOTSUPP;
+		ret = dai->driver->compress_new(rtd, num);
+	return soc_dai_ret(dai, ret);
 }
 
 /*

commit 5bd70440cb0a6f5c6a84019bb2aa93ab8310a5cd
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Tue Apr 14 22:04:37 2020 -0500

    ASoC: soc-dai: revert all changes to DAI startup/shutdown sequence
    
    On Baytrail/Cherrytrail, the Atom/SST driver fails miserably:
    
    [    9.741953] intel_sst_acpi 80860F28:00: FW Version 01.0c.00.01
    [    9.832992] intel_sst_acpi 80860F28:00: FW sent error response 0x40034
    [    9.833019] intel_sst_acpi 80860F28:00: FW alloc failed ret -4
    [    9.833028] intel_sst_acpi 80860F28:00: sst_get_stream returned err -5
    [    9.833033] sst-mfld-platform sst-mfld-platform: ASoC: DAI prepare error: -5
    [    9.833037]  Baytrail Audio Port: ASoC: prepare FE Baytrail Audio Port failed
    [    9.853942] intel_sst_acpi 80860F28:00: FW sent error response 0x40034
    [    9.853974] intel_sst_acpi 80860F28:00: FW alloc failed ret -4
    [    9.853984] intel_sst_acpi 80860F28:00: sst_get_stream returned err -5
    [    9.853990] sst-mfld-platform sst-mfld-platform: ASoC: DAI prepare error: -5
    [    9.853994]  Baytrail Audio Port: ASoC: prepare FE Baytrail Audio Port failed
    
    Commit b56be800f1292 ("ASoC: soc-pcm: call
    snd_soc_dai_startup()/shutdown() once") was the initial problematic
    commit.
    
    Commit 1ba616bd1a6d5e ("ASoC: soc-dai: fix DAI startup/shutdown sequence")
    was an attempt to fix things but it does not work on Baytrail,
    reverting all changes seems necessary for now.
    
    Fixes: 1ba616bd1a6d5e ("ASoC: soc-dai: fix DAI startup/shutdown sequence")
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200415030437.23803-1-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 8f3cad8db89a..31c41559034b 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -295,24 +295,17 @@ int snd_soc_dai_startup(struct snd_soc_dai *dai,
 {
 	int ret = 0;
 
-	if (!dai->started[substream->stream] &&
-	    dai->driver->ops->startup)
+	if (dai->driver->ops->startup)
 		ret = dai->driver->ops->startup(substream, dai);
 
-	if (ret == 0)
-		dai->started[substream->stream] = 1;
-
 	return ret;
 }
 
 void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
 			 struct snd_pcm_substream *substream)
 {
-	if (dai->started[substream->stream] &&
-	    dai->driver->ops->shutdown)
+	if (dai->driver->ops->shutdown)
 		dai->driver->ops->shutdown(substream, dai);
-
-	dai->started[substream->stream] = 0;
 }
 
 int snd_soc_dai_prepare(struct snd_soc_dai *dai,

commit 1ba616bd1a6d5ebdb31ceaa9265b2a2bb670155b
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Mon Mar 30 11:06:02 2020 -0500

    ASoC: soc-dai: fix DAI startup/shutdown sequence
    
    The addition of a single flag to track the DAI status prevents the DAI
    startup sequence from being called on capture if the DAI is already
    used for playback.
    
    Fix by extending the existing code with one flag per direction.
    
    Fixes: b56be800f1292 ("ASoC: soc-pcm: call snd_soc_dai_startup()/shutdown() once")
    Reported-by: Amadeusz Sawiski <amadeuszx.slawinski@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Tested-by: Amadeusz Sawiski <amadeuszx.slawinski@linux.intel.com>
    Link: https://lore.kernel.org/r/20200330160602.10180-1-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 19142f6e533c..8f3cad8db89a 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -295,12 +295,12 @@ int snd_soc_dai_startup(struct snd_soc_dai *dai,
 {
 	int ret = 0;
 
-	if (!dai->started &&
+	if (!dai->started[substream->stream] &&
 	    dai->driver->ops->startup)
 		ret = dai->driver->ops->startup(substream, dai);
 
 	if (ret == 0)
-		dai->started = 1;
+		dai->started[substream->stream] = 1;
 
 	return ret;
 }
@@ -308,11 +308,11 @@ int snd_soc_dai_startup(struct snd_soc_dai *dai,
 void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
 			 struct snd_pcm_substream *substream)
 {
-	if (dai->started &&
+	if (dai->started[substream->stream] &&
 	    dai->driver->ops->shutdown)
 		dai->driver->ops->shutdown(substream, dai);
 
-	dai->started = 0;
+	dai->started[substream->stream] = 0;
 }
 
 int snd_soc_dai_prepare(struct snd_soc_dai *dai,

commit acf253c11329caa6be6d2abc14dfc8c0ec83718a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Feb 19 15:56:30 2020 +0900

    ASoC: soc-pcm: add snd_soc_dai_get_pcm_stream()
    
    DAI driver has playback/capture stream.
    OTOH, we have SNDRV_PCM_STREAM_PLAYBACK/CAPTURE.
    Because of this kind of implementation,
    ALSA SoC needs to have many verbose code.
    
    To solve this issue, this patch adds snd_soc_dai_get_pcm_stream() macro
    to get playback/capture stream pointer from stream.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ftf7jcab.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 73a829393652..19142f6e533c 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -390,12 +390,7 @@ int snd_soc_dai_compress_new(struct snd_soc_dai *dai,
  */
 bool snd_soc_dai_stream_valid(struct snd_soc_dai *dai, int dir)
 {
-	struct snd_soc_pcm_stream *stream;
-
-	if (dir == SNDRV_PCM_STREAM_PLAYBACK)
-		stream = &dai->driver->playback;
-	else
-		stream = &dai->driver->capture;
+	struct snd_soc_pcm_stream *stream = snd_soc_dai_get_pcm_stream(dai, dir);
 
 	/* If the codec specifies any channels at all, it supports the stream */
 	return stream->channels_min;

commit b56be800f1292c9b79c4f66571c701551bdf9e12
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 10 12:14:33 2020 +0900

    ASoC: soc-pcm: call snd_soc_dai_startup()/shutdown() once
    
    Current soc_pcm_open() calls snd_soc_dai_startup() under loop.
    Thus, it needs to care about started/not-yet-started codec DAI.
    
    But, if soc-dai.c is handling it, soc-pcm.c don't need to care
    about it.
    This patch adds started flag to soc-dai.h, and simplify soc-pcm.c.
    This is one of prepare for cleanup soc-pcm-open()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/875zgfcey5.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 51031e330179..73a829393652 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -295,17 +295,24 @@ int snd_soc_dai_startup(struct snd_soc_dai *dai,
 {
 	int ret = 0;
 
-	if (dai->driver->ops->startup)
+	if (!dai->started &&
+	    dai->driver->ops->startup)
 		ret = dai->driver->ops->startup(substream, dai);
 
+	if (ret == 0)
+		dai->started = 1;
+
 	return ret;
 }
 
 void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
 			 struct snd_pcm_substream *substream)
 {
-	if (dai->driver->ops->shutdown)
+	if (dai->started &&
+	    dai->driver->ops->shutdown)
 		dai->driver->ops->shutdown(substream, dai);
+
+	dai->started = 0;
 }
 
 int snd_soc_dai_prepare(struct snd_soc_dai *dai,

commit 450312b640f9c6caeeaf4bd8d4130f86ea27f456
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 20 10:05:03 2020 +0900

    ASoC: soc-core: remove DAI suspend/resume
    
    Historically, CPU and Codec were implemented different, but now it is
    merged as Component.
    ALSA SoC is supporting suspend/resume at DAI and Component level.
    The method is like below.
    
            1) Suspend/Resume all CPU DAI if bus-control was 0
            2) Suspend/Resume all Component
            3) Suspend/Resume all CPU DAI if bus-control was 1
    
    Historically 2) was Codec special operation.
    Because CPU and Codec were merged into Component,
    CPU   suspend/resume has 3 chance to suspend(= 1/2/3), but
    Codec suspend/resume has 1 chance (= 2).
    
    Here, DAI side suspend/resume is caring bus-control, but no driver
    which is supporting suspend/resume is setting bus-control.
    This means 3) was never used.
    
    Here, used parameter for suspend/resume component->dev and dai->dev are
    same pointer.
    For that reason, we can merge DAI and Component suspend/resume.
    One note is that we should use 2), because it is caring BIAS level.
    
    This patch removes 1) and 3).
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87r1zvx7i8.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 1c7f63871c1d..51031e330179 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -354,18 +354,6 @@ snd_pcm_sframes_t snd_soc_dai_delay(struct snd_soc_dai *dai,
 	return delay;
 }
 
-void snd_soc_dai_suspend(struct snd_soc_dai *dai)
-{
-	if (dai->driver->suspend)
-		dai->driver->suspend(dai);
-}
-
-void snd_soc_dai_resume(struct snd_soc_dai *dai)
-{
-	if (dai->driver->resume)
-		dai->driver->resume(dai);
-}
-
 int snd_soc_dai_probe(struct snd_soc_dai *dai)
 {
 	if (dai->driver->probe)

commit 467fece8fbc6774a3a3bd0981e1a342fb5022706
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:36:16 2019 +0900

    ASoC: soc-dai: move snd_soc_dai_stream_valid() to soc-dai.c
    
    snd_soc_dai_stream_valid() is function to check stream validity.
    But, some code is using it, some code are checking stream->channels_min
    directly. Doing samethings by different method is confusable.
    This patch uses same funcntion for same purpose.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ftmyhmzz.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index e6f161b9f975..1c7f63871c1d 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -387,3 +387,21 @@ int snd_soc_dai_compress_new(struct snd_soc_dai *dai,
 		return dai->driver->compress_new(rtd, num);
 	return -ENOTSUPP;
 }
+
+/*
+ * snd_soc_dai_stream_valid() - check if a DAI supports the given stream
+ *
+ * Returns true if the DAI supports the indicated stream type.
+ */
+bool snd_soc_dai_stream_valid(struct snd_soc_dai *dai, int dir)
+{
+	struct snd_soc_pcm_stream *stream;
+
+	if (dir == SNDRV_PCM_STREAM_PLAYBACK)
+		stream = &dai->driver->playback;
+	else
+		stream = &dai->driver->capture;
+
+	/* If the codec specifies any channels at all, it supports the stream */
+	return stream->channels_min;
+}

commit b423c4202135f7794e0a9c55a884f5933d8e7156
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:35:29 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_compress_new()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_compress_new() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87h87ehn1a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 384765c747da..e6f161b9f975 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -379,3 +379,11 @@ int snd_soc_dai_remove(struct snd_soc_dai *dai)
 		return dai->driver->remove(dai);
 	return 0;
 }
+
+int snd_soc_dai_compress_new(struct snd_soc_dai *dai,
+			     struct snd_soc_pcm_runtime *rtd, int num)
+{
+	if (dai->driver->compress_new)
+		return dai->driver->compress_new(rtd, num);
+	return -ENOTSUPP;
+}

commit dcdab5820edd6123911dbd767ee1e389008b6a83
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:35:05 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_remove()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_remvoe() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87imruhn1x.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 55c1fac99613..384765c747da 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -372,3 +372,10 @@ int snd_soc_dai_probe(struct snd_soc_dai *dai)
 		return dai->driver->probe(dai);
 	return 0;
 }
+
+int snd_soc_dai_remove(struct snd_soc_dai *dai)
+{
+	if (dai->driver->remove)
+		return dai->driver->remove(dai);
+	return 0;
+}

commit cfd9b5fbfe1e8763018aea2600aa0d6ff015ebfc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:34:56 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_probe()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_probe() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87k1cahn26.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index ddb6f217c0ed..55c1fac99613 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -365,3 +365,10 @@ void snd_soc_dai_resume(struct snd_soc_dai *dai)
 	if (dai->driver->resume)
 		dai->driver->resume(dai);
 }
+
+int snd_soc_dai_probe(struct snd_soc_dai *dai)
+{
+	if (dai->driver->probe)
+		return dai->driver->probe(dai);
+	return 0;
+}

commit 24b09d051164680f0a1d1910efe21ce36ad5c1ca
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:34:43 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_resume()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_resume() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87lfwqhn2j.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 3373598e0682..ddb6f217c0ed 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -359,3 +359,9 @@ void snd_soc_dai_suspend(struct snd_soc_dai *dai)
 	if (dai->driver->suspend)
 		dai->driver->suspend(dai);
 }
+
+void snd_soc_dai_resume(struct snd_soc_dai *dai)
+{
+	if (dai->driver->resume)
+		dai->driver->resume(dai);
+}

commit e0f2262292d0c8160cfd9a8c40425107fb65ab29
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:34:29 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_suspend()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_suspend() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87muh6hn2x.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 5b5b979cd1f3..3373598e0682 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -353,3 +353,9 @@ snd_pcm_sframes_t snd_soc_dai_delay(struct snd_soc_dai *dai,
 
 	return delay;
 }
+
+void snd_soc_dai_suspend(struct snd_soc_dai *dai)
+{
+	if (dai->driver->suspend)
+		dai->driver->suspend(dai);
+}

commit 1dea80d4b2bd3b53c58f008ca2bcd73182583711
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:34:09 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_delay()
    
    Current ALSA SoC is directly using dai->driver->ops->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_delay() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87o91mhn3i.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 6f466cfcbeef..5b5b979cd1f3 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -342,3 +342,14 @@ int snd_soc_dai_bespoke_trigger(struct snd_soc_dai *dai,
 
 	return ret;
 }
+
+snd_pcm_sframes_t snd_soc_dai_delay(struct snd_soc_dai *dai,
+				    struct snd_pcm_substream *substream)
+{
+	int delay = 0;
+
+	if (dai->driver->ops->delay)
+		delay = dai->driver->ops->delay(substream, dai);
+
+	return delay;
+}

commit 5c0769af4caf8fbdad2e9c0051ab0081b8e22b0a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:33:56 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_bespoke_trigger()
    
    Current ALSA SoC is directly using dai->driver->ops->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_bespoke_trigger() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87r26ihn3u.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 18c447e169f6..6f466cfcbeef 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -330,3 +330,15 @@ int snd_soc_dai_trigger(struct snd_soc_dai *dai,
 
 	return ret;
 }
+
+int snd_soc_dai_bespoke_trigger(struct snd_soc_dai *dai,
+				struct snd_pcm_substream *substream,
+				int cmd)
+{
+	int ret = 0;
+
+	if (dai->driver->ops->bespoke_trigger)
+		ret = dai->driver->ops->bespoke_trigger(substream, cmd, dai);
+
+	return ret;
+}

commit 95aef35533844f35544851b0cdc1fc154b603307
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:33:51 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_trigger()
    
    Current ALSA SoC is directly using dai->driver->ops->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_trigger() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87sgqyhn40.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index cb810888c563..18c447e169f6 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -318,3 +318,15 @@ int snd_soc_dai_prepare(struct snd_soc_dai *dai,
 
 	return ret;
 }
+
+int snd_soc_dai_trigger(struct snd_soc_dai *dai,
+			struct snd_pcm_substream *substream,
+			int cmd)
+{
+	int ret = 0;
+
+	if (dai->driver->ops->trigger)
+		ret = dai->driver->ops->trigger(substream, cmd, dai);
+
+	return ret;
+}

commit 4beb8e109d30d339d44308a767dd6f5614492f3e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:33:45 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_prepare()
    
    Current ALSA SoC is directly using dai->driver->ops->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_prepare() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87tvbehn46.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 67ff6cc1fe02..cb810888c563 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -307,3 +307,14 @@ void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
 	if (dai->driver->ops->shutdown)
 		dai->driver->ops->shutdown(substream, dai);
 }
+
+int snd_soc_dai_prepare(struct snd_soc_dai *dai,
+			struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+
+	if (dai->driver->ops->prepare)
+		ret = dai->driver->ops->prepare(substream, dai);
+
+	return ret;
+}

commit 330fcb5135e0588b1ea3b0bbab587d1317c1cf7b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:33:39 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_shutdown()
    
    Current ALSA SoC is directly using dai->driver->ops->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_shutdown() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87v9vuhn4b.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 6e196636e42f..67ff6cc1fe02 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -300,3 +300,10 @@ int snd_soc_dai_startup(struct snd_soc_dai *dai,
 
 	return ret;
 }
+
+void snd_soc_dai_shutdown(struct snd_soc_dai *dai,
+			 struct snd_pcm_substream *substream)
+{
+	if (dai->driver->ops->shutdown)
+		dai->driver->ops->shutdown(substream, dai);
+}

commit 5a52a04531486e2ab069b7882432c8b266db36e6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:33:32 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_startup()
    
    Current ALSA SoC is directly using dai->driver->ops->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_startup() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87wogahn4i.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index 39a685e6acd5..6e196636e42f 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -289,3 +289,14 @@ void snd_soc_dai_hw_free(struct snd_soc_dai *dai,
 	if (dai->driver->ops->hw_free)
 		dai->driver->ops->hw_free(substream, dai);
 }
+
+int snd_soc_dai_startup(struct snd_soc_dai *dai,
+			struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+
+	if (dai->driver->ops->startup)
+		ret = dai->driver->ops->startup(substream, dai);
+
+	return ret;
+}

commit 846faaed9df7899e74311db3aec0a41a2f6bc345
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:33:19 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_hw_free()
    
    Current ALSA SoC is directly using dai->driver->ops->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_hw_free() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87y30qhn4w.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index f883d27d136f..39a685e6acd5 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -282,3 +282,10 @@ int snd_soc_dai_hw_params(struct snd_soc_dai *dai,
 
 	return 0;
 }
+
+void snd_soc_dai_hw_free(struct snd_soc_dai *dai,
+			 struct snd_pcm_substream *substream)
+{
+	if (dai->driver->ops->hw_free)
+		dai->driver->ops->hw_free(substream, dai);
+}

commit aa6166c2ac28392d64f2d8b3acfb56c8fe657147
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:33:04 2019 +0900

    ASoC: soc-dai: mv soc_dai_hw_params() to soc-dai
    
    Sometimes ALSA SoC naming is very random.
    Current soc_dai_hw_params() should use snd_soc_dai_xxx() style.
    And then, 1st parameter should be dai. Otherwise it is confusable.
     - soc_dai_hw_params(..., dai);
     + snd_soc_dai_hw_params(dai, ...);
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87zhl6hn5b.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
index a1009ead40de..f883d27d136f 100644
--- a/sound/soc/soc-dai.c
+++ b/sound/soc/soc-dai.c
@@ -252,3 +252,33 @@ int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
 		return -ENOTSUPP;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
+
+int snd_soc_dai_hw_params(struct snd_soc_dai *dai,
+			  struct snd_pcm_substream *substream,
+			  struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int ret;
+
+	/* perform any topology hw_params fixups before DAI  */
+	if (rtd->dai_link->be_hw_params_fixup) {
+		ret = rtd->dai_link->be_hw_params_fixup(rtd, params);
+		if (ret < 0) {
+			dev_err(rtd->dev,
+				"ASoC: hw_params topology fixup failed %d\n",
+				ret);
+			return ret;
+		}
+	}
+
+	if (dai->driver->ops->hw_params) {
+		ret = dai->driver->ops->hw_params(substream, params, dai);
+		if (ret < 0) {
+			dev_err(dai->dev, "ASoC: can't set %s hw params: %d\n",
+				dai->name, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}

commit 06f6e1d41427f394ad3f67ecf06efcd28a46932c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:32:12 2019 +0900

    ASoC: add soc-dai.c
    
    Current ALSA SoC has many snd_soc_dai_xxx() function which is
    using dai->driver->ops->xxx.
    But, some of them are implemented as snd_soc_dai_xxx(),
    but others are directly using dai->driver->ops->xxx.
    Because of it, the code is not easy to read.
    
    This patch creats new soc-dai.c and moves snd_soc_dai_xxx()
    functions into it.
    One exception is snd_soc_dai_is_dummy() which is based on
    soc-utils local variable. We need to keep it as-is there.
    
    Others which is directly using dai->driver->ops->xxx will be
    implemented at soc-dai.c by incremental patches.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/871ryij1r6.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-dai.c b/sound/soc/soc-dai.c
new file mode 100644
index 000000000000..a1009ead40de
--- /dev/null
+++ b/sound/soc/soc-dai.c
@@ -0,0 +1,254 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// soc-dai.c
+//
+// Copyright (C) 2019 Renesas Electronics Corp.
+// Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+//
+
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+
+/**
+ * snd_soc_dai_set_sysclk - configure DAI system or master clock.
+ * @dai: DAI
+ * @clk_id: DAI specific clock ID
+ * @freq: new clock frequency in Hz
+ * @dir: new clock direction - input/output.
+ *
+ * Configures the DAI master (MCLK) or system (SYSCLK) clocking.
+ */
+int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+			   unsigned int freq, int dir)
+{
+	if (dai->driver->ops->set_sysclk)
+		return dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
+
+	return snd_soc_component_set_sysclk(dai->component, clk_id, 0,
+					    freq, dir);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
+
+/**
+ * snd_soc_dai_set_clkdiv - configure DAI clock dividers.
+ * @dai: DAI
+ * @div_id: DAI specific clock divider ID
+ * @div: new clock divisor.
+ *
+ * Configures the clock dividers. This is used to derive the best DAI bit and
+ * frame clocks from the system or master clock. It's best to set the DAI bit
+ * and frame clocks as low as possible to save system power.
+ */
+int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
+			   int div_id, int div)
+{
+	if (dai->driver->ops->set_clkdiv)
+		return dai->driver->ops->set_clkdiv(dai, div_id, div);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
+
+/**
+ * snd_soc_dai_set_pll - configure DAI PLL.
+ * @dai: DAI
+ * @pll_id: DAI specific PLL ID
+ * @source: DAI specific source for the PLL
+ * @freq_in: PLL input clock frequency in Hz
+ * @freq_out: requested PLL output clock frequency in Hz
+ *
+ * Configures and enables PLL to generate output clock based on input clock.
+ */
+int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
+			unsigned int freq_in, unsigned int freq_out)
+{
+	if (dai->driver->ops->set_pll)
+		return dai->driver->ops->set_pll(dai, pll_id, source,
+						 freq_in, freq_out);
+
+	return snd_soc_component_set_pll(dai->component, pll_id, source,
+					 freq_in, freq_out);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
+
+/**
+ * snd_soc_dai_set_bclk_ratio - configure BCLK to sample rate ratio.
+ * @dai: DAI
+ * @ratio: Ratio of BCLK to Sample rate.
+ *
+ * Configures the DAI for a preset BCLK to sample rate ratio.
+ */
+int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
+{
+	if (dai->driver->ops->set_bclk_ratio)
+		return dai->driver->ops->set_bclk_ratio(dai, ratio);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
+
+/**
+ * snd_soc_dai_set_fmt - configure DAI hardware audio format.
+ * @dai: DAI
+ * @fmt: SND_SOC_DAIFMT_* format value.
+ *
+ * Configures the DAI hardware format and clocking.
+ */
+int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	if (dai->driver->ops->set_fmt == NULL)
+		return -ENOTSUPP;
+	return dai->driver->ops->set_fmt(dai, fmt);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
+
+/**
+ * snd_soc_xlate_tdm_slot - generate tx/rx slot mask.
+ * @slots: Number of slots in use.
+ * @tx_mask: bitmask representing active TX slots.
+ * @rx_mask: bitmask representing active RX slots.
+ *
+ * Generates the TDM tx and rx slot default masks for DAI.
+ */
+static int snd_soc_xlate_tdm_slot_mask(unsigned int slots,
+				       unsigned int *tx_mask,
+				       unsigned int *rx_mask)
+{
+	if (*tx_mask || *rx_mask)
+		return 0;
+
+	if (!slots)
+		return -EINVAL;
+
+	*tx_mask = (1 << slots) - 1;
+	*rx_mask = (1 << slots) - 1;
+
+	return 0;
+}
+
+/**
+ * snd_soc_dai_set_tdm_slot() - Configures a DAI for TDM operation
+ * @dai: The DAI to configure
+ * @tx_mask: bitmask representing active TX slots.
+ * @rx_mask: bitmask representing active RX slots.
+ * @slots: Number of slots in use.
+ * @slot_width: Width in bits for each slot.
+ *
+ * This function configures the specified DAI for TDM operation. @slot contains
+ * the total number of slots of the TDM stream and @slot_with the width of each
+ * slot in bit clock cycles. @tx_mask and @rx_mask are bitmasks specifying the
+ * active slots of the TDM stream for the specified DAI, i.e. which slots the
+ * DAI should write to or read from. If a bit is set the corresponding slot is
+ * active, if a bit is cleared the corresponding slot is inactive. Bit 0 maps to
+ * the first slot, bit 1 to the second slot and so on. The first active slot
+ * maps to the first channel of the DAI, the second active slot to the second
+ * channel and so on.
+ *
+ * TDM mode can be disabled by passing 0 for @slots. In this case @tx_mask,
+ * @rx_mask and @slot_width will be ignored.
+ *
+ * Returns 0 on success, a negative error code otherwise.
+ */
+int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
+			     unsigned int tx_mask, unsigned int rx_mask,
+			     int slots, int slot_width)
+{
+	if (dai->driver->ops->xlate_tdm_slot_mask)
+		dai->driver->ops->xlate_tdm_slot_mask(slots,
+						      &tx_mask, &rx_mask);
+	else
+		snd_soc_xlate_tdm_slot_mask(slots, &tx_mask, &rx_mask);
+
+	dai->tx_mask = tx_mask;
+	dai->rx_mask = rx_mask;
+
+	if (dai->driver->ops->set_tdm_slot)
+		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
+						      slots, slot_width);
+	else
+		return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
+
+/**
+ * snd_soc_dai_set_channel_map - configure DAI audio channel map
+ * @dai: DAI
+ * @tx_num: how many TX channels
+ * @tx_slot: pointer to an array which imply the TX slot number channel
+ *           0~num-1 uses
+ * @rx_num: how many RX channels
+ * @rx_slot: pointer to an array which imply the RX slot number channel
+ *           0~num-1 uses
+ *
+ * configure the relationship between channel number and TDM slot number.
+ */
+int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,
+				unsigned int tx_num, unsigned int *tx_slot,
+				unsigned int rx_num, unsigned int *rx_slot)
+{
+	if (dai->driver->ops->set_channel_map)
+		return dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,
+							 rx_num, rx_slot);
+	else
+		return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);
+
+/**
+ * snd_soc_dai_get_channel_map - Get DAI audio channel map
+ * @dai: DAI
+ * @tx_num: how many TX channels
+ * @tx_slot: pointer to an array which imply the TX slot number channel
+ *           0~num-1 uses
+ * @rx_num: how many RX channels
+ * @rx_slot: pointer to an array which imply the RX slot number channel
+ *           0~num-1 uses
+ */
+int snd_soc_dai_get_channel_map(struct snd_soc_dai *dai,
+				unsigned int *tx_num, unsigned int *tx_slot,
+				unsigned int *rx_num, unsigned int *rx_slot)
+{
+	if (dai->driver->ops->get_channel_map)
+		return dai->driver->ops->get_channel_map(dai, tx_num, tx_slot,
+							 rx_num, rx_slot);
+	else
+		return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_get_channel_map);
+
+/**
+ * snd_soc_dai_set_tristate - configure DAI system or master clock.
+ * @dai: DAI
+ * @tristate: tristate enable
+ *
+ * Tristates the DAI so that others can use it.
+ */
+int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
+{
+	if (dai->driver->ops->set_tristate)
+		return dai->driver->ops->set_tristate(dai, tristate);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
+
+/**
+ * snd_soc_dai_digital_mute - configure DAI system or master clock.
+ * @dai: DAI
+ * @mute: mute enable
+ * @direction: stream to mute
+ *
+ * Mutes the DAI DAC.
+ */
+int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
+			     int direction)
+{
+	if (dai->driver->ops->mute_stream)
+		return dai->driver->ops->mute_stream(dai, mute, direction);
+	else if (direction == SNDRV_PCM_STREAM_PLAYBACK &&
+		 dai->driver->ops->digital_mute)
+		return dai->driver->ops->digital_mute(dai, mute);
+	else
+		return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
