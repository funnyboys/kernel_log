commit 34a43780622ace5a495d1dd661e5d493123d4e3f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 23 14:20:30 2020 +0900

    ASoC: sh: use asoc_rtd_to_cpu() / asoc_rtd_to_codec() macro for DAI pointer
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87eetjir4x.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 0bfcb77e5f65..4349f2fb823f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -696,7 +696,7 @@ struct snd_soc_dai *rsnd_substream_to_dai(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 
-	return  rtd->cpu_dai;
+	return  asoc_rtd_to_cpu(rtd, 0);
 }
 
 static

commit e91f134c83b1b3319db4c14bb5d9d23dc567b283
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 15:53:57 2019 +0100

    ASoC: sh: Drop superfluous ioctl PCM ops
    
    ASoC PCM core deals the empty ioctl field now as default.
    Let's kill the redundant lines.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20191210145406.21419-15-tiwai@suse.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3dfc02092f76..0bfcb77e5f65 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1652,7 +1652,6 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
  */
 static const struct snd_soc_component_driver rsnd_soc_component = {
 	.name		= "rsnd",
-	.ioctl		= snd_soc_pcm_lib_ioctl,
 	.hw_params	= rsnd_hw_params,
 	.hw_free	= rsnd_hw_free,
 	.pointer	= rsnd_pointer,

commit e494dbcd9be743f41cf842f94ffbc7c56b6b072a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 15:25:59 2019 +0100

    ASoC: rcar: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The superfluous snd_pcm_lib_malloc_pages() and
    snd_pcm_lib_free_pages() calls are dropped.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20191210142614.19405-9-tiwai@suse.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 6aac25095218..3dfc02092f76 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1218,10 +1218,10 @@ static int rsnd_preallocate_pages(struct snd_soc_pcm_runtime *rtd,
 	for (substream = rtd->pcm->streams[stream].substream;
 	     substream;
 	     substream = substream->next) {
-		snd_pcm_lib_preallocate_pages(substream,
-					      SNDRV_DMA_TYPE_DEV,
-					      dev,
-					      PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
+		snd_pcm_set_managed_buffer(substream,
+					   SNDRV_DMA_TYPE_DEV,
+					   dev,
+					   PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
 	}
 
 	return 0;
@@ -1400,7 +1400,6 @@ static int rsnd_hw_params(struct snd_soc_component *component,
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
 	struct snd_soc_pcm_runtime *fe = substream->private_data;
-	int ret;
 
 	/*
 	 * rsnd assumes that it might be used under DPCM if user want to use
@@ -1433,12 +1432,7 @@ static int rsnd_hw_params(struct snd_soc_component *component,
 			dev_dbg(dev, "convert rate     = %d\n", io->converted_rate);
 	}
 
-	ret = rsnd_dai_call(hw_params, io, substream, hw_params);
-	if (ret)
-		return ret;
-
-	return snd_pcm_lib_malloc_pages(substream,
-					params_buffer_bytes(hw_params));
+	return rsnd_dai_call(hw_params, io, substream, hw_params);
 }
 
 static int rsnd_hw_free(struct snd_soc_component *component,
@@ -1447,13 +1441,8 @@ static int rsnd_hw_free(struct snd_soc_component *component,
 	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
-	int ret;
-
-	ret = rsnd_dai_call(hw_free, io, substream);
-	if (ret)
-		return ret;
 
-	return snd_pcm_lib_free_pages(substream);
+	return rsnd_dai_call(hw_free, io, substream);
 }
 
 static snd_pcm_uframes_t rsnd_pointer(struct snd_soc_component *component,

commit b553bd238da23041bf39110e58ee80f8efe034e0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:33:50 2019 +0900

    ASoC: soc-core: remove snd_soc_disconnect_sync()
    
    Sound card disconnecting operation was needed when "sound driver" was
    unbinded without unbinding "sound card".
    In such case, sound driver should be stopped even though it was
    playbacking/capturing. Otherwise clock open/close counter mismatch happen.
    
    One headache was that we can't skip unbind in error case because unbind
    operation doesn't check return value from each drivers.
    snd_soc_disconnect_sync() was added for these purpose, and Renesas
    sound card only is used it.
    
    But now, ALSA SoC automatically disconnect sound card when sound driver
    was unbinded. Thus, snd_soc_disconnect_sync() is no longer needed.
    This patch removes it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87eexdyq6p.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index d20f03dfdee6..6aac25095218 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1819,8 +1819,6 @@ static int rsnd_remove(struct platform_device *pdev)
 	};
 	int ret = 0, i;
 
-	snd_soc_disconnect_sync(&pdev->dev);
-
 	pm_runtime_disable(&pdev->dev);
 
 	for_each_rsnd_dai(rdai, priv, i) {

commit 49df1e3925824cf44e590daac635974270185841
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Dec 2 16:58:34 2019 +0100

    ASoC: rsnd: Calculate DALIGN inversion at run-time
    
    There is no need to store the inverted DALIGN values in the table, as
    they can easily be calculated at run-time.  This also protects against
    the introduction of inconsistencies between normal and inverted values
    by a future table modification.
    
    Reorder the two subexpressions in the AND check, to perform the least
    expensive check first.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/20191202155834.22582-1-geert+renesas@glider.be
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 399dc6e9bde5..d20f03dfdee6 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -376,20 +376,15 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
  */
 u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 {
-	static const u32 dalign_values[8][2] = {
-		{0x76543210, 0x67452301},
-		{0x00000032, 0x00000023},
-		{0x00007654, 0x00006745},
-		{0x00000076, 0x00000067},
-		{0xfedcba98, 0xefcdab89},
-		{0x000000ba, 0x000000ab},
-		{0x0000fedc, 0x0000efcd},
-		{0x000000fe, 0x000000ef},
+	static const u32 dalign_values[8] = {
+		0x76543210, 0x00000032, 0x00007654, 0x00000076,
+		0xfedcba98, 0x000000ba, 0x0000fedc, 0x000000fe,
 	};
-	int id = 0, inv;
+	int id = 0;
 	struct rsnd_mod *ssiu = rsnd_io_to_mod_ssiu(io);
 	struct rsnd_mod *target;
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	u32 dalign;
 
 	/*
 	 * *Hardware* L/R and *Software* L/R are inverted for 16bit data.
@@ -425,15 +420,15 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	if (mod == ssiu)
 		id = rsnd_mod_id_sub(mod);
 
-	/* Non target mod or non 16bit needs normal DALIGN */
-	if ((snd_pcm_format_width(runtime->format) != 16) ||
-	    (mod != target))
-		inv = 0;
-	/* Target mod needs inverted DALIGN when 16bit */
-	else
-		inv = 1;
+	dalign = dalign_values[id];
+
+	if (mod == target && snd_pcm_format_width(runtime->format) == 16) {
+		/* Target mod needs inverted DALIGN when 16bit */
+		dalign = (dalign & 0xf0f0f0f0) >> 4 |
+			 (dalign & 0x0f0f0f0f) << 4;
+	}
 
-	return dalign_values[id][inv];
+	return dalign;
 }
 
 u32 rsnd_get_busif_shift(struct rsnd_dai_stream *io, struct rsnd_mod *mod)

commit 8c4d2a0bfbd27d030e4652b714cd5a1598f3559b
Merge: 3701d2cb8767 39870b0dec68
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Nov 22 19:56:02 2019 +0000

    Merge branch 'asoc-5.5' into asoc-next

commit ef8e14794308a428b194f8b06ad9ae06b43466e4
Author: Nilkanth Ahirrao <anilkanth@jp.adit-jv.com>
Date:   Thu Nov 21 12:10:23 2019 +0100

    ASoC: rsnd: fix DALIGN register for SSIU
    
    The current driver only sets 0x76543210 and 0x67452301 for DALIGN.
    This doesnâ€™t work well for TDM split and ex-split mode for all SSIU.
    This patch programs the DALIGN registers based on the SSIU number.
    
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jiada Wang <jiada_wang@mentor.com>
    Cc: Andrew Gabbasov <andrew_gabbasov@mentor.com>
    Fixes: a914e44693d41b ("ASoC: rsnd: more clear rsnd_get_dalign() for DALIGN")
    Signed-off-by: Nilkanth Ahirrao <anilkanth@jp.adit-jv.com>
    Signed-off-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/20191121111023.10976-1-erosca@de.adit-jv.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index e9596c2096cd..a6c1cf987e6e 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -376,6 +376,17 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
  */
 u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 {
+	static const u32 dalign_values[8][2] = {
+		{0x76543210, 0x67452301},
+		{0x00000032, 0x00000023},
+		{0x00007654, 0x00006745},
+		{0x00000076, 0x00000067},
+		{0xfedcba98, 0xefcdab89},
+		{0x000000ba, 0x000000ab},
+		{0x0000fedc, 0x0000efcd},
+		{0x000000fe, 0x000000ef},
+	};
+	int id = 0, inv;
 	struct rsnd_mod *ssiu = rsnd_io_to_mod_ssiu(io);
 	struct rsnd_mod *target;
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
@@ -411,13 +422,18 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 		target = cmd ? cmd : ssiu;
 	}
 
+	if (mod == ssiu)
+		id = rsnd_mod_id_sub(mod);
+
 	/* Non target mod or non 16bit needs normal DALIGN */
 	if ((snd_pcm_format_width(runtime->format) != 16) ||
 	    (mod != target))
-		return 0x76543210;
+		inv = 0;
 	/* Target mod needs inverted DALIGN when 16bit */
 	else
-		return 0x67452301;
+		inv = 1;
+
+	return dalign_values[id][inv];
 }
 
 u32 rsnd_get_busif_shift(struct rsnd_dai_stream *io, struct rsnd_mod *mod)

commit 992fd39a349ac62044d9e20d17d309c2cf0f5c27
Merge: 18dd66ea8446 9508ef5a980f
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 6 16:29:34 2019 +0000

    Merge branch 'for-5.4' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-5.5

commit 5db8617ba7e8fcda1c5dd310c62ac8d31eaf9eae
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 28 14:29:55 2019 +0900

    ASoC: rsnd: core.c: add WARN_ON() on rsnd_channel_normalization()
    
    chan > 8 or chan < 0 shouldn't happen.
    This patch uses WARN_ON() for such case.
    
    Reported-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87y2x530a4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 72924c8b0696..871afe75ca42 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -302,7 +302,7 @@ int rsnd_runtime_channel_after_ctu_with_params(struct rsnd_dai_stream *io,
 
 int rsnd_channel_normalization(int chan)
 {
-	if ((chan > 8) || (chan < 0))
+	if (WARN_ON((chan > 8) || (chan < 0)))
 		return 0;
 
 	/* TDM Extend Mode needs 8ch */

commit ef2c695151df54817f92128f96a920ff888c6920
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 23 11:10:43 2019 +0900

    ASoC: rsnd: add missing of_node_put()
    
    This patch adds missing of_node_put() for
    rsnd_parse_tdm_split_mode()
    rsnd_parse_connect_graph()
    
    Reported-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/8736fkyzx8.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 4bed26842095..72924c8b0696 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1075,7 +1075,10 @@ static void rsnd_parse_tdm_split_mode(struct rsnd_priv *priv,
 			j++;
 		}
 
+		of_node_put(node);
 	}
+
+	of_node_put(ssiu_np);
 }
 
 static void rsnd_parse_connect_simple(struct rsnd_priv *priv,
@@ -1093,11 +1096,13 @@ static void rsnd_parse_connect_graph(struct rsnd_priv *priv,
 				     struct device_node *endpoint)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
-	struct device_node *remote_node = of_graph_get_remote_port_parent(endpoint);
+	struct device_node *remote_node;
 
 	if (!rsnd_io_to_mod_ssi(io))
 		return;
 
+	remote_node = of_graph_get_remote_port_parent(endpoint);
+
 	/* HDMI0 */
 	if (strstr(remote_node->full_name, "hdmi@fead0000")) {
 		rsnd_flags_set(io, RSND_STREAM_HDMI0);
@@ -1111,6 +1116,8 @@ static void rsnd_parse_connect_graph(struct rsnd_priv *priv,
 	}
 
 	rsnd_parse_tdm_split_mode(priv, io, endpoint);
+
+	of_node_put(remote_node);
 }
 
 void rsnd_parse_connect_common(struct rsnd_dai *rdai,

commit 22e58665a01006d05f0239621f7d41cacca96cc4
Author: Junya Monden <jmonden@jp.adit-jv.com>
Date:   Wed Oct 16 14:42:55 2019 +0200

    ASoC: rsnd: Reinitialize bit clock inversion flag for every format setting
    
    Unlike other format-related DAI parameters, rdai->bit_clk_inv flag
    is not properly re-initialized when setting format for new stream
    processing. The inversion, if requested, is then applied not to default,
    but to a previous value, which leads to SCKP bit in SSICR register being
    set incorrectly.
    Fix this by re-setting the flag to its initial value, determined by format.
    
    Fixes: 1a7889ca8aba3 ("ASoC: rsnd: fixup SND_SOC_DAIFMT_xB_xF behavior")
    Cc: Andrew Gabbasov <andrew_gabbasov@mentor.com>
    Cc: Jiada Wang <jiada_wang@mentor.com>
    Cc: Timo Wischer <twischer@de.adit-jv.com>
    Cc: stable@vger.kernel.org # v3.17+
    Signed-off-by: Junya Monden <jmonden@jp.adit-jv.com>
    Signed-off-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/20191016124255.7442-1-erosca@de.adit-jv.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index bda5b958d0dc..e9596c2096cd 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -761,6 +761,7 @@ static int rsnd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	}
 
 	/* set format */
+	rdai->bit_clk_inv = 0;
 	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 	case SND_SOC_DAIFMT_I2S:
 		rdai->sys_delay = 0;

commit 9dcefa7232d3fd5a7141454849d46ed24c7af867
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:33:01 2019 +0900

    ASoC: sh: rsnd: remove snd_pcm_ops
    
    snd_pcm_ops is no longer needed.
    Let's use component driver callback.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/871rvvaf02.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index bda5b958d0dc..4bed26842095 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1373,8 +1373,9 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 /*
  *		pcm ops
  */
-static int rsnd_hw_params(struct snd_pcm_substream *substream,
-			 struct snd_pcm_hw_params *hw_params)
+static int rsnd_hw_params(struct snd_soc_component *component,
+			  struct snd_pcm_substream *substream,
+			  struct snd_pcm_hw_params *hw_params)
 {
 	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
@@ -1421,7 +1422,8 @@ static int rsnd_hw_params(struct snd_pcm_substream *substream,
 					params_buffer_bytes(hw_params));
 }
 
-static int rsnd_hw_free(struct snd_pcm_substream *substream)
+static int rsnd_hw_free(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream)
 {
 	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
@@ -1435,7 +1437,8 @@ static int rsnd_hw_free(struct snd_pcm_substream *substream)
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static snd_pcm_uframes_t rsnd_pointer(struct snd_pcm_substream *substream)
+static snd_pcm_uframes_t rsnd_pointer(struct snd_soc_component *component,
+				      struct snd_pcm_substream *substream)
 {
 	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
@@ -1447,13 +1450,6 @@ static snd_pcm_uframes_t rsnd_pointer(struct snd_pcm_substream *substream)
 	return pointer;
 }
 
-static const struct snd_pcm_ops rsnd_pcm_ops = {
-	.ioctl		= snd_pcm_lib_ioctl,
-	.hw_params	= rsnd_hw_params,
-	.hw_free	= rsnd_hw_free,
-	.pointer	= rsnd_pointer,
-};
-
 /*
  *		snd_kcontrol
  */
@@ -1647,8 +1643,11 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
  *		snd_soc_component
  */
 static const struct snd_soc_component_driver rsnd_soc_component = {
-	.ops		= &rsnd_pcm_ops,
 	.name		= "rsnd",
+	.ioctl		= snd_soc_pcm_lib_ioctl,
+	.hw_params	= rsnd_hw_params,
+	.hw_free	= rsnd_hw_free,
+	.pointer	= rsnd_pointer,
 };
 
 static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,

commit 859fd6cbf1fb32b5428c26f837215c085b8a822e
Author: Timo Wischer <twischer@de.adit-jv.com>
Date:   Mon Jul 22 16:24:01 2019 +0900

    ASoC: rsnd: Support hw_free() callback at DAI level
    
    This patch provides the needed infrastructure to support calling hw_free()
    at the DAI level. This is for example required to free resources allocated
    in hw_params() callback.
    
    The modification of __rsnd_mod_add_hw_params does not have any side
    effects because rsnd_mod_ops::hw_params callback is not used by anyone
    until now.
    
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Link: https://lore.kernel.org/r/20190722072403.11008-2-jiada_wang@mentor.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 56e8dae9a15c..bda5b958d0dc 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1421,6 +1421,20 @@ static int rsnd_hw_params(struct snd_pcm_substream *substream,
 					params_buffer_bytes(hw_params));
 }
 
+static int rsnd_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+	int ret;
+
+	ret = rsnd_dai_call(hw_free, io, substream);
+	if (ret)
+		return ret;
+
+	return snd_pcm_lib_free_pages(substream);
+}
+
 static snd_pcm_uframes_t rsnd_pointer(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
@@ -1436,7 +1450,7 @@ static snd_pcm_uframes_t rsnd_pointer(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops rsnd_pcm_ops = {
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= rsnd_hw_params,
-	.hw_free	= snd_pcm_lib_free_pages,
+	.hw_free	= rsnd_hw_free,
 	.pointer	= rsnd_pointer,
 };
 

commit e9b5daad4e9bdd1b9e467873a4463c867ccf9ff1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri May 17 10:29:16 2019 +0900

    ASoC: rsnd: move pcm_new from snd_soc_component_driver to snd_soc_dai_driver
    
    snd_soc_dai_driver :: pcm_new has snd_soc_dai as parameter, but
    snd_soc_component_driver :: pcm_new doesn't have it.
    
    rsnd driver needs snd_soc_dai at pcm_new.
    This patch moves .pcm_new from snd_soc_component_driver to
    snd_soc_dai_driver, and don't use rtd->cpu_dai anymore.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 37cb61553d5f..56e8dae9a15c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1176,6 +1176,65 @@ static struct device_node *rsnd_dai_of_node(struct rsnd_priv *priv,
 	return ret;
 }
 
+
+#define PREALLOC_BUFFER		(32 * 1024)
+#define PREALLOC_BUFFER_MAX	(32 * 1024)
+
+static int rsnd_preallocate_pages(struct snd_soc_pcm_runtime *rtd,
+				  struct rsnd_dai_stream *io,
+				  int stream)
+{
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct snd_pcm_substream *substream;
+
+	/*
+	 * use Audio-DMAC dev if we can use IPMMU
+	 * see
+	 *	rsnd_dmaen_attach()
+	 */
+	if (io->dmac_dev)
+		dev = io->dmac_dev;
+
+	for (substream = rtd->pcm->streams[stream].substream;
+	     substream;
+	     substream = substream->next) {
+		snd_pcm_lib_preallocate_pages(substream,
+					      SNDRV_DMA_TYPE_DEV,
+					      dev,
+					      PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
+	}
+
+	return 0;
+}
+
+static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd,
+			struct snd_soc_dai *dai)
+{
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	int ret;
+
+	ret = rsnd_dai_call(pcm_new, &rdai->playback, rtd);
+	if (ret)
+		return ret;
+
+	ret = rsnd_dai_call(pcm_new, &rdai->capture, rtd);
+	if (ret)
+		return ret;
+
+	ret = rsnd_preallocate_pages(rtd, &rdai->playback,
+				     SNDRV_PCM_STREAM_PLAYBACK);
+	if (ret)
+		return ret;
+
+	ret = rsnd_preallocate_pages(rtd, &rdai->capture,
+				     SNDRV_PCM_STREAM_CAPTURE);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 static void __rsnd_dai_probe(struct rsnd_priv *priv,
 			     struct device_node *dai_np,
 			     int dai_i)
@@ -1198,6 +1257,7 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 	rdai->priv	= priv;
 	drv->name	= rdai->name;
 	drv->ops	= &rsnd_soc_dai_ops;
+	drv->pcm_new	= rsnd_pcm_new;
 
 	snprintf(io_playback->name, RSND_DAI_NAME_SIZE,
 		 "DAI%d Playback", dai_i);
@@ -1572,68 +1632,8 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
 /*
  *		snd_soc_component
  */
-
-#define PREALLOC_BUFFER		(32 * 1024)
-#define PREALLOC_BUFFER_MAX	(32 * 1024)
-
-static int rsnd_preallocate_pages(struct snd_soc_pcm_runtime *rtd,
-				  struct rsnd_dai_stream *io,
-				  int stream)
-{
-	struct rsnd_priv *priv = rsnd_io_to_priv(io);
-	struct device *dev = rsnd_priv_to_dev(priv);
-	struct snd_pcm_substream *substream;
-
-	/*
-	 * use Audio-DMAC dev if we can use IPMMU
-	 * see
-	 *	rsnd_dmaen_attach()
-	 */
-	if (io->dmac_dev)
-		dev = io->dmac_dev;
-
-	for (substream = rtd->pcm->streams[stream].substream;
-	     substream;
-	     substream = substream->next) {
-		snd_pcm_lib_preallocate_pages(substream,
-					SNDRV_DMA_TYPE_DEV,
-					dev,
-					PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
-	}
-
-	return 0;
-}
-
-static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_dai *dai = rtd->cpu_dai;
-	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	int ret;
-
-	ret = rsnd_dai_call(pcm_new, &rdai->playback, rtd);
-	if (ret)
-		return ret;
-
-	ret = rsnd_dai_call(pcm_new, &rdai->capture, rtd);
-	if (ret)
-		return ret;
-
-	ret = rsnd_preallocate_pages(rtd, &rdai->playback,
-				     SNDRV_PCM_STREAM_PLAYBACK);
-	if (ret)
-		return ret;
-
-	ret = rsnd_preallocate_pages(rtd, &rdai->capture,
-				     SNDRV_PCM_STREAM_CAPTURE);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
 static const struct snd_soc_component_driver rsnd_soc_component = {
 	.ops		= &rsnd_pcm_ops,
-	.pcm_new	= rsnd_pcm_new,
 	.name		= "rsnd",
 };
 

commit 66287def435315d9d8de740da4c543e37630b897
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Apr 25 15:16:58 2019 +0900

    ASoC: rsnd: fixup 6ch settings to 8ch
    
    rsnd need to use 8ch clock settings for 6ch for TDM.
    Otherwise, it can't work correctly.
    This patch fixup it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 4fe83e611c01..37cb61553d5f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -300,6 +300,18 @@ int rsnd_runtime_channel_after_ctu_with_params(struct rsnd_dai_stream *io,
 	return chan;
 }
 
+int rsnd_channel_normalization(int chan)
+{
+	if ((chan > 8) || (chan < 0))
+		return 0;
+
+	/* TDM Extend Mode needs 8ch */
+	if (chan == 6)
+		chan = 8;
+
+	return chan;
+}
+
 int rsnd_runtime_channel_for_ssi_with_params(struct rsnd_dai_stream *io,
 					     struct snd_pcm_hw_params *params)
 {
@@ -312,11 +324,7 @@ int rsnd_runtime_channel_for_ssi_with_params(struct rsnd_dai_stream *io,
 	if (rsnd_runtime_is_multi_ssi(io))
 		chan /= rsnd_rdai_ssi_lane_get(rdai);
 
-	/* TDM Extend Mode needs 8ch */
-	if (chan == 6)
-		chan = 8;
-
-	return chan;
+	return rsnd_channel_normalization(chan);
 }
 
 int rsnd_runtime_is_multi_ssi(struct rsnd_dai_stream *io)

commit 22d91ed32b653481f47e81719858678e8c92089e
Merge: 2b13bee38849 9e98c678c2d6
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Mar 18 11:14:51 2019 +0000

    Merge tag 'v5.1-rc1' into asoc-5.1
    
    Linux 5.1-rc1

commit ba164a49f8f7390b036713bf8a70a150a938c670
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Thu Mar 7 15:15:53 2019 +0900

    ASoC: rsnd: src: Avoid a potential deadlock
    
    lockdep warns us that priv->lock and k->k_lock can cause a
    deadlock when after acquire of k->k_lock, process is interrupted
    by src, while in another routine of src .init, k->k_lock is
    acquired with priv->lock held.
    
    This patch avoids a potential deadlock by not calling soc_device_match()
    in SRC .init callback, instead it adds new soc fields in priv->flags to
    differentiate SoCs.
    
    Fixes: linux-next commit 7674bec4fc09 ("ASoC: rsnd: update BSDSR/BSDISR handling")
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 9834474684b1..8d3758f862f1 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -110,6 +110,8 @@ static const struct of_device_id rsnd_of_match[] = {
 	{ .compatible = "renesas,rcar_sound-gen1", .data = (void *)RSND_GEN1 },
 	{ .compatible = "renesas,rcar_sound-gen2", .data = (void *)RSND_GEN2 },
 	{ .compatible = "renesas,rcar_sound-gen3", .data = (void *)RSND_GEN3 },
+	/* Special Handling */
+	{ .compatible = "renesas,rcar_sound-r8a77990", .data = (void *)(RSND_GEN3 | RSND_SOC_E) },
 	{},
 };
 MODULE_DEVICE_TABLE(of, rsnd_of_match);

commit d02cac152c97dffcb0cdd91e09b54fd6e2cca63d
Merge: 36e4617c0115 a50e32694fbc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 8 14:20:32 2019 +0100

    Merge tag 'asoc-v5.1' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: Updates for v5.1
    
    Lots and lots of new drivers so far, a highlight being the MediaTek
    BTCVSD which is a driver for a Bluetooth radio chip - the first such
    driver we've had upstream.  Hopefully we will soon also see a baseband
    with an upstream driver!
    
     - Support for only powering up channels that are actively being used.
     - Quite a few improvements to simplify the generic card drivers,
       especially the merge of the SCU cards into the main generic drivers.
     - Lots of fixes for probing on Intel systems, trying to rationalize
       things to look more standard from a framework point of view.
     - New drivers for Asahi Kasei Microdevices AK4497, Cirrus Logic CS4341,
       Google ChromeOS embedded controllers, Ingenic JZ4725B, MediaTek
       BTCVSD, MT8183 and MT6358, NXP MICFIL, Rockchip RK3328, Spreadtrum
       DMA controllers, Qualcomm WCD9335, Xilinx S/PDIF and PCM formatters.

commit e29fe437ea5d926ea23d806b2468bf60ee8dc08a
Merge: 47306401835a c16e12010060
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Feb 6 17:31:39 2019 +0000

    Merge branch 'asoc-5.0' into asoc-5.1 for dapm table

commit b76c7fe6c99d427a064e5e152dca7fe24f424f53
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:39:54 2019 +0100

    ASoC: sh: Drop superfluous PCM preallocation error checks
    
    snd_pcm_lib_preallocate_pages() and co always succeed, so the error
    check is simply redundant.  Drop it.
    
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 59e250cc2e9d..29213b90755f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1575,7 +1575,6 @@ static int rsnd_preallocate_pages(struct snd_soc_pcm_runtime *rtd,
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct snd_pcm_substream *substream;
-	int err;
 
 	/*
 	 * use Audio-DMAC dev if we can use IPMMU
@@ -1588,12 +1587,10 @@ static int rsnd_preallocate_pages(struct snd_soc_pcm_runtime *rtd,
 	for (substream = rtd->pcm->streams[stream].substream;
 	     substream;
 	     substream = substream->next) {
-		err = snd_pcm_lib_preallocate_pages(substream,
+		snd_pcm_lib_preallocate_pages(substream,
 					SNDRV_DMA_TYPE_DEV,
 					dev,
 					PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
-		if (err < 0)
-			return err;
 	}
 
 	return 0;

commit 2264cf2e5db99cdff995592bf80ab6dea567ea91
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 1 16:47:25 2019 +0900

    ASoC: rsnd: fixup TDM Split mode check for CTU
    
    Renesas sound card need to judge that whether it is using
    "TDM Split mode". To judge it and for other purpose, it has
    rsnd_parse_connect_simple() and rsnd_parse_connect_graph(),
    but these are using different judgement policy for
    TDM Split mode.
    It is pointless and confusable.
    This patch add new rsnd_parse_tdm_split_mode() and use common
    judgement policy for simple-card/audio-graph.
    
    Without this patch, CTU will be judged as TDM Split mode
    on audio-graph card.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 2a48d8a6cc76..2c2c60a3f276 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1031,7 +1031,7 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.prepare	= rsnd_soc_dai_prepare,
 };
 
-static void rsnd_parse_connect_simple(struct rsnd_priv *priv,
+static void rsnd_parse_tdm_split_mode(struct rsnd_priv *priv,
 				      struct rsnd_dai_stream *io,
 				      struct device_node *dai_np)
 {
@@ -1044,9 +1044,6 @@ static void rsnd_parse_connect_simple(struct rsnd_priv *priv,
 	if (!ssiu_np)
 		return;
 
-	if (!rsnd_io_to_mod_ssi(io))
-		return;
-
 	/*
 	 * This driver assumes that it is TDM Split mode
 	 * if it includes ssiu node
@@ -1071,12 +1068,21 @@ static void rsnd_parse_connect_simple(struct rsnd_priv *priv,
 	}
 }
 
+static void rsnd_parse_connect_simple(struct rsnd_priv *priv,
+				      struct rsnd_dai_stream *io,
+				      struct device_node *dai_np)
+{
+	if (!rsnd_io_to_mod_ssi(io))
+		return;
+
+	rsnd_parse_tdm_split_mode(priv, io, dai_np);
+}
+
 static void rsnd_parse_connect_graph(struct rsnd_priv *priv,
 				     struct rsnd_dai_stream *io,
 				     struct device_node *endpoint)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
-	struct device_node *remote_port = of_graph_get_remote_port(endpoint);
 	struct device_node *remote_node = of_graph_get_remote_port_parent(endpoint);
 
 	if (!rsnd_io_to_mod_ssi(io))
@@ -1094,14 +1100,7 @@ static void rsnd_parse_connect_graph(struct rsnd_priv *priv,
 		dev_dbg(dev, "%s connected to HDMI1\n", io->name);
 	}
 
-	/*
-	 * This driver assumes that it is TDM Split mode
-	 * if remote node has multi endpoint
-	 */
-	if (of_get_child_count(remote_port) > 1) {
-		rsnd_flags_set(io, RSND_STREAM_TDM_SPLIT);
-		dev_dbg(dev, "%s is part of TDM Split\n", io->name);
-	}
+	rsnd_parse_tdm_split_mode(priv, io, endpoint);
 }
 
 void rsnd_parse_connect_common(struct rsnd_dai *rdai,

commit f497c88b195eaee8733a304f2a1dc27fb319c9c3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 1 16:46:27 2019 +0900

    ASoC: rsnd: synchronize connection check for simple-card/audio-graph
    
    Current rsnd driver has below function to check connection
            rsnd_parse_connect_simple()
            rsnd_parse_connect_graph()
    But these have different parameters. This patch synchronize these
    for cleanup.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 59e250cc2e9d..2a48d8a6cc76 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1032,16 +1032,13 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 };
 
 static void rsnd_parse_connect_simple(struct rsnd_priv *priv,
-				      struct device_node *dai_np,
-				      int dai_i, int is_play)
+				      struct rsnd_dai_stream *io,
+				      struct device_node *dai_np)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
-	struct rsnd_dai *rdai = rsnd_rdai_get(priv, dai_i);
-	struct rsnd_dai_stream *io = is_play ?
-		&rdai->playback :
-		&rdai->capture;
 	struct device_node *ssiu_np = rsnd_ssiu_of_node(priv);
 	struct device_node *np;
+	int is_play = rsnd_io_is_play(io);
 	int i, j;
 
 	if (!ssiu_np)
@@ -1292,8 +1289,10 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 		for_each_child_of_node(dai_node, dai_np) {
 			__rsnd_dai_probe(priv, dai_np, dai_i);
 			if (rsnd_is_gen3(priv)) {
-				rsnd_parse_connect_simple(priv, dai_np, dai_i, 1);
-				rsnd_parse_connect_simple(priv, dai_np, dai_i, 0);
+				struct rsnd_dai *rdai = rsnd_rdai_get(priv, dai_i);
+
+				rsnd_parse_connect_simple(priv, &rdai->playback, dai_np);
+				rsnd_parse_connect_simple(priv, &rdai->capture,  dai_np);
 			}
 			dai_i++;
 		}

commit 7aea8a9d71d54f449f49e20324df06341cc18395
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 1 16:49:30 2019 +0900

    ASoC: rsnd: fixup MIX kctrl registration
    
    Renesas sound device has many IPs and many situations.
    If platform/board uses MIXer, situation will be more complex.
    To avoid duplicate DVC kctrl registration when MIXer was used,
    it had original flags.
    But it was issue when sound card was re-binded, because
    no one can't cleanup this flags then.
    
    To solve this issue, commit 9c698e8481a15237a ("ASoC: rsnd: tidyup
    registering method for rsnd_kctrl_new()") checks registered
    card->controls, because if card was re-binded, these were cleanuped
    automatically. This patch could solve re-binding issue.
    But, it start to avoid MIX kctrl.
    
    To solve these issues, we need below.
    To avoid card re-binding issue: check registered card->controls
    To avoid duplicate DVC registration: check registered rsnd_kctrl_cfg
    To allow multiple MIX registration: check registered rsnd_kctrl_cfg
    This patch do it.
    
    Fixes: 9c698e8481a15237a ("ASoC: rsnd: tidyup registering method for rsnd_kctrl_new()")
    Reported-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-By: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 59e250cc2e9d..e819e965e1db 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1526,14 +1526,14 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
 	int ret;
 
 	/*
-	 * 1) Avoid duplicate register (ex. MIXer case)
-	 * 2) re-register if card was rebinded
+	 * 1) Avoid duplicate register for DVC with MIX case
+	 * 2) Allow duplicate register for MIX
+	 * 3) re-register if card was rebinded
 	 */
 	list_for_each_entry(kctrl, &card->controls, list) {
 		struct rsnd_kctrl_cfg *c = kctrl->private_data;
 
-		if (strcmp(kctrl->id.name, name) == 0 &&
-		    c->mod == mod)
+		if (c == cfg)
 			return 0;
 	}
 

commit 8fe8915b6c0b5298fa547be21957b3860c39c46e
Merge: 1b46ed96961d a01b8d1d2445
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Dec 13 14:36:46 2018 +0000

    Merge branch 'for-4.20' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-4.21 intel dep

commit 538a4ffea3f719ed8f853f78826e360aee5fe9d7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 4 08:02:43 2018 +0000

    ASoC: rsnd: add missing TDM Split mode support for simple-card
    
    commit f69f452243e4e1 ("ASoC: rsnd: add TDM Split mode support")
    added TDM Split mode support for rsnd driver.
    But, it cares audio-graph-card style only. We can't use TDM Split
    mode on simple-card style now.
    This patch fixup this issue.
    
    Fixes: f69f452243e4e1 ("ASoC: rsnd: add TDM Split mode support")
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 56469ac4bc8c..ad6298330fdb 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1031,6 +1031,49 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.prepare	= rsnd_soc_dai_prepare,
 };
 
+static void rsnd_parse_connect_simple(struct rsnd_priv *priv,
+				      struct device_node *dai_np,
+				      int dai_i, int is_play)
+{
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_dai *rdai = rsnd_rdai_get(priv, dai_i);
+	struct rsnd_dai_stream *io = is_play ?
+		&rdai->playback :
+		&rdai->capture;
+	struct device_node *ssiu_np = rsnd_ssiu_of_node(priv);
+	struct device_node *np;
+	int i, j;
+
+	if (!ssiu_np)
+		return;
+
+	if (!rsnd_io_to_mod_ssi(io))
+		return;
+
+	/*
+	 * This driver assumes that it is TDM Split mode
+	 * if it includes ssiu node
+	 */
+	for (i = 0;; i++) {
+		struct device_node *node = is_play ?
+			of_parse_phandle(dai_np, "playback", i) :
+			of_parse_phandle(dai_np, "capture",  i);
+
+		if (!node)
+			break;
+
+		j = 0;
+		for_each_child_of_node(ssiu_np, np) {
+			if (np == node) {
+				rsnd_flags_set(io, RSND_STREAM_TDM_SPLIT);
+				dev_dbg(dev, "%s is part of TDM Split\n", io->name);
+			}
+			j++;
+		}
+
+	}
+}
+
 static void rsnd_parse_connect_graph(struct rsnd_priv *priv,
 				     struct rsnd_dai_stream *io,
 				     struct device_node *endpoint)
@@ -1246,8 +1289,14 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 			dai_i++;
 		}
 	} else {
-		for_each_child_of_node(dai_node, dai_np)
-			__rsnd_dai_probe(priv, dai_np, dai_i++);
+		for_each_child_of_node(dai_node, dai_np) {
+			__rsnd_dai_probe(priv, dai_np, dai_i);
+			if (rsnd_is_gen3(priv)) {
+				rsnd_parse_connect_simple(priv, dai_np, dai_i, 1);
+				rsnd_parse_connect_simple(priv, dai_np, dai_i, 0);
+			}
+			dai_i++;
+		}
 	}
 
 	return 0;

commit 9c698e8481a15237a5b1db5f8391dd66d59e42a4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 27 07:35:34 2018 +0000

    ASoC: rsnd: tidyup registering method for rsnd_kctrl_new()
    
    Current rsnd dvc.c is using flags to avoid duplicating register for
    MIXer case. OTOH, commit e894efef9ac7 ("ASoC: core: add support to card
    rebind") allows to rebind sound card without rebinding all drivers.
    
    Because of above patch and dvc.c flags, it can't re-register kctrl if
    only sound card was rebinded, because dvc is keeping old flags.
    (Of course it will be no problem if rsnd driver also be rebinded,
    but it is not purpose of above patch).
    
    This patch checks current card registered kctrl when registering.
    In MIXer case, it can avoid duplicate register if card already has same
    kctrl. In rebind case, it can re-register kctrl because card registered
    kctl had been removed when unbinding.
    
    This patch is updated version of commit b918f1bc7f1ce ("ASoC: rsnd: DVC
    kctrl sets once")
    
    Reported-by: Nguyen Viet Dung <dung.nguyen.aj@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Nguyen Viet Dung <dung.nguyen.aj@renesas.com>
    Cc: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f930f51b686f..114f8f233764 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1339,6 +1339,18 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
 	};
 	int ret;
 
+	/*
+	 * 1) Avoid duplicate register (ex. MIXer case)
+	 * 2) re-register if card was rebinded
+	 */
+	list_for_each_entry(kctrl, &card->controls, list) {
+		struct rsnd_kctrl_cfg *c = kctrl->private_data;
+
+		if (strcmp(kctrl->id.name, name) == 0 &&
+		    c->mod == mod)
+			return 0;
+	}
+
 	if (size > RSND_MAX_CHANNELS)
 		return -EINVAL;
 

commit 0246c661b6f0051ef7bfbfff01d8ef7fd0359372
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Nov 9 04:15:46 2018 +0000

    ASoC: rsnd: use ring buffer for rsnd_mod_name()
    
    commit c0ea089dbad4 ("ASoC: rsnd: rsnd_mod_name() handles both name and
    ID") merged "name" and "ID" on rsnd_mod_name() to handle sub-ID
    (= for CTU/BUSIF).
    Then, it decided to share static char to avoid pointless memory.
    But, it doesn't work correctry in below case, because last called
    name will be used.
    
            dev_xxx(dev, "%s is connected to %s\n",
                    rsnd_mod_name(mod_a),  /* ssiu[00] */
                    rsnd_mod_name(mod_b)); /* ssi[0]   */
            ->
            rcar_sound ec500000.sound: ssi[0] is connected to ssi[0]
                                       ~~~~~~                 ~~~~~~
    We still don't want to have pointless memory, so let's use ring buffer.
    16byte x 5 is very enough for this purpose.
    
            dev_xxx(dev, "%s is connected to %s\n",
                    rsnd_mod_name(mod_a),  /* ssiu[00] */
                    rsnd_mod_name(mod_b)); /* ssi[0]   */
            ->
            rcar_sound ec500000.sound: ssiu[00] is connected to ssi[0]
                                       ~~~~~~~~                 ~~~~~~
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 12f559e0463f..56469ac4bc8c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -137,10 +137,17 @@ struct dma_chan *rsnd_mod_dma_req(struct rsnd_dai_stream *io,
 	return mod->ops->dma_req(io, mod);
 }
 
+#define MOD_NAME_NUM   5
 #define MOD_NAME_SIZE 16
 char *rsnd_mod_name(struct rsnd_mod *mod)
 {
-	static char name[MOD_NAME_SIZE];
+	static char names[MOD_NAME_NUM][MOD_NAME_SIZE];
+	static int num;
+	char *name = names[num];
+
+	num++;
+	if (num >= MOD_NAME_NUM)
+		num = 0;
 
 	/*
 	 * Let's use same char to avoid pointlessness memory

commit f69f452243e4e16d7a3d0a14e14126b10933d545
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 6 05:21:46 2018 +0000

    ASoC: rsnd: add TDM Split mode support
    
    This patch adds TDM Split mode support. rsnd driver is assuming
    audio-graph-scu-card is used for Sound Card.
    
    This is very simple sample DT settings to use it.
    
            sound_card: sound {
                    compatible = "audio-graph-scu-card";
                    ...
                    convert-channels = <8>; /* TDM Split */
    
                    dais = <&rsnd_port0     /* playback ch1/ch2 */
                            &rsnd_port1     /* playback ch3/ch4 */
                            &rsnd_port2     /* playback ch5/ch6 */
                            &rsnd_port3     /* playback ch7/ch8 */
                            >;
            };
    
            audio-codec {
                    ...
                    port {
                            codec_0: endpoint@1 {
                                    remote-endpoint = <&rsnd_ep0>;
                            };
                            codec_1: endpoint@2 {
                                    remote-endpoint = <&rsnd_ep1>;
                            };
                            codec_2: endpoint@3 {
                                    remote-endpoint = <&rsnd_ep2>;
                            };
                            codec_3: endpoint@4 {
                                    remote-endpoint = <&rsnd_ep3>;
                            };
                    };
            };
    
            &rcar_sound {
                    ...
                    ports {
                            rsnd_port0: port@0 {
                                    rsnd_ep0: endpoint {
                                            remote-endpoint = <&codec_0>;
                                            ...
                                            playback = <&ssiu30 &ssi3>;
                                    };
                            };
                            rsnd_port1: port@1 {
                                    rsnd_ep1: endpoint {
                                            remote-endpoint = <&codec_1>;
                                            ...
                                            playback = <&ssiu31 &ssi3>;
                                    };
                            };
                            rsnd_port2: port@2 {
                                    rsnd_ep2: endpoint {
                                            remote-endpoint = <&codec_2>;
                                            ...
                                            playback = <&ssiu32 &ssi3>;
                                    };
                            };
                            rsnd_port3: port@3 {
                                    rsnd_ep3: endpoint {
                                            remote-endpoint = <&codec_3>;
                                            ...
                                            playback = <&ssiu33 &ssi3>;
                                    };
                            };
                    };
            };
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ff621615a924..12f559e0463f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -271,6 +271,19 @@ int rsnd_runtime_channel_after_ctu_with_params(struct rsnd_dai_stream *io,
 	if (ctu_mod) {
 		u32 converted_chan = rsnd_io_converted_chan(io);
 
+		/*
+		 * !! Note !!
+		 *
+		 * converted_chan will be used for CTU,
+		 * or TDM Split mode.
+		 * User shouldn't use CTU with TDM Split mode.
+		 */
+		if (rsnd_runtime_is_tdm_split(io)) {
+			struct device *dev = rsnd_priv_to_dev(rsnd_io_to_priv(io));
+
+			dev_err(dev, "CTU and TDM Split should be used\n");
+		}
+
 		if (converted_chan)
 			return converted_chan;
 	}
@@ -313,6 +326,11 @@ int rsnd_runtime_is_tdm(struct rsnd_dai_stream *io)
 	return rsnd_runtime_channel_for_ssi(io) >= 6;
 }
 
+int rsnd_runtime_is_tdm_split(struct rsnd_dai_stream *io)
+{
+	return !!rsnd_flags_has(io, RSND_STREAM_TDM_SPLIT);
+}
+
 /*
  *	ADINR function
  */
@@ -790,6 +808,7 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 
 	switch (slots) {
 	case 2:
+		/* TDM Split Mode */
 	case 6:
 	case 8:
 		/* TDM Extend Mode */
@@ -1010,6 +1029,7 @@ static void rsnd_parse_connect_graph(struct rsnd_priv *priv,
 				     struct device_node *endpoint)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
+	struct device_node *remote_port = of_graph_get_remote_port(endpoint);
 	struct device_node *remote_node = of_graph_get_remote_port_parent(endpoint);
 
 	if (!rsnd_io_to_mod_ssi(io))
@@ -1026,6 +1046,15 @@ static void rsnd_parse_connect_graph(struct rsnd_priv *priv,
 		rsnd_flags_set(io, RSND_STREAM_HDMI1);
 		dev_dbg(dev, "%s connected to HDMI1\n", io->name);
 	}
+
+	/*
+	 * This driver assumes that it is TDM Split mode
+	 * if remote node has multi endpoint
+	 */
+	if (of_get_child_count(remote_port) > 1) {
+		rsnd_flags_set(io, RSND_STREAM_TDM_SPLIT);
+		dev_dbg(dev, "%s is part of TDM Split\n", io->name);
+	}
 }
 
 void rsnd_parse_connect_common(struct rsnd_dai *rdai,

commit 4e7788fb8018afbb2e34e9d59b59baea30f5b045
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 6 05:21:08 2018 +0000

    ASoC: rsnd: add SSIU BUSIF support
    
    Gen2 has BUSIF0-3, Gen3 has BUSIF0-7 on some SSIU.
    Current driver is assuming it is using BUSIF0 as default.
    Thus, SSI is attaching SSIU (with BUSIF0) by using rsnd_ssiu_attach().
    But, TDM split mode also needs other BUSIF to use it.
    This patch adds missing SSIU BUSIFx support.
    
    BUSIF is handled by SSIU instead of SSI anymore.
    Thus, its settings no longer needed on SSI node on DT.
    This patch removes its settings from Document, but driver is still
    keeping compatibility. Thus, old DT style is still working.
    But, to avoid confusing, it doesn't indicate old compatibility things on
    Document. New SoC should have SSIU on DT from this patch.
    
    1) old style DT is still supported (= no rcar_sound,ssiu node on DT)
    2) If ssiu is not indicated on playback/capture,
       BUSIF0 will be used as default
            playback = <&ssi3>; /* ssiu30 will be selected */
    3) you can select own ssiu
            playback = <&ssi32 &ssi3>; /* ssiu32 will be selected */
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index fcc5c2e9d191..ff621615a924 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1144,6 +1144,7 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 			break;
 
 		rsnd_parse_connect_ssi(rdai, playback, capture);
+		rsnd_parse_connect_ssiu(rdai, playback, capture);
 		rsnd_parse_connect_src(rdai, playback, capture);
 		rsnd_parse_connect_ctu(rdai, playback, capture);
 		rsnd_parse_connect_mix(rdai, playback, capture);

commit c2aaaa57d44a195b71fe1e9ff0c6a80ac017495d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 6 05:20:10 2018 +0000

    ASoC: rsnd: handle DPCM converted rate/chan under core
    
    converted rate/chan are handled each rated module, but
    it will be used other module too.
    For examle, converted channel is currently used for CTU,
    but, it will be used for TDM Split mode, too.
    
    This patch move/merge SRC/CTU hw_param under core.c
    and handles converted rate/chan under rsnd_dai_stream.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1758fecaed4c..fcc5c2e9d191 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -269,7 +269,7 @@ int rsnd_runtime_channel_after_ctu_with_params(struct rsnd_dai_stream *io,
 	struct rsnd_mod *ctu_mod = rsnd_io_to_mod_ctu(io);
 
 	if (ctu_mod) {
-		u32 converted_chan = rsnd_ctu_converted_channel(ctu_mod);
+		u32 converted_chan = rsnd_io_converted_chan(io);
 
 		if (converted_chan)
 			return converted_chan;
@@ -1225,8 +1225,40 @@ static int rsnd_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+	struct snd_soc_pcm_runtime *fe = substream->private_data;
 	int ret;
 
+	/*
+	 * rsnd assumes that it might be used under DPCM if user want to use
+	 * channel / rate convert. Then, rsnd should be FE.
+	 * And then, this function will be called *after* BE settings.
+	 * this means, each BE already has fixuped hw_params.
+	 * see
+	 *	dpcm_fe_dai_hw_params()
+	 *	dpcm_be_dai_hw_params()
+	 */
+	io->converted_rate = 0;
+	io->converted_chan = 0;
+	if (fe->dai_link->dynamic) {
+		struct rsnd_priv *priv = rsnd_io_to_priv(io);
+		struct device *dev = rsnd_priv_to_dev(priv);
+		struct snd_soc_dpcm *dpcm;
+		struct snd_pcm_hw_params *be_params;
+		int stream = substream->stream;
+
+		for_each_dpcm_be(fe, stream, dpcm) {
+			be_params = &dpcm->hw_params;
+			if (params_channels(hw_params) != params_channels(be_params))
+				io->converted_chan = params_channels(be_params);
+			if (params_rate(hw_params) != params_rate(be_params))
+				io->converted_rate = params_rate(be_params);
+		}
+		if (io->converted_chan)
+			dev_dbg(dev, "convert channels = %d\n", io->converted_chan);
+		if (io->converted_rate)
+			dev_dbg(dev, "convert rate     = %d\n", io->converted_rate);
+	}
+
 	ret = rsnd_dai_call(hw_params, io, substream, hw_params);
 	if (ret)
 		return ret;

commit beed78aeeb10214798b1fd5f1dd05e0b7199d65f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 6 05:19:48 2018 +0000

    ASoC: rsnd: move HDMI information from ssi.c to core.c
    
    Current driver is supporting HDMI output, and its information
    are handled under ssi.c. But, it is stream information.
    Let's move it from ssi.c to core.c.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index cb592191bc86..1758fecaed4c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1005,6 +1005,29 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.prepare	= rsnd_soc_dai_prepare,
 };
 
+static void rsnd_parse_connect_graph(struct rsnd_priv *priv,
+				     struct rsnd_dai_stream *io,
+				     struct device_node *endpoint)
+{
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct device_node *remote_node = of_graph_get_remote_port_parent(endpoint);
+
+	if (!rsnd_io_to_mod_ssi(io))
+		return;
+
+	/* HDMI0 */
+	if (strstr(remote_node->full_name, "hdmi@fead0000")) {
+		rsnd_flags_set(io, RSND_STREAM_HDMI0);
+		dev_dbg(dev, "%s connected to HDMI0\n", io->name);
+	}
+
+	/* HDMI1 */
+	if (strstr(remote_node->full_name, "hdmi@feae0000")) {
+		rsnd_flags_set(io, RSND_STREAM_HDMI1);
+		dev_dbg(dev, "%s connected to HDMI1\n", io->name);
+	}
+}
+
 void rsnd_parse_connect_common(struct rsnd_dai *rdai,
 		struct rsnd_mod* (*mod_get)(struct rsnd_priv *priv, int id),
 		struct device_node *node,
@@ -1177,7 +1200,12 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 	if (is_graph) {
 		for_each_endpoint_of_node(dai_node, dai_np) {
 			__rsnd_dai_probe(priv, dai_np, dai_i);
-			rsnd_ssi_parse_hdmi_connection(priv, dai_np, dai_i);
+			if (rsnd_is_gen3(priv)) {
+				struct rsnd_dai *rdai = rsnd_rdai_get(priv, dai_i);
+
+				rsnd_parse_connect_graph(priv, &rdai->playback, dai_np);
+				rsnd_parse_connect_graph(priv, &rdai->capture,  dai_np);
+			}
 			dai_i++;
 		}
 	} else {

commit 9328882e9dc6b3ae6d11eaf6dbdeb45dfbb2d38f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 6 05:19:33 2018 +0000

    ASoC: rsnd: use defined io_playback/io_capture
    
    rdai->playback/rdai->capture are defined as io_playback/io_capture
    on __rsnd_dai_probe(). Let's use it instead of original one.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index cbe846e4438f..cb592191bc86 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1091,24 +1091,24 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 	drv->name	= rdai->name;
 	drv->ops	= &rsnd_soc_dai_ops;
 
-	snprintf(rdai->playback.name, RSND_DAI_NAME_SIZE,
+	snprintf(io_playback->name, RSND_DAI_NAME_SIZE,
 		 "DAI%d Playback", dai_i);
 	drv->playback.rates		= RSND_RATES;
 	drv->playback.formats		= RSND_FMTS;
 	drv->playback.channels_min	= 2;
 	drv->playback.channels_max	= 8;
-	drv->playback.stream_name	= rdai->playback.name;
+	drv->playback.stream_name	= io_playback->name;
 
-	snprintf(rdai->capture.name, RSND_DAI_NAME_SIZE,
+	snprintf(io_capture->name, RSND_DAI_NAME_SIZE,
 		 "DAI%d Capture", dai_i);
 	drv->capture.rates		= RSND_RATES;
 	drv->capture.formats		= RSND_FMTS;
 	drv->capture.channels_min	= 2;
 	drv->capture.channels_max	= 8;
-	drv->capture.stream_name	= rdai->capture.name;
+	drv->capture.stream_name	= io_capture->name;
 
-	rdai->playback.rdai		= rdai;
-	rdai->capture.rdai		= rdai;
+	io_playback->rdai		= rdai;
+	io_capture->rdai		= rdai;
 	rsnd_rdai_channels_set(rdai, 2); /* default 2ch */
 	rsnd_rdai_ssi_lane_set(rdai, 1); /* default 1lane */
 	rsnd_rdai_width_set(rdai, 32);   /* default 32bit width */

commit a607280293b4b804fa080c75412b256ec37ce04c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 6 05:19:19 2018 +0000

    ASoC: rsnd: rename rsnd_runtime_is_ssi_xxx()
    
    Current rsnd driver has rsnd_runtime_is_ssi_xxx() functions,
    but it is not only related to SSI, thus, it is misunderstandable.
    This patch renames it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 5e100122391a..cbe846e4438f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -287,7 +287,7 @@ int rsnd_runtime_channel_for_ssi_with_params(struct rsnd_dai_stream *io,
 		rsnd_runtime_channel_original_with_params(io, params);
 
 	/* Use Multi SSI */
-	if (rsnd_runtime_is_ssi_multi(io))
+	if (rsnd_runtime_is_multi_ssi(io))
 		chan /= rsnd_rdai_ssi_lane_get(rdai);
 
 	/* TDM Extend Mode needs 8ch */
@@ -297,7 +297,7 @@ int rsnd_runtime_channel_for_ssi_with_params(struct rsnd_dai_stream *io,
 	return chan;
 }
 
-int rsnd_runtime_is_ssi_multi(struct rsnd_dai_stream *io)
+int rsnd_runtime_is_multi_ssi(struct rsnd_dai_stream *io)
 {
 	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
 	int lane = rsnd_rdai_ssi_lane_get(rdai);
@@ -308,7 +308,7 @@ int rsnd_runtime_is_ssi_multi(struct rsnd_dai_stream *io)
 	return (chan > 2) && (lane > 1);
 }
 
-int rsnd_runtime_is_ssi_tdm(struct rsnd_dai_stream *io)
+int rsnd_runtime_is_tdm(struct rsnd_dai_stream *io)
 {
 	return rsnd_runtime_channel_for_ssi(io) >= 6;
 }

commit c0ea089dbad47a41ae30ad290766d7a6571c9802
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 30 07:47:50 2018 +0000

    ASoC: rsnd: rsnd_mod_name() handles both name and ID
    
    Current rsnd driver is using "%s[%d]" for mod name and ID,
    but, this ID portion might confusable.
    For example currently, CTU ID is 0 to 7, but using 00 to 13
    (= 00, 01, 02, 03, 10, 11, 12, 13) is very best matching to datasheet.
    
    In the future, we will support BUSIFn, but it will be more complicated
    numbering. To avoid future confusable code, this patch modify
    rsnd_mod_name() to return understandable name.
    
    To avoid using pointless memory, it uses static char and snprintf,
    thus, rsnd_mod_name() user should use it immediately, and shouldn't keep
    its pointer.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 82d2234840c5..5e100122391a 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -123,8 +123,8 @@ void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
 		struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 		struct device *dev = rsnd_priv_to_dev(priv);
 
-		dev_warn(dev, "%s[%d] is not your expected module\n",
-			 rsnd_mod_name(mod), rsnd_mod_id(mod));
+		dev_warn(dev, "%s is not your expected module\n",
+			 rsnd_mod_name(mod));
 	}
 }
 
@@ -137,6 +137,30 @@ struct dma_chan *rsnd_mod_dma_req(struct rsnd_dai_stream *io,
 	return mod->ops->dma_req(io, mod);
 }
 
+#define MOD_NAME_SIZE 16
+char *rsnd_mod_name(struct rsnd_mod *mod)
+{
+	static char name[MOD_NAME_SIZE];
+
+	/*
+	 * Let's use same char to avoid pointlessness memory
+	 * Thus, rsnd_mod_name() should be used immediately
+	 * Don't keep pointer
+	 */
+	if ((mod)->ops->id_sub) {
+		snprintf(name, MOD_NAME_SIZE, "%s[%d%d]",
+			 mod->ops->name,
+			 rsnd_mod_id(mod),
+			 rsnd_mod_id_sub(mod));
+	} else {
+		snprintf(name, MOD_NAME_SIZE, "%s[%d]",
+			 mod->ops->name,
+			 rsnd_mod_id(mod));
+	}
+
+	return name;
+}
+
 u32 *rsnd_mod_get_status(struct rsnd_mod *mod,
 			 struct rsnd_dai_stream *io,
 			 enum rsnd_mod_type type)
@@ -494,15 +518,14 @@ static int rsnd_status_update(u32 *status,
 						__rsnd_mod_shift_##fn,	\
 						__rsnd_mod_add_##fn,	\
 						__rsnd_mod_call_##fn);	\
-		rsnd_dbg_dai_call(dev, "%s[%d]\t0x%08x %s\n",		\
-			rsnd_mod_name(mod), rsnd_mod_id(mod), *status,	\
+		rsnd_dbg_dai_call(dev, "%s\t0x%08x %s\n",		\
+			rsnd_mod_name(mod), *status,	\
 			(func_call && (mod)->ops->fn) ? #fn : "");	\
 		if (func_call && (mod)->ops->fn)			\
 			tmp = (mod)->ops->fn(mod, io, param);		\
 		if (tmp && (tmp != -EPROBE_DEFER))			\
-			dev_err(dev, "%s[%d] : %s error %d\n",		\
-				rsnd_mod_name(mod), rsnd_mod_id(mod),	\
-						     #fn, tmp);		\
+			dev_err(dev, "%s : %s error %d\n",		\
+				rsnd_mod_name(mod), #fn, tmp);		\
 		ret |= tmp;						\
 	}								\
 	ret;								\
@@ -529,8 +552,8 @@ int rsnd_dai_connect(struct rsnd_mod *mod,
 
 	io->mod[type] = mod;
 
-	dev_dbg(dev, "%s[%d] is connected to io (%s)\n",
-		rsnd_mod_name(mod), rsnd_mod_id(mod),
+	dev_dbg(dev, "%s is connected to io (%s)\n",
+		rsnd_mod_name(mod),
 		rsnd_io_is_play(io) ? "Playback" : "Capture");
 
 	return 0;

commit c16015f36cc128244c910152663de45c3b99f551
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 30 07:47:18 2018 +0000

    ASoC: rsnd: add .get_id/.get_id_sub
    
    ID for CTU and SSIU are confusable.
    1 CTU has 4 sub nodes. This means, CTU0 has CTU01 - CTU03, CTU1 has
    CTU10 - CTU13. SSIU is more confusable. Gen2 SSIU has BUSIF0-3, Gen3
    SSIU has BUSIF0-7, but not for all SSIU.
    In rsnd driver, each mod drivers are assuming rsnd_mod_id() returns
    main device ID (In CTU case CTU0-1, SSIU case SSIU0-9), not serial
    number.
    This patch adds new .id/.id_sub to handling more detail ID.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 5373eba5d572..82d2234840c5 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -144,6 +144,27 @@ u32 *rsnd_mod_get_status(struct rsnd_mod *mod,
 	return &mod->status;
 }
 
+int rsnd_mod_id_raw(struct rsnd_mod *mod)
+{
+	return mod->id;
+}
+
+int rsnd_mod_id(struct rsnd_mod *mod)
+{
+	if ((mod)->ops->id)
+		return (mod)->ops->id(mod);
+
+	return rsnd_mod_id_raw(mod);
+}
+
+int rsnd_mod_id_sub(struct rsnd_mod *mod)
+{
+	if ((mod)->ops->id_sub)
+		return (mod)->ops->id_sub(mod);
+
+	return 0;
+}
+
 int rsnd_mod_init(struct rsnd_priv *priv,
 		  struct rsnd_mod *mod,
 		  struct rsnd_mod_ops *ops,

commit 7e7fe06de376e9874f4399dac81d65ea9b0a9507
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 30 07:46:05 2018 +0000

    ASoC: rsnd: move .get_status under rsnd_mod_ops
    
    Each mod needs to have .get_status, but current driver is handling it
    under rsnd_mod, instead of rsnd_mod_ops.
    It is not any make sence. This patch moves it to rsnd_mod_ops, and
    tidyup its parameter order to align to other callback functions.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f930f51b686f..5373eba5d572 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -137,8 +137,8 @@ struct dma_chan *rsnd_mod_dma_req(struct rsnd_dai_stream *io,
 	return mod->ops->dma_req(io, mod);
 }
 
-u32 *rsnd_mod_get_status(struct rsnd_dai_stream *io,
-			 struct rsnd_mod *mod,
+u32 *rsnd_mod_get_status(struct rsnd_mod *mod,
+			 struct rsnd_dai_stream *io,
 			 enum rsnd_mod_type type)
 {
 	return &mod->status;
@@ -148,9 +148,6 @@ int rsnd_mod_init(struct rsnd_priv *priv,
 		  struct rsnd_mod *mod,
 		  struct rsnd_mod_ops *ops,
 		  struct clk *clk,
-		  u32* (*get_status)(struct rsnd_dai_stream *io,
-				     struct rsnd_mod *mod,
-				     enum rsnd_mod_type type),
 		  enum rsnd_mod_type type,
 		  int id)
 {
@@ -164,7 +161,6 @@ int rsnd_mod_init(struct rsnd_priv *priv,
 	mod->type	= type;
 	mod->clk	= clk;
 	mod->priv	= priv;
-	mod->get_status	= get_status;
 
 	return ret;
 }
@@ -472,7 +468,7 @@ static int rsnd_status_update(u32 *status,
 	enum rsnd_mod_type *types = rsnd_mod_sequence[is_play];		\
 	for_each_rsnd_mod_arrays(i, mod, io, types, RSND_MOD_MAX) {	\
 		int tmp = 0;						\
-		u32 *status = mod->get_status(io, mod, types[i]);	\
+		u32 *status = mod->ops->get_status(mod, io, types[i]);	\
 		int func_call = rsnd_status_update(status,		\
 						__rsnd_mod_shift_##fn,	\
 						__rsnd_mod_add_##fn,	\

commit 82ab7e9a4d3fcec27f745be04063e17da1881dda
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 10 02:20:42 2018 +0000

    ASoC: rsnd: use 32bit TDM width as default
    
    commit fb2815f44a9e ("ASoC: rsnd: add support for 16/24 bit slot widths")
    added TDM width check, and return error if it was not 16/24/32 bit.
    But it is too strict. This patch uses 32bit same as default.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 40d7dc4f7839..f930f51b686f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -744,8 +744,8 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 	case 32:
 		break;
 	default:
-		dev_err(dev, "unsupported slot width value: %d\n", slot_width);
-		return -EINVAL;
+		/* use default */
+		slot_width = 32;
 	}
 
 	switch (slots) {

commit 54a3da1c105ca91c4d32f25c3d9c57a61e9a3467
Merge: 1c8bc7b3de5e 90a3b7f8aba3
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Sep 10 18:55:12 2018 +0100

    Merge branch 'asoc-4.19' into asoc-4.20 Cirrus conflict

commit 6c92d5a2744e27619a8fcc9d74b91ee9f1cdebd1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 6 03:21:47 2018 +0000

    ASoC: rsnd: don't fallback to PIO mode when -EPROBE_DEFER
    
    Current rsnd driver will fallback to PIO mode if it can't get DMA
    handler. But, DMA might return -EPROBE_DEFER when probe timing.
    This driver always fallback to PIO mode especially from
    commit ac6bbf0cdf4206c ("iommu: Remove IOMMU_OF_DECLARE") because
    of this reason.
    
    The DMA driver will be probed later, but sound driver might be
    probed as PIO mode in such case. This patch fixup this issue.
    Then, -EPROBE_DEFER is not error. Thus, let's don't indicate error
    message in such case.
    And it needs to call rsnd_adg_remove() individually if probe failed,
    because it registers clk which should be unregister.
    
    Maybe PIO fallback feature itself is not needed,
    but let's keep it so far.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b35f5509cfe2..d23c2bbff0cf 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -478,7 +478,7 @@ static int rsnd_status_update(u32 *status,
 			(func_call && (mod)->ops->fn) ? #fn : "");	\
 		if (func_call && (mod)->ops->fn)			\
 			tmp = (mod)->ops->fn(mod, io, param);		\
-		if (tmp)						\
+		if (tmp && (tmp != -EPROBE_DEFER))			\
 			dev_err(dev, "%s[%d] : %s error %d\n",		\
 				rsnd_mod_name(mod), rsnd_mod_id(mod),	\
 						     #fn, tmp);		\
@@ -1561,6 +1561,14 @@ static int rsnd_probe(struct platform_device *pdev)
 		rsnd_dai_call(remove, &rdai->capture, priv);
 	}
 
+	/*
+	 * adg is very special mod which can't use rsnd_dai_call(remove),
+	 * and it registers ADG clock on probe.
+	 * It should be unregister if probe failed.
+	 * Mainly it is assuming -EPROBE_DEFER case
+	 */
+	rsnd_adg_remove(priv);
+
 	return ret;
 }
 

commit 6ab6a2474e0dce02f71e92adb9778a168a8931f4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Sep 3 07:09:17 2018 +0000

    ASoC: rsnd: merge .nolock_start and .prepare
    
    Main purpose of .nolock_start is we need to call
    some function without spinlock.
    OTOH we have .prepare which main purpose is
    called under atomic context.
    Then, it is called without spinlock.
    
    In summary, our main callback init/quit, and start/stop
    are called under "atomic context and with spinlock".
    And some function need to be called under
    "non-atomic context or without spinlock".
    Let's merge .nolock_start and prepare to be more clear code.
    Then, let's rename nolock_stop to cleanup
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 299fb457573d..e46415c807a0 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -881,12 +881,10 @@ static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
 	struct snd_pcm_hw_constraint_list *constraint = &rdai->constraint;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int max_channels = rsnd_rdai_channels_get(rdai);
-	int ret;
 	int i;
 
 	rsnd_dai_stream_init(io, substream);
@@ -930,14 +928,7 @@ static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
 				    SNDRV_PCM_HW_PARAM_RATE, -1);
 	}
 
-	/*
-	 * call rsnd_dai_call without spinlock
-	 */
-	ret = rsnd_dai_call(nolock_start, io, priv);
-	if (ret < 0)
-		rsnd_dai_call(nolock_stop, io, priv);
-
-	return ret;
+	return 0;
 }
 
 static void rsnd_soc_dai_shutdown(struct snd_pcm_substream *substream,
@@ -950,7 +941,7 @@ static void rsnd_soc_dai_shutdown(struct snd_pcm_substream *substream,
 	/*
 	 * call rsnd_dai_call without spinlock
 	 */
-	rsnd_dai_call(nolock_stop, io, priv);
+	rsnd_dai_call(cleanup, io, priv);
 
 	rsnd_dai_stream_quit(io);
 }

commit d47f9580a6ea82b80c34c9dbc9dd8dba6bb25dc0
Merge: 2e66d523cd05 4d230d127106
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Sep 3 14:37:28 2018 +0100

    Merge branch 'asoc-4.19' into asoc-4.20 for rcar dep

commit b735662fa473c0e3618a4d645ce797d31e0c9192
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Mon Sep 3 07:06:50 2018 +0000

    ASoC: rsnd: remove is_play parameter from hw_rule function
    
    Currently rsnd_dai_stream *io is set to either &rdai->playback or
    &rdai->capture based on whether it is a playback or capture stream,
    in __rsnd_soc_hw_rule_* functions, but this is not necessary,
    rsnd_dai_stream *io handler can be get from rule->private.
    
    This patch removes 'is_play' parameter from hw_rule function.
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    [Kuninori: tidyup for upstream]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index cd0ff1eef463..c66b3dade947 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -819,16 +819,14 @@ static int rsnd_soc_hw_rule(struct rsnd_dai *rdai,
 	return snd_interval_refine(iv, &p);
 }
 
-static int __rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,
-				   struct snd_pcm_hw_rule *rule,
-				   int is_play)
+static int rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,
+				 struct snd_pcm_hw_rule *rule)
 {
 	struct snd_interval *ic_ = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
 	struct snd_interval *ir = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 	struct snd_interval ic;
-	struct snd_soc_dai *dai = rule->private;
-	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	struct rsnd_dai_stream *io = is_play ? &rdai->playback : &rdai->capture;
+	struct rsnd_dai_stream *io = rule->private;
+	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
 
 	/*
 	 * possible sampling rate limitation is same as
@@ -844,28 +842,14 @@ static int __rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,
 				&ic, ir);
 }
 
-static int rsnd_soc_hw_rule_rate_playback(struct snd_pcm_hw_params *params,
-				 struct snd_pcm_hw_rule *rule)
-{
-	return __rsnd_soc_hw_rule_rate(params, rule, 1);
-}
-
-static int rsnd_soc_hw_rule_rate_capture(struct snd_pcm_hw_params *params,
-					  struct snd_pcm_hw_rule *rule)
-{
-	return __rsnd_soc_hw_rule_rate(params, rule, 0);
-}
-
-static int __rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
-				       struct snd_pcm_hw_rule *rule,
-				       int is_play)
+static int rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
+				     struct snd_pcm_hw_rule *rule)
 {
 	struct snd_interval *ic_ = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
 	struct snd_interval *ir = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 	struct snd_interval ic;
-	struct snd_soc_dai *dai = rule->private;
-	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	struct rsnd_dai_stream *io = is_play ? &rdai->playback : &rdai->capture;
+	struct rsnd_dai_stream *io = rule->private;
+	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
 
 	/*
 	 * possible sampling rate limitation is same as
@@ -881,18 +865,6 @@ static int __rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
 				ir, &ic);
 }
 
-static int rsnd_soc_hw_rule_channels_playback(struct snd_pcm_hw_params *params,
-					      struct snd_pcm_hw_rule *rule)
-{
-	return __rsnd_soc_hw_rule_channels(params, rule, 1);
-}
-
-static int rsnd_soc_hw_rule_channels_capture(struct snd_pcm_hw_params *params,
-					     struct snd_pcm_hw_rule *rule)
-{
-	return __rsnd_soc_hw_rule_channels(params, rule, 0);
-}
-
 static const struct snd_pcm_hardware rsnd_pcm_hardware = {
 	.info =		SNDRV_PCM_INFO_INTERLEAVED	|
 			SNDRV_PCM_INFO_MMAP		|
@@ -949,14 +921,12 @@ static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
 		int is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-				    is_play ? rsnd_soc_hw_rule_rate_playback :
-					      rsnd_soc_hw_rule_rate_capture,
-				    dai,
+				    rsnd_soc_hw_rule_rate,
+				    is_play ? &rdai->playback : &rdai->capture,
 				    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				    is_play ? rsnd_soc_hw_rule_channels_playback :
-					      rsnd_soc_hw_rule_channels_capture,
-				    dai,
+				    rsnd_soc_hw_rule_channels,
+				    is_play ? &rdai->playback : &rdai->capture,
 				    SNDRV_PCM_HW_PARAM_RATE, -1);
 	}
 

commit ba5d553b7bd71e63d639863e2cb09e0c9543b8b7
Author: Dragos Tarcatu <dragos_tarcatu@mentor.com>
Date:   Mon Sep 3 07:06:29 2018 +0000

    ASoC: rsnd: add support for 8 bit S8 format
    
    This patch adds support for SNDRV_PCM_FMTBIT_S8 format.
    
    Signed-off-by: Dragos Tarcatu <dragos_tarcatu@mentor.com>
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    [Kuninori: tidyup for upstream]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8a417768b7ef..cd0ff1eef463 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -102,7 +102,9 @@
 #include "rsnd.h"
 
 #define RSND_RATES SNDRV_PCM_RATE_8000_192000
-#define RSND_FMTS (SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE)
+#define RSND_FMTS (SNDRV_PCM_FMTBIT_S8 |\
+		   SNDRV_PCM_FMTBIT_S16_LE |\
+		   SNDRV_PCM_FMTBIT_S24_LE)
 
 static const struct of_device_id rsnd_of_match[] = {
 	{ .compatible = "renesas,rcar_sound-gen1", .data = (void *)RSND_GEN1 },
@@ -280,6 +282,8 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	struct device *dev = rsnd_priv_to_dev(priv);
 
 	switch (snd_pcm_format_width(runtime->format)) {
+	case 8:
+		return 16 << 16;
 	case 16:
 		return 8 << 16;
 	case 24:
@@ -331,7 +335,7 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 		target = cmd ? cmd : ssiu;
 	}
 
-	/* Non target mod or 24bit data needs normal DALIGN */
+	/* Non target mod or non 16bit needs normal DALIGN */
 	if ((snd_pcm_format_width(runtime->format) != 16) ||
 	    (mod != target))
 		return 0x76543210;
@@ -367,7 +371,7 @@ u32 rsnd_get_busif_shift(struct rsnd_dai_stream *io, struct rsnd_mod *mod)
 	 * HW    24bit data is located as 0x******00
 	 *
 	 */
-	if (snd_pcm_format_width(runtime->format) == 16)
+	if (snd_pcm_format_width(runtime->format) != 24)
 		return 0;
 
 	for (i = 0; i < ARRAY_SIZE(playback_mods); i++) {

commit 3791b3ee4bb13c381868da89e9e6deb11de660ad
Author: Dragos Tarcatu <dragos_tarcatu@mentor.com>
Date:   Mon Sep 3 07:06:01 2018 +0000

    ASoC: rsnd: add support for the DSP_A/DSP_B formats
    
    Signed-off-by: Dragos Tarcatu <dragos_tarcatu@mentor.com>
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    [Kuninori: tidyup for upstream]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ce0a3a61c441..8a417768b7ef 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -689,6 +689,7 @@ static int rsnd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 		rdai->frm_clk_inv = 0;
 		break;
 	case SND_SOC_DAIFMT_LEFT_J:
+	case SND_SOC_DAIFMT_DSP_B:
 		rdai->sys_delay = 1;
 		rdai->data_alignment = 0;
 		rdai->frm_clk_inv = 1;
@@ -698,6 +699,11 @@ static int rsnd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 		rdai->data_alignment = 1;
 		rdai->frm_clk_inv = 1;
 		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		rdai->sys_delay = 0;
+		rdai->data_alignment = 0;
+		rdai->frm_clk_inv = 1;
+		break;
 	}
 
 	/* set clock inversion */

commit fb2815f44a9eb341ed8990263855a266960a5135
Author: Dragos Tarcatu <dragos_tarcatu@mentor.com>
Date:   Mon Sep 3 07:05:42 2018 +0000

    ASoC: rsnd: add support for 16/24 bit slot widths
    
    The slot width (system word length) was fixed at 32 bits.
    This patch allows also setting it to 16 or 24 bits.
    
    Signed-off-by: Dragos Tarcatu <dragos_tarcatu@mentor.com>
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    [Kuninori: tidyup for upstream]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ab7e317bbed8..ce0a3a61c441 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -540,6 +540,14 @@ int rsnd_rdai_ssi_lane_ctrl(struct rsnd_dai *rdai,
 	return rdai->ssi_lane;
 }
 
+int rsnd_rdai_width_ctrl(struct rsnd_dai *rdai, int width)
+{
+	if (width > 0)
+		rdai->chan_width = width;
+
+	return rdai->chan_width;
+}
+
 struct rsnd_dai *rsnd_rdai_get(struct rsnd_priv *priv, int id)
 {
 	if ((id < 0) || (id >= rsnd_rdai_nr(priv)))
@@ -720,6 +728,16 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct device *dev = rsnd_priv_to_dev(priv);
 
+	switch (slot_width) {
+	case 16:
+	case 24:
+	case 32:
+		break;
+	default:
+		dev_err(dev, "unsupported slot width value: %d\n", slot_width);
+		return -EINVAL;
+	}
+
 	switch (slots) {
 	case 2:
 	case 6:
@@ -727,6 +745,7 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 		/* TDM Extend Mode */
 		rsnd_rdai_channels_set(rdai, slots);
 		rsnd_rdai_ssi_lane_set(rdai, 1);
+		rsnd_rdai_width_set(rdai, slot_width);
 		break;
 	default:
 		dev_err(dev, "unsupported TDM slots (%d)\n", slots);
@@ -755,7 +774,7 @@ static unsigned int rsnd_soc_hw_rate_list[] = {
 	192000,
 };
 
-static int rsnd_soc_hw_rule(struct rsnd_priv *priv,
+static int rsnd_soc_hw_rule(struct rsnd_dai *rdai,
 			    unsigned int *list, int list_num,
 			    struct snd_interval *baseline, struct snd_interval *iv)
 {
@@ -772,14 +791,14 @@ static int rsnd_soc_hw_rule(struct rsnd_priv *priv,
 		if (!snd_interval_test(iv, list[i]))
 			continue;
 
-		rate = rsnd_ssi_clk_query(priv,
+		rate = rsnd_ssi_clk_query(rdai,
 					  baseline->min, list[i], NULL);
 		if (rate > 0) {
 			p.min = min(p.min, list[i]);
 			p.max = max(p.max, list[i]);
 		}
 
-		rate = rsnd_ssi_clk_query(priv,
+		rate = rsnd_ssi_clk_query(rdai,
 					  baseline->max, list[i], NULL);
 		if (rate > 0) {
 			p.min = min(p.min, list[i]);
@@ -799,7 +818,6 @@ static int __rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,
 	struct snd_interval ic;
 	struct snd_soc_dai *dai = rule->private;
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
 	struct rsnd_dai_stream *io = is_play ? &rdai->playback : &rdai->capture;
 
 	/*
@@ -811,7 +829,7 @@ static int __rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,
 	ic.min =
 	ic.max = rsnd_runtime_channel_for_ssi_with_params(io, params);
 
-	return rsnd_soc_hw_rule(priv, rsnd_soc_hw_rate_list,
+	return rsnd_soc_hw_rule(rdai, rsnd_soc_hw_rate_list,
 				ARRAY_SIZE(rsnd_soc_hw_rate_list),
 				&ic, ir);
 }
@@ -837,7 +855,6 @@ static int __rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
 	struct snd_interval ic;
 	struct snd_soc_dai *dai = rule->private;
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
 	struct rsnd_dai_stream *io = is_play ? &rdai->playback : &rdai->capture;
 
 	/*
@@ -849,7 +866,7 @@ static int __rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
 	ic.min =
 	ic.max = rsnd_runtime_channel_for_ssi_with_params(io, params);
 
-	return rsnd_soc_hw_rule(priv, rsnd_soc_hw_channels_list,
+	return rsnd_soc_hw_rule(rdai, rsnd_soc_hw_channels_list,
 				ARRAY_SIZE(rsnd_soc_hw_channels_list),
 				ir, &ic);
 }
@@ -1072,6 +1089,7 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 	rdai->capture.rdai		= rdai;
 	rsnd_rdai_channels_set(rdai, 2); /* default 2ch */
 	rsnd_rdai_ssi_lane_set(rdai, 1); /* default 1lane */
+	rsnd_rdai_width_set(rdai, 32);   /* default 32bit width */
 
 	for (io_i = 0;; io_i++) {
 		playback = of_parse_phandle(dai_np, "playback", io_i);

commit b5c088689847372794500f83b65673aaa8ca4d8d
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Mon Sep 3 07:05:11 2018 +0000

    ASoC: rsnd: add warning message to rsnd_kctrl_accept_runtime()
    
    Add warning message to rsnd_kctrl_accept_runtime(), when kctrl
    update is rejected due to corresponding dai-link is idle.
    So that user can notice the reason of kctrl update failure.
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    [kuninori: adjust to upstream]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f8425d8b44d2..ab7e317bbed8 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1263,8 +1263,15 @@ int rsnd_kctrl_accept_anytime(struct rsnd_dai_stream *io)
 int rsnd_kctrl_accept_runtime(struct rsnd_dai_stream *io)
 {
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);
+	struct device *dev = rsnd_priv_to_dev(priv);
+
+	if (!runtime) {
+		dev_warn(dev, "Can't update kctrl when idle\n");
+		return 0;
+	}
 
-	return !!runtime;
+	return 1;
 }
 
 struct rsnd_kctrl_cfg *rsnd_kctrl_init_m(struct rsnd_kctrl_cfg_m *cfg)

commit 4d230d12710646788af581ba0155d83ab48b955c
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Mon Sep 3 07:08:58 2018 +0000

    ASoC: rsnd: fixup not to call clk_get/set under non-atomic
    
    Clocking operations clk_get/set_rate, are non-atomic,
    they shouldn't be called in soc_pcm_trigger() which is atomic.
    
    Following issue was found due to execution of clk_get_rate() causes
    sleep in soc_pcm_trigger(), which shouldn't be blocked.
    
    We can reproduce this issue by following
            > enable CONFIG_DEBUG_ATOMIC_SLEEP=y
            > compile, and boot
            > mount -t debugfs none /sys/kernel/debug
            > while true; do cat /sys/kernel/debug/clk/clk_summary > /dev/null; done &
            > while true; do aplay xxx; done
    
    This patch adds support to .prepare callback, and moves non-atomic
    clocking operations to it. As .prepare is non-atomic, it is always
    called before trigger_start/trigger_stop.
    
            BUG: sleeping function called from invalid context at kernel/locking/mutex.c:620
            in_atomic(): 1, irqs_disabled(): 128, pid: 2242, name: aplay
            INFO: lockdep is turned off.
            irq event stamp: 5964
            hardirqs last enabled at (5963): [<ffff200008e59e40>] mutex_lock_nested+0x6e8/0x6f0
            hardirqs last disabled at (5964): [<ffff200008e623f0>] _raw_spin_lock_irqsave+0x24/0x68
            softirqs last enabled at (5502): [<ffff200008081838>] __do_softirq+0x560/0x10c0
            softirqs last disabled at (5495): [<ffff2000080c2e78>] irq_exit+0x160/0x25c
            Preemption disabled at:[ 62.904063] [<ffff200008be4d48>] snd_pcm_stream_lock+0xb4/0xc0
            CPU: 2 PID: 2242 Comm: aplay Tainted: G B C 4.9.54+ #186
            Hardware name: Renesas Salvator-X board based on r8a7795 (DT)
            Call trace:
            [<ffff20000808fe48>] dump_backtrace+0x0/0x37c
            [<ffff2000080901d8>] show_stack+0x14/0x1c
            [<ffff2000086f4458>] dump_stack+0xfc/0x154
            [<ffff2000081134a0>] ___might_sleep+0x57c/0x58c
            [<ffff2000081136b8>] __might_sleep+0x208/0x21c
            [<ffff200008e5980c>] mutex_lock_nested+0xb4/0x6f0
            [<ffff2000087cac74>] clk_prepare_lock+0xb0/0x184
            [<ffff2000087cb094>] clk_core_get_rate+0x14/0x54
            [<ffff2000087cb0f4>] clk_get_rate+0x20/0x34
            [<ffff20000113aa00>] rsnd_adg_ssi_clk_try_start+0x158/0x4f8 [snd_soc_rcar]
            [<ffff20000113da00>] rsnd_ssi_init+0x668/0x7a0 [snd_soc_rcar]
            [<ffff200001133ff4>] rsnd_soc_dai_trigger+0x4bc/0xcf8 [snd_soc_rcar]
            [<ffff200008c1af24>] soc_pcm_trigger+0x2a4/0x2d4
    
    Fixes: e7d850dd10f4 ("ASoC: rsnd: use mod base common method on SSI-parent")
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    [Kuninori: tidyup for upstream]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f8425d8b44d2..b35f5509cfe2 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -958,12 +958,23 @@ static void rsnd_soc_dai_shutdown(struct snd_pcm_substream *substream,
 	rsnd_dai_stream_quit(io);
 }
 
+static int rsnd_soc_dai_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct rsnd_priv *priv = rsnd_dai_to_priv(dai);
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+
+	return rsnd_dai_call(prepare, io, priv);
+}
+
 static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.startup	= rsnd_soc_dai_startup,
 	.shutdown	= rsnd_soc_dai_shutdown,
 	.trigger	= rsnd_soc_dai_trigger,
 	.set_fmt	= rsnd_soc_dai_set_fmt,
 	.set_tdm_slot	= rsnd_soc_set_dai_tdm_slot,
+	.prepare	= rsnd_soc_dai_prepare,
 };
 
 void rsnd_parse_connect_common(struct rsnd_dai *rdai,

commit 44fedd7da485bafcc5eee8794fa54cfc0c047dd4
Merge: 3bec6fa3cdd3 1b31de922e28
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jun 22 15:47:23 2018 +0100

    Merge branch 'asoc-4.18' into asoc-4.19 for amd dep

commit a0d847c380ba47886fcca4168698eef51c69f109
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jun 12 05:51:46 2018 +0000

    ASoC: rsnd: add rsnd_daidrv_get()
    
    rsnd priv has many parameters. On __rsnd_dai_probe() it uses
    rsnd_rdai_get() to get rdai pointer, but is using priv->daidrv
    directly to get daidrvhv, but it is confusable for reader.
    This patch adds rsnd_daidrv_get() to get daidrv from priv.
    Now reader can understand that rdai and daidrv are related.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index eac22fef4543..6091e0916085 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -548,6 +548,15 @@ struct rsnd_dai *rsnd_rdai_get(struct rsnd_priv *priv, int id)
 	return priv->rdai + id;
 }
 
+static struct snd_soc_dai_driver
+*rsnd_daidrv_get(struct rsnd_priv *priv, int id)
+{
+	if ((id < 0) || (id >= rsnd_rdai_nr(priv)))
+		return NULL;
+
+	return priv->daidrv + id;
+}
+
 #define rsnd_dai_to_priv(dai) snd_soc_dai_get_drvdata(dai)
 static struct rsnd_dai *rsnd_dai_to_rdai(struct snd_soc_dai *dai)
 {
@@ -1033,7 +1042,7 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 	int io_i;
 
 	rdai		= rsnd_rdai_get(priv, dai_i);
-	drv		= priv->daidrv + dai_i;
+	drv		= rsnd_daidrv_get(priv, dai_i);
 	io_playback	= &rdai->playback;
 	io_capture	= &rdai->capture;
 

commit 7cc90a5cadb1733d95d3c2bc147cbcf7843aa585
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jun 12 05:52:00 2018 +0000

    ASoC: rsnd: has .symmetric_rates if SSIs are sharing WS pin
    
    If SSIs are sharing WS pin, it should has .symmetric_rates.
    This patch sets it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index af04d41a4274..6bbdddef426e 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1085,6 +1085,12 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 		of_node_put(capture);
 	}
 
+	if (rsnd_ssi_is_pin_sharing(io_capture) ||
+	    rsnd_ssi_is_pin_sharing(io_playback)) {
+		/* should have symmetric_rates if pin sharing */
+		drv->symmetric_rates = 1;
+	}
+
 	dev_dbg(dev, "%s (%s/%s)\n", rdai->name,
 		rsnd_io_to_mod_ssi(io_playback) ? "play"    : " -- ",
 		rsnd_io_to_mod_ssi(io_capture) ? "capture" : "  --   ");

commit 1e0edd4deadbbacd3b35179c233efa26624ab2af
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jun 12 05:58:38 2018 +0000

    ASoC: rsnd: convert to SPDX identifiers
    
    Tidyup incoherence between MODULE_LICENSE and header license, too
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f237002180c0..eac22fef4543 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1,16 +1,12 @@
-/*
- * Renesas R-Car SRU/SCU/SSIU/SSI support
- *
- * Copyright (C) 2013 Renesas Solutions Corp.
- * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
- *
- * Based on fsi.c
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
+// SPDX-License-Identifier: GPL-2.0
+//
+// Renesas R-Car SRU/SCU/SSIU/SSI support
+//
+// Copyright (C) 2013 Renesas Solutions Corp.
+// Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+//
+// Based on fsi.c
+// Kuninori Morimoto <morimoto.kuninori@renesas.com>
 
 /*
  * Renesas R-Car sound device structure
@@ -1606,7 +1602,7 @@ static struct platform_driver rsnd_driver = {
 };
 module_platform_driver(rsnd_driver);
 
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("Renesas R-Car audio driver");
 MODULE_AUTHOR("Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>");
 MODULE_ALIAS("platform:rcar-pcm-audio");

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index af04d41a4274..f237002180c0 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1110,8 +1110,8 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 	if (!nr)
 		return -EINVAL;
 
-	rdrv = devm_kzalloc(dev, sizeof(*rdrv) * nr, GFP_KERNEL);
-	rdai = devm_kzalloc(dev, sizeof(*rdai) * nr, GFP_KERNEL);
+	rdrv = devm_kcalloc(dev, nr, sizeof(*rdrv), GFP_KERNEL);
+	rdai = devm_kcalloc(dev, nr, sizeof(*rdai), GFP_KERNEL);
 	if (!rdrv || !rdai)
 		return -ENOMEM;
 

commit 953de782cccf7a84e8a20cea72aea2a056fea3bf
Merge: 3fd391fb7c97 d0f8b9c5a350
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Apr 16 12:58:21 2018 +0100

    Merge branch 'asoc-4.17' into asoc-4.18 to get adau17x1 changes so
    further patches can be applied.

commit 5423d77253ac5bcb2d3de61cf0811c0f2a62c0af
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Apr 16 05:14:01 2018 +0000

    ASoC: rsnd: Enable IPMMU v2
    
    commit 4821d914fe747 ("ASoC: rsnd: use dma_sync_single_for_xxx() for
    IOMMU") (= v1) which have been already reverted had supported IPMMU
    support on rsnd driver.
    Because memory allocating timing and DMAEngine access timing were
    different, it used continuous memory and called dma map function by
    itself.
    
    OTOH, it is using DMA descriptor mode (= DMA cyclic mode), thus, there
    was timing conflict between DMA sync/unsync and DMA transfer starting,
    and it maked sound noise.
    
    This patch supports IPMMU with coherent memory, and, it uses Audio DMAC
    dev for allocating memory by snd_pcm_lib_preallocate_pages_for_all() to
    indicate memory area to IPMMU.
    One note is that Playback/Capture need each paired Audio DMAC dev.
    Because of this, we need to keep each paired Audio DMAC dev when probing,
    and use it when allocating each memory for IPMMU.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 47a55d6bfd80..f9ac086d8e05 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1352,6 +1352,37 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
 #define PREALLOC_BUFFER		(32 * 1024)
 #define PREALLOC_BUFFER_MAX	(32 * 1024)
 
+static int rsnd_preallocate_pages(struct snd_soc_pcm_runtime *rtd,
+				  struct rsnd_dai_stream *io,
+				  int stream)
+{
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct snd_pcm_substream *substream;
+	int err;
+
+	/*
+	 * use Audio-DMAC dev if we can use IPMMU
+	 * see
+	 *	rsnd_dmaen_attach()
+	 */
+	if (io->dmac_dev)
+		dev = io->dmac_dev;
+
+	for (substream = rtd->pcm->streams[stream].substream;
+	     substream;
+	     substream = substream->next) {
+		err = snd_pcm_lib_preallocate_pages(substream,
+					SNDRV_DMA_TYPE_DEV,
+					dev,
+					PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
 static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_dai *dai = rtd->cpu_dai;
@@ -1366,11 +1397,17 @@ static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 	if (ret)
 		return ret;
 
-	return snd_pcm_lib_preallocate_pages_for_all(
-		rtd->pcm,
-		SNDRV_DMA_TYPE_DEV,
-		rtd->card->snd_card->dev,
-		PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
+	ret = rsnd_preallocate_pages(rtd, &rdai->playback,
+				     SNDRV_PCM_STREAM_PLAYBACK);
+	if (ret)
+		return ret;
+
+	ret = rsnd_preallocate_pages(rtd, &rdai->capture,
+				     SNDRV_PCM_STREAM_CAPTURE);
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
 static const struct snd_soc_component_driver rsnd_soc_component = {

commit d188e140ad9723faccefa4ed5dc313cd467123c9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Apr 11 02:10:29 2018 +0000

    ASoC: rsnd: add RSND_GEN3 for R-Car Gen3
    
    rsnd driver is supporting Gen3. The difference between Gen1 and Gen2
    were very big, but, between Gen2 and Gen3 are not so much.
    Thus, it is assuming Gen2 and Gen3 have compatible, therefore,
    there is no RSND_GEN3 and rsnd_is_gen3() macro.
    But in the future, it will need Gen2 and Gen3 different operation,
    and for Gen4.
    This patch adds missing RSND_GEN3 and rsnd_is_gen3() macro.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Nguyen Viet Dung <dung.nguyen.aj@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 6a76688a8ba9..47a55d6bfd80 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -111,7 +111,7 @@
 static const struct of_device_id rsnd_of_match[] = {
 	{ .compatible = "renesas,rcar_sound-gen1", .data = (void *)RSND_GEN1 },
 	{ .compatible = "renesas,rcar_sound-gen2", .data = (void *)RSND_GEN2 },
-	{ .compatible = "renesas,rcar_sound-gen3", .data = (void *)RSND_GEN2 }, /* gen2 compatible */
+	{ .compatible = "renesas,rcar_sound-gen3", .data = (void *)RSND_GEN3 },
 	{},
 };
 MODULE_DEVICE_TABLE(of, rsnd_of_match);

commit 6f5427039c33e149b711c0f973fcac7f6875b768
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 28 16:53:10 2018 +0200

    ASoC: rsnd: mark PM functions __maybe_unused
    
    The suspend/resume callbacks are now optional, leading to a warning
    when they are unused:
    
    sound/soc/sh/rcar/core.c:1548:12: error: 'rsnd_resume' defined but not used [-Werror=unused-function]
     static int rsnd_resume(struct device *dev)
                ^~~~~~~~~~~
    sound/soc/sh/rcar/core.c:1539:12: error: 'rsnd_suspend' defined but not used [-Werror=unused-function]
     static int rsnd_suspend(struct device *dev)
    
    This marks the as __maybe_unused to avoid the warning.
    
    Fixes: f8a9a29c4fe9 ("ASoC: rsnd: set pm_ops in hibernate-compatible way")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 6a76688a8ba9..94f081b93258 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1536,7 +1536,7 @@ static int rsnd_remove(struct platform_device *pdev)
 	return ret;
 }
 
-static int rsnd_suspend(struct device *dev)
+static int __maybe_unused rsnd_suspend(struct device *dev)
 {
 	struct rsnd_priv *priv = dev_get_drvdata(dev);
 
@@ -1545,7 +1545,7 @@ static int rsnd_suspend(struct device *dev)
 	return 0;
 }
 
-static int rsnd_resume(struct device *dev)
+static int __maybe_unused rsnd_resume(struct device *dev)
 {
 	struct rsnd_priv *priv = dev_get_drvdata(dev);
 

commit 5c19015418b6b3322d573dee9210a7c9760d3ffe
Merge: 7275949eb51d 8dc906d3ae08 8b597ff47053 f8a9a29c4fe9 f548dd4f871b 8153362e757a
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Mar 28 10:30:19 2018 +0800

    Merge remote-tracking branches 'asoc/topic/pistachio', 'asoc/topic/pxa', 'asoc/topic/rsnd', 'asoc/topic/rt274' and 'asoc/topic/rt286' into asoc-next

commit f8a9a29c4fe9dd0dd2206cc4368efec95dc9defb
Author: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
Date:   Tue Mar 20 11:41:15 2018 +0300

    ASoC: rsnd: set pm_ops in hibernate-compatible way
    
    Use SET_SYSTEM_SLEEP_PM_OPS() macro instead of direct assignment to
    .suspend and .resume fields.
    
    This makes driver working after restore from hibernation.
    
    Signed-off-by: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 5aafc37f5119..96526c91a94b 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1569,8 +1569,7 @@ static int rsnd_resume(struct device *dev)
 }
 
 static const struct dev_pm_ops rsnd_pm_ops = {
-	.suspend		= rsnd_suspend,
-	.resume			= rsnd_resume,
+	SET_SYSTEM_SLEEP_PM_OPS(rsnd_suspend, rsnd_resume)
 };
 
 static struct platform_driver rsnd_driver = {

commit 1f6e920faae065fa8e6985b99ec86899bc3308de
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Feb 13 02:09:14 2018 +0000

    ASoC: rsnd: suppress rsnd_dai_call() debug message
    
    rsnd_dai_call() is using dev_dbg(), but its message is sometimes
    blocks nessesary other messages. If RSND_DEBUG_NO_DAI_CALL was
    defined it will be suppressed by this patch.
    
    Reported-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 64d5ecb86528..5aafc37f5119 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -93,6 +93,15 @@
  *  [mod]->fn() -> [mod]->fn() -> [mod]->fn()...
  *
  */
+
+/*
+ * you can enable below define if you don't need
+ * DAI status debug message when debugging
+ * see rsnd_dbg_dai_call()
+ *
+ * #define RSND_DEBUG_NO_DAI_CALL 1
+ */
+
 #include <linux/pm_runtime.h>
 #include "rsnd.h"
 
@@ -468,7 +477,7 @@ static int rsnd_status_update(u32 *status,
 						__rsnd_mod_shift_##fn,	\
 						__rsnd_mod_add_##fn,	\
 						__rsnd_mod_call_##fn);	\
-		dev_dbg(dev, "%s[%d]\t0x%08x %s\n",			\
+		rsnd_dbg_dai_call(dev, "%s[%d]\t0x%08x %s\n",		\
 			rsnd_mod_name(mod), rsnd_mod_id(mod), *status,	\
 			(func_call && (mod)->ops->fn) ? #fn : "");	\
 		if (func_call && (mod)->ops->fn)			\

commit 019ea01b7c510803d2f1ca8315916084887463c9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 29 02:42:53 2018 +0000

    ASoC: sh: rsnd: replace platform to component
    
    Now platform can be replaced to component, let's do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 64d5ecb86528..b4007669c704 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1337,7 +1337,7 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
 }
 
 /*
- *		snd_soc_platform
+ *		snd_soc_component
  */
 
 #define PREALLOC_BUFFER		(32 * 1024)
@@ -1364,12 +1364,9 @@ static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 		PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
 }
 
-static const struct snd_soc_platform_driver rsnd_soc_platform = {
+static const struct snd_soc_component_driver rsnd_soc_component = {
 	.ops		= &rsnd_pcm_ops,
 	.pcm_new	= rsnd_pcm_new,
-};
-
-static const struct snd_soc_component_driver rsnd_soc_component = {
 	.name		= "rsnd",
 };
 
@@ -1478,17 +1475,11 @@ static int rsnd_probe(struct platform_device *pdev)
 	/*
 	 *	asoc register
 	 */
-	ret = snd_soc_register_platform(dev, &rsnd_soc_platform);
-	if (ret < 0) {
-		dev_err(dev, "cannot snd soc register\n");
-		return ret;
-	}
-
-	ret = snd_soc_register_component(dev, &rsnd_soc_component,
+	ret = devm_snd_soc_register_component(dev, &rsnd_soc_component,
 					 priv->daidrv, rsnd_rdai_nr(priv));
 	if (ret < 0) {
 		dev_err(dev, "cannot snd dai register\n");
-		goto exit_snd_soc;
+		goto exit_snd_probe;
 	}
 
 	pm_runtime_enable(dev);
@@ -1496,8 +1487,6 @@ static int rsnd_probe(struct platform_device *pdev)
 	dev_info(dev, "probed\n");
 	return ret;
 
-exit_snd_soc:
-	snd_soc_unregister_platform(dev);
 exit_snd_probe:
 	for_each_rsnd_dai(rdai, priv, i) {
 		rsnd_dai_call(remove, &rdai->playback, priv);
@@ -1535,9 +1524,6 @@ static int rsnd_remove(struct platform_device *pdev)
 	for (i = 0; i < ARRAY_SIZE(remove_func); i++)
 		remove_func[i](priv);
 
-	snd_soc_unregister_component(&pdev->dev);
-	snd_soc_unregister_platform(&pdev->dev);
-
 	return ret;
 }
 

commit 9f761183947b91aacc4ed5c2a1a39ac08b938b6c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Dec 11 02:43:41 2017 +0000

    ASoC: rsnd: remove unneeded "is_graph" from __rsnd_dai_probe()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index a96ebebd96de..64d5ecb86528 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1017,7 +1017,7 @@ static struct device_node *rsnd_dai_of_node(struct rsnd_priv *priv,
 
 static void __rsnd_dai_probe(struct rsnd_priv *priv,
 			     struct device_node *dai_np,
-			     int dai_i, int is_graph)
+			     int dai_i)
 {
 	struct device_node *playback, *capture;
 	struct rsnd_dai_stream *io_playback;
@@ -1116,13 +1116,13 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 	dai_i = 0;
 	if (is_graph) {
 		for_each_endpoint_of_node(dai_node, dai_np) {
-			__rsnd_dai_probe(priv, dai_np, dai_i, is_graph);
+			__rsnd_dai_probe(priv, dai_np, dai_i);
 			rsnd_ssi_parse_hdmi_connection(priv, dai_np, dai_i);
 			dai_i++;
 		}
 	} else {
 		for_each_child_of_node(dai_node, dai_np)
-			__rsnd_dai_probe(priv, dai_np, dai_i++, is_graph);
+			__rsnd_dai_probe(priv, dai_np, dai_i++);
 	}
 
 	return 0;

commit 41acc8ec04f32abb16e035ca1c9fe4d52819601e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Dec 11 02:24:23 2017 +0000

    ASoC: rsnd: don't use runtime->sample_bits
    
    Current rsnd driver is judging 16bit/24bit data by using
    runtime->sample_bits, but it is indicating physical size,
    not format size. This is confusable code.
    This patch uses snd_pcm_format_width() to be more correct code.
    
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8e50b284230d..a96ebebd96de 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -274,10 +274,10 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
 
-	switch (runtime->sample_bits) {
+	switch (snd_pcm_format_width(runtime->format)) {
 	case 16:
 		return 8 << 16;
-	case 32:
+	case 24:
 		return 0 << 16;
 	}
 
@@ -327,7 +327,7 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	}
 
 	/* Non target mod or 24bit data needs normal DALIGN */
-	if ((runtime->sample_bits != 16) ||
+	if ((snd_pcm_format_width(runtime->format) != 16) ||
 	    (mod != target))
 		return 0x76543210;
 	/* Target mod needs inverted DALIGN when 16bit */
@@ -362,12 +362,8 @@ u32 rsnd_get_busif_shift(struct rsnd_dai_stream *io, struct rsnd_mod *mod)
 	 * HW    24bit data is located as 0x******00
 	 *
 	 */
-	switch (runtime->sample_bits) {
-	case 16:
+	if (snd_pcm_format_width(runtime->format) == 16)
 		return 0;
-	case 32:
-		break;
-	}
 
 	for (i = 0; i < ARRAY_SIZE(playback_mods); i++) {
 		tmod = rsnd_io_to_mod(io, mods[i]);

commit a914e44693d41ba43604afa8c435c98a6d2c7cb1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 8 06:23:11 2017 +0000

    ASoC: rsnd: more clear rsnd_get_dalign() for DALIGN
    
    On Renesas sound device, DALIGN which exchanges channel position
    is needed because SW and HW are using defferent data order if
    16bit data. It is not needed when 24bit data.
    rsnd_get_dalign() returns necessary value, but it was confusable
    code. This patch makes it more simple.
    
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index d76ad46a6fd9..8e50b284230d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -294,11 +294,12 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	struct rsnd_mod *ssiu = rsnd_io_to_mod_ssiu(io);
 	struct rsnd_mod *target;
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
-	u32 val = 0x76543210;
-	u32 mask = ~0;
 
 	/*
-	 * *Hardware* L/R and *Software* L/R are inverted.
+	 * *Hardware* L/R and *Software* L/R are inverted for 16bit data.
+	 *	    31..16 15...0
+	 *	HW: [L ch] [R ch]
+	 *	SW: [R ch] [L ch]
 	 * We need to care about inversion timing to control
 	 * Playback/Capture correctly.
 	 * The point is [DVC] needs *Hardware* L/R, [MEM] needs *Software* L/R
@@ -325,27 +326,13 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 		target = cmd ? cmd : ssiu;
 	}
 
-	mask <<= runtime->channels * 4;
-	val = val & mask;
-
-	switch (runtime->sample_bits) {
-	case 16:
-		val |= 0x67452301 & ~mask;
-		break;
-	case 32:
-		val |= 0x76543210 & ~mask;
-		break;
-	}
-
-	/*
-	 * exchange channeles on SRC if possible,
-	 * otherwise, R/L volume settings on DVC
-	 * changes inverted channels
-	 */
-	if (mod == target)
-		return val;
-	else
+	/* Non target mod or 24bit data needs normal DALIGN */
+	if ((runtime->sample_bits != 16) ||
+	    (mod != target))
 		return 0x76543210;
+	/* Target mod needs inverted DALIGN when 16bit */
+	else
+		return 0x67452301;
 }
 
 u32 rsnd_get_busif_shift(struct rsnd_dai_stream *io, struct rsnd_mod *mod)

commit b2fb31bb7454d5479b1c7214ccd10c1af85a6245
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 29 03:07:51 2017 +0000

    ASoC: rsnd: TDM 6ch needs 8ch clock for hw refine
    
    Renesas sound needs 8ch clock if TDM 6ch mode, and needs 2ch clock for
    6ch or 8ch sound if Multi SSI mode. And these are related to before/after
    CTU (= Channel Transfer Unit).
    To calculate these we already has rsnd_runtime_channel_for_ssi() which
    returns runtime necessary channels.
    But, it based on runtime->channels  which is not yet set when hw refine.
    We need to use hw_params instead of runtime->xxx when hw refine,
    and it is not needed after runtime was set.
    This patch adds new hw_params on rsnd_dai_stream, and it will be removed
    on rsnd_hw_params().
    This is very temporary durty code, but it seems no choice at this point.
    
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index bd64dc6ec1c3..d76ad46a6fd9 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -197,16 +197,27 @@ int rsnd_io_is_working(struct rsnd_dai_stream *io)
 	return 0;
 }
 
-int rsnd_runtime_channel_original(struct rsnd_dai_stream *io)
+int rsnd_runtime_channel_original_with_params(struct rsnd_dai_stream *io,
+					      struct snd_pcm_hw_params *params)
 {
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 
-	return runtime->channels;
+	/*
+	 * params will be added when refine
+	 * see
+	 *	__rsnd_soc_hw_rule_rate()
+	 *	__rsnd_soc_hw_rule_channels()
+	 */
+	if (params)
+		return params_channels(params);
+	else
+		return runtime->channels;
 }
 
-int rsnd_runtime_channel_after_ctu(struct rsnd_dai_stream *io)
+int rsnd_runtime_channel_after_ctu_with_params(struct rsnd_dai_stream *io,
+					       struct snd_pcm_hw_params *params)
 {
-	int chan = rsnd_runtime_channel_original(io);
+	int chan = rsnd_runtime_channel_original_with_params(io, params);
 	struct rsnd_mod *ctu_mod = rsnd_io_to_mod_ctu(io);
 
 	if (ctu_mod) {
@@ -219,12 +230,13 @@ int rsnd_runtime_channel_after_ctu(struct rsnd_dai_stream *io)
 	return chan;
 }
 
-int rsnd_runtime_channel_for_ssi(struct rsnd_dai_stream *io)
+int rsnd_runtime_channel_for_ssi_with_params(struct rsnd_dai_stream *io,
+					     struct snd_pcm_hw_params *params)
 {
 	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
 	int chan = rsnd_io_is_play(io) ?
-		rsnd_runtime_channel_after_ctu(io) :
-		rsnd_runtime_channel_original(io);
+		rsnd_runtime_channel_after_ctu_with_params(io, params) :
+		rsnd_runtime_channel_original_with_params(io, params);
 
 	/* Use Multi SSI */
 	if (rsnd_runtime_is_ssi_multi(io))
@@ -616,8 +628,6 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
-		rsnd_dai_stream_init(io, substream);
-
 		ret = rsnd_dai_call(init, io, priv);
 		if (ret < 0)
 			goto dai_trigger_end;
@@ -639,7 +649,6 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 
 		ret |= rsnd_dai_call(quit, io, priv);
 
-		rsnd_dai_stream_quit(io);
 		break;
 	default:
 		ret = -EINVAL;
@@ -784,8 +793,9 @@ static int rsnd_soc_hw_rule(struct rsnd_priv *priv,
 	return snd_interval_refine(iv, &p);
 }
 
-static int rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,
-				 struct snd_pcm_hw_rule *rule)
+static int __rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,
+				   struct snd_pcm_hw_rule *rule,
+				   int is_play)
 {
 	struct snd_interval *ic_ = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
 	struct snd_interval *ir = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
@@ -793,25 +803,37 @@ static int rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,
 	struct snd_soc_dai *dai = rule->private;
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
+	struct rsnd_dai_stream *io = is_play ? &rdai->playback : &rdai->capture;
 
 	/*
 	 * possible sampling rate limitation is same as
 	 * 2ch if it supports multi ssi
+	 * and same as 8ch if TDM 6ch (see rsnd_ssi_config_init())
 	 */
 	ic = *ic_;
-	if (1 < rsnd_rdai_ssi_lane_get(rdai)) {
-		ic.min = 2;
-		ic.max = 2;
-	}
+	ic.min =
+	ic.max = rsnd_runtime_channel_for_ssi_with_params(io, params);
 
 	return rsnd_soc_hw_rule(priv, rsnd_soc_hw_rate_list,
 				ARRAY_SIZE(rsnd_soc_hw_rate_list),
 				&ic, ir);
 }
 
+static int rsnd_soc_hw_rule_rate_playback(struct snd_pcm_hw_params *params,
+				 struct snd_pcm_hw_rule *rule)
+{
+	return __rsnd_soc_hw_rule_rate(params, rule, 1);
+}
+
+static int rsnd_soc_hw_rule_rate_capture(struct snd_pcm_hw_params *params,
+					  struct snd_pcm_hw_rule *rule)
+{
+	return __rsnd_soc_hw_rule_rate(params, rule, 0);
+}
 
-static int rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
-				     struct snd_pcm_hw_rule *rule)
+static int __rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
+				       struct snd_pcm_hw_rule *rule,
+				       int is_play)
 {
 	struct snd_interval *ic_ = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
 	struct snd_interval *ir = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
@@ -819,22 +841,34 @@ static int rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
 	struct snd_soc_dai *dai = rule->private;
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
+	struct rsnd_dai_stream *io = is_play ? &rdai->playback : &rdai->capture;
 
 	/*
 	 * possible sampling rate limitation is same as
 	 * 2ch if it supports multi ssi
+	 * and same as 8ch if TDM 6ch (see rsnd_ssi_config_init())
 	 */
 	ic = *ic_;
-	if (1 < rsnd_rdai_ssi_lane_get(rdai)) {
-		ic.min = 2;
-		ic.max = 2;
-	}
+	ic.min =
+	ic.max = rsnd_runtime_channel_for_ssi_with_params(io, params);
 
 	return rsnd_soc_hw_rule(priv, rsnd_soc_hw_channels_list,
 				ARRAY_SIZE(rsnd_soc_hw_channels_list),
 				ir, &ic);
 }
 
+static int rsnd_soc_hw_rule_channels_playback(struct snd_pcm_hw_params *params,
+					      struct snd_pcm_hw_rule *rule)
+{
+	return __rsnd_soc_hw_rule_channels(params, rule, 1);
+}
+
+static int rsnd_soc_hw_rule_channels_capture(struct snd_pcm_hw_params *params,
+					     struct snd_pcm_hw_rule *rule)
+{
+	return __rsnd_soc_hw_rule_channels(params, rule, 0);
+}
+
 static const struct snd_pcm_hardware rsnd_pcm_hardware = {
 	.info =		SNDRV_PCM_INFO_INTERLEAVED	|
 			SNDRV_PCM_INFO_MMAP		|
@@ -859,6 +893,8 @@ static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
 	int ret;
 	int i;
 
+	rsnd_dai_stream_init(io, substream);
+
 	/*
 	 * Channel Limitation
 	 * It depends on Platform design
@@ -886,11 +922,17 @@ static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
 	 * It depends on Clock Master Mode
 	 */
 	if (rsnd_rdai_is_clk_master(rdai)) {
+		int is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-				    rsnd_soc_hw_rule_rate, dai,
+				    is_play ? rsnd_soc_hw_rule_rate_playback :
+					      rsnd_soc_hw_rule_rate_capture,
+				    dai,
 				    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				    rsnd_soc_hw_rule_channels, dai,
+				    is_play ? rsnd_soc_hw_rule_channels_playback :
+					      rsnd_soc_hw_rule_channels_capture,
+				    dai,
 				    SNDRV_PCM_HW_PARAM_RATE, -1);
 	}
 
@@ -915,6 +957,8 @@ static void rsnd_soc_dai_shutdown(struct snd_pcm_substream *substream,
 	 * call rsnd_dai_call without spinlock
 	 */
 	rsnd_dai_call(nolock_stop, io, priv);
+
+	rsnd_dai_stream_quit(io);
 }
 
 static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {

commit 180d9ef58104dfae78622d01910b9b7756701134
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 6 08:41:37 2017 +0000

    ASoC: rsnd: call snd_soc_disconnect_sync() when remove
    
    Renesas R-Car sound driver should be stopped if unbinded during
    playbacking/capturing. Otherwise clock open/close counter mismatch
    happen.
    
    One note is that we can't skip from remove function (= return -Exxx)
    in such case if user used unbind. Because unbind function doesn't
    check return value from each driver's remove function.
    This means we must to stop and remove driver in remove function.
    
    Now ASoC has snd_soc_disconnect_sync() for this purpose.
    Let's use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f12a88a21dfa..bd64dc6ec1c3 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1496,6 +1496,8 @@ static int rsnd_remove(struct platform_device *pdev)
 	};
 	int ret = 0, i;
 
+	snd_soc_disconnect_sync(&pdev->dev);
+
 	pm_runtime_disable(&pdev->dev);
 
 	for_each_rsnd_dai(rdai, priv, i) {

commit c20c6704bf2dafaba0d90c8310ef9e919fe4d2e2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 16 04:36:51 2017 +0000

    ASoC: rcar: revert IOMMU support so far
    
    commit 4821d914fe74 ("ASoC: rsnd: use dma_sync_single_for_xxx() for
    IOMMU") had supported IOMMU, but it breaks normal sound "recorde"
    and both PulseAudio's "playback/recorde". The sound will be noisy.
    
    That commit was using dma_sync_single_for_xxx(), and driver should
    make sure memory is protected during CPU or Device are using it.
    But if driver returns current "residue" data size correctly on pointer
    function, player/recorder will access to protected memory.
    
    IOMMU feature should be supported, but I don't know how to handle it
    without memory cache problem at this point.
    Thus, this patch simply revert it to avoid current noisy sound.
    
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Tested-by: Ryo Kodama <ryo.kodama.vz@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index c70eb2097816..f12a88a21dfa 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1332,8 +1332,8 @@ static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 
 	return snd_pcm_lib_preallocate_pages_for_all(
 		rtd->pcm,
-		SNDRV_DMA_TYPE_CONTINUOUS,
-		snd_dma_continuous_data(GFP_KERNEL),
+		SNDRV_DMA_TYPE_DEV,
+		rtd->card->snd_card->dev,
 		PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
 }
 

commit 9b6ea25066b05c4b8bc4ea69037741bd67649cd1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 1 07:17:34 2017 +0000

    ASoC: rsnd: remove NULL check from rsnd_mod_name()/rsnd_mod_id()
    
    Current rsnd driver has rsnd_mod_id() which returns mod ID,
    and it returns -1 if mod was NULL.
    In the same time, this driver has rsnd_mod_name() which returns mod
    name, and it returns "unknown" if mod or mod->ops was NULL.
    
    Basically these "mod" never be NULL, but the reason why rsnd driver
    has such behavior is that DMA path finder is assuming memory as
    "mod == NULL".
    Thus, current DMA path debug code prints like below.
    Here "unknown[-1]" means it was memory.
    
            ...
            rcar_sound ec500000.sound:   unknown[-1] from
            rcar_sound ec500000.sound:   src[0] to
            rcar_sound ec500000.sound:   ctu[2]
            rcar_sound ec500000.sound:   mix[0]
            rcar_sound ec500000.sound:   dvc[0]
            rcar_sound ec500000.sound:   ssi[0]
            rcar_sound ec500000.sound: audmac[0] unknown[-1] -> src[0]
            ...
    
    1st issue is that it is confusable for user.
    2nd issue is rsnd driver has something like below code.
    
            mask |= 1 << rsnd_mod_id(mod);
    
    Because of this kind of code, some statically code checker will
    reports "Shifting by a negative value is undefined behaviour".
    
    But this "mod" never be NULL, thus negative shift never happen.
    To avoid these issues, this patch adds new dummy "mem" to
    indicate memory, and use it to indicate debug information,
    and, remove unneeded "NULL mod" behavior from rsnd_mod_id() and
    rsnd_mod_name().
    
    The debug information will be like below by this patch
            ...
            rcar_sound ec500000.sound:   mem[0] from
            rcar_sound ec500000.sound:   src[0] to
            rcar_sound ec500000.sound:   ctu[2]
            rcar_sound ec500000.sound:   mix[0]
            rcar_sound ec500000.sound:   dvc[0]
            rcar_sound ec500000.sound:   ssi[0]
            rcar_sound ec500000.sound: audmac[0] mem[0] -> src[0]
            ...
    
    Reported-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b36832ef7342..c70eb2097816 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -121,14 +121,6 @@ void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
 	}
 }
 
-char *rsnd_mod_name(struct rsnd_mod *mod)
-{
-	if (!mod || !mod->ops)
-		return "unknown";
-
-	return mod->ops->name;
-}
-
 struct dma_chan *rsnd_mod_dma_req(struct rsnd_dai_stream *io,
 				  struct rsnd_mod *mod)
 {

commit 8fce974bc4d5478d4ddee2443a3e268532ab35a8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 31 00:39:45 2017 +0000

    ASoC: rsnd: use snd_pcm_running() in rsnd_io_is_working()
    
    Let's use more common style to checking running/working
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 0216d3f53097..b36832ef7342 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -199,7 +199,10 @@ void rsnd_mod_interrupt(struct rsnd_mod *mod,
 int rsnd_io_is_working(struct rsnd_dai_stream *io)
 {
 	/* see rsnd_dai_stream_init/quit() */
-	return !!io->substream;
+	if (io->substream)
+		return snd_pcm_running(io->substream);
+
+	return 0;
 }
 
 int rsnd_runtime_channel_original(struct rsnd_dai_stream *io)

commit ed3ac14ca90074d51f365dba5ed535e76ea155ea
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 31 00:39:17 2017 +0000

    ASoC: rsnd: NULL check is not needed for clk_unprepare()
    
    clk_unprepare() is checking parameter by IS_ERR_OR_NULL().
    clk NULL check is not needed on rsnd_mod_quit()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8fc3bf2b20f5..0216d3f53097 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -172,8 +172,7 @@ int rsnd_mod_init(struct rsnd_priv *priv,
 
 void rsnd_mod_quit(struct rsnd_mod *mod)
 {
-	if (mod->clk)
-		clk_unprepare(mod->clk);
+	clk_unprepare(mod->clk);
 	mod->clk = NULL;
 }
 

commit b12f1e3a798e19727ca632d92abe619b418ad0d0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 31 00:38:36 2017 +0000

    ASoC: rsnd: tidyup rsnd_mod_next() for loop method
    
    Let's remove point less "continue"
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b338c0009506..8fc3bf2b20f5 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -408,10 +408,8 @@ struct rsnd_mod *rsnd_mod_next(int *iterator,
 	for (; *iterator < max; (*iterator)++) {
 		type = (array) ? array[*iterator] : *iterator;
 		mod = rsnd_io_to_mod(io, type);
-		if (!mod)
-			continue;
-
-		return mod;
+		if (mod)
+			return mod;
 	}
 
 	return NULL;

commit 138f878647f2ac0d7700f669b860cb130306e062
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 31 00:38:09 2017 +0000

    ASoC: rsnd: don't use io->mod[] directly
    
    We have rsnd_io_to_mod() macro. Let's use it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index e9b0b0f5f0ee..b338c0009506 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -407,7 +407,7 @@ struct rsnd_mod *rsnd_mod_next(int *iterator,
 
 	for (; *iterator < max; (*iterator)++) {
 		type = (array) ? array[*iterator] : *iterator;
-		mod = io->mod[type];
+		mod = rsnd_io_to_mod(io, type);
 		if (!mod)
 			continue;
 

commit 3e3c9ee1e4b3d0ef1f68f2037752196e7260bad9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Oct 1 23:49:18 2017 +0000

    ASoC: rsnd: add MIX Volume Ramp support
    
    Both DVC/MIX have Volume Ramp Control. This patch supprts MIX
    Volume Ramp. One note is that main purpose of MIX Volume Ramp
    is to reduce noise, thus, MIX Ramp range is very few if you
    compare to DVC Volume Ramp (DVC = 5bit, MIX = 4bit).
    
    You can use MIX Volume Ranp like below
            amixer set "MIX Ramp Up Rate"   "0.125 dB/1 step"
            amixer set "MIX Ramp Down Rate" "0.125 dB/1 step"
            amixer set "MIX Ramp" on
            aplay xxx.wav &
            amixer set "MIX",0  80%  // DAI0 Volume Down
            amixer set "MIX",1 100%  // DAI1 Volume Up
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 2d94b3d4519c..e9b0b0f5f0ee 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1253,7 +1253,7 @@ const char * const volume_ramp_rate[] = {
 	"1 dB/1 step",		 /* 00111 */
 	"0.5 dB/1 step",	 /* 01000 */
 	"0.25 dB/1 step",	 /* 01001 */
-	"0.125 dB/1 step",	 /* 01010 */
+	"0.125 dB/1 step",	 /* 01010 = VOLUME_RAMP_MAX_MIX */
 	"0.125 dB/2 steps",	 /* 01011 */
 	"0.125 dB/4 steps",	 /* 01100 */
 	"0.125 dB/8 steps",	 /* 01101 */

commit f3c26ac61c09862f0037fe484a98da0364f02ec3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Oct 1 23:49:03 2017 +0000

    ASoC: rsnd: makes volume ramp rate list generic
    
    DVC is supporting Volume Ramp Rate, and MIX has Volume Ramp
    but not yet supported. To support MIX Volume Ramp, we want to
    share Rate List since DVC/MIX are using almost same list.
    This patch move DVC specific Volume Ramp Rate List to core.c.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 107133297e8d..2d94b3d4519c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1242,6 +1242,33 @@ struct rsnd_kctrl_cfg *rsnd_kctrl_init_s(struct rsnd_kctrl_cfg_s *cfg)
 	return &cfg->cfg;
 }
 
+const char * const volume_ramp_rate[] = {
+	"128 dB/1 step",	 /* 00000 */
+	"64 dB/1 step",		 /* 00001 */
+	"32 dB/1 step",		 /* 00010 */
+	"16 dB/1 step",		 /* 00011 */
+	"8 dB/1 step",		 /* 00100 */
+	"4 dB/1 step",		 /* 00101 */
+	"2 dB/1 step",		 /* 00110 */
+	"1 dB/1 step",		 /* 00111 */
+	"0.5 dB/1 step",	 /* 01000 */
+	"0.25 dB/1 step",	 /* 01001 */
+	"0.125 dB/1 step",	 /* 01010 */
+	"0.125 dB/2 steps",	 /* 01011 */
+	"0.125 dB/4 steps",	 /* 01100 */
+	"0.125 dB/8 steps",	 /* 01101 */
+	"0.125 dB/16 steps",	 /* 01110 */
+	"0.125 dB/32 steps",	 /* 01111 */
+	"0.125 dB/64 steps",	 /* 10000 */
+	"0.125 dB/128 steps",	 /* 10001 */
+	"0.125 dB/256 steps",	 /* 10010 */
+	"0.125 dB/512 steps",	 /* 10011 */
+	"0.125 dB/1024 steps",	 /* 10100 */
+	"0.125 dB/2048 steps",	 /* 10101 */
+	"0.125 dB/4096 steps",	 /* 10110 */
+	"0.125 dB/8192 steps",	 /* 10111 = VOLUME_RAMP_MAX_DVC */
+};
+
 int rsnd_kctrl_new(struct rsnd_mod *mod,
 		   struct rsnd_dai_stream *io,
 		   struct snd_soc_pcm_runtime *rtd,

commit 5c2e035e69ffff4c8b3f0a2ddfefa102ad9d9d42
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Thu Aug 17 15:46:11 2017 +0530

    ASoC: sh: make snd_pcm_hardware const
    
    Make these const as they are only passed as the 2nd argument to the
    function snd_soc_set_runtime_hwparams, which is const.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index df39831b8e8f..107133297e8d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -843,7 +843,7 @@ static int rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
 				ir, &ic);
 }
 
-static struct snd_pcm_hardware rsnd_pcm_hardware = {
+static const struct snd_pcm_hardware rsnd_pcm_hardware = {
 	.info =		SNDRV_PCM_INFO_INTERLEAVED	|
 			SNDRV_PCM_INFO_MMAP		|
 			SNDRV_PCM_INFO_MMAP_VALID,

commit ce25f0d6e750a808118b699fe9f917c954710cc8
Merge: 0d7820d0918e b23bd34c402d
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Aug 14 17:53:16 2017 +0100

    Merge branch 'topic/sh' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-rcar

commit b23bd34c402d08a2c1d6facdba4a75e016601c12
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Aug 14 11:26:32 2017 +0530

    ASoC: sh: constify snd_pcm_ops structures
    
    snd_pcm_ops are not supposed to change at runtime. All functions
    working with snd_pcm_ops provided by <sound/soc.h> work with
    const snd_pcm_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index e50f7e7981c8..08f3a06978e1 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1158,7 +1158,7 @@ static snd_pcm_uframes_t rsnd_pointer(struct snd_pcm_substream *substream)
 	return pointer;
 }
 
-static struct snd_pcm_ops rsnd_pcm_ops = {
+static const struct snd_pcm_ops rsnd_pcm_ops = {
 	.open		= rsnd_pcm_open,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= rsnd_hw_params,

commit 517725545179be8d32730844f1619ee31ef04bf3
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Aug 14 17:08:48 2017 +0530

    ASoC: sh: make snd_soc_platform_driver const
    
    Make these const as they are either passed as the 2nd argument to
    the function devm_snd_soc_register_platform or snd_soc_register_platform,
    and the arguments are of type const.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3f2ced26ed37..e50f7e7981c8 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1339,7 +1339,7 @@ static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 		PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
 }
 
-static struct snd_soc_platform_driver rsnd_soc_platform = {
+static const struct snd_soc_platform_driver rsnd_soc_platform = {
 	.ops		= &rsnd_pcm_ops,
 	.pcm_new	= rsnd_pcm_new,
 };

commit 0d7820d0918efa6c2a53acdfc47cbfc3b48df727
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Aug 10 17:13:19 2017 +0200

    ASoC: rsnd: Delete an error message for a failed memory allocation in three functions
    
    Omit an extra message for a memory allocation failure in these functions.
    
    This issue was detected by using the Coccinelle software.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 2c12ad2b2b34..650cc28b0fb6 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1401,10 +1401,8 @@ static int rsnd_probe(struct platform_device *pdev)
 	 *	init priv data
 	 */
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		dev_err(dev, "priv allocate failed\n");
+	if (!priv)
 		return -ENODEV;
-	}
 
 	priv->pdev	= pdev;
 	priv->flags	= (unsigned long)of_device_get_match_data(dev);

commit 880c15b1e66345cdd1bbd8fc4c9c2119c6eb2da3
Merge: bb002f925ae1 e0936c3471a8
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Aug 10 15:51:05 2017 +0100

    Merge branch 'fix/rcar' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-rcar

commit 29d03ff5c752e02918e8319fdcc86faa374d36ec
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 9 01:46:23 2017 +0000

    ASoC: rsnd: remove 16ch support for now
    
    R-Car Gen3 sound device can use TDM 16ch, but its usage is very
    limited. It is not yet supported.
    Let's remove unexpected/unsupported channel settings for now.
    This patch makes xx_ADINR register settings sanity without
    runtime check.
    
    R-Car Gen3 datasheet
    
    40.4.7 Note on Usage of the SSIU Module
    When an SSIU module is used in "TDM-16ch mode",
    only the transfer with the external memory is available.
    
    Reported-by: Nguyen Viet Dung <dung.nguyen.aj@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3f2ced26ed37..7fa40fcad59e 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -726,7 +726,6 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 	case 2:
 	case 6:
 	case 8:
-	case 16:
 		/* TDM Extend Mode */
 		rsnd_rdai_channels_set(rdai, slots);
 		rsnd_rdai_ssi_lane_set(rdai, 1);
@@ -740,7 +739,7 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 }
 
 static unsigned int rsnd_soc_hw_channels_list[] = {
-	2, 6, 8, 16,
+	2, 6, 8,
 };
 
 static unsigned int rsnd_soc_hw_rate_list[] = {
@@ -1017,7 +1016,7 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 	drv->playback.rates		= RSND_RATES;
 	drv->playback.formats		= RSND_FMTS;
 	drv->playback.channels_min	= 2;
-	drv->playback.channels_max	= 16;
+	drv->playback.channels_max	= 8;
 	drv->playback.stream_name	= rdai->playback.name;
 
 	snprintf(rdai->capture.name, RSND_DAI_NAME_SIZE,
@@ -1025,7 +1024,7 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 	drv->capture.rates		= RSND_RATES;
 	drv->capture.formats		= RSND_FMTS;
 	drv->capture.channels_min	= 2;
-	drv->capture.channels_max	= 16;
+	drv->capture.channels_max	= 8;
 	drv->capture.stream_name	= rdai->capture.name;
 
 	rdai->playback.rdai		= rdai;

commit 3c9736aa1ab59e64ebc33b140b000f90c8f9de46
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jul 27 01:32:06 2017 +0000

    ASoC: rsnd: merge snd_pcm_ops::open and snd_soc_dai_ops::startup
    
    Current rsnd driver has snd_pcm_ops::open and snd_soc_dai_ops::startup,
    but, these are called from soc_pcm_open in same time.
    This patch merge these into rsnd_soc_dai_startup()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index acafb838b7b7..c34562388cfa 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -844,12 +844,28 @@ static int rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
 				ir, &ic);
 }
 
-static void rsnd_soc_hw_constraint(struct snd_pcm_runtime *runtime,
-				   struct snd_soc_dai *dai)
+static struct snd_pcm_hardware rsnd_pcm_hardware = {
+	.info =		SNDRV_PCM_INFO_INTERLEAVED	|
+			SNDRV_PCM_INFO_MMAP		|
+			SNDRV_PCM_INFO_MMAP_VALID,
+	.buffer_bytes_max	= 64 * 1024,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8192,
+	.periods_min		= 1,
+	.periods_max		= 32,
+	.fifo_size		= 256,
+};
+
+static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
 {
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
+	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
 	struct snd_pcm_hw_constraint_list *constraint = &rdai->constraint;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int max_channels = rsnd_rdai_channels_get(rdai);
+	int ret;
 	int i;
 
 	/*
@@ -866,34 +882,26 @@ static void rsnd_soc_hw_constraint(struct snd_pcm_runtime *runtime,
 		constraint->count = i + 1;
 	}
 
+	snd_soc_set_runtime_hwparams(substream, &rsnd_pcm_hardware);
+
 	snd_pcm_hw_constraint_list(runtime, 0,
 				   SNDRV_PCM_HW_PARAM_CHANNELS, constraint);
 
+	snd_pcm_hw_constraint_integer(runtime,
+				      SNDRV_PCM_HW_PARAM_PERIODS);
+
 	/*
 	 * Sampling Rate / Channel Limitation
 	 * It depends on Clock Master Mode
 	 */
-	if (!rsnd_rdai_is_clk_master(rdai))
-		return;
-
-	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-			    rsnd_soc_hw_rule_rate, dai,
-			    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
-	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-			    rsnd_soc_hw_rule_channels, dai,
-			    SNDRV_PCM_HW_PARAM_RATE, -1);
-}
-
-static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
-				struct snd_soc_dai *dai)
-{
-	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
-	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
-	int ret;
-
-	/* rsnd_io_to_runtime() is not yet enabled here */
-	rsnd_soc_hw_constraint(substream->runtime, dai);
+	if (rsnd_rdai_is_clk_master(rdai)) {
+		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				    rsnd_soc_hw_rule_rate, dai,
+				    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+				    rsnd_soc_hw_rule_channels, dai,
+				    SNDRV_PCM_HW_PARAM_RATE, -1);
+	}
 
 	/*
 	 * call rsnd_dai_call without spinlock
@@ -1105,31 +1113,6 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 /*
  *		pcm ops
  */
-static struct snd_pcm_hardware rsnd_pcm_hardware = {
-	.info =		SNDRV_PCM_INFO_INTERLEAVED	|
-			SNDRV_PCM_INFO_MMAP		|
-			SNDRV_PCM_INFO_MMAP_VALID,
-	.buffer_bytes_max	= 64 * 1024,
-	.period_bytes_min	= 32,
-	.period_bytes_max	= 8192,
-	.periods_min		= 1,
-	.periods_max		= 32,
-	.fifo_size		= 256,
-};
-
-static int rsnd_pcm_open(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int ret = 0;
-
-	snd_soc_set_runtime_hwparams(substream, &rsnd_pcm_hardware);
-
-	ret = snd_pcm_hw_constraint_integer(runtime,
-					    SNDRV_PCM_HW_PARAM_PERIODS);
-
-	return ret;
-}
-
 static int rsnd_hw_params(struct snd_pcm_substream *substream,
 			 struct snd_pcm_hw_params *hw_params)
 {
@@ -1159,7 +1142,6 @@ static snd_pcm_uframes_t rsnd_pointer(struct snd_pcm_substream *substream)
 }
 
 static struct snd_pcm_ops rsnd_pcm_ops = {
-	.open		= rsnd_pcm_open,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= rsnd_hw_params,
 	.hw_free	= snd_pcm_lib_free_pages,

commit 16d4498962c7b76a76553e8dd943abe1e9facc0d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 24 01:45:59 2017 +0000

    ASoC: rsnd: don't use private_value on rsnd_kctrl_new()
    
    Current rsnd kctrl is using both .private_value (for rsnd_kctrl_cfg)
    and .private_data (for rsnd_mod) on snd_kcontrol.
    But only 1 private data (= rsnd_kctrl_cfg) can be enough if it has
    rsnd_mod pointer.
    This patch doesn't use private_value.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3f2ced26ed37..acafb838b7b7 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1169,11 +1169,10 @@ static struct snd_pcm_ops rsnd_pcm_ops = {
 /*
  *		snd_kcontrol
  */
-#define kcontrol_to_cfg(kctrl) ((struct rsnd_kctrl_cfg *)kctrl->private_value)
 static int rsnd_kctrl_info(struct snd_kcontrol *kctrl,
 			   struct snd_ctl_elem_info *uinfo)
 {
-	struct rsnd_kctrl_cfg *cfg = kcontrol_to_cfg(kctrl);
+	struct rsnd_kctrl_cfg *cfg = snd_kcontrol_chip(kctrl);
 
 	if (cfg->texts) {
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
@@ -1199,7 +1198,7 @@ static int rsnd_kctrl_info(struct snd_kcontrol *kctrl,
 static int rsnd_kctrl_get(struct snd_kcontrol *kctrl,
 			  struct snd_ctl_elem_value *uc)
 {
-	struct rsnd_kctrl_cfg *cfg = kcontrol_to_cfg(kctrl);
+	struct rsnd_kctrl_cfg *cfg = snd_kcontrol_chip(kctrl);
 	int i;
 
 	for (i = 0; i < cfg->size; i++)
@@ -1214,8 +1213,7 @@ static int rsnd_kctrl_get(struct snd_kcontrol *kctrl,
 static int rsnd_kctrl_put(struct snd_kcontrol *kctrl,
 			  struct snd_ctl_elem_value *uc)
 {
-	struct rsnd_mod *mod = snd_kcontrol_chip(kctrl);
-	struct rsnd_kctrl_cfg *cfg = kcontrol_to_cfg(kctrl);
+	struct rsnd_kctrl_cfg *cfg = snd_kcontrol_chip(kctrl);
 	int i, change = 0;
 
 	if (!cfg->accept(cfg->io))
@@ -1232,7 +1230,7 @@ static int rsnd_kctrl_put(struct snd_kcontrol *kctrl,
 	}
 
 	if (change && cfg->update)
-		cfg->update(cfg->io, mod);
+		cfg->update(cfg->io, cfg->mod);
 
 	return change;
 }
@@ -1284,14 +1282,13 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
 		.index		= rtd->num,
 		.get		= rsnd_kctrl_get,
 		.put		= rsnd_kctrl_put,
-		.private_value	= (unsigned long)cfg,
 	};
 	int ret;
 
 	if (size > RSND_MAX_CHANNELS)
 		return -EINVAL;
 
-	kctrl = snd_ctl_new1(&knew, mod);
+	kctrl = snd_ctl_new1(&knew, cfg);
 	if (!kctrl)
 		return -ENOMEM;
 
@@ -1307,6 +1304,7 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
 	cfg->card	= card;
 	cfg->kctrl	= kctrl;
 	cfg->io		= io;
+	cfg->mod	= mod;
 
 	return 0;
 }

commit 49ebf13b0453d8535cd53abb514e1683a1875208
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Jun 29 10:40:50 2017 +0530

    ASoC: rsnd: constify dev_pm_ops structures.
    
    dev_pm_ops are not supposed to change at runtime. All functions
    working with dev_pm_ops provided by <linux/device.h> work with const
    dev_pm_ops. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
       8172     920       0    9092    2384 sound/soc/sh/rcar/core.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
       8364     728       0    9092    2384 sound/soc/sh/rcar/core.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 409bac331d27..3f2ced26ed37 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1534,7 +1534,7 @@ static int rsnd_resume(struct device *dev)
 	return 0;
 }
 
-static struct dev_pm_ops rsnd_pm_ops = {
+static const struct dev_pm_ops rsnd_pm_ops = {
 	.suspend		= rsnd_suspend,
 	.resume			= rsnd_resume,
 };

commit 947f4eb58d2054b10a1d8146d0ab90b0e7fd3494
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jun 16 00:02:59 2017 +0000

    ASoC: rsnd: fixup unsigned expression compared with zero: main_rate
    
    This patch fixes this WARNING
    
    sound/soc/sh/rcar/ssi.c:285:5-14: WARNING: Unsigned expression\
            compared with zero: main_rate < 0
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 4892c0a4b613..409bac331d27 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -763,7 +763,7 @@ static int rsnd_soc_hw_rule(struct rsnd_priv *priv,
 			    struct snd_interval *baseline, struct snd_interval *iv)
 {
 	struct snd_interval p;
-	int rate;
+	unsigned int rate;
 	int i;
 
 	snd_interval_any(&p);

commit 8cc03722403a5153054993388857e4e565dcdfb1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jun 15 00:50:19 2017 +0000

    ASoC: rsnd: add rsnd_soc_hw_rule/constraint()
    
    Current Renesas sound driver is assuming that all Sampling rate and
    channles are possible to use, but these are depends on inputed clock
    and SSI connection situation.
    For example, if it is using 1 SSI, enabled TDM mode and has 12288000
    input clock, 2ch output can support until 192000Hz, but 6ch output can
    support until 64000Hz, 8ch can support 48000Hz.
    To control these situation correctly, it needs to support
    hw_constraints / refine feature.
    
    To support such feature, this patch adds new
    rsnd_soc_hw_rule/constraint() which adds hw rule of Channel and
    Sampling Rate.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 9b9e898d0df3..4892c0a4b613 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -723,7 +723,10 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 	struct device *dev = rsnd_priv_to_dev(priv);
 
 	switch (slots) {
+	case 2:
 	case 6:
+	case 8:
+	case 16:
 		/* TDM Extend Mode */
 		rsnd_rdai_channels_set(rdai, slots);
 		rsnd_rdai_ssi_lane_set(rdai, 1);
@@ -736,6 +739,151 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 	return 0;
 }
 
+static unsigned int rsnd_soc_hw_channels_list[] = {
+	2, 6, 8, 16,
+};
+
+static unsigned int rsnd_soc_hw_rate_list[] = {
+	  8000,
+	 11025,
+	 16000,
+	 22050,
+	 32000,
+	 44100,
+	 48000,
+	 64000,
+	 88200,
+	 96000,
+	176400,
+	192000,
+};
+
+static int rsnd_soc_hw_rule(struct rsnd_priv *priv,
+			    unsigned int *list, int list_num,
+			    struct snd_interval *baseline, struct snd_interval *iv)
+{
+	struct snd_interval p;
+	int rate;
+	int i;
+
+	snd_interval_any(&p);
+	p.min = UINT_MAX;
+	p.max = 0;
+
+	for (i = 0; i < list_num; i++) {
+
+		if (!snd_interval_test(iv, list[i]))
+			continue;
+
+		rate = rsnd_ssi_clk_query(priv,
+					  baseline->min, list[i], NULL);
+		if (rate > 0) {
+			p.min = min(p.min, list[i]);
+			p.max = max(p.max, list[i]);
+		}
+
+		rate = rsnd_ssi_clk_query(priv,
+					  baseline->max, list[i], NULL);
+		if (rate > 0) {
+			p.min = min(p.min, list[i]);
+			p.max = max(p.max, list[i]);
+		}
+	}
+
+	return snd_interval_refine(iv, &p);
+}
+
+static int rsnd_soc_hw_rule_rate(struct snd_pcm_hw_params *params,
+				 struct snd_pcm_hw_rule *rule)
+{
+	struct snd_interval *ic_ = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *ir = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval ic;
+	struct snd_soc_dai *dai = rule->private;
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
+
+	/*
+	 * possible sampling rate limitation is same as
+	 * 2ch if it supports multi ssi
+	 */
+	ic = *ic_;
+	if (1 < rsnd_rdai_ssi_lane_get(rdai)) {
+		ic.min = 2;
+		ic.max = 2;
+	}
+
+	return rsnd_soc_hw_rule(priv, rsnd_soc_hw_rate_list,
+				ARRAY_SIZE(rsnd_soc_hw_rate_list),
+				&ic, ir);
+}
+
+
+static int rsnd_soc_hw_rule_channels(struct snd_pcm_hw_params *params,
+				     struct snd_pcm_hw_rule *rule)
+{
+	struct snd_interval *ic_ = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *ir = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval ic;
+	struct snd_soc_dai *dai = rule->private;
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
+
+	/*
+	 * possible sampling rate limitation is same as
+	 * 2ch if it supports multi ssi
+	 */
+	ic = *ic_;
+	if (1 < rsnd_rdai_ssi_lane_get(rdai)) {
+		ic.min = 2;
+		ic.max = 2;
+	}
+
+	return rsnd_soc_hw_rule(priv, rsnd_soc_hw_channels_list,
+				ARRAY_SIZE(rsnd_soc_hw_channels_list),
+				ir, &ic);
+}
+
+static void rsnd_soc_hw_constraint(struct snd_pcm_runtime *runtime,
+				   struct snd_soc_dai *dai)
+{
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct snd_pcm_hw_constraint_list *constraint = &rdai->constraint;
+	unsigned int max_channels = rsnd_rdai_channels_get(rdai);
+	int i;
+
+	/*
+	 * Channel Limitation
+	 * It depends on Platform design
+	 */
+	constraint->list	= rsnd_soc_hw_channels_list;
+	constraint->count	= 0;
+	constraint->mask	= 0;
+
+	for (i = 0; i < ARRAY_SIZE(rsnd_soc_hw_channels_list); i++) {
+		if (rsnd_soc_hw_channels_list[i] > max_channels)
+			break;
+		constraint->count = i + 1;
+	}
+
+	snd_pcm_hw_constraint_list(runtime, 0,
+				   SNDRV_PCM_HW_PARAM_CHANNELS, constraint);
+
+	/*
+	 * Sampling Rate / Channel Limitation
+	 * It depends on Clock Master Mode
+	 */
+	if (!rsnd_rdai_is_clk_master(rdai))
+		return;
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			    rsnd_soc_hw_rule_rate, dai,
+			    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			    rsnd_soc_hw_rule_channels, dai,
+			    SNDRV_PCM_HW_PARAM_RATE, -1);
+}
+
 static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
@@ -744,6 +892,9 @@ static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
 	int ret;
 
+	/* rsnd_io_to_runtime() is not yet enabled here */
+	rsnd_soc_hw_constraint(substream->runtime, dai);
+
 	/*
 	 * call rsnd_dai_call without spinlock
 	 */
@@ -866,7 +1017,7 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 	drv->playback.rates		= RSND_RATES;
 	drv->playback.formats		= RSND_FMTS;
 	drv->playback.channels_min	= 2;
-	drv->playback.channels_max	= 6;
+	drv->playback.channels_max	= 16;
 	drv->playback.stream_name	= rdai->playback.name;
 
 	snprintf(rdai->capture.name, RSND_DAI_NAME_SIZE,
@@ -874,7 +1025,7 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 	drv->capture.rates		= RSND_RATES;
 	drv->capture.formats		= RSND_FMTS;
 	drv->capture.channels_min	= 2;
-	drv->capture.channels_max	= 6;
+	drv->capture.channels_max	= 16;
 	drv->capture.stream_name	= rdai->capture.name;
 
 	rdai->playback.rdai		= rdai;

commit 1ff9593d2f27a48fbeeccd7fc253eed2a7102d16
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jun 15 00:49:27 2017 +0000

    ASoC: rsnd: rename "slots" related variable
    
    Current Renesas sound driver has slots and slots_num in
    struct rsnd_dai, but these are very un-understandable naming
    (It had named from TDM slots).
    In this driver, the "slots" means total usable channels, and
    "stot_num" means SSI lane number if Multi SSI was used.
    To more understandable code, this patch renames "slots" to
    "max_channels", and "slots_num" to "ssi_lane", and replaces related
    functions name.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1b536d140e49..9b9e898d0df3 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -203,27 +203,6 @@ int rsnd_io_is_working(struct rsnd_dai_stream *io)
 	return !!io->substream;
 }
 
-void rsnd_set_slot(struct rsnd_dai *rdai,
-		   int slots, int num)
-{
-	rdai->slots	= slots;
-	rdai->slots_num	= num;
-}
-
-int rsnd_get_slot(struct rsnd_dai_stream *io)
-{
-	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
-
-	return rdai->slots;
-}
-
-int rsnd_get_slot_num(struct rsnd_dai_stream *io)
-{
-	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
-
-	return rdai->slots_num;
-}
-
 int rsnd_runtime_channel_original(struct rsnd_dai_stream *io)
 {
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
@@ -248,13 +227,14 @@ int rsnd_runtime_channel_after_ctu(struct rsnd_dai_stream *io)
 
 int rsnd_runtime_channel_for_ssi(struct rsnd_dai_stream *io)
 {
+	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
 	int chan = rsnd_io_is_play(io) ?
 		rsnd_runtime_channel_after_ctu(io) :
 		rsnd_runtime_channel_original(io);
 
 	/* Use Multi SSI */
 	if (rsnd_runtime_is_ssi_multi(io))
-		chan /= rsnd_get_slot_num(io);
+		chan /= rsnd_rdai_ssi_lane_get(rdai);
 
 	/* TDM Extend Mode needs 8ch */
 	if (chan == 6)
@@ -265,12 +245,13 @@ int rsnd_runtime_channel_for_ssi(struct rsnd_dai_stream *io)
 
 int rsnd_runtime_is_ssi_multi(struct rsnd_dai_stream *io)
 {
-	int slots = rsnd_get_slot_num(io);
+	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
+	int lane = rsnd_rdai_ssi_lane_get(rdai);
 	int chan = rsnd_io_is_play(io) ?
 		rsnd_runtime_channel_after_ctu(io) :
 		rsnd_runtime_channel_original(io);
 
-	return (chan >= 6) && (slots > 1);
+	return (chan > 2) && (lane > 1);
 }
 
 int rsnd_runtime_is_ssi_tdm(struct rsnd_dai_stream *io)
@@ -549,6 +530,24 @@ static void rsnd_dai_disconnect(struct rsnd_mod *mod,
 	io->mod[type] = NULL;
 }
 
+int rsnd_rdai_channels_ctrl(struct rsnd_dai *rdai,
+			    int max_channels)
+{
+	if (max_channels > 0)
+		rdai->max_channels = max_channels;
+
+	return rdai->max_channels;
+}
+
+int rsnd_rdai_ssi_lane_ctrl(struct rsnd_dai *rdai,
+			    int ssi_lane)
+{
+	if (ssi_lane > 0)
+		rdai->ssi_lane = ssi_lane;
+
+	return rdai->ssi_lane;
+}
+
 struct rsnd_dai *rsnd_rdai_get(struct rsnd_priv *priv, int id)
 {
 	if ((id < 0) || (id >= rsnd_rdai_nr(priv)))
@@ -726,7 +725,8 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 	switch (slots) {
 	case 6:
 		/* TDM Extend Mode */
-		rsnd_set_slot(rdai, slots, 1);
+		rsnd_rdai_channels_set(rdai, slots);
+		rsnd_rdai_ssi_lane_set(rdai, 1);
 		break;
 	default:
 		dev_err(dev, "unsupported TDM slots (%d)\n", slots);
@@ -879,7 +879,8 @@ static void __rsnd_dai_probe(struct rsnd_priv *priv,
 
 	rdai->playback.rdai		= rdai;
 	rdai->capture.rdai		= rdai;
-	rsnd_set_slot(rdai, 2, 1); /* default */
+	rsnd_rdai_channels_set(rdai, 2); /* default 2ch */
+	rsnd_rdai_ssi_lane_set(rdai, 1); /* default 1lane */
 
 	for (io_i = 0;; io_i++) {
 		playback = of_parse_phandle(dai_np, "playback", io_i);

commit f30b4ca4447095f6923b59ffaa25ca6a54daffac
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 14 07:41:43 2017 +0000

    ASoC: rsnd: reduce confusable macro parameter magic
    
    rsnd_dai_call() macro is using "priv" inside.
    Thus, if caller function doesn't have "priv" related operation, strange
    phenomenon occur which code is using "priv", but compiler indicates
    "unused variable 'priv'".
    
    >From code point of view, it is not problem, but it is very confusable.
    This patch removes "priv" from rsnd_dai_call() macro, and adds "priv"
    on caller function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 0bb99aa70e29..1b536d140e49 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -488,8 +488,7 @@ static int rsnd_status_update(u32 *status,
 
 #define rsnd_dai_call(fn, io, param...)					\
 ({									\
-	struct rsnd_priv *priv = rsnd_io_to_priv(io);			\
-	struct device *dev = rsnd_priv_to_dev(priv);			\
+	struct device *dev = rsnd_priv_to_dev(rsnd_io_to_priv(io));	\
 	struct rsnd_mod *mod;						\
 	int is_play = rsnd_io_is_play(io);				\
 	int ret = 0, i;							\
@@ -741,6 +740,7 @@ static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
 	int ret;
 
@@ -758,6 +758,7 @@ static void rsnd_soc_dai_shutdown(struct snd_pcm_substream *substream,
 				  struct snd_soc_dai *dai)
 {
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
 
 	/*

commit f0b04d8b442757f7bcad2cd07b54f63910253ebc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 7 00:11:48 2017 +0000

    ASoC: rsnd: control kctrl items acceptance anytime/runtime
    
    Current SRC/DVC/CTU adds kctrl for each device,
    and SRC can adjust its sampling rate during playback,
    thus, this feature should be enabled only *during* playback.
    This patch controls it more clearly
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1bf261d677b7..0bb99aa70e29 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1065,6 +1065,9 @@ static int rsnd_kctrl_put(struct snd_kcontrol *kctrl,
 	struct rsnd_kctrl_cfg *cfg = kcontrol_to_cfg(kctrl);
 	int i, change = 0;
 
+	if (!cfg->accept(cfg->io))
+		return 0;
+
 	for (i = 0; i < cfg->size; i++) {
 		if (cfg->texts) {
 			change |= (uc->value.enumerated.item[i] != cfg->val[i]);
@@ -1081,6 +1084,18 @@ static int rsnd_kctrl_put(struct snd_kcontrol *kctrl,
 	return change;
 }
 
+int rsnd_kctrl_accept_anytime(struct rsnd_dai_stream *io)
+{
+	return 1;
+}
+
+int rsnd_kctrl_accept_runtime(struct rsnd_dai_stream *io)
+{
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+
+	return !!runtime;
+}
+
 struct rsnd_kctrl_cfg *rsnd_kctrl_init_m(struct rsnd_kctrl_cfg_m *cfg)
 {
 	cfg->cfg.val = cfg->val;
@@ -1099,6 +1114,7 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
 		   struct rsnd_dai_stream *io,
 		   struct snd_soc_pcm_runtime *rtd,
 		   const unsigned char *name,
+		   int (*accept)(struct rsnd_dai_stream *io),
 		   void (*update)(struct rsnd_dai_stream *io,
 				  struct rsnd_mod *mod),
 		   struct rsnd_kctrl_cfg *cfg,
@@ -1133,6 +1149,7 @@ int rsnd_kctrl_new(struct rsnd_mod *mod,
 	cfg->texts	= texts;
 	cfg->max	= max;
 	cfg->size	= size;
+	cfg->accept	= accept;
 	cfg->update	= update;
 	cfg->card	= card;
 	cfg->kctrl	= kctrl;

commit 8cce431aa26ef24a4d4b820301ac73bf55df7a5e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jun 9 00:34:09 2017 +0000

    ASoC: rsnd: add detail explanation of L/R conversion timing
    
    Renesas Sound device *Hardware* L/R and Linux *Software* L/R are
    inverted. Because of this background, it needs to convert L/R.
    Then, DVC needs *Hardware* L/R, and Linux needs *Software* L/R.
    Because Playback/Capture needs different timing, and there is no
    explanation about it on source code / git log, this patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7c68f9d4a0ed..1bf261d677b7 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -310,6 +310,24 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	u32 val = 0x76543210;
 	u32 mask = ~0;
 
+	/*
+	 * *Hardware* L/R and *Software* L/R are inverted.
+	 * We need to care about inversion timing to control
+	 * Playback/Capture correctly.
+	 * The point is [DVC] needs *Hardware* L/R, [MEM] needs *Software* L/R
+	 *
+	 * sL/R : software L/R
+	 * hL/R : hardware L/R
+	 * (*)  : conversion timing
+	 *
+	 * Playback
+	 *	     sL/R (*) hL/R     hL/R     hL/R      hL/R     hL/R
+	 *	[MEM] -> [SRC] -> [DVC] -> [CMD] -> [SSIU] -> [SSI] -> codec
+	 *
+	 * Capture
+	 *	     hL/R     hL/R      hL/R     hL/R     hL/R (*) sL/R
+	 *	codec -> [SSI] -> [SSIU] -> [SRC] -> [DVC] -> [CMD] -> [MEM]
+	 */
 	if (rsnd_io_is_play(io)) {
 		struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 

commit a97a06c7efc1ee34f500171f1c4e9608295bb79a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 7 00:20:47 2017 +0000

    ASoC: rsnd: cleanup pointer related code
    
    Current rsnd driver is sharing pointer related code between
    PIO / DMA. But, it is used only PIO mode now, no longer needed.
    This patch cleanup these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7a8c08933503..7c68f9d4a0ed 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -551,40 +551,6 @@ static struct rsnd_dai *rsnd_dai_to_rdai(struct snd_soc_dai *dai)
 /*
  *	rsnd_soc_dai functions
  */
-int rsnd_dai_pointer_offset(struct rsnd_dai_stream *io, int additional)
-{
-	struct snd_pcm_substream *substream = io->substream;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int pos = io->byte_pos + additional;
-
-	pos %= (runtime->periods * io->byte_per_period);
-
-	return pos;
-}
-
-bool rsnd_dai_pointer_update(struct rsnd_dai_stream *io, int byte)
-{
-	io->byte_pos += byte;
-
-	if (io->byte_pos >= io->next_period_byte) {
-		struct snd_pcm_substream *substream = io->substream;
-		struct snd_pcm_runtime *runtime = substream->runtime;
-
-		io->period_pos++;
-		io->next_period_byte += io->byte_per_period;
-
-		if (io->period_pos >= runtime->periods) {
-			io->byte_pos = 0;
-			io->period_pos = 0;
-			io->next_period_byte = io->byte_per_period;
-		}
-
-		return true;
-	}
-
-	return false;
-}
-
 void rsnd_dai_period_elapsed(struct rsnd_dai_stream *io)
 {
 	struct snd_pcm_substream *substream = io->substream;
@@ -602,15 +568,7 @@ void rsnd_dai_period_elapsed(struct rsnd_dai_stream *io)
 static void rsnd_dai_stream_init(struct rsnd_dai_stream *io,
 				struct snd_pcm_substream *substream)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
 	io->substream		= substream;
-	io->byte_pos		= 0;
-	io->period_pos		= 0;
-	io->byte_per_period	= runtime->period_size *
-				  runtime->channels *
-				  samples_to_bytes(runtime, 1);
-	io->next_period_byte	= io->byte_per_period;
 }
 
 static void rsnd_dai_stream_quit(struct rsnd_dai_stream *io)

commit 9bc3b4ff18d130da09ad608718d4afcda01b3e56
Merge: 07b7acb51d28 e8a3ce113013
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Jun 7 20:30:32 2017 +0100

    Merge branch 'fix/rcar' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-rcar

commit 07b7acb51d283d8469696c906b91f1882696a4d4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 7 00:20:01 2017 +0000

    ASoC: rsnd: update pointer more accurate
    
    Current rsnd driver updates pointer when DMA transfer was finished
    in DMA transfer mode. But PulseAudio requests more accurate
    pointer update when timer mode.
    This patch consider about DMA transfer residue and update more
    accurate pointer.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 080431543141..bc12c449857a 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -968,12 +968,14 @@ static int rsnd_hw_params(struct snd_pcm_substream *substream,
 
 static snd_pcm_uframes_t rsnd_pointer(struct snd_pcm_substream *substream)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+	snd_pcm_uframes_t pointer = 0;
+
+	rsnd_dai_call(pointer, io, &pointer);
 
-	return bytes_to_frames(runtime, io->byte_pos);
+	return pointer;
 }
 
 static struct snd_pcm_ops rsnd_pcm_ops = {

commit 7fa72cca39a042228965a578b9249216082591e0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 18 01:28:22 2017 +0000

    ASoC: rsnd: add HDMI output support
    
    Renesas R-Car Gen3 can output HDMI sound if SSIU/SSI are connected to
    R-Car built-in HDMI device (R-Car Gen3 built-in HDMI device will be
    controlled by DRM/KMS driver).
    If SSIx was connected to HDMI0/1 on DT, SSI driver will detect it
    automatically by this patch.
    Note is that now Renesas R-Car sound driver is assuming that it is
    using OF-graph base simple card for HDMI sound.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 41b2e782b0bf..080431543141 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -909,8 +909,11 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 	 */
 	dai_i = 0;
 	if (is_graph) {
-		for_each_endpoint_of_node(dai_node, dai_np)
-			__rsnd_dai_probe(priv, dai_np, dai_i++, is_graph);
+		for_each_endpoint_of_node(dai_node, dai_np) {
+			__rsnd_dai_probe(priv, dai_np, dai_i, is_graph);
+			rsnd_ssi_parse_hdmi_connection(priv, dai_np, dai_i);
+			dai_i++;
+		}
 	} else {
 		for_each_child_of_node(dai_node, dai_np)
 			__rsnd_dai_probe(priv, dai_np, dai_i++, is_graph);

commit 4d4b334bda47f1b7b57f7aca9bc19b7e317d764d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 18 01:28:06 2017 +0000

    ASoC: rsnd: add support graph base DT phase 2
    
    To enable OF-graph base DT on rsnd driver, and to keep compatible
    previous normal sound card style, it need to support both
    "rcar_sound,dai" and "ports" (or "port") on DT.
    
    This patch parses both style.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 72a3139b70c3..41b2e782b0bf 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -810,33 +810,95 @@ static struct device_node *rsnd_dai_of_node(struct rsnd_priv *priv,
 	return ret;
 }
 
-static int rsnd_dai_probe(struct rsnd_priv *priv)
+static void __rsnd_dai_probe(struct rsnd_priv *priv,
+			     struct device_node *dai_np,
+			     int dai_i, int is_graph)
 {
-	struct device_node *dai_node;
-	struct device_node *dai_np;
 	struct device_node *playback, *capture;
 	struct rsnd_dai_stream *io_playback;
 	struct rsnd_dai_stream *io_capture;
-	struct snd_soc_dai_driver *rdrv, *drv;
+	struct snd_soc_dai_driver *drv;
 	struct rsnd_dai *rdai;
 	struct device *dev = rsnd_priv_to_dev(priv);
-	int nr, dai_i, io_i;
+	int io_i;
+
+	rdai		= rsnd_rdai_get(priv, dai_i);
+	drv		= priv->daidrv + dai_i;
+	io_playback	= &rdai->playback;
+	io_capture	= &rdai->capture;
+
+	snprintf(rdai->name, RSND_DAI_NAME_SIZE, "rsnd-dai.%d", dai_i);
+
+	rdai->priv	= priv;
+	drv->name	= rdai->name;
+	drv->ops	= &rsnd_soc_dai_ops;
+
+	snprintf(rdai->playback.name, RSND_DAI_NAME_SIZE,
+		 "DAI%d Playback", dai_i);
+	drv->playback.rates		= RSND_RATES;
+	drv->playback.formats		= RSND_FMTS;
+	drv->playback.channels_min	= 2;
+	drv->playback.channels_max	= 6;
+	drv->playback.stream_name	= rdai->playback.name;
+
+	snprintf(rdai->capture.name, RSND_DAI_NAME_SIZE,
+		 "DAI%d Capture", dai_i);
+	drv->capture.rates		= RSND_RATES;
+	drv->capture.formats		= RSND_FMTS;
+	drv->capture.channels_min	= 2;
+	drv->capture.channels_max	= 6;
+	drv->capture.stream_name	= rdai->capture.name;
+
+	rdai->playback.rdai		= rdai;
+	rdai->capture.rdai		= rdai;
+	rsnd_set_slot(rdai, 2, 1); /* default */
+
+	for (io_i = 0;; io_i++) {
+		playback = of_parse_phandle(dai_np, "playback", io_i);
+		capture  = of_parse_phandle(dai_np, "capture", io_i);
+
+		if (!playback && !capture)
+			break;
+
+		rsnd_parse_connect_ssi(rdai, playback, capture);
+		rsnd_parse_connect_src(rdai, playback, capture);
+		rsnd_parse_connect_ctu(rdai, playback, capture);
+		rsnd_parse_connect_mix(rdai, playback, capture);
+		rsnd_parse_connect_dvc(rdai, playback, capture);
+
+		of_node_put(playback);
+		of_node_put(capture);
+	}
+
+	dev_dbg(dev, "%s (%s/%s)\n", rdai->name,
+		rsnd_io_to_mod_ssi(io_playback) ? "play"    : " -- ",
+		rsnd_io_to_mod_ssi(io_capture) ? "capture" : "  --   ");
+}
+
+static int rsnd_dai_probe(struct rsnd_priv *priv)
+{
+	struct device_node *dai_node;
+	struct device_node *dai_np;
+	struct snd_soc_dai_driver *rdrv;
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_dai *rdai;
+	int nr;
 	int is_graph;
-	int ret;
+	int dai_i;
 
 	dai_node = rsnd_dai_of_node(priv, &is_graph);
-	nr = of_get_child_count(dai_node);
-	if (!nr) {
-		ret = -EINVAL;
-		goto rsnd_dai_probe_done;
-	}
+	if (is_graph)
+		nr = of_graph_get_endpoint_count(dai_node);
+	else
+		nr = of_get_child_count(dai_node);
+
+	if (!nr)
+		return -EINVAL;
 
 	rdrv = devm_kzalloc(dev, sizeof(*rdrv) * nr, GFP_KERNEL);
 	rdai = devm_kzalloc(dev, sizeof(*rdai) * nr, GFP_KERNEL);
-	if (!rdrv || !rdai) {
-		ret = -ENOMEM;
-		goto rsnd_dai_probe_done;
-	}
+	if (!rdrv || !rdai)
+		return -ENOMEM;
 
 	priv->rdai_nr	= nr;
 	priv->daidrv	= rdrv;
@@ -846,68 +908,15 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 	 * parse all dai
 	 */
 	dai_i = 0;
-	for_each_child_of_node(dai_node, dai_np) {
-		rdai		= rsnd_rdai_get(priv, dai_i);
-		drv		= rdrv + dai_i;
-		io_playback	= &rdai->playback;
-		io_capture	= &rdai->capture;
-
-		snprintf(rdai->name, RSND_DAI_NAME_SIZE, "rsnd-dai.%d", dai_i);
-
-		rdai->priv	= priv;
-		drv->name	= rdai->name;
-		drv->ops	= &rsnd_soc_dai_ops;
-
-		snprintf(rdai->playback.name, RSND_DAI_NAME_SIZE,
-			 "DAI%d Playback", dai_i);
-		drv->playback.rates		= RSND_RATES;
-		drv->playback.formats		= RSND_FMTS;
-		drv->playback.channels_min	= 2;
-		drv->playback.channels_max	= 6;
-		drv->playback.stream_name	= rdai->playback.name;
-
-		snprintf(rdai->capture.name, RSND_DAI_NAME_SIZE,
-			 "DAI%d Capture", dai_i);
-		drv->capture.rates		= RSND_RATES;
-		drv->capture.formats		= RSND_FMTS;
-		drv->capture.channels_min	= 2;
-		drv->capture.channels_max	= 6;
-		drv->capture.stream_name	= rdai->capture.name;
-
-		rdai->playback.rdai		= rdai;
-		rdai->capture.rdai		= rdai;
-		rsnd_set_slot(rdai, 2, 1); /* default */
-
-		for (io_i = 0;; io_i++) {
-			playback = of_parse_phandle(dai_np, "playback", io_i);
-			capture  = of_parse_phandle(dai_np, "capture", io_i);
-
-			if (!playback && !capture)
-				break;
-
-			rsnd_parse_connect_ssi(rdai, playback, capture);
-			rsnd_parse_connect_src(rdai, playback, capture);
-			rsnd_parse_connect_ctu(rdai, playback, capture);
-			rsnd_parse_connect_mix(rdai, playback, capture);
-			rsnd_parse_connect_dvc(rdai, playback, capture);
-
-			of_node_put(playback);
-			of_node_put(capture);
-		}
-
-		dai_i++;
-
-		dev_dbg(dev, "%s (%s/%s)\n", rdai->name,
-			rsnd_io_to_mod_ssi(io_playback) ? "play"    : " -- ",
-			rsnd_io_to_mod_ssi(io_capture) ? "capture" : "  --   ");
+	if (is_graph) {
+		for_each_endpoint_of_node(dai_node, dai_np)
+			__rsnd_dai_probe(priv, dai_np, dai_i++, is_graph);
+	} else {
+		for_each_child_of_node(dai_node, dai_np)
+			__rsnd_dai_probe(priv, dai_np, dai_i++, is_graph);
 	}
 
-	ret = 0;
-
-rsnd_dai_probe_done:
-	of_node_put(dai_node);
-
-	return ret;
+	return 0;
 }
 
 /*

commit 11d0f8ed6dc3e553b20329bc85f2a1aefb5f180f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 18 01:27:48 2017 +0000

    ASoC: rsnd: add support graph base DT phase 1
    
    To enable OF-graph base DT on rsnd driver, and to keep compatible
    previous normal sound card style, it need to support both
    "rcar_sound,dai" and "ports" (or "port") on DT.
    
    This patch modify rsnd_dai_of_node() to parse
    "rcar_sound,dai" and "ports" (or "port") as phase 1. It can detect
    graph base style, but do nothing at this point.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3c47af1990cb..72a3139b70c3 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -774,6 +774,42 @@ void rsnd_parse_connect_common(struct rsnd_dai *rdai,
 	of_node_put(node);
 }
 
+static struct device_node *rsnd_dai_of_node(struct rsnd_priv *priv,
+					    int *is_graph)
+{
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct device_node *np = dev->of_node;
+	struct device_node *dai_node;
+	struct device_node *ret;
+
+	*is_graph = 0;
+
+	/*
+	 * parse both previous dai (= rcar_sound,dai), and
+	 * graph dai (= ports/port)
+	 */
+	dai_node = of_get_child_by_name(np, RSND_NODE_DAI);
+	if (dai_node) {
+		ret = dai_node;
+		goto of_node_compatible;
+	}
+
+	ret = np;
+
+	dai_node = of_graph_get_next_endpoint(np, NULL);
+	if (dai_node)
+		goto of_node_graph;
+
+	return NULL;
+
+of_node_graph:
+	*is_graph = 1;
+of_node_compatible:
+	of_node_put(dai_node);
+
+	return ret;
+}
+
 static int rsnd_dai_probe(struct rsnd_priv *priv)
 {
 	struct device_node *dai_node;
@@ -785,9 +821,10 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 	struct rsnd_dai *rdai;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	int nr, dai_i, io_i;
+	int is_graph;
 	int ret;
 
-	dai_node = rsnd_dai_of_node(priv);
+	dai_node = rsnd_dai_of_node(priv, &is_graph);
 	nr = of_get_child_count(dai_node);
 	if (!nr) {
 		ret = -EINVAL;

commit 90431eb49bff6d79814cbf0c96e13597ad53095c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 16 01:51:41 2017 +0000

    ASoC: rsnd: don't use PDTA bit for 24bit on SSI
    
    Current SSI uses PDTA bit which indicates data that Input/Output
    data are Right-Aligned. But, 24bit sound should be Left-Aligned
    in this HW. Because Linux is using Right-Aligned data, and HW uses
    Left-Aligned data, current 24bit data is missing lower 8bit.
    To fix this issue, this patch removes PDTA bit, and shift 8bit
    in necessary module
    
    Reported-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1744015408c3..8c1f4e2e0c4f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -343,6 +343,57 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 		return 0x76543210;
 }
 
+u32 rsnd_get_busif_shift(struct rsnd_dai_stream *io, struct rsnd_mod *mod)
+{
+	enum rsnd_mod_type playback_mods[] = {
+		RSND_MOD_SRC,
+		RSND_MOD_CMD,
+		RSND_MOD_SSIU,
+	};
+	enum rsnd_mod_type capture_mods[] = {
+		RSND_MOD_CMD,
+		RSND_MOD_SRC,
+		RSND_MOD_SSIU,
+	};
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	struct rsnd_mod *tmod = NULL;
+	enum rsnd_mod_type *mods =
+		rsnd_io_is_play(io) ?
+		playback_mods : capture_mods;
+	int i;
+
+	/*
+	 * This is needed for 24bit data
+	 * We need to shift 8bit
+	 *
+	 * Linux 24bit data is located as 0x00******
+	 * HW    24bit data is located as 0x******00
+	 *
+	 */
+	switch (runtime->sample_bits) {
+	case 16:
+		return 0;
+	case 32:
+		break;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(playback_mods); i++) {
+		tmod = rsnd_io_to_mod(io, mods[i]);
+		if (tmod)
+			break;
+	}
+
+	if (tmod != mod)
+		return 0;
+
+	if (rsnd_io_is_play(io))
+		return  (0 << 20) | /* shift to Left */
+			(8 << 16);  /* 8bit */
+	else
+		return  (1 << 20) | /* shift to Right */
+			(8 << 16);  /* 8bit */
+}
+
 /*
  *	rsnd_dai functions
  */

commit 2adcea7e22d382e2becf5671e92296f79672b957
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed May 17 07:59:20 2017 +0000

    ASoC: rsnd: need to call nolock_stop if nolock_start was failed
    
    rsnd_dai_call() is counting the called number of start/stop functions.
    nolock_stop should be called if nolock_start was failed.
    Otherwise, nolock_start doesn't called in 2nd play.
    This patch solved this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reported-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1744015408c3..3c47af1990cb 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -715,11 +715,16 @@ static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
 {
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+	int ret;
 
 	/*
 	 * call rsnd_dai_call without spinlock
 	 */
-	return rsnd_dai_call(nolock_start, io, priv);
+	ret = rsnd_dai_call(nolock_start, io, priv);
+	if (ret < 0)
+		rsnd_dai_call(nolock_stop, io, priv);
+
+	return ret;
 }
 
 static void rsnd_soc_dai_shutdown(struct snd_pcm_substream *substream,

commit 9ca5e57d78446c8bd42adff3dcae693703f91d9c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Apr 19 00:41:24 2017 +0000

    ASoC: rsnd: rsnd_mod_make_sure() is not under DEBUG
    
    rsnd_mod_make_sure() will be used any situation,
    thus, under DEBUG is not realistic.
    This patch move it to non DEBUG area
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f8eb9d3d1949..1744015408c3 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -110,7 +110,6 @@ MODULE_DEVICE_TABLE(of, rsnd_of_match);
 /*
  *	rsnd_mod functions
  */
-#ifdef DEBUG
 void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
 {
 	if (mod->type != type) {
@@ -121,7 +120,6 @@ void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
 			 rsnd_mod_name(mod), rsnd_mod_id(mod));
 	}
 }
-#endif
 
 char *rsnd_mod_name(struct rsnd_mod *mod)
 {

commit 32973dcf71ebee8806a6ee552665c5fad6857e16
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Apr 6 07:25:13 2017 +0000

    ASoC: rsnd: merge rsnd_kctrl_new_m/s/e into rsnd_kctrl_new()
    
    Current rsnd driver is using rsnd_kctrl_new_m/s/e function,
    but the differences are very few.
    This patch merge these rsnd_kctrl_new_m/s/e into rsnd_kctrl_new
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 35c96e4bbd64..f8eb9d3d1949 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1000,13 +1000,30 @@ static int rsnd_kctrl_put(struct snd_kcontrol *kctrl,
 	return change;
 }
 
-static int __rsnd_kctrl_new(struct rsnd_mod *mod,
-			    struct rsnd_dai_stream *io,
-			    struct snd_soc_pcm_runtime *rtd,
-			    const unsigned char *name,
-			    struct rsnd_kctrl_cfg *cfg,
-			    void (*update)(struct rsnd_dai_stream *io,
-					   struct rsnd_mod *mod))
+struct rsnd_kctrl_cfg *rsnd_kctrl_init_m(struct rsnd_kctrl_cfg_m *cfg)
+{
+	cfg->cfg.val = cfg->val;
+
+	return &cfg->cfg;
+}
+
+struct rsnd_kctrl_cfg *rsnd_kctrl_init_s(struct rsnd_kctrl_cfg_s *cfg)
+{
+	cfg->cfg.val = &cfg->val;
+
+	return &cfg->cfg;
+}
+
+int rsnd_kctrl_new(struct rsnd_mod *mod,
+		   struct rsnd_dai_stream *io,
+		   struct snd_soc_pcm_runtime *rtd,
+		   const unsigned char *name,
+		   void (*update)(struct rsnd_dai_stream *io,
+				  struct rsnd_mod *mod),
+		   struct rsnd_kctrl_cfg *cfg,
+		   const char * const *texts,
+		   int size,
+		   u32 max)
 {
 	struct snd_card *card = rtd->card->snd_card;
 	struct snd_kcontrol *kctrl;
@@ -1021,6 +1038,9 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 	};
 	int ret;
 
+	if (size > RSND_MAX_CHANNELS)
+		return -EINVAL;
+
 	kctrl = snd_ctl_new1(&knew, mod);
 	if (!kctrl)
 		return -ENOMEM;
@@ -1029,65 +1049,17 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 	if (ret < 0)
 		return ret;
 
-	cfg->update = update;
-	cfg->card = card;
-	cfg->kctrl = kctrl;
-	cfg->io = io;
+	cfg->texts	= texts;
+	cfg->max	= max;
+	cfg->size	= size;
+	cfg->update	= update;
+	cfg->card	= card;
+	cfg->kctrl	= kctrl;
+	cfg->io		= io;
 
 	return 0;
 }
 
-int rsnd_kctrl_new_m(struct rsnd_mod *mod,
-		     struct rsnd_dai_stream *io,
-		     struct snd_soc_pcm_runtime *rtd,
-		     const unsigned char *name,
-		     void (*update)(struct rsnd_dai_stream *io,
-				    struct rsnd_mod *mod),
-		     struct rsnd_kctrl_cfg_m *_cfg,
-		     int ch_size,
-		     u32 max)
-{
-	if (ch_size > RSND_MAX_CHANNELS)
-		return -EINVAL;
-
-	_cfg->cfg.max	= max;
-	_cfg->cfg.size	= ch_size;
-	_cfg->cfg.val	= _cfg->val;
-	return __rsnd_kctrl_new(mod, io, rtd, name, &_cfg->cfg, update);
-}
-
-int rsnd_kctrl_new_s(struct rsnd_mod *mod,
-		     struct rsnd_dai_stream *io,
-		     struct snd_soc_pcm_runtime *rtd,
-		     const unsigned char *name,
-		     void (*update)(struct rsnd_dai_stream *io,
-				    struct rsnd_mod *mod),
-		     struct rsnd_kctrl_cfg_s *_cfg,
-		     u32 max)
-{
-	_cfg->cfg.max	= max;
-	_cfg->cfg.size	= 1;
-	_cfg->cfg.val	= &_cfg->val;
-	return __rsnd_kctrl_new(mod, io, rtd, name, &_cfg->cfg, update);
-}
-
-int rsnd_kctrl_new_e(struct rsnd_mod *mod,
-		     struct rsnd_dai_stream *io,
-		     struct snd_soc_pcm_runtime *rtd,
-		     const unsigned char *name,
-		     struct rsnd_kctrl_cfg_s *_cfg,
-		     void (*update)(struct rsnd_dai_stream *io,
-				    struct rsnd_mod *mod),
-		     const char * const *texts,
-		     u32 max)
-{
-	_cfg->cfg.max	= max;
-	_cfg->cfg.size	= 1;
-	_cfg->cfg.val	= &_cfg->val;
-	_cfg->cfg.texts	= texts;
-	return __rsnd_kctrl_new(mod, io, rtd, name, &_cfg->cfg, update);
-}
-
 /*
  *		snd_soc_platform
  */

commit 3a37471551cd3b287ce7f02ed25bcf8ec37a191d
Merge: e0c4211854bf fc99d23f6d3e
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Apr 6 11:50:04 2017 +0100

    Merge branch 'fix/rcar' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-rcar

commit e0c4211854bfebd5507761a2bfddaa9e37074230
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Mar 28 02:31:23 2017 +0000

    ASoC: rcar: remove rsnd_kctrl_remove()
    
    Current rcar driver is trying to remove kctrl when remove time.
    But, 1) rcar driver can't/shouldn't remove before removing sound
    card driver, 2) sound card driver will call snd_ctl_dev_free()
    and removes all kctrls by snd_ctl_remove().
    Thus, rsnd_kctrl_remove() is not necessary. Current implementation
    will get Oops when removing rcar driver after sound card.
    This patch fix this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3e852e00b277..134fe2ea4d9e 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1039,15 +1039,6 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 	return 0;
 }
 
-void _rsnd_kctrl_remove(struct rsnd_kctrl_cfg *cfg)
-{
-	if (cfg->card && cfg->kctrl)
-		snd_ctl_remove(cfg->card, cfg->kctrl);
-
-	cfg->card = NULL;
-	cfg->kctrl = NULL;
-}
-
 int rsnd_kctrl_new_m(struct rsnd_mod *mod,
 		     struct rsnd_dai_stream *io,
 		     struct snd_soc_pcm_runtime *rtd,

commit dc2721564f6da549f6eb29ac5bca28d65beadcb7
Author: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
Date:   Wed Mar 22 05:43:35 2017 +0000

    ASoC: rcar: enable PCM RATE untile 192000
    
    R-Car sound can handle untile 192000 rate.
    
    Signed-off-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 72966bdd3daa..3e852e00b277 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -96,7 +96,7 @@
 #include <linux/pm_runtime.h>
 #include "rsnd.h"
 
-#define RSND_RATES SNDRV_PCM_RATE_8000_96000
+#define RSND_RATES SNDRV_PCM_RATE_8000_192000
 #define RSND_FMTS (SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE)
 
 static const struct of_device_id rsnd_of_match[] = {

commit 34157f7bec8276b4296cf2ec172fc13385ac8af7
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon Feb 20 21:58:34 2017 +0100

    ASoC: rsnd: drop useles self-assignments
    
    Coverity reported (CID 1397992) this self-assignment. I think the code
    stays readable even with the assignments removed.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 948c5ec87980..72966bdd3daa 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -674,12 +674,10 @@ static int rsnd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	/* set clock inversion */
 	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
 	case SND_SOC_DAIFMT_NB_IF:
-		rdai->bit_clk_inv =  rdai->bit_clk_inv;
 		rdai->frm_clk_inv = !rdai->frm_clk_inv;
 		break;
 	case SND_SOC_DAIFMT_IB_NF:
 		rdai->bit_clk_inv = !rdai->bit_clk_inv;
-		rdai->frm_clk_inv =  rdai->frm_clk_inv;
 		break;
 	case SND_SOC_DAIFMT_IB_IF:
 		rdai->bit_clk_inv = !rdai->bit_clk_inv;

commit bd85d189b33bda263bc59602de86391f476a3093
Merge: 5bf3db18db32 ef30da1c52c6
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:35:36 2017 +0000

    Merge remote-tracking branch 'asoc/fix/rcar' into asoc-linus

commit 90ffc1ecc500c04bf43a45d804bb151505c0d6a6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 20 04:23:29 2017 +0000

    ASoC: rsnd: fixup for_each_rsnd_mod_array{s} iterator increment
    
    commit 5f222a292 ("ASoC: rsnd: use for_each_rsnd_mod_xxx() ...")
    modifies rsnd_dai_call() to use for_each_rsnd_mod_arrays().
    
    Current rsnd is incrementing iterator in rsnd_mod_next(),
    but the iterator will indicate +1 position in for_each loop in
    this case. Incremental position should be inside for()
    
    Reported-by: Hoan Nguyen An <na-hoan@jinso.co.jp>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 4bd68de76130..948c5ec87980 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -363,8 +363,6 @@ struct rsnd_mod *rsnd_mod_next(int *iterator,
 		if (!mod)
 			continue;
 
-		(*iterator)++;
-
 		return mod;
 	}
 

commit 826e83de58e3bb243b154380837c6506a0575395
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 20 04:23:29 2017 +0000

    ASoC: rsnd: fixup for_each_rsnd_mod_array{s} iterator increment
    
    commit 5f222a292 ("ASoC: rsnd: use for_each_rsnd_mod_xxx() ...")
    modifies rsnd_dai_call() to use for_each_rsnd_mod_arrays().
    
    Current rsnd is incrementing iterator in rsnd_mod_next(),
    but the iterator will indicate +1 position in for_each loop in
    this case. Incremental position should be inside for()
    
    Reported-by: Hoan Nguyen An <na-hoan@jinso.co.jp>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 4bd68de76130..948c5ec87980 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -363,8 +363,6 @@ struct rsnd_mod *rsnd_mod_next(int *iterator,
 		if (!mod)
 			continue;
 
-		(*iterator)++;
-
 		return mod;
 	}
 

commit 0ea617a298dcdc2251b4e10f83ac3f3e627b66e3
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Dec 8 13:05:43 2016 +0000

    ASoC: rsnd: don't double free kctrl
    
    On an error, snd_ctl_add already free's kctrl, so calling snd_ctl_free_one
    to free it again leads to a double free error.  Fix this by removing
    the extraneous snd_ctl_free_one call.
    
    Issue found using static analysis with CoverityScan, CID 1372908
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 4bd68de76130..99b5b0835c1e 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1030,10 +1030,8 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 		return -ENOMEM;
 
 	ret = snd_ctl_add(card, kctrl);
-	if (ret < 0) {
-		snd_ctl_free_one(kctrl);
+	if (ret < 0)
 		return ret;
-	}
 
 	cfg->update = update;
 	cfg->card = card;

commit c2d3171847611e8a33d3e10a9942f6c065d05c1f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Dec 7 00:29:02 2016 +0000

    ASoC: rsnd: enable/disable ADG when suspend/resume timing
    
    Current rsnd driver enables ADG clock when .probe timing,
    but it breaks sound after Suspend/Resume. These should be setups
    every suspend/resume timing too.
    This patch is tested on R-Car Gen3 Salvator-X board
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Gaku Inami <gaku.inami.xw@bp.renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 825635aaf30e..4bd68de76130 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1308,9 +1308,33 @@ static int rsnd_remove(struct platform_device *pdev)
 	return ret;
 }
 
+static int rsnd_suspend(struct device *dev)
+{
+	struct rsnd_priv *priv = dev_get_drvdata(dev);
+
+	rsnd_adg_clk_disable(priv);
+
+	return 0;
+}
+
+static int rsnd_resume(struct device *dev)
+{
+	struct rsnd_priv *priv = dev_get_drvdata(dev);
+
+	rsnd_adg_clk_enable(priv);
+
+	return 0;
+}
+
+static struct dev_pm_ops rsnd_pm_ops = {
+	.suspend		= rsnd_suspend,
+	.resume			= rsnd_resume,
+};
+
 static struct platform_driver rsnd_driver = {
 	.driver	= {
 		.name	= "rcar_sound",
+		.pm	= &rsnd_pm_ops,
 		.of_match_table = rsnd_of_match,
 	},
 	.probe		= rsnd_probe,

commit 3ce2959d162a8f2d69a83582df619a20ff3f6645
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 2 02:44:23 2016 +0000

    ASoC: rsnd: rsnd_get_dalign() needs to care SSIU, not SSI
    
    SSIU was controlled by SSI before, but
    commit c7f69ab53("ASoC: rsnd: use mod base common method on SSIU")
    separated it into ssiu.c
    
    But, it didn't care about rsnd_get_dalign() for judging SSI_BUSIF_DALIGN
    register value which changes the stream data order.
    This function will be called from cmd/src/ssiu now, but current code
    still cares ssi, not ssiu.
    This patch fix it up
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 912dc62ff9c7..825635aaf30e 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -306,7 +306,7 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
  */
 u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 {
-	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
+	struct rsnd_mod *ssiu = rsnd_io_to_mod_ssiu(io);
 	struct rsnd_mod *target;
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	u32 val = 0x76543210;
@@ -315,11 +315,11 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	if (rsnd_io_is_play(io)) {
 		struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 
-		target = src ? src : ssi;
+		target = src ? src : ssiu;
 	} else {
 		struct rsnd_mod *cmd = rsnd_io_to_mod_cmd(io);
 
-		target = cmd ? cmd : ssi;
+		target = cmd ? cmd : ssiu;
 	}
 
 	mask <<= runtime->channels * 4;

commit 4821d914fe747a91453021675a74069776f0b819
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 14 04:20:56 2016 +0000

    ASoC: rsnd: use dma_sync_single_for_xxx() for IOMMU
    
    IOMMU needs DMA mapping function to use it. One solution is that
    we can use DMA mapped dev on snd_pcm_lib_preallocate_pages_for_all()
    for SNDRV_DMA_TYPE_DEV. But pcm_new and dma map timing are mismatched.
    Thus, this patch uses SNDRV_DMA_TYPE_CONTINUOUS for pcm_new,
    and use dma_sync_single_for_xxx() for each transfer.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 9ffa29941ceb..912dc62ff9c7 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1126,8 +1126,8 @@ static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 
 	return snd_pcm_lib_preallocate_pages_for_all(
 		rtd->pcm,
-		SNDRV_DMA_TYPE_DEV,
-		rtd->card->snd_card->dev,
+		SNDRV_DMA_TYPE_CONTINUOUS,
+		snd_dma_continuous_data(GFP_KERNEL),
 		PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
 }
 

commit 10a9cca13220888c20a259abbd42ea117cddfdb0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 25 00:37:35 2016 +0000

    ASoC: rsnd: add nolock_start/stop callback
    
    Current Renesas Sound driver requests DMA channel when .probe timing,
    and release it when .remove timing. And use DMA on .start/.stop
    But, Audio DMAC power ON was handled when request timing (= .probe),
    and power OFF was when release timing (= .remove).
    This means Audio DMAC power is always ON during driver was enabled.
    To fixup this issue, it should request/release DMA channel on each
    playback/recorde timing.
    But, DMA channel request/release function uses mutex lock inside.
    This means it will breaks current spinlock's interrupt protect.
    To solve this issue, DMA channel request/release function needs to
    be called from non-spinlock area. This patch adds its callback.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ea14a1470de2..9ffa29941ceb 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -716,7 +716,33 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 	return 0;
 }
 
+static int rsnd_soc_dai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+
+	/*
+	 * call rsnd_dai_call without spinlock
+	 */
+	return rsnd_dai_call(nolock_start, io, priv);
+}
+
+static void rsnd_soc_dai_shutdown(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+
+	/*
+	 * call rsnd_dai_call without spinlock
+	 */
+	rsnd_dai_call(nolock_stop, io, priv);
+}
+
 static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
+	.startup	= rsnd_soc_dai_startup,
+	.shutdown	= rsnd_soc_dai_shutdown,
 	.trigger	= rsnd_soc_dai_trigger,
 	.set_fmt	= rsnd_soc_dai_set_fmt,
 	.set_tdm_slot	= rsnd_soc_set_dai_tdm_slot,

commit 9b87bfb2e8e1bbd685489a84f4841250cab493ca
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 19 03:57:27 2016 +0000

    ASoC: rsnd: use for_each_rsnd_mod_xxx() on rsnd_rdai_continuance_probe()
    
    Now, we have for_each_rsnd_mod(), let's use it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index aba49b2b0103..ea14a1470de2 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1122,6 +1122,7 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 	ret = rsnd_dai_call(probe, io, priv);
 	if (ret == -EAGAIN) {
 		struct rsnd_mod *ssi_mod = rsnd_io_to_mod_ssi(io);
+		struct rsnd_mod *mod;
 		int i;
 
 		/*
@@ -1141,8 +1142,8 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 		 * remove all mod from io
 		 * and, re connect ssi
 		 */
-		for (i = 0; i < RSND_MOD_MAX; i++)
-			rsnd_dai_disconnect((io)->mod[i], io, i);
+		for_each_rsnd_mod(i, mod, io)
+			rsnd_dai_disconnect(mod, io, i);
 		rsnd_dai_connect(ssi_mod, io, RSND_MOD_SSI);
 
 		/*

commit 5f222a29212cac3b64e7da8657d4404cc8201595
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 19 03:57:08 2016 +0000

    ASoC: rsnd: use for_each_rsnd_mod_xxx() on rsnd_dai_call()
    
    Current rsnd driver is using too complex macro for for-loop of each mod.
    rsnd_dai_call() is especially defined as very complex macro.
    It is easier to read just a little bit by using for_each_rsnd_mod_xxx()
    and new rsnd_status_update()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index c0196f81e082..aba49b2b0103 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -371,33 +371,6 @@ struct rsnd_mod *rsnd_mod_next(int *iterator,
 	return NULL;
 }
 
-#define rsnd_mod_call(idx, io, func, param...)			\
-({								\
-	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
-	struct rsnd_mod *mod = (io)->mod[idx];			\
-	struct device *dev = rsnd_priv_to_dev(priv);		\
-	u32 *status = mod->get_status(io, mod, idx);			\
-	u32 mask = 0xF << __rsnd_mod_shift_##func;			\
-	u8 val  = (*status >> __rsnd_mod_shift_##func) & 0xF;		\
-	u8 add  = ((val + __rsnd_mod_add_##func) & 0xF);		\
-	int ret = 0;							\
-	int call = (val == __rsnd_mod_call_##func) && (mod)->ops->func;	\
-	if (add == 0xF)							\
-		call = 0;						\
-	else								\
-		*status = (*status & ~mask) +				\
-			(add << __rsnd_mod_shift_##func);		\
-	dev_dbg(dev, "%s[%d]\t0x%08x %s\n",				\
-		rsnd_mod_name(mod), rsnd_mod_id(mod),			\
-		*status, call ? #func : "");				\
-	if (call)							\
-		ret = (mod)->ops->func(mod, io, param);			\
-	if (ret)							\
-		dev_dbg(dev, "%s[%d] : rsnd_mod_call error %d\n",	\
-			rsnd_mod_name(mod), rsnd_mod_id(mod), ret);	\
-	ret;								\
-})
-
 static enum rsnd_mod_type rsnd_mod_sequence[][RSND_MOD_MAX] = {
 	{
 		/* CAPTURE */
@@ -432,19 +405,49 @@ static enum rsnd_mod_type rsnd_mod_sequence[][RSND_MOD_MAX] = {
 	},
 };
 
-#define rsnd_dai_call(fn, io, param...)				\
-({								\
-	struct rsnd_mod *mod;					\
-	int type, is_play = rsnd_io_is_play(io);		\
-	int ret = 0, i;						\
-	for (i = 0; i < RSND_MOD_MAX; i++) {			\
-		type = rsnd_mod_sequence[is_play][i];		\
-		mod = (io)->mod[type];				\
-		if (!mod)					\
-			continue;				\
-		ret |= rsnd_mod_call(type, io, fn, param);	\
-	}							\
-	ret;							\
+static int rsnd_status_update(u32 *status,
+			      int shift, int add, int timing)
+{
+	u32 mask	= 0xF << shift;
+	u8 val		= (*status >> shift) & 0xF;
+	u8 next_val	= (val + add) & 0xF;
+	int func_call	= (val == timing);
+
+	if (next_val == 0xF) /* underflow case */
+		func_call = 0;
+	else
+		*status = (*status & ~mask) + (next_val << shift);
+
+	return func_call;
+}
+
+#define rsnd_dai_call(fn, io, param...)					\
+({									\
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);			\
+	struct device *dev = rsnd_priv_to_dev(priv);			\
+	struct rsnd_mod *mod;						\
+	int is_play = rsnd_io_is_play(io);				\
+	int ret = 0, i;							\
+	enum rsnd_mod_type *types = rsnd_mod_sequence[is_play];		\
+	for_each_rsnd_mod_arrays(i, mod, io, types, RSND_MOD_MAX) {	\
+		int tmp = 0;						\
+		u32 *status = mod->get_status(io, mod, types[i]);	\
+		int func_call = rsnd_status_update(status,		\
+						__rsnd_mod_shift_##fn,	\
+						__rsnd_mod_add_##fn,	\
+						__rsnd_mod_call_##fn);	\
+		dev_dbg(dev, "%s[%d]\t0x%08x %s\n",			\
+			rsnd_mod_name(mod), rsnd_mod_id(mod), *status,	\
+			(func_call && (mod)->ops->fn) ? #fn : "");	\
+		if (func_call && (mod)->ops->fn)			\
+			tmp = (mod)->ops->fn(mod, io, param);		\
+		if (tmp)						\
+			dev_err(dev, "%s[%d] : %s error %d\n",		\
+				rsnd_mod_name(mod), rsnd_mod_id(mod),	\
+						     #fn, tmp);		\
+		ret |= tmp;						\
+	}								\
+	ret;								\
 })
 
 int rsnd_dai_connect(struct rsnd_mod *mod,

commit b3ca3fbeb229890e8de569d1b34cd46fcb95826c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 19 03:56:46 2016 +0000

    ASoC: rsnd: add rsnd_mod_next() for for_each_rsnd_mod_xxx()
    
    Current rsnd driver is using too complex macro for for-loop of each mod.
    In order to simplify this issue, this patch adds new rsnd_mod_next()
    which is non-macro.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 209e7363bfdd..c0196f81e082 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -348,6 +348,29 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 /*
  *	rsnd_dai functions
  */
+struct rsnd_mod *rsnd_mod_next(int *iterator,
+			       struct rsnd_dai_stream *io,
+			       enum rsnd_mod_type *array,
+			       int array_size)
+{
+	struct rsnd_mod *mod;
+	enum rsnd_mod_type type;
+	int max = array ? array_size : RSND_MOD_MAX;
+
+	for (; *iterator < max; (*iterator)++) {
+		type = (array) ? array[*iterator] : *iterator;
+		mod = io->mod[type];
+		if (!mod)
+			continue;
+
+		(*iterator)++;
+
+		return mod;
+	}
+
+	return NULL;
+}
+
 #define rsnd_mod_call(idx, io, func, param...)			\
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\

commit 0af5c01a79ade438698af683511803fc11291360
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 19 03:56:26 2016 +0000

    ASoC: rsnd: amend .probe/.remove call for DPCM
    
    commit 1a5658c2131 ("ASoC: rsnd: count .probe/.remove for
    rsnd_mod_call()") solved multi-resource-free issue, by putting
    .probe/.remove under count control. But,it breaks sound mixing case
    (if it was used under DPCM). In such case, it uses MIXn/DVCn/SSIn,
    and these should be always probed.
    This patch reverted above patch, and solved the same issue by
    modifing _rsnd_kctrl_remove() function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f18141098b50..209e7363bfdd 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -993,7 +993,11 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 
 void _rsnd_kctrl_remove(struct rsnd_kctrl_cfg *cfg)
 {
-	snd_ctl_remove(cfg->card, cfg->kctrl);
+	if (cfg->card && cfg->kctrl)
+		snd_ctl_remove(cfg->card, cfg->kctrl);
+
+	cfg->card = NULL;
+	cfg->kctrl = NULL;
 }
 
 int rsnd_kctrl_new_m(struct rsnd_mod *mod,

commit 4b9c75eaa4f35504c3ee28d3a354f7b6362dfbe8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 29 03:09:22 2016 +0000

    ASoC: rsnd: add SNDRV_PCM_TRIGGER_SUSPEND/RESUME
    
    This patch adds SNDRV_PCM_TRIGGER_SUSPEND/RESUME.
    Otherwise, it breaks rsnd driver internal start/stop counter
    when suspend/resume. This issue was reported/tested by Hiep
    
    Tested-by: Hiep Cao Minh <cm-hiep@jinso.co.jp>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f718a200f77d..f18141098b50 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -576,6 +576,7 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
 		rsnd_dai_stream_init(io, substream);
 
 		ret = rsnd_dai_call(init, io, priv);
@@ -592,6 +593,7 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		ret = rsnd_dai_call(irq, io, priv, 0);
 
 		ret |= rsnd_dai_call(stop, io, priv);

commit 1d9d0c65d95ecc446972ace6a7583e5cfdc69e48
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Thu Aug 11 14:38:13 2016 +0800

    ASoC: fix W=1 build warnings
    
    We get 1 warning about global functions without a declaration
    in the ASoC sub-system when building with W=1:
    
    sound/soc/sh/rcar/core.c:113:6: warning: no previous prototype for 'rsnd_mod_make_sure' [-Wmissing-prototypes]
     void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
    
    In this case, the function 'rsnd_mod_make_sure' is declared in rsnd.h file,
    but it only valid if the macro DEBUG is claimed.
    
    so the implementation of function 'rsnd_mod_make_sure' need be
    held by macro DEBUG.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3351a701c60e..f718a200f77d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -110,6 +110,7 @@ MODULE_DEVICE_TABLE(of, rsnd_of_match);
 /*
  *	rsnd_mod functions
  */
+#ifdef DEBUG
 void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
 {
 	if (mod->type != type) {
@@ -120,6 +121,7 @@ void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
 			 rsnd_mod_name(mod), rsnd_mod_id(mod));
 	}
 }
+#endif
 
 char *rsnd_mod_name(struct rsnd_mod *mod)
 {

commit eed76bb811cd143119b4bdeca88606685222e687
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Feb 25 05:54:58 2016 +0000

    ASoC: rsnd: add rsnd_runtime_channel_xxx()
    
    Current SSI is supporting Normal SSI/Multi mode SSI/TDM mode SSI
    and its behavior is based on input channels.
    This input channel might be converted by CTU,
    and SSI needs to be Multi SSI mode / TDM SSI mode if 6ch input
    
    EX) 6ch input, CTU for 2ch, playback
    
     6ch    6ch    2ch    2ch    2ch     2ch
     -> SRC -> CTU -> MIX -> DVC -> SSIU -> SSI
    
    EX) 6ch input, no CTU, Multi SSI, playback
    
     6ch    6ch    6ch    6ch    6ch     2ch
     -> SRC -> CTU -> MIX -> DVC -> SSIU -> SSI0/SSI1/SSI2
    
    Current driver is using rsnd_get_adinr_chan() / rsnd_get_slot_width()
    for this purpose, but it is complicated enough without meaning.
    This patch adds new rsnd_runtime_channel_xxx() which is caring
    CTU/Multi SSI.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3a3dc2ff18c9..3351a701c60e 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -224,13 +224,36 @@ int rsnd_get_slot_num(struct rsnd_dai_stream *io)
 	return rdai->slots_num;
 }
 
-int rsnd_get_slot_width(struct rsnd_dai_stream *io)
+int rsnd_runtime_channel_original(struct rsnd_dai_stream *io)
 {
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
-	int chan = runtime->channels;
 
-	/* Multi channel Mode */
-	if (rsnd_ssi_multi_slaves_runtime(io))
+	return runtime->channels;
+}
+
+int rsnd_runtime_channel_after_ctu(struct rsnd_dai_stream *io)
+{
+	int chan = rsnd_runtime_channel_original(io);
+	struct rsnd_mod *ctu_mod = rsnd_io_to_mod_ctu(io);
+
+	if (ctu_mod) {
+		u32 converted_chan = rsnd_ctu_converted_channel(ctu_mod);
+
+		if (converted_chan)
+			return converted_chan;
+	}
+
+	return chan;
+}
+
+int rsnd_runtime_channel_for_ssi(struct rsnd_dai_stream *io)
+{
+	int chan = rsnd_io_is_play(io) ?
+		rsnd_runtime_channel_after_ctu(io) :
+		rsnd_runtime_channel_original(io);
+
+	/* Use Multi SSI */
+	if (rsnd_runtime_is_ssi_multi(io))
 		chan /= rsnd_get_slot_num(io);
 
 	/* TDM Extend Mode needs 8ch */
@@ -240,6 +263,21 @@ int rsnd_get_slot_width(struct rsnd_dai_stream *io)
 	return chan;
 }
 
+int rsnd_runtime_is_ssi_multi(struct rsnd_dai_stream *io)
+{
+	int slots = rsnd_get_slot_num(io);
+	int chan = rsnd_io_is_play(io) ?
+		rsnd_runtime_channel_after_ctu(io) :
+		rsnd_runtime_channel_original(io);
+
+	return (chan >= 6) && (slots > 1);
+}
+
+int rsnd_runtime_is_ssi_tdm(struct rsnd_dai_stream *io)
+{
+	return rsnd_runtime_channel_for_ssi(io) >= 6;
+}
+
 /*
  *	ADINR function
  */
@@ -261,29 +299,6 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	return 0;
 }
 
-u32 rsnd_get_adinr_chan(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
-{
-	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
-	struct device *dev = rsnd_priv_to_dev(priv);
-	u32 chan = runtime->channels;
-
-	switch (chan) {
-	case 1:
-	case 2:
-	case 4:
-	case 6:
-	case 8:
-		break;
-	default:
-		dev_warn(dev, "not supported channel\n");
-		chan = 0;
-		break;
-	}
-
-	return chan;
-}
-
 /*
  *	DALIGN function
  */

commit d7289565483c65094d0473555625a4acd89567d3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Feb 25 05:51:12 2016 +0000

    ASoC: rsnd: don't call update callback if it was NULL
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ba37b0d55b21..3a3dc2ff18c9 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -927,7 +927,7 @@ static int rsnd_kctrl_put(struct snd_kcontrol *kctrl,
 		}
 	}
 
-	if (change)
+	if (change && cfg->update)
 		cfg->update(cfg->io, mod);
 
 	return change;

commit 6d8044b4ff305238503edca7d75f3ab7410396ba
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Mar 1 17:39:19 2016 +0100

    ASoC: sh: rcar: core: don't open code of_device_get_match_data()
    
    This change will also make Coverity happy by avoiding a theoretical NULL
    pointer dereference; yet another reason is to use the above helper function
    to tighten the code and make it more readable.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 21e13b3a356f..ba37b0d55b21 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1119,7 +1119,6 @@ static int rsnd_probe(struct platform_device *pdev)
 	struct rsnd_priv *priv;
 	struct device *dev = &pdev->dev;
 	struct rsnd_dai *rdai;
-	const struct of_device_id *of_id = of_match_device(rsnd_of_match, dev);
 	int (*probe_func[])(struct rsnd_priv *priv) = {
 		rsnd_gen_probe,
 		rsnd_dma_probe,
@@ -1145,7 +1144,7 @@ static int rsnd_probe(struct platform_device *pdev)
 	}
 
 	priv->pdev	= pdev;
-	priv->flags	= (unsigned long)of_id->data;
+	priv->flags	= (unsigned long)of_device_get_match_data(dev);
 	spin_lock_init(&priv->lock);
 
 	/*

commit 79e24da00b1137031245f3341828e4215b1b5b59
Merge: fd9adcfdc143 e6ef243fa466
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Mar 2 12:58:58 2016 +0900

    Merge branch 'topic/update-bits' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap into asoc-rcar

commit 4f5c634d58e71963d3c34a0a4af9ec71785f094f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Feb 18 08:18:54 2016 +0000

    ASoC: rsnd: judge multi SSI in runtime
    
    Current rsnd supports multi SSI (maximum 4 SSI for 8ch),
    and, it should determine whether using each SSI or not in runtime.
    Current judgement is vague, and had broken by
    c308abe45e2("ASoC: rsnd: rsnd_ssi_is_multi_slave() macro uses
    rsnd_ssi_multi_slaves()")
    This patch makes clean it, and solve this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f86d62730614..7bc5b724fbf5 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -230,7 +230,7 @@ int rsnd_get_slot_width(struct rsnd_dai_stream *io)
 	int chan = runtime->channels;
 
 	/* Multi channel Mode */
-	if (rsnd_ssi_multi_slaves(io))
+	if (rsnd_ssi_multi_slaves_runtime(io))
 		chan /= rsnd_get_slot_num(io);
 
 	/* TDM Extend Mode needs 8ch */

commit d2240f0dad488c66e14c45762bd23999901f57a1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Feb 18 08:13:13 2016 +0000

    ASoC: rsnd: rename RSND_DVC_CHANNELS to RSND_MAX_CHANNELS
    
    The channels number is not only for DVC. Let's rename it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 704ba7ae9eaf..f86d62730614 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -988,7 +988,7 @@ int rsnd_kctrl_new_m(struct rsnd_mod *mod,
 		     int ch_size,
 		     u32 max)
 {
-	if (ch_size > RSND_DVC_CHANNELS)
+	if (ch_size > RSND_MAX_CHANNELS)
 		return -EINVAL;
 
 	_cfg->cfg.max	= max;

commit b5b442abd9d5cfe4f04a1e83be9900c87444bd66
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jan 26 04:56:57 2016 +0000

    ASoC: rsnd: add .irq callback
    
    Current rsnd driver has .init/.start/.stop/.quit callbacks,
    and it needs many IPs (SRC/CTU/MUX/DVC/CMD/SSIU/SSI).
    Because of these relationship, it might get unnecessary
    error IRQ when start/stop.
    This patch adds new .irq callback and control IRQ enable/disable
    timing to avoid it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1fcefab03ad6..704ba7ae9eaf 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -568,9 +568,16 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		ret = rsnd_dai_call(start, io, priv);
 		if (ret < 0)
 			goto dai_trigger_end;
+
+		ret = rsnd_dai_call(irq, io, priv, 1);
+		if (ret < 0)
+			goto dai_trigger_end;
+
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-		ret = rsnd_dai_call(stop, io, priv);
+		ret = rsnd_dai_call(irq, io, priv, 0);
+
+		ret |= rsnd_dai_call(stop, io, priv);
 
 		ret |= rsnd_dai_call(quit, io, priv);
 

commit 38587f4cb7937344e12a9eef1ccdc5b8a0e992ba
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 21 01:59:55 2016 +0000

    ASoC: rsnd: tidyup Playback/Capture sequence
    
    Based on datasheet sequence
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b460d714d088..1fcefab03ad6 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -358,15 +358,51 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	ret;								\
 })
 
+static enum rsnd_mod_type rsnd_mod_sequence[][RSND_MOD_MAX] = {
+	{
+		/* CAPTURE */
+		RSND_MOD_AUDMAPP,
+		RSND_MOD_AUDMA,
+		RSND_MOD_DVC,
+		RSND_MOD_MIX,
+		RSND_MOD_CTU,
+		RSND_MOD_CMD,
+		RSND_MOD_SRC,
+		RSND_MOD_SSIU,
+		RSND_MOD_SSIM3,
+		RSND_MOD_SSIM2,
+		RSND_MOD_SSIM1,
+		RSND_MOD_SSIP,
+		RSND_MOD_SSI,
+	}, {
+		/* PLAYBACK */
+		RSND_MOD_AUDMAPP,
+		RSND_MOD_AUDMA,
+		RSND_MOD_SSIM3,
+		RSND_MOD_SSIM2,
+		RSND_MOD_SSIM1,
+		RSND_MOD_SSIP,
+		RSND_MOD_SSI,
+		RSND_MOD_SSIU,
+		RSND_MOD_DVC,
+		RSND_MOD_MIX,
+		RSND_MOD_CTU,
+		RSND_MOD_CMD,
+		RSND_MOD_SRC,
+	},
+};
+
 #define rsnd_dai_call(fn, io, param...)				\
 ({								\
 	struct rsnd_mod *mod;					\
+	int type, is_play = rsnd_io_is_play(io);		\
 	int ret = 0, i;						\
 	for (i = 0; i < RSND_MOD_MAX; i++) {			\
-		mod = (io)->mod[i];				\
+		type = rsnd_mod_sequence[is_play][i];		\
+		mod = (io)->mod[type];				\
 		if (!mod)					\
 			continue;				\
-		ret |= rsnd_mod_call(i, io, fn, param);		\
+		ret |= rsnd_mod_call(type, io, fn, param);	\
 	}							\
 	ret;							\
 })

commit 5ba17b42e1755c3c5cfe96370cfd47f34d01f62c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 21 01:58:07 2016 +0000

    ASoC: rsnd: each mod has status again for CTU/MUX support
    
    SSI will be used as normal SSI or as clock parent SSI. Therefor,
    rsnd driver wants to control SSI and parent SSI separately. Otherwise it
    can't use Playback/Capture in the same time.
    And it has been done by c2dc47d5cf("ASoC: rsnd: rsnd_dai_stream has each
    mod's status insted of rsnd_mod") before.
    
    OTOH, rsnd driver doesn't want to control CTU/MUX/DVC/SSIU/SSI in
    separately. Otherwise, these will be re-initialized during playing if
    MUX merges 2 sounds.
    Because of these picky reasons, this patch re-defines status on each mod,
    and add new parent_ssi_status on rsnd_dai_stream.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ed0918967def..b460d714d088 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -138,12 +138,22 @@ struct dma_chan *rsnd_mod_dma_req(struct rsnd_dai_stream *io,
 	return mod->ops->dma_req(io, mod);
 }
 
+u32 *rsnd_mod_get_status(struct rsnd_dai_stream *io,
+			 struct rsnd_mod *mod,
+			 enum rsnd_mod_type type)
+{
+	return &mod->status;
+}
+
 int rsnd_mod_init(struct rsnd_priv *priv,
 		  struct rsnd_mod *mod,
-		   struct rsnd_mod_ops *ops,
-		   struct clk *clk,
-		   enum rsnd_mod_type type,
-		   int id)
+		  struct rsnd_mod_ops *ops,
+		  struct clk *clk,
+		  u32* (*get_status)(struct rsnd_dai_stream *io,
+				     struct rsnd_mod *mod,
+				     enum rsnd_mod_type type),
+		  enum rsnd_mod_type type,
+		  int id)
 {
 	int ret = clk_prepare(clk);
 
@@ -155,6 +165,7 @@ int rsnd_mod_init(struct rsnd_priv *priv,
 	mod->type	= type;
 	mod->clk	= clk;
 	mod->priv	= priv;
+	mod->get_status	= get_status;
 
 	return ret;
 }
@@ -325,7 +336,7 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct rsnd_mod *mod = (io)->mod[idx];			\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
-	u32 *status = (io)->mod_status + idx;			\
+	u32 *status = mod->get_status(io, mod, idx);			\
 	u32 mask = 0xF << __rsnd_mod_shift_##func;			\
 	u8 val  = (*status >> __rsnd_mod_shift_##func) & 0xF;		\
 	u8 add  = ((val + __rsnd_mod_add_##func) & 0xF);		\

commit ea96380baa2794cb6e0d5bfbcca0c78b237a5f8a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 21 01:56:59 2016 +0000

    ASoC: rsnd: always call probe/remove for MUX
    
    CTU/MUX/DVC/SSIU/SSI/Audio-DMAC-periperi might be used under multipath.
    So, probe()/remove() need to be called multiple times.
    This patch allows it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ad97ce3ae844..ed0918967def 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -163,6 +163,7 @@ void rsnd_mod_quit(struct rsnd_mod *mod)
 {
 	if (mod->clk)
 		clk_unprepare(mod->clk);
+	mod->clk = NULL;
 }
 
 void rsnd_mod_interrupt(struct rsnd_mod *mod,

commit bfa3119c38afb8177f8e403b9e9b2ecd0306bb26
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 21 01:56:36 2016 +0000

    ASoC: rsnd: try to connect connected mod is not error
    
    If system uses CTU/MUX, CTU/MUX/DVC will try to connect same CMD to
    system, but it is not error in this case.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3eb7e9a7b5dc..ad97ce3ae844 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -369,6 +369,9 @@ int rsnd_dai_connect(struct rsnd_mod *mod,
 	if (!mod)
 		return -EIO;
 
+	if (io->mod[type] == mod)
+		return 0;
+
 	if (io->mod[type])
 		return -EINVAL;
 

commit 6c001f3ab4ce20f01a1b3064b2bd1a9352c5d6b1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 21 01:56:18 2016 +0000

    ASoC: rsnd: don't update status if rsnd_mod_call() doesn't match
    
    If system uses CTU/MUX, and if probe error happened, it will try to
    call rsnd_dai_call(remove, ...). Then, MUX/DVC/SSIU/SSI might be called
    without calling rsnd_dai_call(probe, ...). Then, each mod status might
    be un-matched. It doesn't call un-matched remove function by this patch.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 691e22381280..3eb7e9a7b5dc 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -330,8 +330,11 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	u8 add  = ((val + __rsnd_mod_add_##func) & 0xF);		\
 	int ret = 0;							\
 	int call = (val == __rsnd_mod_call_##func) && (mod)->ops->func;	\
-	*status = (*status & ~mask) +					\
-		(add << __rsnd_mod_shift_##func);			\
+	if (add == 0xF)							\
+		call = 0;						\
+	else								\
+		*status = (*status & ~mask) +				\
+			(add << __rsnd_mod_shift_##func);		\
 	dev_dbg(dev, "%s[%d]\t0x%08x %s\n",				\
 		rsnd_mod_name(mod), rsnd_mod_id(mod),			\
 		*status, call ? #func : "");				\

commit 4e880b2674a6d36d6c7b9741d88973e00a76922b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 21 01:55:57 2016 +0000

    ASoC: rsnd: add debug message for rsnd_mod_call()
    
    rsnd_mod_call() tries to call each IP's relevant function. But it is
    difficult to understand which function returned error.
    This patch adds debug message for this purpose
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ca05a0a95a4d..691e22381280 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -337,6 +337,9 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 		*status, call ? #func : "");				\
 	if (call)							\
 		ret = (mod)->ops->func(mod, io, param);			\
+	if (ret)							\
+		dev_dbg(dev, "%s[%d] : rsnd_mod_call error %d\n",	\
+			rsnd_mod_name(mod), rsnd_mod_id(mod), ret);	\
 	ret;								\
 })
 

commit 81b6863cae0ca371ebe8bd176548be4d2741e6bb
Merge: 9451a469280a d1afdf34fc17 18560a4e3b07 b4c83b171557 5f4f276077ae 5938448b9927
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Dec 23 00:23:46 2015 +0000

    Merge remote-tracking branches 'asoc/topic/pxa', 'asoc/topic/qcom', 'asoc/topic/rcar', 'asoc/topic/rk3036' and 'asoc/topic/rockchip' into asoc-next

commit b4c83b171557815a0b31a36805900cc9f21c9ee4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 17 03:00:10 2015 +0000

    ASoC: rsnd: add Multi channel support
    
    This patch adds Multi channel support on Renesas R-Car sound.
    This patch is tested on Salvator-X board, but it can't use
    Multi channel, because supported format is different between
    codec chip and R-Car.
    Thus, it was tested on board which doesn't mount codec chip,
    with oscilloscope.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7781cef634d4..ca05a0a95a4d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -215,7 +215,11 @@ int rsnd_get_slot_num(struct rsnd_dai_stream *io)
 int rsnd_get_slot_width(struct rsnd_dai_stream *io)
 {
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
-	int chan = runtime->channels / rsnd_get_slot_num(io);
+	int chan = runtime->channels;
+
+	/* Multi channel Mode */
+	if (rsnd_ssi_multi_slaves(io))
+		chan /= rsnd_get_slot_num(io);
 
 	/* TDM Extend Mode needs 8ch */
 	if (chan == 6)

commit 89b66174eca6609020cc3d1ef32df7956fd16b34
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 17 02:58:14 2015 +0000

    ASoC: rsnd: add rsnd_parse_connect_common() and remove complex macro
    
    Current rsnd driver is using complex macro to parse DAI connection.
    This patch adds new rsnd_parse_connect_common() and replace current
    macro to it.
    This is prepare for multi channel support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 528041eff704..7781cef634d4 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -609,17 +609,44 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.set_tdm_slot	= rsnd_soc_set_dai_tdm_slot,
 };
 
+void rsnd_parse_connect_common(struct rsnd_dai *rdai,
+		struct rsnd_mod* (*mod_get)(struct rsnd_priv *priv, int id),
+		struct device_node *node,
+		struct device_node *playback,
+		struct device_node *capture)
+{
+	struct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);
+	struct device_node *np;
+	struct rsnd_mod *mod;
+	int i;
+
+	if (!node)
+		return;
+
+	i = 0;
+	for_each_child_of_node(node, np) {
+		mod = mod_get(priv, i);
+		if (np == playback)
+			rsnd_dai_connect(mod, &rdai->playback, mod->type);
+		if (np == capture)
+			rsnd_dai_connect(mod, &rdai->capture, mod->type);
+		i++;
+	}
+
+	of_node_put(node);
+}
+
 static int rsnd_dai_probe(struct rsnd_priv *priv)
 {
 	struct device_node *dai_node;
-	struct device_node *dai_np, *np, *node;
+	struct device_node *dai_np;
 	struct device_node *playback, *capture;
 	struct rsnd_dai_stream *io_playback;
 	struct rsnd_dai_stream *io_capture;
 	struct snd_soc_dai_driver *rdrv, *drv;
 	struct rsnd_dai *rdai;
 	struct device *dev = rsnd_priv_to_dev(priv);
-	int nr, dai_i, io_i, np_i;
+	int nr, dai_i, io_i;
 	int ret;
 
 	dai_node = rsnd_dai_of_node(priv);
@@ -676,22 +703,6 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 		rdai->capture.rdai		= rdai;
 		rsnd_set_slot(rdai, 2, 1); /* default */
 
-#define mod_parse(name)							\
-node = rsnd_##name##_of_node(priv);					\
-if (node) {								\
-	struct rsnd_mod *mod;						\
-	np_i = 0;							\
-	for_each_child_of_node(node, np) {				\
-		mod = rsnd_##name##_mod_get(priv, np_i);		\
-		if (np == playback)					\
-			rsnd_dai_connect(mod, io_playback, mod->type);	\
-		if (np == capture)					\
-			rsnd_dai_connect(mod, io_capture, mod->type);	\
-		np_i++;							\
-	}								\
-	of_node_put(node);						\
-}
-
 		for (io_i = 0;; io_i++) {
 			playback = of_parse_phandle(dai_np, "playback", io_i);
 			capture  = of_parse_phandle(dai_np, "capture", io_i);
@@ -699,11 +710,11 @@ if (node) {								\
 			if (!playback && !capture)
 				break;
 
-			mod_parse(ssi);
-			mod_parse(src);
-			mod_parse(ctu);
-			mod_parse(mix);
-			mod_parse(dvc);
+			rsnd_parse_connect_ssi(rdai, playback, capture);
+			rsnd_parse_connect_src(rdai, playback, capture);
+			rsnd_parse_connect_ctu(rdai, playback, capture);
+			rsnd_parse_connect_mix(rdai, playback, capture);
+			rsnd_parse_connect_dvc(rdai, playback, capture);
 
 			of_node_put(playback);
 			of_node_put(capture);

commit 750fd445ac53f1623cfcbf710d2bfc7aa1b7086d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 17 02:57:47 2015 +0000

    ASoC: rsnd: add rsnd_set_slot() / rsnd_get_slot_num()
    
    TDM will use 6 or 8 slots on 1 SSI, and Multi channel will use
    6 or 8 slots on few SSI (each SSI uses 2 slots).
    Thus, this adds new slot control functions which can be prepare
    for Multi channel support.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 76af41633f9f..528041eff704 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -191,6 +191,13 @@ int rsnd_io_is_working(struct rsnd_dai_stream *io)
 	return !!io->substream;
 }
 
+void rsnd_set_slot(struct rsnd_dai *rdai,
+		   int slots, int num)
+{
+	rdai->slots	= slots;
+	rdai->slots_num	= num;
+}
+
 int rsnd_get_slot(struct rsnd_dai_stream *io)
 {
 	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
@@ -198,10 +205,17 @@ int rsnd_get_slot(struct rsnd_dai_stream *io)
 	return rdai->slots;
 }
 
+int rsnd_get_slot_num(struct rsnd_dai_stream *io)
+{
+	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
+
+	return rdai->slots_num;
+}
+
 int rsnd_get_slot_width(struct rsnd_dai_stream *io)
 {
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
-	int chan = runtime->channels;
+	int chan = runtime->channels / rsnd_get_slot_num(io);
 
 	/* TDM Extend Mode needs 8ch */
 	if (chan == 6)
@@ -579,7 +593,7 @@ static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
 	switch (slots) {
 	case 6:
 		/* TDM Extend Mode */
-		rdai->slots = slots;
+		rsnd_set_slot(rdai, slots, 1);
 		break;
 	default:
 		dev_err(dev, "unsupported TDM slots (%d)\n", slots);
@@ -660,7 +674,7 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 
 		rdai->playback.rdai		= rdai;
 		rdai->capture.rdai		= rdai;
-		rdai->slots			= 2; /* default */
+		rsnd_set_slot(rdai, 2, 1); /* default */
 
 #define mod_parse(name)							\
 node = rsnd_##name##_of_node(priv);					\

commit c140284b8085e0fa07c24f4285db9dc107ad2ed3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 17 02:57:27 2015 +0000

    ASoC: rsnd: tidyup rsnd_get_slot_xxx() naming
    
    rsnd_get_slot_rdai() returns total slots (it returns 6 if total 6
    channels) , and rsnd_get_slot_extend() returns extended SSI width
    (it returns 8 if total 6 channels). This will be used on SSI multi
    channel support too (It will return 2 if total 6 channels with 3 SSI).
    But, it is using confusable naming.
    This patch changes rsnd_get_slot_rdai() -> rsnd_get_slot(),
    rsnd_get_slot_extend() -> rsnd_get_slot_width()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7f3a7edba096..76af41633f9f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -191,12 +191,14 @@ int rsnd_io_is_working(struct rsnd_dai_stream *io)
 	return !!io->substream;
 }
 
-int rsnd_get_slot_rdai(struct rsnd_dai *rdai)
+int rsnd_get_slot(struct rsnd_dai_stream *io)
 {
+	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
+
 	return rdai->slots;
 }
 
-int rsnd_get_slot_extend(struct rsnd_dai_stream *io)
+int rsnd_get_slot_width(struct rsnd_dai_stream *io)
 {
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	int chan = runtime->channels;

commit 5858a7d17e266945b9860768d0549aeb6a52d31f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 17 02:57:07 2015 +0000

    ASoC: rsnd: remove rsnd_get_slot_runtime()
    
    Current Renesas sound driver is using rsnd_get_slot_runtime(), but
    it is same as runtime->channels. This patch removes
    rsnd_get_slot_runtime()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index e59dc8a461bb..7f3a7edba096 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -196,21 +196,10 @@ int rsnd_get_slot_rdai(struct rsnd_dai *rdai)
 	return rdai->slots;
 }
 
-int rsnd_get_slot_runtime(struct rsnd_dai_stream *io)
-{
-	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
-	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
-	int chan = rsnd_get_slot_rdai(rdai);
-
-	if (runtime->channels < chan)
-		chan = runtime->channels;
-
-	return chan;
-}
-
 int rsnd_get_slot_extend(struct rsnd_dai_stream *io)
 {
-	int chan = rsnd_get_slot_runtime(io);
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	int chan = runtime->channels;
 
 	/* TDM Extend Mode needs 8ch */
 	if (chan == 6)
@@ -243,9 +232,9 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 u32 rsnd_get_adinr_chan(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 {
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
-	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
-	u32 chan = rsnd_get_slot_rdai(rdai);
+	u32 chan = runtime->channels;
 
 	switch (chan) {
 	case 1:

commit 52dc68524327ed7bedfc2856bca4fa634f11141a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 17 02:56:31 2015 +0000

    ASoC: rsnd: rsnd_dai_connect() returns error if it connect to existing mod
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 44f32c1db05d..e59dc8a461bb 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -354,6 +354,9 @@ int rsnd_dai_connect(struct rsnd_mod *mod,
 	if (!mod)
 		return -EIO;
 
+	if (io->mod[type])
+		return -EINVAL;
+
 	priv = rsnd_mod_to_priv(mod);
 	dev = rsnd_priv_to_dev(priv);
 

commit 5e7b9edd928d22ffd4936fc61c80532ed6df5077
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 17 02:55:51 2015 +0000

    ASoC: rsnd: tidyup return value of rsnd_get_adinr_bit()
    
    Renesas sound driver has rsnd_get_adinr_bit/chan() functions.
    It is assuming _bit() returns ADINR :: OTBL,
    and _chan() returns ADINR :: CHNUM.
    Current _bit() returns both OTBL and CHNUM. This patch fixup it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 849c1ad93df2..44f32c1db05d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -227,21 +227,17 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
-	u32 adinr = runtime->channels;
 
 	switch (runtime->sample_bits) {
 	case 16:
-		adinr |= (8 << 16);
-		break;
+		return 8 << 16;
 	case 32:
-		adinr |= (0 << 16);
-		break;
-	default:
-		dev_warn(dev, "not supported sample bits\n");
-		return 0;
+		return 0 << 16;
 	}
 
-	return adinr;
+	dev_warn(dev, "not supported sample bits\n");
+
+	return 0;
 }
 
 u32 rsnd_get_adinr_chan(struct rsnd_mod *mod, struct rsnd_dai_stream *io)

commit a504b1ee417ffd1e3c272b4594213edf14af3ef1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 8 05:38:23 2015 +0000

    ASoC: rsnd: tidyup data align position for capture
    
    L/R channel data has been treated as inverted on R-Car sound 16bit mode,
    Thus, 4689032b1("ASoC: rsnd: tidyup data align position") tidyuped data
    align position. But it couldn't care about capture case. This patch
    cares both playback/capture
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f1d7af114a31..849c1ad93df2 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -272,13 +272,22 @@ u32 rsnd_get_adinr_chan(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
  */
 u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 {
-	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
-	struct rsnd_mod *target = src ? src : ssi;
+	struct rsnd_mod *target;
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	u32 val = 0x76543210;
 	u32 mask = ~0;
 
+	if (rsnd_io_is_play(io)) {
+		struct rsnd_mod *src = rsnd_io_to_mod_src(io);
+
+		target = src ? src : ssi;
+	} else {
+		struct rsnd_mod *cmd = rsnd_io_to_mod_cmd(io);
+
+		target = cmd ? cmd : ssi;
+	}
+
 	mask <<= runtime->channels * 4;
 	val = val & mask;
 

commit 2ff2ecca06d5302782c73626b841a509a9b01ef6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 1 08:31:38 2015 +0000

    ASoC: rsnd: fixup wrong snd_soc_dai_driver pointer access
    
    drv pointer should be "base + offset" instead of
    "current + offset". This patch fixup this issue, otherwise
    third and subsequent pointer will be broken
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b187a8927e29..f1d7af114a31 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -603,7 +603,7 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 	struct device_node *playback, *capture;
 	struct rsnd_dai_stream *io_playback;
 	struct rsnd_dai_stream *io_capture;
-	struct snd_soc_dai_driver *drv;
+	struct snd_soc_dai_driver *rdrv, *drv;
 	struct rsnd_dai *rdai;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	int nr, dai_i, io_i, np_i;
@@ -616,15 +616,15 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 		goto rsnd_dai_probe_done;
 	}
 
-	drv  = devm_kzalloc(dev, sizeof(*drv)  * nr, GFP_KERNEL);
+	rdrv = devm_kzalloc(dev, sizeof(*rdrv) * nr, GFP_KERNEL);
 	rdai = devm_kzalloc(dev, sizeof(*rdai) * nr, GFP_KERNEL);
-	if (!drv || !rdai) {
+	if (!rdrv || !rdai) {
 		ret = -ENOMEM;
 		goto rsnd_dai_probe_done;
 	}
 
 	priv->rdai_nr	= nr;
-	priv->daidrv	= drv;
+	priv->daidrv	= rdrv;
 	priv->rdai	= rdai;
 
 	/*
@@ -633,7 +633,7 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 	dai_i = 0;
 	for_each_child_of_node(dai_node, dai_np) {
 		rdai		= rsnd_rdai_get(priv, dai_i);
-		drv		= drv + dai_i;
+		drv		= rdrv + dai_i;
 		io_playback	= &rdai->playback;
 		io_capture	= &rdai->capture;
 

commit 186fadc132f0d634c7b43202a240fbd3654b6623
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 30 08:54:03 2015 +0000

    ASoC: rsnd: add TDM Extend Mode support
    
    Renesas R-Car can out TDM by
    1) 6ch x 1 DAI as TDM Extend Mode
    2) 2ch x 4 x 1 DAI as TDM split Mode
    3) 2ch x 3 DAI or
       2ch x 4 DAI as TDM Multichannel Mode
    
    This patch adds 1) TDM Extend Mode. Because of HW design,
    this 6ch data will be outputed via 8ch data width.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7d364d7505a1..b187a8927e29 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -247,9 +247,9 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 u32 rsnd_get_adinr_chan(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 {
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
-	u32 chan = runtime->channels;
+	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
+	u32 chan = rsnd_get_slot_rdai(rdai);
 
 	switch (chan) {
 	case 1:
@@ -569,9 +569,31 @@ static int rsnd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	return 0;
 }
 
+static int rsnd_soc_set_dai_tdm_slot(struct snd_soc_dai *dai,
+				     u32 tx_mask, u32 rx_mask,
+				     int slots, int slot_width)
+{
+	struct rsnd_priv *priv = rsnd_dai_to_priv(dai);
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct device *dev = rsnd_priv_to_dev(priv);
+
+	switch (slots) {
+	case 6:
+		/* TDM Extend Mode */
+		rdai->slots = slots;
+		break;
+	default:
+		dev_err(dev, "unsupported TDM slots (%d)\n", slots);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.trigger	= rsnd_soc_dai_trigger,
 	.set_fmt	= rsnd_soc_dai_set_fmt,
+	.set_tdm_slot	= rsnd_soc_set_dai_tdm_slot,
 };
 
 static int rsnd_dai_probe(struct rsnd_priv *priv)
@@ -626,7 +648,7 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 		drv->playback.rates		= RSND_RATES;
 		drv->playback.formats		= RSND_FMTS;
 		drv->playback.channels_min	= 2;
-		drv->playback.channels_max	= 2;
+		drv->playback.channels_max	= 6;
 		drv->playback.stream_name	= rdai->playback.name;
 
 		snprintf(rdai->capture.name, RSND_DAI_NAME_SIZE,
@@ -634,7 +656,7 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 		drv->capture.rates		= RSND_RATES;
 		drv->capture.formats		= RSND_FMTS;
 		drv->capture.channels_min	= 2;
-		drv->capture.channels_max	= 2;
+		drv->capture.channels_max	= 6;
 		drv->capture.stream_name	= rdai->capture.name;
 
 		rdai->playback.rdai		= rdai;

commit 42ab9a791bd1fb6ad5a47ad66727dcd66093b1ae
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 30 08:53:44 2015 +0000

    ASoC: rsnd: dvc enables non-stereo sound
    
    Current DVC is assuming that the sound is always stereo.
    This patch makes it more flexible
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f990b4cb7192..7d364d7505a1 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -871,10 +871,14 @@ int rsnd_kctrl_new_m(struct rsnd_mod *mod,
 		     void (*update)(struct rsnd_dai_stream *io,
 				    struct rsnd_mod *mod),
 		     struct rsnd_kctrl_cfg_m *_cfg,
+		     int ch_size,
 		     u32 max)
 {
+	if (ch_size > RSND_DVC_CHANNELS)
+		return -EINVAL;
+
 	_cfg->cfg.max	= max;
-	_cfg->cfg.size	= RSND_DVC_CHANNELS;
+	_cfg->cfg.size	= ch_size;
 	_cfg->cfg.val	= _cfg->val;
 	return __rsnd_kctrl_new(mod, io, rtd, name, &_cfg->cfg, update);
 }

commit 8ec85e7f7e9a2f9c36a92596db53c30b1ca45f17
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 30 08:53:27 2015 +0000

    ASoC: rsnd: ssi enables non-stereo sound
    
    Current SSI is assuming that the sound is always stereo. But, SSI needs
    to calculate its frequency when master mode. Then This frequency depends
    on each SSI's slots, and TDM mode (= TDM Extend Mode, TDM split Mode,
    TDM Multichannel Mode).
    This patch enables to use non-stereo sound.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 81a6bdb6848c..f990b4cb7192 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -191,6 +191,34 @@ int rsnd_io_is_working(struct rsnd_dai_stream *io)
 	return !!io->substream;
 }
 
+int rsnd_get_slot_rdai(struct rsnd_dai *rdai)
+{
+	return rdai->slots;
+}
+
+int rsnd_get_slot_runtime(struct rsnd_dai_stream *io)
+{
+	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	int chan = rsnd_get_slot_rdai(rdai);
+
+	if (runtime->channels < chan)
+		chan = runtime->channels;
+
+	return chan;
+}
+
+int rsnd_get_slot_extend(struct rsnd_dai_stream *io)
+{
+	int chan = rsnd_get_slot_runtime(io);
+
+	/* TDM Extend Mode needs 8ch */
+	if (chan == 6)
+		chan = 8;
+
+	return chan;
+}
+
 /*
  *	ADINR function
  */
@@ -611,6 +639,7 @@ static int rsnd_dai_probe(struct rsnd_priv *priv)
 
 		rdai->playback.rdai		= rdai;
 		rdai->capture.rdai		= rdai;
+		rdai->slots			= 2; /* default */
 
 #define mod_parse(name)							\
 node = rsnd_##name##_of_node(priv);					\

commit a29d0f3ef934dd9eb2fbb51eb0f112f48046ee91
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 23 10:35:54 2015 +0100

    ASoC: rcar: remove unused variable
    
    After a recent cleanup, the soc_card variable became unused
    and now produces a warning:
    
    soc/sh/rcar/core.c: In function '__rsnd_kctrl_new':
    soc/sh/rcar/core.c:801:23: warning: unused variable 'soc_card' [-Wunused-variable]
    
    This removes the variable.
    
    Fixes: 1a497983a5ae ("ASoC: Change the PCM runtime array to a list")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8c4f54b0cb92..e1da5654fa25 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1033,7 +1033,6 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 			    void (*update)(struct rsnd_dai_stream *io,
 					   struct rsnd_mod *mod))
 {
-	struct snd_soc_card *soc_card = rtd->card;
 	struct snd_card *card = rtd->card->snd_card;
 	struct snd_kcontrol *kctrl;
 	struct snd_kcontrol_new knew = {

commit c51eb1c66e55bf23af4a10dd6e71c5a82c0e6d81
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 19 04:22:56 2015 +0000

    ASoC: rsnd: tidyup void* cast for 64bit compiler
    
    64bit compiler indicates this without this patch
    
    linux/sound/soc/sh/rcar/core.c: In function 'rsnd_probe':
    linux/sound/soc/sh/rcar/core.c:1002:16: warning: cast from pointer to\
         integer of different size [-Wpointer-to-int-cast]
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8dceae4b731a..81a6bdb6848c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -999,7 +999,7 @@ static int rsnd_probe(struct platform_device *pdev)
 	}
 
 	priv->pdev	= pdev;
-	priv->flags	= (u32)of_id->data;
+	priv->flags	= (unsigned long)of_id->data;
 	spin_lock_init(&priv->lock);
 
 	/*

commit 1a497983a5ae62b4970187183fb3b40e68515a24
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Wed Nov 18 02:34:11 2015 -0500

    ASoC: Change the PCM runtime array to a list
    
    Currently the number of DAI links is statically defined by the machine
    driver at build time using an array. This makes it difficult to shrink/
    grow the number of DAI links at runtime in order to reflect any changes
    in topology.
    
    We can change the DAI link array in the core to a list so that PCMs and
    FE DAI links can be added and deleted at runtime to reflect changes in
    use case and DSP topology. The machine driver can still register DAI links
    as an array.
    
    As the 1st step, this patch change the PCM runtime array to a list. A new
    PCM runtime is added to the list when a DAI link is bound successfully.
    
    Later patches will further implement the DAI link list.
    
    More:
    - define snd_soc_new/free_pcm_runtime() to create/free a runtime.
    - define soc_add_pcm_runtime() to add a runtime to the rtd list.
    - define soc_remove_pcm_runtimes() to clean up the runtime list.
    
    - traverse the rtd list to probe the link components and dais.
    
    - Add a field "num" to PCM runtime struct, used to specify the device
      number when creating the pcm device, and for a soc card to access
      its dai_props array.
    
    - The following 3rd party machine/platform drivers iterate the rtd list
      to check the runtimes:
      sound/soc/intel/atom/sst-mfld-platform-pcm.c
      sound/soc/intel/boards/cht_bsw_rt5645.c
      sound/soc/intel/boards/cht_bsw_rt5672.c
      sound/soc/intel/boards/cht_bsw_max98090_ti.c
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index deed48ef28b8..8c4f54b0cb92 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1040,7 +1040,7 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 		.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name		= name,
 		.info		= rsnd_kctrl_info,
-		.index		= rtd - soc_card->rtd,
+		.index		= rtd->num,
 		.get		= rsnd_kctrl_get,
 		.put		= rsnd_kctrl_put,
 		.private_value	= (unsigned long)cfg,

commit 2ea6b0749c366787dbf6e87c7642e23b448ca63b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:14:12 2015 +0000

    ASoC: rsnd: remove struct platform_device from probe/remove parameter
    
    Current Renesas sound driver requests struct platform_device on
    probe/remove for each modules. But driver can get it by
    rsnd_priv_to_pdev(). This patch removes unnecessary parameter
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8af166809629..8dceae4b731a 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -546,8 +546,7 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.set_fmt	= rsnd_soc_dai_set_fmt,
 };
 
-static int rsnd_dai_probe(struct platform_device *pdev,
-			  struct rsnd_priv *priv)
+static int rsnd_dai_probe(struct rsnd_priv *priv)
 {
 	struct device_node *dai_node;
 	struct device_node *dai_np, *np, *node;
@@ -556,7 +555,7 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 	struct rsnd_dai_stream *io_capture;
 	struct snd_soc_dai_driver *drv;
 	struct rsnd_dai *rdai;
-	struct device *dev = &pdev->dev;
+	struct device *dev = rsnd_priv_to_dev(priv);
 	int nr, dai_i, io_i, np_i;
 	int ret;
 
@@ -975,8 +974,7 @@ static int rsnd_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct rsnd_dai *rdai;
 	const struct of_device_id *of_id = of_match_device(rsnd_of_match, dev);
-	int (*probe_func[])(struct platform_device *pdev,
-			    struct rsnd_priv *priv) = {
+	int (*probe_func[])(struct rsnd_priv *priv) = {
 		rsnd_gen_probe,
 		rsnd_dma_probe,
 		rsnd_ssi_probe,
@@ -1008,7 +1006,7 @@ static int rsnd_probe(struct platform_device *pdev)
 	 *	init each module
 	 */
 	for (i = 0; i < ARRAY_SIZE(probe_func); i++) {
-		ret = probe_func[i](pdev, priv);
+		ret = probe_func[i](priv);
 		if (ret)
 			return ret;
 	}
@@ -1061,8 +1059,7 @@ static int rsnd_remove(struct platform_device *pdev)
 {
 	struct rsnd_priv *priv = dev_get_drvdata(&pdev->dev);
 	struct rsnd_dai *rdai;
-	void (*remove_func[])(struct platform_device *pdev,
-			      struct rsnd_priv *priv) = {
+	void (*remove_func[])(struct rsnd_priv *priv) = {
 		rsnd_ssi_remove,
 		rsnd_ssiu_remove,
 		rsnd_src_remove,
@@ -1082,7 +1079,7 @@ static int rsnd_remove(struct platform_device *pdev)
 	}
 
 	for (i = 0; i < ARRAY_SIZE(remove_func); i++)
-		remove_func[i](pdev, priv);
+		remove_func[i](priv);
 
 	snd_soc_unregister_component(&pdev->dev);
 	snd_soc_unregister_platform(&pdev->dev);

commit 2ea2cc86db7c73dc4e3a9fc3232cb04fe1b1ab91
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:13:53 2015 +0000

    ASoC: rsnd: remove struct rcar_snd_info
    
    No board is using Renesas sound driver via platform boot now.
    This means all user is using DT boot. Platform boot support is
    no longer needed. But, it strongly depends on platform boot style.
    Now, platform boot style was removed from driver.
    This is cleanup patch, and remove pointless struct rcar_snd_info
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8b9d721acb41..8af166809629 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -107,13 +107,6 @@ static const struct of_device_id rsnd_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, rsnd_of_match);
 
-/*
- *	rsnd_platform functions
- */
-#define rsnd_platform_call(priv, dai, func, param...)	\
-	(!(priv->info->func) ? 0 :		\
-	 priv->info->func(param))
-
 /*
  *	rsnd_mod functions
  */
@@ -457,7 +450,6 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	struct rsnd_priv *priv = rsnd_dai_to_priv(dai);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
-	int ssi_id = rsnd_mod_id(rsnd_io_to_mod_ssi(io));
 	int ret;
 	unsigned long flags;
 
@@ -467,10 +459,6 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_START:
 		rsnd_dai_stream_init(io, substream);
 
-		ret = rsnd_platform_call(priv, dai, start, ssi_id);
-		if (ret < 0)
-			goto dai_trigger_end;
-
 		ret = rsnd_dai_call(init, io, priv);
 		if (ret < 0)
 			goto dai_trigger_end;
@@ -484,8 +472,6 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 
 		ret |= rsnd_dai_call(quit, io, priv);
 
-		ret |= rsnd_platform_call(priv, dai, stop, ssi_id);
-
 		rsnd_dai_stream_quit(io);
 		break;
 	default:
@@ -985,7 +971,6 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
  */
 static int rsnd_probe(struct platform_device *pdev)
 {
-	struct rcar_snd_info *info;
 	struct rsnd_priv *priv;
 	struct device *dev = &pdev->dev;
 	struct rsnd_dai *rdai;
@@ -1006,11 +991,6 @@ static int rsnd_probe(struct platform_device *pdev)
 	};
 	int ret, i;
 
-	info = devm_kzalloc(&pdev->dev, sizeof(struct rcar_snd_info),
-			    GFP_KERNEL);
-	if (!info)
-		return -ENOMEM;
-
 	/*
 	 *	init priv data
 	 */
@@ -1021,7 +1001,6 @@ static int rsnd_probe(struct platform_device *pdev)
 	}
 
 	priv->pdev	= pdev;
-	priv->info	= info;
 	priv->flags	= (u32)of_id->data;
 	spin_lock_init(&priv->lock);
 

commit e797f58ead6069478e535ae62b180da87b28a84f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:13:33 2015 +0000

    ASoC: rsnd: remove struct rsnd_of_data
    
    No board is using Renesas sound driver via platform boot now.
    This means all user is using DT boot. Platform boot support is
    no longer needed. But, it strongly depends on platform boot style.
    Now, platform boot style was removed from driver.
    This is cleanup patch, and remove pointless struct rsnd_of_data
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 6043c71d10c9..8b9d721acb41 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -99,18 +99,10 @@
 #define RSND_RATES SNDRV_PCM_RATE_8000_96000
 #define RSND_FMTS (SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE)
 
-static const struct rsnd_of_data rsnd_of_data_gen1 = {
-	.flags = RSND_GEN1,
-};
-
-static const struct rsnd_of_data rsnd_of_data_gen2 = {
-	.flags = RSND_GEN2,
-};
-
 static const struct of_device_id rsnd_of_match[] = {
-	{ .compatible = "renesas,rcar_sound-gen1", .data = &rsnd_of_data_gen1 },
-	{ .compatible = "renesas,rcar_sound-gen2", .data = &rsnd_of_data_gen2 },
-	{ .compatible = "renesas,rcar_sound-gen3", .data = &rsnd_of_data_gen2 }, /* gen2 compatible */
+	{ .compatible = "renesas,rcar_sound-gen1", .data = (void *)RSND_GEN1 },
+	{ .compatible = "renesas,rcar_sound-gen2", .data = (void *)RSND_GEN2 },
+	{ .compatible = "renesas,rcar_sound-gen3", .data = (void *)RSND_GEN2 }, /* gen2 compatible */
 	{},
 };
 MODULE_DEVICE_TABLE(of, rsnd_of_match);
@@ -569,7 +561,6 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 };
 
 static int rsnd_dai_probe(struct platform_device *pdev,
-			  const struct rsnd_of_data *of_data,
 			  struct rsnd_priv *priv)
 {
 	struct device_node *dai_node;
@@ -583,9 +574,6 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 	int nr, dai_i, io_i, np_i;
 	int ret;
 
-	if (!of_data)
-		return 0;
-
 	dai_node = rsnd_dai_of_node(priv);
 	nr = of_get_child_count(dai_node);
 	if (!nr) {
@@ -1002,9 +990,7 @@ static int rsnd_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct rsnd_dai *rdai;
 	const struct of_device_id *of_id = of_match_device(rsnd_of_match, dev);
-	const struct rsnd_of_data *of_data;
 	int (*probe_func[])(struct platform_device *pdev,
-			    const struct rsnd_of_data *of_data,
 			    struct rsnd_priv *priv) = {
 		rsnd_gen_probe,
 		rsnd_dma_probe,
@@ -1024,7 +1010,6 @@ static int rsnd_probe(struct platform_device *pdev)
 			    GFP_KERNEL);
 	if (!info)
 		return -ENOMEM;
-	of_data = of_id->data;
 
 	/*
 	 *	init priv data
@@ -1037,14 +1022,14 @@ static int rsnd_probe(struct platform_device *pdev)
 
 	priv->pdev	= pdev;
 	priv->info	= info;
-	priv->flags	= of_data->flags;
+	priv->flags	= (u32)of_id->data;
 	spin_lock_init(&priv->lock);
 
 	/*
 	 *	init each module
 	 */
 	for (i = 0; i < ARRAY_SIZE(probe_func); i++) {
-		ret = probe_func[i](pdev, of_data, priv);
+		ret = probe_func[i](pdev, priv);
 		if (ret)
 			return ret;
 	}

commit 348d592c719da61a7dab289c7ce36e73c7caf063
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:13:12 2015 +0000

    ASoC: rsnd: remove platform boot support from gen.c
    
    No board is using Renesas sound driver via platform boot now.
    This means all user is using DT boot. Platform boot support is
    no longer needed. But, it strongly depends on platform boot style.
    This patch removes platform boot support from gen.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 039d6cba8414..6043c71d10c9 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1037,6 +1037,7 @@ static int rsnd_probe(struct platform_device *pdev)
 
 	priv->pdev	= pdev;
 	priv->info	= info;
+	priv->flags	= of_data->flags;
 	spin_lock_init(&priv->lock);
 
 	/*

commit 94e2710cd2ce447cde879177d869b9ac231bc459
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:11:18 2015 +0000

    ASoC: rsnd: remove platform boot support from core.c
    
    No board is using Renesas sound driver via platform boot now.
    This means all user is using DT boot. Platform boot support is
    no longer needed. But, it strongly depends on platform boot style.
    This patch removes platform boot support from core.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 81250cf6788d..039d6cba8414 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -122,11 +122,6 @@ MODULE_DEVICE_TABLE(of, rsnd_of_match);
 	(!(priv->info->func) ? 0 :		\
 	 priv->info->func(param))
 
-#define rsnd_is_enable_path(io, name) \
-	((io)->info ? (io)->info->name : NULL)
-#define rsnd_info_id(priv, io, name) \
-	((io)->info->name - priv->info->name##_info)
-
 /*
  *	rsnd_mod functions
  */
@@ -573,140 +568,96 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.set_fmt	= rsnd_soc_dai_set_fmt,
 };
 
-#define rsnd_path_add(priv, io, _type)				\
-({								\
-	struct rsnd_mod *mod;					\
-	int ret = 0;						\
-	int id = -1;						\
-								\
-	if (rsnd_is_enable_path(io, _type)) {			\
-		id = rsnd_info_id(priv, io, _type);		\
-		if (id >= 0) {					\
-			mod = rsnd_##_type##_mod_get(priv, id);	\
-			ret = rsnd_dai_connect(mod, io, mod->type);\
-		}						\
-	}							\
-	ret;							\
-})
-
-static int rsnd_path_init(struct rsnd_priv *priv,
-			  struct rsnd_dai *rdai,
-			  struct rsnd_dai_stream *io)
-{
-	int ret;
-
-	/*
-	 * Gen1 is created by SRU/SSI, and this SRU is base module of
-	 * Gen2's SCU/SSIU/SSI. (Gen2 SCU/SSIU came from SRU)
-	 *
-	 * Easy image is..
-	 *	Gen1 SRU = Gen2 SCU + SSIU + etc
-	 *
-	 * Gen2 SCU path is very flexible, but, Gen1 SRU (SCU parts) is
-	 * using fixed path.
-	 */
-
-	/* SSI */
-	ret = rsnd_path_add(priv, io, ssi);
-	if (ret < 0)
-		return ret;
-
-	/* SRC */
-	ret = rsnd_path_add(priv, io, src);
-	if (ret < 0)
-		return ret;
-
-	/* CTU */
-	ret = rsnd_path_add(priv, io, ctu);
-	if (ret < 0)
-		return ret;
-
-	/* MIX */
-	ret = rsnd_path_add(priv, io, mix);
-	if (ret < 0)
-		return ret;
-
-	/* DVC */
-	ret = rsnd_path_add(priv, io, dvc);
-	if (ret < 0)
-		return ret;
-
-	return ret;
-}
-
-static void rsnd_of_parse_dai(struct platform_device *pdev,
-			      const struct rsnd_of_data *of_data,
-			      struct rsnd_priv *priv)
+static int rsnd_dai_probe(struct platform_device *pdev,
+			  const struct rsnd_of_data *of_data,
+			  struct rsnd_priv *priv)
 {
-	struct device_node *dai_node,	*dai_np;
-	struct device_node *ssi_node,	*ssi_np;
-	struct device_node *src_node,	*src_np;
-	struct device_node *ctu_node,	*ctu_np;
-	struct device_node *mix_node,	*mix_np;
-	struct device_node *dvc_node,	*dvc_np;
+	struct device_node *dai_node;
+	struct device_node *dai_np, *np, *node;
 	struct device_node *playback, *capture;
-	struct rsnd_dai_platform_info *dai_info;
-	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
+	struct rsnd_dai_stream *io_playback;
+	struct rsnd_dai_stream *io_capture;
+	struct snd_soc_dai_driver *drv;
+	struct rsnd_dai *rdai;
 	struct device *dev = &pdev->dev;
-	int nr, i;
-	int dai_i, ssi_i, src_i, ctu_i, mix_i, dvc_i;
+	int nr, dai_i, io_i, np_i;
+	int ret;
 
 	if (!of_data)
-		return;
-
-	dai_node = of_get_child_by_name(dev->of_node, "rcar_sound,dai");
-	if (!dai_node)
-		return;
+		return 0;
 
+	dai_node = rsnd_dai_of_node(priv);
 	nr = of_get_child_count(dai_node);
-	if (!nr)
-		return;
-
-	dai_info = devm_kzalloc(dev,
-				sizeof(struct rsnd_dai_platform_info) * nr,
-				GFP_KERNEL);
-	if (!dai_info) {
-		dev_err(dev, "dai info allocation error\n");
-		return;
+	if (!nr) {
+		ret = -EINVAL;
+		goto rsnd_dai_probe_done;
 	}
 
-	info->dai_info_nr	= nr;
-	info->dai_info		= dai_info;
-
-	ssi_node = of_get_child_by_name(dev->of_node, "rcar_sound,ssi");
-	src_node = of_get_child_by_name(dev->of_node, "rcar_sound,src");
-	ctu_node = of_get_child_by_name(dev->of_node, "rcar_sound,ctu");
-	mix_node = of_get_child_by_name(dev->of_node, "rcar_sound,mix");
-	dvc_node = of_get_child_by_name(dev->of_node, "rcar_sound,dvc");
+	drv  = devm_kzalloc(dev, sizeof(*drv)  * nr, GFP_KERNEL);
+	rdai = devm_kzalloc(dev, sizeof(*rdai) * nr, GFP_KERNEL);
+	if (!drv || !rdai) {
+		ret = -ENOMEM;
+		goto rsnd_dai_probe_done;
+	}
 
-#define mod_parse(name)							\
-if (name##_node) {							\
-	struct rsnd_##name##_platform_info *name##_info;		\
-									\
-	name##_i = 0;							\
-	for_each_child_of_node(name##_node, name##_np) {		\
-		name##_info = info->name##_info + name##_i;		\
-									\
-		if (name##_np == playback)				\
-			dai_info->playback.name = name##_info;		\
-		if (name##_np == capture)				\
-			dai_info->capture.name = name##_info;		\
-									\
-		name##_i++;						\
-	}								\
-}
+	priv->rdai_nr	= nr;
+	priv->daidrv	= drv;
+	priv->rdai	= rdai;
 
 	/*
 	 * parse all dai
 	 */
 	dai_i = 0;
 	for_each_child_of_node(dai_node, dai_np) {
-		dai_info = info->dai_info + dai_i;
+		rdai		= rsnd_rdai_get(priv, dai_i);
+		drv		= drv + dai_i;
+		io_playback	= &rdai->playback;
+		io_capture	= &rdai->capture;
+
+		snprintf(rdai->name, RSND_DAI_NAME_SIZE, "rsnd-dai.%d", dai_i);
+
+		rdai->priv	= priv;
+		drv->name	= rdai->name;
+		drv->ops	= &rsnd_soc_dai_ops;
+
+		snprintf(rdai->playback.name, RSND_DAI_NAME_SIZE,
+			 "DAI%d Playback", dai_i);
+		drv->playback.rates		= RSND_RATES;
+		drv->playback.formats		= RSND_FMTS;
+		drv->playback.channels_min	= 2;
+		drv->playback.channels_max	= 2;
+		drv->playback.stream_name	= rdai->playback.name;
+
+		snprintf(rdai->capture.name, RSND_DAI_NAME_SIZE,
+			 "DAI%d Capture", dai_i);
+		drv->capture.rates		= RSND_RATES;
+		drv->capture.formats		= RSND_FMTS;
+		drv->capture.channels_min	= 2;
+		drv->capture.channels_max	= 2;
+		drv->capture.stream_name	= rdai->capture.name;
+
+		rdai->playback.rdai		= rdai;
+		rdai->capture.rdai		= rdai;
 
-		for (i = 0;; i++) {
+#define mod_parse(name)							\
+node = rsnd_##name##_of_node(priv);					\
+if (node) {								\
+	struct rsnd_mod *mod;						\
+	np_i = 0;							\
+	for_each_child_of_node(node, np) {				\
+		mod = rsnd_##name##_mod_get(priv, np_i);		\
+		if (np == playback)					\
+			rsnd_dai_connect(mod, io_playback, mod->type);	\
+		if (np == capture)					\
+			rsnd_dai_connect(mod, io_capture, mod->type);	\
+		np_i++;							\
+	}								\
+	of_node_put(node);						\
+}
 
-			playback = of_parse_phandle(dai_np, "playback", i);
-			capture  = of_parse_phandle(dai_np, "capture", i);
+		for (io_i = 0;; io_i++) {
+			playback = of_parse_phandle(dai_np, "playback", io_i);
+			capture  = of_parse_phandle(dai_np, "capture", io_i);
 
 			if (!playback && !capture)
 				break;
@@ -722,91 +673,18 @@ if (name##_node) {							\
 		}
 
 		dai_i++;
-	}
-}
-
-static int rsnd_dai_probe(struct platform_device *pdev,
-			  const struct rsnd_of_data *of_data,
-			  struct rsnd_priv *priv)
-{
-	struct snd_soc_dai_driver *drv;
-	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
-	struct rsnd_dai *rdai;
-	struct rsnd_ssi_platform_info *pmod, *cmod;
-	struct device *dev = rsnd_priv_to_dev(priv);
-	int dai_nr;
-	int i;
-
-	rsnd_of_parse_dai(pdev, of_data, priv);
 
-	dai_nr = info->dai_info_nr;
-	if (!dai_nr) {
-		dev_err(dev, "no dai\n");
-		return -EIO;
-	}
-
-	drv  = devm_kzalloc(dev, sizeof(*drv)  * dai_nr, GFP_KERNEL);
-	rdai = devm_kzalloc(dev, sizeof(*rdai) * dai_nr, GFP_KERNEL);
-	if (!drv || !rdai) {
-		dev_err(dev, "dai allocate failed\n");
-		return -ENOMEM;
+		dev_dbg(dev, "%s (%s/%s)\n", rdai->name,
+			rsnd_io_to_mod_ssi(io_playback) ? "play"    : " -- ",
+			rsnd_io_to_mod_ssi(io_capture) ? "capture" : "  --   ");
 	}
 
-	priv->rdai_nr	= dai_nr;
-	priv->daidrv	= drv;
-	priv->rdai	= rdai;
-
-	for (i = 0; i < dai_nr; i++) {
-
-		pmod = info->dai_info[i].playback.ssi;
-		cmod = info->dai_info[i].capture.ssi;
-
-		/*
-		 *	init rsnd_dai
-		 */
-		snprintf(rdai[i].name, RSND_DAI_NAME_SIZE, "rsnd-dai.%d", i);
-		rdai[i].priv = priv;
-
-		/*
-		 *	init snd_soc_dai_driver
-		 */
-		drv[i].name	= rdai[i].name;
-		drv[i].ops	= &rsnd_soc_dai_ops;
-		if (pmod) {
-			snprintf(rdai[i].playback.name, RSND_DAI_NAME_SIZE,
-				 "DAI%d Playback", i);
-
-			drv[i].playback.rates		= RSND_RATES;
-			drv[i].playback.formats		= RSND_FMTS;
-			drv[i].playback.channels_min	= 2;
-			drv[i].playback.channels_max	= 2;
-			drv[i].playback.stream_name	= rdai[i].playback.name;
-
-			rdai[i].playback.info = &info->dai_info[i].playback;
-			rdai[i].playback.rdai = rdai + i;
-			rsnd_path_init(priv, &rdai[i], &rdai[i].playback);
-		}
-		if (cmod) {
-			snprintf(rdai[i].capture.name, RSND_DAI_NAME_SIZE,
-				 "DAI%d Capture", i);
-
-			drv[i].capture.rates		= RSND_RATES;
-			drv[i].capture.formats		= RSND_FMTS;
-			drv[i].capture.channels_min	= 2;
-			drv[i].capture.channels_max	= 2;
-			drv[i].capture.stream_name	= rdai[i].capture.name;
-
-			rdai[i].capture.info = &info->dai_info[i].capture;
-			rdai[i].capture.rdai = rdai + i;
-			rsnd_path_init(priv, &rdai[i], &rdai[i].capture);
-		}
+	ret = 0;
 
-		dev_dbg(dev, "%s (%s/%s)\n", rdai[i].name,
-			pmod ? "play"    : " -- ",
-			cmod ? "capture" : "  --   ");
-	}
+rsnd_dai_probe_done:
+	of_node_put(dai_node);
 
-	return 0;
+	return ret;
 }
 
 /*

commit 68a550248e295ba548e30c876ccdec351e286eee
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 5 08:51:15 2015 +0000

    ASoC: rsnd: call clk_prepare()/clk_enable() for AUDIO_CLKx
    
    ADG can output AUDIO_CLKOUTx, and these are generated from
    AUDIO_CLKx. Thus we need to call clk_prepare()/clk_enable()
    for AUDIO_CLKx.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1363966fa957..81250cf6788d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1227,6 +1227,7 @@ static int rsnd_remove(struct platform_device *pdev)
 		rsnd_mix_remove,
 		rsnd_dvc_remove,
 		rsnd_cmd_remove,
+		rsnd_adg_remove,
 	};
 	int ret = 0, i;
 

commit 81ad174db5ca8f372da6dc31a4ca25d52f9bec5f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 5 08:50:10 2015 +0000

    ASoC: rsnd: tidyup comment position of rsnd_mod_xxx
    
    f1df12290("ASoC: rsnd: add common mod confirm method")
    added rsnd_mod_make_sure(), but rsnd_mod_xxx() comment position
    was wrong. This patch tidyup it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 5586b888db56..1363966fa957 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -127,6 +127,9 @@ MODULE_DEVICE_TABLE(of, rsnd_of_match);
 #define rsnd_info_id(priv, io, name) \
 	((io)->info->name - priv->info->name##_info)
 
+/*
+ *	rsnd_mod functions
+ */
 void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
 {
 	if (mod->type != type) {
@@ -138,9 +141,6 @@ void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
 	}
 }
 
-/*
- *	rsnd_mod functions
- */
 char *rsnd_mod_name(struct rsnd_mod *mod)
 {
 	if (!mod || !mod->ops)

commit c7f69ab5364da21a2fc7f01c5bc32a5b5b5fee5d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:43:41 2015 +0000

    ASoC: rsnd: use mod base common method on SSIU
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    This patch makes SSIU mod base common method
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1cbd20f311b8..5586b888db56 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1131,6 +1131,7 @@ static int rsnd_probe(struct platform_device *pdev)
 		rsnd_gen_probe,
 		rsnd_dma_probe,
 		rsnd_ssi_probe,
+		rsnd_ssiu_probe,
 		rsnd_src_probe,
 		rsnd_ctu_probe,
 		rsnd_mix_probe,
@@ -1220,6 +1221,7 @@ static int rsnd_remove(struct platform_device *pdev)
 	void (*remove_func[])(struct platform_device *pdev,
 			      struct rsnd_priv *priv) = {
 		rsnd_ssi_remove,
+		rsnd_ssiu_remove,
 		rsnd_src_remove,
 		rsnd_ctu_remove,
 		rsnd_mix_remove,

commit 1b2ca0adf1a0cb3aa766259650eddd25b44486b7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:43:21 2015 +0000

    ASoC: rsnd: use mod base common method on CMD
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    This patch makes CMD mod base common method
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8af2d22d0cd3..1cbd20f311b8 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -589,79 +589,6 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	ret;							\
 })
 
-void rsnd_path_parse(struct rsnd_priv *priv,
-		     struct rsnd_dai_stream *io)
-{
-	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
-	struct rsnd_mod *mix = rsnd_io_to_mod_mix(io);
-	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
-	struct rsnd_mod *cmd;
-	struct device *dev = rsnd_priv_to_dev(priv);
-	u32 data;
-
-	/* Gen1 is not supported */
-	if (rsnd_is_gen1(priv))
-		return;
-
-	if (!mix && !dvc)
-		return;
-
-	if (mix) {
-		struct rsnd_dai *rdai;
-		int i;
-		u32 path[] = {
-			[0] = 0,
-			[1] = 1 << 0,
-			[2] = 0,
-			[3] = 0,
-			[4] = 0,
-			[5] = 1 << 8
-		};
-
-		/*
-		 * it is assuming that integrater is well understanding about
-		 * data path. Here doesn't check impossible connection,
-		 * like src2 + src5
-		 */
-		data = 0;
-		for_each_rsnd_dai(rdai, priv, i) {
-			io = &rdai->playback;
-			if (mix == rsnd_io_to_mod_mix(io))
-				data |= path[rsnd_mod_id(src)];
-
-			io = &rdai->capture;
-			if (mix == rsnd_io_to_mod_mix(io))
-				data |= path[rsnd_mod_id(src)];
-		}
-
-		/*
-		 * We can't use ctu = rsnd_io_ctu() here.
-		 * Since, ID of dvc/mix are 0 or 1 (= same as CMD number)
-		 * but ctu IDs are 0 - 7 (= CTU00 - CTU13)
-		 */
-		cmd = mix;
-	} else {
-		u32 path[] = {
-			[0] = 0x30000,
-			[1] = 0x30001,
-			[2] = 0x40000,
-			[3] = 0x10000,
-			[4] = 0x20000,
-			[5] = 0x40100
-		};
-
-		data = path[rsnd_mod_id(src)];
-
-		cmd = dvc;
-	}
-
-	dev_dbg(dev, "ctu/mix path = 0x%08x", data);
-
-	rsnd_mod_write(cmd, CMD_ROUTE_SLCT, data);
-
-	rsnd_mod_write(cmd, CMD_CTRL, 0x10);
-}
-
 static int rsnd_path_init(struct rsnd_priv *priv,
 			  struct rsnd_dai *rdai,
 			  struct rsnd_dai_stream *io)
@@ -1208,6 +1135,7 @@ static int rsnd_probe(struct platform_device *pdev)
 		rsnd_ctu_probe,
 		rsnd_mix_probe,
 		rsnd_dvc_probe,
+		rsnd_cmd_probe,
 		rsnd_adg_probe,
 		rsnd_dai_probe,
 	};
@@ -1296,6 +1224,7 @@ static int rsnd_remove(struct platform_device *pdev)
 		rsnd_ctu_remove,
 		rsnd_mix_remove,
 		rsnd_dvc_remove,
+		rsnd_cmd_remove,
 	};
 	int ret = 0, i;
 

commit 2daf71ad8da6cb57f919c9c876ee7e42530371df
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:41:53 2015 +0000

    ASoC: rsnd: avoid pointless loop in rsnd_mod_interrupt()
    
    Current Renesas sound driver doesn't have 1:1 relationship between
    stream <-> mod because it is supporting MIX. Because of this reason
    rsnd_mod_interrupt() is searching correspond mod by for loop.
    But this loop is not needed, because each mod has own type.
    This patch avoid pointless loop by using mod->type.
    
    This patch is good for SSI-parent support, because stream might have
    2 SSI as SSI-parent/child. SSI interrupt handler will be called twice
    if stream has SSI-parent without this patch.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 5f20d6776281..8af2d22d0cd3 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -192,19 +192,16 @@ void rsnd_mod_interrupt(struct rsnd_mod *mod,
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct rsnd_dai_stream *io;
 	struct rsnd_dai *rdai;
-	int i, j;
-
-	for_each_rsnd_dai(rdai, priv, j) {
+	int i;
 
-		for (i = 0; i < RSND_MOD_MAX; i++) {
-			io = &rdai->playback;
-			if (mod == io->mod[i])
-				callback(mod, io);
+	for_each_rsnd_dai(rdai, priv, i) {
+		io = &rdai->playback;
+		if (mod == io->mod[mod->type])
+			callback(mod, io);
 
-			io = &rdai->capture;
-			if (mod == io->mod[i])
-				callback(mod, io);
-		}
+		io = &rdai->capture;
+		if (mod == io->mod[mod->type])
+			callback(mod, io);
 	}
 }
 

commit c2dc47d5cff62bfe21a691bef40eb30a585caa3c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:41:17 2015 +0000

    ASoC: rsnd: rsnd_dai_stream has each mod's status insted of rsnd_mod
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    Current rsnd is controling each mod's status on mod. But it was not
    good design for SSI, because stream might has SSI-parent.
    In such case, it can't play/capture in same time, because SSI-parent
    is used as normal SSI in other stream, but it shares same status.
    To avoid this issue each mod's status is controlled by rsnd_dai_stream
    instead of rsnd_mod.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b6fc0d86c03d..5f20d6776281 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -300,20 +300,22 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 /*
  *	rsnd_dai functions
  */
-#define rsnd_mod_call(mod, io, func, param...)			\
+#define rsnd_mod_call(idx, io, func, param...)			\
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
+	struct rsnd_mod *mod = (io)->mod[idx];			\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
+	u32 *status = (io)->mod_status + idx;			\
 	u32 mask = 0xF << __rsnd_mod_shift_##func;			\
-	u8 val  = (mod->status >> __rsnd_mod_shift_##func) & 0xF;	\
+	u8 val  = (*status >> __rsnd_mod_shift_##func) & 0xF;		\
 	u8 add  = ((val + __rsnd_mod_add_##func) & 0xF);		\
 	int ret = 0;							\
 	int call = (val == __rsnd_mod_call_##func) && (mod)->ops->func;	\
-	mod->status = (mod->status & ~mask) +				\
+	*status = (*status & ~mask) +					\
 		(add << __rsnd_mod_shift_##func);			\
 	dev_dbg(dev, "%s[%d]\t0x%08x %s\n",				\
 		rsnd_mod_name(mod), rsnd_mod_id(mod),			\
-		mod->status, call ? #func : "");			\
+		*status, call ? #func : "");				\
 	if (call)							\
 		ret = (mod)->ops->func(mod, io, param);			\
 	ret;								\
@@ -327,7 +329,7 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 		mod = (io)->mod[i];				\
 		if (!mod)					\
 			continue;				\
-		ret |= rsnd_mod_call(mod, io, fn, param);	\
+		ret |= rsnd_mod_call(i, io, fn, param);		\
 	}							\
 	ret;							\
 })

commit 48d582819fdc38cda1aeb17f26cfe586d3900f2f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:40:02 2015 +0000

    ASoC: rsnd: remove all modules when PIO fallback
    
    Current Renesas sound is supporting PIO fallback if it can't use DMA.
    In such case, it should remove all attached modules, but current driver
    is missing about CTU/MIX. Because current implement requests
    specific mod for remove.
    To avoid same things in future, this patch removes all mods,
    and re-connects SSI when PIO fallback case.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index d7d2a59d0553..b6fc0d86c03d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -590,20 +590,6 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	ret;							\
 })
 
-#define rsnd_path_remove(priv, io, _type)			\
-{								\
-	struct rsnd_mod *mod;					\
-	int id = -1;						\
-								\
-	if (rsnd_is_enable_path(io, _type)) {			\
-		id = rsnd_info_id(priv, io, _type);		\
-		if (id >= 0) {					\
-			mod = rsnd_##_type##_mod_get(priv, id);	\
-			rsnd_dai_disconnect(mod, io, mod->type);\
-		}						\
-	}							\
-}
-
 void rsnd_path_parse(struct rsnd_priv *priv,
 		     struct rsnd_dai_stream *io)
 {
@@ -1163,6 +1149,9 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 
 	ret = rsnd_dai_call(probe, io, priv);
 	if (ret == -EAGAIN) {
+		struct rsnd_mod *ssi_mod = rsnd_io_to_mod_ssi(io);
+		int i;
+
 		/*
 		 * Fallback to PIO mode
 		 */
@@ -1177,10 +1166,12 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 		rsnd_dai_call(remove, io, priv);
 
 		/*
-		 * remove SRC/DVC from DAI,
+		 * remove all mod from io
+		 * and, re connect ssi
 		 */
-		rsnd_path_remove(priv, io, src);
-		rsnd_path_remove(priv, io, dvc);
+		for (i = 0; i < RSND_MOD_MAX; i++)
+			rsnd_dai_disconnect((io)->mod[i], io, i);
+		rsnd_dai_connect(ssi_mod, io, RSND_MOD_SSI);
 
 		/*
 		 * fallback

commit 27924f3208c9f37a1d58b80d999bb9cfc96536d4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:39:41 2015 +0000

    ASoC: rsnd: enable to use rsnd_dai_connect() from each mod
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    DMAC/SSIU/SSI-parent/CMD will be implemented as module, but these are
    not customer controlled module. These should be automatically install
    to system. Because of this, rsnd_dai_connect() should be called from
    each mod. SSI can be very special, because it will be installed as
    SSI-parent / SSI-child. Thus, new rsnd_dai_connect() has type parameter
    which should be mod->type except SSI-parent
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index deed48ef28b8..d7d2a59d0553 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -332,8 +332,9 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	ret;							\
 })
 
-static int rsnd_dai_connect(struct rsnd_mod *mod,
-			    struct rsnd_dai_stream *io)
+int rsnd_dai_connect(struct rsnd_mod *mod,
+		     struct rsnd_dai_stream *io,
+		     enum rsnd_mod_type type)
 {
 	struct rsnd_priv *priv;
 	struct device *dev;
@@ -344,7 +345,7 @@ static int rsnd_dai_connect(struct rsnd_mod *mod,
 	priv = rsnd_mod_to_priv(mod);
 	dev = rsnd_priv_to_dev(priv);
 
-	io->mod[mod->type] = mod;
+	io->mod[type] = mod;
 
 	dev_dbg(dev, "%s[%d] is connected to io (%s)\n",
 		rsnd_mod_name(mod), rsnd_mod_id(mod),
@@ -354,9 +355,10 @@ static int rsnd_dai_connect(struct rsnd_mod *mod,
 }
 
 static void rsnd_dai_disconnect(struct rsnd_mod *mod,
-				struct rsnd_dai_stream *io)
+				struct rsnd_dai_stream *io,
+				enum rsnd_mod_type type)
 {
-	io->mod[mod->type] = NULL;
+	io->mod[type] = NULL;
 }
 
 struct rsnd_dai *rsnd_rdai_get(struct rsnd_priv *priv, int id)
@@ -572,32 +574,32 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.set_fmt	= rsnd_soc_dai_set_fmt,
 };
 
-#define rsnd_path_add(priv, io, type)				\
+#define rsnd_path_add(priv, io, _type)				\
 ({								\
 	struct rsnd_mod *mod;					\
 	int ret = 0;						\
 	int id = -1;						\
 								\
-	if (rsnd_is_enable_path(io, type)) {			\
-		id = rsnd_info_id(priv, io, type);		\
+	if (rsnd_is_enable_path(io, _type)) {			\
+		id = rsnd_info_id(priv, io, _type);		\
 		if (id >= 0) {					\
-			mod = rsnd_##type##_mod_get(priv, id);	\
-			ret = rsnd_dai_connect(mod, io);	\
+			mod = rsnd_##_type##_mod_get(priv, id);	\
+			ret = rsnd_dai_connect(mod, io, mod->type);\
 		}						\
 	}							\
 	ret;							\
 })
 
-#define rsnd_path_remove(priv, io, type)			\
+#define rsnd_path_remove(priv, io, _type)			\
 {								\
 	struct rsnd_mod *mod;					\
 	int id = -1;						\
 								\
-	if (rsnd_is_enable_path(io, type)) {			\
-		id = rsnd_info_id(priv, io, type);		\
+	if (rsnd_is_enable_path(io, _type)) {			\
+		id = rsnd_info_id(priv, io, _type);		\
 		if (id >= 0) {					\
-			mod = rsnd_##type##_mod_get(priv, id);	\
-			rsnd_dai_disconnect(mod, io);		\
+			mod = rsnd_##_type##_mod_get(priv, id);	\
+			rsnd_dai_disconnect(mod, io, mod->type);\
 		}						\
 	}							\
 }

commit 89e3e2c352a523be46be5104bf18e200a8ccd444
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Oct 22 03:14:43 2015 +0000

    ASoC: rsnd: fixup rsnd_dai_call() behavior for .stop/.quit
    
    Current rsnd_dai_call returns immediately if rsnd_mod_call return fail.
    Thus, each callback-count can be unbalanced for example .init was OK,
    start was OK, but, .stop was not OK. This case .quit should be called
    but isn't called. And, rsnd_dai_stream_quit() also not be called.
    rsnd_dai_call() should call all .stop/.quit eventhough it returns error.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 5c6714481f59..deed48ef28b8 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -327,9 +327,7 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 		mod = (io)->mod[i];				\
 		if (!mod)					\
 			continue;				\
-		ret = rsnd_mod_call(mod, io, fn, param);	\
-		if (ret < 0)					\
-			break;					\
+		ret |= rsnd_mod_call(mod, io, fn, param);	\
 	}							\
 	ret;							\
 })
@@ -495,16 +493,10 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 		ret = rsnd_dai_call(stop, io, priv);
-		if (ret < 0)
-			goto dai_trigger_end;
 
-		ret = rsnd_dai_call(quit, io, priv);
-		if (ret < 0)
-			goto dai_trigger_end;
+		ret |= rsnd_dai_call(quit, io, priv);
 
-		ret = rsnd_platform_call(priv, dai, stop, ssi_id);
-		if (ret < 0)
-			goto dai_trigger_end;
+		ret |= rsnd_platform_call(priv, dai, stop, ssi_id);
 
 		rsnd_dai_stream_quit(io);
 		break;

commit 32a96d558d02581c32b09401b8aa5eecb3965d3e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Oct 22 03:14:21 2015 +0000

    ASoC: rsnd: fixup rsnd_dai_call() behavior for unimplemented method
    
    Current rsnd_dai_call didn't count callback-count if callback
    wasn't implemented. Thus, it counts can be unbalance.
    ex) .start : implemented
        .stop  : not implemented
    This patch solve this issue
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index c0182ac254c9..5c6714481f59 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -300,7 +300,7 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 /*
  *	rsnd_dai functions
  */
-#define __rsnd_mod_call(mod, io, func, param...)		\
+#define rsnd_mod_call(mod, io, func, param...)			\
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
@@ -308,7 +308,7 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	u8 val  = (mod->status >> __rsnd_mod_shift_##func) & 0xF;	\
 	u8 add  = ((val + __rsnd_mod_add_##func) & 0xF);		\
 	int ret = 0;							\
-	int call = (val == __rsnd_mod_call_##func);			\
+	int call = (val == __rsnd_mod_call_##func) && (mod)->ops->func;	\
 	mod->status = (mod->status & ~mask) +				\
 		(add << __rsnd_mod_shift_##func);			\
 	dev_dbg(dev, "%s[%d]\t0x%08x %s\n",				\
@@ -319,11 +319,6 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	ret;								\
 })
 
-#define rsnd_mod_call(mod, io, func, param...)	\
-	(!(mod) ? -ENODEV :			\
-	 !((mod)->ops->func) ? 0 :		\
-	 __rsnd_mod_call(mod, io, func, param))
-
 #define rsnd_dai_call(fn, io, param...)				\
 ({								\
 	struct rsnd_mod *mod;					\

commit 1355720a3b3eba5604431d89d5cf69ce4ad51311
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Oct 22 03:14:02 2015 +0000

    ASoC: rsnd: fixup rsnd_mod_call() behavior for debug
    
    Indicating each module method as debug message before executing is
    readable/understandable.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 6ef9a884ca7c..c0182ac254c9 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -308,16 +308,14 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	u8 val  = (mod->status >> __rsnd_mod_shift_##func) & 0xF;	\
 	u8 add  = ((val + __rsnd_mod_add_##func) & 0xF);		\
 	int ret = 0;							\
-	int called = 0;							\
-	if (val == __rsnd_mod_call_##func) {				\
-		called = 1;						\
-		ret = (mod)->ops->func(mod, io, param);			\
-	}								\
+	int call = (val == __rsnd_mod_call_##func);			\
 	mod->status = (mod->status & ~mask) +				\
 		(add << __rsnd_mod_shift_##func);			\
-	dev_dbg(dev, "%s[%d] 0x%08x %s\n",				\
-		rsnd_mod_name(mod), rsnd_mod_id(mod), mod->status,	\
-		called ? #func : "");					\
+	dev_dbg(dev, "%s[%d]\t0x%08x %s\n",				\
+		rsnd_mod_name(mod), rsnd_mod_id(mod),			\
+		mod->status, call ? #func : "");			\
+	if (call)							\
+		ret = (mod)->ops->func(mod, io, param);			\
 	ret;								\
 })
 

commit dcc448e619194098b24477a6d56af50c57f26f1d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 7 12:42:22 2015 +0200

    ASoC: rsnd: Remove obsolete platform data support
    
    Since commit 3d7608e4c169af03 ("ARM: shmobile: bockw: remove legacy
    board file and config"), Renesas R-Car SoCs are only supported in
    generic DT-only ARM multi-platform builds.  The driver doesn't need to
    use platform data anymore, hence remove platform data configuration.
    
    Move <sound/rcar_snd.h> to sound/soc/sh/rcar/, as it's no longer needed
    by platform code.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index eec294da81e3..6ef9a884ca7c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1236,20 +1236,11 @@ static int rsnd_probe(struct platform_device *pdev)
 	};
 	int ret, i;
 
-	info = NULL;
-	of_data = NULL;
-	if (of_id) {
-		info = devm_kzalloc(&pdev->dev,
-				    sizeof(struct rcar_snd_info), GFP_KERNEL);
-		of_data = of_id->data;
-	} else {
-		info = pdev->dev.platform_data;
-	}
-
-	if (!info) {
-		dev_err(dev, "driver needs R-Car sound information\n");
-		return -ENODEV;
-	}
+	info = devm_kzalloc(&pdev->dev, sizeof(struct rcar_snd_info),
+			    GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+	of_data = of_id->data;
 
 	/*
 	 *	init priv data

commit f1df12290722f998f5eb173ae30434d313aea54c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 10 07:03:08 2015 +0000

    ASoC: rsnd: add common mod confirm method
    
    Renesas sound has SSI/SRC/DVC/MIX/ADG modules, and these have original
    register mapping. Thus this driver is using regmap field, and each module
    is using it based on each module ID.
    
    Sometimes, each module needs other module to controlling. but current each
    function is using just "mod" as parameter name. This is confusable.
    For example, if SSI0 and SRC2 are connected, and if SRC module function
    has bug of module access, and if it needs to control connected SSI,
    SRC function will access to SSI2 (It should access to SSI0, but it uses
    SRC's ID 2). This is easy to happen in current driver style.
    
    To avoid this kind of confusable trouble, this patch adds module confirm
    macro for debug purpose.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 870f94415abc..eec294da81e3 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -127,6 +127,17 @@ MODULE_DEVICE_TABLE(of, rsnd_of_match);
 #define rsnd_info_id(priv, io, name) \
 	((io)->info->name - priv->info->name##_info)
 
+void rsnd_mod_make_sure(struct rsnd_mod *mod, enum rsnd_mod_type type)
+{
+	if (mod->type != type) {
+		struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+		struct device *dev = rsnd_priv_to_dev(priv);
+
+		dev_warn(dev, "%s[%d] is not your expected module\n",
+			 rsnd_mod_name(mod), rsnd_mod_id(mod));
+	}
+}
+
 /*
  *	rsnd_mod functions
  */

commit ac37a45b0b6c8400719bb837f1c321079b72db53
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 10 07:01:58 2015 +0000

    ASoC: rsnd: Add Gen3 initial support
    
    Renesas sound Gen3 is updated version of Gen2. We need to update
    driver for it, but basically it should works as Gen2 compatible.
    This is initial support for Gen3. Gen3 specific feature will be
    incrementally added in the future
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f3feed5ce9b6..870f94415abc 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -110,6 +110,7 @@ static const struct rsnd_of_data rsnd_of_data_gen2 = {
 static const struct of_device_id rsnd_of_match[] = {
 	{ .compatible = "renesas,rcar_sound-gen1", .data = &rsnd_of_data_gen1 },
 	{ .compatible = "renesas,rcar_sound-gen2", .data = &rsnd_of_data_gen2 },
+	{ .compatible = "renesas,rcar_sound-gen3", .data = &rsnd_of_data_gen2 }, /* gen2 compatible */
 	{},
 };
 MODULE_DEVICE_TABLE(of, rsnd_of_match);

commit 48725e9cc841da395bfd74e7691bba91613d3517
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jul 21 00:03:35 2015 +0000

    ASoC: rsnd: tidyup parameter assignment position
    
    84e95355602c("ASoC: rsnd: show debug message for SSI/SRC/DVC connection")
    added debug message on rsnd_dai_connect(), but the relationship of
    parameter check was absurdity. This patch tidyup it.
    It is reported via Smatch/Dan
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 927a7b02123b..f3feed5ce9b6 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -332,12 +332,15 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 static int rsnd_dai_connect(struct rsnd_mod *mod,
 			    struct rsnd_dai_stream *io)
 {
-	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_priv *priv;
+	struct device *dev;
 
 	if (!mod)
 		return -EIO;
 
+	priv = rsnd_mod_to_priv(mod);
+	dev = rsnd_priv_to_dev(priv);
+
 	io->mod[mod->type] = mod;
 
 	dev_dbg(dev, "%s[%d] is connected to io (%s)\n",

commit 70fb10529f61c31c26397a02091177bedd23217d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:17:36 2015 +0000

    ASoC: rsnd: add MIX (Mixer) support
    
    This patch adds MIX (Mixer) initial support for rsnd driver.
    It is assuming that this MIX is used via DPCM.
    
    This is sample code for playback.
    
            CPU0  : [MEM] -> [SRC1] -> [CTU02] -+
                                                |
                                                +-> [MIX0] -> [DVC0] -> [SSI0]
                                                |
            CPU1  : [MEM] -> [SRC2] -> [CTU03] -+
    
            sound {
                    compatible = "renesas,rsrc-card";
    
                    ...
    
                    cpu@0 {
                            sound-dai = <&rcar_sound 0>;
                    };
    
                    cpu@1 {
                            sound-dai = <&rcar_sound 1>;
                    };
    
                    codec {
                            ...
                    };
            };
    
            rcar_sound {
    
                    ...
    
                    rcar_sound,dai {
                            dai0 {
                                    playback = <&src1 &ctu02 &mix0 &dvc0 &ssi0>;
                            };
                            dai1 {
                                    playback = <&src2 &ctu03 &mix0 &dvc0 &ssi0>;
                            };
                    };
            };
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 63ae7bbfd1dc..927a7b02123b 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -605,23 +605,74 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 void rsnd_path_parse(struct rsnd_priv *priv,
 		     struct rsnd_dai_stream *io)
 {
-	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
-	int src_id = rsnd_mod_id(src);
-	u32 path[] = {
-		[0] = 0x30000,
-		[1] = 0x30001,
-		[2] = 0x40000,
-		[3] = 0x10000,
-		[4] = 0x20000,
-		[5] = 0x40100
-	};
+	struct rsnd_mod *mix = rsnd_io_to_mod_mix(io);
+	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
+	struct rsnd_mod *cmd;
+	struct device *dev = rsnd_priv_to_dev(priv);
+	u32 data;
 
 	/* Gen1 is not supported */
 	if (rsnd_is_gen1(priv))
 		return;
 
-	rsnd_mod_write(dvc, CMD_ROUTE_SLCT, path[src_id]);
+	if (!mix && !dvc)
+		return;
+
+	if (mix) {
+		struct rsnd_dai *rdai;
+		int i;
+		u32 path[] = {
+			[0] = 0,
+			[1] = 1 << 0,
+			[2] = 0,
+			[3] = 0,
+			[4] = 0,
+			[5] = 1 << 8
+		};
+
+		/*
+		 * it is assuming that integrater is well understanding about
+		 * data path. Here doesn't check impossible connection,
+		 * like src2 + src5
+		 */
+		data = 0;
+		for_each_rsnd_dai(rdai, priv, i) {
+			io = &rdai->playback;
+			if (mix == rsnd_io_to_mod_mix(io))
+				data |= path[rsnd_mod_id(src)];
+
+			io = &rdai->capture;
+			if (mix == rsnd_io_to_mod_mix(io))
+				data |= path[rsnd_mod_id(src)];
+		}
+
+		/*
+		 * We can't use ctu = rsnd_io_ctu() here.
+		 * Since, ID of dvc/mix are 0 or 1 (= same as CMD number)
+		 * but ctu IDs are 0 - 7 (= CTU00 - CTU13)
+		 */
+		cmd = mix;
+	} else {
+		u32 path[] = {
+			[0] = 0x30000,
+			[1] = 0x30001,
+			[2] = 0x40000,
+			[3] = 0x10000,
+			[4] = 0x20000,
+			[5] = 0x40100
+		};
+
+		data = path[rsnd_mod_id(src)];
+
+		cmd = dvc;
+	}
+
+	dev_dbg(dev, "ctu/mix path = 0x%08x", data);
+
+	rsnd_mod_write(cmd, CMD_ROUTE_SLCT, data);
+
+	rsnd_mod_write(cmd, CMD_CTRL, 0x10);
 }
 
 static int rsnd_path_init(struct rsnd_priv *priv,
@@ -656,6 +707,11 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	if (ret < 0)
 		return ret;
 
+	/* MIX */
+	ret = rsnd_path_add(priv, io, mix);
+	if (ret < 0)
+		return ret;
+
 	/* DVC */
 	ret = rsnd_path_add(priv, io, dvc);
 	if (ret < 0)
@@ -672,13 +728,14 @@ static void rsnd_of_parse_dai(struct platform_device *pdev,
 	struct device_node *ssi_node,	*ssi_np;
 	struct device_node *src_node,	*src_np;
 	struct device_node *ctu_node,	*ctu_np;
+	struct device_node *mix_node,	*mix_np;
 	struct device_node *dvc_node,	*dvc_np;
 	struct device_node *playback, *capture;
 	struct rsnd_dai_platform_info *dai_info;
 	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
 	struct device *dev = &pdev->dev;
 	int nr, i;
-	int dai_i, ssi_i, src_i, ctu_i, dvc_i;
+	int dai_i, ssi_i, src_i, ctu_i, mix_i, dvc_i;
 
 	if (!of_data)
 		return;
@@ -705,6 +762,7 @@ static void rsnd_of_parse_dai(struct platform_device *pdev,
 	ssi_node = of_get_child_by_name(dev->of_node, "rcar_sound,ssi");
 	src_node = of_get_child_by_name(dev->of_node, "rcar_sound,src");
 	ctu_node = of_get_child_by_name(dev->of_node, "rcar_sound,ctu");
+	mix_node = of_get_child_by_name(dev->of_node, "rcar_sound,mix");
 	dvc_node = of_get_child_by_name(dev->of_node, "rcar_sound,dvc");
 
 #define mod_parse(name)							\
@@ -742,6 +800,7 @@ if (name##_node) {							\
 			mod_parse(ssi);
 			mod_parse(src);
 			mod_parse(ctu);
+			mod_parse(mix);
 			mod_parse(dvc);
 
 			of_node_put(playback);
@@ -1155,6 +1214,7 @@ static int rsnd_probe(struct platform_device *pdev)
 		rsnd_ssi_probe,
 		rsnd_src_probe,
 		rsnd_ctu_probe,
+		rsnd_mix_probe,
 		rsnd_dvc_probe,
 		rsnd_adg_probe,
 		rsnd_dai_probe,
@@ -1251,6 +1311,7 @@ static int rsnd_remove(struct platform_device *pdev)
 		rsnd_ssi_remove,
 		rsnd_src_remove,
 		rsnd_ctu_remove,
+		rsnd_mix_remove,
 		rsnd_dvc_remove,
 	};
 	int ret = 0, i;

commit 9269e3c3cfac277a49b485e27ac6850f9a11a259
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:17:17 2015 +0000

    ASoC: rsnd: add CTU (Channel Transfer Unit) prototype support
    
    This patch adds CTU (Channel Transfer Unit) support for rsnd driver.
    But, it does nothing to data at this point, but is required for MIX
    support.
    
    CTU design is a little different from other IPs (CTU0 is including
    CTU00 - CTU03, and CTU1 is including CTU10 - CTU13, these have different
    register mapping) We need to care about it on this driver.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index e20d8ea0aafe..63ae7bbfd1dc 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -651,6 +651,11 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	if (ret < 0)
 		return ret;
 
+	/* CTU */
+	ret = rsnd_path_add(priv, io, ctu);
+	if (ret < 0)
+		return ret;
+
 	/* DVC */
 	ret = rsnd_path_add(priv, io, dvc);
 	if (ret < 0)
@@ -666,13 +671,14 @@ static void rsnd_of_parse_dai(struct platform_device *pdev,
 	struct device_node *dai_node,	*dai_np;
 	struct device_node *ssi_node,	*ssi_np;
 	struct device_node *src_node,	*src_np;
+	struct device_node *ctu_node,	*ctu_np;
 	struct device_node *dvc_node,	*dvc_np;
 	struct device_node *playback, *capture;
 	struct rsnd_dai_platform_info *dai_info;
 	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
 	struct device *dev = &pdev->dev;
 	int nr, i;
-	int dai_i, ssi_i, src_i, dvc_i;
+	int dai_i, ssi_i, src_i, ctu_i, dvc_i;
 
 	if (!of_data)
 		return;
@@ -698,6 +704,7 @@ static void rsnd_of_parse_dai(struct platform_device *pdev,
 
 	ssi_node = of_get_child_by_name(dev->of_node, "rcar_sound,ssi");
 	src_node = of_get_child_by_name(dev->of_node, "rcar_sound,src");
+	ctu_node = of_get_child_by_name(dev->of_node, "rcar_sound,ctu");
 	dvc_node = of_get_child_by_name(dev->of_node, "rcar_sound,dvc");
 
 #define mod_parse(name)							\
@@ -734,6 +741,7 @@ if (name##_node) {							\
 
 			mod_parse(ssi);
 			mod_parse(src);
+			mod_parse(ctu);
 			mod_parse(dvc);
 
 			of_node_put(playback);
@@ -1146,6 +1154,7 @@ static int rsnd_probe(struct platform_device *pdev)
 		rsnd_dma_probe,
 		rsnd_ssi_probe,
 		rsnd_src_probe,
+		rsnd_ctu_probe,
 		rsnd_dvc_probe,
 		rsnd_adg_probe,
 		rsnd_dai_probe,
@@ -1241,6 +1250,7 @@ static int rsnd_remove(struct platform_device *pdev)
 			      struct rsnd_priv *priv) = {
 		rsnd_ssi_remove,
 		rsnd_src_remove,
+		rsnd_ctu_remove,
 		rsnd_dvc_remove,
 	};
 	int ret = 0, i;

commit 78edead4494219640d9fdf37d76beae24f79de9e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:16:37 2015 +0000

    ASoC: rsnd: tidyup SRC position on each code
    
    This is cleanup for CTU/MIX support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8919afabe48f..e20d8ea0aafe 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -641,13 +641,13 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	 * using fixed path.
 	 */
 
-	/* SRC */
-	ret = rsnd_path_add(priv, io, src);
+	/* SSI */
+	ret = rsnd_path_add(priv, io, ssi);
 	if (ret < 0)
 		return ret;
 
-	/* SSI */
-	ret = rsnd_path_add(priv, io, ssi);
+	/* SRC */
+	ret = rsnd_path_add(priv, io, src);
 	if (ret < 0)
 		return ret;
 

commit 84e95355602c59865be8a3bd18cd2f0b3863b4cb
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:15:10 2015 +0000

    ASoC: rsnd: show debug message for SSI/SRC/DVC connection
    
    It can help for connection debug
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 0f9323f2c049..8919afabe48f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -332,11 +332,18 @@ u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 static int rsnd_dai_connect(struct rsnd_mod *mod,
 			    struct rsnd_dai_stream *io)
 {
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct device *dev = rsnd_priv_to_dev(priv);
+
 	if (!mod)
 		return -EIO;
 
 	io->mod[mod->type] = mod;
 
+	dev_dbg(dev, "%s[%d] is connected to io (%s)\n",
+		rsnd_mod_name(mod), rsnd_mod_id(mod),
+		rsnd_io_is_play(io) ? "Playback" : "Capture");
+
 	return 0;
 }
 

commit 4689032b11d1af10e5eb755eb575f9761a455a72
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:14:47 2015 +0000

    ASoC: rsnd: tidyup data align position
    
    Sound L/R order of SSI is different from Linux sound data order.
    So current rsnd driver is using DALIGN (= data align) to exchange data
    align on SSIU. OTOH, CMD/SRC/SSIU have DALIGN register. Now inverted
    sound volume will be exchanged if user used volume control on DVC.
    Because SSIU which exchanges data align is located after DVC.
    
            MEM -> SRC -> DVC -> SSI
    
    This patch exchanges data align SRC if possible
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index a3637b92b187..0f9323f2c049 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -249,6 +249,42 @@ u32 rsnd_get_adinr_chan(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 
 	return chan;
 }
+
+/*
+ *	DALIGN function
+ */
+u32 rsnd_get_dalign(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
+{
+	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
+	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
+	struct rsnd_mod *target = src ? src : ssi;
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	u32 val = 0x76543210;
+	u32 mask = ~0;
+
+	mask <<= runtime->channels * 4;
+	val = val & mask;
+
+	switch (runtime->sample_bits) {
+	case 16:
+		val |= 0x67452301 & ~mask;
+		break;
+	case 32:
+		val |= 0x76543210 & ~mask;
+		break;
+	}
+
+	/*
+	 * exchange channeles on SRC if possible,
+	 * otherwise, R/L volume settings on DVC
+	 * changes inverted channels
+	 */
+	if (mod == target)
+		return val;
+	else
+		return 0x76543210;
+}
+
 /*
  *	rsnd_dai functions
  */

commit bfe1360d79210f9c1d330a07c26a8d5cb202159d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:14:29 2015 +0000

    ASoC: rsnd: add rsnd_get_adinr_chan()
    
    Current rsnd driver has rsnd_get_adinr_bit() to get bit settings for
    ADINR (= Audio Information Register) of SSIU/SRC/DVC.
    This patch adds rsnd_get_adinr_chan() to get channel settings for
    ADINR (= Audio Information Register) of CTU/MIX.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 0ca6d0268b56..a3637b92b187 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -227,6 +227,28 @@ u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	return adinr;
 }
 
+u32 rsnd_get_adinr_chan(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
+{
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	struct device *dev = rsnd_priv_to_dev(priv);
+	u32 chan = runtime->channels;
+
+	switch (chan) {
+	case 1:
+	case 2:
+	case 4:
+	case 6:
+	case 8:
+		break;
+	default:
+		dev_warn(dev, "not supported channel\n");
+		chan = 0;
+		break;
+	}
+
+	return chan;
+}
 /*
  *	rsnd_dai functions
  */

commit 3023b384d0c9da49028131b91fe64b24b5b84e6d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:14:05 2015 +0000

    ASoC: rsnd: tidyup ADINR function name
    
    Renesas sound IP (= SSIU/SRC/CTU/MIX/DVC) have ADINR
    (= Audio Information Register), but some of them (= SSIU/SRC/DVC)
    are for audio data bits, some of them (= CTU/MIX) are for audio data
    channels.
    Current rsnd driver is supporting SSIU/SRC/DVC, and these ADINR were
    for bits. This patch rename rsnd_get_adinr() to rsnd_get_adinr_bit(),
    and we will have rsnd_get_adinr_chan() for CTU/MIX.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index cb8206721283..0ca6d0268b56 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -203,9 +203,9 @@ int rsnd_io_is_working(struct rsnd_dai_stream *io)
 }
 
 /*
- *	settting function
+ *	ADINR function
  */
-u32 rsnd_get_adinr(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
+u32 rsnd_get_adinr_bit(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 {
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);

commit e2c08416196bd10a6575057fdd1347a307ce3a15
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:13:10 2015 +0000

    ASoC: rsnd: add rsnd_path_parse() for CTU/MIX/DVC route setting
    
    Current sound data route settings is done in dvc.c, and it doesn't care
    about CTU/MIX at this poinnt, but we need to care about these.
    OTOH, rsnd driver already has rsnd_path_xxx() functions for data path which
    are good match for CTU/MIX/DVC path selectio.
    This patch adds new rsnd_path_parse() to select sound data route which will
    care about CTU/MIX/DVC path.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 93fed5031c69..cb8206721283 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -537,6 +537,28 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	}							\
 }
 
+void rsnd_path_parse(struct rsnd_priv *priv,
+		     struct rsnd_dai_stream *io)
+{
+	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
+	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
+	int src_id = rsnd_mod_id(src);
+	u32 path[] = {
+		[0] = 0x30000,
+		[1] = 0x30001,
+		[2] = 0x40000,
+		[3] = 0x10000,
+		[4] = 0x20000,
+		[5] = 0x40100
+	};
+
+	/* Gen1 is not supported */
+	if (rsnd_is_gen1(priv))
+		return;
+
+	rsnd_mod_write(dvc, CMD_ROUTE_SLCT, path[src_id]);
+}
+
 static int rsnd_path_init(struct rsnd_priv *priv,
 			  struct rsnd_dai *rdai,
 			  struct rsnd_dai_stream *io)

commit c8cf15f64f8ddb3169987c2f26df3341b8556296
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:12:52 2015 +0000

    ASoC: rsnd: rename rsnd_path_parse/break() into add/remove
    
    parse/break is a little ambiguous/confusable name for rsnd module path.
    Especially for CTU/MIX support. It was renamed to add/remove
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ff4f15a2666a..93fed5031c69 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -507,7 +507,7 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.set_fmt	= rsnd_soc_dai_set_fmt,
 };
 
-#define rsnd_path_parse(priv, io, type)				\
+#define rsnd_path_add(priv, io, type)				\
 ({								\
 	struct rsnd_mod *mod;					\
 	int ret = 0;						\
@@ -523,7 +523,7 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	ret;							\
 })
 
-#define rsnd_path_break(priv, io, type)				\
+#define rsnd_path_remove(priv, io, type)			\
 {								\
 	struct rsnd_mod *mod;					\
 	int id = -1;						\
@@ -555,17 +555,17 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	 */
 
 	/* SRC */
-	ret = rsnd_path_parse(priv, io, src);
+	ret = rsnd_path_add(priv, io, src);
 	if (ret < 0)
 		return ret;
 
 	/* SSI */
-	ret = rsnd_path_parse(priv, io, ssi);
+	ret = rsnd_path_add(priv, io, ssi);
 	if (ret < 0)
 		return ret;
 
 	/* DVC */
-	ret = rsnd_path_parse(priv, io, dvc);
+	ret = rsnd_path_add(priv, io, dvc);
 	if (ret < 0)
 		return ret;
 
@@ -1023,8 +1023,8 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 		/*
 		 * remove SRC/DVC from DAI,
 		 */
-		rsnd_path_break(priv, io, src);
-		rsnd_path_break(priv, io, dvc);
+		rsnd_path_remove(priv, io, src);
+		rsnd_path_remove(priv, io, dvc);
 
 		/*
 		 * fallback

commit d6f8d5b4422a5a391c02df97af9ef7da5a929d71
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:12:36 2015 +0000

    ASoC: rsnd: enable module multi connection
    
    '8a4e379b54f8("ASoC: rsnd: remove io from rsnd_mod")' removed mod/io
    relationship. rsnd_dai_connect() mod/io check is no longer needed
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index d44bfb79779a..ff4f15a2666a 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -277,16 +277,6 @@ static int rsnd_dai_connect(struct rsnd_mod *mod,
 	if (!mod)
 		return -EIO;
 
-	if (io->mod[mod->type]) {
-		struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-		struct device *dev = rsnd_priv_to_dev(priv);
-
-		dev_err(dev, "%s[%d] is not empty\n",
-			rsnd_mod_name(mod),
-			rsnd_mod_id(mod));
-		return -EIO;
-	}
-
 	io->mod[mod->type] = mod;
 
 	return 0;

commit a48e3f9747fd62b385221a892cd4726b82dacd11
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:10:04 2015 +0000

    ASoC: rsnd: fixup each module counter on __rsnd_mod_call()
    
    '5451ea443b ("ASoC: rsnd: count each mod (SSI/SRC/DVC)")' counts each
    module's callback status, but counts 1st callback only.
    This patch fixup it. Otherwise, multi-called function will be trouble
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f1e5920654f6..d44bfb79779a 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -242,9 +242,9 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 	if (val == __rsnd_mod_call_##func) {				\
 		called = 1;						\
 		ret = (mod)->ops->func(mod, io, param);			\
-		mod->status = (mod->status & ~mask) +			\
-			(add << __rsnd_mod_shift_##func);		\
 	}								\
+	mod->status = (mod->status & ~mask) +				\
+		(add << __rsnd_mod_shift_##func);			\
 	dev_dbg(dev, "%s[%d] 0x%08x %s\n",				\
 		rsnd_mod_name(mod), rsnd_mod_id(mod), mod->status,	\
 		called ? #func : "");					\

commit 8a4e379b54f8cf1180cfee8ad3bfe16beedac65b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:28:03 2015 +0000

    ASoC: rsnd: remove io from rsnd_mod
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many path
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship. rsnd_mod_to_io() is no longer needed. Let's remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1eca85ff3e91..f1e5920654f6 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -288,7 +288,6 @@ static int rsnd_dai_connect(struct rsnd_mod *mod,
 	}
 
 	io->mod[mod->type] = mod;
-	mod->io = io;
 
 	return 0;
 }
@@ -296,7 +295,6 @@ static int rsnd_dai_connect(struct rsnd_mod *mod,
 static void rsnd_dai_disconnect(struct rsnd_mod *mod,
 				struct rsnd_dai_stream *io)
 {
-	mod->io = NULL;
 	io->mod[mod->type] = NULL;
 }
 

commit d5bbe7de563ccce62765f1183561218b6dbdbe1e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:27:47 2015 +0000

    ASoC: rsnd: move rsnd_mod_is_working() to rsnd_io_is_working()
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship.
    This patch checks module working status via io instead of mod
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 266b24ae621d..1eca85ff3e91 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -196,10 +196,8 @@ void rsnd_mod_interrupt(struct rsnd_mod *mod,
 	}
 }
 
-int rsnd_mod_is_working(struct rsnd_mod *mod)
+int rsnd_io_is_working(struct rsnd_dai_stream *io)
 {
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
-
 	/* see rsnd_dai_stream_init/quit() */
 	return !!io->substream;
 }

commit b65a7cccb58ce5acfed579e1ca10f8a4d3d0dd04
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:27:28 2015 +0000

    ASoC: rsnd: don't use rsnd_mod_to_io() on snd_kcontrol
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship. This patch removes rsnd_mod_to_io() from snd_kcontrol
    and related function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index daa01e2aebb6..266b24ae621d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -880,16 +880,18 @@ static int rsnd_kctrl_put(struct snd_kcontrol *kctrl,
 	}
 
 	if (change)
-		cfg->update(mod);
+		cfg->update(cfg->io, mod);
 
 	return change;
 }
 
 static int __rsnd_kctrl_new(struct rsnd_mod *mod,
+			    struct rsnd_dai_stream *io,
 			    struct snd_soc_pcm_runtime *rtd,
 			    const unsigned char *name,
 			    struct rsnd_kctrl_cfg *cfg,
-			    void (*update)(struct rsnd_mod *mod))
+			    void (*update)(struct rsnd_dai_stream *io,
+					   struct rsnd_mod *mod))
 {
 	struct snd_soc_card *soc_card = rtd->card;
 	struct snd_card *card = rtd->card->snd_card;
@@ -918,6 +920,7 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 	cfg->update = update;
 	cfg->card = card;
 	cfg->kctrl = kctrl;
+	cfg->io = io;
 
 	return 0;
 }
@@ -928,36 +931,42 @@ void _rsnd_kctrl_remove(struct rsnd_kctrl_cfg *cfg)
 }
 
 int rsnd_kctrl_new_m(struct rsnd_mod *mod,
+		     struct rsnd_dai_stream *io,
 		     struct snd_soc_pcm_runtime *rtd,
 		     const unsigned char *name,
-		     void (*update)(struct rsnd_mod *mod),
+		     void (*update)(struct rsnd_dai_stream *io,
+				    struct rsnd_mod *mod),
 		     struct rsnd_kctrl_cfg_m *_cfg,
 		     u32 max)
 {
 	_cfg->cfg.max	= max;
 	_cfg->cfg.size	= RSND_DVC_CHANNELS;
 	_cfg->cfg.val	= _cfg->val;
-	return __rsnd_kctrl_new(mod, rtd, name, &_cfg->cfg, update);
+	return __rsnd_kctrl_new(mod, io, rtd, name, &_cfg->cfg, update);
 }
 
 int rsnd_kctrl_new_s(struct rsnd_mod *mod,
+		     struct rsnd_dai_stream *io,
 		     struct snd_soc_pcm_runtime *rtd,
 		     const unsigned char *name,
-		     void (*update)(struct rsnd_mod *mod),
+		     void (*update)(struct rsnd_dai_stream *io,
+				    struct rsnd_mod *mod),
 		     struct rsnd_kctrl_cfg_s *_cfg,
 		     u32 max)
 {
 	_cfg->cfg.max	= max;
 	_cfg->cfg.size	= 1;
 	_cfg->cfg.val	= &_cfg->val;
-	return __rsnd_kctrl_new(mod, rtd, name, &_cfg->cfg, update);
+	return __rsnd_kctrl_new(mod, io, rtd, name, &_cfg->cfg, update);
 }
 
 int rsnd_kctrl_new_e(struct rsnd_mod *mod,
+		     struct rsnd_dai_stream *io,
 		     struct snd_soc_pcm_runtime *rtd,
 		     const unsigned char *name,
 		     struct rsnd_kctrl_cfg_s *_cfg,
-		     void (*update)(struct rsnd_mod *mod),
+		     void (*update)(struct rsnd_dai_stream *io,
+				    struct rsnd_mod *mod),
 		     const char * const *texts,
 		     u32 max)
 {
@@ -965,7 +974,7 @@ int rsnd_kctrl_new_e(struct rsnd_mod *mod,
 	_cfg->cfg.size	= 1;
 	_cfg->cfg.val	= &_cfg->val;
 	_cfg->cfg.texts	= texts;
-	return __rsnd_kctrl_new(mod, rtd, name, &_cfg->cfg, update);
+	return __rsnd_kctrl_new(mod, io, rtd, name, &_cfg->cfg, update);
 }
 
 /*

commit 9b99e9a7c5057684104178bb6c3815fcb2f13be4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:26:25 2015 +0000

    ASoC: rsnd: don't use rsnd_mod_to_io() on rsnd_dma_xxx()
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship. This patch removes rsnd_mod_to_io() from rsnd_dma_xxx()
    and related function
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index e1d1b22f324f..daa01e2aebb6 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -137,12 +137,13 @@ char *rsnd_mod_name(struct rsnd_mod *mod)
 	return mod->ops->name;
 }
 
-struct dma_chan *rsnd_mod_dma_req(struct rsnd_mod *mod)
+struct dma_chan *rsnd_mod_dma_req(struct rsnd_dai_stream *io,
+				  struct rsnd_mod *mod)
 {
 	if (!mod || !mod->ops || !mod->ops->dma_req)
 		return NULL;
 
-	return mod->ops->dma_req(mod);
+	return mod->ops->dma_req(io, mod);
 }
 
 int rsnd_mod_init(struct rsnd_priv *priv,

commit 4e2639ff38d28dccdd8e7cf8f60181f0c17e10d3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:26:08 2015 +0000

    ASoC: rsnd: don't use rsnd_mod_to_io() on rsnd_get_adinr()
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship. This patch removes rsnd_mod_to_io() from rsnd_get_adinr()
    and its related function
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 424d1a31c471..e1d1b22f324f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -206,10 +206,9 @@ int rsnd_mod_is_working(struct rsnd_mod *mod)
 /*
  *	settting function
  */
-u32 rsnd_get_adinr(struct rsnd_mod *mod)
+u32 rsnd_get_adinr(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 {
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
 	u32 adinr = runtime->channels;

commit f501b7a4e7ceb76a5d24cc0f75403072af5e85a0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:25:48 2015 +0000

    ASoC: rsnd: add common interrupt handler for SSI/SRC/DMA
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship. Then, interrupt handler can't use rsnd_mod_to_io().
    This patch adds SSI/SRC/DMA common interrupt handler frame
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 54297d74ea1f..424d1a31c471 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -172,6 +172,29 @@ void rsnd_mod_quit(struct rsnd_mod *mod)
 		clk_unprepare(mod->clk);
 }
 
+void rsnd_mod_interrupt(struct rsnd_mod *mod,
+			void (*callback)(struct rsnd_mod *mod,
+					 struct rsnd_dai_stream *io))
+{
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_dai_stream *io;
+	struct rsnd_dai *rdai;
+	int i, j;
+
+	for_each_rsnd_dai(rdai, priv, j) {
+
+		for (i = 0; i < RSND_MOD_MAX; i++) {
+			io = &rdai->playback;
+			if (mod == io->mod[i])
+				callback(mod, io);
+
+			io = &rdai->capture;
+			if (mod == io->mod[i])
+				callback(mod, io);
+		}
+	}
+}
+
 int rsnd_mod_is_working(struct rsnd_mod *mod)
 {
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);

commit 2c0fac19de2cd74181122f7e62f4ebffdd6f8fa3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:25:20 2015 +0000

    ASoC: rsnd: adds struct rsnd_dai_stream as on each fuction as parameter
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship. This means we can't call rsnd_mod_to_io() any more.
    This patch adds struct rsnd_dai_stream to each function as parameter.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1e8d7e59998c..54297d74ea1f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -209,7 +209,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 /*
  *	rsnd_dai functions
  */
-#define __rsnd_mod_call(mod, func, param...)			\
+#define __rsnd_mod_call(mod, io, func, param...)		\
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
@@ -220,7 +220,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 	int called = 0;							\
 	if (val == __rsnd_mod_call_##func) {				\
 		called = 1;						\
-		ret = (mod)->ops->func(mod, param);			\
+		ret = (mod)->ops->func(mod, io, param);			\
 		mod->status = (mod->status & ~mask) +			\
 			(add << __rsnd_mod_shift_##func);		\
 	}								\
@@ -230,10 +230,10 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 	ret;								\
 })
 
-#define rsnd_mod_call(mod, func, param...)	\
+#define rsnd_mod_call(mod, io, func, param...)	\
 	(!(mod) ? -ENODEV :			\
 	 !((mod)->ops->func) ? 0 :		\
-	 __rsnd_mod_call(mod, func, param))
+	 __rsnd_mod_call(mod, io, func, param))
 
 #define rsnd_dai_call(fn, io, param...)				\
 ({								\
@@ -243,7 +243,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 		mod = (io)->mod[i];				\
 		if (!mod)					\
 			continue;				\
-		ret = rsnd_mod_call(mod, fn, param);		\
+		ret = rsnd_mod_call(mod, io, fn, param);	\
 		if (ret < 0)					\
 			break;					\
 	}							\

commit 2099bc8eb0b257196a8535fba343cb23a8a6807c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:24:54 2015 +0000

    ASoC: rsnd: rsnd_mod has rsnd_priv
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship. This means we can't use rsnd_mod_to_io() in SSI/SRC/DMA
    interrupt handler. In such case, we need to check all io in interrupt
    handler, and then, "priv" is needed.
    This patch adds rsnd_priv pointer in rsnd_mod for prepare it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 50ec28c24867..1e8d7e59998c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -145,7 +145,8 @@ struct dma_chan *rsnd_mod_dma_req(struct rsnd_mod *mod)
 	return mod->ops->dma_req(mod);
 }
 
-int rsnd_mod_init(struct rsnd_mod *mod,
+int rsnd_mod_init(struct rsnd_priv *priv,
+		  struct rsnd_mod *mod,
 		   struct rsnd_mod_ops *ops,
 		   struct clk *clk,
 		   enum rsnd_mod_type type,
@@ -160,6 +161,7 @@ int rsnd_mod_init(struct rsnd_mod *mod,
 	mod->ops	= ops;
 	mod->type	= type;
 	mod->clk	= clk;
+	mod->priv	= priv;
 
 	return ret;
 }

commit 5451ea443bf8889a786ea394ac90a3de5af53e24
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:24:34 2015 +0000

    ASoC: rsnd: count each mod (SSI/SRC/DVC)
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. Then, we don't need to re-call each mod function
    that had been called. This patch count each mod status.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 027b04392674..50ec28c24867 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -211,15 +211,20 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
-	u32 mask = (1 << __rsnd_mod_shift_##func) & ~(1 << 31);	\
-	u32 call = __rsnd_mod_call_##func << __rsnd_mod_shift_##func;	\
+	u32 mask = 0xF << __rsnd_mod_shift_##func;			\
+	u8 val  = (mod->status >> __rsnd_mod_shift_##func) & 0xF;	\
+	u8 add  = ((val + __rsnd_mod_add_##func) & 0xF);		\
 	int ret = 0;							\
-	if ((mod->status & mask) == call) {				\
-		dev_dbg(dev, "%s[%d] %s\n",				\
-			rsnd_mod_name(mod), rsnd_mod_id(mod), #func);	\
+	int called = 0;							\
+	if (val == __rsnd_mod_call_##func) {				\
+		called = 1;						\
 		ret = (mod)->ops->func(mod, param);			\
-		mod->status = (mod->status & ~mask) | (~call & mask);	\
+		mod->status = (mod->status & ~mask) +			\
+			(add << __rsnd_mod_shift_##func);		\
 	}								\
+	dev_dbg(dev, "%s[%d] 0x%08x %s\n",				\
+		rsnd_mod_name(mod), rsnd_mod_id(mod), mod->status,	\
+		called ? #func : "");					\
 	ret;								\
 })
 

commit 75defee0f1b3fcd91d8a304d6444635a459b8249
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:21:15 2015 +0000

    ASoC: rsnd: don't call snd_pcm_period_elapsed() under spin lock
    
    'a9e1ac1a9e4585b5("ASoC: rsnd: spin lock for interrupt handler")'
    added spin lock under interrupt handler to solve HW restart issue.
    
    OTOH, current rsnd driver calls snd_pcm_period_elapsed() from
    rsnd_dai_pointer_update(). but, it will be called under spin lock
    if SSI was PIO mode.
    
    If it was called under spin lock, it will call
    snd_pcm_update_state() -> snd_pcm_drain_done().
    Then, it calls rsnd_soc_dai_trigger() and will be dead-lock.
    This patch doesn't call rsnd_dai_pointer_update() under spin lock
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index d460d2aa82ee..027b04392674 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -302,7 +302,7 @@ int rsnd_dai_pointer_offset(struct rsnd_dai_stream *io, int additional)
 	return pos;
 }
 
-void rsnd_dai_pointer_update(struct rsnd_dai_stream *io, int byte)
+bool rsnd_dai_pointer_update(struct rsnd_dai_stream *io, int byte)
 {
 	io->byte_pos += byte;
 
@@ -319,8 +319,24 @@ void rsnd_dai_pointer_update(struct rsnd_dai_stream *io, int byte)
 			io->next_period_byte = io->byte_per_period;
 		}
 
-		snd_pcm_period_elapsed(substream);
+		return true;
 	}
+
+	return false;
+}
+
+void rsnd_dai_period_elapsed(struct rsnd_dai_stream *io)
+{
+	struct snd_pcm_substream *substream = io->substream;
+
+	/*
+	 * this function should be called...
+	 *
+	 * - if rsnd_dai_pointer_update() returns true
+	 * - without spin lock
+	 */
+
+	snd_pcm_period_elapsed(substream);
 }
 
 static void rsnd_dai_stream_init(struct rsnd_dai_stream *io,

commit 02299d9875bab5b1e9d87ce9ae4aecf537eb12a4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 21 03:50:23 2015 +0000

    ASoC: rsnd: spin lock for interrupt handler
    
    Renesas R-Car driver interrupt handler was not locked before.
    But now, SSI/SRC interrupt handler calls restart function
    which should be called under spin lock.
    Below error might happen witout this patch.
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000048
    pgd = edfac000
    [00000048] *pgd=6e0f0831, *pte=00000000, *ppte=00000000
    Internal error: Oops: 17 [#1] SMP ARM
    CPU: 0 PID: 2009 Comm: aplay Not tainted 4.1.0-rc2-dirty #4
    Hardware name: Generic R8A7790 (Flattened Device Tree)
    task: eeac9040 ti: eebe8000 task.ti: eebe8000
    PC is at rsnd_get_adinr+0x28/0x60
    LR is at rsnd_src_ssiu_start+0xdc/0x19c
    pc : [<c0409790>]    lr : [<c040c068>]    psr: a0000193
    sp : eebe9e58  ip : eebe9e68  fp : eebe9e64
    r10: c06ed9d0  r9 : ee919d10  r8 : 00000001
    r7 : 00000001  r6 : ee1cb090  r5 : 00000000  r4 : edcaa418
    r3 : 00000000  r2 : eea8ce00  r1 : 80000193  r0 : edcaa418
    ...
    
    Reported-by: Cao Minh Hiep <cm-hiep@jinso.co.jp>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Tested by: Cao Minh Hiep <cm-hiep@jinso.co.jp>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 2b7323c92994..d460d2aa82ee 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -170,6 +170,14 @@ void rsnd_mod_quit(struct rsnd_mod *mod)
 		clk_unprepare(mod->clk);
 }
 
+int rsnd_mod_is_working(struct rsnd_mod *mod)
+{
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+
+	/* see rsnd_dai_stream_init/quit() */
+	return !!io->substream;
+}
+
 /*
  *	settting function
  */
@@ -362,7 +370,7 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	int ret;
 	unsigned long flags;
 
-	rsnd_lock(priv, flags);
+	spin_lock_irqsave(&priv->lock, flags);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -400,7 +408,7 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	}
 
 dai_trigger_end:
-	rsnd_unlock(priv, flags);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
 	return ret;
 }

commit 5626ad0866657c4758958040589b395d2a58816d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 21 03:49:54 2015 +0000

    ASoC: rsnd: add rsnd_dai_stream_quit()
    
    Current Renesas R-Car sound driver calls rsnd_dai_stream_init() when
    start, but it didn't call paired function. This patch adds
    rsnd_dai_stream_quit() for it. This is prepare for interrupt error
    status check feature support.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Tested by: Cao Minh Hiep <cm-hiep@jinso.co.jp>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 405cacdbedfb..2b7323c92994 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -315,7 +315,7 @@ void rsnd_dai_pointer_update(struct rsnd_dai_stream *io, int byte)
 	}
 }
 
-static int rsnd_dai_stream_init(struct rsnd_dai_stream *io,
+static void rsnd_dai_stream_init(struct rsnd_dai_stream *io,
 				struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -327,8 +327,11 @@ static int rsnd_dai_stream_init(struct rsnd_dai_stream *io,
 				  runtime->channels *
 				  samples_to_bytes(runtime, 1);
 	io->next_period_byte	= io->byte_per_period;
+}
 
-	return 0;
+static void rsnd_dai_stream_quit(struct rsnd_dai_stream *io)
+{
+	io->substream		= NULL;
 }
 
 static
@@ -363,9 +366,7 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		ret = rsnd_dai_stream_init(io, substream);
-		if (ret < 0)
-			goto dai_trigger_end;
+		rsnd_dai_stream_init(io, substream);
 
 		ret = rsnd_platform_call(priv, dai, start, ssi_id);
 		if (ret < 0)
@@ -391,6 +392,8 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		ret = rsnd_platform_call(priv, dai, stop, ssi_id);
 		if (ret < 0)
 			goto dai_trigger_end;
+
+		rsnd_dai_stream_quit(io);
 		break;
 	default:
 		ret = -EINVAL;

commit ae11a9be5a9bfc085ab3e0b7d2ea7cd01bc1d477
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 12 01:57:50 2015 +0000

    ASoC: rsnd: revert lock for calls to rsnd_dai_call
    
    This reverts commit 'e9c390df671f ("ASoC: rsnd: make sure it uses lock when
    it calls rsnd_dai_call)' The additional locks make 1") lock issue when boot
    2) lock issue when unbind/rmmod. And there is no problem without these
    locks. This patch revert it.
    
    Reported-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 99eb1093c569..405cacdbedfb 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -731,15 +731,10 @@ static int rsnd_hw_params(struct snd_pcm_substream *substream,
 {
 	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	struct rsnd_priv *priv = rsnd_dai_to_priv(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
-	unsigned long flags;
 	int ret;
 
-	rsnd_lock(priv, flags);
 	ret = rsnd_dai_call(hw_params, io, substream, hw_params);
-	rsnd_unlock(priv, flags);
-
 	if (ret)
 		return ret;
 
@@ -926,16 +921,14 @@ int rsnd_kctrl_new_e(struct rsnd_mod *mod,
 static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_dai *dai = rtd->cpu_dai;
-	struct rsnd_priv *priv = rsnd_dai_to_priv(dai);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	unsigned long flags;
-	int ret = 0;
+	int ret;
 
-	rsnd_lock(priv, flags);
-	ret |= rsnd_dai_call(pcm_new, &rdai->playback, rtd);
-	ret |= rsnd_dai_call(pcm_new, &rdai->capture, rtd);
-	rsnd_unlock(priv, flags);
+	ret = rsnd_dai_call(pcm_new, &rdai->playback, rtd);
+	if (ret)
+		return ret;
 
+	ret = rsnd_dai_call(pcm_new, &rdai->capture, rtd);
 	if (ret)
 		return ret;
 
@@ -958,11 +951,8 @@ static const struct snd_soc_component_driver rsnd_soc_component = {
 static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 				       struct rsnd_dai_stream *io)
 {
-	unsigned long flags;
 	int ret;
 
-	rsnd_lock(priv, flags);
-
 	ret = rsnd_dai_call(probe, io, priv);
 	if (ret == -EAGAIN) {
 		/*
@@ -995,7 +985,6 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 		 */
 		ret = rsnd_dai_call(probe, io, priv);
 	}
-	rsnd_unlock(priv, flags);
 
 	return ret;
 }
@@ -1011,7 +1000,6 @@ static int rsnd_probe(struct platform_device *pdev)
 	struct rsnd_dai *rdai;
 	const struct of_device_id *of_id = of_match_device(rsnd_of_match, dev);
 	const struct rsnd_of_data *of_data;
-	unsigned long flags;
 	int (*probe_func[])(struct platform_device *pdev,
 			    const struct rsnd_of_data *of_data,
 			    struct rsnd_priv *priv) = {
@@ -1098,12 +1086,10 @@ static int rsnd_probe(struct platform_device *pdev)
 exit_snd_soc:
 	snd_soc_unregister_platform(dev);
 exit_snd_probe:
-	rsnd_lock(priv, flags);
 	for_each_rsnd_dai(rdai, priv, i) {
 		rsnd_dai_call(remove, &rdai->playback, priv);
 		rsnd_dai_call(remove, &rdai->capture, priv);
 	}
-	rsnd_unlock(priv, flags);
 
 	return ret;
 }
@@ -1112,7 +1098,6 @@ static int rsnd_remove(struct platform_device *pdev)
 {
 	struct rsnd_priv *priv = dev_get_drvdata(&pdev->dev);
 	struct rsnd_dai *rdai;
-	unsigned long flags;
 	void (*remove_func[])(struct platform_device *pdev,
 			      struct rsnd_priv *priv) = {
 		rsnd_ssi_remove,
@@ -1123,12 +1108,10 @@ static int rsnd_remove(struct platform_device *pdev)
 
 	pm_runtime_disable(&pdev->dev);
 
-	rsnd_lock(priv, flags);
 	for_each_rsnd_dai(rdai, priv, i) {
 		ret |= rsnd_dai_call(remove, &rdai->playback, priv);
 		ret |= rsnd_dai_call(remove, &rdai->capture, priv);
 	}
-	rsnd_unlock(priv, flags);
 
 	for (i = 0; i < ARRAY_SIZE(remove_func); i++)
 		remove_func[i](pdev, priv);

commit da620d722a7b7b16bf8571150acd7fd9e155809f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 10 08:50:50 2015 +0000

    ASoC: rsnd: care snd_kcontrol's index
    
    rsnd might be used in multi-codec sound card.
    Then, same name kcontrol will be registered many times, and it will
    be error. This patch fixes this issue by using .index
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 164653c0bc10..99eb1093c569 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -839,12 +839,14 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 			    struct rsnd_kctrl_cfg *cfg,
 			    void (*update)(struct rsnd_mod *mod))
 {
+	struct snd_soc_card *soc_card = rtd->card;
 	struct snd_card *card = rtd->card->snd_card;
 	struct snd_kcontrol *kctrl;
 	struct snd_kcontrol_new knew = {
 		.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name		= name,
 		.info		= rsnd_kctrl_info,
+		.index		= rtd - soc_card->rtd,
 		.get		= rsnd_kctrl_get,
 		.put		= rsnd_kctrl_put,
 		.private_value	= (unsigned long)cfg,

commit e9c390df671fadc829550935ffb6b23549f26ded
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 10 08:49:49 2015 +0000

    ASoC: rsnd: make sure it uses lock when it calls rsnd_dai_call
    
    rsnd_dai_call() should be called under rsnd_lock
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index a2a0b5768c44..164653c0bc10 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -731,10 +731,15 @@ static int rsnd_hw_params(struct snd_pcm_substream *substream,
 {
 	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_priv *priv = rsnd_dai_to_priv(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+	unsigned long flags;
 	int ret;
 
+	rsnd_lock(priv, flags);
 	ret = rsnd_dai_call(hw_params, io, substream, hw_params);
+	rsnd_unlock(priv, flags);
+
 	if (ret)
 		return ret;
 
@@ -919,14 +924,16 @@ int rsnd_kctrl_new_e(struct rsnd_mod *mod,
 static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_dai *dai = rtd->cpu_dai;
+	struct rsnd_priv *priv = rsnd_dai_to_priv(dai);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
-	int ret;
+	unsigned long flags;
+	int ret = 0;
 
-	ret = rsnd_dai_call(pcm_new, &rdai->playback, rtd);
-	if (ret)
-		return ret;
+	rsnd_lock(priv, flags);
+	ret |= rsnd_dai_call(pcm_new, &rdai->playback, rtd);
+	ret |= rsnd_dai_call(pcm_new, &rdai->capture, rtd);
+	rsnd_unlock(priv, flags);
 
-	ret = rsnd_dai_call(pcm_new, &rdai->capture, rtd);
 	if (ret)
 		return ret;
 
@@ -949,8 +956,11 @@ static const struct snd_soc_component_driver rsnd_soc_component = {
 static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 				       struct rsnd_dai_stream *io)
 {
+	unsigned long flags;
 	int ret;
 
+	rsnd_lock(priv, flags);
+
 	ret = rsnd_dai_call(probe, io, priv);
 	if (ret == -EAGAIN) {
 		/*
@@ -983,6 +993,7 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 		 */
 		ret = rsnd_dai_call(probe, io, priv);
 	}
+	rsnd_unlock(priv, flags);
 
 	return ret;
 }
@@ -998,6 +1009,7 @@ static int rsnd_probe(struct platform_device *pdev)
 	struct rsnd_dai *rdai;
 	const struct of_device_id *of_id = of_match_device(rsnd_of_match, dev);
 	const struct rsnd_of_data *of_data;
+	unsigned long flags;
 	int (*probe_func[])(struct platform_device *pdev,
 			    const struct rsnd_of_data *of_data,
 			    struct rsnd_priv *priv) = {
@@ -1084,10 +1096,12 @@ static int rsnd_probe(struct platform_device *pdev)
 exit_snd_soc:
 	snd_soc_unregister_platform(dev);
 exit_snd_probe:
+	rsnd_lock(priv, flags);
 	for_each_rsnd_dai(rdai, priv, i) {
 		rsnd_dai_call(remove, &rdai->playback, priv);
 		rsnd_dai_call(remove, &rdai->capture, priv);
 	}
+	rsnd_unlock(priv, flags);
 
 	return ret;
 }
@@ -1096,6 +1110,7 @@ static int rsnd_remove(struct platform_device *pdev)
 {
 	struct rsnd_priv *priv = dev_get_drvdata(&pdev->dev);
 	struct rsnd_dai *rdai;
+	unsigned long flags;
 	void (*remove_func[])(struct platform_device *pdev,
 			      struct rsnd_priv *priv) = {
 		rsnd_ssi_remove,
@@ -1106,10 +1121,12 @@ static int rsnd_remove(struct platform_device *pdev)
 
 	pm_runtime_disable(&pdev->dev);
 
+	rsnd_lock(priv, flags);
 	for_each_rsnd_dai(rdai, priv, i) {
 		ret |= rsnd_dai_call(remove, &rdai->playback, priv);
 		ret |= rsnd_dai_call(remove, &rdai->capture, priv);
 	}
+	rsnd_unlock(priv, flags);
 
 	for (i = 0; i < ARRAY_SIZE(remove_func); i++)
 		remove_func[i](pdev, priv);

commit eb2535f542b4279b42518d6a312c6f7290434e55
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 10 08:49:25 2015 +0000

    ASoC: rsnd: add rsnd_dai_to_priv() macro
    
    Using standardized function/macro name is useful in driver
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 9f48d75fa992..a2a0b5768c44 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -272,9 +272,10 @@ struct rsnd_dai *rsnd_rdai_get(struct rsnd_priv *priv, int id)
 	return priv->rdai + id;
 }
 
+#define rsnd_dai_to_priv(dai) snd_soc_dai_get_drvdata(dai)
 static struct rsnd_dai *rsnd_dai_to_rdai(struct snd_soc_dai *dai)
 {
-	struct rsnd_priv *priv = snd_soc_dai_get_drvdata(dai);
+	struct rsnd_priv *priv = rsnd_dai_to_priv(dai);
 
 	return rsnd_rdai_get(priv, dai->id);
 }
@@ -351,7 +352,7 @@ struct rsnd_dai_stream *rsnd_rdai_to_io(struct rsnd_dai *rdai,
 static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 			    struct snd_soc_dai *dai)
 {
-	struct rsnd_priv *priv = snd_soc_dai_get_drvdata(dai);
+	struct rsnd_priv *priv = rsnd_dai_to_priv(dai);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
 	int ssi_id = rsnd_mod_id(rsnd_io_to_mod_ssi(io));

commit 1fa1e0731db9e5579afa60b6299b6c47447eee3a
Merge: e1f059937a2b 59c41d15e630 6a328885896e 8616774968f3 d53d59ecad74
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Apr 12 19:49:11 2015 +0100

    Merge remote-tracking branches 'asoc/topic/omap', 'asoc/topic/qcom', 'asoc/topic/rcar' and 'asoc/topic/rt286' into asoc-next

commit 250acc709ee23856eba8432f979e42ba64a9a8b6
Merge: a37a9407ca3c c01673e0b723 3a82002c7cbb 74ff960222d9 a57069e33fbc 2f78dd7f4026
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Apr 12 19:48:22 2015 +0100

    Merge remote-tracking branches 'asoc/fix/ak4642', 'asoc/fix/atmel', 'asoc/fix/cs4271', 'asoc/fix/davinci' and 'asoc/fix/rcar' into asoc-linus

commit 969b8619069f0e4da767c54481dcc10812f949a5
Author: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
Date:   Tue Mar 31 20:35:09 2015 +0200

    ASoC: rcar: mark device data as constant
    
    A driver's device data should and can be const. This is a follow-up on
    commit 33187fb4a203 (ASoC: rsnd: constify of_device_id array) which
    marked the of_device_id as const.
    
    Signed-off-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 9b0de428c45b..6f60149acdbf 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -99,11 +99,11 @@
 #define RSND_RATES SNDRV_PCM_RATE_8000_96000
 #define RSND_FMTS (SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE)
 
-static struct rsnd_of_data rsnd_of_data_gen1 = {
+static const struct rsnd_of_data rsnd_of_data_gen1 = {
 	.flags = RSND_GEN1,
 };
 
-static struct rsnd_of_data rsnd_of_data_gen2 = {
+static const struct rsnd_of_data rsnd_of_data_gen2 = {
 	.flags = RSND_GEN2,
 };
 

commit 3b7843ff618f63d1776abd71de7eea9130987037
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 26 04:02:51 2015 +0000

    ASoC: rsnd: add DPCM based sampling rate convert
    
    This patch supports DPCM based sampling rate convert on Renesas sound
    driver. It assumes...
     1. SRC is implemented as FE
     2. BE dai_link supports .be_hw_params_fixup
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 770247cddb6c..9b0de428c45b 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -203,7 +203,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
-	u32 mask = 1 << __rsnd_mod_shift_##func;			\
+	u32 mask = (1 << __rsnd_mod_shift_##func) & ~(1 << 31);	\
 	u32 call = __rsnd_mod_call_##func << __rsnd_mod_shift_##func;	\
 	int ret = 0;							\
 	if ((mod->status & mask) == call) {				\
@@ -728,6 +728,15 @@ static int rsnd_pcm_open(struct snd_pcm_substream *substream)
 static int rsnd_hw_params(struct snd_pcm_substream *substream,
 			 struct snd_pcm_hw_params *hw_params)
 {
+	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+	int ret;
+
+	ret = rsnd_dai_call(hw_params, io, substream, hw_params);
+	if (ret)
+		return ret;
+
 	return snd_pcm_lib_malloc_pages(substream,
 					params_buffer_bytes(hw_params));
 }

commit f8d04e7d91f86c61dbb096d81b99cd692b87fa19
Merge: af7e2be96623 2f78dd7f4026
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 27 16:00:39 2015 -0700

    Merge branch 'asoc-fix-rcar' into HEAD

commit 2f78dd7f40264697afed4c2ac0890df8f0588e49
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 26 04:02:09 2015 +0000

    ASoC: rsnd: call clk_prepare/unprepare() in probe/remove
    
    clk_prepare_enable()/clk_disable_unprepare() uses mutex inside,
    in concretely clk_prepare()/clk_unprepare().And it uses __schedule().
    Then, raw_spin_lock/unlock_irq() is called, and it breaks Renesas
    sound driver's spin lock irq.
    This patch separates thesse into clk_prepare()/clk_unprepare() and
    clk_enable/clk_disable. And call clk_prepare()/clk_unprepare() from
    probe/remove function. Special thanks to Das Biju.
    
    Reported-by: Das Biju <biju.das@bp.renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1b53605f7154..6046c10ef3c7 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -149,16 +149,29 @@ char *rsnd_mod_dma_name(struct rsnd_mod *mod)
 	return mod->ops->dma_name(mod);
 }
 
-void rsnd_mod_init(struct rsnd_mod *mod,
+int rsnd_mod_init(struct rsnd_mod *mod,
 		   struct rsnd_mod_ops *ops,
 		   struct clk *clk,
 		   enum rsnd_mod_type type,
 		   int id)
 {
+	int ret = clk_prepare(clk);
+
+	if (ret)
+		return ret;
+
 	mod->id		= id;
 	mod->ops	= ops;
 	mod->type	= type;
 	mod->clk	= clk;
+
+	return ret;
+}
+
+void rsnd_mod_quit(struct rsnd_mod *mod)
+{
+	if (mod->clk)
+		clk_unprepare(mod->clk);
 }
 
 /*
@@ -1290,6 +1303,12 @@ static int rsnd_remove(struct platform_device *pdev)
 {
 	struct rsnd_priv *priv = dev_get_drvdata(&pdev->dev);
 	struct rsnd_dai *rdai;
+	void (*remove_func[])(struct platform_device *pdev,
+			      struct rsnd_priv *priv) = {
+		rsnd_ssi_remove,
+		rsnd_src_remove,
+		rsnd_dvc_remove,
+	};
 	int ret = 0, i;
 
 	pm_runtime_disable(&pdev->dev);
@@ -1299,6 +1318,9 @@ static int rsnd_remove(struct platform_device *pdev)
 		ret |= rsnd_dai_call(remove, &rdai->capture, priv);
 	}
 
+	for (i = 0; i < ARRAY_SIZE(remove_func); i++)
+		remove_func[i](pdev, priv);
+
 	snd_soc_unregister_component(&pdev->dev);
 	snd_soc_unregister_platform(&pdev->dev);
 

commit f8c3c3094302cb25d9720804b8100fdd37a3ace0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 19 04:15:18 2015 +0000

    ASoC: rsnd: add dai_link stream name
    
    This patch adds missing dai_link stream_name
    which is used when DPCM
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index cd78a17f9cf9..519d85692e0c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -648,20 +648,28 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 		drv[i].name	= rdai[i].name;
 		drv[i].ops	= &rsnd_soc_dai_ops;
 		if (pmod) {
+			snprintf(rdai[i].playback.name, RSND_DAI_NAME_SIZE,
+				 "DAI%d Playback", i);
+
 			drv[i].playback.rates		= RSND_RATES;
 			drv[i].playback.formats		= RSND_FMTS;
 			drv[i].playback.channels_min	= 2;
 			drv[i].playback.channels_max	= 2;
+			drv[i].playback.stream_name	= rdai[i].playback.name;
 
 			rdai[i].playback.info = &info->dai_info[i].playback;
 			rdai[i].playback.rdai = rdai + i;
 			rsnd_path_init(priv, &rdai[i], &rdai[i].playback);
 		}
 		if (cmod) {
+			snprintf(rdai[i].capture.name, RSND_DAI_NAME_SIZE,
+				 "DAI%d Capture", i);
+
 			drv[i].capture.rates		= RSND_RATES;
 			drv[i].capture.formats		= RSND_FMTS;
 			drv[i].capture.channels_min	= 2;
 			drv[i].capture.channels_max	= 2;
+			drv[i].capture.stream_name	= rdai[i].capture.name;
 
 			rdai[i].capture.info = &info->dai_info[i].capture;
 			rdai[i].capture.rdai = rdai + i;

commit 072bd1e7e136e089e41c8cc2d2b2251ed60b5bcd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 19 04:14:20 2015 +0000

    ASoC: rsnd: tidyup error message format
    
    This driver sometimes fixups debug/error message format
    30cc4faf703955cd5cd07da489bd817ae43e3fec
    (ASoC: rsnd: tidyup debug message format and timing)
    337b0b4c5f415705f1b97df57cecfac45903449a
    (ASoC: rsnd: error meesage indicates its port)
    But, it still exist un-fomated error message. This patch fixup it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7be1602f57f3..cd78a17f9cf9 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -232,7 +232,7 @@ static int rsnd_dai_connect(struct rsnd_mod *mod,
 		struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 		struct device *dev = rsnd_priv_to_dev(priv);
 
-		dev_err(dev, "%s%d is not empty\n",
+		dev_err(dev, "%s[%d] is not empty\n",
 			rsnd_mod_name(mod),
 			rsnd_mod_id(mod));
 		return -EIO;

commit 33187fb4a203e44dec11211f2fa86a63139615bc
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Mar 18 17:49:02 2015 +0100

    ASoC: rsnd: constify of_device_id array
    
    of_device_id is always used as const.
    (See driver.of_match_table and open firmware functions)
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7b995f025e22..7be1602f57f3 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -107,7 +107,7 @@ static struct rsnd_of_data rsnd_of_data_gen2 = {
 	.flags = RSND_GEN2,
 };
 
-static struct of_device_id rsnd_of_match[] = {
+static const struct of_device_id rsnd_of_match[] = {
 	{ .compatible = "renesas,rcar_sound-gen1", .data = &rsnd_of_data_gen1 },
 	{ .compatible = "renesas,rcar_sound-gen2", .data = &rsnd_of_data_gen2 },
 	{},

commit 72adc61f4637aa3596c1db1129f84d768475a885
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:31:23 2015 +0000

    ASoC: rsnd: 1st DMAC dma-names cares subnode
    
    Renesas R-Car sound (= rsnd) needs 2 DMAC which are called as
    Audio DMAC (= 1st DMAC) and Audio DMAC peri peri (2nd DMAC).
    And rsnd had assumed that 1st / 2nd DMACs are implemented as DMAEngine.
    But, in result of DMA ML discussion, 2nd DMAC was concluded that it is
    not a general purpose DMAC (2nd DMAC is for Device to Device inside
    sound system). Additionally, current DMAEngine can't support Device to
    Device, and we don't have correct DT bindings for it at this point.
    So the easiest solution for it is that move it from DMAEngine to rsnd
    driver.
    
    dma-names on DT was implemented as no difference between 1st / 2nd
    DMAC's, since rsnd had assumed that both DMACs are implemented as
    DMAEngine. That style was "src_dst". But now, 2nd DMAC was implemented
    as non DMAEngine, and it doesn't need dma-names anymore. So, this
    dma-names rule is no longer needed.
    
    And additionally, dma-names was assumed that it has all
    (= SSI/SSIU/SRC/DVC) nodes under sound node.
    
    In upstream code, no SoC/platform is supporting DMA for rsnd driver yet.
    This means there is no compatible issue if this patch changes
    dma-names's rule of DT.
    
    This patch assumes dma-names for 1st DMAC are tx/rx base, and listed
    in each SSI/SRC/DVC subnode
    ex)
            rcar_sound,dvc {
                    dvc0: dvc@0 {
                            dmas = <&audma0 0xbc>;
                            dma-names = "tx";
                    };
            ...
    
            rcar_sound,src {
                    src0: src@0 {
                            ...
                            dmas = <&audma0 0x85>, <&audma1 0x9a>;
                            dma-names = "rx", "tx";
                    };
            ...
    
            rcar_sound,ssi {
                    ssi0: ssi@0 {
                            ...
                            dmas = <&audma0 0x01>, <&audma1 0x02>, <&audma0 0x15>, <&audma1 0x16>;
                            dma-names = "rx", "tx", "rxu", "txu";
                    };
            ...
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 3b6e21948c71..7b995f025e22 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -137,15 +137,12 @@ char *rsnd_mod_name(struct rsnd_mod *mod)
 	return mod->ops->name;
 }
 
-char *rsnd_mod_dma_name(struct rsnd_mod *mod)
+struct dma_chan *rsnd_mod_dma_req(struct rsnd_mod *mod)
 {
-	if (!mod || !mod->ops)
-		return "unknown";
-
-	if (!mod->ops->dma_name)
-		return mod->ops->name;
+	if (!mod || !mod->ops || !mod->ops->dma_req)
+		return NULL;
 
-	return mod->ops->dma_name(mod);
+	return mod->ops->dma_req(mod);
 }
 
 void rsnd_mod_init(struct rsnd_mod *mod,

commit 288f392e729dd4d3719c2319c7c3f8d4c820488b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:27:42 2015 +0000

    ASoC: rsnd: add Audio DMAC peri peri support rework
    
    Renesas R-Car sound (= rsnd) needs 2 DMAC which are called as
    Audio DMAC (= 1st DMAC) and Audio DMAC peri peri (2nd DMAC).
    And rsnd had assumed that 1st / 2nd DMACs are implemented as DMAEngine.
    But, in result of DMA ML discussion, 2nd DMAC was concluded that it is
    not a general purpose DMAC (2nd DMAC is for Device to Device inside
    sound system). Additionally, current DMAEngine can't support Device to
    Device, and we don't have correct DT bindings for it at this point.
    So the easiest solution for it is that move it from DMAEngine to rsnd
    driver.
    Audio DMAC peri peri is controlled from sound driver without DMAEngine
    by this patch.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 9beea9ba338a..3b6e21948c71 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -974,6 +974,7 @@ static int rsnd_probe(struct platform_device *pdev)
 			    const struct rsnd_of_data *of_data,
 			    struct rsnd_priv *priv) = {
 		rsnd_gen_probe,
+		rsnd_dma_probe,
 		rsnd_ssi_probe,
 		rsnd_src_probe,
 		rsnd_dvc_probe,

commit bfe834be9525a82c8a40380c7df8ca3b149e9c93
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:25:55 2015 +0000

    ASoC: rsnd: add dma.c for Audio DMAC / Audio DMAC peri peri
    
    Renesas sound driver had been assumed that Audio DMAC /
    Audio DMAC peri peri are implemented by DMAEngine. But, result of DMA
    ML discussion, it was concluded that it is not a general purpose DMAC.
    And it should be moved from current DMAEngine to rsnd driver.
    So, Audio DMAC peri peri become non DMAEngine.
    
    OTOH, ALSA SoC has soc-generic-dmaengine-pcm implementation. but it
    seems difficult to use this generic implementation on rsnd driver at
    this point, since it needs to fallback to PIO mode if DMA can't use.
    and additionally it needs 2 DMAC (= Audio DMAC / Audio DMAC peri peri).
    These are not "generic" feature.
    
    Of course I will try to use this generic dmaengine in the future somehow,
    but just use current style at this point until it can formally use 2 DMACs.
    This patch adds new dma.c and moves current dma code to dma.c from core.c.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7db686d0cbd8..9beea9ba338a 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -160,224 +160,6 @@ void rsnd_mod_init(struct rsnd_mod *mod,
 	mod->clk	= clk;
 }
 
-/*
- *	rsnd_dma functions
- */
-void rsnd_dma_stop(struct rsnd_dma *dma)
-{
-	dmaengine_terminate_all(dma->chan);
-}
-
-static void rsnd_dma_complete(void *data)
-{
-	struct rsnd_dma *dma = (struct rsnd_dma *)data;
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
-
-	/*
-	 * Renesas sound Gen1 needs 1 DMAC,
-	 * Gen2 needs 2 DMAC.
-	 * In Gen2 case, it are Audio-DMAC, and Audio-DMAC-peri-peri.
-	 * But, Audio-DMAC-peri-peri doesn't have interrupt,
-	 * and this driver is assuming that here.
-	 *
-	 * If Audio-DMAC-peri-peri has interrpt,
-	 * rsnd_dai_pointer_update() will be called twice,
-	 * ant it will breaks io->byte_pos
-	 */
-
-	rsnd_dai_pointer_update(io, io->byte_per_period);
-}
-
-void rsnd_dma_start(struct rsnd_dma *dma)
-{
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
-	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
-	struct snd_pcm_substream *substream = io->substream;
-	struct device *dev = rsnd_priv_to_dev(priv);
-	struct dma_async_tx_descriptor *desc;
-
-	desc = dmaengine_prep_dma_cyclic(dma->chan,
-					 (dma->addr) ? dma->addr :
-					 substream->runtime->dma_addr,
-					 snd_pcm_lib_buffer_bytes(substream),
-					 snd_pcm_lib_period_bytes(substream),
-					 dma->dir,
-					 DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
-
-	if (!desc) {
-		dev_err(dev, "dmaengine_prep_slave_sg() fail\n");
-		return;
-	}
-
-	desc->callback		= rsnd_dma_complete;
-	desc->callback_param	= dma;
-
-	if (dmaengine_submit(desc) < 0) {
-		dev_err(dev, "dmaengine_submit() fail\n");
-		return;
-	}
-
-	dma_async_issue_pending(dma->chan);
-}
-
-#define DMA_NAME_SIZE 16
-#define MOD_MAX 4 /* MEM/SSI/SRC/DVC */
-static int _rsnd_dma_of_name(char *dma_name, struct rsnd_mod *mod)
-{
-	if (mod)
-		return snprintf(dma_name, DMA_NAME_SIZE / 2, "%s%d",
-			 rsnd_mod_dma_name(mod), rsnd_mod_id(mod));
-	else
-		return snprintf(dma_name, DMA_NAME_SIZE / 2, "mem");
-
-}
-
-static void rsnd_dma_of_name(struct rsnd_mod *mod_from,
-			     struct rsnd_mod *mod_to,
-			     char *dma_name)
-{
-	int index = 0;
-
-	index = _rsnd_dma_of_name(dma_name + index, mod_from);
-	*(dma_name + index++) = '_';
-	index = _rsnd_dma_of_name(dma_name + index, mod_to);
-}
-
-static void rsnd_dma_of_path(struct rsnd_dma *dma,
-			     int is_play,
-			     struct rsnd_mod **mod_from,
-			     struct rsnd_mod **mod_to)
-{
-	struct rsnd_mod *this = rsnd_dma_to_mod(dma);
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(this);
-	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
-	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
-	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
-	struct rsnd_mod *mod[MOD_MAX];
-	int i, index;
-
-
-	for (i = 0; i < MOD_MAX; i++)
-		mod[i] = NULL;
-
-	/*
-	 * in play case...
-	 *
-	 * src -> dst
-	 *
-	 * mem -> SSI
-	 * mem -> SRC -> SSI
-	 * mem -> SRC -> DVC -> SSI
-	 */
-	mod[0] = NULL; /* for "mem" */
-	index = 1;
-	for (i = 1; i < MOD_MAX; i++) {
-		if (!src) {
-			mod[i] = ssi;
-		} else if (!dvc) {
-			mod[i] = src;
-			src = NULL;
-		} else {
-			if ((!is_play) && (this == src))
-				this = dvc;
-
-			mod[i] = (is_play) ? src : dvc;
-			i++;
-			mod[i] = (is_play) ? dvc : src;
-			src = NULL;
-			dvc = NULL;
-		}
-
-		if (mod[i] == this)
-			index = i;
-
-		if (mod[i] == ssi)
-			break;
-	}
-
-	if (is_play) {
-		*mod_from = mod[index - 1];
-		*mod_to   = mod[index];
-	} else {
-		*mod_from = mod[index];
-		*mod_to   = mod[index - 1];
-	}
-}
-
-int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
-{
-	struct device *dev = rsnd_priv_to_dev(priv);
-	struct dma_slave_config cfg;
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
-	struct rsnd_mod *mod_from;
-	struct rsnd_mod *mod_to;
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
-	int is_play = rsnd_io_is_play(io);
-	char dma_name[DMA_NAME_SIZE];
-	dma_cap_mask_t mask;
-	int ret;
-
-	if (dma->chan) {
-		dev_err(dev, "it already has dma channel\n");
-		return -EIO;
-	}
-
-	dma_cap_zero(mask);
-	dma_cap_set(DMA_SLAVE, mask);
-
-	rsnd_dma_of_path(dma, is_play, &mod_from, &mod_to);
-	rsnd_dma_of_name(mod_from, mod_to, dma_name);
-
-	cfg.slave_id	= id;
-	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
-	cfg.src_addr	= rsnd_gen_dma_addr(priv, mod_from, is_play, 1);
-	cfg.dst_addr	= rsnd_gen_dma_addr(priv, mod_to,   is_play, 0);
-	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-
-	dev_dbg(dev, "dma : %s %pad -> %pad\n",
-		dma_name, &cfg.src_addr, &cfg.dst_addr);
-
-	dma->chan = dma_request_slave_channel_compat(mask, shdma_chan_filter,
-						     (void *)id, dev,
-						     dma_name);
-	if (!dma->chan) {
-		dev_err(dev, "can't get dma channel\n");
-		goto rsnd_dma_channel_err;
-	}
-
-	ret = dmaengine_slave_config(dma->chan, &cfg);
-	if (ret < 0)
-		goto rsnd_dma_init_err;
-
-	dma->addr = is_play ? cfg.src_addr : cfg.dst_addr;
-	dma->dir = is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
-
-	return 0;
-
-rsnd_dma_init_err:
-	rsnd_dma_quit(dma);
-rsnd_dma_channel_err:
-
-	/*
-	 * DMA failed. try to PIO mode
-	 * see
-	 *	rsnd_ssi_fallback()
-	 *	rsnd_rdai_continuance_probe()
-	 */
-	return -EAGAIN;
-}
-
-void  rsnd_dma_quit(struct rsnd_dma *dma)
-{
-	if (dma->chan)
-		dma_release_channel(dma->chan);
-
-	dma->chan = NULL;
-}
-
 /*
  *	settting function
  */

commit 8a2ff4262ca611c38b31fec0af65be656d934f52
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:24:06 2015 +0000

    ASoC: rsnd: remove un-needed parameter from rsnd_dma_quit()
    
    priv is not used on rsnd_dma_quit()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1da94bf730d2..7db686d0cbd8 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -358,7 +358,7 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 	return 0;
 
 rsnd_dma_init_err:
-	rsnd_dma_quit(priv, dma);
+	rsnd_dma_quit(dma);
 rsnd_dma_channel_err:
 
 	/*
@@ -370,8 +370,7 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 	return -EAGAIN;
 }
 
-void  rsnd_dma_quit(struct rsnd_priv *priv,
-		    struct rsnd_dma *dma)
+void  rsnd_dma_quit(struct rsnd_dma *dma)
 {
 	if (dma->chan)
 		dma_release_channel(dma->chan);

commit 9c706ab29f33b9562f570d1e99e21955d898dc85
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:23:39 2015 +0000

    ASoC: rsnd: remove unused rsnd_dma_available()
    
    rsnd_dma_available() is not used. Let's remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1edf4dc41c70..1da94bf730d2 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -222,11 +222,6 @@ void rsnd_dma_start(struct rsnd_dma *dma)
 	dma_async_issue_pending(dma->chan);
 }
 
-int rsnd_dma_available(struct rsnd_dma *dma)
-{
-	return !!dma->chan;
-}
-
 #define DMA_NAME_SIZE 16
 #define MOD_MAX 4 /* MEM/SSI/SRC/DVC */
 static int _rsnd_dma_of_name(char *dma_name, struct rsnd_mod *mod)

commit 4715219ecef50cf79d7784545bf5bb4664bb800d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:23:08 2015 +0000

    ASoC: rsnd: remove un-needed parameter from rsnd_dma_init()
    
    It can get DMA direction via rsnd_dai_stream.
    Remove un-needed is_play from rsnd_dma_init().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 0b14d3762cff..1edf4dc41c70 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -311,13 +311,15 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	}
 }
 
-int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
-		  int is_play, int id)
+int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_slave_config cfg;
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_mod *mod_from;
 	struct rsnd_mod *mod_to;
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	int is_play = rsnd_io_is_play(io);
 	char dma_name[DMA_NAME_SIZE];
 	dma_cap_mask_t mask;
 	int ret;

commit c303cf0895ad927f5e9b8a5f8ed1c6b8c96a500f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:22:37 2015 +0000

    ASoC: rsnd: remove SH-DMA-BASE specific implementation
    
    Renesas R-Car sound had SH-DMA-BASE specific implementation before,
    but, now, it is no longer needed. Let's remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1b53605f7154..0b14d3762cff 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -94,7 +94,6 @@
  *
  */
 #include <linux/pm_runtime.h>
-#include <linux/shdma-base.h>
 #include "rsnd.h"
 
 #define RSND_RATES SNDRV_PCM_RATE_8000_96000

commit e0427428db79f7d6648f27985c775b3f6f5db28b
Merge: a9ca2a3cf40b 0b1f6ec7a5fb
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Mar 4 20:42:41 2015 +0000

    Merge remote-tracking branch 'asoc/fix/rsnd' into asoc-linus

commit 0b1f6ec7a5fb3faff1a62afee132dac316eec63d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 9 08:05:22 2015 +0000

    ASoC: rsnd: set device data before snd_soc_register_platform/component
    
    Set device data before snd_soc_register_platform/component.
    Otherwise, it will use NULL pointer if user calls unbind -> bind or
    rmmod -> insmod
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 75308bbc2ce8..fc227d3bc021 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1268,6 +1268,8 @@ static int rsnd_probe(struct platform_device *pdev)
 			goto exit_snd_probe;
 	}
 
+	dev_set_drvdata(dev, priv);
+
 	/*
 	 *	asoc register
 	 */
@@ -1284,8 +1286,6 @@ static int rsnd_probe(struct platform_device *pdev)
 		goto exit_snd_soc;
 	}
 
-	dev_set_drvdata(dev, priv);
-
 	pm_runtime_enable(dev);
 
 	dev_info(dev, "probed\n");

commit d7c42ff8c34f1c291fcd45c7d56d41aba68c4b13
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 2 04:54:07 2015 +0000

    ASoC: rsnd: call missing snd_soc_unregiter_component/platform()
    
    Current Renesas R-Car sound driver doesn't call
    snd_soc_unregiter_component/platform() in .remove.
    This patch call these functions.
    
    Reported-by: Nguyen Viet Dung <nv-dung@jinso.co.jp>
    Reported-by: Bui Duc Phuc <bd-phuc@jinso.co.jp>
    Reported-by: Cao Minh Hiep <cm-hiep@jinso.co.jp>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 6fb38b879bb6..1b53605f7154 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1299,6 +1299,9 @@ static int rsnd_remove(struct platform_device *pdev)
 		ret |= rsnd_dai_call(remove, &rdai->capture, priv);
 	}
 
+	snd_soc_unregister_component(&pdev->dev);
+	snd_soc_unregister_platform(&pdev->dev);
+
 	return ret;
 }
 

commit d1f83d6ef43bf1b4a3d19805098b3a9724047479
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 2 04:53:53 2015 +0000

    ASoC: rsnd: call missing snd_ctl_remove()
    
    Current Renesas R-Car sound driver is using snd_ctl_xxx()
    functions, but it didn't call snd_ctl free_one() / snd_ctl_remove().
    This patch call these functions.
    
    Reported-by: Nguyen Viet Dung <nv-dung@jinso.co.jp>
    Reported-by: Bui Duc Phuc <bd-phuc@jinso.co.jp>
    Reported-by: Cao Minh Hiep <cm-hiep@jinso.co.jp>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f0bb137da31b..6fb38b879bb6 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1046,14 +1046,23 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 		return -ENOMEM;
 
 	ret = snd_ctl_add(card, kctrl);
-	if (ret < 0)
+	if (ret < 0) {
+		snd_ctl_free_one(kctrl);
 		return ret;
+	}
 
 	cfg->update = update;
+	cfg->card = card;
+	cfg->kctrl = kctrl;
 
 	return 0;
 }
 
+void _rsnd_kctrl_remove(struct rsnd_kctrl_cfg *cfg)
+{
+	snd_ctl_remove(cfg->card, cfg->kctrl);
+}
+
 int rsnd_kctrl_new_m(struct rsnd_mod *mod,
 		     struct snd_soc_pcm_runtime *rtd,
 		     const unsigned char *name,

commit 1b13d118ee8f25227ad779c0f62b46e997e9f5a3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 15 08:08:34 2015 +0000

    ASoC: rsnd: save priv in struct rsnd_dai
    
    Current rsnd driver has rsnd_mod_to_priv() macro, and struct rsnd_mod
    has struct rsnd_priv pointer. But, it is waste of memory from data
    structure point of view.
    Today we can link mod <-> io <-> rdai each other, so saving priv in
    rdai is very reasonable.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 6fa8709571ff..f0bb137da31b 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -149,14 +149,12 @@ char *rsnd_mod_dma_name(struct rsnd_mod *mod)
 	return mod->ops->dma_name(mod);
 }
 
-void rsnd_mod_init(struct rsnd_priv *priv,
-		   struct rsnd_mod *mod,
+void rsnd_mod_init(struct rsnd_mod *mod,
 		   struct rsnd_mod_ops *ops,
 		   struct clk *clk,
 		   enum rsnd_mod_type type,
 		   int id)
 {
-	mod->priv	= priv;
 	mod->id		= id;
 	mod->ops	= ops;
 	mod->type	= type;
@@ -868,6 +866,7 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 		 *	init rsnd_dai
 		 */
 		snprintf(rdai[i].name, RSND_DAI_NAME_SIZE, "rsnd-dai.%d", i);
+		rdai[i].priv = priv;
 
 		/*
 		 *	init snd_soc_dai_driver

commit 690602fcd85385ff325b65fe4bba32ceaf3c33a3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 15 08:07:47 2015 +0000

    ASoC: rsnd: replace rdai to priv in each function
    
    Current rsnd driver's function requests rdai, but it is not used.
    Adding priv is more reasonable. Let's replace it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 74e2c4214058..6fa8709571ff 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -414,7 +414,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 /*
  *	rsnd_dai functions
  */
-#define __rsnd_mod_call(mod, func, rdai...)			\
+#define __rsnd_mod_call(mod, func, param...)			\
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
@@ -424,18 +424,18 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 	if ((mod->status & mask) == call) {				\
 		dev_dbg(dev, "%s[%d] %s\n",				\
 			rsnd_mod_name(mod), rsnd_mod_id(mod), #func);	\
-		ret = (mod)->ops->func(mod, rdai);			\
+		ret = (mod)->ops->func(mod, param);			\
 		mod->status = (mod->status & ~mask) | (~call & mask);	\
 	}								\
 	ret;								\
 })
 
-#define rsnd_mod_call(mod, func, rdai...)	\
+#define rsnd_mod_call(mod, func, param...)	\
 	(!(mod) ? -ENODEV :			\
 	 !((mod)->ops->func) ? 0 :		\
-	 __rsnd_mod_call(mod, func, rdai))
+	 __rsnd_mod_call(mod, func, param))
 
-#define rsnd_dai_call(fn, io, rdai...)				\
+#define rsnd_dai_call(fn, io, param...)				\
 ({								\
 	struct rsnd_mod *mod;					\
 	int ret = 0, i;						\
@@ -443,7 +443,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 		mod = (io)->mod[i];				\
 		if (!mod)					\
 			continue;				\
-		ret = rsnd_mod_call(mod, fn, rdai);		\
+		ret = rsnd_mod_call(mod, fn, param);		\
 		if (ret < 0)					\
 			break;					\
 	}							\
@@ -585,20 +585,20 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (ret < 0)
 			goto dai_trigger_end;
 
-		ret = rsnd_dai_call(init, io, rdai);
+		ret = rsnd_dai_call(init, io, priv);
 		if (ret < 0)
 			goto dai_trigger_end;
 
-		ret = rsnd_dai_call(start, io, rdai);
+		ret = rsnd_dai_call(start, io, priv);
 		if (ret < 0)
 			goto dai_trigger_end;
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-		ret = rsnd_dai_call(stop, io, rdai);
+		ret = rsnd_dai_call(stop, io, priv);
 		if (ret < 0)
 			goto dai_trigger_end;
 
-		ret = rsnd_dai_call(quit, io, rdai);
+		ret = rsnd_dai_call(quit, io, priv);
 		if (ret < 0)
 			goto dai_trigger_end;
 
@@ -1109,11 +1109,11 @@ static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	int ret;
 
-	ret = rsnd_dai_call(pcm_new, &rdai->playback, rdai, rtd);
+	ret = rsnd_dai_call(pcm_new, &rdai->playback, rtd);
 	if (ret)
 		return ret;
 
-	ret = rsnd_dai_call(pcm_new, &rdai->capture, rdai, rtd);
+	ret = rsnd_dai_call(pcm_new, &rdai->capture, rtd);
 	if (ret)
 		return ret;
 
@@ -1136,10 +1136,9 @@ static const struct snd_soc_component_driver rsnd_soc_component = {
 static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 				       struct rsnd_dai_stream *io)
 {
-	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
 	int ret;
 
-	ret = rsnd_dai_call(probe, io, rdai);
+	ret = rsnd_dai_call(probe, io, priv);
 	if (ret == -EAGAIN) {
 		/*
 		 * Fallback to PIO mode
@@ -1152,7 +1151,7 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 		 *	rsnd_dma_init()
 		 *	rsnd_ssi_fallback()
 		 */
-		rsnd_dai_call(remove, io, rdai);
+		rsnd_dai_call(remove, io, priv);
 
 		/*
 		 * remove SRC/DVC from DAI,
@@ -1163,13 +1162,13 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 		/*
 		 * fallback
 		 */
-		rsnd_dai_call(fallback, io, rdai);
+		rsnd_dai_call(fallback, io, priv);
 
 		/*
 		 * retry to "probe".
 		 * DAI has SSI which is PIO mode only now.
 		 */
-		ret = rsnd_dai_call(probe, io, rdai);
+		ret = rsnd_dai_call(probe, io, priv);
 	}
 
 	return ret;
@@ -1272,8 +1271,8 @@ static int rsnd_probe(struct platform_device *pdev)
 	snd_soc_unregister_platform(dev);
 exit_snd_probe:
 	for_each_rsnd_dai(rdai, priv, i) {
-		rsnd_dai_call(remove, &rdai->playback, rdai);
-		rsnd_dai_call(remove, &rdai->capture, rdai);
+		rsnd_dai_call(remove, &rdai->playback, priv);
+		rsnd_dai_call(remove, &rdai->capture, priv);
 	}
 
 	return ret;
@@ -1288,8 +1287,8 @@ static int rsnd_remove(struct platform_device *pdev)
 	pm_runtime_disable(&pdev->dev);
 
 	for_each_rsnd_dai(rdai, priv, i) {
-		ret |= rsnd_dai_call(remove, &rdai->playback, rdai);
-		ret |= rsnd_dai_call(remove, &rdai->capture, rdai);
+		ret |= rsnd_dai_call(remove, &rdai->playback, priv);
+		ret |= rsnd_dai_call(remove, &rdai->capture, priv);
 	}
 
 	return ret;

commit f708d944fee384961f5ab7df3463760099c9d69c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 15 08:07:19 2015 +0000

    ASoC: rsnd: remove unsed rdai parameter from each function
    
    Current rsnd driver's many functions requests struct rsnd_dai (= rdai),
    but, 1) we can get rdai from rsnd_io_to_rsnd(), 2) almost all rdai
    is not used. Let's remove these rdai.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index c1f577da41fe..74e2c4214058 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1025,7 +1025,6 @@ static int rsnd_kctrl_put(struct snd_kcontrol *kctrl,
 }
 
 static int __rsnd_kctrl_new(struct rsnd_mod *mod,
-			    struct rsnd_dai *rdai,
 			    struct snd_soc_pcm_runtime *rtd,
 			    const unsigned char *name,
 			    struct rsnd_kctrl_cfg *cfg,
@@ -1057,7 +1056,6 @@ static int __rsnd_kctrl_new(struct rsnd_mod *mod,
 }
 
 int rsnd_kctrl_new_m(struct rsnd_mod *mod,
-		     struct rsnd_dai *rdai,
 		     struct snd_soc_pcm_runtime *rtd,
 		     const unsigned char *name,
 		     void (*update)(struct rsnd_mod *mod),
@@ -1067,11 +1065,10 @@ int rsnd_kctrl_new_m(struct rsnd_mod *mod,
 	_cfg->cfg.max	= max;
 	_cfg->cfg.size	= RSND_DVC_CHANNELS;
 	_cfg->cfg.val	= _cfg->val;
-	return __rsnd_kctrl_new(mod, rdai, rtd, name, &_cfg->cfg, update);
+	return __rsnd_kctrl_new(mod, rtd, name, &_cfg->cfg, update);
 }
 
 int rsnd_kctrl_new_s(struct rsnd_mod *mod,
-		     struct rsnd_dai *rdai,
 		     struct snd_soc_pcm_runtime *rtd,
 		     const unsigned char *name,
 		     void (*update)(struct rsnd_mod *mod),
@@ -1081,11 +1078,10 @@ int rsnd_kctrl_new_s(struct rsnd_mod *mod,
 	_cfg->cfg.max	= max;
 	_cfg->cfg.size	= 1;
 	_cfg->cfg.val	= &_cfg->val;
-	return __rsnd_kctrl_new(mod, rdai, rtd, name, &_cfg->cfg, update);
+	return __rsnd_kctrl_new(mod, rtd, name, &_cfg->cfg, update);
 }
 
 int rsnd_kctrl_new_e(struct rsnd_mod *mod,
-		     struct rsnd_dai *rdai,
 		     struct snd_soc_pcm_runtime *rtd,
 		     const unsigned char *name,
 		     struct rsnd_kctrl_cfg_s *_cfg,
@@ -1097,7 +1093,7 @@ int rsnd_kctrl_new_e(struct rsnd_mod *mod,
 	_cfg->cfg.size	= 1;
 	_cfg->cfg.val	= &_cfg->val;
 	_cfg->cfg.texts	= texts;
-	return __rsnd_kctrl_new(mod, rdai, rtd, name, &_cfg->cfg, update);
+	return __rsnd_kctrl_new(mod, rtd, name, &_cfg->cfg, update);
 }
 
 /*
@@ -1138,10 +1134,9 @@ static const struct snd_soc_component_driver rsnd_soc_component = {
 };
 
 static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
-				       struct rsnd_dai *rdai,
-				       int is_play)
+				       struct rsnd_dai_stream *io)
 {
-	struct rsnd_dai_stream *io = is_play ? &rdai->playback : &rdai->capture;
+	struct rsnd_dai *rdai = rsnd_io_to_rdai(io);
 	int ret;
 
 	ret = rsnd_dai_call(probe, io, rdai);
@@ -1241,11 +1236,11 @@ static int rsnd_probe(struct platform_device *pdev)
 	}
 
 	for_each_rsnd_dai(rdai, priv, i) {
-		ret = rsnd_rdai_continuance_probe(priv, rdai, 1);
+		ret = rsnd_rdai_continuance_probe(priv, &rdai->playback);
 		if (ret)
 			goto exit_snd_probe;
 
-		ret = rsnd_rdai_continuance_probe(priv, rdai, 0);
+		ret = rsnd_rdai_continuance_probe(priv, &rdai->capture);
 		if (ret)
 			goto exit_snd_probe;
 	}

commit 985a4f6e61560c4cba19d910a0d81757a1063571
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 15 08:06:49 2015 +0000

    ASoC: rsnd: replace rsnd_dai_is_play() to rsnd_io_is_play()
    
    Current rsnd driver can use rsnd_io_to_rdai()
    we can get play/capture direction via io now.
    Let's replace rsnd_dai_is_play() to rsnd_io_is_play()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index c8111857c9d9..c1f577da41fe 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -494,11 +494,6 @@ static struct rsnd_dai *rsnd_dai_to_rdai(struct snd_soc_dai *dai)
 	return rsnd_rdai_get(priv, dai->id);
 }
 
-int rsnd_dai_is_play(struct rsnd_dai *rdai, struct rsnd_dai_stream *io)
-{
-	return &rdai->playback == io;
-}
-
 /*
  *	rsnd_soc_dai functions
  */

commit 54cb556247b171753484efb3c4777ca4d1babfa0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 15 08:06:24 2015 +0000

    ASoC: rsnd: add rsnd_io_to_rdai()
    
    Current rsnd driver request rdai in everywhere, but each mod should
    reach to rdai by itself. this patch adds missing rsnd_io_to_rdai().
    
    io   = rsnd_mod_to_io(mod);
    rdai = rsnd_io_to_rdai(io);
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 852fa0410afd..c8111857c9d9 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -886,6 +886,7 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 			drv[i].playback.channels_max	= 2;
 
 			rdai[i].playback.info = &info->dai_info[i].playback;
+			rdai[i].playback.rdai = rdai + i;
 			rsnd_path_init(priv, &rdai[i], &rdai[i].playback);
 		}
 		if (cmod) {
@@ -895,6 +896,7 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 			drv[i].capture.channels_max	= 2;
 
 			rdai[i].capture.info = &info->dai_info[i].capture;
+			rdai[i].capture.rdai = rdai + i;
 			rsnd_path_init(priv, &rdai[i], &rdai[i].capture);
 		}
 

commit 7c57d76f5181d50ae04adf92180c5d53dd3c9756
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 15 08:05:59 2015 +0000

    ASoC: rsnd: remove rsnd_dai_get_platform_info() macro
    
    rsnd_dai_get_platform_info() is not used. Let's remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 487ddf78b8ee..852fa0410afd 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -865,10 +865,9 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 	priv->rdai	= rdai;
 
 	for (i = 0; i < dai_nr; i++) {
-		rdai[i].info = &info->dai_info[i];
 
-		pmod = rdai[i].info->playback.ssi;
-		cmod = rdai[i].info->capture.ssi;
+		pmod = info->dai_info[i].playback.ssi;
+		cmod = info->dai_info[i].capture.ssi;
 
 		/*
 		 *	init rsnd_dai

commit 2842aa719252bbec99869b03dfc42c52a307877a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 15 08:05:10 2015 +0000

    ASoC: rsnd: remove unused rsnd_dai_id()
    
    rsnd_dai_id() was not used. Let's remove it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b4c25d661e3d..487ddf78b8ee 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -479,16 +479,6 @@ static void rsnd_dai_disconnect(struct rsnd_mod *mod,
 	io->mod[mod->type] = NULL;
 }
 
-int rsnd_dai_id(struct rsnd_priv *priv, struct rsnd_dai *rdai)
-{
-	int id = rdai - priv->rdai;
-
-	if ((id < 0) || (id >= rsnd_rdai_nr(priv)))
-		return -EINVAL;
-
-	return id;
-}
-
 struct rsnd_dai *rsnd_rdai_get(struct rsnd_priv *priv, int id)
 {
 	if ((id < 0) || (id >= rsnd_rdai_nr(priv)))

commit 710d088923856bb0e0369e675985047a51ba729c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 15 08:03:38 2015 +0000

    ASoC: rsnd: rename rsnd_dai_get() to rsnd_rdai_get()
    
    struct rsnd_dai is called as "rdai", and struct snd_soc_dai is called
    as "dai" on this driver. but macro/function have confusable naming.
    This patch rename rsnd_dai_get() to rsnd_rdai_get()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 766bd4ce439b..b4c25d661e3d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -489,7 +489,7 @@ int rsnd_dai_id(struct rsnd_priv *priv, struct rsnd_dai *rdai)
 	return id;
 }
 
-struct rsnd_dai *rsnd_dai_get(struct rsnd_priv *priv, int id)
+struct rsnd_dai *rsnd_rdai_get(struct rsnd_priv *priv, int id)
 {
 	if ((id < 0) || (id >= rsnd_rdai_nr(priv)))
 		return NULL;
@@ -501,7 +501,7 @@ static struct rsnd_dai *rsnd_dai_to_rdai(struct snd_soc_dai *dai)
 {
 	struct rsnd_priv *priv = snd_soc_dai_get_drvdata(dai);
 
-	return rsnd_dai_get(priv, dai->id);
+	return rsnd_rdai_get(priv, dai->id);
 }
 
 int rsnd_dai_is_play(struct rsnd_dai *rdai, struct rsnd_dai_stream *io)

commit 8564295231727c4a05ed2e9b8337fe70afe531ef
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 15 08:03:22 2015 +0000

    ASoC: rsnd: rsnd_mod controls clock
    
    Current rsnd driver's mod (= ssi/src/dvc) have each own clk,
    but, these are needed to start/stop each mod.
    This patch adds struct clk in rsnd_mod, and start/stop these
    via rsnd_mod_hw_start/stop() macro
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index d9c81cda09f7..766bd4ce439b 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -152,6 +152,7 @@ char *rsnd_mod_dma_name(struct rsnd_mod *mod)
 void rsnd_mod_init(struct rsnd_priv *priv,
 		   struct rsnd_mod *mod,
 		   struct rsnd_mod_ops *ops,
+		   struct clk *clk,
 		   enum rsnd_mod_type type,
 		   int id)
 {
@@ -159,6 +160,7 @@ void rsnd_mod_init(struct rsnd_priv *priv,
 	mod->id		= id;
 	mod->ops	= ops;
 	mod->type	= type;
+	mod->clk	= clk;
 }
 
 /*

commit ddf3335b3e716ab2161e4db5b70984aef35075a3
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 13:56:11 2015 +0100

    ASoC: rcar: Remove unnecessary snd_pcm_lib_preallocate_free_for_all()
    
    The ALSA core takes care that all preallocated memory is freed when the PCM
    itself is freed. There is no need to do this manually in the driver.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 75308bbc2ce8..d9c81cda09f7 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1140,15 +1140,9 @@ static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 		PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
 }
 
-static void rsnd_pcm_free(struct snd_pcm *pcm)
-{
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static struct snd_soc_platform_driver rsnd_soc_platform = {
 	.ops		= &rsnd_pcm_ops,
 	.pcm_new	= rsnd_pcm_new,
-	.pcm_free	= rsnd_pcm_free,
 };
 
 static const struct snd_soc_component_driver rsnd_soc_component = {

commit 6e6d57d07a4fb995dfdf6da4b8ced206a28d0a8a
Merge: c9098c6120f7 6cfad7896103 8d213de7ffff a5a267cf9ca9 e2dce944cc2b
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 8 13:12:07 2014 +0000

    Merge remote-tracking branches 'asoc/topic/rcar', 'asoc/topic/rockchip', 'asoc/topic/rt286' and 'asoc/topic/rt5631' into asoc-next

commit 170a2497a25688f4c6bbf011208fc5fe144ef59c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 27 08:06:14 2014 +0000

    ASoC: rsnd: move snd_kcontrol_new fucntions to core.c
    
    Current DVC is using snd_kcontrol_new functions, but, SRC will need
    same method. Move common functions to core.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index fce61a05d771..77af00831003 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -969,6 +969,150 @@ static struct snd_pcm_ops rsnd_pcm_ops = {
 	.pointer	= rsnd_pointer,
 };
 
+/*
+ *		snd_kcontrol
+ */
+#define kcontrol_to_cfg(kctrl) ((struct rsnd_kctrl_cfg *)kctrl->private_value)
+static int rsnd_kctrl_info(struct snd_kcontrol *kctrl,
+			   struct snd_ctl_elem_info *uinfo)
+{
+	struct rsnd_kctrl_cfg *cfg = kcontrol_to_cfg(kctrl);
+
+	if (cfg->texts) {
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		uinfo->count = cfg->size;
+		uinfo->value.enumerated.items = cfg->max;
+		if (uinfo->value.enumerated.item >= cfg->max)
+			uinfo->value.enumerated.item = cfg->max - 1;
+		strlcpy(uinfo->value.enumerated.name,
+			cfg->texts[uinfo->value.enumerated.item],
+			sizeof(uinfo->value.enumerated.name));
+	} else {
+		uinfo->count = cfg->size;
+		uinfo->value.integer.min = 0;
+		uinfo->value.integer.max = cfg->max;
+		uinfo->type = (cfg->max == 1) ?
+			SNDRV_CTL_ELEM_TYPE_BOOLEAN :
+			SNDRV_CTL_ELEM_TYPE_INTEGER;
+	}
+
+	return 0;
+}
+
+static int rsnd_kctrl_get(struct snd_kcontrol *kctrl,
+			  struct snd_ctl_elem_value *uc)
+{
+	struct rsnd_kctrl_cfg *cfg = kcontrol_to_cfg(kctrl);
+	int i;
+
+	for (i = 0; i < cfg->size; i++)
+		if (cfg->texts)
+			uc->value.enumerated.item[i] = cfg->val[i];
+		else
+			uc->value.integer.value[i] = cfg->val[i];
+
+	return 0;
+}
+
+static int rsnd_kctrl_put(struct snd_kcontrol *kctrl,
+			  struct snd_ctl_elem_value *uc)
+{
+	struct rsnd_mod *mod = snd_kcontrol_chip(kctrl);
+	struct rsnd_kctrl_cfg *cfg = kcontrol_to_cfg(kctrl);
+	int i, change = 0;
+
+	for (i = 0; i < cfg->size; i++) {
+		if (cfg->texts) {
+			change |= (uc->value.enumerated.item[i] != cfg->val[i]);
+			cfg->val[i] = uc->value.enumerated.item[i];
+		} else {
+			change |= (uc->value.integer.value[i] != cfg->val[i]);
+			cfg->val[i] = uc->value.integer.value[i];
+		}
+	}
+
+	if (change)
+		cfg->update(mod);
+
+	return change;
+}
+
+static int __rsnd_kctrl_new(struct rsnd_mod *mod,
+			    struct rsnd_dai *rdai,
+			    struct snd_soc_pcm_runtime *rtd,
+			    const unsigned char *name,
+			    struct rsnd_kctrl_cfg *cfg,
+			    void (*update)(struct rsnd_mod *mod))
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_kcontrol *kctrl;
+	struct snd_kcontrol_new knew = {
+		.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name		= name,
+		.info		= rsnd_kctrl_info,
+		.get		= rsnd_kctrl_get,
+		.put		= rsnd_kctrl_put,
+		.private_value	= (unsigned long)cfg,
+	};
+	int ret;
+
+	kctrl = snd_ctl_new1(&knew, mod);
+	if (!kctrl)
+		return -ENOMEM;
+
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0)
+		return ret;
+
+	cfg->update = update;
+
+	return 0;
+}
+
+int rsnd_kctrl_new_m(struct rsnd_mod *mod,
+		     struct rsnd_dai *rdai,
+		     struct snd_soc_pcm_runtime *rtd,
+		     const unsigned char *name,
+		     void (*update)(struct rsnd_mod *mod),
+		     struct rsnd_kctrl_cfg_m *_cfg,
+		     u32 max)
+{
+	_cfg->cfg.max	= max;
+	_cfg->cfg.size	= RSND_DVC_CHANNELS;
+	_cfg->cfg.val	= _cfg->val;
+	return __rsnd_kctrl_new(mod, rdai, rtd, name, &_cfg->cfg, update);
+}
+
+int rsnd_kctrl_new_s(struct rsnd_mod *mod,
+		     struct rsnd_dai *rdai,
+		     struct snd_soc_pcm_runtime *rtd,
+		     const unsigned char *name,
+		     void (*update)(struct rsnd_mod *mod),
+		     struct rsnd_kctrl_cfg_s *_cfg,
+		     u32 max)
+{
+	_cfg->cfg.max	= max;
+	_cfg->cfg.size	= 1;
+	_cfg->cfg.val	= &_cfg->val;
+	return __rsnd_kctrl_new(mod, rdai, rtd, name, &_cfg->cfg, update);
+}
+
+int rsnd_kctrl_new_e(struct rsnd_mod *mod,
+		     struct rsnd_dai *rdai,
+		     struct snd_soc_pcm_runtime *rtd,
+		     const unsigned char *name,
+		     struct rsnd_kctrl_cfg_s *_cfg,
+		     void (*update)(struct rsnd_mod *mod),
+		     const char * const *texts,
+		     u32 max)
+{
+	_cfg->cfg.max	= max;
+	_cfg->cfg.size	= 1;
+	_cfg->cfg.val	= &_cfg->val;
+	_cfg->cfg.texts	= texts;
+	return __rsnd_kctrl_new(mod, rdai, rtd, name, &_cfg->cfg, update);
+}
+
 /*
  *		snd_soc_platform
  */

commit 417f96420a5823485b90ad7ee9fddb67996bbd7f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 27 08:02:55 2014 +0000

    ASoC: rsnd: add callback status check method
    
    R-Car sound can use SSI/SRC/DVC modules, and these are controlled as
    rsnd_mod in rsnd driver. These rsnd_mod has each own function as
    callback. Basically these callback function has pair like probe/remove,
    start/stop, etc. And, these functions are called by order to each stage
    like below.
     1. src->probe
     2. ssi->probe
     3. dvc->probe
     4. src->start
     5. ssi->start
     6. dvc->start
     7. src->stop
     8. ssi->stop
     9. dvc->stop
    10. src->remove
    11. ssi->remove
    12. dvc->remove
    
    But, current rsnd driver doesn't care about its status which indicates
    which function is called.
    For example, if 5) returns error, 6) is not called. In such case,
    9) should not be called. This patch care about each modules status.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 0785f84b54db..fce61a05d771 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -416,9 +416,16 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
-	dev_dbg(dev, "%s[%d] %s\n",				\
-		rsnd_mod_name(mod), rsnd_mod_id(mod), #func);	\
-	(mod)->ops->func(mod, rdai);				\
+	u32 mask = 1 << __rsnd_mod_shift_##func;			\
+	u32 call = __rsnd_mod_call_##func << __rsnd_mod_shift_##func;	\
+	int ret = 0;							\
+	if ((mod->status & mask) == call) {				\
+		dev_dbg(dev, "%s[%d] %s\n",				\
+			rsnd_mod_name(mod), rsnd_mod_id(mod), #func);	\
+		ret = (mod)->ops->func(mod, rdai);			\
+		mod->status = (mod->status & ~mask) | (~call & mask);	\
+	}								\
+	ret;								\
 })
 
 #define rsnd_mod_call(mod, func, rdai...)	\

commit 97463e193654574e1533f71359d91d9d2fdb3571
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 27 08:02:43 2014 +0000

    ASoC: rsnd: add .fallback callback
    
    Current R-Car sound has PIO fallback support if it couldn't use DMA.
    This fallback is done in .remove callback, but, it should have
    .fallback callback. Otherwise, normal .remove callback will have
    strange behavior. This patch adds .fallback callback.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 110b99da7acd..0785f84b54db 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -368,7 +368,7 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 	/*
 	 * DMA failed. try to PIO mode
 	 * see
-	 *	rsnd_ssi_dma_remove()
+	 *	rsnd_ssi_fallback()
 	 *	rsnd_rdai_continuance_probe()
 	 */
 	return -EAGAIN;
@@ -1023,7 +1023,7 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 		 * SSI will be switch to PIO mode if it was DMA mode
 		 * see
 		 *	rsnd_dma_init()
-		 *	rsnd_ssi_dma_remove()
+		 *	rsnd_ssi_fallback()
 		 */
 		rsnd_dai_call(remove, io, rdai);
 
@@ -1033,6 +1033,11 @@ static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
 		rsnd_path_break(priv, io, src);
 		rsnd_path_break(priv, io, dvc);
 
+		/*
+		 * fallback
+		 */
+		rsnd_dai_call(fallback, io, rdai);
+
 		/*
 		 * retry to "probe".
 		 * DAI has SSI which is PIO mode only now.

commit d3a768233243b5892a9c74b85896b9e8c017b259
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Nov 9 20:00:58 2014 -0800

    ASoC: rsnd: fallback to PIO mode if DMA mode was failed
    
    Current Renesas R-Car sound driver probe will be failed
    if it try to use DMA mode and it couldn't use for some reasons.
    But PIO mode works even though in such case.
    This patch try to fallback to PIO mode if DMA mode probing was failed.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 5205618a1990..110b99da7acd 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -349,7 +349,7 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 						     dma_name);
 	if (!dma->chan) {
 		dev_err(dev, "can't get dma channel\n");
-		return -EIO;
+		goto rsnd_dma_channel_err;
 	}
 
 	ret = dmaengine_slave_config(dma->chan, &cfg);
@@ -363,8 +363,15 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 
 rsnd_dma_init_err:
 	rsnd_dma_quit(priv, dma);
+rsnd_dma_channel_err:
 
-	return ret;
+	/*
+	 * DMA failed. try to PIO mode
+	 * see
+	 *	rsnd_ssi_dma_remove()
+	 *	rsnd_rdai_continuance_probe()
+	 */
+	return -EAGAIN;
 }
 
 void  rsnd_dma_quit(struct rsnd_priv *priv,
@@ -456,6 +463,13 @@ static int rsnd_dai_connect(struct rsnd_mod *mod,
 	return 0;
 }
 
+static void rsnd_dai_disconnect(struct rsnd_mod *mod,
+				struct rsnd_dai_stream *io)
+{
+	mod->io = NULL;
+	io->mod[mod->type] = NULL;
+}
+
 int rsnd_dai_id(struct rsnd_priv *priv, struct rsnd_dai *rdai)
 {
 	int id = rdai - priv->rdai;
@@ -686,6 +700,20 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	ret;							\
 })
 
+#define rsnd_path_break(priv, io, type)				\
+{								\
+	struct rsnd_mod *mod;					\
+	int id = -1;						\
+								\
+	if (rsnd_is_enable_path(io, type)) {			\
+		id = rsnd_info_id(priv, io, type);		\
+		if (id >= 0) {					\
+			mod = rsnd_##type##_mod_get(priv, id);	\
+			rsnd_dai_disconnect(mod, io);		\
+		}						\
+	}							\
+}
+
 static int rsnd_path_init(struct rsnd_priv *priv,
 			  struct rsnd_dai *rdai,
 			  struct rsnd_dai_stream *io)
@@ -977,6 +1005,44 @@ static const struct snd_soc_component_driver rsnd_soc_component = {
 	.name		= "rsnd",
 };
 
+static int rsnd_rdai_continuance_probe(struct rsnd_priv *priv,
+				       struct rsnd_dai *rdai,
+				       int is_play)
+{
+	struct rsnd_dai_stream *io = is_play ? &rdai->playback : &rdai->capture;
+	int ret;
+
+	ret = rsnd_dai_call(probe, io, rdai);
+	if (ret == -EAGAIN) {
+		/*
+		 * Fallback to PIO mode
+		 */
+
+		/*
+		 * call "remove" for SSI/SRC/DVC
+		 * SSI will be switch to PIO mode if it was DMA mode
+		 * see
+		 *	rsnd_dma_init()
+		 *	rsnd_ssi_dma_remove()
+		 */
+		rsnd_dai_call(remove, io, rdai);
+
+		/*
+		 * remove SRC/DVC from DAI,
+		 */
+		rsnd_path_break(priv, io, src);
+		rsnd_path_break(priv, io, dvc);
+
+		/*
+		 * retry to "probe".
+		 * DAI has SSI which is PIO mode only now.
+		 */
+		ret = rsnd_dai_call(probe, io, rdai);
+	}
+
+	return ret;
+}
+
 /*
  *	rsnd probe
  */
@@ -1038,11 +1104,11 @@ static int rsnd_probe(struct platform_device *pdev)
 	}
 
 	for_each_rsnd_dai(rdai, priv, i) {
-		ret = rsnd_dai_call(probe, &rdai->playback, rdai);
+		ret = rsnd_rdai_continuance_probe(priv, rdai, 1);
 		if (ret)
 			goto exit_snd_probe;
 
-		ret = rsnd_dai_call(probe, &rdai->capture, rdai);
+		ret = rsnd_rdai_continuance_probe(priv, rdai, 0);
 		if (ret)
 			goto exit_snd_probe;
 	}

commit 30cc4faf703955cd5cd07da489bd817ae43e3fec
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Nov 9 20:00:30 2014 -0800

    ASoC: rsnd: tidyup debug message format and timing
    
    Current Renesas R-Car sound driver debug message
    is using random format
    (ex "ssi0: xxx" / "SSI0 xxx" / "ssi[0]: xxx")
    and confusable timing
    ("xxx probe failed" and "xxx probed" are shown in same time)
    This patch fixes these
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1922ec57d10a..5205618a1990 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -409,7 +409,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
-	dev_dbg(dev, "%s [%d] %s\n",				\
+	dev_dbg(dev, "%s[%d] %s\n",				\
 		rsnd_mod_name(mod), rsnd_mod_id(mod), #func);	\
 	(mod)->ops->func(mod, rdai);				\
 })

commit 706c66213e5e623e23f521b1acbd8171af7a3549
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 28 21:02:03 2014 -0700

    ASoC: rsnd: remove unsupported PAUSE flag
    
    R-Car sound doesn't support PAUSE.
    Remove SNDRV_PCM_INFO_PAUSE flags from snd_pcm_hardware info
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1922ec57d10a..70042197f9e2 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -886,8 +886,7 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 static struct snd_pcm_hardware rsnd_pcm_hardware = {
 	.info =		SNDRV_PCM_INFO_INTERLEAVED	|
 			SNDRV_PCM_INFO_MMAP		|
-			SNDRV_PCM_INFO_MMAP_VALID	|
-			SNDRV_PCM_INFO_PAUSE,
+			SNDRV_PCM_INFO_MMAP_VALID,
 	.buffer_bytes_max	= 64 * 1024,
 	.period_bytes_min	= 32,
 	.period_bytes_max	= 8192,

commit a493b6a637e9d8e828d7ed4be4bdf24dfd1f9250
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Aug 8 12:07:49 2014 +0200

    ASoC: rsnd: delete unneeded test before of_node_put
    
    Of_node_put supports NULL as its argument, so the initial test is not
    necessary.
    
    Suggested by Uwe Kleine-KÃ¶nig.
    
    The semantic patch that fixes this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression e;
    @@
    
    -if (e)
       of_node_put(e);
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 19f78963e8b9..1922ec57d10a 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -798,10 +798,8 @@ if (name##_node) {							\
 			mod_parse(src);
 			mod_parse(dvc);
 
-			if (playback)
-				of_node_put(playback);
-			if (capture)
-				of_node_put(capture);
+			of_node_put(playback);
+			of_node_put(capture);
 		}
 
 		dai_i++;

commit 1a7889ca8aba333d7c74fad543d692c31bc7f280
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jul 31 18:08:18 2014 -0700

    ASoC: rsnd: fixup SND_SOC_DAIFMT_xB_xF behavior
    
    In current R-Car rsnd driver,
    the SND_SOC_DAIFMT_xB_xF flags are used to HW default behavior,
    but, it should be used to specific format.
    The waveforms of LEFT_J/RIGHT_J format with
    SND_SOC_DAIFMT_NB_NF flag will be
    started from "falling edge" without this patch.
    But, it should be started from "rising edge".
    
    Reported-by: Jun Watanabe <jun.watanabe.ue@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index d7c669790dd4..19f78963e8b9 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -624,40 +624,41 @@ static int rsnd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 		return -EINVAL;
 	}
 
-	/* set clock inversion */
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_IF:
-		rdai->bit_clk_inv = 0;
-		rdai->frm_clk_inv = 1;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		rdai->bit_clk_inv = 1;
-		rdai->frm_clk_inv = 0;
-		break;
-	case SND_SOC_DAIFMT_IB_IF:
-		rdai->bit_clk_inv = 1;
-		rdai->frm_clk_inv = 1;
-		break;
-	case SND_SOC_DAIFMT_NB_NF:
-	default:
-		rdai->bit_clk_inv = 0;
-		rdai->frm_clk_inv = 0;
-		break;
-	}
-
 	/* set format */
 	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 	case SND_SOC_DAIFMT_I2S:
 		rdai->sys_delay = 0;
 		rdai->data_alignment = 0;
+		rdai->frm_clk_inv = 0;
 		break;
 	case SND_SOC_DAIFMT_LEFT_J:
 		rdai->sys_delay = 1;
 		rdai->data_alignment = 0;
+		rdai->frm_clk_inv = 1;
 		break;
 	case SND_SOC_DAIFMT_RIGHT_J:
 		rdai->sys_delay = 1;
 		rdai->data_alignment = 1;
+		rdai->frm_clk_inv = 1;
+		break;
+	}
+
+	/* set clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_IF:
+		rdai->bit_clk_inv =  rdai->bit_clk_inv;
+		rdai->frm_clk_inv = !rdai->frm_clk_inv;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		rdai->bit_clk_inv = !rdai->bit_clk_inv;
+		rdai->frm_clk_inv =  rdai->frm_clk_inv;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		rdai->bit_clk_inv = !rdai->bit_clk_inv;
+		rdai->frm_clk_inv = !rdai->frm_clk_inv;
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+	default:
 		break;
 	}
 

commit 7c63f3c02f5a998621758239abed43c5bd454b70
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 30 23:53:03 2014 -0700

    ASoC: rsnd: fixup pcm_new callback method
    
    bff58ea4f43d9b4a9fd6fb05fabc8f50f68131f5
    (ASoC: rsnd: add DVC support) added DVC support,
    and it added pcm_new callback feature for it.
    Then it called all DAI's pcm_new callback, and it was wrong.
    This patch fixup it and call correct callback.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f07742f1eb11..d7c669790dd4 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -944,19 +944,17 @@ static struct snd_pcm_ops rsnd_pcm_ops = {
 
 static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
-	struct rsnd_priv *priv = snd_soc_dai_get_drvdata(rtd->cpu_dai);
-	struct rsnd_dai *rdai;
-	int i, ret;
+	struct snd_soc_dai *dai = rtd->cpu_dai;
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	int ret;
 
-	for_each_rsnd_dai(rdai, priv, i) {
-		ret = rsnd_dai_call(pcm_new, &rdai->playback, rdai, rtd);
-		if (ret)
-			return ret;
+	ret = rsnd_dai_call(pcm_new, &rdai->playback, rdai, rtd);
+	if (ret)
+		return ret;
 
-		ret = rsnd_dai_call(pcm_new, &rdai->capture, rdai, rtd);
-		if (ret)
-			return ret;
-	}
+	ret = rsnd_dai_call(pcm_new, &rdai->capture, rdai, rtd);
+	if (ret)
+		return ret;
 
 	return snd_pcm_lib_preallocate_pages_for_all(
 		rtd->pcm,

commit d62a3dcd4d75b1713d12697afdbffaf9a9da8f43
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jul 24 01:51:31 2014 -0700

    ASoC: rsnd: fixup dai remove callback operation
    
    rsnd driver is using SSI/SRC/DVC which are
    using "mod" base operation.
    These "mod" are supporting "probe" and "remove" callbacks.
    
    Current rsnd_probe should call "remove" if "probe" was failed,
    since "probe" might be having DMAEngine handle.
    Some mod's "remove" callback might be called without calling
    "probe", but it is no problem. because "remove" do nothing
    in such case.
    
    So, all mod's "remove" should be called when error case
    of rsnd_probe() and rsnd_remove().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index c48d999a3fce..f07742f1eb11 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -1043,11 +1043,11 @@ static int rsnd_probe(struct platform_device *pdev)
 	for_each_rsnd_dai(rdai, priv, i) {
 		ret = rsnd_dai_call(probe, &rdai->playback, rdai);
 		if (ret)
-			return ret;
+			goto exit_snd_probe;
 
 		ret = rsnd_dai_call(probe, &rdai->capture, rdai);
 		if (ret)
-			return ret;
+			goto exit_snd_probe;
 	}
 
 	/*
@@ -1075,6 +1075,11 @@ static int rsnd_probe(struct platform_device *pdev)
 
 exit_snd_soc:
 	snd_soc_unregister_platform(dev);
+exit_snd_probe:
+	for_each_rsnd_dai(rdai, priv, i) {
+		rsnd_dai_call(remove, &rdai->playback, rdai);
+		rsnd_dai_call(remove, &rdai->capture, rdai);
+	}
 
 	return ret;
 }
@@ -1083,21 +1088,16 @@ static int rsnd_remove(struct platform_device *pdev)
 {
 	struct rsnd_priv *priv = dev_get_drvdata(&pdev->dev);
 	struct rsnd_dai *rdai;
-	int ret, i;
+	int ret = 0, i;
 
 	pm_runtime_disable(&pdev->dev);
 
 	for_each_rsnd_dai(rdai, priv, i) {
-		ret = rsnd_dai_call(remove, &rdai->playback, rdai);
-		if (ret)
-			return ret;
-
-		ret = rsnd_dai_call(remove, &rdai->capture, rdai);
-		if (ret)
-			return ret;
+		ret |= rsnd_dai_call(remove, &rdai->playback, rdai);
+		ret |= rsnd_dai_call(remove, &rdai->capture, rdai);
 	}
 
-	return 0;
+	return ret;
 }
 
 static struct platform_driver rsnd_driver = {

commit 2bf865ba30405056e7922b960a1687bb4d5a4999
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 16 23:18:44 2014 -0700

    ASoC: rsnd: add missing src/dst_addr_width for DMAEngine
    
    Renesas new DMAEngine driver requests src/dst_addr_width
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 907d4802fd5c..c48d999a3fce 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -338,6 +338,8 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
 	cfg.src_addr	= rsnd_gen_dma_addr(priv, mod_from, is_play, 1);
 	cfg.dst_addr	= rsnd_gen_dma_addr(priv, mod_to,   is_play, 0);
+	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
 	dev_dbg(dev, "dma : %s %pad -> %pad\n",
 		dma_name, &cfg.src_addr, &cfg.dst_addr);

commit 34cb6123f90d264d63bdcd3ee0df0d2cb4b36aab
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jun 22 17:59:28 2014 -0700

    ASoC: rsnd: add DT support to DVC
    
    Now, DVC can use DT
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 49d9b31b185c..907d4802fd5c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -286,7 +286,13 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 			mod[i] = src;
 			src = NULL;
 		} else {
-			mod[i] = dvc;
+			if ((!is_play) && (this == src))
+				this = dvc;
+
+			mod[i] = (is_play) ? src : dvc;
+			i++;
+			mod[i] = (is_play) ? dvc : src;
+			src = NULL;
 			dvc = NULL;
 		}
 
@@ -719,12 +725,13 @@ static void rsnd_of_parse_dai(struct platform_device *pdev,
 	struct device_node *dai_node,	*dai_np;
 	struct device_node *ssi_node,	*ssi_np;
 	struct device_node *src_node,	*src_np;
+	struct device_node *dvc_node,	*dvc_np;
 	struct device_node *playback, *capture;
 	struct rsnd_dai_platform_info *dai_info;
 	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
 	struct device *dev = &pdev->dev;
 	int nr, i;
-	int dai_i, ssi_i, src_i;
+	int dai_i, ssi_i, src_i, dvc_i;
 
 	if (!of_data)
 		return;
@@ -750,6 +757,7 @@ static void rsnd_of_parse_dai(struct platform_device *pdev,
 
 	ssi_node = of_get_child_by_name(dev->of_node, "rcar_sound,ssi");
 	src_node = of_get_child_by_name(dev->of_node, "rcar_sound,src");
+	dvc_node = of_get_child_by_name(dev->of_node, "rcar_sound,dvc");
 
 #define mod_parse(name)							\
 if (name##_node) {							\
@@ -785,6 +793,7 @@ if (name##_node) {							\
 
 			mod_parse(ssi);
 			mod_parse(src);
+			mod_parse(dvc);
 
 			if (playback)
 				of_node_put(playback);

commit 340371005d399b595f4044fc5e336f4a66ead101
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jun 22 17:59:02 2014 -0700

    ASoC: rsnd: DMA start address is properly used for each DMAC
    
    R-Car sound uses Audio DMAC and Audio DMAC peri peri.
    Audio DMAC peri peri transfers data inside circuit.
    
    DMA transfer needs source / destination address,
    and destination address can be set via dmaengine_slave_config().
    The source address can be set when starting DMAEngine.
    Because Audio DMAC peri peri always ignores its value,
    current driver always used same source address for
    Audio DMAC / Audio DMAC peri peri
    (Audio DMAC peri peri source / destination address
    is always fixed value)
    But, This is not good match for DT booting.
    This patch properly uses DMA start address
    for Audio DMAC / Audio DMAC peri peri.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 4435a31ecdad..49d9b31b185c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -200,6 +200,7 @@ void rsnd_dma_start(struct rsnd_dma *dma)
 	struct dma_async_tx_descriptor *desc;
 
 	desc = dmaengine_prep_dma_cyclic(dma->chan,
+					 (dma->addr) ? dma->addr :
 					 substream->runtime->dma_addr,
 					 snd_pcm_lib_buffer_bytes(substream),
 					 snd_pcm_lib_period_bytes(substream),
@@ -347,6 +348,7 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 	if (ret < 0)
 		goto rsnd_dma_init_err;
 
+	dma->addr = is_play ? cfg.src_addr : cfg.dst_addr;
 	dma->dir = is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
 
 	return 0;

commit 37523034851d6a4b1dc951e24bf2f11bc28fe58d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jun 22 17:58:26 2014 -0700

    ASoC: rsnd: DMA cleanup for flexible SSI/SRC selection
    
    Current R-Car sound SSI/SRC/DVC selection has feature limit.
    (It is assuming that SSI/SRC are using same index number)
    
    So that enabling SSI/SRC flexible selection,
    this patch modifies DMA settings.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 5149fe2dae9f..4435a31ecdad 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -239,8 +239,21 @@ static int _rsnd_dma_of_name(char *dma_name, struct rsnd_mod *mod)
 
 }
 
-static void rsnd_dma_of_name(struct rsnd_dma *dma,
-			     int is_play, char *dma_name)
+static void rsnd_dma_of_name(struct rsnd_mod *mod_from,
+			     struct rsnd_mod *mod_to,
+			     char *dma_name)
+{
+	int index = 0;
+
+	index = _rsnd_dma_of_name(dma_name + index, mod_from);
+	*(dma_name + index++) = '_';
+	index = _rsnd_dma_of_name(dma_name + index, mod_to);
+}
+
+static void rsnd_dma_of_path(struct rsnd_dma *dma,
+			     int is_play,
+			     struct rsnd_mod **mod_from,
+			     struct rsnd_mod **mod_to)
 {
 	struct rsnd_mod *this = rsnd_dma_to_mod(dma);
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(this);
@@ -248,7 +261,6 @@ static void rsnd_dma_of_name(struct rsnd_dma *dma,
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
 	struct rsnd_mod *mod[MOD_MAX];
-	struct rsnd_mod *src_mod, *dst_mod;
 	int i, index;
 
 
@@ -285,17 +297,12 @@ static void rsnd_dma_of_name(struct rsnd_dma *dma,
 	}
 
 	if (is_play) {
-		src_mod = mod[index - 1];
-		dst_mod = mod[index];
+		*mod_from = mod[index - 1];
+		*mod_to   = mod[index];
 	} else {
-		src_mod = mod[index];
-		dst_mod = mod[index - 1];
+		*mod_from = mod[index];
+		*mod_to   = mod[index - 1];
 	}
-
-	index = 0;
-	index = _rsnd_dma_of_name(dma_name + index, src_mod);
-	*(dma_name + index++) = '_';
-	index = _rsnd_dma_of_name(dma_name + index, dst_mod);
 }
 
 int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
@@ -303,6 +310,8 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_slave_config cfg;
+	struct rsnd_mod *mod_from;
+	struct rsnd_mod *mod_to;
 	char dma_name[DMA_NAME_SIZE];
 	dma_cap_mask_t mask;
 	int ret;
@@ -315,10 +324,16 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
 
-	rsnd_dma_of_name(dma, is_play, dma_name);
-	rsnd_gen_dma_addr(priv, dma, &cfg, is_play, id);
+	rsnd_dma_of_path(dma, is_play, &mod_from, &mod_to);
+	rsnd_dma_of_name(mod_from, mod_to, dma_name);
+
+	cfg.slave_id	= id;
+	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
+	cfg.src_addr	= rsnd_gen_dma_addr(priv, mod_from, is_play, 1);
+	cfg.dst_addr	= rsnd_gen_dma_addr(priv, mod_to,   is_play, 0);
 
-	dev_dbg(dev, "dma name : %s\n", dma_name);
+	dev_dbg(dev, "dma : %s %pad -> %pad\n",
+		dma_name, &cfg.src_addr, &cfg.dst_addr);
 
 	dma->chan = dma_request_slave_channel_compat(mask, shdma_chan_filter,
 						     (void *)id, dev,

commit ccd01559ead29b59918458e9b412ff18b88fc6cf
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jun 22 17:56:41 2014 -0700

    ASoC: rsnd: use dmaengine_prep_dma_cyclic() instead of original method
    
    Current R-Car sound driver is using DMAEngine directly,
    but, ASoC is requesting to use common DMA transfer method,
    like snd_dmaengine_pcm_trigger() or dmaengine_pcm_ops.
    It is difficult to switch at this point, since Renesas
    driver is also supporting PIO transfer.
    This patch uses dmaengine_prep_dma_cyclic() instead
    of dmaengine_prep_slave_single().
    It is used in requested method,
    and is good first step to switch over.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8c3707a68603..5149fe2dae9f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -164,26 +164,8 @@ void rsnd_mod_init(struct rsnd_priv *priv,
 /*
  *	rsnd_dma functions
  */
-static void __rsnd_dma_start(struct rsnd_dma *dma);
-static void rsnd_dma_continue(struct rsnd_dma *dma)
-{
-	/* push next A or B plane */
-	dma->submit_loop = 1;
-	schedule_work(&dma->work);
-}
-
-void rsnd_dma_start(struct rsnd_dma *dma)
-{
-	/* push both A and B plane*/
-	dma->offset = 0;
-	dma->submit_loop = 2;
-	__rsnd_dma_start(dma);
-}
-
 void rsnd_dma_stop(struct rsnd_dma *dma)
 {
-	dma->submit_loop = 0;
-	cancel_work_sync(&dma->work);
 	dmaengine_terminate_all(dma->chan);
 }
 
@@ -191,11 +173,7 @@ static void rsnd_dma_complete(void *data)
 {
 	struct rsnd_dma *dma = (struct rsnd_dma *)data;
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
-	struct rsnd_priv *priv = rsnd_mod_to_priv(rsnd_dma_to_mod(dma));
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
-	unsigned long flags;
-
-	rsnd_lock(priv, flags);
 
 	/*
 	 * Renesas sound Gen1 needs 1 DMAC,
@@ -208,57 +186,40 @@ static void rsnd_dma_complete(void *data)
 	 * rsnd_dai_pointer_update() will be called twice,
 	 * ant it will breaks io->byte_pos
 	 */
-	if (dma->submit_loop)
-		rsnd_dma_continue(dma);
-
-	rsnd_unlock(priv, flags);
 
 	rsnd_dai_pointer_update(io, io->byte_per_period);
 }
 
-static void __rsnd_dma_start(struct rsnd_dma *dma)
+void rsnd_dma_start(struct rsnd_dma *dma)
 {
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
-	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	struct snd_pcm_substream *substream = io->substream;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
-	dma_addr_t buf;
-	size_t len = io->byte_per_period;
-	int i;
-
-	for (i = 0; i < dma->submit_loop; i++) {
 
-		buf = runtime->dma_addr +
-			rsnd_dai_pointer_offset(io, dma->offset + len);
-		dma->offset = len;
+	desc = dmaengine_prep_dma_cyclic(dma->chan,
+					 substream->runtime->dma_addr,
+					 snd_pcm_lib_buffer_bytes(substream),
+					 snd_pcm_lib_period_bytes(substream),
+					 dma->dir,
+					 DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 
-		desc = dmaengine_prep_slave_single(
-			dma->chan, buf, len, dma->dir,
-			DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
-		if (!desc) {
-			dev_err(dev, "dmaengine_prep_slave_sg() fail\n");
-			return;
-		}
-
-		desc->callback		= rsnd_dma_complete;
-		desc->callback_param	= dma;
+	if (!desc) {
+		dev_err(dev, "dmaengine_prep_slave_sg() fail\n");
+		return;
+	}
 
-		if (dmaengine_submit(desc) < 0) {
-			dev_err(dev, "dmaengine_submit() fail\n");
-			return;
-		}
+	desc->callback		= rsnd_dma_complete;
+	desc->callback_param	= dma;
 
-		dma_async_issue_pending(dma->chan);
+	if (dmaengine_submit(desc) < 0) {
+		dev_err(dev, "dmaengine_submit() fail\n");
+		return;
 	}
-}
-
-static void rsnd_dma_do_work(struct work_struct *work)
-{
-	struct rsnd_dma *dma = container_of(work, struct rsnd_dma, work);
 
-	__rsnd_dma_start(dma);
+	dma_async_issue_pending(dma->chan);
 }
 
 int rsnd_dma_available(struct rsnd_dma *dma)
@@ -372,7 +333,6 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 		goto rsnd_dma_init_err;
 
 	dma->dir = is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
-	INIT_WORK(&dma->work, rsnd_dma_do_work);
 
 	return 0;
 

commit d9288d0ba12de1b5efb830b9128e4cc6877318fc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jun 22 17:56:23 2014 -0700

    ASoC: rsnd: SSI + DMA can select BUSIF
    
    Sound data needs to be sent to R-Car sound SSI when playback.
    But, there are 2 interfaces for it.
    1st is SSITDR/SSIRDR which are mapped on SSI.
    2nd is SSIn_BUSIF which are mapped on SSIU.
    
    2nd SSIn_BUSIF is used when DMA transfer,
    and it is always used if sound data came from via SRC.
    But, we can use it when SSI+DMA case too.
    (Current driver is assuming 1st SSITDR/SSIRDR for it)
    
    2nd SSIn_BUSIF can be used as FIFO.
    This is very helpful/useful for SSI+DMA.
    
    But DMA address / DMA ID are not same between 1st/2nd cases.
    This patch care about these settings.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7f68b33dcbbb..8c3707a68603 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -138,6 +138,17 @@ char *rsnd_mod_name(struct rsnd_mod *mod)
 	return mod->ops->name;
 }
 
+char *rsnd_mod_dma_name(struct rsnd_mod *mod)
+{
+	if (!mod || !mod->ops)
+		return "unknown";
+
+	if (!mod->ops->dma_name)
+		return mod->ops->name;
+
+	return mod->ops->dma_name(mod);
+}
+
 void rsnd_mod_init(struct rsnd_priv *priv,
 		   struct rsnd_mod *mod,
 		   struct rsnd_mod_ops *ops,
@@ -261,7 +272,7 @@ static int _rsnd_dma_of_name(char *dma_name, struct rsnd_mod *mod)
 {
 	if (mod)
 		return snprintf(dma_name, DMA_NAME_SIZE / 2, "%s%d",
-			 rsnd_mod_name(mod), rsnd_mod_id(mod));
+			 rsnd_mod_dma_name(mod), rsnd_mod_id(mod));
 	else
 		return snprintf(dma_name, DMA_NAME_SIZE / 2, "mem");
 
@@ -343,11 +354,8 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
 
-	if (dev->of_node)
-		rsnd_dma_of_name(dma, is_play, dma_name);
-	else
-		snprintf(dma_name, DMA_NAME_SIZE,
-			 is_play ? "tx" : "rx");
+	rsnd_dma_of_name(dma, is_play, dma_name);
+	rsnd_gen_dma_addr(priv, dma, &cfg, is_play, id);
 
 	dev_dbg(dev, "dma name : %s\n", dma_name);
 
@@ -359,8 +367,6 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 		return -EIO;
 	}
 
-	rsnd_gen_dma_addr(priv, dma, &cfg, is_play, id);
-
 	ret = dmaengine_slave_config(dma->chan, &cfg);
 	if (ret < 0)
 		goto rsnd_dma_init_err;

commit 6f2a06cd42336c75c74181730a7c31c78e2be6fb
Merge: cd7bcc600016 c08c3b088053
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Jun 28 14:41:15 2014 +0100

    Merge remote-tracking branch 'asoc/fix/rcar' into asoc-rcar

commit cd7bcc6000165f6215d15e2e32b58a646e5de5ec
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Jun 19 09:40:30 2014 +0200

    ASoC: rcar: Fix dma direction type
    
    dmaengine_prep_slave_single() expects a enum dma_transfer_direction and not a
    enum dma_data_direction. Since the integer representations of both DMA_TO_DEVICE
    and DMA_MEM_TO_DEV aswell as DMA_FROM_DEVICE and DMA_DEV_TO_MEM have the same
    value the code worked fine even though it was using the wrong type.
    
    Fixes the following warning from sparse:
            sound/soc/sh/rcar/core.c:227:49: warning: mixing different enum types
            sound/soc/sh/rcar/core.c:227:49:     int enum dma_data_direction  versus
            sound/soc/sh/rcar/core.c:227:49:     int enum dma_transfer_direction
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 91880156e1ae..7bdda8fbde87 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -363,7 +363,7 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 	if (ret < 0)
 		goto rsnd_dma_init_err;
 
-	dma->dir = is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+	dma->dir = is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
 	INIT_WORK(&dma->work, rsnd_dma_do_work);
 
 	return 0;

commit c08c3b088053cec1465051258844e7934d3e3e37
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 18 17:55:09 2014 +0900

    ASoC: rsnd: fixup loop exit timing of dma name search
    
    Current dma name search loop didn't care about SSI index
    This patch fixes it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 4e86265f625c..ed76901f8202 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -297,7 +297,6 @@ static void rsnd_dma_of_name(struct rsnd_dma *dma,
 	for (i = 1; i < MOD_MAX; i++) {
 		if (!src) {
 			mod[i] = ssi;
-			break;
 		} else if (!dvc) {
 			mod[i] = src;
 			src = NULL;
@@ -308,6 +307,9 @@ static void rsnd_dma_of_name(struct rsnd_dma *dma,
 
 		if (mod[i] == this)
 			index = i;
+
+		if (mod[i] == ssi)
+			break;
 	}
 
 	if (is_play) {

commit 4cf612780cec81317a0278b28679a8b69ea8f09c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jun 10 23:41:03 2014 -0700

    ASoC: rsnd: fixup index of src/dst mod when capture
    
    Index of dma name should use -1, not +1 when capture case.
    Thank you Dan.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 91880156e1ae..4e86265f625c 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -315,7 +315,7 @@ static void rsnd_dma_of_name(struct rsnd_dma *dma,
 		dst_mod = mod[index];
 	} else {
 		src_mod = mod[index];
-		dst_mod = mod[index + 1];
+		dst_mod = mod[index - 1];
 	}
 
 	index = 0;

commit 440a5285589d4abc7f7c44f063a3554557820ab6
Merge: b12a1906be48 87c1936426d1 ad32d0c7b0e9
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Jun 3 10:39:53 2014 +0100

    Merge remote-tracking branches 'asoc/topic/omap' and 'asoc/topic/rcar' into asoc-next

commit ad32d0c7b0e993433df152ae747652647eb65a27
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 22 23:25:54 2014 -0700

    ASoC: rsnd: add rsnd_gen_dma_addr() for DMAC addr
    
    The DMAC src/dst addr needs to be set from driver when DT case.
    (It was set from SoC/DMAEngine code when non-DT case)
    This patch adds rsnd_gen_dma_addr() to set DMAC src/dst addr.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index cddb76d7d965..ebb5d46029a5 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -358,10 +358,7 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 		return -EIO;
 	}
 
-	cfg.slave_id	= id;
-	cfg.dst_addr	= 0; /* use default addr when playback */
-	cfg.src_addr	= 0; /* use default addr when capture */
-	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
+	rsnd_gen_dma_addr(priv, dma, &cfg, is_play, id);
 
 	ret = dmaengine_slave_config(dma->chan, &cfg);
 	if (ret < 0)

commit 199e7688bdf7d188d70c3432c96ec13d8a14b341
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 22 23:25:49 2014 -0700

    ASoC: rsnd: care DMA slave channel name for DT
    
    Renesas sound driver is supporting to use DMAEngine.
    But, DMA slave channel name "tx", "rx" is not enough
    in DT case.
    Becuase, it has many ports and path combination.
    
    This patch adds rsnd_dma_of_name() to find
    DMA channel name, for example
    memory to SSI0 is "mem_ssi0",
    SSI0 to memory is "ssi0_mem",
    SSI0 to SRC0   is "ssi0_src0",
    SRC0 to SSI0   is "src0_ssi0",
    SRC0 to DVC0   is "src0_dvc0"...
    
    Renesas sound want to use PIO transfer mode for some reasons.
    It will be PIO tranfer mode if device node doesn't have
    DMA settings.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 073a29354c85..cddb76d7d965 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -256,11 +256,81 @@ int rsnd_dma_available(struct rsnd_dma *dma)
 	return !!dma->chan;
 }
 
+#define DMA_NAME_SIZE 16
+#define MOD_MAX 4 /* MEM/SSI/SRC/DVC */
+static int _rsnd_dma_of_name(char *dma_name, struct rsnd_mod *mod)
+{
+	if (mod)
+		return snprintf(dma_name, DMA_NAME_SIZE / 2, "%s%d",
+			 rsnd_mod_name(mod), rsnd_mod_id(mod));
+	else
+		return snprintf(dma_name, DMA_NAME_SIZE / 2, "mem");
+
+}
+
+static void rsnd_dma_of_name(struct rsnd_dma *dma,
+			     int is_play, char *dma_name)
+{
+	struct rsnd_mod *this = rsnd_dma_to_mod(dma);
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(this);
+	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
+	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
+	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
+	struct rsnd_mod *mod[MOD_MAX];
+	struct rsnd_mod *src_mod, *dst_mod;
+	int i, index;
+
+
+	for (i = 0; i < MOD_MAX; i++)
+		mod[i] = NULL;
+
+	/*
+	 * in play case...
+	 *
+	 * src -> dst
+	 *
+	 * mem -> SSI
+	 * mem -> SRC -> SSI
+	 * mem -> SRC -> DVC -> SSI
+	 */
+	mod[0] = NULL; /* for "mem" */
+	index = 1;
+	for (i = 1; i < MOD_MAX; i++) {
+		if (!src) {
+			mod[i] = ssi;
+			break;
+		} else if (!dvc) {
+			mod[i] = src;
+			src = NULL;
+		} else {
+			mod[i] = dvc;
+			dvc = NULL;
+		}
+
+		if (mod[i] == this)
+			index = i;
+	}
+
+	if (is_play) {
+		src_mod = mod[index - 1];
+		dst_mod = mod[index];
+	} else {
+		src_mod = mod[index];
+		dst_mod = mod[index + 1];
+	}
+
+	index = 0;
+	index = _rsnd_dma_of_name(dma_name + index, src_mod);
+	*(dma_name + index++) = '_';
+	index = _rsnd_dma_of_name(dma_name + index, dst_mod);
+}
+
 int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 		  int is_play, int id)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_slave_config cfg;
+	char dma_name[DMA_NAME_SIZE];
 	dma_cap_mask_t mask;
 	int ret;
 
@@ -272,9 +342,17 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
 
+	if (dev->of_node)
+		rsnd_dma_of_name(dma, is_play, dma_name);
+	else
+		snprintf(dma_name, DMA_NAME_SIZE,
+			 is_play ? "tx" : "rx");
+
+	dev_dbg(dev, "dma name : %s\n", dma_name);
+
 	dma->chan = dma_request_slave_channel_compat(mask, shdma_chan_filter,
 						     (void *)id, dev,
-						     is_play ? "tx" : "rx");
+						     dma_name);
 	if (!dma->chan) {
 		dev_err(dev, "can't get dma channel\n");
 		return -EIO;

commit 9f464f8e076e6fcc8d249e76d84f4fb99c1fecff
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 22 23:25:30 2014 -0700

    ASoC: rsnd: save platform_device instead of device
    
    DT DMA support needs struct platform_device pointer,
    and it can get struct device pointer from platform_device.
    Save platform_device instead of device.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 1f6981a56354..073a29354c85 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -957,7 +957,7 @@ static int rsnd_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	priv->dev	= dev;
+	priv->pdev	= pdev;
 	priv->info	= info;
 	spin_lock_init(&priv->lock);
 

commit 6f821c644966e6ccbe9a98e081621b7e1a58dc64
Merge: 6630f30ed5e4 49e3c6418ba4 0596f70069bb b45281412a63 e6b0d896ab05 57f174f47e73 8c32570441f9
Author: Mark Brown <broonie@linaro.org>
Date:   Thu May 22 00:23:57 2014 +0100

    Merge remote-tracking branches 'asoc/topic/nuc900', 'asoc/topic/omap', 'asoc/topic/pxa', 'asoc/topic/rcar', 'asoc/topic/rt5640' and 'asoc/topic/rt5645' into asoc-next

commit bff58ea4f43d9b4a9fd6fb05fabc8f50f68131f5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 8 17:44:49 2014 -0700

    ASoC: rsnd: add DVC support
    
    This patch adds DVC (Digital Volume Controller)
    support which is member of CMD unit.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 378985b028ef..1f6981a56354 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -645,6 +645,11 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	if (ret < 0)
 		return ret;
 
+	/* DVC */
+	ret = rsnd_path_parse(priv, io, dvc);
+	if (ret < 0)
+		return ret;
+
 	return ret;
 }
 
@@ -869,6 +874,20 @@ static struct snd_pcm_ops rsnd_pcm_ops = {
 
 static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
+	struct rsnd_priv *priv = snd_soc_dai_get_drvdata(rtd->cpu_dai);
+	struct rsnd_dai *rdai;
+	int i, ret;
+
+	for_each_rsnd_dai(rdai, priv, i) {
+		ret = rsnd_dai_call(pcm_new, &rdai->playback, rdai, rtd);
+		if (ret)
+			return ret;
+
+		ret = rsnd_dai_call(pcm_new, &rdai->capture, rdai, rtd);
+		if (ret)
+			return ret;
+	}
+
 	return snd_pcm_lib_preallocate_pages_for_all(
 		rtd->pcm,
 		SNDRV_DMA_TYPE_DEV,
@@ -908,6 +927,7 @@ static int rsnd_probe(struct platform_device *pdev)
 		rsnd_gen_probe,
 		rsnd_ssi_probe,
 		rsnd_src_probe,
+		rsnd_dvc_probe,
 		rsnd_adg_probe,
 		rsnd_dai_probe,
 	};

commit 68b6af3656a1f3303cca094a19e26653fad1853a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 8 17:44:41 2014 -0700

    ASoC: rsnd: enable to use multi parameter on rsnd_dai_call/rsnd_mod_call
    
    rsnd_mod_ops would like to come to use multi parameter.
    modify macro to enable it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 86c9b78d8df1..378985b028ef 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -338,7 +338,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 /*
  *	rsnd_dai functions
  */
-#define __rsnd_mod_call(mod, func, rdai)			\
+#define __rsnd_mod_call(mod, func, rdai...)			\
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
@@ -347,12 +347,12 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 	(mod)->ops->func(mod, rdai);				\
 })
 
-#define rsnd_mod_call(mod, func, rdai)	\
+#define rsnd_mod_call(mod, func, rdai...)	\
 	(!(mod) ? -ENODEV :			\
 	 !((mod)->ops->func) ? 0 :		\
-	 __rsnd_mod_call(mod, func, (rdai)))
+	 __rsnd_mod_call(mod, func, rdai))
 
-#define rsnd_dai_call(rdai, io, fn)				\
+#define rsnd_dai_call(fn, io, rdai...)				\
 ({								\
 	struct rsnd_mod *mod;					\
 	int ret = 0, i;						\
@@ -360,7 +360,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 		mod = (io)->mod[i];				\
 		if (!mod)					\
 			continue;				\
-		ret = rsnd_mod_call(mod, fn, (rdai));		\
+		ret = rsnd_mod_call(mod, fn, rdai);		\
 		if (ret < 0)					\
 			break;					\
 	}							\
@@ -510,20 +510,20 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (ret < 0)
 			goto dai_trigger_end;
 
-		ret = rsnd_dai_call(rdai, io, init);
+		ret = rsnd_dai_call(init, io, rdai);
 		if (ret < 0)
 			goto dai_trigger_end;
 
-		ret = rsnd_dai_call(rdai, io, start);
+		ret = rsnd_dai_call(start, io, rdai);
 		if (ret < 0)
 			goto dai_trigger_end;
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-		ret = rsnd_dai_call(rdai, io, stop);
+		ret = rsnd_dai_call(stop, io, rdai);
 		if (ret < 0)
 			goto dai_trigger_end;
 
-		ret = rsnd_dai_call(rdai, io, quit);
+		ret = rsnd_dai_call(quit, io, rdai);
 		if (ret < 0)
 			goto dai_trigger_end;
 
@@ -951,11 +951,11 @@ static int rsnd_probe(struct platform_device *pdev)
 	}
 
 	for_each_rsnd_dai(rdai, priv, i) {
-		ret = rsnd_dai_call(rdai, &rdai->playback, probe);
+		ret = rsnd_dai_call(probe, &rdai->playback, rdai);
 		if (ret)
 			return ret;
 
-		ret = rsnd_dai_call(rdai, &rdai->capture, probe);
+		ret = rsnd_dai_call(probe, &rdai->capture, rdai);
 		if (ret)
 			return ret;
 	}
@@ -998,11 +998,11 @@ static int rsnd_remove(struct platform_device *pdev)
 	pm_runtime_disable(&pdev->dev);
 
 	for_each_rsnd_dai(rdai, priv, i) {
-		ret = rsnd_dai_call(rdai, &rdai->playback, remove);
+		ret = rsnd_dai_call(remove, &rdai->playback, rdai);
 		if (ret)
 			return ret;
 
-		ret = rsnd_dai_call(rdai, &rdai->capture, remove);
+		ret = rsnd_dai_call(remove, &rdai->capture, rdai);
 		if (ret)
 			return ret;
 	}

commit b42fccf69cd7153d1158c85137ec718d7309e074
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 8 17:44:29 2014 -0700

    ASoC: rsnd: remove duplicate parameter from rsnd_mod_ops
    
    Now, it can get rsnd_dai_stream pointer from rsnd_mod.
    Remove duplicate parameter from rsnd_mod_ops
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index e47aa53471b1..86c9b78d8df1 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -338,19 +338,19 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 /*
  *	rsnd_dai functions
  */
-#define __rsnd_mod_call(mod, func, rdai, io)			\
+#define __rsnd_mod_call(mod, func, rdai)			\
 ({								\
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
 	struct device *dev = rsnd_priv_to_dev(priv);		\
 	dev_dbg(dev, "%s [%d] %s\n",				\
 		rsnd_mod_name(mod), rsnd_mod_id(mod), #func);	\
-	(mod)->ops->func(mod, rdai, io);			\
+	(mod)->ops->func(mod, rdai);				\
 })
 
-#define rsnd_mod_call(mod, func, rdai, io)	\
+#define rsnd_mod_call(mod, func, rdai)	\
 	(!(mod) ? -ENODEV :			\
 	 !((mod)->ops->func) ? 0 :		\
-	 __rsnd_mod_call(mod, func, (rdai), (io)))
+	 __rsnd_mod_call(mod, func, (rdai)))
 
 #define rsnd_dai_call(rdai, io, fn)				\
 ({								\
@@ -360,7 +360,7 @@ u32 rsnd_get_adinr(struct rsnd_mod *mod)
 		mod = (io)->mod[i];				\
 		if (!mod)					\
 			continue;				\
-		ret = rsnd_mod_call(mod, fn, (rdai), (io));	\
+		ret = rsnd_mod_call(mod, fn, (rdai));		\
 		if (ret < 0)					\
 			break;					\
 	}							\

commit d7bdbc5d9e4e813522f46632527826211270b9d0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 8 17:44:14 2014 -0700

    ASoC: rsnd: add rsnd_get_adinr()
    
    SRC module needs ADINR register settings,
    but, it has many similar xxx_ADINR register,
    and needs same settings.
    This patch adds rsnd_get_adinr() to sharing code.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f74d02cb70f1..e47aa53471b1 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -309,6 +309,32 @@ void  rsnd_dma_quit(struct rsnd_priv *priv,
 	dma->chan = NULL;
 }
 
+/*
+ *	settting function
+ */
+u32 rsnd_get_adinr(struct rsnd_mod *mod)
+{
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	struct device *dev = rsnd_priv_to_dev(priv);
+	u32 adinr = runtime->channels;
+
+	switch (runtime->sample_bits) {
+	case 16:
+		adinr |= (8 << 16);
+		break;
+	case 32:
+		adinr |= (0 << 16);
+		break;
+	default:
+		dev_warn(dev, "not supported sample bits\n");
+		return 0;
+	}
+
+	return adinr;
+}
+
 /*
  *	rsnd_dai functions
  */

commit 739f9502fdd7c7202123ded842415a0392b7dc40
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 8 17:43:26 2014 -0700

    ASoC: rsnd: add rsnd_path_parse() macro
    
    Current R-Car sound supports only SRC/SSI,
    but, other module will be supported.
    This patch adds rsnd_path_parse() macro to share code
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 8ed84703b280..f74d02cb70f1 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -576,14 +576,27 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.set_fmt	= rsnd_soc_dai_set_fmt,
 };
 
+#define rsnd_path_parse(priv, io, type)				\
+({								\
+	struct rsnd_mod *mod;					\
+	int ret = 0;						\
+	int id = -1;						\
+								\
+	if (rsnd_is_enable_path(io, type)) {			\
+		id = rsnd_info_id(priv, io, type);		\
+		if (id >= 0) {					\
+			mod = rsnd_##type##_mod_get(priv, id);	\
+			ret = rsnd_dai_connect(mod, io);	\
+		}						\
+	}							\
+	ret;							\
+})
+
 static int rsnd_path_init(struct rsnd_priv *priv,
 			  struct rsnd_dai *rdai,
 			  struct rsnd_dai_stream *io)
 {
-	struct rsnd_mod *mod;
 	int ret;
-	int ssi_id = -1;
-	int src_id = -1;
 
 	/*
 	 * Gen1 is created by SRU/SSI, and this SRU is base module of
@@ -595,28 +608,16 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	 * Gen2 SCU path is very flexible, but, Gen1 SRU (SCU parts) is
 	 * using fixed path.
 	 */
-	if (rsnd_is_enable_path(io, ssi))
-		ssi_id = rsnd_info_id(priv, io, ssi);
-	if (rsnd_is_enable_path(io, src))
-		src_id = rsnd_info_id(priv, io, src);
-
-	ret = 0;
 
 	/* SRC */
-	if (src_id >= 0) {
-		mod = rsnd_src_mod_get(priv, src_id);
-		ret = rsnd_dai_connect(mod, io);
-		if (ret < 0)
-			return ret;
-	}
+	ret = rsnd_path_parse(priv, io, src);
+	if (ret < 0)
+		return ret;
 
 	/* SSI */
-	if (ssi_id >= 0) {
-		mod = rsnd_ssi_mod_get(priv, ssi_id);
-		ret = rsnd_dai_connect(mod, io);
-		if (ret < 0)
-			return ret;
-	}
+	ret = rsnd_path_parse(priv, io, ssi);
+	if (ret < 0)
+		return ret;
 
 	return ret;
 }

commit 29e69fd2cd6f55233f64f600ad55ce2b661784d1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 8 01:59:26 2014 -0700

    ASoC: rsnd: remove compatibility code
    
    Now, all platform is using new style rsnd_dai_platform_info.
    Keeping compatibility is no longer needed.
    We can cleanup code.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 215b668166be..8ed84703b280 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -468,10 +468,7 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	struct rsnd_priv *priv = snd_soc_dai_get_drvdata(dai);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
-	struct rsnd_mod *mod = rsnd_ssi_mod_get_frm_dai(priv,
-						rsnd_dai_id(priv, rdai),
-						rsnd_dai_is_play(rdai, io));
-	int ssi_id = rsnd_mod_id(mod);
+	int ssi_id = rsnd_mod_id(rsnd_io_to_mod_ssi(io));
 	int ret;
 	unsigned long flags;
 
@@ -584,7 +581,6 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 			  struct rsnd_dai_stream *io)
 {
 	struct rsnd_mod *mod;
-	struct rsnd_dai_platform_info *dai_info = rdai->info;
 	int ret;
 	int ssi_id = -1;
 	int src_id = -1;
@@ -599,20 +595,10 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	 * Gen2 SCU path is very flexible, but, Gen1 SRU (SCU parts) is
 	 * using fixed path.
 	 */
-	if (dai_info) {
-		if (rsnd_is_enable_path(io, ssi))
-			ssi_id = rsnd_info_id(priv, io, ssi);
-		if (rsnd_is_enable_path(io, src))
-			src_id = rsnd_info_id(priv, io, src);
-	} else {
-		/* get SSI's ID */
-		mod = rsnd_ssi_mod_get_frm_dai(priv,
-					       rsnd_dai_id(priv, rdai),
-					       rsnd_dai_is_play(rdai, io));
-		if (!mod)
-			return 0;
-		ssi_id = src_id = rsnd_mod_id(mod);
-	}
+	if (rsnd_is_enable_path(io, ssi))
+		ssi_id = rsnd_info_id(priv, io, ssi);
+	if (rsnd_is_enable_path(io, src))
+		src_id = rsnd_info_id(priv, io, src);
 
 	ret = 0;
 
@@ -726,29 +712,14 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 	struct snd_soc_dai_driver *drv;
 	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
 	struct rsnd_dai *rdai;
-	struct rsnd_mod *pmod, *cmod;
+	struct rsnd_ssi_platform_info *pmod, *cmod;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	int dai_nr;
 	int i;
 
 	rsnd_of_parse_dai(pdev, of_data, priv);
 
-	/*
-	 * dai_nr should be set via dai_info_nr,
-	 * but allow it to keeping compatible
-	 */
 	dai_nr = info->dai_info_nr;
-	if (!dai_nr) {
-		/* get max dai nr */
-		for (dai_nr = 0; dai_nr < 32; dai_nr++) {
-			pmod = rsnd_ssi_mod_get_frm_dai(priv, dai_nr, 1);
-			cmod = rsnd_ssi_mod_get_frm_dai(priv, dai_nr, 0);
-
-			if (!pmod && !cmod)
-				break;
-		}
-	}
-
 	if (!dai_nr) {
 		dev_err(dev, "no dai\n");
 		return -EIO;
@@ -766,11 +737,10 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 	priv->rdai	= rdai;
 
 	for (i = 0; i < dai_nr; i++) {
-		if (info->dai_info)
-			rdai[i].info = &info->dai_info[i];
+		rdai[i].info = &info->dai_info[i];
 
-		pmod = rsnd_ssi_mod_get_frm_dai(priv, i, 1);
-		cmod = rsnd_ssi_mod_get_frm_dai(priv, i, 0);
+		pmod = rdai[i].info->playback.ssi;
+		cmod = rdai[i].info->capture.ssi;
 
 		/*
 		 *	init rsnd_dai
@@ -788,8 +758,7 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 			drv[i].playback.channels_min	= 2;
 			drv[i].playback.channels_max	= 2;
 
-			if (info->dai_info)
-				rdai[i].playback.info = &info->dai_info[i].playback;
+			rdai[i].playback.info = &info->dai_info[i].playback;
 			rsnd_path_init(priv, &rdai[i], &rdai[i].playback);
 		}
 		if (cmod) {
@@ -798,8 +767,7 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 			drv[i].capture.channels_min	= 2;
 			drv[i].capture.channels_max	= 2;
 
-			if (info->dai_info)
-				rdai[i].capture.info = &info->dai_info[i].capture;
+			rdai[i].capture.info = &info->dai_info[i].capture;
 			rsnd_path_init(priv, &rdai[i], &rdai[i].capture);
 		}
 

commit 836b31fe1a9791d84ed95783ed42ebd5719f7918
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Apr 23 14:59:12 2014 +0900

    ASoC: rsnd: call rsnd_dai_pointer_update() from outside of lock
    
    rsnd_soc_dai_trigger() will be called
    after rsnd_dai_pointer_update() function
    which is using rsnd_lock().
    Thus, it should be called from outside of rsnd_lock().
    Kernel will be hangup without this patch.
    Special thanks to Kataoka-san
    
    Reported-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 215b668166be..89424470a1f3 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -197,13 +197,12 @@ static void rsnd_dma_complete(void *data)
 	 * rsnd_dai_pointer_update() will be called twice,
 	 * ant it will breaks io->byte_pos
 	 */
-
-	rsnd_dai_pointer_update(io, io->byte_per_period);
-
 	if (dma->submit_loop)
 		rsnd_dma_continue(dma);
 
 	rsnd_unlock(priv, flags);
+
+	rsnd_dai_pointer_update(io, io->byte_per_period);
 }
 
 static void __rsnd_dma_start(struct rsnd_dma *dma)

commit ca9e54c625911cb9c409687d96e78645cf55fa33
Merge: 980aac20877e 90e8e50fce35
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 23 14:00:58 2014 +0000

    Merge remote-tracking branch 'asoc/topic/rcar' into asoc-next

commit d66fa86956149a211db3d7ae9e9f2536b65ccde4
Merge: ebec909345bb deeed33850c8
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 23 14:00:41 2014 +0000

    Merge tag 'asoc-v3.15' into asoc-next
    
    ASoC: Updates for v3.15
    
    Quite a busy release for ASoC this time, more on janitorial work than
    exciting new features but welcome nontheless:
    
     - Lots of cleanups from Takashi for enumerations; the original API for
       these was error prone so he's refactored lots of code to use more
       modern APIs which avoid issues.
     - Elimination of the ASoC level wrappers for I2C and SPI moving us
       closer to converting to regmap completely and avoiding some
       randconfig hassle.
     - Provide both manually and transparently locked DAPM APIs rather than
       a mix of the two fixing some concurrency issues.
     - Start converting CODEC drivers to use separate bus interface drivers
       rather than having them all in one file helping avoid dependency
       issues.
     - DPCM support for Intel Haswell and Bay Trail platforms.
     - Lots of work on improvements for simple-card, DaVinci and the Renesas
       rcar drivers.
     - New drivers for Analog Devices ADAU1977, TI PCM512x and parts of the
       CSR SiRF SoC.
    
    # gpg: Signature made Wed 12 Mar 2014 23:05:45 GMT using RSA key ID 7EA229BD
    # gpg: Good signature from "Mark Brown <broonie@sirena.org.uk>"
    # gpg:                 aka "Mark Brown <broonie@debian.org>"
    # gpg:                 aka "Mark Brown <broonie@kernel.org>"
    # gpg:                 aka "Mark Brown <broonie@tardis.ed.ac.uk>"
    # gpg:                 aka "Mark Brown <broonie@linaro.org>"
    # gpg:                 aka "Mark Brown <Mark.Brown@linaro.org>"

commit 90e8e50fce3585d6f9902701de08389b027dadc6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 17 19:29:55 2014 -0700

    ASoC: rsnd: add DeviceTree support
    
    Support for loading the Renesas R-Car sound driver via DeviceTree.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 6a1b45df8101..e77f7716f1d7 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -100,6 +100,21 @@
 #define RSND_RATES SNDRV_PCM_RATE_8000_96000
 #define RSND_FMTS (SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE)
 
+static struct rsnd_of_data rsnd_of_data_gen1 = {
+	.flags = RSND_GEN1,
+};
+
+static struct rsnd_of_data rsnd_of_data_gen2 = {
+	.flags = RSND_GEN2,
+};
+
+static struct of_device_id rsnd_of_match[] = {
+	{ .compatible = "renesas,rcar_sound-gen1", .data = &rsnd_of_data_gen1 },
+	{ .compatible = "renesas,rcar_sound-gen2", .data = &rsnd_of_data_gen2 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rsnd_of_match);
+
 /*
  *	rsnd_platform functions
  */
@@ -620,7 +635,92 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	return ret;
 }
 
+static void rsnd_of_parse_dai(struct platform_device *pdev,
+			      const struct rsnd_of_data *of_data,
+			      struct rsnd_priv *priv)
+{
+	struct device_node *dai_node,	*dai_np;
+	struct device_node *ssi_node,	*ssi_np;
+	struct device_node *src_node,	*src_np;
+	struct device_node *playback, *capture;
+	struct rsnd_dai_platform_info *dai_info;
+	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
+	struct device *dev = &pdev->dev;
+	int nr, i;
+	int dai_i, ssi_i, src_i;
+
+	if (!of_data)
+		return;
+
+	dai_node = of_get_child_by_name(dev->of_node, "rcar_sound,dai");
+	if (!dai_node)
+		return;
+
+	nr = of_get_child_count(dai_node);
+	if (!nr)
+		return;
+
+	dai_info = devm_kzalloc(dev,
+				sizeof(struct rsnd_dai_platform_info) * nr,
+				GFP_KERNEL);
+	if (!dai_info) {
+		dev_err(dev, "dai info allocation error\n");
+		return;
+	}
+
+	info->dai_info_nr	= nr;
+	info->dai_info		= dai_info;
+
+	ssi_node = of_get_child_by_name(dev->of_node, "rcar_sound,ssi");
+	src_node = of_get_child_by_name(dev->of_node, "rcar_sound,src");
+
+#define mod_parse(name)							\
+if (name##_node) {							\
+	struct rsnd_##name##_platform_info *name##_info;		\
+									\
+	name##_i = 0;							\
+	for_each_child_of_node(name##_node, name##_np) {		\
+		name##_info = info->name##_info + name##_i;		\
+									\
+		if (name##_np == playback)				\
+			dai_info->playback.name = name##_info;		\
+		if (name##_np == capture)				\
+			dai_info->capture.name = name##_info;		\
+									\
+		name##_i++;						\
+	}								\
+}
+
+	/*
+	 * parse all dai
+	 */
+	dai_i = 0;
+	for_each_child_of_node(dai_node, dai_np) {
+		dai_info = info->dai_info + dai_i;
+
+		for (i = 0;; i++) {
+
+			playback = of_parse_phandle(dai_np, "playback", i);
+			capture  = of_parse_phandle(dai_np, "capture", i);
+
+			if (!playback && !capture)
+				break;
+
+			mod_parse(ssi);
+			mod_parse(src);
+
+			if (playback)
+				of_node_put(playback);
+			if (capture)
+				of_node_put(capture);
+		}
+
+		dai_i++;
+	}
+}
+
 static int rsnd_dai_probe(struct platform_device *pdev,
+			  const struct rsnd_of_data *of_data,
 			  struct rsnd_priv *priv)
 {
 	struct snd_soc_dai_driver *drv;
@@ -628,13 +728,16 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 	struct rsnd_dai *rdai;
 	struct rsnd_mod *pmod, *cmod;
 	struct device *dev = rsnd_priv_to_dev(priv);
-	int dai_nr = info->dai_info_nr;
+	int dai_nr;
 	int i;
 
+	rsnd_of_parse_dai(pdev, of_data, priv);
+
 	/*
 	 * dai_nr should be set via dai_info_nr,
 	 * but allow it to keeping compatible
 	 */
+	dai_nr = info->dai_info_nr;
 	if (!dai_nr) {
 		/* get max dai nr */
 		for (dai_nr = 0; dai_nr < 32; dai_nr++) {
@@ -802,7 +905,10 @@ static int rsnd_probe(struct platform_device *pdev)
 	struct rsnd_priv *priv;
 	struct device *dev = &pdev->dev;
 	struct rsnd_dai *rdai;
+	const struct of_device_id *of_id = of_match_device(rsnd_of_match, dev);
+	const struct rsnd_of_data *of_data;
 	int (*probe_func[])(struct platform_device *pdev,
+			    const struct rsnd_of_data *of_data,
 			    struct rsnd_priv *priv) = {
 		rsnd_gen_probe,
 		rsnd_ssi_probe,
@@ -812,7 +918,16 @@ static int rsnd_probe(struct platform_device *pdev)
 	};
 	int ret, i;
 
-	info = pdev->dev.platform_data;
+	info = NULL;
+	of_data = NULL;
+	if (of_id) {
+		info = devm_kzalloc(&pdev->dev,
+				    sizeof(struct rcar_snd_info), GFP_KERNEL);
+		of_data = of_id->data;
+	} else {
+		info = pdev->dev.platform_data;
+	}
+
 	if (!info) {
 		dev_err(dev, "driver needs R-Car sound information\n");
 		return -ENODEV;
@@ -835,7 +950,7 @@ static int rsnd_probe(struct platform_device *pdev)
 	 *	init each module
 	 */
 	for (i = 0; i < ARRAY_SIZE(probe_func); i++) {
-		ret = probe_func[i](pdev, priv);
+		ret = probe_func[i](pdev, of_data, priv);
 		if (ret)
 			return ret;
 	}
@@ -903,6 +1018,7 @@ static int rsnd_remove(struct platform_device *pdev)
 static struct platform_driver rsnd_driver = {
 	.driver	= {
 		.name	= "rcar_sound",
+		.of_match_table = rsnd_of_match,
 	},
 	.probe		= rsnd_probe,
 	.remove		= rsnd_remove,

commit e1508289404ab6ca28e0dc931612600f0441c417
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 13 17:56:43 2014 -0700

    ASoC: rcar: fixup SND_SOC_DAIFMT_CBx_CFx flags
    
    SND_SOC_DAIFMT_CBx_CFx means "codec" side master/slave mode.
    Then, rcar will be master mode if it was SND_SOC_DAIFMT_CBS_CFS.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 743de5e3b1e1..3a4fe9d0d4f2 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -486,10 +486,10 @@ static int rsnd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	/* set master/slave audio interface */
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBM_CFM:
-		rdai->clk_master = 1;
+		rdai->clk_master = 0;
 		break;
 	case SND_SOC_DAIFMT_CBS_CFS:
-		rdai->clk_master = 0;
+		rdai->clk_master = 1; /* codec is slave, cpu is master */
 		break;
 	default:
 		return -EINVAL;

commit ba9c949f797aa3af56303445812a452144c61c35
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 3 20:51:21 2014 -0800

    ASoC: rsnd: rename scu to src
    
    R-Car sound has SCU unit which has SRC/CTU/MIX/DVC,
    and current rsnd driver has scu.c and scu module.
    Current scu.c has SRC support only.
    My first concept was control these feature on scu.c
    but, it become difficult and un-understandable now.
    This patch rename scu to src
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ceb4e8bd4970..6a1b45df8101 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -73,13 +73,13 @@
  *   |  +- ssi[2]
  *   |  ...
  *   |
- *   | ** these control scu
+ *   | ** these control src
  *   |
- *   +- scu
+ *   +- src
  *      |
- *      +- scu[0]
- *      +- scu[1]
- *      +- scu[2]
+ *      +- src[0]
+ *      +- src[1]
+ *      +- src[2]
  *      ...
  *
  *
@@ -572,7 +572,7 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	struct rsnd_dai_platform_info *dai_info = rdai->info;
 	int ret;
 	int ssi_id = -1;
-	int scu_id = -1;
+	int src_id = -1;
 
 	/*
 	 * Gen1 is created by SRU/SSI, and this SRU is base module of
@@ -587,8 +587,8 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	if (dai_info) {
 		if (rsnd_is_enable_path(io, ssi))
 			ssi_id = rsnd_info_id(priv, io, ssi);
-		if (rsnd_is_enable_path(io, scu))
-			scu_id = rsnd_info_id(priv, io, scu);
+		if (rsnd_is_enable_path(io, src))
+			src_id = rsnd_info_id(priv, io, src);
 	} else {
 		/* get SSI's ID */
 		mod = rsnd_ssi_mod_get_frm_dai(priv,
@@ -596,14 +596,14 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 					       rsnd_dai_is_play(rdai, io));
 		if (!mod)
 			return 0;
-		ssi_id = scu_id = rsnd_mod_id(mod);
+		ssi_id = src_id = rsnd_mod_id(mod);
 	}
 
 	ret = 0;
 
-	/* SCU */
-	if (scu_id >= 0) {
-		mod = rsnd_scu_mod_get(priv, scu_id);
+	/* SRC */
+	if (src_id >= 0) {
+		mod = rsnd_src_mod_get(priv, src_id);
 		ret = rsnd_dai_connect(mod, io);
 		if (ret < 0)
 			return ret;
@@ -806,7 +806,7 @@ static int rsnd_probe(struct platform_device *pdev)
 			    struct rsnd_priv *priv) = {
 		rsnd_gen_probe,
 		rsnd_ssi_probe,
-		rsnd_scu_probe,
+		rsnd_src_probe,
 		rsnd_adg_probe,
 		rsnd_dai_probe,
 	};

commit 9524be0e761edd9f3c020344677d914ed249d010
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 3 20:51:11 2014 -0800

    ASoC: rsnd: remove all rsnd_xxx_remove()
    
    Now, rsnd_xxx_remove() do nothing.
    remove these
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 92e155b7b6a7..ceb4e8bd4970 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -708,11 +708,6 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 	return 0;
 }
 
-static void rsnd_dai_remove(struct platform_device *pdev,
-			  struct rsnd_priv *priv)
-{
-}
-
 /*
  *		pcm ops
  */
@@ -902,15 +897,6 @@ static int rsnd_remove(struct platform_device *pdev)
 			return ret;
 	}
 
-	/*
-	 *	remove each module
-	 */
-	rsnd_ssi_remove(pdev, priv);
-	rsnd_adg_remove(pdev, priv);
-	rsnd_scu_remove(pdev, priv);
-	rsnd_dai_remove(pdev, priv);
-	rsnd_gen_remove(pdev, priv);
-
 	return 0;
 }
 

commit 4076220767416b8b65009dd57eeb317c38d41baa
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 3 20:51:03 2014 -0800

    ASoC: rsnd: nothing to do on rsnd_dai_remove()
    
    rsnd_dai_remove() called rsnd_path_exit(),
    but these memory will be cleaned automatically.
    Because it is created by devm_kzalloc().
    nothing to do on rsnd_dai_remove()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index e8e585de7251..92e155b7b6a7 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -348,14 +348,6 @@ static int rsnd_dai_connect(struct rsnd_mod *mod,
 	return 0;
 }
 
-static int rsnd_dai_disconnect(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
-{
-	io->mod[mod->type] = NULL;
-	mod->io = NULL;
-
-	return 0;
-}
-
 int rsnd_dai_id(struct rsnd_priv *priv, struct rsnd_dai *rdai)
 {
 	int id = rdai - priv->rdai;
@@ -628,26 +620,6 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	return ret;
 }
 
-static int rsnd_path_exit(struct rsnd_priv *priv,
-			  struct rsnd_dai *rdai,
-			  struct rsnd_dai_stream *io)
-{
-	struct rsnd_mod *mod;
-	int ret = 0, i;
-
-	/*
-	 * remove all mod from rdai
-	 */
-	for (i = 0; i < RSND_MOD_MAX; i++) {
-		mod = io->mod[i];
-		if (!mod)
-			continue;
-		ret |= rsnd_dai_disconnect(mod, io);
-	}
-
-	return ret;
-}
-
 static int rsnd_dai_probe(struct platform_device *pdev,
 			  struct rsnd_priv *priv)
 {
@@ -739,14 +711,6 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 static void rsnd_dai_remove(struct platform_device *pdev,
 			  struct rsnd_priv *priv)
 {
-	struct rsnd_dai *rdai;
-	int i;
-
-	for (i = 0; i < rsnd_rdai_nr(priv); i++) {
-		rdai = rsnd_dai_get(priv, i);
-		rsnd_path_exit(priv, rdai, &rdai->playback);
-		rsnd_path_exit(priv, rdai, &rdai->capture);
-	}
 }
 
 /*

commit 7681f6ac6b6338932621f842d68e54f6267b785f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 3 20:50:33 2014 -0800

    ASoC: rsnd: add probe/remove callback on rsnd_mod_ops
    
    Each rsnd mod needs specific probe method,
    and its best timing is DAI probe timing.
    But current code runs it mod probe timing.
    This patch adds new probe/remove callback to solve it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 7316d10e4649..e8e585de7251 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -842,6 +842,7 @@ static int rsnd_probe(struct platform_device *pdev)
 	struct rcar_snd_info *info;
 	struct rsnd_priv *priv;
 	struct device *dev = &pdev->dev;
+	struct rsnd_dai *rdai;
 	int (*probe_func[])(struct platform_device *pdev,
 			    struct rsnd_priv *priv) = {
 		rsnd_gen_probe,
@@ -880,6 +881,16 @@ static int rsnd_probe(struct platform_device *pdev)
 			return ret;
 	}
 
+	for_each_rsnd_dai(rdai, priv, i) {
+		ret = rsnd_dai_call(rdai, &rdai->playback, probe);
+		if (ret)
+			return ret;
+
+		ret = rsnd_dai_call(rdai, &rdai->capture, probe);
+		if (ret)
+			return ret;
+	}
+
 	/*
 	 *	asoc register
 	 */
@@ -912,9 +923,21 @@ static int rsnd_probe(struct platform_device *pdev)
 static int rsnd_remove(struct platform_device *pdev)
 {
 	struct rsnd_priv *priv = dev_get_drvdata(&pdev->dev);
+	struct rsnd_dai *rdai;
+	int ret, i;
 
 	pm_runtime_disable(&pdev->dev);
 
+	for_each_rsnd_dai(rdai, priv, i) {
+		ret = rsnd_dai_call(rdai, &rdai->playback, remove);
+		if (ret)
+			return ret;
+
+		ret = rsnd_dai_call(rdai, &rdai->capture, remove);
+		if (ret)
+			return ret;
+	}
+
 	/*
 	 *	remove each module
 	 */

commit 389933d9f6e55a1ef3a71549c36f6283b9f8c145
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 3 20:50:00 2014 -0800

    ASoC: rsnd: Get correct SCU ID
    
    Current rsnd driver is assuming that SCU/SRU ID is
    same as SSIU/SSI ID, because Gen1 can't select it.
    But, Gen2 can select it.
    The SCU/SRU/SSIU/SSI pair depends on the platform.
    This patch get correct SCU ID from platform info.
    To keep compatible, it still assuming SCU ID = SSI ID
    if platform doesn't have info
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 450472633eb1..7316d10e4649 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -107,6 +107,11 @@
 	(!(priv->info->func) ? 0 :		\
 	 priv->info->func(param))
 
+#define rsnd_is_enable_path(io, name) \
+	((io)->info ? (io)->info->name : NULL)
+#define rsnd_info_id(priv, io, name) \
+	((io)->info->name - priv->info->name##_info)
+
 /*
  *	rsnd_mod functions
  */
@@ -572,8 +577,10 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 			  struct rsnd_dai_stream *io)
 {
 	struct rsnd_mod *mod;
+	struct rsnd_dai_platform_info *dai_info = rdai->info;
 	int ret;
-	int id;
+	int ssi_id = -1;
+	int scu_id = -1;
 
 	/*
 	 * Gen1 is created by SRU/SSI, and this SRU is base module of
@@ -584,29 +591,35 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	 *
 	 * Gen2 SCU path is very flexible, but, Gen1 SRU (SCU parts) is
 	 * using fixed path.
-	 *
-	 * Then, SSI id = SCU id here
 	 */
-	/* get SSI's ID */
-	mod = rsnd_ssi_mod_get_frm_dai(priv,
-				       rsnd_dai_id(priv, rdai),
-				       rsnd_dai_is_play(rdai, io));
-	if (!mod)
-		return 0;
-	id = rsnd_mod_id(mod);
+	if (dai_info) {
+		if (rsnd_is_enable_path(io, ssi))
+			ssi_id = rsnd_info_id(priv, io, ssi);
+		if (rsnd_is_enable_path(io, scu))
+			scu_id = rsnd_info_id(priv, io, scu);
+	} else {
+		/* get SSI's ID */
+		mod = rsnd_ssi_mod_get_frm_dai(priv,
+					       rsnd_dai_id(priv, rdai),
+					       rsnd_dai_is_play(rdai, io));
+		if (!mod)
+			return 0;
+		ssi_id = scu_id = rsnd_mod_id(mod);
+	}
+
 	ret = 0;
 
 	/* SCU */
-	mod = rsnd_scu_mod_get(priv, id);
-	if (mod) {
+	if (scu_id >= 0) {
+		mod = rsnd_scu_mod_get(priv, scu_id);
 		ret = rsnd_dai_connect(mod, io);
 		if (ret < 0)
 			return ret;
 	}
 
 	/* SSI */
-	mod = rsnd_ssi_mod_get(priv, id);
-	if (mod) {
+	if (ssi_id >= 0) {
+		mod = rsnd_ssi_mod_get(priv, ssi_id);
 		ret = rsnd_dai_connect(mod, io);
 		if (ret < 0)
 			return ret;
@@ -699,6 +712,9 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 			drv[i].playback.formats		= RSND_FMTS;
 			drv[i].playback.channels_min	= 2;
 			drv[i].playback.channels_max	= 2;
+
+			if (info->dai_info)
+				rdai[i].playback.info = &info->dai_info[i].playback;
 			rsnd_path_init(priv, &rdai[i], &rdai[i].playback);
 		}
 		if (cmod) {
@@ -706,6 +722,9 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 			drv[i].capture.formats		= RSND_FMTS;
 			drv[i].capture.channels_min	= 2;
 			drv[i].capture.channels_max	= 2;
+
+			if (info->dai_info)
+				rdai[i].capture.info = &info->dai_info[i].capture;
 			rsnd_path_init(priv, &rdai[i], &rdai[i].capture);
 		}
 

commit 78f13d0c5a2888564b2bed7f8433c8ec889997ff
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 3 20:49:50 2014 -0800

    ASoC: rsnd: add struct rsnd_dai_platform_info
    
    R-Car sound DAI consists from SSI/SCU/SSIU/SRU...
    Current R-Car sound DAI is decided from these settings,
    but it is intuitively unclear, and is not good design for DT support.
    This patch adds new rsnd_dai_platform_info to solve this issue.
    
    But now, many platform is using this driver without
    rsnd_dai_platform_info.
    So, this patch still supports DAI settings via SSI to keep compatible.
    It will be removed in next Linux version.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ea747614fbf8..450472633eb1 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -639,19 +639,26 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 			  struct rsnd_priv *priv)
 {
 	struct snd_soc_dai_driver *drv;
+	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
 	struct rsnd_dai *rdai;
 	struct rsnd_mod *pmod, *cmod;
 	struct device *dev = rsnd_priv_to_dev(priv);
-	int dai_nr;
+	int dai_nr = info->dai_info_nr;
 	int i;
 
-	/* get max dai nr */
-	for (dai_nr = 0; dai_nr < 32; dai_nr++) {
-		pmod = rsnd_ssi_mod_get_frm_dai(priv, dai_nr, 1);
-		cmod = rsnd_ssi_mod_get_frm_dai(priv, dai_nr, 0);
+	/*
+	 * dai_nr should be set via dai_info_nr,
+	 * but allow it to keeping compatible
+	 */
+	if (!dai_nr) {
+		/* get max dai nr */
+		for (dai_nr = 0; dai_nr < 32; dai_nr++) {
+			pmod = rsnd_ssi_mod_get_frm_dai(priv, dai_nr, 1);
+			cmod = rsnd_ssi_mod_get_frm_dai(priv, dai_nr, 0);
 
-		if (!pmod && !cmod)
-			break;
+			if (!pmod && !cmod)
+				break;
+		}
 	}
 
 	if (!dai_nr) {
@@ -671,6 +678,8 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 	priv->rdai	= rdai;
 
 	for (i = 0; i < dai_nr; i++) {
+		if (info->dai_info)
+			rdai[i].info = &info->dai_info[i];
 
 		pmod = rsnd_ssi_mod_get_frm_dai(priv, i, 1);
 		cmod = rsnd_ssi_mod_get_frm_dai(priv, i, 0);

commit d1ac970f5de94bef9e094b46f016899d04e8178b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Mar 2 23:43:18 2014 -0800

    ASoC: rsnd: use function pointer for each probe
    
    R-Car sound consists of many devices.
    It will have more device support in the future.
    Thus, for each probe become now function pointer array.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 416b0782503a..ea747614fbf8 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -814,7 +814,15 @@ static int rsnd_probe(struct platform_device *pdev)
 	struct rcar_snd_info *info;
 	struct rsnd_priv *priv;
 	struct device *dev = &pdev->dev;
-	int ret;
+	int (*probe_func[])(struct platform_device *pdev,
+			    struct rsnd_priv *priv) = {
+		rsnd_gen_probe,
+		rsnd_ssi_probe,
+		rsnd_scu_probe,
+		rsnd_adg_probe,
+		rsnd_dai_probe,
+	};
+	int ret, i;
 
 	info = pdev->dev.platform_data;
 	if (!info) {
@@ -838,25 +846,11 @@ static int rsnd_probe(struct platform_device *pdev)
 	/*
 	 *	init each module
 	 */
-	ret = rsnd_gen_probe(pdev, priv);
-	if (ret)
-		return ret;
-
-	ret = rsnd_ssi_probe(pdev, priv);
-	if (ret)
-		return ret;
-
-	ret = rsnd_scu_probe(pdev, priv);
-	if (ret)
-		return ret;
-
-	ret = rsnd_adg_probe(pdev, priv);
-	if (ret)
-		return ret;
-
-	ret = rsnd_dai_probe(pdev, priv);
-	if (ret)
-		return ret;
+	for (i = 0; i < ARRAY_SIZE(probe_func); i++) {
+		ret = probe_func[i](pdev, priv);
+		if (ret)
+			return ret;
+	}
 
 	/*
 	 *	asoc register

commit a126021d144bae88a563db2b57b0ad5eb1ee66d9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Mar 2 23:42:55 2014 -0800

    ASoC: rsnd: use mod array instead of list on rdai
    
    struct rsnd_dai_stream used list for mod list.
    It added only odd flexibility to current driver, and
    it is a factor which makes extendibility difficult.
    rsnd use mod array instead of list from now.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 96cb78612a7d..416b0782503a 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -121,12 +121,13 @@ char *rsnd_mod_name(struct rsnd_mod *mod)
 void rsnd_mod_init(struct rsnd_priv *priv,
 		   struct rsnd_mod *mod,
 		   struct rsnd_mod_ops *ops,
+		   enum rsnd_mod_type type,
 		   int id)
 {
 	mod->priv	= priv;
 	mod->id		= id;
 	mod->ops	= ops;
-	INIT_LIST_HEAD(&mod->list);
+	mod->type	= type;
 }
 
 /*
@@ -307,9 +308,12 @@ void  rsnd_dma_quit(struct rsnd_priv *priv,
 
 #define rsnd_dai_call(rdai, io, fn)				\
 ({								\
-	struct rsnd_mod *mod, *n;				\
-	int ret = 0;						\
-	for_each_rsnd_mod(mod, n, (io)) {			\
+	struct rsnd_mod *mod;					\
+	int ret = 0, i;						\
+	for (i = 0; i < RSND_MOD_MAX; i++) {			\
+		mod = (io)->mod[i];				\
+		if (!mod)					\
+			continue;				\
 		ret = rsnd_mod_call(mod, fn, (rdai), (io));	\
 		if (ret < 0)					\
 			break;					\
@@ -317,14 +321,13 @@ void  rsnd_dma_quit(struct rsnd_priv *priv,
 	ret;							\
 })
 
-static int rsnd_dai_connect(struct rsnd_dai *rdai,
-			    struct rsnd_mod *mod,
+static int rsnd_dai_connect(struct rsnd_mod *mod,
 			    struct rsnd_dai_stream *io)
 {
 	if (!mod)
 		return -EIO;
 
-	if (!list_empty(&mod->list)) {
+	if (io->mod[mod->type]) {
 		struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 		struct device *dev = rsnd_priv_to_dev(priv);
 
@@ -334,15 +337,15 @@ static int rsnd_dai_connect(struct rsnd_dai *rdai,
 		return -EIO;
 	}
 
-	list_add_tail(&mod->list, &io->head);
+	io->mod[mod->type] = mod;
 	mod->io = io;
 
 	return 0;
 }
 
-static int rsnd_dai_disconnect(struct rsnd_mod *mod)
+static int rsnd_dai_disconnect(struct rsnd_mod *mod, struct rsnd_dai_stream *io)
 {
-	list_del_init(&mod->list);
+	io->mod[mod->type] = NULL;
 	mod->io = NULL;
 
 	return 0;
@@ -596,7 +599,7 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	/* SCU */
 	mod = rsnd_scu_mod_get(priv, id);
 	if (mod) {
-		ret = rsnd_dai_connect(rdai, mod, io);
+		ret = rsnd_dai_connect(mod, io);
 		if (ret < 0)
 			return ret;
 	}
@@ -604,7 +607,7 @@ static int rsnd_path_init(struct rsnd_priv *priv,
 	/* SSI */
 	mod = rsnd_ssi_mod_get(priv, id);
 	if (mod) {
-		ret = rsnd_dai_connect(rdai, mod, io);
+		ret = rsnd_dai_connect(mod, io);
 		if (ret < 0)
 			return ret;
 	}
@@ -616,14 +619,18 @@ static int rsnd_path_exit(struct rsnd_priv *priv,
 			  struct rsnd_dai *rdai,
 			  struct rsnd_dai_stream *io)
 {
-	struct rsnd_mod *mod, *n;
-	int ret = 0;
+	struct rsnd_mod *mod;
+	int ret = 0, i;
 
 	/*
 	 * remove all mod from rdai
 	 */
-	for_each_rsnd_mod(mod, n, io)
-		ret |= rsnd_dai_disconnect(mod);
+	for (i = 0; i < RSND_MOD_MAX; i++) {
+		mod = io->mod[i];
+		if (!mod)
+			continue;
+		ret |= rsnd_dai_disconnect(mod, io);
+	}
 
 	return ret;
 }
@@ -671,9 +678,6 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 		/*
 		 *	init rsnd_dai
 		 */
-		INIT_LIST_HEAD(&rdai[i].playback.head);
-		INIT_LIST_HEAD(&rdai[i].capture.head);
-
 		snprintf(rdai[i].name, RSND_DAI_NAME_SIZE, "rsnd-dai.%d", i);
 
 		/*

commit 9bfed6cf4fa2cd2c5e80431244348b0c5d933cf5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Mar 2 23:42:47 2014 -0800

    ASoC: rsnd: run rsnd_path_init() when probe() timing
    
    Current rsnd SSIU/SSI/SCU/SRU path is set
    when playback/capture starts up.
    But it is meaningless method, since the path is based
    on platform and can be set in probe() timing.
    This patch sets the path on probe() timing.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f0745af316be..96cb78612a7d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -317,9 +317,9 @@ void  rsnd_dma_quit(struct rsnd_priv *priv,
 	ret;							\
 })
 
-int rsnd_dai_connect(struct rsnd_dai *rdai,
-		     struct rsnd_mod *mod,
-		     struct rsnd_dai_stream *io)
+static int rsnd_dai_connect(struct rsnd_dai *rdai,
+			    struct rsnd_mod *mod,
+			    struct rsnd_dai_stream *io)
 {
 	if (!mod)
 		return -EIO;
@@ -340,7 +340,7 @@ int rsnd_dai_connect(struct rsnd_dai *rdai,
 	return 0;
 }
 
-int rsnd_dai_disconnect(struct rsnd_mod *mod)
+static int rsnd_dai_disconnect(struct rsnd_mod *mod)
 {
 	list_del_init(&mod->list);
 	mod->io = NULL;
@@ -418,10 +418,6 @@ static int rsnd_dai_stream_init(struct rsnd_dai_stream *io,
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	if (!list_empty(&io->head))
-		return -EIO;
-
-	INIT_LIST_HEAD(&io->head);
 	io->substream		= substream;
 	io->byte_pos		= 0;
 	io->period_pos		= 0;
@@ -476,10 +472,6 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (ret < 0)
 			goto dai_trigger_end;
 
-		ret = rsnd_gen_path_init(priv, rdai, io);
-		if (ret < 0)
-			goto dai_trigger_end;
-
 		ret = rsnd_dai_call(rdai, io, init);
 		if (ret < 0)
 			goto dai_trigger_end;
@@ -497,10 +489,6 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (ret < 0)
 			goto dai_trigger_end;
 
-		ret = rsnd_gen_path_exit(priv, rdai, io);
-		if (ret < 0)
-			goto dai_trigger_end;
-
 		ret = rsnd_platform_call(priv, dai, stop, ssi_id);
 		if (ret < 0)
 			goto dai_trigger_end;
@@ -576,6 +564,70 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 	.set_fmt	= rsnd_soc_dai_set_fmt,
 };
 
+static int rsnd_path_init(struct rsnd_priv *priv,
+			  struct rsnd_dai *rdai,
+			  struct rsnd_dai_stream *io)
+{
+	struct rsnd_mod *mod;
+	int ret;
+	int id;
+
+	/*
+	 * Gen1 is created by SRU/SSI, and this SRU is base module of
+	 * Gen2's SCU/SSIU/SSI. (Gen2 SCU/SSIU came from SRU)
+	 *
+	 * Easy image is..
+	 *	Gen1 SRU = Gen2 SCU + SSIU + etc
+	 *
+	 * Gen2 SCU path is very flexible, but, Gen1 SRU (SCU parts) is
+	 * using fixed path.
+	 *
+	 * Then, SSI id = SCU id here
+	 */
+	/* get SSI's ID */
+	mod = rsnd_ssi_mod_get_frm_dai(priv,
+				       rsnd_dai_id(priv, rdai),
+				       rsnd_dai_is_play(rdai, io));
+	if (!mod)
+		return 0;
+	id = rsnd_mod_id(mod);
+	ret = 0;
+
+	/* SCU */
+	mod = rsnd_scu_mod_get(priv, id);
+	if (mod) {
+		ret = rsnd_dai_connect(rdai, mod, io);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* SSI */
+	mod = rsnd_ssi_mod_get(priv, id);
+	if (mod) {
+		ret = rsnd_dai_connect(rdai, mod, io);
+		if (ret < 0)
+			return ret;
+	}
+
+	return ret;
+}
+
+static int rsnd_path_exit(struct rsnd_priv *priv,
+			  struct rsnd_dai *rdai,
+			  struct rsnd_dai_stream *io)
+{
+	struct rsnd_mod *mod, *n;
+	int ret = 0;
+
+	/*
+	 * remove all mod from rdai
+	 */
+	for_each_rsnd_mod(mod, n, io)
+		ret |= rsnd_dai_disconnect(mod);
+
+	return ret;
+}
+
 static int rsnd_dai_probe(struct platform_device *pdev,
 			  struct rsnd_priv *priv)
 {
@@ -634,12 +686,14 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 			drv[i].playback.formats		= RSND_FMTS;
 			drv[i].playback.channels_min	= 2;
 			drv[i].playback.channels_max	= 2;
+			rsnd_path_init(priv, &rdai[i], &rdai[i].playback);
 		}
 		if (cmod) {
 			drv[i].capture.rates		= RSND_RATES;
 			drv[i].capture.formats		= RSND_FMTS;
 			drv[i].capture.channels_min	= 2;
 			drv[i].capture.channels_max	= 2;
+			rsnd_path_init(priv, &rdai[i], &rdai[i].capture);
 		}
 
 		dev_dbg(dev, "%s (%s/%s)\n", rdai[i].name,
@@ -653,6 +707,14 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 static void rsnd_dai_remove(struct platform_device *pdev,
 			  struct rsnd_priv *priv)
 {
+	struct rsnd_dai *rdai;
+	int i;
+
+	for (i = 0; i < rsnd_rdai_nr(priv); i++) {
+		rdai = rsnd_dai_get(priv, i);
+		rsnd_path_exit(priv, rdai, &rdai->playback);
+		rsnd_path_exit(priv, rdai, &rdai->capture);
+	}
 }
 
 /*

commit ecba9e724c5775aebd3a28e831643160c7146e83
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 24 22:15:18 2014 -0800

    ASoC: rsnd: unify rdai naming
    
    struct rsnd_dai is called as "rdai",
    but its size has been called as "dai_nr".
    Unify these as "rdai"
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b2370f68e645..f0745af316be 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -352,7 +352,7 @@ int rsnd_dai_id(struct rsnd_priv *priv, struct rsnd_dai *rdai)
 {
 	int id = rdai - priv->rdai;
 
-	if ((id < 0) || (id >= rsnd_dai_nr(priv)))
+	if ((id < 0) || (id >= rsnd_rdai_nr(priv)))
 		return -EINVAL;
 
 	return id;
@@ -360,7 +360,7 @@ int rsnd_dai_id(struct rsnd_priv *priv, struct rsnd_dai *rdai)
 
 struct rsnd_dai *rsnd_dai_get(struct rsnd_priv *priv, int id)
 {
-	if ((id < 0) || (id >= rsnd_dai_nr(priv)))
+	if ((id < 0) || (id >= rsnd_rdai_nr(priv)))
 		return NULL;
 
 	return priv->rdai + id;
@@ -607,7 +607,7 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 		return -ENOMEM;
 	}
 
-	priv->dai_nr	= dai_nr;
+	priv->rdai_nr	= dai_nr;
 	priv->daidrv	= drv;
 	priv->rdai	= rdai;
 
@@ -802,7 +802,7 @@ static int rsnd_probe(struct platform_device *pdev)
 	}
 
 	ret = snd_soc_register_component(dev, &rsnd_soc_component,
-					 priv->daidrv, rsnd_dai_nr(priv));
+					 priv->daidrv, rsnd_rdai_nr(priv));
 	if (ret < 0) {
 		dev_err(dev, "cannot snd dai register\n");
 		goto exit_snd_soc;

commit 5da39cf30454bbf3e92f56935e7d137e5bd2c830
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 24 22:15:00 2014 -0800

    ASoC: rsnd: remove verbose function parameter
    
    priv has rcar_snd_info pointer.
    having priv and info in same time is verbose.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 5f6d9fef23d1..b2370f68e645 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -577,7 +577,6 @@ static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
 };
 
 static int rsnd_dai_probe(struct platform_device *pdev,
-			  struct rcar_snd_info *info,
 			  struct rsnd_priv *priv)
 {
 	struct snd_soc_dai_driver *drv;
@@ -773,23 +772,23 @@ static int rsnd_probe(struct platform_device *pdev)
 	/*
 	 *	init each module
 	 */
-	ret = rsnd_gen_probe(pdev, info, priv);
+	ret = rsnd_gen_probe(pdev, priv);
 	if (ret)
 		return ret;
 
-	ret = rsnd_ssi_probe(pdev, info, priv);
+	ret = rsnd_ssi_probe(pdev, priv);
 	if (ret)
 		return ret;
 
-	ret = rsnd_scu_probe(pdev, info, priv);
+	ret = rsnd_scu_probe(pdev, priv);
 	if (ret)
 		return ret;
 
-	ret = rsnd_adg_probe(pdev, info, priv);
+	ret = rsnd_adg_probe(pdev, priv);
 	if (ret)
 		return ret;
 
-	ret = rsnd_dai_probe(pdev, info, priv);
+	ret = rsnd_dai_probe(pdev, priv);
 	if (ret)
 		return ret;
 

commit d870a91e9d0eae524ac2da7cbdc7e399a71b86c4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 24 22:14:41 2014 -0800

    ASoC: rsnd: move rsnd_mod_call() macro
    
    core.c is the only user of rsnd_mod_call() macro.
    Move it to core.c from rsnd.h
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index a8e6aa6cb334..5f6d9fef23d1 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -291,16 +291,30 @@ void  rsnd_dma_quit(struct rsnd_priv *priv,
 /*
  *	rsnd_dai functions
  */
-#define rsnd_dai_call(rdai, io, fn)			\
-({							\
-	struct rsnd_mod *mod, *n;			\
-	int ret = 0;					\
-	for_each_rsnd_mod(mod, n, io) {			\
-		ret = rsnd_mod_call(mod, fn, rdai, io);	\
-		if (ret < 0)				\
-			break;				\
-	}						\
-	ret;						\
+#define __rsnd_mod_call(mod, func, rdai, io)			\
+({								\
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);		\
+	struct device *dev = rsnd_priv_to_dev(priv);		\
+	dev_dbg(dev, "%s [%d] %s\n",				\
+		rsnd_mod_name(mod), rsnd_mod_id(mod), #func);	\
+	(mod)->ops->func(mod, rdai, io);			\
+})
+
+#define rsnd_mod_call(mod, func, rdai, io)	\
+	(!(mod) ? -ENODEV :			\
+	 !((mod)->ops->func) ? 0 :		\
+	 __rsnd_mod_call(mod, func, (rdai), (io)))
+
+#define rsnd_dai_call(rdai, io, fn)				\
+({								\
+	struct rsnd_mod *mod, *n;				\
+	int ret = 0;						\
+	for_each_rsnd_mod(mod, n, (io)) {			\
+		ret = rsnd_mod_call(mod, fn, (rdai), (io));	\
+		if (ret < 0)					\
+			break;					\
+	}							\
+	ret;							\
 })
 
 int rsnd_dai_connect(struct rsnd_dai *rdai,

commit 498480731e232d7c9a96a338924b5a275121e091
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 24 22:14:33 2014 -0800

    ASoC: rsnd: move priv member settings to upper side
    
    There is no big meaning, but preparation for platform dai support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index f316a663e4d3..a8e6aa6cb334 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -594,6 +594,10 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 		return -ENOMEM;
 	}
 
+	priv->dai_nr	= dai_nr;
+	priv->daidrv	= drv;
+	priv->rdai	= rdai;
+
 	for (i = 0; i < dai_nr; i++) {
 
 		pmod = rsnd_ssi_mod_get_frm_dai(priv, i, 1);
@@ -630,10 +634,6 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 			cmod ? "capture" : "  --   ");
 	}
 
-	priv->dai_nr	= dai_nr;
-	priv->daidrv	= drv;
-	priv->rdai	= rdai;
-
 	return 0;
 }
 

commit eb854f6dff24a59378acc8d8eda57a3543a25acc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 23 18:41:51 2014 -0800

    ASoC: rsnd: rsnd_ssi_probe() goes forwarder than rsnd_scu_probe()
    
    rsnd_ssi_probe() goes forwarder than rsnd_scu_probe(),
    since scu will need ssi information on Gen2
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b5af6f5145ea..f316a663e4d3 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -763,15 +763,15 @@ static int rsnd_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	ret = rsnd_scu_probe(pdev, info, priv);
+	ret = rsnd_ssi_probe(pdev, info, priv);
 	if (ret)
 		return ret;
 
-	ret = rsnd_adg_probe(pdev, info, priv);
+	ret = rsnd_scu_probe(pdev, info, priv);
 	if (ret)
 		return ret;
 
-	ret = rsnd_ssi_probe(pdev, info, priv);
+	ret = rsnd_adg_probe(pdev, info, priv);
 	if (ret)
 		return ret;
 

commit 4686a0ad9aaee89495f181e5755d153e7fe7ffe6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 23 18:41:44 2014 -0800

    ASoC: rsnd: remove SSI dependent DMAEngine callback
    
    Renesas Gen2 sound will use 2 DMAC
    which are Audio-DMAC, and Audio-DMAC-peri-peri.
    Current driver has callback function for each DMAC,
    because it assumed each DMAC needs special settings.
    But it became clear that these can share settings.
    This patch removes unnecessary callback
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 11eb0e35b9ce..b5af6f5145ea 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -143,6 +143,7 @@ static void rsnd_dma_continue(struct rsnd_dma *dma)
 void rsnd_dma_start(struct rsnd_dma *dma)
 {
 	/* push both A and B plane*/
+	dma->offset = 0;
 	dma->submit_loop = 2;
 	__rsnd_dma_start(dma);
 }
@@ -157,12 +158,26 @@ void rsnd_dma_stop(struct rsnd_dma *dma)
 static void rsnd_dma_complete(void *data)
 {
 	struct rsnd_dma *dma = (struct rsnd_dma *)data;
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(rsnd_dma_to_mod(dma));
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	unsigned long flags;
 
 	rsnd_lock(priv, flags);
 
-	dma->complete(dma);
+	/*
+	 * Renesas sound Gen1 needs 1 DMAC,
+	 * Gen2 needs 2 DMAC.
+	 * In Gen2 case, it are Audio-DMAC, and Audio-DMAC-peri-peri.
+	 * But, Audio-DMAC-peri-peri doesn't have interrupt,
+	 * and this driver is assuming that here.
+	 *
+	 * If Audio-DMAC-peri-peri has interrpt,
+	 * rsnd_dai_pointer_update() will be called twice,
+	 * ant it will breaks io->byte_pos
+	 */
+
+	rsnd_dai_pointer_update(io, io->byte_per_period);
 
 	if (dma->submit_loop)
 		rsnd_dma_continue(dma);
@@ -172,17 +187,21 @@ static void rsnd_dma_complete(void *data)
 
 static void __rsnd_dma_start(struct rsnd_dma *dma)
 {
-	struct rsnd_priv *priv = rsnd_mod_to_priv(rsnd_dma_to_mod(dma));
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
 	dma_addr_t buf;
-	size_t len;
+	size_t len = io->byte_per_period;
 	int i;
 
 	for (i = 0; i < dma->submit_loop; i++) {
 
-		if (dma->inquiry(dma, &buf, &len) < 0)
-			return;
+		buf = runtime->dma_addr +
+			rsnd_dai_pointer_offset(io, dma->offset + len);
+		dma->offset = len;
 
 		desc = dmaengine_prep_slave_single(
 			dma->chan, buf, len, dma->dir,
@@ -217,10 +236,7 @@ int rsnd_dma_available(struct rsnd_dma *dma)
 }
 
 int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
-		  int is_play, int id,
-		  int (*inquiry)(struct rsnd_dma *dma,
-				  dma_addr_t *buf, int *len),
-		  int (*complete)(struct rsnd_dma *dma))
+		  int is_play, int id)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_slave_config cfg;
@@ -253,8 +269,6 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 		goto rsnd_dma_init_err;
 
 	dma->dir = is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
-	dma->inquiry = inquiry;
-	dma->complete = complete;
 	INIT_WORK(&dma->work, rsnd_dma_do_work);
 
 	return 0;
@@ -307,6 +321,7 @@ int rsnd_dai_connect(struct rsnd_dai *rdai,
 	}
 
 	list_add_tail(&mod->list, &io->head);
+	mod->io = io;
 
 	return 0;
 }
@@ -314,6 +329,7 @@ int rsnd_dai_connect(struct rsnd_dai *rdai,
 int rsnd_dai_disconnect(struct rsnd_mod *mod)
 {
 	list_del_init(&mod->list);
+	mod->io = NULL;
 
 	return 0;
 }

commit f5cab3b8976d59c6166228874a5af3d87c94c723
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 23 18:40:27 2014 -0800

    ASoC: rsnd: don't use schedule_work() when rsnd_dma_start()
    
    rsnd_dma_start() is the function to start DMAEngine.
    Current code is using schedule_work() for it,
    but it breaks DMAC/SSI register setting timing.
    Don't use schedule_work() on it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 4fd57351c54a..11eb0e35b9ce 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -132,6 +132,7 @@ void rsnd_mod_init(struct rsnd_priv *priv,
 /*
  *	rsnd_dma functions
  */
+static void __rsnd_dma_start(struct rsnd_dma *dma);
 static void rsnd_dma_continue(struct rsnd_dma *dma)
 {
 	/* push next A or B plane */
@@ -143,7 +144,7 @@ void rsnd_dma_start(struct rsnd_dma *dma)
 {
 	/* push both A and B plane*/
 	dma->submit_loop = 2;
-	schedule_work(&dma->work);
+	__rsnd_dma_start(dma);
 }
 
 void rsnd_dma_stop(struct rsnd_dma *dma)
@@ -169,9 +170,8 @@ static void rsnd_dma_complete(void *data)
 	rsnd_unlock(priv, flags);
 }
 
-static void rsnd_dma_do_work(struct work_struct *work)
+static void __rsnd_dma_start(struct rsnd_dma *dma)
 {
-	struct rsnd_dma *dma = container_of(work, struct rsnd_dma, work);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(rsnd_dma_to_mod(dma));
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
@@ -204,6 +204,13 @@ static void rsnd_dma_do_work(struct work_struct *work)
 	}
 }
 
+static void rsnd_dma_do_work(struct work_struct *work)
+{
+	struct rsnd_dma *dma = container_of(work, struct rsnd_dma, work);
+
+	__rsnd_dma_start(dma);
+}
+
 int rsnd_dma_available(struct rsnd_dma *dma)
 {
 	return !!dma->chan;

commit 106d2eff563b2abdb34872cb8ec7b19766edaffc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 23 18:40:13 2014 -0800

    ASoC: rsnd: non 0 is error on probe
    
    Some xxx_probe() returns not only -Exx, but also PTR_ERR().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index ed8611f9c64f..4fd57351c54a 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -737,23 +737,23 @@ static int rsnd_probe(struct platform_device *pdev)
 	 *	init each module
 	 */
 	ret = rsnd_gen_probe(pdev, info, priv);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	ret = rsnd_scu_probe(pdev, info, priv);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	ret = rsnd_adg_probe(pdev, info, priv);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	ret = rsnd_ssi_probe(pdev, info, priv);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	ret = rsnd_dai_probe(pdev, info, priv);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	/*

commit 9b5ab573a81b9ac0df90b74d732651fdf8b24525
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 23 18:40:03 2014 -0800

    ASoC: rsnd: remove duplicate *priv from rsnd_dma
    
    *priv pointer exists under rsnd_mod,
    and, it can get rsnd_mod pointer from rsnd_dma.
    remove duplicate rsnd_dma :: priv
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 743de5e3b1e1..ed8611f9c64f 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -156,7 +156,7 @@ void rsnd_dma_stop(struct rsnd_dma *dma)
 static void rsnd_dma_complete(void *data)
 {
 	struct rsnd_dma *dma = (struct rsnd_dma *)data;
-	struct rsnd_priv *priv = dma->priv;
+	struct rsnd_priv *priv = rsnd_mod_to_priv(rsnd_dma_to_mod(dma));
 	unsigned long flags;
 
 	rsnd_lock(priv, flags);
@@ -172,7 +172,7 @@ static void rsnd_dma_complete(void *data)
 static void rsnd_dma_do_work(struct work_struct *work)
 {
 	struct rsnd_dma *dma = container_of(work, struct rsnd_dma, work);
-	struct rsnd_priv *priv = dma->priv;
+	struct rsnd_priv *priv = rsnd_mod_to_priv(rsnd_dma_to_mod(dma));
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
 	dma_addr_t buf;
@@ -246,7 +246,6 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 		goto rsnd_dma_init_err;
 
 	dma->dir = is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
-	dma->priv = priv;
 	dma->inquiry = inquiry;
 	dma->complete = complete;
 	INIT_WORK(&dma->work, rsnd_dma_do_work);

commit a7ddf151b0eb12a8840d9d127f1679bb1c89a1ff
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jan 6 14:19:14 2014 +0100

    ASoC: sh: Don't set unused struct snd_pcm_hardware fields
    
    The ASoC core assumes that the PCM component of the ASoC card transparently
    moves data around and does not impose any restrictions on the memory layout or
    the transfer speed. It ignores all fields from the snd_pcm_hardware struct for
    the PCM driver that are related to this. Setting these fields in the PCM driver
    might suggest otherwise though, so rather not set them.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b3653d37f75f..743de5e3b1e1 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -628,12 +628,6 @@ static struct snd_pcm_hardware rsnd_pcm_hardware = {
 			SNDRV_PCM_INFO_MMAP		|
 			SNDRV_PCM_INFO_MMAP_VALID	|
 			SNDRV_PCM_INFO_PAUSE,
-	.formats		= RSND_FMTS,
-	.rates			= RSND_RATES,
-	.rate_min		= 8000,
-	.rate_max		= 192000,
-	.channels_min		= 2,
-	.channels_max		= 2,
 	.buffer_bytes_max	= 64 * 1024,
 	.period_bytes_min	= 32,
 	.period_bytes_max	= 8192,

commit 4b47ab4265c9f7164f9c897792551d4640eaf9ab
Merge: cde4d7596c83 a0d32bca511f
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Nov 20 15:20:38 2013 +0000

    Merge remote-tracking branch 'asoc/fix/rcar' into asoc-linus

commit a0d32bca511fd6b570e964ca38a0c3dcd9eacafb
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Nov 17 18:45:16 2013 -0800

    ASoC: rcar: fixup dma_async_issue_pending() timing
    
    DMAEngine will stall without this patch
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 2e09ee8d2500..4e55f9d9ef43 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -199,9 +199,8 @@ static void rsnd_dma_do_work(struct work_struct *work)
 			return;
 		}
 
+		dma_async_issue_pending(dma->chan);
 	}
-
-	dma_async_issue_pending(dma->chan);
 }
 
 int rsnd_dma_available(struct rsnd_dma *dma)

commit 6020779b118f6221e5d067bd1e6b44bab6fc0276
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Nov 10 17:00:42 2013 -0800

    ASoC: rcar: fixup mod access before checking
    
    rsnd_dai_connect() is using mod before NULL checking.
    This patch fixes it up
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b234ed663073..2e09ee8d2500 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -279,15 +279,13 @@ int rsnd_dai_connect(struct rsnd_dai *rdai,
 		     struct rsnd_mod *mod,
 		     struct rsnd_dai_stream *io)
 {
-	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	struct device *dev = rsnd_priv_to_dev(priv);
-
-	if (!mod) {
-		dev_err(dev, "NULL mod\n");
+	if (!mod)
 		return -EIO;
-	}
 
 	if (!list_empty(&mod->list)) {
+		struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+		struct device *dev = rsnd_priv_to_dev(priv);
+
 		dev_err(dev, "%s%d is not empty\n",
 			rsnd_mod_name(mod),
 			rsnd_mod_id(mod));

commit 9ade09d6c62e48fba6c74ce3958ca1035dfd8427
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 29 00:52:19 2013 -0700

    ASoC: rcar: remove original filter from rsnd_dma_init()
    
    Remove original filter from rsnd_dma_init(),
    and use SH-DMA suitable filter.
    This new style can be used from Device Tree.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index b234ed663073..78c35b44fc04 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -94,6 +94,7 @@
  *
  */
 #include <linux/pm_runtime.h>
+#include <linux/shdma-base.h>
 #include "rsnd.h"
 
 #define RSND_RATES SNDRV_PCM_RATE_8000_96000
@@ -209,13 +210,6 @@ int rsnd_dma_available(struct rsnd_dma *dma)
 	return !!dma->chan;
 }
 
-static bool rsnd_dma_filter(struct dma_chan *chan, void *param)
-{
-	chan->private = param;
-
-	return true;
-}
-
 int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 		  int is_play, int id,
 		  int (*inquiry)(struct rsnd_dma *dma,
@@ -223,7 +217,9 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 		  int (*complete)(struct rsnd_dma *dma))
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
+	struct dma_slave_config cfg;
 	dma_cap_mask_t mask;
+	int ret;
 
 	if (dma->chan) {
 		dev_err(dev, "it already has dma channel\n");
@@ -233,15 +229,23 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
 
-	dma->slave.shdma_slave.slave_id = id;
-
-	dma->chan = dma_request_channel(mask, rsnd_dma_filter,
-					&dma->slave.shdma_slave);
+	dma->chan = dma_request_slave_channel_compat(mask, shdma_chan_filter,
+						     (void *)id, dev,
+						     is_play ? "tx" : "rx");
 	if (!dma->chan) {
 		dev_err(dev, "can't get dma channel\n");
 		return -EIO;
 	}
 
+	cfg.slave_id	= id;
+	cfg.dst_addr	= 0; /* use default addr when playback */
+	cfg.src_addr	= 0; /* use default addr when capture */
+	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
+
+	ret = dmaengine_slave_config(dma->chan, &cfg);
+	if (ret < 0)
+		goto rsnd_dma_init_err;
+
 	dma->dir = is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
 	dma->priv = priv;
 	dma->inquiry = inquiry;
@@ -249,6 +253,11 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
 	INIT_WORK(&dma->work, rsnd_dma_do_work);
 
 	return 0;
+
+rsnd_dma_init_err:
+	rsnd_dma_quit(priv, dma);
+
+	return ret;
 }
 
 void  rsnd_dma_quit(struct rsnd_priv *priv,

commit 2192f81c53a7879c803f0f7d6c49645fdf6c2f6a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Oct 11 00:07:48 2013 -0700

    ASoC: rcar: add ID check on rsnd_dai_get()
    
    checking id in rsnd_dai_get() is good idea
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 28c24fcf8bc7..b234ed663073 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -318,6 +318,9 @@ int rsnd_dai_id(struct rsnd_priv *priv, struct rsnd_dai *rdai)
 
 struct rsnd_dai *rsnd_dai_get(struct rsnd_priv *priv, int id)
 {
+	if ((id < 0) || (id >= rsnd_dai_nr(priv)))
+		return NULL;
+
 	return priv->rdai + id;
 }
 

commit 740ad6c328823f066efb8b907576a54ef92aca69
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Oct 11 00:06:34 2013 -0700

    ASoC: rcar: fixup rsnd_platform_call() return value
    
    Un-implemented platform callback is not error.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index fc83f0f2aead..28c24fcf8bc7 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -103,7 +103,7 @@
  *	rsnd_platform functions
  */
 #define rsnd_platform_call(priv, dai, func, param...)	\
-	(!(priv->info->func) ? -ENODEV :		\
+	(!(priv->info->func) ? 0 :		\
 	 priv->info->func(param))
 
 /*

commit 55e5b6fd5af04b6d8b0ac6635edf49476ff298ba
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Sep 23 23:12:27 2013 -0700

    ASoC: rsnd: use regmap instead of original register mapping method
    
    Current Linux kernel is supporting regmap/regmap_field,
    and, it is good match for Renesas Sound Gen1/Gen2 register mapping.
    This patch uses regmap instead of original method for register access
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index a35706028514..fc83f0f2aead 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -106,51 +106,6 @@
 	(!(priv->info->func) ? -ENODEV :		\
 	 priv->info->func(param))
 
-
-/*
- *	basic function
- */
-u32 rsnd_read(struct rsnd_priv *priv,
-	      struct rsnd_mod *mod, enum rsnd_reg reg)
-{
-	void __iomem *base = rsnd_gen_reg_get(priv, mod, reg);
-
-	BUG_ON(!base);
-
-	return ioread32(base);
-}
-
-void rsnd_write(struct rsnd_priv *priv,
-		struct rsnd_mod *mod,
-		enum rsnd_reg reg, u32 data)
-{
-	void __iomem *base = rsnd_gen_reg_get(priv, mod, reg);
-	struct device *dev = rsnd_priv_to_dev(priv);
-
-	BUG_ON(!base);
-
-	dev_dbg(dev, "w %p : %08x\n", base, data);
-
-	iowrite32(data, base);
-}
-
-void rsnd_bset(struct rsnd_priv *priv, struct rsnd_mod *mod,
-	       enum rsnd_reg reg, u32 mask, u32 data)
-{
-	void __iomem *base = rsnd_gen_reg_get(priv, mod, reg);
-	struct device *dev = rsnd_priv_to_dev(priv);
-	u32 val;
-
-	BUG_ON(!base);
-
-	val = ioread32(base);
-	val &= ~mask;
-	val |= data & mask;
-	iowrite32(val, base);
-
-	dev_dbg(dev, "s %p : %08x\n", base, val);
-}
-
 /*
  *	rsnd_mod functions
  */

commit 0a4d94c07ce782e645a8c0484d52221758b4c398
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jul 28 18:58:50 2013 -0700

    ASoC: rsnd: add common DMAEngine method
    
    R-Car Sound driver will support DMA transfer in the future,
    then, SSI/SRU/SRC will use it.
    Current R-Car can't use soc-dmaengine-pcm.c since its DMAEngine
    doesn't support dmaengine_prep_dma_cyclic(),
    and SSI needs double plane transfer (which needs special submit) on DMAC.
    This patch adds common DMAEngine method for it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 420d6df9c3d0..a35706028514 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -173,6 +173,138 @@ void rsnd_mod_init(struct rsnd_priv *priv,
 	INIT_LIST_HEAD(&mod->list);
 }
 
+/*
+ *	rsnd_dma functions
+ */
+static void rsnd_dma_continue(struct rsnd_dma *dma)
+{
+	/* push next A or B plane */
+	dma->submit_loop = 1;
+	schedule_work(&dma->work);
+}
+
+void rsnd_dma_start(struct rsnd_dma *dma)
+{
+	/* push both A and B plane*/
+	dma->submit_loop = 2;
+	schedule_work(&dma->work);
+}
+
+void rsnd_dma_stop(struct rsnd_dma *dma)
+{
+	dma->submit_loop = 0;
+	cancel_work_sync(&dma->work);
+	dmaengine_terminate_all(dma->chan);
+}
+
+static void rsnd_dma_complete(void *data)
+{
+	struct rsnd_dma *dma = (struct rsnd_dma *)data;
+	struct rsnd_priv *priv = dma->priv;
+	unsigned long flags;
+
+	rsnd_lock(priv, flags);
+
+	dma->complete(dma);
+
+	if (dma->submit_loop)
+		rsnd_dma_continue(dma);
+
+	rsnd_unlock(priv, flags);
+}
+
+static void rsnd_dma_do_work(struct work_struct *work)
+{
+	struct rsnd_dma *dma = container_of(work, struct rsnd_dma, work);
+	struct rsnd_priv *priv = dma->priv;
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct dma_async_tx_descriptor *desc;
+	dma_addr_t buf;
+	size_t len;
+	int i;
+
+	for (i = 0; i < dma->submit_loop; i++) {
+
+		if (dma->inquiry(dma, &buf, &len) < 0)
+			return;
+
+		desc = dmaengine_prep_slave_single(
+			dma->chan, buf, len, dma->dir,
+			DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+		if (!desc) {
+			dev_err(dev, "dmaengine_prep_slave_sg() fail\n");
+			return;
+		}
+
+		desc->callback		= rsnd_dma_complete;
+		desc->callback_param	= dma;
+
+		if (dmaengine_submit(desc) < 0) {
+			dev_err(dev, "dmaengine_submit() fail\n");
+			return;
+		}
+
+	}
+
+	dma_async_issue_pending(dma->chan);
+}
+
+int rsnd_dma_available(struct rsnd_dma *dma)
+{
+	return !!dma->chan;
+}
+
+static bool rsnd_dma_filter(struct dma_chan *chan, void *param)
+{
+	chan->private = param;
+
+	return true;
+}
+
+int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma,
+		  int is_play, int id,
+		  int (*inquiry)(struct rsnd_dma *dma,
+				  dma_addr_t *buf, int *len),
+		  int (*complete)(struct rsnd_dma *dma))
+{
+	struct device *dev = rsnd_priv_to_dev(priv);
+	dma_cap_mask_t mask;
+
+	if (dma->chan) {
+		dev_err(dev, "it already has dma channel\n");
+		return -EIO;
+	}
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	dma->slave.shdma_slave.slave_id = id;
+
+	dma->chan = dma_request_channel(mask, rsnd_dma_filter,
+					&dma->slave.shdma_slave);
+	if (!dma->chan) {
+		dev_err(dev, "can't get dma channel\n");
+		return -EIO;
+	}
+
+	dma->dir = is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+	dma->priv = priv;
+	dma->inquiry = inquiry;
+	dma->complete = complete;
+	INIT_WORK(&dma->work, rsnd_dma_do_work);
+
+	return 0;
+}
+
+void  rsnd_dma_quit(struct rsnd_priv *priv,
+		    struct rsnd_dma *dma)
+{
+	if (dma->chan)
+		dma_release_channel(dma->chan);
+
+	dma->chan = NULL;
+}
+
 /*
  *	rsnd_dai functions
  */

commit 4b4dab82340d969521f4f86108441cb597c8595d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jul 28 18:58:29 2013 -0700

    ASoC: rsnd: remove platform dai and add dai_id on platform setting
    
    Current rsnd driver is using struct rsnd_dai_platform_info
    so that indicate sound DAI information (playback/capture SSI ID).
    But, SSI settings were also required separately.
    Thus, platform settings was very un-understandable.
    This patch adds dai_id to SSI
    settings, and removed rsnd_dai_platform_info.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 9a5469d3f352..420d6df9c3d0 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -219,6 +219,16 @@ int rsnd_dai_disconnect(struct rsnd_mod *mod)
 	return 0;
 }
 
+int rsnd_dai_id(struct rsnd_priv *priv, struct rsnd_dai *rdai)
+{
+	int id = rdai - priv->rdai;
+
+	if ((id < 0) || (id >= rsnd_dai_nr(priv)))
+		return -EINVAL;
+
+	return id;
+}
+
 struct rsnd_dai *rsnd_dai_get(struct rsnd_priv *priv, int id)
 {
 	return priv->rdai + id;
@@ -315,9 +325,10 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	struct rsnd_priv *priv = snd_soc_dai_get_drvdata(dai);
 	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
 	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
-	struct rsnd_dai_platform_info *info = rsnd_dai_get_platform_info(rdai);
-	int ssi_id = rsnd_dai_is_play(rdai, io) ?	info->ssi_id_playback :
-							info->ssi_id_capture;
+	struct rsnd_mod *mod = rsnd_ssi_mod_get_frm_dai(priv,
+						rsnd_dai_id(priv, rdai),
+						rsnd_dai_is_play(rdai, io));
+	int ssi_id = rsnd_mod_id(mod);
 	int ret;
 	unsigned long flags;
 
@@ -439,10 +450,24 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 {
 	struct snd_soc_dai_driver *drv;
 	struct rsnd_dai *rdai;
+	struct rsnd_mod *pmod, *cmod;
 	struct device *dev = rsnd_priv_to_dev(priv);
-	struct rsnd_dai_platform_info *dai_info;
-	int dai_nr = info->dai_info_nr;
-	int i, pid, cid;
+	int dai_nr;
+	int i;
+
+	/* get max dai nr */
+	for (dai_nr = 0; dai_nr < 32; dai_nr++) {
+		pmod = rsnd_ssi_mod_get_frm_dai(priv, dai_nr, 1);
+		cmod = rsnd_ssi_mod_get_frm_dai(priv, dai_nr, 0);
+
+		if (!pmod && !cmod)
+			break;
+	}
+
+	if (!dai_nr) {
+		dev_err(dev, "no dai\n");
+		return -EIO;
+	}
 
 	drv  = devm_kzalloc(dev, sizeof(*drv)  * dai_nr, GFP_KERNEL);
 	rdai = devm_kzalloc(dev, sizeof(*rdai) * dai_nr, GFP_KERNEL);
@@ -452,10 +477,9 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 	}
 
 	for (i = 0; i < dai_nr; i++) {
-		dai_info = &info->dai_info[i];
 
-		pid = dai_info->ssi_id_playback;
-		cid = dai_info->ssi_id_capture;
+		pmod = rsnd_ssi_mod_get_frm_dai(priv, i, 1);
+		cmod = rsnd_ssi_mod_get_frm_dai(priv, i, 0);
 
 		/*
 		 *	init rsnd_dai
@@ -463,8 +487,6 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 		INIT_LIST_HEAD(&rdai[i].playback.head);
 		INIT_LIST_HEAD(&rdai[i].capture.head);
 
-		rdai[i].info = dai_info;
-
 		snprintf(rdai[i].name, RSND_DAI_NAME_SIZE, "rsnd-dai.%d", i);
 
 		/*
@@ -472,20 +494,22 @@ static int rsnd_dai_probe(struct platform_device *pdev,
 		 */
 		drv[i].name	= rdai[i].name;
 		drv[i].ops	= &rsnd_soc_dai_ops;
-		if (pid >= 0) {
+		if (pmod) {
 			drv[i].playback.rates		= RSND_RATES;
 			drv[i].playback.formats		= RSND_FMTS;
 			drv[i].playback.channels_min	= 2;
 			drv[i].playback.channels_max	= 2;
 		}
-		if (cid >= 0) {
+		if (cmod) {
 			drv[i].capture.rates		= RSND_RATES;
 			drv[i].capture.formats		= RSND_FMTS;
 			drv[i].capture.channels_min	= 2;
 			drv[i].capture.channels_max	= 2;
 		}
 
-		dev_dbg(dev, "%s (%d, %d) probed", rdai[i].name, pid, cid);
+		dev_dbg(dev, "%s (%s/%s)\n", rdai[i].name,
+			pmod ? "play"    : " -- ",
+			cmod ? "capture" : "  --   ");
 	}
 
 	priv->dai_nr	= dai_nr;
@@ -627,10 +651,6 @@ static int rsnd_probe(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
-	ret = rsnd_dai_probe(pdev, info, priv);
-	if (ret < 0)
-		return ret;
-
 	ret = rsnd_scu_probe(pdev, info, priv);
 	if (ret < 0)
 		return ret;
@@ -643,6 +663,10 @@ static int rsnd_probe(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
+	ret = rsnd_dai_probe(pdev, info, priv);
+	if (ret < 0)
+		return ret;
+
 	/*
 	 *	asoc register
 	 */

commit ae5c322303fff50b93d60e34c6563f1264a5941b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jul 21 21:36:57 2013 -0700

    ASoC: add Renesas R-Car SSI feature
    
    Renesas R-Car series sound circuit consists of SSI and its peripheral.
    But this peripheral circuit is different between
    R-Car Generation1 (E1/M1/H1) and Generation2 (E2/M2/H2)
    (Actually, there are many difference in Generation1 chips)
    
    As 1st protype, this patch adds SSI feature on this driver.
    But, it is PIO sound playback support only at this point.
    The DMA transfer, and capture feature will be supported in the future
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index e588d8a8ae40..9a5469d3f352 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -639,6 +639,10 @@ static int rsnd_probe(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
+	ret = rsnd_ssi_probe(pdev, info, priv);
+	if (ret < 0)
+		return ret;
+
 	/*
 	 *	asoc register
 	 */
@@ -677,6 +681,7 @@ static int rsnd_remove(struct platform_device *pdev)
 	/*
 	 *	remove each module
 	 */
+	rsnd_ssi_remove(pdev, priv);
 	rsnd_adg_remove(pdev, priv);
 	rsnd_scu_remove(pdev, priv);
 	rsnd_dai_remove(pdev, priv);

commit dfc9403b7c1f566bb099a12c58aee20589e390f1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jul 21 21:36:46 2013 -0700

    ASoC: add Renesas R-Car ADG feature
    
    Renesas R-Car series sound circuit consists of SSI and its peripheral.
    But this peripheral circuit is different between
    R-Car Generation1 (E1/M1/H1) and Generation2 (E2/M2/H2)
    (Actually, there are many difference in Generation1 chips)
    
    This patch adds ADG feature which controls sound clock
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 02d736bb4f54..e588d8a8ae40 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -635,6 +635,10 @@ static int rsnd_probe(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
+	ret = rsnd_adg_probe(pdev, info, priv);
+	if (ret < 0)
+		return ret;
+
 	/*
 	 *	asoc register
 	 */
@@ -673,6 +677,7 @@ static int rsnd_remove(struct platform_device *pdev)
 	/*
 	 *	remove each module
 	 */
+	rsnd_adg_remove(pdev, priv);
 	rsnd_scu_remove(pdev, priv);
 	rsnd_dai_remove(pdev, priv);
 	rsnd_gen_remove(pdev, priv);

commit 07539c1de82cdc0ecbe72b413762b2e920407227
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jul 21 21:36:35 2013 -0700

    ASoC: add Renesas R-Car SCU feature
    
    Renesas R-Car series sound circuit consists of SSI and its peripheral.
    But this peripheral circuit is different between
    R-Car Generation1 (E1/M1/H1) and Generation2 (E2/M2/H2)
    (Actually, there are many difference in Generation1 chips)
    
    This patch adds SCU feature on this driver.
    But, it defines SCU style only, does nothing at this point.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index bb8959f93a7d..02d736bb4f54 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -631,6 +631,10 @@ static int rsnd_probe(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
+	ret = rsnd_scu_probe(pdev, info, priv);
+	if (ret < 0)
+		return ret;
+
 	/*
 	 *	asoc register
 	 */
@@ -669,6 +673,7 @@ static int rsnd_remove(struct platform_device *pdev)
 	/*
 	 *	remove each module
 	 */
+	rsnd_scu_remove(pdev, priv);
 	rsnd_dai_remove(pdev, priv);
 	rsnd_gen_remove(pdev, priv);
 

commit 3337744ac41bee00b0068ad5f926dd9c27540809
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jul 21 21:36:21 2013 -0700

    ASoC: add Renesas R-Car Generation feature
    
    Renesas R-Car series sound circuit consists of SSI and its peripheral.
    But this peripheral circuit is different between
    R-Car Generation1 (E1/M1/H1) and Generation2 (E2/M2/H2)
    (Actually, there are many difference in Generation1 chips)
    
    The main difference between Gen1 and Gen2 are
    1) register offset, 2) data path
    
    In order to control Gen1/Gen2 by same method,
    this patch adds gen.c.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index a47fda2aa600..bb8959f93a7d 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -107,6 +107,50 @@
 	 priv->info->func(param))
 
 
+/*
+ *	basic function
+ */
+u32 rsnd_read(struct rsnd_priv *priv,
+	      struct rsnd_mod *mod, enum rsnd_reg reg)
+{
+	void __iomem *base = rsnd_gen_reg_get(priv, mod, reg);
+
+	BUG_ON(!base);
+
+	return ioread32(base);
+}
+
+void rsnd_write(struct rsnd_priv *priv,
+		struct rsnd_mod *mod,
+		enum rsnd_reg reg, u32 data)
+{
+	void __iomem *base = rsnd_gen_reg_get(priv, mod, reg);
+	struct device *dev = rsnd_priv_to_dev(priv);
+
+	BUG_ON(!base);
+
+	dev_dbg(dev, "w %p : %08x\n", base, data);
+
+	iowrite32(data, base);
+}
+
+void rsnd_bset(struct rsnd_priv *priv, struct rsnd_mod *mod,
+	       enum rsnd_reg reg, u32 mask, u32 data)
+{
+	void __iomem *base = rsnd_gen_reg_get(priv, mod, reg);
+	struct device *dev = rsnd_priv_to_dev(priv);
+	u32 val;
+
+	BUG_ON(!base);
+
+	val = ioread32(base);
+	val &= ~mask;
+	val |= data & mask;
+	iowrite32(val, base);
+
+	dev_dbg(dev, "s %p : %08x\n", base, val);
+}
+
 /*
  *	rsnd_mod functions
  */
@@ -289,6 +333,10 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (ret < 0)
 			goto dai_trigger_end;
 
+		ret = rsnd_gen_path_init(priv, rdai, io);
+		if (ret < 0)
+			goto dai_trigger_end;
+
 		ret = rsnd_dai_call(rdai, io, init);
 		if (ret < 0)
 			goto dai_trigger_end;
@@ -306,10 +354,13 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (ret < 0)
 			goto dai_trigger_end;
 
-		ret = rsnd_platform_call(priv, dai, stop, ssi_id);
+		ret = rsnd_gen_path_exit(priv, rdai, io);
 		if (ret < 0)
 			goto dai_trigger_end;
 
+		ret = rsnd_platform_call(priv, dai, stop, ssi_id);
+		if (ret < 0)
+			goto dai_trigger_end;
 		break;
 	default:
 		ret = -EINVAL;
@@ -572,6 +623,10 @@ static int rsnd_probe(struct platform_device *pdev)
 	/*
 	 *	init each module
 	 */
+	ret = rsnd_gen_probe(pdev, info, priv);
+	if (ret < 0)
+		return ret;
+
 	ret = rsnd_dai_probe(pdev, info, priv);
 	if (ret < 0)
 		return ret;
@@ -615,6 +670,7 @@ static int rsnd_remove(struct platform_device *pdev)
 	 *	remove each module
 	 */
 	rsnd_dai_remove(pdev, priv);
+	rsnd_gen_remove(pdev, priv);
 
 	return 0;
 }

commit cdaa3cdfb4a710545a53740b1780a683b043618a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jul 21 21:36:03 2013 -0700

    ASoC: add Renesas R-Car module feature
    
    Renesas R-Car series sound circuit consists of SSI and its peripheral.
    But this peripheral circuit is different between
    R-Car Generation1 (E1/M1/H1) and Generation2 (E2/M2/H2)
    (Actually, there are many difference in Generation1 chips)
    
    Gen1 series consists of SRU/SSI/ADG, and
    Gen2 series consists of SCU/SSIU/SSI/ADG.
    
    In order to control these by same method,
    these are treated as "mod" on this driver.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
index 13b5d50efd06..a47fda2aa600 100644
--- a/sound/soc/sh/rcar/core.c
+++ b/sound/soc/sh/rcar/core.c
@@ -107,9 +107,74 @@
 	 priv->info->func(param))
 
 
+/*
+ *	rsnd_mod functions
+ */
+char *rsnd_mod_name(struct rsnd_mod *mod)
+{
+	if (!mod || !mod->ops)
+		return "unknown";
+
+	return mod->ops->name;
+}
+
+void rsnd_mod_init(struct rsnd_priv *priv,
+		   struct rsnd_mod *mod,
+		   struct rsnd_mod_ops *ops,
+		   int id)
+{
+	mod->priv	= priv;
+	mod->id		= id;
+	mod->ops	= ops;
+	INIT_LIST_HEAD(&mod->list);
+}
+
 /*
  *	rsnd_dai functions
  */
+#define rsnd_dai_call(rdai, io, fn)			\
+({							\
+	struct rsnd_mod *mod, *n;			\
+	int ret = 0;					\
+	for_each_rsnd_mod(mod, n, io) {			\
+		ret = rsnd_mod_call(mod, fn, rdai, io);	\
+		if (ret < 0)				\
+			break;				\
+	}						\
+	ret;						\
+})
+
+int rsnd_dai_connect(struct rsnd_dai *rdai,
+		     struct rsnd_mod *mod,
+		     struct rsnd_dai_stream *io)
+{
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct device *dev = rsnd_priv_to_dev(priv);
+
+	if (!mod) {
+		dev_err(dev, "NULL mod\n");
+		return -EIO;
+	}
+
+	if (!list_empty(&mod->list)) {
+		dev_err(dev, "%s%d is not empty\n",
+			rsnd_mod_name(mod),
+			rsnd_mod_id(mod));
+		return -EIO;
+	}
+
+	list_add_tail(&mod->list, &io->head);
+
+	return 0;
+}
+
+int rsnd_dai_disconnect(struct rsnd_mod *mod)
+{
+	list_del_init(&mod->list);
+
+	return 0;
+}
+
 struct rsnd_dai *rsnd_dai_get(struct rsnd_priv *priv, int id)
 {
 	return priv->rdai + id;
@@ -224,8 +289,23 @@ static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (ret < 0)
 			goto dai_trigger_end;
 
+		ret = rsnd_dai_call(rdai, io, init);
+		if (ret < 0)
+			goto dai_trigger_end;
+
+		ret = rsnd_dai_call(rdai, io, start);
+		if (ret < 0)
+			goto dai_trigger_end;
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
+		ret = rsnd_dai_call(rdai, io, stop);
+		if (ret < 0)
+			goto dai_trigger_end;
+
+		ret = rsnd_dai_call(rdai, io, quit);
+		if (ret < 0)
+			goto dai_trigger_end;
+
 		ret = rsnd_platform_call(priv, dai, stop, ssi_id);
 		if (ret < 0)
 			goto dai_trigger_end;

commit 1536a968892aa9095aada4b6d2ed326432cd71c8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Jul 21 21:35:52 2013 -0700

    ASoC: add Renesas R-Car core feature
    
    Renesas R-Car series sound circuit consists of SSI and its peripheral.
    But this peripheral circuits are different between
    R-Car Generation1 (E1/M1/H1) and Generation2 (E2/M2/H2).
    (Actually, there are many difference in Generation1 chips)
    
    Basically, for the future, Renesas R-Car series will use
    Gen2 style sound circuit, but driver should care Gen1 also.
    The main differences between Gen1 and Gen2 peripheral
    are 1) register offset, 2) data path.
    
    This patch adds basic (core) feature for R-Car
    series sound driver as prototype
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c
new file mode 100644
index 000000000000..13b5d50efd06
--- /dev/null
+++ b/sound/soc/sh/rcar/core.c
@@ -0,0 +1,554 @@
+/*
+ * Renesas R-Car SRU/SCU/SSIU/SSI support
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+ *
+ * Based on fsi.c
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * Renesas R-Car sound device structure
+ *
+ * Gen1
+ *
+ * SRU		: Sound Routing Unit
+ *  - SRC	: Sampling Rate Converter
+ *  - CMD
+ *    - CTU	: Channel Count Conversion Unit
+ *    - MIX	: Mixer
+ *    - DVC	: Digital Volume and Mute Function
+ *  - SSI	: Serial Sound Interface
+ *
+ * Gen2
+ *
+ * SCU		: Sampling Rate Converter Unit
+ *  - SRC	: Sampling Rate Converter
+ *  - CMD
+ *   - CTU	: Channel Count Conversion Unit
+ *   - MIX	: Mixer
+ *   - DVC	: Digital Volume and Mute Function
+ * SSIU		: Serial Sound Interface Unit
+ *  - SSI	: Serial Sound Interface
+ */
+
+/*
+ *	driver data Image
+ *
+ * rsnd_priv
+ *   |
+ *   | ** this depends on Gen1/Gen2
+ *   |
+ *   +- gen
+ *   |
+ *   | ** these depend on data path
+ *   | ** gen and platform data control it
+ *   |
+ *   +- rdai[0]
+ *   |   |		 sru     ssiu      ssi
+ *   |   +- playback -> [mod] -> [mod] -> [mod] -> ...
+ *   |   |
+ *   |   |		 sru     ssiu      ssi
+ *   |   +- capture  -> [mod] -> [mod] -> [mod] -> ...
+ *   |
+ *   +- rdai[1]
+ *   |   |		 sru     ssiu      ssi
+ *   |   +- playback -> [mod] -> [mod] -> [mod] -> ...
+ *   |   |
+ *   |   |		 sru     ssiu      ssi
+ *   |   +- capture  -> [mod] -> [mod] -> [mod] -> ...
+ *   ...
+ *   |
+ *   | ** these control ssi
+ *   |
+ *   +- ssi
+ *   |  |
+ *   |  +- ssi[0]
+ *   |  +- ssi[1]
+ *   |  +- ssi[2]
+ *   |  ...
+ *   |
+ *   | ** these control scu
+ *   |
+ *   +- scu
+ *      |
+ *      +- scu[0]
+ *      +- scu[1]
+ *      +- scu[2]
+ *      ...
+ *
+ *
+ * for_each_rsnd_dai(xx, priv, xx)
+ *  rdai[0] => rdai[1] => rdai[2] => ...
+ *
+ * for_each_rsnd_mod(xx, rdai, xx)
+ *  [mod] => [mod] => [mod] => ...
+ *
+ * rsnd_dai_call(xxx, fn )
+ *  [mod]->fn() -> [mod]->fn() -> [mod]->fn()...
+ *
+ */
+#include <linux/pm_runtime.h>
+#include "rsnd.h"
+
+#define RSND_RATES SNDRV_PCM_RATE_8000_96000
+#define RSND_FMTS (SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE)
+
+/*
+ *	rsnd_platform functions
+ */
+#define rsnd_platform_call(priv, dai, func, param...)	\
+	(!(priv->info->func) ? -ENODEV :		\
+	 priv->info->func(param))
+
+
+/*
+ *	rsnd_dai functions
+ */
+struct rsnd_dai *rsnd_dai_get(struct rsnd_priv *priv, int id)
+{
+	return priv->rdai + id;
+}
+
+static struct rsnd_dai *rsnd_dai_to_rdai(struct snd_soc_dai *dai)
+{
+	struct rsnd_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+	return rsnd_dai_get(priv, dai->id);
+}
+
+int rsnd_dai_is_play(struct rsnd_dai *rdai, struct rsnd_dai_stream *io)
+{
+	return &rdai->playback == io;
+}
+
+/*
+ *	rsnd_soc_dai functions
+ */
+int rsnd_dai_pointer_offset(struct rsnd_dai_stream *io, int additional)
+{
+	struct snd_pcm_substream *substream = io->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int pos = io->byte_pos + additional;
+
+	pos %= (runtime->periods * io->byte_per_period);
+
+	return pos;
+}
+
+void rsnd_dai_pointer_update(struct rsnd_dai_stream *io, int byte)
+{
+	io->byte_pos += byte;
+
+	if (io->byte_pos >= io->next_period_byte) {
+		struct snd_pcm_substream *substream = io->substream;
+		struct snd_pcm_runtime *runtime = substream->runtime;
+
+		io->period_pos++;
+		io->next_period_byte += io->byte_per_period;
+
+		if (io->period_pos >= runtime->periods) {
+			io->byte_pos = 0;
+			io->period_pos = 0;
+			io->next_period_byte = io->byte_per_period;
+		}
+
+		snd_pcm_period_elapsed(substream);
+	}
+}
+
+static int rsnd_dai_stream_init(struct rsnd_dai_stream *io,
+				struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (!list_empty(&io->head))
+		return -EIO;
+
+	INIT_LIST_HEAD(&io->head);
+	io->substream		= substream;
+	io->byte_pos		= 0;
+	io->period_pos		= 0;
+	io->byte_per_period	= runtime->period_size *
+				  runtime->channels *
+				  samples_to_bytes(runtime, 1);
+	io->next_period_byte	= io->byte_per_period;
+
+	return 0;
+}
+
+static
+struct snd_soc_dai *rsnd_substream_to_dai(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	return  rtd->cpu_dai;
+}
+
+static
+struct rsnd_dai_stream *rsnd_rdai_to_io(struct rsnd_dai *rdai,
+					struct snd_pcm_substream *substream)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return &rdai->playback;
+	else
+		return &rdai->capture;
+}
+
+static int rsnd_soc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
+			    struct snd_soc_dai *dai)
+{
+	struct rsnd_priv *priv = snd_soc_dai_get_drvdata(dai);
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+	struct rsnd_dai_platform_info *info = rsnd_dai_get_platform_info(rdai);
+	int ssi_id = rsnd_dai_is_play(rdai, io) ?	info->ssi_id_playback :
+							info->ssi_id_capture;
+	int ret;
+	unsigned long flags;
+
+	rsnd_lock(priv, flags);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		ret = rsnd_dai_stream_init(io, substream);
+		if (ret < 0)
+			goto dai_trigger_end;
+
+		ret = rsnd_platform_call(priv, dai, start, ssi_id);
+		if (ret < 0)
+			goto dai_trigger_end;
+
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		ret = rsnd_platform_call(priv, dai, stop, ssi_id);
+		if (ret < 0)
+			goto dai_trigger_end;
+
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+dai_trigger_end:
+	rsnd_unlock(priv, flags);
+
+	return ret;
+}
+
+static int rsnd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		rdai->clk_master = 1;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		rdai->clk_master = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* set clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_IF:
+		rdai->bit_clk_inv = 0;
+		rdai->frm_clk_inv = 1;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		rdai->bit_clk_inv = 1;
+		rdai->frm_clk_inv = 0;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		rdai->bit_clk_inv = 1;
+		rdai->frm_clk_inv = 1;
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+	default:
+		rdai->bit_clk_inv = 0;
+		rdai->frm_clk_inv = 0;
+		break;
+	}
+
+	/* set format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		rdai->sys_delay = 0;
+		rdai->data_alignment = 0;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		rdai->sys_delay = 1;
+		rdai->data_alignment = 0;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		rdai->sys_delay = 1;
+		rdai->data_alignment = 1;
+		break;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops rsnd_soc_dai_ops = {
+	.trigger	= rsnd_soc_dai_trigger,
+	.set_fmt	= rsnd_soc_dai_set_fmt,
+};
+
+static int rsnd_dai_probe(struct platform_device *pdev,
+			  struct rcar_snd_info *info,
+			  struct rsnd_priv *priv)
+{
+	struct snd_soc_dai_driver *drv;
+	struct rsnd_dai *rdai;
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_dai_platform_info *dai_info;
+	int dai_nr = info->dai_info_nr;
+	int i, pid, cid;
+
+	drv  = devm_kzalloc(dev, sizeof(*drv)  * dai_nr, GFP_KERNEL);
+	rdai = devm_kzalloc(dev, sizeof(*rdai) * dai_nr, GFP_KERNEL);
+	if (!drv || !rdai) {
+		dev_err(dev, "dai allocate failed\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < dai_nr; i++) {
+		dai_info = &info->dai_info[i];
+
+		pid = dai_info->ssi_id_playback;
+		cid = dai_info->ssi_id_capture;
+
+		/*
+		 *	init rsnd_dai
+		 */
+		INIT_LIST_HEAD(&rdai[i].playback.head);
+		INIT_LIST_HEAD(&rdai[i].capture.head);
+
+		rdai[i].info = dai_info;
+
+		snprintf(rdai[i].name, RSND_DAI_NAME_SIZE, "rsnd-dai.%d", i);
+
+		/*
+		 *	init snd_soc_dai_driver
+		 */
+		drv[i].name	= rdai[i].name;
+		drv[i].ops	= &rsnd_soc_dai_ops;
+		if (pid >= 0) {
+			drv[i].playback.rates		= RSND_RATES;
+			drv[i].playback.formats		= RSND_FMTS;
+			drv[i].playback.channels_min	= 2;
+			drv[i].playback.channels_max	= 2;
+		}
+		if (cid >= 0) {
+			drv[i].capture.rates		= RSND_RATES;
+			drv[i].capture.formats		= RSND_FMTS;
+			drv[i].capture.channels_min	= 2;
+			drv[i].capture.channels_max	= 2;
+		}
+
+		dev_dbg(dev, "%s (%d, %d) probed", rdai[i].name, pid, cid);
+	}
+
+	priv->dai_nr	= dai_nr;
+	priv->daidrv	= drv;
+	priv->rdai	= rdai;
+
+	return 0;
+}
+
+static void rsnd_dai_remove(struct platform_device *pdev,
+			  struct rsnd_priv *priv)
+{
+}
+
+/*
+ *		pcm ops
+ */
+static struct snd_pcm_hardware rsnd_pcm_hardware = {
+	.info =		SNDRV_PCM_INFO_INTERLEAVED	|
+			SNDRV_PCM_INFO_MMAP		|
+			SNDRV_PCM_INFO_MMAP_VALID	|
+			SNDRV_PCM_INFO_PAUSE,
+	.formats		= RSND_FMTS,
+	.rates			= RSND_RATES,
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 64 * 1024,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8192,
+	.periods_min		= 1,
+	.periods_max		= 32,
+	.fifo_size		= 256,
+};
+
+static int rsnd_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret = 0;
+
+	snd_soc_set_runtime_hwparams(substream, &rsnd_pcm_hardware);
+
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+
+	return ret;
+}
+
+static int rsnd_hw_params(struct snd_pcm_substream *substream,
+			 struct snd_pcm_hw_params *hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+static snd_pcm_uframes_t rsnd_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_dai *dai = rsnd_substream_to_dai(substream);
+	struct rsnd_dai *rdai = rsnd_dai_to_rdai(dai);
+	struct rsnd_dai_stream *io = rsnd_rdai_to_io(rdai, substream);
+
+	return bytes_to_frames(runtime, io->byte_pos);
+}
+
+static struct snd_pcm_ops rsnd_pcm_ops = {
+	.open		= rsnd_pcm_open,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= rsnd_hw_params,
+	.hw_free	= snd_pcm_lib_free_pages,
+	.pointer	= rsnd_pointer,
+};
+
+/*
+ *		snd_soc_platform
+ */
+
+#define PREALLOC_BUFFER		(32 * 1024)
+#define PREALLOC_BUFFER_MAX	(32 * 1024)
+
+static int rsnd_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	return snd_pcm_lib_preallocate_pages_for_all(
+		rtd->pcm,
+		SNDRV_DMA_TYPE_DEV,
+		rtd->card->snd_card->dev,
+		PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
+}
+
+static void rsnd_pcm_free(struct snd_pcm *pcm)
+{
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static struct snd_soc_platform_driver rsnd_soc_platform = {
+	.ops		= &rsnd_pcm_ops,
+	.pcm_new	= rsnd_pcm_new,
+	.pcm_free	= rsnd_pcm_free,
+};
+
+static const struct snd_soc_component_driver rsnd_soc_component = {
+	.name		= "rsnd",
+};
+
+/*
+ *	rsnd probe
+ */
+static int rsnd_probe(struct platform_device *pdev)
+{
+	struct rcar_snd_info *info;
+	struct rsnd_priv *priv;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	info = pdev->dev.platform_data;
+	if (!info) {
+		dev_err(dev, "driver needs R-Car sound information\n");
+		return -ENODEV;
+	}
+
+	/*
+	 *	init priv data
+	 */
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(dev, "priv allocate failed\n");
+		return -ENODEV;
+	}
+
+	priv->dev	= dev;
+	priv->info	= info;
+	spin_lock_init(&priv->lock);
+
+	/*
+	 *	init each module
+	 */
+	ret = rsnd_dai_probe(pdev, info, priv);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 *	asoc register
+	 */
+	ret = snd_soc_register_platform(dev, &rsnd_soc_platform);
+	if (ret < 0) {
+		dev_err(dev, "cannot snd soc register\n");
+		return ret;
+	}
+
+	ret = snd_soc_register_component(dev, &rsnd_soc_component,
+					 priv->daidrv, rsnd_dai_nr(priv));
+	if (ret < 0) {
+		dev_err(dev, "cannot snd dai register\n");
+		goto exit_snd_soc;
+	}
+
+	dev_set_drvdata(dev, priv);
+
+	pm_runtime_enable(dev);
+
+	dev_info(dev, "probed\n");
+	return ret;
+
+exit_snd_soc:
+	snd_soc_unregister_platform(dev);
+
+	return ret;
+}
+
+static int rsnd_remove(struct platform_device *pdev)
+{
+	struct rsnd_priv *priv = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	/*
+	 *	remove each module
+	 */
+	rsnd_dai_remove(pdev, priv);
+
+	return 0;
+}
+
+static struct platform_driver rsnd_driver = {
+	.driver	= {
+		.name	= "rcar_sound",
+	},
+	.probe		= rsnd_probe,
+	.remove		= rsnd_remove,
+};
+module_platform_driver(rsnd_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Renesas R-Car audio driver");
+MODULE_AUTHOR("Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>");
+MODULE_ALIAS("platform:rcar-pcm-audio");
