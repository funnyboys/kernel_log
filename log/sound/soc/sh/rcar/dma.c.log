commit 992fd39a349ac62044d9e20d17d309c2cf0f5c27
Merge: 18dd66ea8446 9508ef5a980f
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 6 16:29:34 2019 +0000

    Merge branch 'for-5.4' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-5.5

commit d10be65f87fc9d98ad3cbdc406e86745fe8c59e2
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Tue Oct 22 20:54:29 2019 +0200

    ASoC: rsnd: dma: fix SSI9 4/5/6/7 busif dma address
    
    Currently each SSI unit's busif dma address is calculated by
    following calculation formula:
    0xec540000 + 0x1000 * id + busif / 4 * 0xA000 + busif % 4 * 0x400
    
    But according to R-Car3 HW manual 41.1.4 Register Configuration,
    ssi9 4/5/6/7 busif data register address
    (SSI9_4_BUSIF/SSI9_5_BUSIF/SSI9_6_BUSIF/SSI9_7_BUSIF)
    are out of this rule.
    
    This patch updates the calculation formula to correct
    ssi9 4/5/6/7 busif data register address.
    
    Fixes: 5e45a6fab3b9 ("ASoc: rsnd: dma: Calculate dma address with consider of BUSIF")
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    [erosca: minor improvements in commit description]
    Cc: Andrew Gabbasov <andrew_gabbasov@mentor.com>
    Cc: stable@vger.kernel.org # v4.20+
    Signed-off-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/20191022185429.12769-1-erosca@de.adit-jv.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 0324a5c39619..28f65eba2bb4 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -508,10 +508,10 @@ static struct rsnd_mod_ops rsnd_dmapp_ops = {
 #define RDMA_SSI_I_N(addr, i)	(addr ##_reg - 0x00300000 + (0x40 * i) + 0x8)
 #define RDMA_SSI_O_N(addr, i)	(addr ##_reg - 0x00300000 + (0x40 * i) + 0xc)
 
-#define RDMA_SSIU_I_N(addr, i, j) (addr ##_reg - 0x00441000 + (0x1000 * (i)) + (((j) / 4) * 0xA000) + (((j) % 4) * 0x400))
+#define RDMA_SSIU_I_N(addr, i, j) (addr ##_reg - 0x00441000 + (0x1000 * (i)) + (((j) / 4) * 0xA000) + (((j) % 4) * 0x400) - (0x4000 * ((i) / 9) * ((j) / 4)))
 #define RDMA_SSIU_O_N(addr, i, j) RDMA_SSIU_I_N(addr, i, j)
 
-#define RDMA_SSIU_I_P(addr, i, j) (addr ##_reg - 0x00141000 + (0x1000 * (i)) + (((j) / 4) * 0xA000) + (((j) % 4) * 0x400))
+#define RDMA_SSIU_I_P(addr, i, j) (addr ##_reg - 0x00141000 + (0x1000 * (i)) + (((j) / 4) * 0xA000) + (((j) % 4) * 0x400) - (0x4000 * ((i) / 9) * ((j) / 4)))
 #define RDMA_SSIU_O_P(addr, i, j) RDMA_SSIU_I_P(addr, i, j)
 
 #define RDMA_SRC_I_N(addr, i)	(addr ##_reg - 0x00500000 + (0x400 * i))

commit d4d9360bf702890b5d3b1b62d8619a2690dd3278
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Tue Oct 22 20:55:18 2019 +0200

    ASoC: rsnd: dma: set bus width to data width for monaural data
    
    According to R-Car3 HW manual 40.3.3 (Data Format on Audio Local Bus),
    in case of monaural data writing or reading through Audio-DMAC,
    it's always in Left Justified format, so both src and dst
    DMA Bus width should be equal to physical data width.
    
    Therefore set src and dst's DMA bus width to:
     - [monaural case] data width
     - [non-monaural case] 32bits (as prior applying the patch)
    
    Cc: Andrew Gabbasov <andrew_gabbasov@mentor.com>
    Cc: Timo Wischer <twischer@de.adit-jv.com>
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Link: https://lore.kernel.org/r/20191022185518.12838-1-erosca@de.adit-jv.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 0324a5c39619..bcb6d5960661 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -165,14 +165,40 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
 	struct dma_slave_config cfg = {};
+	enum dma_slave_buswidth buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	int is_play = rsnd_io_is_play(io);
 	int ret;
 
+	/*
+	 * in case of monaural data writing or reading through Audio-DMAC
+	 * data is always in Left Justified format, so both src and dst
+	 * DMA Bus width need to be set equal to physical data width.
+	 */
+	if (rsnd_runtime_channel_original(io) == 1) {
+		struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+		int bits = snd_pcm_format_physical_width(runtime->format);
+
+		switch (bits) {
+		case 8:
+			buswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;
+			break;
+		case 16:
+			buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+			break;
+		case 32:
+			buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
+			break;
+		default:
+			dev_err(dev, "invalid format width %d\n", bits);
+			return -EINVAL;
+		}
+	}
+
 	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
 	cfg.src_addr	= dma->src_addr;
 	cfg.dst_addr	= dma->dst_addr;
-	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	cfg.src_addr_width = buswidth;
+	cfg.dst_addr_width = buswidth;
 
 	dev_dbg(dev, "%s %pad -> %pad\n",
 		rsnd_mod_name(mod),

commit 4e7788fb8018afbb2e34e9d59b59baea30f5b045
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 6 05:21:08 2018 +0000

    ASoC: rsnd: add SSIU BUSIF support
    
    Gen2 has BUSIF0-3, Gen3 has BUSIF0-7 on some SSIU.
    Current driver is assuming it is using BUSIF0 as default.
    Thus, SSI is attaching SSIU (with BUSIF0) by using rsnd_ssiu_attach().
    But, TDM split mode also needs other BUSIF to use it.
    This patch adds missing SSIU BUSIFx support.
    
    BUSIF is handled by SSIU instead of SSI anymore.
    Thus, its settings no longer needed on SSI node on DT.
    This patch removes its settings from Document, but driver is still
    keeping compatibility. Thus, old DT style is still working.
    But, to avoid confusing, it doesn't indicate old compatibility things on
    Document. New SoC should have SSIU on DT from this patch.
    
    1) old style DT is still supported (= no rcar_sound,ssiu node on DT)
    2) If ssiu is not indicated on playback/capture,
       BUSIF0 will be used as default
            playback = <&ssi3>; /* ssiu30 will be selected */
    3) you can select own ssiu
            playback = <&ssi32 &ssi3>; /* ssiu32 will be selected */
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 5daa6c932fce..0324a5c39619 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -218,7 +218,7 @@ struct dma_chan *rsnd_dma_request_channel(struct device_node *of_node,
 	int i = 0;
 
 	for_each_child_of_node(of_node, np) {
-		if (i == rsnd_mod_id(mod) && (!chan))
+		if (i == rsnd_mod_id_raw(mod) && (!chan))
 			chan = of_dma_request_slave_channel(np, name);
 		i++;
 	}
@@ -344,14 +344,16 @@ static u32 rsnd_dmapp_get_id(struct rsnd_dai_stream *io,
 			     struct rsnd_mod *mod)
 {
 	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
+	struct rsnd_mod *ssiu = rsnd_io_to_mod_ssiu(io);
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
 	const u8 *entry = NULL;
 	int id = 255;
 	int size = 0;
 
-	if (mod == ssi) {
-		int busif = rsnd_ssi_get_busif(io);
+	if ((mod == ssi) ||
+	    (mod == ssiu)) {
+		int busif = rsnd_mod_id_sub(ssiu);
 
 		entry = gen2_id_table_ssiu;
 		size = ARRAY_SIZE(gen2_id_table_ssiu);
@@ -530,13 +532,14 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 	struct device *dev = rsnd_priv_to_dev(priv);
 	phys_addr_t ssi_reg = rsnd_gen_get_phy_addr(priv, RSND_GEN2_SSI);
 	phys_addr_t src_reg = rsnd_gen_get_phy_addr(priv, RSND_GEN2_SCU);
-	int is_ssi = !!(rsnd_io_to_mod_ssi(io) == mod);
+	int is_ssi = !!(rsnd_io_to_mod_ssi(io) == mod) ||
+		     !!(rsnd_io_to_mod_ssiu(io) == mod);
 	int use_src = !!rsnd_io_to_mod_src(io);
 	int use_cmd = !!rsnd_io_to_mod_dvc(io) ||
 		      !!rsnd_io_to_mod_mix(io) ||
 		      !!rsnd_io_to_mod_ctu(io);
 	int id = rsnd_mod_id(mod);
-	int busif = rsnd_ssi_get_busif(io);
+	int busif = rsnd_mod_id_sub(rsnd_io_to_mod_ssiu(io));
 	struct dma_addr {
 		dma_addr_t out_addr;
 		dma_addr_t in_addr;
@@ -620,7 +623,7 @@ static void rsnd_dma_of_path(struct rsnd_mod *this,
 			     struct rsnd_mod **mod_from,
 			     struct rsnd_mod **mod_to)
 {
-	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
+	struct rsnd_mod *ssi;
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *ctu = rsnd_io_to_mod_ctu(io);
 	struct rsnd_mod *mix = rsnd_io_to_mod_mix(io);
@@ -631,6 +634,28 @@ static void rsnd_dma_of_path(struct rsnd_mod *this,
 	struct device *dev = rsnd_priv_to_dev(priv);
 	int nr, i, idx;
 
+	/*
+	 * It should use "rcar_sound,ssiu" on DT.
+	 * But, we need to keep compatibility for old version.
+	 *
+	 * If it has "rcar_sound.ssiu", it will be used.
+	 * If not, "rcar_sound.ssi" will be used.
+	 * see
+	 *	rsnd_ssiu_dma_req()
+	 *	rsnd_ssi_dma_req()
+	 */
+	if (rsnd_ssiu_of_node(priv)) {
+		struct rsnd_mod *ssiu = rsnd_io_to_mod_ssiu(io);
+
+		/* use SSIU */
+		ssi = ssiu;
+		if (this == rsnd_io_to_mod_ssi(io))
+			this = ssiu;
+	} else {
+		/* keep compatible, use SSI */
+		ssi = rsnd_io_to_mod_ssi(io);
+	}
+
 	if (!ssi)
 		return;
 

commit c0ea089dbad47a41ae30ad290766d7a6571c9802
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 30 07:47:50 2018 +0000

    ASoC: rsnd: rsnd_mod_name() handles both name and ID
    
    Current rsnd driver is using "%s[%d]" for mod name and ID,
    but, this ID portion might confusable.
    For example currently, CTU ID is 0 to 7, but using 00 to 13
    (= 00, 01, 02, 03, 10, 11, 12, 13) is very best matching to datasheet.
    
    In the future, we will support BUSIFn, but it will be more complicated
    numbering. To avoid future confusable code, this patch modify
    rsnd_mod_name() to return understandable name.
    
    To avoid using pointless memory, it uses static char and snprintf,
    thus, rsnd_mod_name() user should use it immediately, and shouldn't keep
    its pointer.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index e5c30eec1190..5daa6c932fce 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -174,8 +174,8 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
-	dev_dbg(dev, "%s[%d] %pad -> %pad\n",
-		rsnd_mod_name(mod), rsnd_mod_id(mod),
+	dev_dbg(dev, "%s %pad -> %pad\n",
+		rsnd_mod_name(mod),
 		&cfg.src_addr, &cfg.dst_addr);
 
 	ret = dmaengine_slave_config(dmaen->chan, &cfg);
@@ -369,8 +369,7 @@ static u32 rsnd_dmapp_get_id(struct rsnd_dai_stream *io,
 	if ((!entry) || (size <= id)) {
 		struct device *dev = rsnd_priv_to_dev(rsnd_io_to_priv(io));
 
-		dev_err(dev, "unknown connection (%s[%d])\n",
-			rsnd_mod_name(mod), rsnd_mod_id(mod));
+		dev_err(dev, "unknown connection (%s)\n", rsnd_mod_name(mod));
 
 		/* use non-prohibited SRS number as error */
 		return 0x00; /* SSI00 */
@@ -692,12 +691,10 @@ static void rsnd_dma_of_path(struct rsnd_mod *this,
 		*mod_to		= mod[1];
 	}
 
-	dev_dbg(dev, "module connection (this is %s[%d])\n",
-		rsnd_mod_name(this), rsnd_mod_id(this));
+	dev_dbg(dev, "module connection (this is %s)\n", rsnd_mod_name(this));
 	for (i = 0; i <= idx; i++) {
-		dev_dbg(dev, "  %s[%d]%s\n",
+		dev_dbg(dev, "  %s%s\n",
 			rsnd_mod_name(mod[i] ? mod[i] : &mem),
-			rsnd_mod_id  (mod[i] ? mod[i] : &mem),
 			(mod[i] == *mod_from) ? " from" :
 			(mod[i] == *mod_to)   ? " to" : "");
 	}
@@ -762,12 +759,10 @@ static int rsnd_dma_alloc(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 	if (ret < 0)
 		return ret;
 
-	dev_dbg(dev, "%s[%d] %s[%d] -> %s[%d]\n",
-		rsnd_mod_name(*dma_mod), rsnd_mod_id(*dma_mod),
+	dev_dbg(dev, "%s %s -> %s\n",
+		rsnd_mod_name(*dma_mod),
 		rsnd_mod_name(mod_from ? mod_from : &mem),
-		rsnd_mod_id  (mod_from ? mod_from : &mem),
-		rsnd_mod_name(mod_to   ? mod_to   : &mem),
-		rsnd_mod_id  (mod_to   ? mod_to   : &mem));
+		rsnd_mod_name(mod_to   ? mod_to   : &mem));
 
 	ret = attach(io, dma, mod_from, mod_to);
 	if (ret < 0)

commit 7e7fe06de376e9874f4399dac81d65ea9b0a9507
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 30 07:46:05 2018 +0000

    ASoC: rsnd: move .get_status under rsnd_mod_ops
    
    Each mod needs to have .get_status, but current driver is handling it
    under rsnd_mod, instead of rsnd_mod_ops.
    It is not any make sence. This patch moves it to rsnd_mod_ops, and
    tidyup its parameter order to align to other callback functions.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 6d1947515dc8..e5c30eec1190 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -289,12 +289,13 @@ static int rsnd_dmaen_pointer(struct rsnd_mod *mod,
 }
 
 static struct rsnd_mod_ops rsnd_dmaen_ops = {
-	.name	= "audmac",
-	.prepare = rsnd_dmaen_prepare,
-	.cleanup = rsnd_dmaen_cleanup,
-	.start	= rsnd_dmaen_start,
-	.stop	= rsnd_dmaen_stop,
-	.pointer= rsnd_dmaen_pointer,
+	.name		= "audmac",
+	.prepare	= rsnd_dmaen_prepare,
+	.cleanup	= rsnd_dmaen_cleanup,
+	.start		= rsnd_dmaen_start,
+	.stop		= rsnd_dmaen_stop,
+	.pointer	= rsnd_dmaen_pointer,
+	.get_status	= rsnd_mod_get_status,
 };
 
 /*
@@ -477,10 +478,11 @@ static int rsnd_dmapp_attach(struct rsnd_dai_stream *io,
 }
 
 static struct rsnd_mod_ops rsnd_dmapp_ops = {
-	.name	= "audmac-pp",
-	.start	= rsnd_dmapp_start,
-	.stop	= rsnd_dmapp_stop,
-	.quit	= rsnd_dmapp_stop,
+	.name		= "audmac-pp",
+	.start		= rsnd_dmapp_start,
+	.stop		= rsnd_dmapp_stop,
+	.quit		= rsnd_dmapp_stop,
+	.get_status	= rsnd_mod_get_status,
 };
 
 /*
@@ -756,7 +758,7 @@ static int rsnd_dma_alloc(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 	*dma_mod = rsnd_mod_get(dma);
 
 	ret = rsnd_mod_init(priv, *dma_mod, ops, NULL,
-			    rsnd_mod_get_status, type, dma_id);
+			    type, dma_id);
 	if (ret < 0)
 		return ret;
 
@@ -823,5 +825,5 @@ int rsnd_dma_probe(struct rsnd_priv *priv)
 	priv->dma = dmac;
 
 	/* dummy mem mod for debug */
-	return rsnd_mod_init(NULL, &mem, &mem_ops, NULL, NULL, 0, 0);
+	return rsnd_mod_init(NULL, &mem, &mem_ops, NULL, 0, 0);
 }

commit 624d1a7cd8991e33dad96ab4629a52c412540e65
Author: Dmytro Prokopchuk <dmytro.prokopchuk@globallogic.com>
Date:   Fri Sep 21 04:59:59 2018 +0000

    ASoC: rsnd: fixup SSI clock during suspend/resume modes
    
    Prepare <-> Cleanup functions pair has balanced calls.
    But in case of suspend mode no call to rsnd_soc_dai_shutdown()
    function, so cleanup isn't called. OTOH during resume mode
    function rsnd_soc_dai_prepare() is called, but calling
    rsnd_ssi_prepare() is skipped (rsnd_status_update() returns zero,
    bacause was not cleanup before).
    We need to call rsnd_ssi_prepare(), because it enables SSI clocks
    by calling rsnd_ssi_master_clk_start().
    
    This patch allows to call prepare/cleanup functions always.
    
    Signed-off-by: Dmytro Prokopchuk <dmytro.prokopchuk@globallogic.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    [kuninori: adjusted to upstream]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 0bbc4b0ea2c6..6d1947515dc8 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -134,10 +134,9 @@ static int rsnd_dmaen_prepare(struct rsnd_mod *mod,
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	struct device *dev = rsnd_priv_to_dev(priv);
 
-	if (dmaen->chan) {
-		dev_err(dev, "it already has dma channel\n");
-		return -EIO;
-	}
+	/* maybe suspended */
+	if (dmaen->chan)
+		return 0;
 
 	/*
 	 * DMAEngine request uses mutex lock.

commit 54a3da1c105ca91c4d32f25c3d9c57a61e9a3467
Merge: 1c8bc7b3de5e 90a3b7f8aba3
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Sep 10 18:55:12 2018 +0100

    Merge branch 'asoc-4.19' into asoc-4.20 Cirrus conflict

commit dabdbe3ae0cb9a67872fa4ac80ffdef61391f645
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 6 03:22:01 2018 +0000

    ASoC: rsnd: don't use %p for dev_dbg()
    
    rsnd driver sometimes want to know which address is used when debugging.
    But it will indicate "(____ptrval____)" if it used "%p" on dev_dbg().
    Let's use "%pa" or "%px" for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index f99c1ab3b0bd..c19342d18998 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -393,7 +393,7 @@ static void rsnd_dmapp_write(struct rsnd_dma *dma, u32 data, u32 reg)
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct device *dev = rsnd_priv_to_dev(priv);
 
-	dev_dbg(dev, "w %p : %08x\n", rsnd_dmapp_addr(dmac, dma, reg), data);
+	dev_dbg(dev, "w 0x%px : %08x\n", rsnd_dmapp_addr(dmac, dma, reg), data);
 
 	iowrite32(data, rsnd_dmapp_addr(dmac, dma, reg));
 }

commit 6c92d5a2744e27619a8fcc9d74b91ee9f1cdebd1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 6 03:21:47 2018 +0000

    ASoC: rsnd: don't fallback to PIO mode when -EPROBE_DEFER
    
    Current rsnd driver will fallback to PIO mode if it can't get DMA
    handler. But, DMA might return -EPROBE_DEFER when probe timing.
    This driver always fallback to PIO mode especially from
    commit ac6bbf0cdf4206c ("iommu: Remove IOMMU_OF_DECLARE") because
    of this reason.
    
    The DMA driver will be probed later, but sound driver might be
    probed as PIO mode in such case. This patch fixup this issue.
    Then, -EPROBE_DEFER is not error. Thus, let's don't indicate error
    message in such case.
    And it needs to call rsnd_adg_remove() individually if probe failed,
    because it registers clk which should be unregister.
    
    Maybe PIO fallback feature itself is not needed,
    but let's keep it so far.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index fe63ef8600d0..d65ea7bc4dac 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -241,6 +241,10 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 	/* try to get DMAEngine channel */
 	chan = rsnd_dmaen_request_channel(io, mod_from, mod_to);
 	if (IS_ERR_OR_NULL(chan)) {
+		/* Let's follow when -EPROBE_DEFER case */
+		if (PTR_ERR(chan) == -EPROBE_DEFER)
+			return PTR_ERR(chan);
+
 		/*
 		 * DMA failed. try to PIO mode
 		 * see

commit 6ab6a2474e0dce02f71e92adb9778a168a8931f4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Sep 3 07:09:17 2018 +0000

    ASoC: rsnd: merge .nolock_start and .prepare
    
    Main purpose of .nolock_start is we need to call
    some function without spinlock.
    OTOH we have .prepare which main purpose is
    called under atomic context.
    Then, it is called without spinlock.
    
    In summary, our main callback init/quit, and start/stop
    are called under "atomic context and with spinlock".
    And some function need to be called under
    "non-atomic context or without spinlock".
    Let's merge .nolock_start and prepare to be more clear code.
    Then, let's rename nolock_stop to cleanup
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index d3b1a4ae876a..f99c1ab3b0bd 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -106,9 +106,9 @@ static int rsnd_dmaen_stop(struct rsnd_mod *mod,
 	return 0;
 }
 
-static int rsnd_dmaen_nolock_stop(struct rsnd_mod *mod,
-				   struct rsnd_dai_stream *io,
-				   struct rsnd_priv *priv)
+static int rsnd_dmaen_cleanup(struct rsnd_mod *mod,
+			      struct rsnd_dai_stream *io,
+			      struct rsnd_priv *priv)
 {
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
@@ -116,7 +116,7 @@ static int rsnd_dmaen_nolock_stop(struct rsnd_mod *mod,
 	/*
 	 * DMAEngine release uses mutex lock.
 	 * Thus, it shouldn't be called under spinlock.
-	 * Let's call it under nolock_start
+	 * Let's call it under prepare
 	 */
 	if (dmaen->chan)
 		dma_release_channel(dmaen->chan);
@@ -126,9 +126,9 @@ static int rsnd_dmaen_nolock_stop(struct rsnd_mod *mod,
 	return 0;
 }
 
-static int rsnd_dmaen_nolock_start(struct rsnd_mod *mod,
-			    struct rsnd_dai_stream *io,
-			    struct rsnd_priv *priv)
+static int rsnd_dmaen_prepare(struct rsnd_mod *mod,
+			      struct rsnd_dai_stream *io,
+			      struct rsnd_priv *priv)
 {
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
@@ -142,7 +142,7 @@ static int rsnd_dmaen_nolock_start(struct rsnd_mod *mod,
 	/*
 	 * DMAEngine request uses mutex lock.
 	 * Thus, it shouldn't be called under spinlock.
-	 * Let's call it under nolock_start
+	 * Let's call it under prepare
 	 */
 	dmaen->chan = rsnd_dmaen_request_channel(io,
 						 dma->mod_from,
@@ -287,8 +287,8 @@ static int rsnd_dmaen_pointer(struct rsnd_mod *mod,
 
 static struct rsnd_mod_ops rsnd_dmaen_ops = {
 	.name	= "audmac",
-	.nolock_start = rsnd_dmaen_nolock_start,
-	.nolock_stop  = rsnd_dmaen_nolock_stop,
+	.prepare = rsnd_dmaen_prepare,
+	.cleanup = rsnd_dmaen_cleanup,
 	.start	= rsnd_dmaen_start,
 	.stop	= rsnd_dmaen_stop,
 	.pointer= rsnd_dmaen_pointer,

commit 92c7d384ff7282738c70720f8670c9b65c90c7df
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Mon Sep 3 07:08:00 2018 +0000

    ASoc: rsnd: dma: Calculate PDMACHCRE with consider of BUSIF
    
    PDMACHCR setting for SSI only considers BUSIF0 so far.
    But BUSIF1 ~ BUSIF7 also maybe used, in the future.
    
    This patch updates table gen2_id_table_ssiu, to also consider
    BUSIF number used by SSI.
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    [kuninori: adjust to upstreaming]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 73f743ea3d08..d3b1a4ae876a 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -298,16 +298,26 @@ static struct rsnd_mod_ops rsnd_dmaen_ops = {
  *		Audio DMAC peri peri
  */
 static const u8 gen2_id_table_ssiu[] = {
-	0x00, /* SSI00 */
-	0x04, /* SSI10 */
-	0x08, /* SSI20 */
-	0x0c, /* SSI3  */
-	0x0d, /* SSI4  */
-	0x0e, /* SSI5  */
-	0x0f, /* SSI6  */
-	0x10, /* SSI7  */
-	0x11, /* SSI8  */
-	0x12, /* SSI90 */
+	/* SSI00 ~ SSI07 */
+	0x00, 0x01, 0x02, 0x03, 0x39, 0x3a, 0x3b, 0x3c,
+	/* SSI10 ~ SSI17 */
+	0x04, 0x05, 0x06, 0x07, 0x3d, 0x3e, 0x3f, 0x40,
+	/* SSI20 ~ SSI27 */
+	0x08, 0x09, 0x0a, 0x0b, 0x41, 0x42, 0x43, 0x44,
+	/* SSI30 ~ SSI37 */
+	0x0c, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
+	/* SSI40 ~ SSI47 */
+	0x0d, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52,
+	/* SSI5 */
+	0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	/* SSI6 */
+	0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	/* SSI7 */
+	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	/* SSI8 */
+	0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	/* SSI90 ~ SSI97 */
+	0x12, 0x13, 0x14, 0x15, 0x53, 0x54, 0x55, 0x56,
 };
 static const u8 gen2_id_table_scu[] = {
 	0x2d, /* SCU_SRCI0 */
@@ -333,18 +343,23 @@ static u32 rsnd_dmapp_get_id(struct rsnd_dai_stream *io,
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
 	const u8 *entry = NULL;
-	int id = rsnd_mod_id(mod);
+	int id = 255;
 	int size = 0;
 
 	if (mod == ssi) {
+		int busif = rsnd_ssi_get_busif(io);
+
 		entry = gen2_id_table_ssiu;
 		size = ARRAY_SIZE(gen2_id_table_ssiu);
+		id = (rsnd_mod_id(mod) * 8) + busif;
 	} else if (mod == src) {
 		entry = gen2_id_table_scu;
 		size = ARRAY_SIZE(gen2_id_table_scu);
+		id = rsnd_mod_id(mod);
 	} else if (mod == dvc) {
 		entry = gen2_id_table_cmd;
 		size = ARRAY_SIZE(gen2_id_table_cmd);
+		id = rsnd_mod_id(mod);
 	}
 
 	if ((!entry) || (size <= id)) {

commit 5e45a6fab3b90ca300e13191fc68baaa8e37d1d4
Author: Jiada Wang <jiada_wang@mentor.com>
Date:   Mon Sep 3 07:07:43 2018 +0000

    ASoc: rsnd: dma: Calculate dma address with consider of BUSIF
    
    DMA address calculated by rsnd_dma_addr() only considers BUSIF0 so far.
    But BUSIF1 ~ BUSIF7 also maybe used, in the future.
    
    This patch updates DMA address calculations, to also consider
    BUSIF number used by SSI.
    
    One note is that we can't support SSI9-4/5/6/7 so far,
    because its address is out of calculation rule.
    
    Signed-off-by: Jiada Wang <jiada_wang@mentor.com>
    Signed-off-by: Timo Wischer <twischer@de.adit-jv.com>
    [kuninori: adjust to upstreaming]
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index fe63ef8600d0..73f743ea3d08 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -487,11 +487,11 @@ static struct rsnd_mod_ops rsnd_dmapp_ops = {
 #define RDMA_SSI_I_N(addr, i)	(addr ##_reg - 0x00300000 + (0x40 * i) + 0x8)
 #define RDMA_SSI_O_N(addr, i)	(addr ##_reg - 0x00300000 + (0x40 * i) + 0xc)
 
-#define RDMA_SSIU_I_N(addr, i)	(addr ##_reg - 0x00441000 + (0x1000 * i))
-#define RDMA_SSIU_O_N(addr, i)	(addr ##_reg - 0x00441000 + (0x1000 * i))
+#define RDMA_SSIU_I_N(addr, i, j) (addr ##_reg - 0x00441000 + (0x1000 * (i)) + (((j) / 4) * 0xA000) + (((j) % 4) * 0x400))
+#define RDMA_SSIU_O_N(addr, i, j) RDMA_SSIU_I_N(addr, i, j)
 
-#define RDMA_SSIU_I_P(addr, i)	(addr ##_reg - 0x00141000 + (0x1000 * i))
-#define RDMA_SSIU_O_P(addr, i)	(addr ##_reg - 0x00141000 + (0x1000 * i))
+#define RDMA_SSIU_I_P(addr, i, j) (addr ##_reg - 0x00141000 + (0x1000 * (i)) + (((j) / 4) * 0xA000) + (((j) % 4) * 0x400))
+#define RDMA_SSIU_O_P(addr, i, j) RDMA_SSIU_I_P(addr, i, j)
 
 #define RDMA_SRC_I_N(addr, i)	(addr ##_reg - 0x00500000 + (0x400 * i))
 #define RDMA_SRC_O_N(addr, i)	(addr ##_reg - 0x004fc000 + (0x400 * i))
@@ -517,6 +517,7 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 		      !!rsnd_io_to_mod_mix(io) ||
 		      !!rsnd_io_to_mod_ctu(io);
 	int id = rsnd_mod_id(mod);
+	int busif = rsnd_ssi_get_busif(io);
 	struct dma_addr {
 		dma_addr_t out_addr;
 		dma_addr_t in_addr;
@@ -533,25 +534,35 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 		},
 		/* SSI */
 		/* Capture */
-		{{{ RDMA_SSI_O_N(ssi, id),	0 },
-		  { RDMA_SSIU_O_P(ssi, id),	0 },
-		  { RDMA_SSIU_O_P(ssi, id),	0 } },
+		{{{ RDMA_SSI_O_N(ssi, id),		0 },
+		  { RDMA_SSIU_O_P(ssi, id, busif),	0 },
+		  { RDMA_SSIU_O_P(ssi, id, busif),	0 } },
 		 /* Playback */
-		 {{ 0,				RDMA_SSI_I_N(ssi, id) },
-		  { 0,				RDMA_SSIU_I_P(ssi, id) },
-		  { 0,				RDMA_SSIU_I_P(ssi, id) } }
+		 {{ 0,			RDMA_SSI_I_N(ssi, id) },
+		  { 0,			RDMA_SSIU_I_P(ssi, id, busif) },
+		  { 0,			RDMA_SSIU_I_P(ssi, id, busif) } }
 		},
 		/* SSIU */
 		/* Capture */
-		{{{ RDMA_SSIU_O_N(ssi, id),	0 },
-		  { RDMA_SSIU_O_P(ssi, id),	0 },
-		  { RDMA_SSIU_O_P(ssi, id),	0 } },
+		{{{ RDMA_SSIU_O_N(ssi, id, busif),	0 },
+		  { RDMA_SSIU_O_P(ssi, id, busif),	0 },
+		  { RDMA_SSIU_O_P(ssi, id, busif),	0 } },
 		 /* Playback */
-		 {{ 0,				RDMA_SSIU_I_N(ssi, id) },
-		  { 0,				RDMA_SSIU_I_P(ssi, id) },
-		  { 0,				RDMA_SSIU_I_P(ssi, id) } } },
+		 {{ 0,			RDMA_SSIU_I_N(ssi, id, busif) },
+		  { 0,			RDMA_SSIU_I_P(ssi, id, busif) },
+		  { 0,			RDMA_SSIU_I_P(ssi, id, busif) } } },
 	};
 
+	/*
+	 * FIXME
+	 *
+	 * We can't support SSI9-4/5/6/7, because its address is
+	 * out of calculation rule
+	 */
+	if ((id == 9) && (busif >= 4))
+		dev_err(dev, "This driver doesn't support SSI%d-%d, so far",
+			id, busif);
+
 	/* it shouldn't happen */
 	if (use_cmd && !use_src)
 		dev_err(dev, "DVC is selected without SRC\n");

commit 1e0edd4deadbbacd3b35179c233efa26624ab2af
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jun 12 05:58:38 2018 +0000

    ASoC: rsnd: convert to SPDX identifiers
    
    Tidyup incoherence between MODULE_LICENSE and header license, too
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index ef82b94d038b..fe63ef8600d0 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -1,13 +1,10 @@
-/*
- * Renesas R-Car Audio DMAC support
- *
- * Copyright (C) 2015 Renesas Electronics Corp.
- * Copyright (c) 2015 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
+// SPDX-License-Identifier: GPL-2.0
+//
+// Renesas R-Car Audio DMAC support
+//
+// Copyright (C) 2015 Renesas Electronics Corp.
+// Copyright (c) 2015 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+
 #include <linux/delay.h>
 #include <linux/of_dma.h>
 #include "rsnd.h"

commit 5423d77253ac5bcb2d3de61cf0811c0f2a62c0af
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Apr 16 05:14:01 2018 +0000

    ASoC: rsnd: Enable IPMMU v2
    
    commit 4821d914fe747 ("ASoC: rsnd: use dma_sync_single_for_xxx() for
    IOMMU") (= v1) which have been already reverted had supported IPMMU
    support on rsnd driver.
    Because memory allocating timing and DMAEngine access timing were
    different, it used continuous memory and called dma map function by
    itself.
    
    OTOH, it is using DMA descriptor mode (= DMA cyclic mode), thus, there
    was timing conflict between DMA sync/unsync and DMA transfer starting,
    and it maked sound noise.
    
    This patch supports IPMMU with coherent memory, and, it uses Audio DMAC
    dev for allocating memory by snd_pcm_lib_preallocate_pages_for_all() to
    indicate memory area to IPMMU.
    One note is that Playback/Capture need each paired Audio DMAC dev.
    Because of this, we need to keep each paired Audio DMAC dev when probing,
    and use it when allocating each memory for IPMMU.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 32ac97be26f1..ef82b94d038b 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -253,6 +253,13 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 		return -EAGAIN;
 	}
 
+	/*
+	 * use it for IPMMU if needed
+	 * see
+	 *	rsnd_preallocate_pages()
+	 */
+	io->dmac_dev = chan->device->dev;
+
 	dma_release_channel(chan);
 
 	dmac->dmaen_num++;

commit d188e140ad9723faccefa4ed5dc313cd467123c9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Apr 11 02:10:29 2018 +0000

    ASoC: rsnd: add RSND_GEN3 for R-Car Gen3
    
    rsnd driver is supporting Gen3. The difference between Gen1 and Gen2
    were very big, but, between Gen2 and Gen3 are not so much.
    Thus, it is assuming Gen2 and Gen3 have compatible, therefore,
    there is no RSND_GEN3 and rsnd_is_gen3() macro.
    But in the future, it will need Gen2 and Gen3 different operation,
    and for Gen4.
    This patch adds missing RSND_GEN3 and rsnd_is_gen3() macro.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Nguyen Viet Dung <dung.nguyen.aj@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 41de23417c4a..32ac97be26f1 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -695,7 +695,7 @@ static int rsnd_dma_alloc(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 
 	rsnd_dma_of_path(mod, io, is_play, &mod_from, &mod_to);
 
-	/* for Gen2 */
+	/* for Gen2 or later */
 	if (mod_from && mod_to) {
 		ops	= &rsnd_dmapp_ops;
 		attach	= rsnd_dmapp_attach;
@@ -773,7 +773,7 @@ int rsnd_dma_probe(struct rsnd_priv *priv)
 		return 0;
 
 	/*
-	 * for Gen2
+	 * for Gen2 or later
 	 */
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "audmapp");
 	dmac = devm_kzalloc(dev, sizeof(*dmac), GFP_KERNEL);

commit 65bedda1feec4f57e1322a200853cc29079b01c6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 29 03:08:35 2017 +0000

    ASoC: rsnd: dma.c: spin lock is no longer needed in IRQ handler
    
    DMA handler had needed to calculate pointer before, but it doesn't
    need now. Thus, we can remove unnecessary spin lock from DMAC handler.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 4d750bdf8e24..41de23417c4a 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -71,25 +71,7 @@ static struct rsnd_mod mem = {
 static void __rsnd_dmaen_complete(struct rsnd_mod *mod,
 				  struct rsnd_dai_stream *io)
 {
-	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	bool elapsed = false;
-	unsigned long flags;
-
-	/*
-	 * Renesas sound Gen1 needs 1 DMAC,
-	 * Gen2 needs 2 DMAC.
-	 * In Gen2 case, it are Audio-DMAC, and Audio-DMAC-peri-peri.
-	 * But, Audio-DMAC-peri-peri doesn't have interrupt,
-	 * and this driver is assuming that here.
-	 */
-	spin_lock_irqsave(&priv->lock, flags);
-
 	if (rsnd_io_is_working(io))
-		elapsed = true;
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	if (elapsed)
 		rsnd_dai_period_elapsed(io);
 }
 

commit c20c6704bf2dafaba0d90c8310ef9e919fe4d2e2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 16 04:36:51 2017 +0000

    ASoC: rcar: revert IOMMU support so far
    
    commit 4821d914fe74 ("ASoC: rsnd: use dma_sync_single_for_xxx() for
    IOMMU") had supported IOMMU, but it breaks normal sound "recorde"
    and both PulseAudio's "playback/recorde". The sound will be noisy.
    
    That commit was using dma_sync_single_for_xxx(), and driver should
    make sure memory is protected during CPU or Device are using it.
    But if driver returns current "residue" data size correctly on pointer
    function, player/recorder will access to protected memory.
    
    IOMMU feature should be supported, but I don't know how to handle it
    without memory cache problem at this point.
    Thus, this patch simply revert it to avoid current noisy sound.
    
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Tested-by: Ryo Kodama <ryo.kodama.vz@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index fd557abfe390..4d750bdf8e24 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -26,10 +26,7 @@
 struct rsnd_dmaen {
 	struct dma_chan		*chan;
 	dma_cookie_t		cookie;
-	dma_addr_t		dma_buf;
 	unsigned int		dma_len;
-	unsigned int		dma_period;
-	unsigned int		dma_cnt;
 };
 
 struct rsnd_dmapp {
@@ -71,38 +68,10 @@ static struct rsnd_mod mem = {
 /*
  *		Audio DMAC
  */
-#define rsnd_dmaen_sync(dmaen, io, i)	__rsnd_dmaen_sync(dmaen, io, i, 1)
-#define rsnd_dmaen_unsync(dmaen, io, i)	__rsnd_dmaen_sync(dmaen, io, i, 0)
-static void __rsnd_dmaen_sync(struct rsnd_dmaen *dmaen, struct rsnd_dai_stream *io,
-			      int i, int sync)
-{
-	struct device *dev = dmaen->chan->device->dev;
-	enum dma_data_direction dir;
-	int is_play = rsnd_io_is_play(io);
-	dma_addr_t buf;
-	int len, max;
-	size_t period;
-
-	len	= dmaen->dma_len;
-	period	= dmaen->dma_period;
-	max	= len / period;
-	i	= i % max;
-	buf	= dmaen->dma_buf + (period * i);
-
-	dir = is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
-
-	if (sync)
-		dma_sync_single_for_device(dev, buf, period, dir);
-	else
-		dma_sync_single_for_cpu(dev, buf, period, dir);
-}
-
 static void __rsnd_dmaen_complete(struct rsnd_mod *mod,
 				  struct rsnd_dai_stream *io)
 {
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
-	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	bool elapsed = false;
 	unsigned long flags;
 
@@ -115,22 +84,9 @@ static void __rsnd_dmaen_complete(struct rsnd_mod *mod,
 	 */
 	spin_lock_irqsave(&priv->lock, flags);
 
-	if (rsnd_io_is_working(io)) {
-		rsnd_dmaen_unsync(dmaen, io, dmaen->dma_cnt);
-
-		/*
-		 * Next period is already started.
-		 * Let's sync Next Next period
-		 * see
-		 *	rsnd_dmaen_start()
-		 */
-		rsnd_dmaen_sync(dmaen, io, dmaen->dma_cnt + 2);
-
+	if (rsnd_io_is_working(io))
 		elapsed = true;
 
-		dmaen->dma_cnt++;
-	}
-
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	if (elapsed)
@@ -165,14 +121,8 @@ static int rsnd_dmaen_stop(struct rsnd_mod *mod,
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 
-	if (dmaen->chan) {
-		int is_play = rsnd_io_is_play(io);
-
+	if (dmaen->chan)
 		dmaengine_terminate_all(dmaen->chan);
-		dma_unmap_single(dmaen->chan->device->dev,
-				 dmaen->dma_buf, dmaen->dma_len,
-				 is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
-	}
 
 	return 0;
 }
@@ -237,11 +187,7 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
 	struct dma_slave_config cfg = {};
-	dma_addr_t buf;
-	size_t len;
-	size_t period;
 	int is_play = rsnd_io_is_play(io);
-	int i;
 	int ret;
 
 	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
@@ -258,19 +204,10 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	if (ret < 0)
 		return ret;
 
-	len	= snd_pcm_lib_buffer_bytes(substream);
-	period	= snd_pcm_lib_period_bytes(substream);
-	buf	= dma_map_single(dmaen->chan->device->dev,
-				 substream->runtime->dma_area,
-				 len,
-				 is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
-	if (dma_mapping_error(dmaen->chan->device->dev, buf)) {
-		dev_err(dev, "dma map failed\n");
-		return -EIO;
-	}
-
 	desc = dmaengine_prep_dma_cyclic(dmaen->chan,
-					 buf, len, period,
+					 substream->runtime->dma_addr,
+					 snd_pcm_lib_buffer_bytes(substream),
+					 snd_pcm_lib_period_bytes(substream),
 					 is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,
 					 DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 
@@ -282,18 +219,7 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	desc->callback		= rsnd_dmaen_complete;
 	desc->callback_param	= rsnd_mod_get(dma);
 
-	dmaen->dma_buf		= buf;
-	dmaen->dma_len		= len;
-	dmaen->dma_period	= period;
-	dmaen->dma_cnt		= 0;
-
-	/*
-	 * synchronize this and next period
-	 * see
-	 *	__rsnd_dmaen_complete()
-	 */
-	for (i = 0; i < 2; i++)
-		rsnd_dmaen_sync(dmaen, io, i);
+	dmaen->dma_len		= snd_pcm_lib_buffer_bytes(substream);
 
 	dmaen->cookie = dmaengine_submit(desc);
 	if (dmaen->cookie < 0) {

commit c409c2a963475f0288ba3bb47a10f04f6441ffb9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 6 01:07:27 2017 +0000

    ASoC: rsnd: return -EIO if rsnd_dmaen_request_channel() failed
    
    PTR_ERR(NULL) is success. Normally when a function returns both NULL
    and error pointers, it means that NULL is not a error.
    But, rsnd_dmaen_request_channel() returns NULL if requested resource
    was failed.
    Let's return -EIO if rsnd_dmaen_request_channel() was failed on
    rsnd_dmaen_nolock_start().
    This patch fixes commit edce5c496c6a ("ASoC: rsnd: Request/Release DMA
    channel eachtime")
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 5bc9ec16813c..fd557abfe390 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -219,11 +219,9 @@ static int rsnd_dmaen_nolock_start(struct rsnd_mod *mod,
 						 dma->mod_from,
 						 dma->mod_to);
 	if (IS_ERR_OR_NULL(dmaen->chan)) {
-		int ret = PTR_ERR(dmaen->chan);
-
 		dmaen->chan = NULL;
 		dev_err(dev, "can't get dma channel\n");
-		return ret;
+		return -EIO;
 	}
 
 	return 0;

commit 9b6ea25066b05c4b8bc4ea69037741bd67649cd1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 1 07:17:34 2017 +0000

    ASoC: rsnd: remove NULL check from rsnd_mod_name()/rsnd_mod_id()
    
    Current rsnd driver has rsnd_mod_id() which returns mod ID,
    and it returns -1 if mod was NULL.
    In the same time, this driver has rsnd_mod_name() which returns mod
    name, and it returns "unknown" if mod or mod->ops was NULL.
    
    Basically these "mod" never be NULL, but the reason why rsnd driver
    has such behavior is that DMA path finder is assuming memory as
    "mod == NULL".
    Thus, current DMA path debug code prints like below.
    Here "unknown[-1]" means it was memory.
    
            ...
            rcar_sound ec500000.sound:   unknown[-1] from
            rcar_sound ec500000.sound:   src[0] to
            rcar_sound ec500000.sound:   ctu[2]
            rcar_sound ec500000.sound:   mix[0]
            rcar_sound ec500000.sound:   dvc[0]
            rcar_sound ec500000.sound:   ssi[0]
            rcar_sound ec500000.sound: audmac[0] unknown[-1] -> src[0]
            ...
    
    1st issue is that it is confusable for user.
    2nd issue is rsnd driver has something like below code.
    
            mask |= 1 << rsnd_mod_id(mod);
    
    Because of this kind of code, some statically code checker will
    reports "Shifting by a negative value is undefined behaviour".
    
    But this "mod" never be NULL, thus negative shift never happen.
    To avoid these issues, this patch adds new dummy "mem" to
    indicate memory, and use it to indicate debug information,
    and, remove unneeded "NULL mod" behavior from rsnd_mod_id() and
    rsnd_mod_name().
    
    The debug information will be like below by this patch
            ...
            rcar_sound ec500000.sound:   mem[0] from
            rcar_sound ec500000.sound:   src[0] to
            rcar_sound ec500000.sound:   ctu[2]
            rcar_sound ec500000.sound:   mix[0]
            rcar_sound ec500000.sound:   dvc[0]
            rcar_sound ec500000.sound:   ssi[0]
            rcar_sound ec500000.sound: audmac[0] mem[0] -> src[0]
            ...
    
    Reported-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 17220c946ff0..5bc9ec16813c 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -60,6 +60,14 @@ struct rsnd_dma_ctrl {
 #define rsnd_dma_to_dmaen(dma)	(&(dma)->dma.en)
 #define rsnd_dma_to_dmapp(dma)	(&(dma)->dma.pp)
 
+/* for DEBUG */
+static struct rsnd_mod_ops mem_ops = {
+	.name = "mem",
+};
+
+static struct rsnd_mod mem = {
+};
+
 /*
  *		Audio DMAC
  */
@@ -747,9 +755,10 @@ static void rsnd_dma_of_path(struct rsnd_mod *this,
 		rsnd_mod_name(this), rsnd_mod_id(this));
 	for (i = 0; i <= idx; i++) {
 		dev_dbg(dev, "  %s[%d]%s\n",
-		       rsnd_mod_name(mod[i]), rsnd_mod_id(mod[i]),
-		       (mod[i] == *mod_from) ? " from" :
-		       (mod[i] == *mod_to)   ? " to" : "");
+			rsnd_mod_name(mod[i] ? mod[i] : &mem),
+			rsnd_mod_id  (mod[i] ? mod[i] : &mem),
+			(mod[i] == *mod_from) ? " from" :
+			(mod[i] == *mod_to)   ? " to" : "");
 	}
 }
 
@@ -814,8 +823,10 @@ static int rsnd_dma_alloc(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 
 	dev_dbg(dev, "%s[%d] %s[%d] -> %s[%d]\n",
 		rsnd_mod_name(*dma_mod), rsnd_mod_id(*dma_mod),
-		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
-		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
+		rsnd_mod_name(mod_from ? mod_from : &mem),
+		rsnd_mod_id  (mod_from ? mod_from : &mem),
+		rsnd_mod_name(mod_to   ? mod_to   : &mem),
+		rsnd_mod_id  (mod_to   ? mod_to   : &mem));
 
 	ret = attach(io, dma, mod_from, mod_to);
 	if (ret < 0)
@@ -872,5 +883,6 @@ int rsnd_dma_probe(struct rsnd_priv *priv)
 
 	priv->dma = dmac;
 
-	return 0;
+	/* dummy mem mod for debug */
+	return rsnd_mod_init(NULL, &mem, &mem_ops, NULL, NULL, 0, 0);
 }

commit 81cb71240e202a8086bda0755d9d78bd3decd0aa
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 20 06:28:44 2017 +0000

    ASoC: rsnd: add rsnd_dma_alloc()
    
    R-Car sound DMA will be used from SSI/SRC.
    dma.c doesn't alloc DMA handler in .probe timing, because we don't
    know what kind of DMA transfer will be used then.
    Thus, SSI/SRC have *rsnd_mod for DMA. rsnd_dma_attach() will allocate
    it and attach it to system.
    It will be PIO mode if it can't alloc DMA handler.
    
    In case of MIX is used, rsnd_dma_attach() will be called twice from SSI.
    To avoid duplicate allocation, current rsnd_dma_attach() is checking
    allocated DMA handler. This DMA related operation is a little bit
    difficult to understand.
    This patch adds new rsnd_dma_alloc() and separates allocation and attach
    for readable code.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 041ec1080d52..17220c946ff0 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -753,14 +753,15 @@ static void rsnd_dma_of_path(struct rsnd_mod *this,
 	}
 }
 
-int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
-		    struct rsnd_mod **dma_mod)
+static int rsnd_dma_alloc(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
+			  struct rsnd_mod **dma_mod)
 {
 	struct rsnd_mod *mod_from = NULL;
 	struct rsnd_mod *mod_to = NULL;
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_dma *dma;
 	struct rsnd_mod_ops *ops;
 	enum rsnd_mod_type type;
 	int (*attach)(struct rsnd_dai_stream *io, struct rsnd_dma *dma,
@@ -800,40 +801,45 @@ int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 		type	= RSND_MOD_AUDMA;
 	}
 
-	if (!(*dma_mod)) {
-		struct rsnd_dma *dma;
+	dma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);
+	if (!dma)
+		return -ENOMEM;
 
-		dma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);
-		if (!dma)
-			return -ENOMEM;
+	*dma_mod = rsnd_mod_get(dma);
 
-		*dma_mod = rsnd_mod_get(dma);
+	ret = rsnd_mod_init(priv, *dma_mod, ops, NULL,
+			    rsnd_mod_get_status, type, dma_id);
+	if (ret < 0)
+		return ret;
 
-		ret = rsnd_mod_init(priv, *dma_mod, ops, NULL,
-				    rsnd_mod_get_status, type, dma_id);
-		if (ret < 0)
-			return ret;
+	dev_dbg(dev, "%s[%d] %s[%d] -> %s[%d]\n",
+		rsnd_mod_name(*dma_mod), rsnd_mod_id(*dma_mod),
+		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
+		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
+
+	ret = attach(io, dma, mod_from, mod_to);
+	if (ret < 0)
+		return ret;
 
-		dev_dbg(dev, "%s[%d] %s[%d] -> %s[%d]\n",
-			rsnd_mod_name(*dma_mod), rsnd_mod_id(*dma_mod),
-			rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
-			rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
+	dma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);
+	dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
+	dma->mod_from = mod_from;
+	dma->mod_to   = mod_to;
+
+	return 0;
+}
+
+int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
+		    struct rsnd_mod **dma_mod)
+{
+	if (!(*dma_mod)) {
+		int ret = rsnd_dma_alloc(io, mod, dma_mod);
 
-		ret = attach(io, dma, mod_from, mod_to);
 		if (ret < 0)
 			return ret;
-
-		dma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);
-		dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
-		dma->mod_from = mod_from;
-		dma->mod_to   = mod_to;
 	}
 
-	ret = rsnd_dai_connect(*dma_mod, io, type);
-	if (ret < 0)
-		return ret;
-
-	return 0;
+	return rsnd_dai_connect(*dma_mod, io, (*dma_mod)->type);
 }
 
 int rsnd_dma_probe(struct rsnd_priv *priv)

commit b65cb7a590274bf5dbf5bbccbbd0c495c27ab14d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Aug 21 07:03:01 2017 +0000

    ASoC: rsnd: tidyup comments position/space/tab
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 60aa5e96a49f..041ec1080d52 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -604,8 +604,8 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 		dma_addr_t in_addr;
 	} dma_addrs[3][2][3] = {
 		/* SRC */
+		/* Capture */
 		{{{ 0,				0 },
-		  /* Capture */
 		  { RDMA_SRC_O_N(src, id),	RDMA_SRC_I_P(src, id) },
 		  { RDMA_CMD_O_N(src, id),	RDMA_SRC_I_P(src, id) } },
 		 /* Playback */

commit a97a06c7efc1ee34f500171f1c4e9608295bb79a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 7 00:20:47 2017 +0000

    ASoC: rsnd: cleanup pointer related code
    
    Current rsnd driver is sharing pointer related code between
    PIO / DMA. But, it is used only PIO mode now, no longer needed.
    This patch cleanup these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 05e538f4c8d5..60aa5e96a49f 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -104,10 +104,6 @@ static void __rsnd_dmaen_complete(struct rsnd_mod *mod,
 	 * In Gen2 case, it are Audio-DMAC, and Audio-DMAC-peri-peri.
 	 * But, Audio-DMAC-peri-peri doesn't have interrupt,
 	 * and this driver is assuming that here.
-	 *
-	 * If Audio-DMAC-peri-peri has interrpt,
-	 * rsnd_dai_pointer_update() will be called twice,
-	 * ant it will breaks io->byte_pos
 	 */
 	spin_lock_irqsave(&priv->lock, flags);
 
@@ -122,7 +118,7 @@ static void __rsnd_dmaen_complete(struct rsnd_mod *mod,
 		 */
 		rsnd_dmaen_sync(dmaen, io, dmaen->dma_cnt + 2);
 
-		elapsed = rsnd_dai_pointer_update(io, io->byte_per_period);
+		elapsed = true;
 
 		dmaen->dma_cnt++;
 	}

commit 07b7acb51d283d8469696c906b91f1882696a4d4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 7 00:20:01 2017 +0000

    ASoC: rsnd: update pointer more accurate
    
    Current rsnd driver updates pointer when DMA transfer was finished
    in DMA transfer mode. But PulseAudio requests more accurate
    pointer update when timer mode.
    This patch consider about DMA transfer residue and update more
    accurate pointer.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 241cb3b08a07..05e538f4c8d5 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -25,6 +25,7 @@
 
 struct rsnd_dmaen {
 	struct dma_chan		*chan;
+	dma_cookie_t		cookie;
 	dma_addr_t		dma_buf;
 	unsigned int		dma_len;
 	unsigned int		dma_period;
@@ -292,7 +293,8 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	for (i = 0; i < 2; i++)
 		rsnd_dmaen_sync(dmaen, io, i);
 
-	if (dmaengine_submit(desc) < 0) {
+	dmaen->cookie = dmaengine_submit(desc);
+	if (dmaen->cookie < 0) {
 		dev_err(dev, "dmaengine_submit() fail\n");
 		return -EIO;
 	}
@@ -348,12 +350,34 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 	return 0;
 }
 
+static int rsnd_dmaen_pointer(struct rsnd_mod *mod,
+			      struct rsnd_dai_stream *io,
+			      snd_pcm_uframes_t *pointer)
+{
+	struct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
+	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
+	struct dma_tx_state state;
+	enum dma_status status;
+	unsigned int pos = 0;
+
+	status = dmaengine_tx_status(dmaen->chan, dmaen->cookie, &state);
+	if (status == DMA_IN_PROGRESS || status == DMA_PAUSED) {
+		if (state.residue > 0 && state.residue <= dmaen->dma_len)
+			pos = dmaen->dma_len - state.residue;
+	}
+	*pointer = bytes_to_frames(runtime, pos);
+
+	return 0;
+}
+
 static struct rsnd_mod_ops rsnd_dmaen_ops = {
 	.name	= "audmac",
 	.nolock_start = rsnd_dmaen_nolock_start,
 	.nolock_stop  = rsnd_dmaen_nolock_stop,
 	.start	= rsnd_dmaen_start,
 	.stop	= rsnd_dmaen_stop,
+	.pointer= rsnd_dmaen_pointer,
 };
 
 /*

commit 9986943ef5d61a9bea3c86000d91d3b789f0060e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 16 04:22:09 2017 +0000

    ASoC: rcar: dma: remove unnecessary "volatile"
    
    commit 2a3af642eb20("ASoC: rcar: clear DE bit only in PDMACHCR...")
    added rsnd_dmapp_bset(), but it used copy-paste. Thus, it had
    unnecessary "volatile", and had below warning on x86.
    This patch fix it.
    
       sound/soc/sh/rcar/dma.c: In function 'rsnd_dmapp_bset':
    >> sound/soc/sh/rcar/dma.c:463:21: warning: passing argument 1 of \
       'ioread32' discards 'volatile' qualifier from pointer target \
       type [-Wdiscarded-qualifiers]
         u32 val = ioread32(addr);
                            ^~~~
       In file included from arch/x86/include/asm/io.h:203:0,
                        from arch/x86/include/asm/realmode.h:5,
                        from arch/x86/include/asm/acpi.h:33,
                        from arch/x86/include/asm/fixmap.h:19,
                        from arch/x86/include/asm/apic.h:10,
                        from arch/x86/include/asm/smp.h:12,
                        from include/linux/smp.h:59,
                        from include/linux/topology.h:33,
                        from include/linux/gfp.h:8,
                        from include/linux/idr.h:16,
                        from include/linux/kernfs.h:14,
                        from include/linux/sysfs.h:15,
                        from include/linux/kobject.h:21,
                        from include/linux/of.h:21,
                        from include/linux/of_dma.h:16,
                        from sound/soc/sh/rcar/dma.c:12:
       include/asm-generic/iomap.h:31:21: note: expected 'void *' \
       but argument is of type 'volatile void *'
        extern unsigned int ioread32(void __iomem *);
                            ^~~~~~~~
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index c2e199b4fcf4..241cb3b08a07 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -459,7 +459,7 @@ static void rsnd_dmapp_bset(struct rsnd_dma *dma, u32 data, u32 mask, u32 reg)
 	struct rsnd_mod *mod = rsnd_mod_get(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
-	volatile void __iomem *addr = rsnd_dmapp_addr(dmac, dma, reg);
+	void __iomem *addr = rsnd_dmapp_addr(dmac, dma, reg);
 	u32 val = ioread32(addr);
 
 	val &= ~mask;

commit 62a10498afb27370ec6018e9d802b74850fd8d9a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Mar 14 09:34:49 2017 +0900

    ASoC: rcar: clear DE bit only in PDMACHCR when it stops
    
    R-Car datasheet indicates "Clear DE in PDMACHCR" for transfer stop,
    but current code clears all bits in PDMACHCR.
    Because of this, DE bit might never been cleared,
    and it causes CMD overflow. This patch fixes this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 1f405c833867..c2e199b4fcf4 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -454,6 +454,20 @@ static u32 rsnd_dmapp_read(struct rsnd_dma *dma, u32 reg)
 	return ioread32(rsnd_dmapp_addr(dmac, dma, reg));
 }
 
+static void rsnd_dmapp_bset(struct rsnd_dma *dma, u32 data, u32 mask, u32 reg)
+{
+	struct rsnd_mod *mod = rsnd_mod_get(dma);
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
+	volatile void __iomem *addr = rsnd_dmapp_addr(dmac, dma, reg);
+	u32 val = ioread32(addr);
+
+	val &= ~mask;
+	val |= (data & mask);
+
+	iowrite32(val, addr);
+}
+
 static int rsnd_dmapp_stop(struct rsnd_mod *mod,
 			   struct rsnd_dai_stream *io,
 			   struct rsnd_priv *priv)
@@ -461,10 +475,10 @@ static int rsnd_dmapp_stop(struct rsnd_mod *mod,
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	int i;
 
-	rsnd_dmapp_write(dma, 0, PDMACHCR);
+	rsnd_dmapp_bset(dma, 0,  PDMACHCR_DE, PDMACHCR);
 
 	for (i = 0; i < 1024; i++) {
-		if (0 == rsnd_dmapp_read(dma, PDMACHCR))
+		if (0 == (rsnd_dmapp_read(dma, PDMACHCR) & PDMACHCR_DE))
 			return 0;
 		udelay(1);
 	}

commit 4821d914fe747a91453021675a74069776f0b819
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 14 04:20:56 2016 +0000

    ASoC: rsnd: use dma_sync_single_for_xxx() for IOMMU
    
    IOMMU needs DMA mapping function to use it. One solution is that
    we can use DMA mapped dev on snd_pcm_lib_preallocate_pages_for_all()
    for SNDRV_DMA_TYPE_DEV. But pcm_new and dma map timing are mismatched.
    Thus, this patch uses SNDRV_DMA_TYPE_CONTINUOUS for pcm_new,
    and use dma_sync_single_for_xxx() for each transfer.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 3c663a5cfe8b..1f405c833867 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -25,6 +25,10 @@
 
 struct rsnd_dmaen {
 	struct dma_chan		*chan;
+	dma_addr_t		dma_buf;
+	unsigned int		dma_len;
+	unsigned int		dma_period;
+	unsigned int		dma_cnt;
 };
 
 struct rsnd_dmapp {
@@ -58,10 +62,38 @@ struct rsnd_dma_ctrl {
 /*
  *		Audio DMAC
  */
+#define rsnd_dmaen_sync(dmaen, io, i)	__rsnd_dmaen_sync(dmaen, io, i, 1)
+#define rsnd_dmaen_unsync(dmaen, io, i)	__rsnd_dmaen_sync(dmaen, io, i, 0)
+static void __rsnd_dmaen_sync(struct rsnd_dmaen *dmaen, struct rsnd_dai_stream *io,
+			      int i, int sync)
+{
+	struct device *dev = dmaen->chan->device->dev;
+	enum dma_data_direction dir;
+	int is_play = rsnd_io_is_play(io);
+	dma_addr_t buf;
+	int len, max;
+	size_t period;
+
+	len	= dmaen->dma_len;
+	period	= dmaen->dma_period;
+	max	= len / period;
+	i	= i % max;
+	buf	= dmaen->dma_buf + (period * i);
+
+	dir = is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+
+	if (sync)
+		dma_sync_single_for_device(dev, buf, period, dir);
+	else
+		dma_sync_single_for_cpu(dev, buf, period, dir);
+}
+
 static void __rsnd_dmaen_complete(struct rsnd_mod *mod,
 				  struct rsnd_dai_stream *io)
 {
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
+	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	bool elapsed = false;
 	unsigned long flags;
 
@@ -78,9 +110,22 @@ static void __rsnd_dmaen_complete(struct rsnd_mod *mod,
 	 */
 	spin_lock_irqsave(&priv->lock, flags);
 
-	if (rsnd_io_is_working(io))
+	if (rsnd_io_is_working(io)) {
+		rsnd_dmaen_unsync(dmaen, io, dmaen->dma_cnt);
+
+		/*
+		 * Next period is already started.
+		 * Let's sync Next Next period
+		 * see
+		 *	rsnd_dmaen_start()
+		 */
+		rsnd_dmaen_sync(dmaen, io, dmaen->dma_cnt + 2);
+
 		elapsed = rsnd_dai_pointer_update(io, io->byte_per_period);
 
+		dmaen->dma_cnt++;
+	}
+
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	if (elapsed)
@@ -116,7 +161,12 @@ static int rsnd_dmaen_stop(struct rsnd_mod *mod,
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 
 	if (dmaen->chan) {
+		int is_play = rsnd_io_is_play(io);
+
 		dmaengine_terminate_all(dmaen->chan);
+		dma_unmap_single(dmaen->chan->device->dev,
+				 dmaen->dma_buf, dmaen->dma_len,
+				 is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 	}
 
 	return 0;
@@ -184,7 +234,11 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
 	struct dma_slave_config cfg = {};
+	dma_addr_t buf;
+	size_t len;
+	size_t period;
 	int is_play = rsnd_io_is_play(io);
+	int i;
 	int ret;
 
 	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
@@ -201,10 +255,19 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	if (ret < 0)
 		return ret;
 
+	len	= snd_pcm_lib_buffer_bytes(substream);
+	period	= snd_pcm_lib_period_bytes(substream);
+	buf	= dma_map_single(dmaen->chan->device->dev,
+				 substream->runtime->dma_area,
+				 len,
+				 is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	if (dma_mapping_error(dmaen->chan->device->dev, buf)) {
+		dev_err(dev, "dma map failed\n");
+		return -EIO;
+	}
+
 	desc = dmaengine_prep_dma_cyclic(dmaen->chan,
-					 substream->runtime->dma_addr,
-					 snd_pcm_lib_buffer_bytes(substream),
-					 snd_pcm_lib_period_bytes(substream),
+					 buf, len, period,
 					 is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,
 					 DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 
@@ -216,6 +279,19 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	desc->callback		= rsnd_dmaen_complete;
 	desc->callback_param	= rsnd_mod_get(dma);
 
+	dmaen->dma_buf		= buf;
+	dmaen->dma_len		= len;
+	dmaen->dma_period	= period;
+	dmaen->dma_cnt		= 0;
+
+	/*
+	 * synchronize this and next period
+	 * see
+	 *	__rsnd_dmaen_complete()
+	 */
+	for (i = 0; i < 2; i++)
+		rsnd_dmaen_sync(dmaen, io, i);
+
 	if (dmaengine_submit(desc) < 0) {
 		dev_err(dev, "dmaengine_submit() fail\n");
 		return -EIO;

commit edce5c496c6af3e5ca6e1bb18f7cf4f6ef6226fa
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 14 04:20:40 2016 +0000

    ASoC: rsnd: Request/Release DMA channel each time
    
    Current Renesas Sound driver requests DMA channel when .probe timing,
    and release it when .remove timing. And use DMA on .start/.stop
    But, Audio DMAC power ON was handled when request timing (= .probe),
    and power OFF was when release timing (= .remove).
    This means Audio DMAC power is always ON during driver was enabled.
    The best choice to solve this issue is that DMAEngine side handle
    this. But current DMAEngine API design can't solve atmic/non-atmic
    context issue for power ON/OFF. So next better choice is sound
    driver request/release DMA channel each time. This patch do it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 2f0327714625..3c663a5cfe8b 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -34,6 +34,8 @@ struct rsnd_dmapp {
 
 struct rsnd_dma {
 	struct rsnd_mod		mod;
+	struct rsnd_mod		*mod_from;
+	struct rsnd_mod		*mod_to;
 	dma_addr_t		src_addr;
 	dma_addr_t		dst_addr;
 	union {
@@ -92,6 +94,20 @@ static void rsnd_dmaen_complete(void *data)
 	rsnd_mod_interrupt(mod, __rsnd_dmaen_complete);
 }
 
+static struct dma_chan *rsnd_dmaen_request_channel(struct rsnd_dai_stream *io,
+						   struct rsnd_mod *mod_from,
+						   struct rsnd_mod *mod_to)
+{
+	if ((!mod_from && !mod_to) ||
+	    (mod_from && mod_to))
+		return NULL;
+
+	if (mod_from)
+		return rsnd_mod_dma_req(io, mod_from);
+	else
+		return rsnd_mod_dma_req(io, mod_to);
+}
+
 static int rsnd_dmaen_stop(struct rsnd_mod *mod,
 			   struct rsnd_dai_stream *io,
 			   struct rsnd_priv *priv)
@@ -99,7 +115,61 @@ static int rsnd_dmaen_stop(struct rsnd_mod *mod,
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 
-	dmaengine_terminate_all(dmaen->chan);
+	if (dmaen->chan) {
+		dmaengine_terminate_all(dmaen->chan);
+	}
+
+	return 0;
+}
+
+static int rsnd_dmaen_nolock_stop(struct rsnd_mod *mod,
+				   struct rsnd_dai_stream *io,
+				   struct rsnd_priv *priv)
+{
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
+	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
+
+	/*
+	 * DMAEngine release uses mutex lock.
+	 * Thus, it shouldn't be called under spinlock.
+	 * Let's call it under nolock_start
+	 */
+	if (dmaen->chan)
+		dma_release_channel(dmaen->chan);
+
+	dmaen->chan = NULL;
+
+	return 0;
+}
+
+static int rsnd_dmaen_nolock_start(struct rsnd_mod *mod,
+			    struct rsnd_dai_stream *io,
+			    struct rsnd_priv *priv)
+{
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
+	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
+	struct device *dev = rsnd_priv_to_dev(priv);
+
+	if (dmaen->chan) {
+		dev_err(dev, "it already has dma channel\n");
+		return -EIO;
+	}
+
+	/*
+	 * DMAEngine request uses mutex lock.
+	 * Thus, it shouldn't be called under spinlock.
+	 * Let's call it under nolock_start
+	 */
+	dmaen->chan = rsnd_dmaen_request_channel(io,
+						 dma->mod_from,
+						 dma->mod_to);
+	if (IS_ERR_OR_NULL(dmaen->chan)) {
+		int ret = PTR_ERR(dmaen->chan);
+
+		dmaen->chan = NULL;
+		dev_err(dev, "can't get dma channel\n");
+		return ret;
+	}
 
 	return 0;
 }
@@ -113,7 +183,23 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 	struct snd_pcm_substream *substream = io->substream;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
+	struct dma_slave_config cfg = {};
 	int is_play = rsnd_io_is_play(io);
+	int ret;
+
+	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
+	cfg.src_addr	= dma->src_addr;
+	cfg.dst_addr	= dma->dst_addr;
+	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	dev_dbg(dev, "%s[%d] %pad -> %pad\n",
+		rsnd_mod_name(mod), rsnd_mod_id(mod),
+		&cfg.src_addr, &cfg.dst_addr);
+
+	ret = dmaengine_slave_config(dmaen->chan, &cfg);
+	if (ret < 0)
+		return ret;
 
 	desc = dmaengine_prep_dma_cyclic(dmaen->chan,
 					 substream->runtime->dma_addr,
@@ -159,97 +245,39 @@ struct dma_chan *rsnd_dma_request_channel(struct device_node *of_node,
 	return chan;
 }
 
-static struct dma_chan *rsnd_dmaen_request_channel(struct rsnd_dai_stream *io,
-						   struct rsnd_mod *mod_from,
-						   struct rsnd_mod *mod_to)
-{
-	if ((!mod_from && !mod_to) ||
-	    (mod_from && mod_to))
-		return NULL;
-
-	if (mod_from)
-		return rsnd_mod_dma_req(io, mod_from);
-	else
-		return rsnd_mod_dma_req(io, mod_to);
-}
-
-static int rsnd_dmaen_remove(struct rsnd_mod *mod,
-			      struct rsnd_dai_stream *io,
-			      struct rsnd_priv *priv)
-{
-	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
-	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
-
-	if (dmaen->chan)
-		dma_release_channel(dmaen->chan);
-
-	dmaen->chan = NULL;
-
-	return 0;
-}
-
 static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 			   struct rsnd_dma *dma,
 			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
-	struct rsnd_mod *mod = rsnd_mod_get(dma);
-	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
-	struct device *dev = rsnd_priv_to_dev(priv);
-	struct dma_slave_config cfg = {};
-	int is_play = rsnd_io_is_play(io);
-	int ret;
-
-	if (dmaen->chan) {
-		dev_err(dev, "it already has dma channel\n");
-		return -EIO;
-	}
-
-	dmaen->chan = rsnd_dmaen_request_channel(io, mod_from, mod_to);
-
-	if (IS_ERR_OR_NULL(dmaen->chan)) {
-		dmaen->chan = NULL;
-		dev_err(dev, "can't get dma channel\n");
-		goto rsnd_dma_channel_err;
+	struct dma_chan *chan;
+
+	/* try to get DMAEngine channel */
+	chan = rsnd_dmaen_request_channel(io, mod_from, mod_to);
+	if (IS_ERR_OR_NULL(chan)) {
+		/*
+		 * DMA failed. try to PIO mode
+		 * see
+		 *	rsnd_ssi_fallback()
+		 *	rsnd_rdai_continuance_probe()
+		 */
+		return -EAGAIN;
 	}
 
-	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
-	cfg.src_addr	= dma->src_addr;
-	cfg.dst_addr	= dma->dst_addr;
-	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-
-	dev_dbg(dev, "%s[%d] %pad -> %pad\n",
-		rsnd_mod_name(mod), rsnd_mod_id(mod),
-		&cfg.src_addr, &cfg.dst_addr);
-
-	ret = dmaengine_slave_config(dmaen->chan, &cfg);
-	if (ret < 0)
-		goto rsnd_dma_attach_err;
+	dma_release_channel(chan);
 
 	dmac->dmaen_num++;
 
 	return 0;
-
-rsnd_dma_attach_err:
-	rsnd_dmaen_remove(mod, io, priv);
-rsnd_dma_channel_err:
-
-	/*
-	 * DMA failed. try to PIO mode
-	 * see
-	 *	rsnd_ssi_fallback()
-	 *	rsnd_rdai_continuance_probe()
-	 */
-	return -EAGAIN;
 }
 
 static struct rsnd_mod_ops rsnd_dmaen_ops = {
 	.name	= "audmac",
+	.nolock_start = rsnd_dmaen_nolock_start,
+	.nolock_stop  = rsnd_dmaen_nolock_stop,
 	.start	= rsnd_dmaen_start,
 	.stop	= rsnd_dmaen_stop,
-	.remove	= rsnd_dmaen_remove,
 };
 
 /*
@@ -671,9 +699,6 @@ int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 
 		*dma_mod = rsnd_mod_get(dma);
 
-		dma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);
-		dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
-
 		ret = rsnd_mod_init(priv, *dma_mod, ops, NULL,
 				    rsnd_mod_get_status, type, dma_id);
 		if (ret < 0)
@@ -687,6 +712,11 @@ int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 		ret = attach(io, dma, mod_from, mod_to);
 		if (ret < 0)
 			return ret;
+
+		dma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);
+		dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
+		dma->mod_from = mod_from;
+		dma->mod_to   = mod_to;
 	}
 
 	ret = rsnd_dai_connect(*dma_mod, io, type);

commit 161ba1f1a5c99c4525eb39cc71ec984e0a39e6d7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 25 00:37:18 2016 +0000

    ASoC: rsnd: don't call unneeded of_node_put() on dma.c
    
    Current rsnd_dmaen_start() is calling of_node_put() for np,
    but it is not needed if it goes through this loop.
    This patch tidyup it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index c85a55111392..2f0327714625 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -143,19 +143,17 @@ static int rsnd_dmaen_start(struct rsnd_mod *mod,
 struct dma_chan *rsnd_dma_request_channel(struct device_node *of_node,
 					  struct rsnd_mod *mod, char *name)
 {
-	struct dma_chan *chan;
+	struct dma_chan *chan = NULL;
 	struct device_node *np;
 	int i = 0;
 
 	for_each_child_of_node(of_node, np) {
-		if (i == rsnd_mod_id(mod))
-			break;
+		if (i == rsnd_mod_id(mod) && (!chan))
+			chan = of_dma_request_slave_channel(np, name);
 		i++;
 	}
 
-	chan = of_dma_request_slave_channel(np, name);
-
-	of_node_put(np);
+	/* It should call of_node_put(), since, it is rsnd_xxx_of_node() */
 	of_node_put(of_node);
 
 	return chan;

commit dae4b83295ae50a86b5e3c60e7b6e2c597a1b69d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 25 00:36:56 2016 +0000

    ASoC: rsnd: remove rsnd_dma_detach()
    
    DMA mod is now connected to stream via rsnd_dai_connect().
    This means DMA mod can use .remove for its clearance.
    rsnd_dma_detach() is no longer needed.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index e0761cac0ab7..c85a55111392 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -698,17 +698,6 @@ int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 	return 0;
 }
 
-void rsnd_dma_detach(struct rsnd_mod *mod, struct rsnd_mod **dma_mod)
-{
-	if (*dma_mod) {
-		struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-		struct device *dev = rsnd_priv_to_dev(priv);
-
-		devm_kfree(dev, *dma_mod);
-		*dma_mod = NULL;
-	}
-}
-
 int rsnd_dma_probe(struct rsnd_priv *priv)
 {
 	struct platform_device *pdev = rsnd_priv_to_pdev(priv);

commit b99305d20122174c9fd0469bae036f0c401999b5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 25 00:36:13 2016 +0000

    ASoC: rsnd: remove non DT support for DMA
    
    Current Renesas Sound driver is based on DeviceTree, and no one is
    using this driver from non DT. Non-DT support is no longer needed.
    Let's remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index b3bdd362a511..e0761cac0ab7 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -191,7 +191,7 @@ static int rsnd_dmaen_remove(struct rsnd_mod *mod,
 }
 
 static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
-			   struct rsnd_dma *dma, int id,
+			   struct rsnd_dma *dma,
 			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
 	struct rsnd_mod *mod = rsnd_mod_get(dma);
@@ -208,17 +208,8 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 		return -EIO;
 	}
 
-	if (dev->of_node) {
-		dmaen->chan = rsnd_dmaen_request_channel(io, mod_from, mod_to);
-	} else {
-		dma_cap_mask_t mask;
-
-		dma_cap_zero(mask);
-		dma_cap_set(DMA_SLAVE, mask);
+	dmaen->chan = rsnd_dmaen_request_channel(io, mod_from, mod_to);
 
-		dmaen->chan = dma_request_channel(mask, shdma_chan_filter,
-						  (void *)(uintptr_t)id);
-	}
 	if (IS_ERR_OR_NULL(dmaen->chan)) {
 		dmaen->chan = NULL;
 		dev_err(dev, "can't get dma channel\n");
@@ -394,7 +385,7 @@ static int rsnd_dmapp_start(struct rsnd_mod *mod,
 }
 
 static int rsnd_dmapp_attach(struct rsnd_dai_stream *io,
-			     struct rsnd_dma *dma, int id,
+			     struct rsnd_dma *dma,
 			     struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
 	struct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);
@@ -627,7 +618,7 @@ static void rsnd_dma_of_path(struct rsnd_mod *this,
 }
 
 int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
-		    struct rsnd_mod **dma_mod, int id)
+		    struct rsnd_mod **dma_mod)
 {
 	struct rsnd_mod *mod_from = NULL;
 	struct rsnd_mod *mod_to = NULL;
@@ -636,7 +627,7 @@ int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct rsnd_mod_ops *ops;
 	enum rsnd_mod_type type;
-	int (*attach)(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id,
+	int (*attach)(struct rsnd_dai_stream *io, struct rsnd_dma *dma,
 		      struct rsnd_mod *mod_from, struct rsnd_mod *mod_to);
 	int is_play = rsnd_io_is_play(io);
 	int ret, dma_id;
@@ -695,7 +686,7 @@ int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 			rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
 			rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
 
-		ret = attach(io, dma, id, mod_from, mod_to);
+		ret = attach(io, dma, mod_from, mod_to);
 		if (ret < 0)
 			return ret;
 	}

commit 0af5c01a79ade438698af683511803fc11291360
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 19 03:56:26 2016 +0000

    ASoC: rsnd: amend .probe/.remove call for DPCM
    
    commit 1a5658c2131 ("ASoC: rsnd: count .probe/.remove for
    rsnd_mod_call()") solved multi-resource-free issue, by putting
    .probe/.remove under count control. But,it breaks sound mixing case
    (if it was used under DPCM). In such case, it uses MIXn/DVCn/SSIn,
    and these should be always probed.
    This patch reverted above patch, and solved the same issue by
    modifing _rsnd_kctrl_remove() function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 6bc93cbb3049..b3bdd362a511 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -707,6 +707,17 @@ int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
 	return 0;
 }
 
+void rsnd_dma_detach(struct rsnd_mod *mod, struct rsnd_mod **dma_mod)
+{
+	if (*dma_mod) {
+		struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+		struct device *dev = rsnd_priv_to_dev(priv);
+
+		devm_kfree(dev, *dma_mod);
+		*dma_mod = NULL;
+	}
+}
+
 int rsnd_dma_probe(struct rsnd_priv *priv)
 {
 	struct platform_device *pdev = rsnd_priv_to_pdev(priv);

commit ee057d2ee73259f455cfbb7a4db808fc6b6405dd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 10 02:22:37 2016 +0000

    ASoC: rsnd: don't use prohibited number to PDMACHCRn.SRS
    
    Current rsnd_dmapp_get_id() returns 0xFF as error code if system used
    strange connection. It will be used as PDMACHCRn.SRS, but 0xFF is
    prohibited number.
    In order not to use prohibited number, this patch indicates error message
    and returns 0x00 (same as SSI00) in error case.
    Special thanks to Dung-san.
    
    Reported-by: Nguyen Viet Dung <nv-dung@jinso.co.jp>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 7658e8fd7bdc..6bc93cbb3049 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -316,11 +316,15 @@ static u32 rsnd_dmapp_get_id(struct rsnd_dai_stream *io,
 		size = ARRAY_SIZE(gen2_id_table_cmd);
 	}
 
-	if (!entry)
-		return 0xFF;
+	if ((!entry) || (size <= id)) {
+		struct device *dev = rsnd_priv_to_dev(rsnd_io_to_priv(io));
 
-	if (size <= id)
-		return 0xFF;
+		dev_err(dev, "unknown connection (%s[%d])\n",
+			rsnd_mod_name(mod), rsnd_mod_id(mod));
+
+		/* use non-prohibited SRS number as error */
+		return 0x00; /* SSI00 */
+	}
 
 	return entry[id];
 }

commit 355cb84fbe1f098f80c17dad9027ad2c6aec3fa0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 21 01:58:33 2016 +0000

    ASoC: rsnd: attach Audio-DMAC-periperi correctly
    
    SSI/SRC will try to attach DMAC as Audio-DMAC or Audio-DMAC-periperi.
    It is fixed IP, but will be attached to each streams as different module
    in case of MUX (= multi sound path will be merged).
    This patch solves this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index d1cb3c177572..7658e8fd7bdc 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -622,15 +622,13 @@ static void rsnd_dma_of_path(struct rsnd_mod *this,
 	}
 }
 
-struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
-				 struct rsnd_mod *mod, int id)
+int rsnd_dma_attach(struct rsnd_dai_stream *io, struct rsnd_mod *mod,
+		    struct rsnd_mod **dma_mod, int id)
 {
-	struct rsnd_mod *dma_mod;
 	struct rsnd_mod *mod_from = NULL;
 	struct rsnd_mod *mod_to = NULL;
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
-	struct rsnd_dma *dma;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct rsnd_mod_ops *ops;
 	enum rsnd_mod_type type;
@@ -646,17 +644,10 @@ struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 	 *	rsnd_rdai_continuance_probe()
 	 */
 	if (!dmac)
-		return ERR_PTR(-EAGAIN);
-
-	dma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);
-	if (!dma)
-		return ERR_PTR(-ENOMEM);
+		return -EAGAIN;
 
 	rsnd_dma_of_path(mod, io, is_play, &mod_from, &mod_to);
 
-	dma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);
-	dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
-
 	/* for Gen2 */
 	if (mod_from && mod_to) {
 		ops	= &rsnd_dmapp_ops;
@@ -678,27 +669,38 @@ struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 		type	= RSND_MOD_AUDMA;
 	}
 
-	dma_mod = rsnd_mod_get(dma);
+	if (!(*dma_mod)) {
+		struct rsnd_dma *dma;
 
-	ret = rsnd_mod_init(priv, dma_mod,
-			    ops, NULL, rsnd_mod_get_status, type, dma_id);
-	if (ret < 0)
-		return ERR_PTR(ret);
+		dma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);
+		if (!dma)
+			return -ENOMEM;
 
-	dev_dbg(dev, "%s[%d] %s[%d] -> %s[%d]\n",
-		rsnd_mod_name(dma_mod), rsnd_mod_id(dma_mod),
-		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
-		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
+		*dma_mod = rsnd_mod_get(dma);
 
-	ret = attach(io, dma, id, mod_from, mod_to);
-	if (ret < 0)
-		return ERR_PTR(ret);
+		dma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);
+		dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
+
+		ret = rsnd_mod_init(priv, *dma_mod, ops, NULL,
+				    rsnd_mod_get_status, type, dma_id);
+		if (ret < 0)
+			return ret;
 
-	ret = rsnd_dai_connect(dma_mod, io, type);
+		dev_dbg(dev, "%s[%d] %s[%d] -> %s[%d]\n",
+			rsnd_mod_name(*dma_mod), rsnd_mod_id(*dma_mod),
+			rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
+			rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
+
+		ret = attach(io, dma, id, mod_from, mod_to);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = rsnd_dai_connect(*dma_mod, io, type);
 	if (ret < 0)
-		return ERR_PTR(ret);
+		return ret;
 
-	return rsnd_mod_get(dma);
+	return 0;
 }
 
 int rsnd_dma_probe(struct rsnd_priv *priv)

commit 5ba17b42e1755c3c5cfe96370cfd47f34d01f62c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 21 01:58:07 2016 +0000

    ASoC: rsnd: each mod has status again for CTU/MUX support
    
    SSI will be used as normal SSI or as clock parent SSI. Therefor,
    rsnd driver wants to control SSI and parent SSI separately. Otherwise it
    can't use Playback/Capture in the same time.
    And it has been done by c2dc47d5cf("ASoC: rsnd: rsnd_dai_stream has each
    mod's status insted of rsnd_mod") before.
    
    OTOH, rsnd driver doesn't want to control CTU/MUX/DVC/SSIU/SSI in
    separately. Otherwise, these will be re-initialized during playing if
    MUX merges 2 sounds.
    Because of these picky reasons, this patch re-defines status on each mod,
    and add new parent_ssi_status on rsnd_dai_stream.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 418e6fdd06a3..d1cb3c177572 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -681,7 +681,7 @@ struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 	dma_mod = rsnd_mod_get(dma);
 
 	ret = rsnd_mod_init(priv, dma_mod,
-			    ops, NULL, type, dma_id);
+			    ops, NULL, rsnd_mod_get_status, type, dma_id);
 	if (ret < 0)
 		return ERR_PTR(ret);
 

commit c90269c1fbfcb3082d379237f0912ea231e90a24
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 17 02:56:11 2015 +0000

    ASoC: rsnd: tidyup debug print position on rsnd_dma_attach()
    
    It can't output corrent dma name *before* rsnd_mod_init().
    It goes to *after* rsnd_mod_init() by this patch
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 33eb37331498..418e6fdd06a3 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -680,16 +680,16 @@ struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 
 	dma_mod = rsnd_mod_get(dma);
 
-	dev_dbg(dev, "%s[%d] %s[%d] -> %s[%d]\n",
-		rsnd_mod_name(dma_mod), rsnd_mod_id(dma_mod),
-		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
-		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
-
 	ret = rsnd_mod_init(priv, dma_mod,
 			    ops, NULL, type, dma_id);
 	if (ret < 0)
 		return ERR_PTR(ret);
 
+	dev_dbg(dev, "%s[%d] %s[%d] -> %s[%d]\n",
+		rsnd_mod_name(dma_mod), rsnd_mod_id(dma_mod),
+		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
+		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
+
 	ret = attach(io, dma, id, mod_from, mod_to);
 	if (ret < 0)
 		return ERR_PTR(ret);

commit 2ea6b0749c366787dbf6e87c7642e23b448ca63b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:14:12 2015 +0000

    ASoC: rsnd: remove struct platform_device from probe/remove parameter
    
    Current Renesas sound driver requests struct platform_device on
    probe/remove for each modules. But driver can get it by
    rsnd_priv_to_pdev(). This patch removes unnecessary parameter
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index e5f435361d96..33eb37331498 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -701,9 +701,9 @@ struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 	return rsnd_mod_get(dma);
 }
 
-int rsnd_dma_probe(struct platform_device *pdev,
-		   struct rsnd_priv *priv)
+int rsnd_dma_probe(struct rsnd_priv *priv)
 {
+	struct platform_device *pdev = rsnd_priv_to_pdev(priv);
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct rsnd_dma_ctrl *dmac;
 	struct resource *res;

commit e797f58ead6069478e535ae62b180da87b28a84f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:13:33 2015 +0000

    ASoC: rsnd: remove struct rsnd_of_data
    
    No board is using Renesas sound driver via platform boot now.
    This means all user is using DT boot. Platform boot support is
    no longer needed. But, it strongly depends on platform boot style.
    Now, platform boot style was removed from driver.
    This is cleanup patch, and remove pointless struct rsnd_of_data
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 9917b985c403..e5f435361d96 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -702,7 +702,6 @@ struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 }
 
 int rsnd_dma_probe(struct platform_device *pdev,
-		   const struct rsnd_of_data *of_data,
 		   struct rsnd_priv *priv)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);

commit 9c66eedc17bdf180d952e8d3550a23c2f93d9fff
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 28 04:31:03 2015 +0000

    ASoC: rsnd: fixup rsnd_dmapp_stop() return value
    
    45a4394d03("ASoC: rsnd: use mod base common method on DMA phase3")
    Exchanged "void rsnd_dmapp_stop()" to "int rsnd_dmapp_stop()",
    but it returns inverted value. This patch fixup it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index fc70e97500ad..9917b985c403 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -368,11 +368,11 @@ static int rsnd_dmapp_stop(struct rsnd_mod *mod,
 
 	for (i = 0; i < 1024; i++) {
 		if (0 == rsnd_dmapp_read(dma, PDMACHCR))
-			return -EIO;
+			return 0;
 		udelay(1);
 	}
 
-	return 0;
+	return -EIO;
 }
 
 static int rsnd_dmapp_start(struct rsnd_mod *mod,

commit 497debaa803e25fc0163fe4380335b8626acad44
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:43:01 2015 +0000

    ASoC: rsnd: use mod base common method on DMA phase3
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    This patch makes DMA mod bse common method
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 4905e82c3788..fc70e97500ad 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -33,9 +33,7 @@ struct rsnd_dmapp {
 };
 
 struct rsnd_dma {
-	struct rsnd_dma_ops	*ops;
 	struct rsnd_mod		mod;
-	struct rsnd_mod		*user_mod;
 	dma_addr_t		src_addr;
 	dma_addr_t		dst_addr;
 	union {
@@ -50,19 +48,6 @@ struct rsnd_dma_ctrl {
 	int dmapp_num;
 };
 
-struct rsnd_dma_ops {
-	char *name;
-	void (*start)(struct rsnd_mod *mod,
-		      struct rsnd_dai_stream *io,
-		      struct rsnd_priv *priv);
-	void (*stop)(struct rsnd_mod *mod,
-		     struct rsnd_dai_stream *io,
-		     struct rsnd_priv *priv);
-	void (*quit)(struct rsnd_mod *mod,
-		     struct rsnd_dai_stream *io,
-		     struct rsnd_priv *priv);
-};
-
 #define rsnd_priv_to_dmac(p)	((struct rsnd_dma_ctrl *)(p)->dma)
 #define rsnd_mod_to_dma(_mod) container_of((_mod), struct rsnd_dma, mod)
 #define rsnd_dma_to_dmaen(dma)	(&(dma)->dma.en)
@@ -107,23 +92,24 @@ static void rsnd_dmaen_complete(void *data)
 	rsnd_mod_interrupt(mod, __rsnd_dmaen_complete);
 }
 
-static void rsnd_dmaen_stop(struct rsnd_mod *mod,
-			    struct rsnd_dai_stream *io,
-			    struct rsnd_priv *priv)
+static int rsnd_dmaen_stop(struct rsnd_mod *mod,
+			   struct rsnd_dai_stream *io,
+			   struct rsnd_priv *priv)
 {
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 
 	dmaengine_terminate_all(dmaen->chan);
+
+	return 0;
 }
 
-static void rsnd_dmaen_start(struct rsnd_mod *mod,
-			     struct rsnd_dai_stream *io,
-			     struct rsnd_priv *priv)
+static int rsnd_dmaen_start(struct rsnd_mod *mod,
+			    struct rsnd_dai_stream *io,
+			    struct rsnd_priv *priv)
 {
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
-	struct rsnd_mod *user_mod = dma->user_mod;
 	struct snd_pcm_substream *substream = io->substream;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
@@ -138,18 +124,20 @@ static void rsnd_dmaen_start(struct rsnd_mod *mod,
 
 	if (!desc) {
 		dev_err(dev, "dmaengine_prep_slave_sg() fail\n");
-		return;
+		return -EIO;
 	}
 
 	desc->callback		= rsnd_dmaen_complete;
-	desc->callback_param	= user_mod;
+	desc->callback_param	= rsnd_mod_get(dma);
 
 	if (dmaengine_submit(desc) < 0) {
 		dev_err(dev, "dmaengine_submit() fail\n");
-		return;
+		return -EIO;
 	}
 
 	dma_async_issue_pending(dmaen->chan);
+
+	return 0;
 }
 
 struct dma_chan *rsnd_dma_request_channel(struct device_node *of_node,
@@ -187,10 +175,26 @@ static struct dma_chan *rsnd_dmaen_request_channel(struct rsnd_dai_stream *io,
 		return rsnd_mod_dma_req(io, mod_to);
 }
 
+static int rsnd_dmaen_remove(struct rsnd_mod *mod,
+			      struct rsnd_dai_stream *io,
+			      struct rsnd_priv *priv)
+{
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
+	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
+
+	if (dmaen->chan)
+		dma_release_channel(dmaen->chan);
+
+	dmaen->chan = NULL;
+
+	return 0;
+}
+
 static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 			   struct rsnd_dma *dma, int id,
 			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
+	struct rsnd_mod *mod = rsnd_mod_get(dma);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
@@ -227,8 +231,8 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
-	dev_dbg(dev, "%s %pad -> %pad\n",
-		dma->ops->name,
+	dev_dbg(dev, "%s[%d] %pad -> %pad\n",
+		rsnd_mod_name(mod), rsnd_mod_id(mod),
 		&cfg.src_addr, &cfg.dst_addr);
 
 	ret = dmaengine_slave_config(dmaen->chan, &cfg);
@@ -240,7 +244,7 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 	return 0;
 
 rsnd_dma_attach_err:
-	rsnd_dma_quit(rsnd_mod_get(dma), io, priv);
+	rsnd_dmaen_remove(mod, io, priv);
 rsnd_dma_channel_err:
 
 	/*
@@ -252,24 +256,11 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 	return -EAGAIN;
 }
 
-static void rsnd_dmaen_quit(struct rsnd_mod *mod,
-			    struct rsnd_dai_stream *io,
-			    struct rsnd_priv *priv)
-{
-	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
-	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
-
-	if (dmaen->chan)
-		dma_release_channel(dmaen->chan);
-
-	dmaen->chan = NULL;
-}
-
-static struct rsnd_dma_ops rsnd_dmaen_ops = {
+static struct rsnd_mod_ops rsnd_dmaen_ops = {
 	.name	= "audmac",
 	.start	= rsnd_dmaen_start,
 	.stop	= rsnd_dmaen_stop,
-	.quit	= rsnd_dmaen_quit,
+	.remove	= rsnd_dmaen_remove,
 };
 
 /*
@@ -366,9 +357,9 @@ static u32 rsnd_dmapp_read(struct rsnd_dma *dma, u32 reg)
 	return ioread32(rsnd_dmapp_addr(dmac, dma, reg));
 }
 
-static void rsnd_dmapp_stop(struct rsnd_mod *mod,
-			    struct rsnd_dai_stream *io,
-			    struct rsnd_priv *priv)
+static int rsnd_dmapp_stop(struct rsnd_mod *mod,
+			   struct rsnd_dai_stream *io,
+			   struct rsnd_priv *priv)
 {
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	int i;
@@ -377,14 +368,16 @@ static void rsnd_dmapp_stop(struct rsnd_mod *mod,
 
 	for (i = 0; i < 1024; i++) {
 		if (0 == rsnd_dmapp_read(dma, PDMACHCR))
-			return;
+			return -EIO;
 		udelay(1);
 	}
+
+	return 0;
 }
 
-static void rsnd_dmapp_start(struct rsnd_mod *mod,
-			     struct rsnd_dai_stream *io,
-			     struct rsnd_priv *priv)
+static int rsnd_dmapp_start(struct rsnd_mod *mod,
+			    struct rsnd_dai_stream *io,
+			    struct rsnd_priv *priv)
 {
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);
@@ -392,6 +385,8 @@ static void rsnd_dmapp_start(struct rsnd_mod *mod,
 	rsnd_dmapp_write(dma, dma->src_addr,	PDMASAR);
 	rsnd_dmapp_write(dma, dma->dst_addr,	PDMADAR);
 	rsnd_dmapp_write(dma, dmapp->chcr,	PDMACHCR);
+
+	return 0;
 }
 
 static int rsnd_dmapp_attach(struct rsnd_dai_stream *io,
@@ -414,7 +409,7 @@ static int rsnd_dmapp_attach(struct rsnd_dai_stream *io,
 	return 0;
 }
 
-static struct rsnd_dma_ops rsnd_dmapp_ops = {
+static struct rsnd_mod_ops rsnd_dmapp_ops = {
 	.name	= "audmac-pp",
 	.start	= rsnd_dmapp_start,
 	.stop	= rsnd_dmapp_stop,
@@ -627,41 +622,6 @@ static void rsnd_dma_of_path(struct rsnd_mod *this,
 	}
 }
 
-void rsnd_dma_stop(struct rsnd_mod *mod,
-		   struct rsnd_dai_stream *io,
-		   struct rsnd_priv *priv)
-
-{
-	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
-
-	dma->ops->stop(mod, io, priv);
-}
-
-void rsnd_dma_start(struct rsnd_mod *mod,
-		    struct rsnd_dai_stream *io,
-		    struct rsnd_priv *priv)
-{
-	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
-
-	dma->ops->start(mod, io, priv);
-}
-
-void rsnd_dma_quit(struct rsnd_mod *mod,
-		   struct rsnd_dai_stream *io,
-		   struct rsnd_priv *priv)
-{
-	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
-	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
-
-	if (!dmac)
-		return;
-
-	dma->ops->quit(mod, io, priv);
-}
-
-static struct rsnd_mod_ops rsnd_dma_ops = {
-};
-
 struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 				 struct rsnd_mod *mod, int id)
 {
@@ -672,6 +632,8 @@ struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct rsnd_dma *dma;
 	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_mod_ops *ops;
+	enum rsnd_mod_type type;
 	int (*attach)(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id,
 		      struct rsnd_mod *mod_from, struct rsnd_mod *mod_to);
 	int is_play = rsnd_io_is_play(io);
@@ -692,37 +654,39 @@ struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 
 	rsnd_dma_of_path(mod, io, is_play, &mod_from, &mod_to);
 
-	dma->user_mod = mod;
 	dma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);
 	dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
 
 	/* for Gen2 */
 	if (mod_from && mod_to) {
-		dma->ops = &rsnd_dmapp_ops;
+		ops	= &rsnd_dmapp_ops;
 		attach	= rsnd_dmapp_attach;
 		dma_id	= dmac->dmapp_num;
+		type	= RSND_MOD_AUDMAPP;
 	} else {
-		dma->ops = &rsnd_dmaen_ops;
+		ops	= &rsnd_dmaen_ops;
 		attach	= rsnd_dmaen_attach;
 		dma_id	= dmac->dmaen_num;
+		type	= RSND_MOD_AUDMA;
 	}
 
 	/* for Gen1, overwrite */
 	if (rsnd_is_gen1(priv)) {
-		dma->ops = &rsnd_dmaen_ops;
+		ops	= &rsnd_dmaen_ops;
 		attach	= rsnd_dmaen_attach;
 		dma_id	= dmac->dmaen_num;
+		type	= RSND_MOD_AUDMA;
 	}
 
 	dma_mod = rsnd_mod_get(dma);
 
-	dev_dbg(dev, "%s %s[%d] -> %s[%d]\n",
-		dma->ops->name,
+	dev_dbg(dev, "%s[%d] %s[%d] -> %s[%d]\n",
+		rsnd_mod_name(dma_mod), rsnd_mod_id(dma_mod),
 		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
 		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
 
 	ret = rsnd_mod_init(priv, dma_mod,
-			    &rsnd_dma_ops, NULL, 0, dma_id);
+			    ops, NULL, type, dma_id);
 	if (ret < 0)
 		return ERR_PTR(ret);
 
@@ -730,6 +694,10 @@ struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 	if (ret < 0)
 		return ERR_PTR(ret);
 
+	ret = rsnd_dai_connect(dma_mod, io, type);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
 	return rsnd_mod_get(dma);
 }
 

commit 76c80b5b3fa666da1a551c47b4597e4efaf2d8c4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:42:46 2015 +0000

    ASoC: rsnd: use mod base common method on DMA phase2
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    DMA will be implemented as module. Then rsnd_dma_ops will be rebased
    to rsnd_mod_ops, but these are similar, but different function.
    This patch modify rsnd_dma_ops same style as rsnd_mod_ops.
    This is prepare for final merge
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 45d30b8e6226..4905e82c3788 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -52,9 +52,15 @@ struct rsnd_dma_ctrl {
 
 struct rsnd_dma_ops {
 	char *name;
-	void (*start)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
-	void (*stop)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
-	void (*quit)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
+	void (*start)(struct rsnd_mod *mod,
+		      struct rsnd_dai_stream *io,
+		      struct rsnd_priv *priv);
+	void (*stop)(struct rsnd_mod *mod,
+		     struct rsnd_dai_stream *io,
+		     struct rsnd_priv *priv);
+	void (*quit)(struct rsnd_mod *mod,
+		     struct rsnd_dai_stream *io,
+		     struct rsnd_priv *priv);
 };
 
 #define rsnd_priv_to_dmac(p)	((struct rsnd_dma_ctrl *)(p)->dma)
@@ -101,18 +107,23 @@ static void rsnd_dmaen_complete(void *data)
 	rsnd_mod_interrupt(mod, __rsnd_dmaen_complete);
 }
 
-static void rsnd_dmaen_stop(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
+static void rsnd_dmaen_stop(struct rsnd_mod *mod,
+			    struct rsnd_dai_stream *io,
+			    struct rsnd_priv *priv)
 {
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 
 	dmaengine_terminate_all(dmaen->chan);
 }
 
-static void rsnd_dmaen_start(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
+static void rsnd_dmaen_start(struct rsnd_mod *mod,
+			     struct rsnd_dai_stream *io,
+			     struct rsnd_priv *priv)
 {
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	struct rsnd_mod *user_mod = dma->user_mod;
-	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct snd_pcm_substream *substream = io->substream;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
@@ -229,7 +240,7 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 	return 0;
 
 rsnd_dma_attach_err:
-	rsnd_dma_quit(io, rsnd_mod_get(dma));
+	rsnd_dma_quit(rsnd_mod_get(dma), io, priv);
 rsnd_dma_channel_err:
 
 	/*
@@ -241,8 +252,11 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 	return -EAGAIN;
 }
 
-static void rsnd_dmaen_quit(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
+static void rsnd_dmaen_quit(struct rsnd_mod *mod,
+			    struct rsnd_dai_stream *io,
+			    struct rsnd_priv *priv)
 {
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 
 	if (dmaen->chan)
@@ -352,8 +366,11 @@ static u32 rsnd_dmapp_read(struct rsnd_dma *dma, u32 reg)
 	return ioread32(rsnd_dmapp_addr(dmac, dma, reg));
 }
 
-static void rsnd_dmapp_stop(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
+static void rsnd_dmapp_stop(struct rsnd_mod *mod,
+			    struct rsnd_dai_stream *io,
+			    struct rsnd_priv *priv)
 {
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	int i;
 
 	rsnd_dmapp_write(dma, 0, PDMACHCR);
@@ -365,8 +382,11 @@ static void rsnd_dmapp_stop(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 	}
 }
 
-static void rsnd_dmapp_start(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
+static void rsnd_dmapp_start(struct rsnd_mod *mod,
+			     struct rsnd_dai_stream *io,
+			     struct rsnd_priv *priv)
 {
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);
 
 	rsnd_dmapp_write(dma, dma->src_addr,	PDMASAR);
@@ -388,8 +408,6 @@ static int rsnd_dmapp_attach(struct rsnd_dai_stream *io,
 
 	dmac->dmapp_num++;
 
-	rsnd_dmapp_stop(io, dma);
-
 	dev_dbg(dev, "id/src/dst/chcr = %d/%pad/%pad/%08x\n",
 		dmapp->dmapp_id, &dma->src_addr, &dma->dst_addr, dmapp->chcr);
 
@@ -609,30 +627,36 @@ static void rsnd_dma_of_path(struct rsnd_mod *this,
 	}
 }
 
-void rsnd_dma_stop(struct rsnd_dai_stream *io, struct rsnd_mod *mod)
+void rsnd_dma_stop(struct rsnd_mod *mod,
+		   struct rsnd_dai_stream *io,
+		   struct rsnd_priv *priv)
+
 {
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 
-	dma->ops->stop(io, dma);
+	dma->ops->stop(mod, io, priv);
 }
 
-void rsnd_dma_start(struct rsnd_dai_stream *io, struct rsnd_mod *mod)
+void rsnd_dma_start(struct rsnd_mod *mod,
+		    struct rsnd_dai_stream *io,
+		    struct rsnd_priv *priv)
 {
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 
-	dma->ops->start(io, dma);
+	dma->ops->start(mod, io, priv);
 }
 
-void rsnd_dma_quit(struct rsnd_dai_stream *io, struct rsnd_mod *mod)
+void rsnd_dma_quit(struct rsnd_mod *mod,
+		   struct rsnd_dai_stream *io,
+		   struct rsnd_priv *priv)
 {
 	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
-	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 
 	if (!dmac)
 		return;
 
-	dma->ops->quit(io, dma);
+	dma->ops->quit(mod, io, priv);
 }
 
 static struct rsnd_mod_ops rsnd_dma_ops = {

commit 940e947926cab8637e7a664e1f6e4bf8b94e42c5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:42:25 2015 +0000

    ASoC: rsnd: use mod base common method on DMA phase1
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    DMA will be implemented as module. Then rsnd_dma will be mod base.
    This patch makes rsnd_dma mod base, but still not yet completely
    finished. This mod is not yet installed to system at this point.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 697f8825215f..45d30b8e6226 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -34,7 +34,8 @@ struct rsnd_dmapp {
 
 struct rsnd_dma {
 	struct rsnd_dma_ops	*ops;
-	struct rsnd_mod		*mod;
+	struct rsnd_mod		mod;
+	struct rsnd_mod		*user_mod;
 	dma_addr_t		src_addr;
 	dma_addr_t		dst_addr;
 	union {
@@ -45,6 +46,7 @@ struct rsnd_dma {
 
 struct rsnd_dma_ctrl {
 	void __iomem *base;
+	int dmaen_num;
 	int dmapp_num;
 };
 
@@ -56,9 +58,9 @@ struct rsnd_dma_ops {
 };
 
 #define rsnd_priv_to_dmac(p)	((struct rsnd_dma_ctrl *)(p)->dma)
+#define rsnd_mod_to_dma(_mod) container_of((_mod), struct rsnd_dma, mod)
 #define rsnd_dma_to_dmaen(dma)	(&(dma)->dma.en)
 #define rsnd_dma_to_dmapp(dma)	(&(dma)->dma.pp)
-#define rsnd_dma_to_mod(_dma) ((dma)->mod)
 
 /*
  *		Audio DMAC
@@ -109,8 +111,8 @@ static void rsnd_dmaen_stop(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 static void rsnd_dmaen_start(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 {
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
-	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_mod *user_mod = dma->user_mod;
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct snd_pcm_substream *substream = io->substream;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
@@ -129,7 +131,7 @@ static void rsnd_dmaen_start(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 	}
 
 	desc->callback		= rsnd_dmaen_complete;
-	desc->callback_param	= mod;
+	desc->callback_param	= user_mod;
 
 	if (dmaengine_submit(desc) < 0) {
 		dev_err(dev, "dmaengine_submit() fail\n");
@@ -180,6 +182,7 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 {
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
+	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_slave_config cfg = {};
 	int is_play = rsnd_io_is_play(io);
@@ -221,10 +224,12 @@ static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 	if (ret < 0)
 		goto rsnd_dma_attach_err;
 
+	dmac->dmaen_num++;
+
 	return 0;
 
 rsnd_dma_attach_err:
-	rsnd_dma_quit(io, dma);
+	rsnd_dma_quit(io, rsnd_mod_get(dma));
 rsnd_dma_channel_err:
 
 	/*
@@ -328,7 +333,7 @@ static u32 rsnd_dmapp_get_chcr(struct rsnd_dai_stream *io,
 	 (0x10 * rsnd_dma_to_dmapp(dma)->dmapp_id))
 static void rsnd_dmapp_write(struct rsnd_dma *dma, u32 data, u32 reg)
 {
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_mod *mod = rsnd_mod_get(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct device *dev = rsnd_priv_to_dev(priv);
@@ -340,7 +345,7 @@ static void rsnd_dmapp_write(struct rsnd_dma *dma, u32 data, u32 reg)
 
 static u32 rsnd_dmapp_read(struct rsnd_dma *dma, u32 reg)
 {
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_mod *mod = rsnd_mod_get(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 
@@ -517,13 +522,12 @@ static dma_addr_t rsnd_dma_addr(struct rsnd_dai_stream *io,
 }
 
 #define MOD_MAX (RSND_MOD_MAX + 1) /* +Memory */
-static void rsnd_dma_of_path(struct rsnd_dma *dma,
+static void rsnd_dma_of_path(struct rsnd_mod *this,
 			     struct rsnd_dai_stream *io,
 			     int is_play,
 			     struct rsnd_mod **mod_from,
 			     struct rsnd_mod **mod_to)
 {
-	struct rsnd_mod *this = rsnd_dma_to_mod(dma);
 	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *ctu = rsnd_io_to_mod_ctu(io);
@@ -605,19 +609,23 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	}
 }
 
-void rsnd_dma_stop(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
+void rsnd_dma_stop(struct rsnd_dai_stream *io, struct rsnd_mod *mod)
 {
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
+
 	dma->ops->stop(io, dma);
 }
 
-void rsnd_dma_start(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
+void rsnd_dma_start(struct rsnd_dai_stream *io, struct rsnd_mod *mod)
 {
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
+
 	dma->ops->start(io, dma);
 }
 
-void rsnd_dma_quit(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
+void rsnd_dma_quit(struct rsnd_dai_stream *io, struct rsnd_mod *mod)
 {
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_dma *dma = rsnd_mod_to_dma(mod);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 
@@ -627,9 +635,13 @@ void rsnd_dma_quit(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 	dma->ops->quit(io, dma);
 }
 
-struct rsnd_dma *rsnd_dma_attach(struct rsnd_dai_stream *io,
+static struct rsnd_mod_ops rsnd_dma_ops = {
+};
+
+struct rsnd_mod *rsnd_dma_attach(struct rsnd_dai_stream *io,
 				 struct rsnd_mod *mod, int id)
 {
+	struct rsnd_mod *dma_mod;
 	struct rsnd_mod *mod_from = NULL;
 	struct rsnd_mod *mod_to = NULL;
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
@@ -639,7 +651,7 @@ struct rsnd_dma *rsnd_dma_attach(struct rsnd_dai_stream *io,
 	int (*attach)(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id,
 		      struct rsnd_mod *mod_from, struct rsnd_mod *mod_to);
 	int is_play = rsnd_io_is_play(io);
-	int ret;
+	int ret, dma_id;
 
 	/*
 	 * DMA failed. try to PIO mode
@@ -654,10 +666,9 @@ struct rsnd_dma *rsnd_dma_attach(struct rsnd_dai_stream *io,
 	if (!dma)
 		return ERR_PTR(-ENOMEM);
 
-	dma->mod = mod;
-
-	rsnd_dma_of_path(dma, io, is_play, &mod_from, &mod_to);
+	rsnd_dma_of_path(mod, io, is_play, &mod_from, &mod_to);
 
+	dma->user_mod = mod;
 	dma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);
 	dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
 
@@ -665,27 +676,37 @@ struct rsnd_dma *rsnd_dma_attach(struct rsnd_dai_stream *io,
 	if (mod_from && mod_to) {
 		dma->ops = &rsnd_dmapp_ops;
 		attach	= rsnd_dmapp_attach;
+		dma_id	= dmac->dmapp_num;
 	} else {
 		dma->ops = &rsnd_dmaen_ops;
 		attach	= rsnd_dmaen_attach;
+		dma_id	= dmac->dmaen_num;
 	}
 
 	/* for Gen1, overwrite */
 	if (rsnd_is_gen1(priv)) {
 		dma->ops = &rsnd_dmaen_ops;
 		attach	= rsnd_dmaen_attach;
+		dma_id	= dmac->dmaen_num;
 	}
 
+	dma_mod = rsnd_mod_get(dma);
+
 	dev_dbg(dev, "%s %s[%d] -> %s[%d]\n",
 		dma->ops->name,
 		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
 		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
 
+	ret = rsnd_mod_init(priv, dma_mod,
+			    &rsnd_dma_ops, NULL, 0, dma_id);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
 	ret = attach(io, dma, id, mod_from, mod_to);
 	if (ret < 0)
 		return ERR_PTR(ret);
 
-	return dma;
+	return rsnd_mod_get(dma);
 }
 
 int rsnd_dma_probe(struct platform_device *pdev,

commit 40854c648ee79019a90034fc1f73ba2822812099
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:40:19 2015 +0000

    ASoC: rsnd: fixup rsnd_dma_of_path method for mod base common method
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    Current rsnd_dma_of_path is assuming that all mods are related to DMA.
    But it will be wrong. This patch tidyup this wrong assumption
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 705e524b0892..697f8825215f 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -533,7 +533,7 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	struct rsnd_mod *mod_start, *mod_end;
 	struct rsnd_priv *priv = rsnd_mod_to_priv(this);
 	struct device *dev = rsnd_priv_to_dev(priv);
-	int nr, i;
+	int nr, i, idx;
 
 	if (!ssi)
 		return;
@@ -562,23 +562,24 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	mod_start	= (is_play) ? NULL : ssi;
 	mod_end		= (is_play) ? ssi  : NULL;
 
-	mod[0] = mod_start;
+	idx = 0;
+	mod[idx++] = mod_start;
 	for (i = 1; i < nr; i++) {
 		if (src) {
-			mod[i] = src;
+			mod[idx++] = src;
 			src = NULL;
 		} else if (ctu) {
-			mod[i] = ctu;
+			mod[idx++] = ctu;
 			ctu = NULL;
 		} else if (mix) {
-			mod[i] = mix;
+			mod[idx++] = mix;
 			mix = NULL;
 		} else if (dvc) {
-			mod[i] = dvc;
+			mod[idx++] = dvc;
 			dvc = NULL;
 		}
 	}
-	mod[i] = mod_end;
+	mod[idx] = mod_end;
 
 	/*
 	 *		| SSI | SRC |
@@ -587,8 +588,8 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	 * !is_play	|  *  |  o  |
 	 */
 	if ((this == ssi) == (is_play)) {
-		*mod_from	= mod[nr - 1];
-		*mod_to		= mod[nr];
+		*mod_from	= mod[idx - 1];
+		*mod_to		= mod[idx];
 	} else {
 		*mod_from	= mod[0];
 		*mod_to		= mod[1];
@@ -596,7 +597,7 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 
 	dev_dbg(dev, "module connection (this is %s[%d])\n",
 		rsnd_mod_name(this), rsnd_mod_id(this));
-	for (i = 0; i <= nr; i++) {
+	for (i = 0; i <= idx; i++) {
 		dev_dbg(dev, "  %s[%d]%s\n",
 		       rsnd_mod_name(mod[i]), rsnd_mod_id(mod[i]),
 		       (mod[i] == *mod_from) ? " from" :

commit 81ecbb654e1015840dec6a1ef3fcfef34d28feed
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:39:20 2015 +0000

    ASoC: rsnd: rename rsnd_dma_init() to rsnd_dma_attach()
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    DMA will be implemented as module. Then each rsnd_dma_ops will be
    rsnd_mod_ops. But current rsnd_dma_ops::init means "DMA attach".
    This patch removes .init from rsnd_dma_ops, and renames
    rsnd_dma_init() to rsnd_dma_attach()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 00e83e0670e7..705e524b0892 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -52,8 +52,6 @@ struct rsnd_dma_ops {
 	char *name;
 	void (*start)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
 	void (*stop)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
-	int (*init)(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id,
-		    struct rsnd_mod *mod_from, struct rsnd_mod *mod_to);
 	void (*quit)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
 };
 
@@ -176,7 +174,7 @@ static struct dma_chan *rsnd_dmaen_request_channel(struct rsnd_dai_stream *io,
 		return rsnd_mod_dma_req(io, mod_to);
 }
 
-static int rsnd_dmaen_init(struct rsnd_dai_stream *io,
+static int rsnd_dmaen_attach(struct rsnd_dai_stream *io,
 			   struct rsnd_dma *dma, int id,
 			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
@@ -221,11 +219,11 @@ static int rsnd_dmaen_init(struct rsnd_dai_stream *io,
 
 	ret = dmaengine_slave_config(dmaen->chan, &cfg);
 	if (ret < 0)
-		goto rsnd_dma_init_err;
+		goto rsnd_dma_attach_err;
 
 	return 0;
 
-rsnd_dma_init_err:
+rsnd_dma_attach_err:
 	rsnd_dma_quit(io, dma);
 rsnd_dma_channel_err:
 
@@ -252,7 +250,6 @@ static struct rsnd_dma_ops rsnd_dmaen_ops = {
 	.name	= "audmac",
 	.start	= rsnd_dmaen_start,
 	.stop	= rsnd_dmaen_stop,
-	.init	= rsnd_dmaen_init,
 	.quit	= rsnd_dmaen_quit,
 };
 
@@ -372,9 +369,9 @@ static void rsnd_dmapp_start(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 	rsnd_dmapp_write(dma, dmapp->chcr,	PDMACHCR);
 }
 
-static int rsnd_dmapp_init(struct rsnd_dai_stream *io,
-			   struct rsnd_dma *dma, int id,
-			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
+static int rsnd_dmapp_attach(struct rsnd_dai_stream *io,
+			     struct rsnd_dma *dma, int id,
+			     struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
 	struct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
@@ -398,7 +395,6 @@ static struct rsnd_dma_ops rsnd_dmapp_ops = {
 	.name	= "audmac-pp",
 	.start	= rsnd_dmapp_start,
 	.stop	= rsnd_dmapp_stop,
-	.init	= rsnd_dmapp_init,
 	.quit	= rsnd_dmapp_stop,
 };
 
@@ -630,8 +626,8 @@ void rsnd_dma_quit(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 	dma->ops->quit(io, dma);
 }
 
-struct rsnd_dma *rsnd_dma_init(struct rsnd_dai_stream *io,
-			       struct rsnd_mod *mod, int id)
+struct rsnd_dma *rsnd_dma_attach(struct rsnd_dai_stream *io,
+				 struct rsnd_mod *mod, int id)
 {
 	struct rsnd_mod *mod_from = NULL;
 	struct rsnd_mod *mod_to = NULL;
@@ -639,6 +635,8 @@ struct rsnd_dma *rsnd_dma_init(struct rsnd_dai_stream *io,
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct rsnd_dma *dma;
 	struct device *dev = rsnd_priv_to_dev(priv);
+	int (*attach)(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id,
+		      struct rsnd_mod *mod_from, struct rsnd_mod *mod_to);
 	int is_play = rsnd_io_is_play(io);
 	int ret;
 
@@ -663,21 +661,26 @@ struct rsnd_dma *rsnd_dma_init(struct rsnd_dai_stream *io,
 	dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
 
 	/* for Gen2 */
-	if (mod_from && mod_to)
+	if (mod_from && mod_to) {
 		dma->ops = &rsnd_dmapp_ops;
-	else
+		attach	= rsnd_dmapp_attach;
+	} else {
 		dma->ops = &rsnd_dmaen_ops;
+		attach	= rsnd_dmaen_attach;
+	}
 
 	/* for Gen1, overwrite */
-	if (rsnd_is_gen1(priv))
+	if (rsnd_is_gen1(priv)) {
 		dma->ops = &rsnd_dmaen_ops;
+		attach	= rsnd_dmaen_attach;
+	}
 
 	dev_dbg(dev, "%s %s[%d] -> %s[%d]\n",
 		dma->ops->name,
 		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
 		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
 
-	ret = dma->ops->init(io, dma, id, mod_from, mod_to);
+	ret = attach(io, dma, id, mod_from, mod_to);
 	if (ret < 0)
 		return ERR_PTR(ret);
 

commit 3e5afa73a9fb4001789508d6f9f0fca3e3475f5a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:38:58 2015 +0000

    ASoC: rsnd: DMA related definition goes to dma.c
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    DMA will be implemented as module. Current DMA definition is no longer
    needed on rsnd.h. Let's move it to dma.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 923120c7b250..00e83e0670e7 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -22,6 +22,27 @@
 /* PDMACHCR */
 #define PDMACHCR_DE		(1 << 0)
 
+
+struct rsnd_dmaen {
+	struct dma_chan		*chan;
+};
+
+struct rsnd_dmapp {
+	int			dmapp_id;
+	u32			chcr;
+};
+
+struct rsnd_dma {
+	struct rsnd_dma_ops	*ops;
+	struct rsnd_mod		*mod;
+	dma_addr_t		src_addr;
+	dma_addr_t		dst_addr;
+	union {
+		struct rsnd_dmaen en;
+		struct rsnd_dmapp pp;
+	} dma;
+};
+
 struct rsnd_dma_ctrl {
 	void __iomem *base;
 	int dmapp_num;
@@ -37,6 +58,9 @@ struct rsnd_dma_ops {
 };
 
 #define rsnd_priv_to_dmac(p)	((struct rsnd_dma_ctrl *)(p)->dma)
+#define rsnd_dma_to_dmaen(dma)	(&(dma)->dma.en)
+#define rsnd_dma_to_dmapp(dma)	(&(dma)->dma.pp)
+#define rsnd_dma_to_mod(_dma) ((dma)->mod)
 
 /*
  *		Audio DMAC

commit 232c00b6e55558c216cbf50358549a1967ee1419
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:38:26 2015 +0000

    ASoC: rsnd: DMA become SSI/SRC member
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    Current rsnd_mod is member of rsnd_mod. But the DMA user is only
    SSI/SRC. This DMA will be implemented as module. As 1st step, DMA
    become SSI/SRC member by this patch.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 5d084d040961..923120c7b250 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -606,14 +606,17 @@ void rsnd_dma_quit(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 	dma->ops->quit(io, dma);
 }
 
-int rsnd_dma_init(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id)
+struct rsnd_dma *rsnd_dma_init(struct rsnd_dai_stream *io,
+			       struct rsnd_mod *mod, int id)
 {
 	struct rsnd_mod *mod_from = NULL;
 	struct rsnd_mod *mod_to = NULL;
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
+	struct rsnd_dma *dma;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	int is_play = rsnd_io_is_play(io);
+	int ret;
 
 	/*
 	 * DMA failed. try to PIO mode
@@ -622,7 +625,13 @@ int rsnd_dma_init(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id)
 	 *	rsnd_rdai_continuance_probe()
 	 */
 	if (!dmac)
-		return -EAGAIN;
+		return ERR_PTR(-EAGAIN);
+
+	dma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);
+	if (!dma)
+		return ERR_PTR(-ENOMEM);
+
+	dma->mod = mod;
 
 	rsnd_dma_of_path(dma, io, is_play, &mod_from, &mod_to);
 
@@ -644,7 +653,11 @@ int rsnd_dma_init(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id)
 		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
 		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
 
-	return dma->ops->init(io, dma, id, mod_from, mod_to);
+	ret = dma->ops->init(io, dma, id, mod_from, mod_to);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	return dma;
 }
 
 int rsnd_dma_probe(struct platform_device *pdev,

commit b415b4d3122a466f3a73d86a1dd2dcdc13de7ef3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Oct 22 03:15:46 2015 +0000

    ASoC: rsnd: remove duplicate parameter from rsnd_ssi_xxx()
    
    rsnd_ssi_use_busif() and rsnd_ssi_is_pin_sharing() are the function
    which returns current SSI status. But these requests duplicated parameter.
    This patch removes duplicated parameter.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index bfbb8a5e93bd..5d084d040961 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -470,7 +470,7 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 		dev_err(dev, "DVC is selected without SRC\n");
 
 	/* use SSIU or SSI ? */
-	if (is_ssi && rsnd_ssi_use_busif(io, mod))
+	if (is_ssi && rsnd_ssi_use_busif(io))
 		is_ssi++;
 
 	return (is_from) ?

commit 1af2cc64b18c29f1d774caa7e592c781bee6a7eb
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Aug 11 14:47:18 2015 +0200

    ASoC: rsnd: Silence DMA slave ID compile warning on 64-bit
    
    On arm64:
    
        sound/soc/sh/rcar/dma.c: In function 'rsnd_dmaen_init':
        sound/soc/sh/rcar/dma.c:180:9: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]
                 (void *)id);
                 ^
        include/linux/dmaengine.h:1185:75: note: in definition of macro 'dma_request_channel'
         #define dma_request_channel(mask, x, y) __dma_request_channel(&(mask), x, y)
                                                                                   ^
    
    Add an intermediate cast to "uintptr_t" to kill the compile warning.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 305b12929853..bfbb8a5e93bd 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -177,7 +177,7 @@ static int rsnd_dmaen_init(struct rsnd_dai_stream *io,
 		dma_cap_set(DMA_SLAVE, mask);
 
 		dmaen->chan = dma_request_channel(mask, shdma_chan_filter,
-						  (void *)id);
+						  (void *)(uintptr_t)id);
 	}
 	if (IS_ERR_OR_NULL(dmaen->chan)) {
 		dmaen->chan = NULL;

commit 70fb10529f61c31c26397a02091177bedd23217d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:17:36 2015 +0000

    ASoC: rsnd: add MIX (Mixer) support
    
    This patch adds MIX (Mixer) initial support for rsnd driver.
    It is assuming that this MIX is used via DPCM.
    
    This is sample code for playback.
    
            CPU0  : [MEM] -> [SRC1] -> [CTU02] -+
                                                |
                                                +-> [MIX0] -> [DVC0] -> [SSI0]
                                                |
            CPU1  : [MEM] -> [SRC2] -> [CTU03] -+
    
            sound {
                    compatible = "renesas,rsrc-card";
    
                    ...
    
                    cpu@0 {
                            sound-dai = <&rcar_sound 0>;
                    };
    
                    cpu@1 {
                            sound-dai = <&rcar_sound 1>;
                    };
    
                    codec {
                            ...
                    };
            };
    
            rcar_sound {
    
                    ...
    
                    rcar_sound,dai {
                            dai0 {
                                    playback = <&src1 &ctu02 &mix0 &dvc0 &ssi0>;
                            };
                            dai1 {
                                    playback = <&src2 &ctu03 &mix0 &dvc0 &ssi0>;
                            };
                    };
            };
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 229b68d2cf70..305b12929853 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -427,6 +427,7 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 	int is_ssi = !!(rsnd_io_to_mod_ssi(io) == mod);
 	int use_src = !!rsnd_io_to_mod_src(io);
 	int use_cmd = !!rsnd_io_to_mod_dvc(io) ||
+		      !!rsnd_io_to_mod_mix(io) ||
 		      !!rsnd_io_to_mod_ctu(io);
 	int id = rsnd_mod_id(mod);
 	struct dma_addr {
@@ -506,6 +507,7 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *ctu = rsnd_io_to_mod_ctu(io);
+	struct rsnd_mod *mix = rsnd_io_to_mod_mix(io);
 	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
 	struct rsnd_mod *mod[MOD_MAX];
 	struct rsnd_mod *mod_start, *mod_end;
@@ -548,6 +550,9 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 		} else if (ctu) {
 			mod[i] = ctu;
 			ctu = NULL;
+		} else if (mix) {
+			mod[i] = mix;
+			mix = NULL;
 		} else if (dvc) {
 			mod[i] = dvc;
 			dvc = NULL;

commit 9269e3c3cfac277a49b485e27ac6850f9a11a259
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:17:17 2015 +0000

    ASoC: rsnd: add CTU (Channel Transfer Unit) prototype support
    
    This patch adds CTU (Channel Transfer Unit) support for rsnd driver.
    But, it does nothing to data at this point, but is required for MIX
    support.
    
    CTU design is a little different from other IPs (CTU0 is including
    CTU00 - CTU03, and CTU1 is including CTU10 - CTU13, these have different
    register mapping) We need to care about it on this driver.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 23282f48f71f..229b68d2cf70 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -426,7 +426,8 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 	phys_addr_t src_reg = rsnd_gen_get_phy_addr(priv, RSND_GEN2_SCU);
 	int is_ssi = !!(rsnd_io_to_mod_ssi(io) == mod);
 	int use_src = !!rsnd_io_to_mod_src(io);
-	int use_dvc = !!rsnd_io_to_mod_dvc(io);
+	int use_cmd = !!rsnd_io_to_mod_dvc(io) ||
+		      !!rsnd_io_to_mod_ctu(io);
 	int id = rsnd_mod_id(mod);
 	struct dma_addr {
 		dma_addr_t out_addr;
@@ -464,7 +465,7 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 	};
 
 	/* it shouldn't happen */
-	if (use_dvc && !use_src)
+	if (use_cmd && !use_src)
 		dev_err(dev, "DVC is selected without SRC\n");
 
 	/* use SSIU or SSI ? */
@@ -472,8 +473,8 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 		is_ssi++;
 
 	return (is_from) ?
-		dma_addrs[is_ssi][is_play][use_src + use_dvc].out_addr :
-		dma_addrs[is_ssi][is_play][use_src + use_dvc].in_addr;
+		dma_addrs[is_ssi][is_play][use_src + use_cmd].out_addr :
+		dma_addrs[is_ssi][is_play][use_src + use_cmd].in_addr;
 }
 
 static dma_addr_t rsnd_dma_addr(struct rsnd_dai_stream *io,
@@ -504,6 +505,7 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	struct rsnd_mod *this = rsnd_dma_to_mod(dma);
 	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
+	struct rsnd_mod *ctu = rsnd_io_to_mod_ctu(io);
 	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
 	struct rsnd_mod *mod[MOD_MAX];
 	struct rsnd_mod *mod_start, *mod_end;
@@ -543,6 +545,9 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 		if (src) {
 			mod[i] = src;
 			src = NULL;
+		} else if (ctu) {
+			mod[i] = ctu;
+			ctu = NULL;
 		} else if (dvc) {
 			mod[i] = dvc;
 			dvc = NULL;

commit 7dfb49194557ccf27ab99c8c04c021320e7ae458
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:16:56 2015 +0000

    ASoC: rsnd: update Audio DMA path search method
    
    Current rsnd driver is assuming Audio DMAC / Audio DMAC peri peri
    are used from SSI/SSIU/SRC/DVC. But we will add CTU/MIX to this driver.
    Then, current DMA path searching method is not understandable, and good
    enough for this purpose. This patch update DMA path search method, more
    simply.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index a175863d239c..23282f48f71f 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -494,7 +494,7 @@ static dma_addr_t rsnd_dma_addr(struct rsnd_dai_stream *io,
 	return rsnd_gen2_dma_addr(io, mod, is_play, is_from);
 }
 
-#define MOD_MAX 4 /* MEM/SSI/SRC/DVC */
+#define MOD_MAX (RSND_MOD_MAX + 1) /* +Memory */
 static void rsnd_dma_of_path(struct rsnd_dma *dma,
 			     struct rsnd_dai_stream *io,
 			     int is_play,
@@ -506,53 +506,71 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
 	struct rsnd_mod *mod[MOD_MAX];
-	int i, index;
+	struct rsnd_mod *mod_start, *mod_end;
+	struct rsnd_priv *priv = rsnd_mod_to_priv(this);
+	struct device *dev = rsnd_priv_to_dev(priv);
+	int nr, i;
 
+	if (!ssi)
+		return;
 
-	for (i = 0; i < MOD_MAX; i++)
+	nr = 0;
+	for (i = 0; i < MOD_MAX; i++) {
 		mod[i] = NULL;
+		nr += !!rsnd_io_to_mod(io, i);
+	}
 
 	/*
-	 * in play case...
+	 * [S] -*-> [E]
+	 * [S] -*-> SRC -o-> [E]
+	 * [S] -*-> SRC -> DVC -o-> [E]
+	 * [S] -*-> SRC -> CTU -> MIX -> DVC -o-> [E]
+	 *
+	 * playback	[S] = mem
+	 *		[E] = SSI
 	 *
-	 * src -> dst
+	 * capture	[S] = SSI
+	 *		[E] = mem
 	 *
-	 * mem -> SSI
-	 * mem -> SRC -> SSI
-	 * mem -> SRC -> DVC -> SSI
+	 * -*->		Audio DMAC
+	 * -o->		Audio DMAC peri peri
 	 */
-	mod[0] = NULL; /* for "mem" */
-	index = 1;
-	for (i = 1; i < MOD_MAX; i++) {
-		if (!src) {
-			mod[i] = ssi;
-		} else if (!dvc) {
-			mod[i] = src;
-			src = NULL;
-		} else {
-			if ((!is_play) && (this == src))
-				this = dvc;
+	mod_start	= (is_play) ? NULL : ssi;
+	mod_end		= (is_play) ? ssi  : NULL;
 
-			mod[i] = (is_play) ? src : dvc;
-			i++;
-			mod[i] = (is_play) ? dvc : src;
+	mod[0] = mod_start;
+	for (i = 1; i < nr; i++) {
+		if (src) {
+			mod[i] = src;
 			src = NULL;
+		} else if (dvc) {
+			mod[i] = dvc;
 			dvc = NULL;
 		}
-
-		if (mod[i] == this)
-			index = i;
-
-		if (mod[i] == ssi)
-			break;
 	}
+	mod[i] = mod_end;
 
-	if (is_play) {
-		*mod_from = mod[index - 1];
-		*mod_to   = mod[index];
+	/*
+	 *		| SSI | SRC |
+	 * -------------+-----+-----+
+	 *  is_play	|  o  |  *  |
+	 * !is_play	|  *  |  o  |
+	 */
+	if ((this == ssi) == (is_play)) {
+		*mod_from	= mod[nr - 1];
+		*mod_to		= mod[nr];
 	} else {
-		*mod_from = mod[index];
-		*mod_to   = mod[index - 1];
+		*mod_from	= mod[0];
+		*mod_to		= mod[1];
+	}
+
+	dev_dbg(dev, "module connection (this is %s[%d])\n",
+		rsnd_mod_name(this), rsnd_mod_id(this));
+	for (i = 0; i <= nr; i++) {
+		dev_dbg(dev, "  %s[%d]%s\n",
+		       rsnd_mod_name(mod[i]), rsnd_mod_id(mod[i]),
+		       (mod[i] == *mod_from) ? " from" :
+		       (mod[i] == *mod_to)   ? " to" : "");
 	}
 }
 
@@ -580,8 +598,8 @@ void rsnd_dma_quit(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 
 int rsnd_dma_init(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id)
 {
-	struct rsnd_mod *mod_from;
-	struct rsnd_mod *mod_to;
+	struct rsnd_mod *mod_from = NULL;
+	struct rsnd_mod *mod_to = NULL;
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct device *dev = rsnd_priv_to_dev(priv);

commit ddea1b2e83c379840aa54fadc587e418cf986ccb
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:16:03 2015 +0000

    ASoC: rsnd: dma: add DMA name on .ops
    
    Current rsnd driver is using Audio DMAC (via DMAEngine) and
    Audio DMAC peri peri (via original method), and usage of these DMAC
    are different. Indicates its naming is useful for debugging.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 943106136d99..a175863d239c 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -28,6 +28,7 @@ struct rsnd_dma_ctrl {
 };
 
 struct rsnd_dma_ops {
+	char *name;
 	void (*start)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
 	void (*stop)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
 	int (*init)(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id,
@@ -190,7 +191,8 @@ static int rsnd_dmaen_init(struct rsnd_dai_stream *io,
 	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
-	dev_dbg(dev, "dma : %pad -> %pad\n",
+	dev_dbg(dev, "%s %pad -> %pad\n",
+		dma->ops->name,
 		&cfg.src_addr, &cfg.dst_addr);
 
 	ret = dmaengine_slave_config(dmaen->chan, &cfg);
@@ -223,6 +225,7 @@ static void rsnd_dmaen_quit(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 }
 
 static struct rsnd_dma_ops rsnd_dmaen_ops = {
+	.name	= "audmac",
 	.start	= rsnd_dmaen_start,
 	.stop	= rsnd_dmaen_stop,
 	.init	= rsnd_dmaen_init,
@@ -368,6 +371,7 @@ static int rsnd_dmapp_init(struct rsnd_dai_stream *io,
 }
 
 static struct rsnd_dma_ops rsnd_dmapp_ops = {
+	.name	= "audmac-pp",
 	.start	= rsnd_dmapp_start,
 	.stop	= rsnd_dmapp_stop,
 	.init	= rsnd_dmapp_init,
@@ -580,6 +584,7 @@ int rsnd_dma_init(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id)
 	struct rsnd_mod *mod_to;
 	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
+	struct device *dev = rsnd_priv_to_dev(priv);
 	int is_play = rsnd_io_is_play(io);
 
 	/*
@@ -606,6 +611,11 @@ int rsnd_dma_init(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id)
 	if (rsnd_is_gen1(priv))
 		dma->ops = &rsnd_dmaen_ops;
 
+	dev_dbg(dev, "%s %s[%d] -> %s[%d]\n",
+		dma->ops->name,
+		rsnd_mod_name(mod_from), rsnd_mod_id(mod_from),
+		rsnd_mod_name(mod_to),   rsnd_mod_id(mod_to));
+
 	return dma->ops->init(io, dma, id, mod_from, mod_to);
 }
 

commit 98d358af07aa6fc4cd6cdfd3256ab792eb3675cd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:15:27 2015 +0000

    ASoC: rsnd: tidyup rsnd_dma_ops definition place
    
    rsnd_dma_ops is used only from dma.c, rsnd.h doesn't need it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index d306e298c63d..943106136d99 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -27,6 +27,14 @@ struct rsnd_dma_ctrl {
 	int dmapp_num;
 };
 
+struct rsnd_dma_ops {
+	void (*start)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
+	void (*stop)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
+	int (*init)(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id,
+		    struct rsnd_mod *mod_from, struct rsnd_mod *mod_to);
+	void (*quit)(struct rsnd_dai_stream *io, struct rsnd_dma *dma);
+};
+
 #define rsnd_priv_to_dmac(p)	((struct rsnd_dma_ctrl *)(p)->dma)
 
 /*

commit 71d8c2d78351a3c2fe6b432f1d5efd78327c97d8
Merge: 861fe717256e bdb052e81f62 8a4e379b54f8 bc08f96b5fa7 b895dc2c47c3
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jun 22 10:24:33 2015 +0100

    Merge remote-tracking branches 'asoc/topic/qcom', 'asoc/topic/rcar', 'asoc/topic/rt286' and 'asoc/topic/rt5640' into asoc-next

commit d5bbe7de563ccce62765f1183561218b6dbdbe1e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:27:47 2015 +0000

    ASoC: rsnd: move rsnd_mod_is_working() to rsnd_io_is_working()
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship.
    This patch checks module working status via io instead of mod
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 6ee34fcc0d68..375a9dc33bca 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -52,7 +52,7 @@ static void __rsnd_dmaen_complete(struct rsnd_mod *mod,
 	 */
 	spin_lock_irqsave(&priv->lock, flags);
 
-	if (rsnd_mod_is_working(mod))
+	if (rsnd_io_is_working(io))
 		elapsed = rsnd_dai_pointer_update(io, io->byte_per_period);
 
 	spin_unlock_irqrestore(&priv->lock, flags);

commit bfc0cfe6b7acb1d0c318f9bc41fcb895a941f83d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:26:56 2015 +0000

    ASoC: rsnd: don't use rsnd_mod_to_io() on rsnd_ssi_xxx()
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship. This patch removes rsnd_mod_to_io() from rsnd_ssi_xxx()
    and related function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index bdd99f582bb1..6ee34fcc0d68 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -455,7 +455,7 @@ rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 		dev_err(dev, "DVC is selected without SRC\n");
 
 	/* use SSIU or SSI ? */
-	if (is_ssi && rsnd_ssi_use_busif(mod))
+	if (is_ssi && rsnd_ssi_use_busif(io, mod))
 		is_ssi++;
 
 	return (is_from) ?

commit 9b99e9a7c5057684104178bb6c3815fcb2f13be4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:26:25 2015 +0000

    ASoC: rsnd: don't use rsnd_mod_to_io() on rsnd_dma_xxx()
    
    Each Renesas sound mod (= SSI/SRC/DVC) might be called from many paths
    if it supports MIXer. In such case, mod <-> io is no longer 1:1
    relationship. This patch removes rsnd_mod_to_io() from rsnd_dma_xxx()
    and related function
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 9034f951adfe..bdd99f582bb1 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -32,12 +32,10 @@ struct rsnd_dma_ctrl {
 /*
  *		Audio DMAC
  */
-static void rsnd_dmaen_complete(void *data)
+static void __rsnd_dmaen_complete(struct rsnd_mod *mod,
+				  struct rsnd_dai_stream *io)
 {
-	struct rsnd_dma *dma = (struct rsnd_dma *)data;
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	bool elapsed = false;
 	unsigned long flags;
 
@@ -54,7 +52,8 @@ static void rsnd_dmaen_complete(void *data)
 	 */
 	spin_lock_irqsave(&priv->lock, flags);
 
-	elapsed = rsnd_dai_pointer_update(io, io->byte_per_period);
+	if (rsnd_mod_is_working(mod))
+		elapsed = rsnd_dai_pointer_update(io, io->byte_per_period);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
@@ -62,19 +61,25 @@ static void rsnd_dmaen_complete(void *data)
 		rsnd_dai_period_elapsed(io);
 }
 
-static void rsnd_dmaen_stop(struct rsnd_dma *dma)
+static void rsnd_dmaen_complete(void *data)
+{
+	struct rsnd_mod *mod = data;
+
+	rsnd_mod_interrupt(mod, __rsnd_dmaen_complete);
+}
+
+static void rsnd_dmaen_stop(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 {
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 
 	dmaengine_terminate_all(dmaen->chan);
 }
 
-static void rsnd_dmaen_start(struct rsnd_dma *dma)
+static void rsnd_dmaen_start(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 {
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	struct snd_pcm_substream *substream = io->substream;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
@@ -93,7 +98,7 @@ static void rsnd_dmaen_start(struct rsnd_dma *dma)
 	}
 
 	desc->callback		= rsnd_dmaen_complete;
-	desc->callback_param	= dma;
+	desc->callback_param	= mod;
 
 	if (dmaengine_submit(desc) < 0) {
 		dev_err(dev, "dmaengine_submit() fail\n");
@@ -124,7 +129,8 @@ struct dma_chan *rsnd_dma_request_channel(struct device_node *of_node,
 	return chan;
 }
 
-static struct dma_chan *rsnd_dmaen_request_channel(struct rsnd_mod *mod_from,
+static struct dma_chan *rsnd_dmaen_request_channel(struct rsnd_dai_stream *io,
+						   struct rsnd_mod *mod_from,
 						   struct rsnd_mod *mod_to)
 {
 	if ((!mod_from && !mod_to) ||
@@ -132,19 +138,19 @@ static struct dma_chan *rsnd_dmaen_request_channel(struct rsnd_mod *mod_from,
 		return NULL;
 
 	if (mod_from)
-		return rsnd_mod_dma_req(mod_from);
+		return rsnd_mod_dma_req(io, mod_from);
 	else
-		return rsnd_mod_dma_req(mod_to);
+		return rsnd_mod_dma_req(io, mod_to);
 }
 
-static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
+static int rsnd_dmaen_init(struct rsnd_dai_stream *io,
+			   struct rsnd_dma *dma, int id,
 			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_slave_config cfg = {};
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	int is_play = rsnd_io_is_play(io);
 	int ret;
 
@@ -154,7 +160,7 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	}
 
 	if (dev->of_node) {
-		dmaen->chan = rsnd_dmaen_request_channel(mod_from, mod_to);
+		dmaen->chan = rsnd_dmaen_request_channel(io, mod_from, mod_to);
 	} else {
 		dma_cap_mask_t mask;
 
@@ -185,7 +191,7 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	return 0;
 
 rsnd_dma_init_err:
-	rsnd_dma_quit(dma);
+	rsnd_dma_quit(io, dma);
 rsnd_dma_channel_err:
 
 	/*
@@ -197,7 +203,7 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	return -EAGAIN;
 }
 
-static void rsnd_dmaen_quit(struct rsnd_dma *dma)
+static void rsnd_dmaen_quit(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 {
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 
@@ -246,9 +252,9 @@ static const u8 gen2_id_table_cmd[] = {
 	0x38, /* SCU_CMD1 */
 };
 
-static u32 rsnd_dmapp_get_id(struct rsnd_mod *mod)
+static u32 rsnd_dmapp_get_id(struct rsnd_dai_stream *io,
+			     struct rsnd_mod *mod)
 {
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
@@ -276,11 +282,12 @@ static u32 rsnd_dmapp_get_id(struct rsnd_mod *mod)
 	return entry[id];
 }
 
-static u32 rsnd_dmapp_get_chcr(struct rsnd_mod *mod_from,
+static u32 rsnd_dmapp_get_chcr(struct rsnd_dai_stream *io,
+			       struct rsnd_mod *mod_from,
 			       struct rsnd_mod *mod_to)
 {
-	return	(rsnd_dmapp_get_id(mod_from) << 24) +
-		(rsnd_dmapp_get_id(mod_to) << 16);
+	return	(rsnd_dmapp_get_id(io, mod_from) << 24) +
+		(rsnd_dmapp_get_id(io, mod_to) << 16);
 }
 
 #define rsnd_dmapp_addr(dmac, dma, reg) \
@@ -307,7 +314,7 @@ static u32 rsnd_dmapp_read(struct rsnd_dma *dma, u32 reg)
 	return ioread32(rsnd_dmapp_addr(dmac, dma, reg));
 }
 
-static void rsnd_dmapp_stop(struct rsnd_dma *dma)
+static void rsnd_dmapp_stop(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 {
 	int i;
 
@@ -320,7 +327,7 @@ static void rsnd_dmapp_stop(struct rsnd_dma *dma)
 	}
 }
 
-static void rsnd_dmapp_start(struct rsnd_dma *dma)
+static void rsnd_dmapp_start(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 {
 	struct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);
 
@@ -329,19 +336,21 @@ static void rsnd_dmapp_start(struct rsnd_dma *dma)
 	rsnd_dmapp_write(dma, dmapp->chcr,	PDMACHCR);
 }
 
-static int rsnd_dmapp_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
+static int rsnd_dmapp_init(struct rsnd_dai_stream *io,
+			   struct rsnd_dma *dma, int id,
 			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
 	struct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct device *dev = rsnd_priv_to_dev(priv);
 
 	dmapp->dmapp_id = dmac->dmapp_num;
-	dmapp->chcr = rsnd_dmapp_get_chcr(mod_from, mod_to) | PDMACHCR_DE;
+	dmapp->chcr = rsnd_dmapp_get_chcr(io, mod_from, mod_to) | PDMACHCR_DE;
 
 	dmac->dmapp_num++;
 
-	rsnd_dmapp_stop(dma);
+	rsnd_dmapp_stop(io, dma);
 
 	dev_dbg(dev, "id/src/dst/chcr = %d/%pad/%pad/%08x\n",
 		dmapp->dmapp_id, &dma->src_addr, &dma->dst_addr, dmapp->chcr);
@@ -394,12 +403,12 @@ static struct rsnd_dma_ops rsnd_dmapp_ops = {
 #define RDMA_CMD_O_P(addr, i)	(addr ##_reg - 0x001f8000 + (0x400 * i))
 
 static dma_addr_t
-rsnd_gen2_dma_addr(struct rsnd_priv *priv,
+rsnd_gen2_dma_addr(struct rsnd_dai_stream *io,
 		   struct rsnd_mod *mod,
 		   int is_play, int is_from)
 {
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct device *dev = rsnd_priv_to_dev(priv);
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	phys_addr_t ssi_reg = rsnd_gen_get_phy_addr(priv, RSND_GEN2_SSI);
 	phys_addr_t src_reg = rsnd_gen_get_phy_addr(priv, RSND_GEN2_SCU);
 	int is_ssi = !!(rsnd_io_to_mod_ssi(io) == mod);
@@ -454,10 +463,12 @@ rsnd_gen2_dma_addr(struct rsnd_priv *priv,
 		dma_addrs[is_ssi][is_play][use_src + use_dvc].in_addr;
 }
 
-static dma_addr_t rsnd_dma_addr(struct rsnd_priv *priv,
+static dma_addr_t rsnd_dma_addr(struct rsnd_dai_stream *io,
 				struct rsnd_mod *mod,
 				int is_play, int is_from)
 {
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);
+
 	/*
 	 * gen1 uses default DMA addr
 	 */
@@ -467,17 +478,17 @@ static dma_addr_t rsnd_dma_addr(struct rsnd_priv *priv,
 	if (!mod)
 		return 0;
 
-	return rsnd_gen2_dma_addr(priv, mod, is_play, is_from);
+	return rsnd_gen2_dma_addr(io, mod, is_play, is_from);
 }
 
 #define MOD_MAX 4 /* MEM/SSI/SRC/DVC */
 static void rsnd_dma_of_path(struct rsnd_dma *dma,
+			     struct rsnd_dai_stream *io,
 			     int is_play,
 			     struct rsnd_mod **mod_from,
 			     struct rsnd_mod **mod_to)
 {
 	struct rsnd_mod *this = rsnd_dma_to_mod(dma);
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(this);
 	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
 	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
 	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
@@ -532,17 +543,17 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	}
 }
 
-void rsnd_dma_stop(struct rsnd_dma *dma)
+void rsnd_dma_stop(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 {
-	dma->ops->stop(dma);
+	dma->ops->stop(io, dma);
 }
 
-void rsnd_dma_start(struct rsnd_dma *dma)
+void rsnd_dma_start(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 {
-	dma->ops->start(dma);
+	dma->ops->start(io, dma);
 }
 
-void rsnd_dma_quit(struct rsnd_dma *dma)
+void rsnd_dma_quit(struct rsnd_dai_stream *io, struct rsnd_dma *dma)
 {
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
@@ -551,15 +562,14 @@ void rsnd_dma_quit(struct rsnd_dma *dma)
 	if (!dmac)
 		return;
 
-	dma->ops->quit(dma);
+	dma->ops->quit(io, dma);
 }
 
-int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
+int rsnd_dma_init(struct rsnd_dai_stream *io, struct rsnd_dma *dma, int id)
 {
-	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_mod *mod_from;
 	struct rsnd_mod *mod_to;
-	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	struct rsnd_priv *priv = rsnd_io_to_priv(io);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	int is_play = rsnd_io_is_play(io);
 
@@ -572,10 +582,10 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 	if (!dmac)
 		return -EAGAIN;
 
-	rsnd_dma_of_path(dma, is_play, &mod_from, &mod_to);
+	rsnd_dma_of_path(dma, io, is_play, &mod_from, &mod_to);
 
-	dma->src_addr = rsnd_dma_addr(priv, mod_from, is_play, 1);
-	dma->dst_addr = rsnd_dma_addr(priv, mod_to,   is_play, 0);
+	dma->src_addr = rsnd_dma_addr(io, mod_from, is_play, 1);
+	dma->dst_addr = rsnd_dma_addr(io, mod_to,   is_play, 0);
 
 	/* for Gen2 */
 	if (mod_from && mod_to)
@@ -587,7 +597,7 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 	if (rsnd_is_gen1(priv))
 		dma->ops = &rsnd_dmaen_ops;
 
-	return dma->ops->init(priv, dma, id, mod_from, mod_to);
+	return dma->ops->init(io, dma, id, mod_from, mod_to);
 }
 
 int rsnd_dma_probe(struct platform_device *pdev,

commit 75defee0f1b3fcd91d8a304d6444635a459b8249
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jun 15 06:21:15 2015 +0000

    ASoC: rsnd: don't call snd_pcm_period_elapsed() under spin lock
    
    'a9e1ac1a9e4585b5("ASoC: rsnd: spin lock for interrupt handler")'
    added spin lock under interrupt handler to solve HW restart issue.
    
    OTOH, current rsnd driver calls snd_pcm_period_elapsed() from
    rsnd_dai_pointer_update(). but, it will be called under spin lock
    if SSI was PIO mode.
    
    If it was called under spin lock, it will call
    snd_pcm_update_state() -> snd_pcm_drain_done().
    Then, it calls rsnd_soc_dai_trigger() and will be dead-lock.
    This patch doesn't call rsnd_dai_pointer_update() under spin lock
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index ac3756f6af60..9034f951adfe 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -36,7 +36,10 @@ static void rsnd_dmaen_complete(void *data)
 {
 	struct rsnd_dma *dma = (struct rsnd_dma *)data;
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	bool elapsed = false;
+	unsigned long flags;
 
 	/*
 	 * Renesas sound Gen1 needs 1 DMAC,
@@ -49,8 +52,14 @@ static void rsnd_dmaen_complete(void *data)
 	 * rsnd_dai_pointer_update() will be called twice,
 	 * ant it will breaks io->byte_pos
 	 */
+	spin_lock_irqsave(&priv->lock, flags);
+
+	elapsed = rsnd_dai_pointer_update(io, io->byte_per_period);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
 
-	rsnd_dai_pointer_update(io, io->byte_per_period);
+	if (elapsed)
+		rsnd_dai_period_elapsed(io);
 }
 
 static void rsnd_dmaen_stop(struct rsnd_dma *dma)

commit d1acba2fdebb449bad01e7cf77a9f9730dfaca6e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Apr 13 06:00:45 2015 +0000

    ASoC: rsnd: set dmaen->chan = NULL when error case
    
    rsnd_dmaen_quit() is assuming dmaen->chan is NULL if it failed
    to get DMAEngine channel. but, current dmaen->chan might have
    error value when error case (this driver is checking it by IS_ERR_OR_NULL())
    This patch makes sure dmaen->chan is NULL when error case.
    Otherwise, it will contact to unknown address in rsnd_dmaen_quit()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index ac3756f6af60..144308f15fb3 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -156,6 +156,7 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 						  (void *)id);
 	}
 	if (IS_ERR_OR_NULL(dmaen->chan)) {
+		dmaen->chan = NULL;
 		dev_err(dev, "can't get dma channel\n");
 		goto rsnd_dma_channel_err;
 	}

commit b543b52a44c4e45283cd17721af1299049405136
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 26 04:02:32 2015 +0000

    ASoC: rsnd: remove useless debug message
    
    This patch removes useless debug message. especially some kind of
    "probed" message will be printed from core.c if it has #define DEBUG
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index cd7b79a01ce2..ac3756f6af60 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -144,8 +144,6 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 		return -EIO;
 	}
 
-	dev_dbg(dev, "Audio DMAC init\n");
-
 	if (dev->of_node) {
 		dmaen->chan = rsnd_dmaen_request_channel(mod_from, mod_to);
 	} else {
@@ -329,8 +327,6 @@ static int rsnd_dmapp_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct device *dev = rsnd_priv_to_dev(priv);
 
-	dev_dbg(dev, "Audio DMAC peri peri init\n");
-
 	dmapp->dmapp_id = dmac->dmapp_num;
 	dmapp->chcr = rsnd_dmapp_get_chcr(mod_from, mod_to) | PDMACHCR_DE;
 

commit 8537483a17038f08c68c1f0a561f0fe686e5706f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Mar 10 01:25:01 2015 +0000

    ASoC: rsnd: recover PIO mode for new dma interface
    
    Renesas sound driver needs 1st/2nd DMA interface,
    and 1st DMA is using DMAEngine, and 2nd is using local method now.
    2nd DMA had been DMAEngine, but it was moved to local method by previous
    patchset. But then, it lost PIO mode fallback when probe.
    this patch recovers it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 2b73df84a769..cd7b79a01ce2 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -539,6 +539,13 @@ void rsnd_dma_start(struct rsnd_dma *dma)
 
 void rsnd_dma_quit(struct rsnd_dma *dma)
 {
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
+
+	if (!dmac)
+		return;
+
 	dma->ops->quit(dma);
 }
 
@@ -548,8 +555,18 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 	struct rsnd_mod *mod_from;
 	struct rsnd_mod *mod_to;
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	int is_play = rsnd_io_is_play(io);
 
+	/*
+	 * DMA failed. try to PIO mode
+	 * see
+	 *	rsnd_ssi_fallback()
+	 *	rsnd_rdai_continuance_probe()
+	 */
+	if (!dmac)
+		return -EAGAIN;
+
 	rsnd_dma_of_path(dma, is_play, &mod_from, &mod_to);
 
 	dma->src_addr = rsnd_dma_addr(priv, mod_from, is_play, 1);
@@ -589,7 +606,7 @@ int rsnd_dma_probe(struct platform_device *pdev,
 	dmac = devm_kzalloc(dev, sizeof(*dmac), GFP_KERNEL);
 	if (!dmac || !res) {
 		dev_err(dev, "dma allocate failed\n");
-		return -ENOMEM;
+		return 0; /* it will be PIO mode */
 	}
 
 	dmac->dmapp_num = 0;

commit 6ec6fb6f231547834925ff802deb4415f49f708e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Mar 10 11:48:05 2015 +0100

    ASoC: rsnd: Use %pad to print dma_addr_t in rsnd_dmapp_init()
    
    sound/soc/sh/rcar/dma.c: In function 'rsnd_dmapp_init':
    sound/soc/sh/rcar/dma.c:341:2: warning: format '%x' expects argument of type 'unsigned int', but argument 5 has type 'dma_addr_t' [-Wformat=]
      dev_dbg(dev, "id/src/dst/chcr = %d/%x/%x/%08x\n",
      ^
    sound/soc/sh/rcar/dma.c:341:2: warning: format '%x' expects argument of type 'unsigned int', but argument 6 has type 'dma_addr_t' [-Wformat=]
    
    Fixes: 288f392e729dd4d3 ("ASoC: rsnd: add Audio DMAC peri peri support rework")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 92fd55044ee6..2b73df84a769 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -338,8 +338,8 @@ static int rsnd_dmapp_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 
 	rsnd_dmapp_stop(dma);
 
-	dev_dbg(dev, "id/src/dst/chcr = %d/%x/%x/%08x\n",
-		dmapp->dmapp_id, dma->src_addr, dma->dst_addr, dmapp->chcr);
+	dev_dbg(dev, "id/src/dst/chcr = %d/%pad/%pad/%08x\n",
+		dmapp->dmapp_id, &dma->src_addr, &dma->dst_addr, dmapp->chcr);
 
 	return 0;
 }

commit 72adc61f4637aa3596c1db1129f84d768475a885
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:31:23 2015 +0000

    ASoC: rsnd: 1st DMAC dma-names cares subnode
    
    Renesas R-Car sound (= rsnd) needs 2 DMAC which are called as
    Audio DMAC (= 1st DMAC) and Audio DMAC peri peri (2nd DMAC).
    And rsnd had assumed that 1st / 2nd DMACs are implemented as DMAEngine.
    But, in result of DMA ML discussion, 2nd DMAC was concluded that it is
    not a general purpose DMAC (2nd DMAC is for Device to Device inside
    sound system). Additionally, current DMAEngine can't support Device to
    Device, and we don't have correct DT bindings for it at this point.
    So the easiest solution for it is that move it from DMAEngine to rsnd
    driver.
    
    dma-names on DT was implemented as no difference between 1st / 2nd
    DMAC's, since rsnd had assumed that both DMACs are implemented as
    DMAEngine. That style was "src_dst". But now, 2nd DMAC was implemented
    as non DMAEngine, and it doesn't need dma-names anymore. So, this
    dma-names rule is no longer needed.
    
    And additionally, dma-names was assumed that it has all
    (= SSI/SSIU/SRC/DVC) nodes under sound node.
    
    In upstream code, no SoC/platform is supporting DMA for rsnd driver yet.
    This means there is no compatible issue if this patch changes
    dma-names's rule of DT.
    
    This patch assumes dma-names for 1st DMAC are tx/rx base, and listed
    in each SSI/SRC/DVC subnode
    ex)
            rcar_sound,dvc {
                    dvc0: dvc@0 {
                            dmas = <&audma0 0xbc>;
                            dma-names = "tx";
                    };
            ...
    
            rcar_sound,src {
                    src0: src@0 {
                            ...
                            dmas = <&audma0 0x85>, <&audma1 0x9a>;
                            dma-names = "rx", "tx";
                    };
            ...
    
            rcar_sound,ssi {
                    ssi0: ssi@0 {
                            ...
                            dmas = <&audma0 0x01>, <&audma1 0x02>, <&audma0 0x15>, <&audma1 0x16>;
                            dma-names = "rx", "tx", "rxu", "txu";
                    };
            ...
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 3f34461da1e0..92fd55044ee6 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -9,6 +9,7 @@
  * published by the Free Software Foundation.
  */
 #include <linux/delay.h>
+#include <linux/of_dma.h>
 #include "rsnd.h"
 
 /*
@@ -52,28 +53,6 @@ static void rsnd_dmaen_complete(void *data)
 	rsnd_dai_pointer_update(io, io->byte_per_period);
 }
 
-#define DMA_NAME_SIZE 16
-static int _rsnd_dmaen_of_name(char *dma_name, struct rsnd_mod *mod)
-{
-	if (mod)
-		return snprintf(dma_name, DMA_NAME_SIZE / 2, "%s%d",
-				rsnd_mod_dma_name(mod), rsnd_mod_id(mod));
-	else
-		return snprintf(dma_name, DMA_NAME_SIZE / 2, "mem");
-
-}
-
-static void rsnd_dmaen_of_name(struct rsnd_mod *mod_from,
-			     struct rsnd_mod *mod_to,
-			     char *dma_name)
-{
-	int index = 0;
-
-	index = _rsnd_dmaen_of_name(dma_name + index, mod_from);
-	*(dma_name + index++) = '_';
-	index = _rsnd_dmaen_of_name(dma_name + index, mod_to);
-}
-
 static void rsnd_dmaen_stop(struct rsnd_dma *dma)
 {
 	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
@@ -115,6 +94,40 @@ static void rsnd_dmaen_start(struct rsnd_dma *dma)
 	dma_async_issue_pending(dmaen->chan);
 }
 
+struct dma_chan *rsnd_dma_request_channel(struct device_node *of_node,
+					  struct rsnd_mod *mod, char *name)
+{
+	struct dma_chan *chan;
+	struct device_node *np;
+	int i = 0;
+
+	for_each_child_of_node(of_node, np) {
+		if (i == rsnd_mod_id(mod))
+			break;
+		i++;
+	}
+
+	chan = of_dma_request_slave_channel(np, name);
+
+	of_node_put(np);
+	of_node_put(of_node);
+
+	return chan;
+}
+
+static struct dma_chan *rsnd_dmaen_request_channel(struct rsnd_mod *mod_from,
+						   struct rsnd_mod *mod_to)
+{
+	if ((!mod_from && !mod_to) ||
+	    (mod_from && mod_to))
+		return NULL;
+
+	if (mod_from)
+		return rsnd_mod_dma_req(mod_from);
+	else
+		return rsnd_mod_dma_req(mod_to);
+}
+
 static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
@@ -124,8 +137,6 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	int is_play = rsnd_io_is_play(io);
-	char dma_name[DMA_NAME_SIZE];
-	dma_cap_mask_t mask;
 	int ret;
 
 	if (dmaen->chan) {
@@ -135,10 +146,21 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 
 	dev_dbg(dev, "Audio DMAC init\n");
 
-	dma_cap_zero(mask);
-	dma_cap_set(DMA_SLAVE, mask);
+	if (dev->of_node) {
+		dmaen->chan = rsnd_dmaen_request_channel(mod_from, mod_to);
+	} else {
+		dma_cap_mask_t mask;
+
+		dma_cap_zero(mask);
+		dma_cap_set(DMA_SLAVE, mask);
 
-	rsnd_dmaen_of_name(mod_from, mod_to, dma_name);
+		dmaen->chan = dma_request_channel(mask, shdma_chan_filter,
+						  (void *)id);
+	}
+	if (IS_ERR_OR_NULL(dmaen->chan)) {
+		dev_err(dev, "can't get dma channel\n");
+		goto rsnd_dma_channel_err;
+	}
 
 	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
 	cfg.src_addr	= dma->src_addr;
@@ -146,16 +168,8 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
-	dev_dbg(dev, "dma : %s %pad -> %pad\n",
-		dma_name, &cfg.src_addr, &cfg.dst_addr);
-
-	dmaen->chan = dma_request_slave_channel_compat(mask, shdma_chan_filter,
-						     (void *)id, dev,
-						     dma_name);
-	if (!dmaen->chan) {
-		dev_err(dev, "can't get dma channel\n");
-		goto rsnd_dma_channel_err;
-	}
+	dev_dbg(dev, "dma : %pad -> %pad\n",
+		&cfg.src_addr, &cfg.dst_addr);
 
 	ret = dmaengine_slave_config(dmaen->chan, &cfg);
 	if (ret < 0)

commit e879a9ddf41c47ccc83039e99e04b0d5c56cd0c5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:29:41 2015 +0000

    ASoC: rsnd: enable rsnd_ssi_use_busif() for DMA
    
    Renesas R-Car sound driver uses SSI, but the DMA interfaces are
    SSI/SSIU. This interface is based on SSI/SRC/DVC connection.
    And DMA function needs to know which interface is used somehow.
    This patch enables rsnd_ssi_use_busif() for DMA.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index b449763ebd43..3f34461da1e0 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -427,7 +427,7 @@ rsnd_gen2_dma_addr(struct rsnd_priv *priv,
 		dev_err(dev, "DVC is selected without SRC\n");
 
 	/* use SSIU or SSI ? */
-	if (is_ssi && (0 == strcmp(rsnd_mod_dma_name(mod), "ssiu")))
+	if (is_ssi && rsnd_ssi_use_busif(mod))
 		is_ssi++;
 
 	return (is_from) ?

commit 0d00a52182be985bfae67d407ee81fefe448a0fd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:29:13 2015 +0000

    ASoC: rsnd: use union with rsnd_dmaen / rsnd_dmapp
    
    Renesas R-Car needs 2 DMACs.1st DMAC is DMAEngine, and 2nd DMAC is
    implemented as local code. These 2 DMACs are never shared.
    We can use union for these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 3f1ea58ee144..b449763ebd43 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -76,11 +76,14 @@ static void rsnd_dmaen_of_name(struct rsnd_mod *mod_from,
 
 static void rsnd_dmaen_stop(struct rsnd_dma *dma)
 {
-	dmaengine_terminate_all(dma->chan);
+	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
+
+	dmaengine_terminate_all(dmaen->chan);
 }
 
 static void rsnd_dmaen_start(struct rsnd_dma *dma)
 {
+	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
@@ -89,7 +92,7 @@ static void rsnd_dmaen_start(struct rsnd_dma *dma)
 	struct dma_async_tx_descriptor *desc;
 	int is_play = rsnd_io_is_play(io);
 
-	desc = dmaengine_prep_dma_cyclic(dma->chan,
+	desc = dmaengine_prep_dma_cyclic(dmaen->chan,
 					 substream->runtime->dma_addr,
 					 snd_pcm_lib_buffer_bytes(substream),
 					 snd_pcm_lib_period_bytes(substream),
@@ -109,12 +112,13 @@ static void rsnd_dmaen_start(struct rsnd_dma *dma)
 		return;
 	}
 
-	dma_async_issue_pending(dma->chan);
+	dma_async_issue_pending(dmaen->chan);
 }
 
 static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
+	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_slave_config cfg = {};
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
@@ -124,7 +128,7 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	dma_cap_mask_t mask;
 	int ret;
 
-	if (dma->chan) {
+	if (dmaen->chan) {
 		dev_err(dev, "it already has dma channel\n");
 		return -EIO;
 	}
@@ -145,15 +149,15 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	dev_dbg(dev, "dma : %s %pad -> %pad\n",
 		dma_name, &cfg.src_addr, &cfg.dst_addr);
 
-	dma->chan = dma_request_slave_channel_compat(mask, shdma_chan_filter,
+	dmaen->chan = dma_request_slave_channel_compat(mask, shdma_chan_filter,
 						     (void *)id, dev,
 						     dma_name);
-	if (!dma->chan) {
+	if (!dmaen->chan) {
 		dev_err(dev, "can't get dma channel\n");
 		goto rsnd_dma_channel_err;
 	}
 
-	ret = dmaengine_slave_config(dma->chan, &cfg);
+	ret = dmaengine_slave_config(dmaen->chan, &cfg);
 	if (ret < 0)
 		goto rsnd_dma_init_err;
 
@@ -174,10 +178,12 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 
 static void rsnd_dmaen_quit(struct rsnd_dma *dma)
 {
-	if (dma->chan)
-		dma_release_channel(dma->chan);
+	struct rsnd_dmaen *dmaen = rsnd_dma_to_dmaen(dma);
+
+	if (dmaen->chan)
+		dma_release_channel(dmaen->chan);
 
-	dma->chan = NULL;
+	dmaen->chan = NULL;
 }
 
 static struct rsnd_dma_ops rsnd_dmaen_ops = {
@@ -257,7 +263,8 @@ static u32 rsnd_dmapp_get_chcr(struct rsnd_mod *mod_from,
 }
 
 #define rsnd_dmapp_addr(dmac, dma, reg) \
-	(dmac->base + 0x20 + (0x10 * dma->dmapp_id) + reg)
+	(dmac->base + 0x20 + reg + \
+	 (0x10 * rsnd_dma_to_dmapp(dma)->dmapp_id))
 static void rsnd_dmapp_write(struct rsnd_dma *dma, u32 data, u32 reg)
 {
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
@@ -294,28 +301,31 @@ static void rsnd_dmapp_stop(struct rsnd_dma *dma)
 
 static void rsnd_dmapp_start(struct rsnd_dma *dma)
 {
+	struct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);
+
 	rsnd_dmapp_write(dma, dma->src_addr,	PDMASAR);
 	rsnd_dmapp_write(dma, dma->dst_addr,	PDMADAR);
-	rsnd_dmapp_write(dma, dma->chcr,	PDMACHCR);
+	rsnd_dmapp_write(dma, dmapp->chcr,	PDMACHCR);
 }
 
 static int rsnd_dmapp_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
+	struct rsnd_dmapp *dmapp = rsnd_dma_to_dmapp(dma);
 	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
 	struct device *dev = rsnd_priv_to_dev(priv);
 
 	dev_dbg(dev, "Audio DMAC peri peri init\n");
 
-	dma->dmapp_id = dmac->dmapp_num;
-	dma->chcr = rsnd_dmapp_get_chcr(mod_from, mod_to) | PDMACHCR_DE;
+	dmapp->dmapp_id = dmac->dmapp_num;
+	dmapp->chcr = rsnd_dmapp_get_chcr(mod_from, mod_to) | PDMACHCR_DE;
 
 	dmac->dmapp_num++;
 
 	rsnd_dmapp_stop(dma);
 
 	dev_dbg(dev, "id/src/dst/chcr = %d/%x/%x/%08x\n",
-		dma->dmapp_id, dma->src_addr, dma->dst_addr, dma->chcr);
+		dmapp->dmapp_id, dma->src_addr, dma->dst_addr, dmapp->chcr);
 
 	return 0;
 }

commit aaf4fce019ecd55a2d93b6111525deeef300f751
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:28:32 2015 +0000

    ASoC: rsnd: remove rsnd_dma::dir
    
    DMAEngine direction can be calculated from rsnd_dai_stream,
    So, rsnd_dma::dir does not make sense now.
    Let's remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index c407fd250d2a..3f1ea58ee144 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -87,12 +87,13 @@ static void rsnd_dmaen_start(struct rsnd_dma *dma)
 	struct snd_pcm_substream *substream = io->substream;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_async_tx_descriptor *desc;
+	int is_play = rsnd_io_is_play(io);
 
 	desc = dmaengine_prep_dma_cyclic(dma->chan,
 					 substream->runtime->dma_addr,
 					 snd_pcm_lib_buffer_bytes(substream),
 					 snd_pcm_lib_period_bytes(substream),
-					 dma->dir,
+					 is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,
 					 DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 
 	if (!desc) {
@@ -156,8 +157,6 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	if (ret < 0)
 		goto rsnd_dma_init_err;
 
-	dma->dir = is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
-
 	return 0;
 
 rsnd_dma_init_err:

commit 56f2906ae2d0b48b64a67feef99e3be3b40c3617
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:28:07 2015 +0000

    ASoC: rsnd: remove rsnd_dma::addr
    
    DMAEngine for Renesas R-Car driver is used only for Audio DMAC now.
    rsnd_dma::addr was added to support Audio DMAC peri peri,
    but it is no longer needed. Let's remove it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index a01bb8c6b068..c407fd250d2a 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -89,7 +89,6 @@ static void rsnd_dmaen_start(struct rsnd_dma *dma)
 	struct dma_async_tx_descriptor *desc;
 
 	desc = dmaengine_prep_dma_cyclic(dma->chan,
-					 (dma->addr) ? dma->addr :
 					 substream->runtime->dma_addr,
 					 snd_pcm_lib_buffer_bytes(substream),
 					 snd_pcm_lib_period_bytes(substream),
@@ -157,7 +156,6 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 	if (ret < 0)
 		goto rsnd_dma_init_err;
 
-	dma->addr = is_play ? cfg.src_addr : cfg.dst_addr;
 	dma->dir = is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
 
 	return 0;

commit 288f392e729dd4d3719c2319c7c3f8d4c820488b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:27:42 2015 +0000

    ASoC: rsnd: add Audio DMAC peri peri support rework
    
    Renesas R-Car sound (= rsnd) needs 2 DMAC which are called as
    Audio DMAC (= 1st DMAC) and Audio DMAC peri peri (2nd DMAC).
    And rsnd had assumed that 1st / 2nd DMACs are implemented as DMAEngine.
    But, in result of DMA ML discussion, 2nd DMAC was concluded that it is
    not a general purpose DMAC (2nd DMAC is for Device to Device inside
    sound system). Additionally, current DMAEngine can't support Device to
    Device, and we don't have correct DT bindings for it at this point.
    So the easiest solution for it is that move it from DMAEngine to rsnd
    driver.
    Audio DMAC peri peri is controlled from sound driver without DMAEngine
    by this patch.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index c911c079fdd0..a01bb8c6b068 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -8,8 +8,29 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+#include <linux/delay.h>
 #include "rsnd.h"
 
+/*
+ * Audio DMAC peri peri register
+ */
+#define PDMASAR		0x00
+#define PDMADAR		0x04
+#define PDMACHCR	0x0c
+
+/* PDMACHCR */
+#define PDMACHCR_DE		(1 << 0)
+
+struct rsnd_dma_ctrl {
+	void __iomem *base;
+	int dmapp_num;
+};
+
+#define rsnd_priv_to_dmac(p)	((struct rsnd_dma_ctrl *)(p)->dma)
+
+/*
+ *		Audio DMAC
+ */
 static void rsnd_dmaen_complete(void *data)
 {
 	struct rsnd_dma *dma = (struct rsnd_dma *)data;
@@ -108,6 +129,8 @@ static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
 		return -EIO;
 	}
 
+	dev_dbg(dev, "Audio DMAC init\n");
+
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
 
@@ -167,6 +190,150 @@ static struct rsnd_dma_ops rsnd_dmaen_ops = {
 	.quit	= rsnd_dmaen_quit,
 };
 
+/*
+ *		Audio DMAC peri peri
+ */
+static const u8 gen2_id_table_ssiu[] = {
+	0x00, /* SSI00 */
+	0x04, /* SSI10 */
+	0x08, /* SSI20 */
+	0x0c, /* SSI3  */
+	0x0d, /* SSI4  */
+	0x0e, /* SSI5  */
+	0x0f, /* SSI6  */
+	0x10, /* SSI7  */
+	0x11, /* SSI8  */
+	0x12, /* SSI90 */
+};
+static const u8 gen2_id_table_scu[] = {
+	0x2d, /* SCU_SRCI0 */
+	0x2e, /* SCU_SRCI1 */
+	0x2f, /* SCU_SRCI2 */
+	0x30, /* SCU_SRCI3 */
+	0x31, /* SCU_SRCI4 */
+	0x32, /* SCU_SRCI5 */
+	0x33, /* SCU_SRCI6 */
+	0x34, /* SCU_SRCI7 */
+	0x35, /* SCU_SRCI8 */
+	0x36, /* SCU_SRCI9 */
+};
+static const u8 gen2_id_table_cmd[] = {
+	0x37, /* SCU_CMD0 */
+	0x38, /* SCU_CMD1 */
+};
+
+static u32 rsnd_dmapp_get_id(struct rsnd_mod *mod)
+{
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
+	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
+	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
+	const u8 *entry = NULL;
+	int id = rsnd_mod_id(mod);
+	int size = 0;
+
+	if (mod == ssi) {
+		entry = gen2_id_table_ssiu;
+		size = ARRAY_SIZE(gen2_id_table_ssiu);
+	} else if (mod == src) {
+		entry = gen2_id_table_scu;
+		size = ARRAY_SIZE(gen2_id_table_scu);
+	} else if (mod == dvc) {
+		entry = gen2_id_table_cmd;
+		size = ARRAY_SIZE(gen2_id_table_cmd);
+	}
+
+	if (!entry)
+		return 0xFF;
+
+	if (size <= id)
+		return 0xFF;
+
+	return entry[id];
+}
+
+static u32 rsnd_dmapp_get_chcr(struct rsnd_mod *mod_from,
+			       struct rsnd_mod *mod_to)
+{
+	return	(rsnd_dmapp_get_id(mod_from) << 24) +
+		(rsnd_dmapp_get_id(mod_to) << 16);
+}
+
+#define rsnd_dmapp_addr(dmac, dma, reg) \
+	(dmac->base + 0x20 + (0x10 * dma->dmapp_id) + reg)
+static void rsnd_dmapp_write(struct rsnd_dma *dma, u32 data, u32 reg)
+{
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
+	struct device *dev = rsnd_priv_to_dev(priv);
+
+	dev_dbg(dev, "w %p : %08x\n", rsnd_dmapp_addr(dmac, dma, reg), data);
+
+	iowrite32(data, rsnd_dmapp_addr(dmac, dma, reg));
+}
+
+static u32 rsnd_dmapp_read(struct rsnd_dma *dma, u32 reg)
+{
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
+
+	return ioread32(rsnd_dmapp_addr(dmac, dma, reg));
+}
+
+static void rsnd_dmapp_stop(struct rsnd_dma *dma)
+{
+	int i;
+
+	rsnd_dmapp_write(dma, 0, PDMACHCR);
+
+	for (i = 0; i < 1024; i++) {
+		if (0 == rsnd_dmapp_read(dma, PDMACHCR))
+			return;
+		udelay(1);
+	}
+}
+
+static void rsnd_dmapp_start(struct rsnd_dma *dma)
+{
+	rsnd_dmapp_write(dma, dma->src_addr,	PDMASAR);
+	rsnd_dmapp_write(dma, dma->dst_addr,	PDMADAR);
+	rsnd_dmapp_write(dma, dma->chcr,	PDMACHCR);
+}
+
+static int rsnd_dmapp_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
+			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
+{
+	struct rsnd_dma_ctrl *dmac = rsnd_priv_to_dmac(priv);
+	struct device *dev = rsnd_priv_to_dev(priv);
+
+	dev_dbg(dev, "Audio DMAC peri peri init\n");
+
+	dma->dmapp_id = dmac->dmapp_num;
+	dma->chcr = rsnd_dmapp_get_chcr(mod_from, mod_to) | PDMACHCR_DE;
+
+	dmac->dmapp_num++;
+
+	rsnd_dmapp_stop(dma);
+
+	dev_dbg(dev, "id/src/dst/chcr = %d/%x/%x/%08x\n",
+		dma->dmapp_id, dma->src_addr, dma->dst_addr, dma->chcr);
+
+	return 0;
+}
+
+static struct rsnd_dma_ops rsnd_dmapp_ops = {
+	.start	= rsnd_dmapp_start,
+	.stop	= rsnd_dmapp_stop,
+	.init	= rsnd_dmapp_init,
+	.quit	= rsnd_dmapp_stop,
+};
+
+/*
+ *		Common DMAC Interface
+ */
+
 /*
  *	DMA read/write register offset
  *
@@ -367,7 +534,49 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 	dma->src_addr = rsnd_dma_addr(priv, mod_from, is_play, 1);
 	dma->dst_addr = rsnd_dma_addr(priv, mod_to,   is_play, 0);
 
-	dma->ops = &rsnd_dmaen_ops;
+	/* for Gen2 */
+	if (mod_from && mod_to)
+		dma->ops = &rsnd_dmapp_ops;
+	else
+		dma->ops = &rsnd_dmaen_ops;
+
+	/* for Gen1, overwrite */
+	if (rsnd_is_gen1(priv))
+		dma->ops = &rsnd_dmaen_ops;
 
 	return dma->ops->init(priv, dma, id, mod_from, mod_to);
 }
+
+int rsnd_dma_probe(struct platform_device *pdev,
+		   const struct rsnd_of_data *of_data,
+		   struct rsnd_priv *priv)
+{
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_dma_ctrl *dmac;
+	struct resource *res;
+
+	/*
+	 * for Gen1
+	 */
+	if (rsnd_is_gen1(priv))
+		return 0;
+
+	/*
+	 * for Gen2
+	 */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "audmapp");
+	dmac = devm_kzalloc(dev, sizeof(*dmac), GFP_KERNEL);
+	if (!dmac || !res) {
+		dev_err(dev, "dma allocate failed\n");
+		return -ENOMEM;
+	}
+
+	dmac->dmapp_num = 0;
+	dmac->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(dmac->base))
+		return PTR_ERR(dmac->base);
+
+	priv->dma = dmac;
+
+	return 0;
+}

commit 3c68565b6cb68b731b51eb21b59dce901002fc6e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:27:12 2015 +0000

    ASoC: rsnd: enable to care 1st / 2nd DMAC on rsnd_dma_xxx()
    
    rsnd driver needs to care about Audio DAMC (via DMAEngine),
    Audio DMAC peri peri (via local method) on rsnd driver.
    This patch adds new rsnd_dma_ops and care it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 188b4634939c..c911c079fdd0 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -10,7 +10,7 @@
  */
 #include "rsnd.h"
 
-static void rsnd_dma_complete(void *data)
+static void rsnd_dmaen_complete(void *data)
 {
 	struct rsnd_dma *dma = (struct rsnd_dma *)data;
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
@@ -32,7 +32,7 @@ static void rsnd_dma_complete(void *data)
 }
 
 #define DMA_NAME_SIZE 16
-static int _rsnd_dma_of_name(char *dma_name, struct rsnd_mod *mod)
+static int _rsnd_dmaen_of_name(char *dma_name, struct rsnd_mod *mod)
 {
 	if (mod)
 		return snprintf(dma_name, DMA_NAME_SIZE / 2, "%s%d",
@@ -42,23 +42,23 @@ static int _rsnd_dma_of_name(char *dma_name, struct rsnd_mod *mod)
 
 }
 
-static void rsnd_dma_of_name(struct rsnd_mod *mod_from,
+static void rsnd_dmaen_of_name(struct rsnd_mod *mod_from,
 			     struct rsnd_mod *mod_to,
 			     char *dma_name)
 {
 	int index = 0;
 
-	index = _rsnd_dma_of_name(dma_name + index, mod_from);
+	index = _rsnd_dmaen_of_name(dma_name + index, mod_from);
 	*(dma_name + index++) = '_';
-	index = _rsnd_dma_of_name(dma_name + index, mod_to);
+	index = _rsnd_dmaen_of_name(dma_name + index, mod_to);
 }
 
-void rsnd_dma_stop(struct rsnd_dma *dma)
+static void rsnd_dmaen_stop(struct rsnd_dma *dma)
 {
 	dmaengine_terminate_all(dma->chan);
 }
 
-void rsnd_dma_start(struct rsnd_dma *dma)
+static void rsnd_dmaen_start(struct rsnd_dma *dma)
 {
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
 	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
@@ -80,7 +80,7 @@ void rsnd_dma_start(struct rsnd_dma *dma)
 		return;
 	}
 
-	desc->callback		= rsnd_dma_complete;
+	desc->callback		= rsnd_dmaen_complete;
 	desc->callback_param	= dma;
 
 	if (dmaengine_submit(desc) < 0) {
@@ -91,22 +91,12 @@ void rsnd_dma_start(struct rsnd_dma *dma)
 	dma_async_issue_pending(dma->chan);
 }
 
-static void rsnd_dma_of_path(struct rsnd_dma *dma,
-			     int is_play,
-			     struct rsnd_mod **mod_from,
-			     struct rsnd_mod **mod_to);
-
-static dma_addr_t rsnd_dma_addr(struct rsnd_priv *priv,
-				struct rsnd_mod *mod,
-				int is_play, int is_from);
-
-int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
+static int rsnd_dmaen_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id,
+			   struct rsnd_mod *mod_from, struct rsnd_mod *mod_to)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct dma_slave_config cfg = {};
 	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
-	struct rsnd_mod *mod_from;
-	struct rsnd_mod *mod_to;
 	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
 	int is_play = rsnd_io_is_play(io);
 	char dma_name[DMA_NAME_SIZE];
@@ -121,12 +111,11 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
 
-	rsnd_dma_of_path(dma, is_play, &mod_from, &mod_to);
-	rsnd_dma_of_name(mod_from, mod_to, dma_name);
+	rsnd_dmaen_of_name(mod_from, mod_to, dma_name);
 
 	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
-	cfg.src_addr	= rsnd_dma_addr(priv, mod_from, is_play, 1);
-	cfg.dst_addr	= rsnd_dma_addr(priv, mod_to,   is_play, 0);
+	cfg.src_addr	= dma->src_addr;
+	cfg.dst_addr	= dma->dst_addr;
 	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
@@ -163,7 +152,7 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 	return -EAGAIN;
 }
 
-void rsnd_dma_quit(struct rsnd_dma *dma)
+static void rsnd_dmaen_quit(struct rsnd_dma *dma)
 {
 	if (dma->chan)
 		dma_release_channel(dma->chan);
@@ -171,6 +160,13 @@ void rsnd_dma_quit(struct rsnd_dma *dma)
 	dma->chan = NULL;
 }
 
+static struct rsnd_dma_ops rsnd_dmaen_ops = {
+	.start	= rsnd_dmaen_start,
+	.stop	= rsnd_dmaen_stop,
+	.init	= rsnd_dmaen_init,
+	.quit	= rsnd_dmaen_quit,
+};
+
 /*
  *	DMA read/write register offset
  *
@@ -343,3 +339,35 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 	}
 }
 
+void rsnd_dma_stop(struct rsnd_dma *dma)
+{
+	dma->ops->stop(dma);
+}
+
+void rsnd_dma_start(struct rsnd_dma *dma)
+{
+	dma->ops->start(dma);
+}
+
+void rsnd_dma_quit(struct rsnd_dma *dma)
+{
+	dma->ops->quit(dma);
+}
+
+int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
+{
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_mod *mod_from;
+	struct rsnd_mod *mod_to;
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	int is_play = rsnd_io_is_play(io);
+
+	rsnd_dma_of_path(dma, is_play, &mod_from, &mod_to);
+
+	dma->src_addr = rsnd_dma_addr(priv, mod_from, is_play, 1);
+	dma->dst_addr = rsnd_dma_addr(priv, mod_to,   is_play, 0);
+
+	dma->ops = &rsnd_dmaen_ops;
+
+	return dma->ops->init(priv, dma, id, mod_from, mod_to);
+}

commit 747c71b12ee8357e73a88eb25f569e2a20e80df3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:26:29 2015 +0000

    ASoC: rsnd: move rsnd_gen_dma_addr() from gen.c to dma.c
    
    Now, we have dma.c for Audio DMAC / Audio DMAC peri peri.
    rsnd_gen_dma_addr() should go there.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
index 37acd409e88c..188b4634939c 100644
--- a/sound/soc/sh/rcar/dma.c
+++ b/sound/soc/sh/rcar/dma.c
@@ -32,7 +32,6 @@ static void rsnd_dma_complete(void *data)
 }
 
 #define DMA_NAME_SIZE 16
-#define MOD_MAX 4 /* MEM/SSI/SRC/DVC */
 static int _rsnd_dma_of_name(char *dma_name, struct rsnd_mod *mod)
 {
 	if (mod)
@@ -97,6 +96,10 @@ static void rsnd_dma_of_path(struct rsnd_dma *dma,
 			     struct rsnd_mod **mod_from,
 			     struct rsnd_mod **mod_to);
 
+static dma_addr_t rsnd_dma_addr(struct rsnd_priv *priv,
+				struct rsnd_mod *mod,
+				int is_play, int is_from);
+
 int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 {
 	struct device *dev = rsnd_priv_to_dev(priv);
@@ -122,8 +125,8 @@ int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
 	rsnd_dma_of_name(mod_from, mod_to, dma_name);
 
 	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
-	cfg.src_addr	= rsnd_gen_dma_addr(priv, mod_from, is_play, 1);
-	cfg.dst_addr	= rsnd_gen_dma_addr(priv, mod_to,   is_play, 0);
+	cfg.src_addr	= rsnd_dma_addr(priv, mod_from, is_play, 1);
+	cfg.dst_addr	= rsnd_dma_addr(priv, mod_to,   is_play, 0);
 	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
@@ -168,6 +171,117 @@ void rsnd_dma_quit(struct rsnd_dma *dma)
 	dma->chan = NULL;
 }
 
+/*
+ *	DMA read/write register offset
+ *
+ *	RSND_xxx_I_N	for Audio DMAC input
+ *	RSND_xxx_O_N	for Audio DMAC output
+ *	RSND_xxx_I_P	for Audio DMAC peri peri input
+ *	RSND_xxx_O_P	for Audio DMAC peri peri output
+ *
+ *	ex) R-Car H2 case
+ *	      mod        / DMAC in    / DMAC out   / DMAC PP in / DMAC pp out
+ *	SSI : 0xec541000 / 0xec241008 / 0xec24100c
+ *	SSIU: 0xec541000 / 0xec100000 / 0xec100000 / 0xec400000 / 0xec400000
+ *	SCU : 0xec500000 / 0xec000000 / 0xec004000 / 0xec300000 / 0xec304000
+ *	CMD : 0xec500000 /            / 0xec008000                0xec308000
+ */
+#define RDMA_SSI_I_N(addr, i)	(addr ##_reg - 0x00300000 + (0x40 * i) + 0x8)
+#define RDMA_SSI_O_N(addr, i)	(addr ##_reg - 0x00300000 + (0x40 * i) + 0xc)
+
+#define RDMA_SSIU_I_N(addr, i)	(addr ##_reg - 0x00441000 + (0x1000 * i))
+#define RDMA_SSIU_O_N(addr, i)	(addr ##_reg - 0x00441000 + (0x1000 * i))
+
+#define RDMA_SSIU_I_P(addr, i)	(addr ##_reg - 0x00141000 + (0x1000 * i))
+#define RDMA_SSIU_O_P(addr, i)	(addr ##_reg - 0x00141000 + (0x1000 * i))
+
+#define RDMA_SRC_I_N(addr, i)	(addr ##_reg - 0x00500000 + (0x400 * i))
+#define RDMA_SRC_O_N(addr, i)	(addr ##_reg - 0x004fc000 + (0x400 * i))
+
+#define RDMA_SRC_I_P(addr, i)	(addr ##_reg - 0x00200000 + (0x400 * i))
+#define RDMA_SRC_O_P(addr, i)	(addr ##_reg - 0x001fc000 + (0x400 * i))
+
+#define RDMA_CMD_O_N(addr, i)	(addr ##_reg - 0x004f8000 + (0x400 * i))
+#define RDMA_CMD_O_P(addr, i)	(addr ##_reg - 0x001f8000 + (0x400 * i))
+
+static dma_addr_t
+rsnd_gen2_dma_addr(struct rsnd_priv *priv,
+		   struct rsnd_mod *mod,
+		   int is_play, int is_from)
+{
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	phys_addr_t ssi_reg = rsnd_gen_get_phy_addr(priv, RSND_GEN2_SSI);
+	phys_addr_t src_reg = rsnd_gen_get_phy_addr(priv, RSND_GEN2_SCU);
+	int is_ssi = !!(rsnd_io_to_mod_ssi(io) == mod);
+	int use_src = !!rsnd_io_to_mod_src(io);
+	int use_dvc = !!rsnd_io_to_mod_dvc(io);
+	int id = rsnd_mod_id(mod);
+	struct dma_addr {
+		dma_addr_t out_addr;
+		dma_addr_t in_addr;
+	} dma_addrs[3][2][3] = {
+		/* SRC */
+		{{{ 0,				0 },
+		  /* Capture */
+		  { RDMA_SRC_O_N(src, id),	RDMA_SRC_I_P(src, id) },
+		  { RDMA_CMD_O_N(src, id),	RDMA_SRC_I_P(src, id) } },
+		 /* Playback */
+		 {{ 0,				0, },
+		  { RDMA_SRC_O_P(src, id),	RDMA_SRC_I_N(src, id) },
+		  { RDMA_CMD_O_P(src, id),	RDMA_SRC_I_N(src, id) } }
+		},
+		/* SSI */
+		/* Capture */
+		{{{ RDMA_SSI_O_N(ssi, id),	0 },
+		  { RDMA_SSIU_O_P(ssi, id),	0 },
+		  { RDMA_SSIU_O_P(ssi, id),	0 } },
+		 /* Playback */
+		 {{ 0,				RDMA_SSI_I_N(ssi, id) },
+		  { 0,				RDMA_SSIU_I_P(ssi, id) },
+		  { 0,				RDMA_SSIU_I_P(ssi, id) } }
+		},
+		/* SSIU */
+		/* Capture */
+		{{{ RDMA_SSIU_O_N(ssi, id),	0 },
+		  { RDMA_SSIU_O_P(ssi, id),	0 },
+		  { RDMA_SSIU_O_P(ssi, id),	0 } },
+		 /* Playback */
+		 {{ 0,				RDMA_SSIU_I_N(ssi, id) },
+		  { 0,				RDMA_SSIU_I_P(ssi, id) },
+		  { 0,				RDMA_SSIU_I_P(ssi, id) } } },
+	};
+
+	/* it shouldn't happen */
+	if (use_dvc && !use_src)
+		dev_err(dev, "DVC is selected without SRC\n");
+
+	/* use SSIU or SSI ? */
+	if (is_ssi && (0 == strcmp(rsnd_mod_dma_name(mod), "ssiu")))
+		is_ssi++;
+
+	return (is_from) ?
+		dma_addrs[is_ssi][is_play][use_src + use_dvc].out_addr :
+		dma_addrs[is_ssi][is_play][use_src + use_dvc].in_addr;
+}
+
+static dma_addr_t rsnd_dma_addr(struct rsnd_priv *priv,
+				struct rsnd_mod *mod,
+				int is_play, int is_from)
+{
+	/*
+	 * gen1 uses default DMA addr
+	 */
+	if (rsnd_is_gen1(priv))
+		return 0;
+
+	if (!mod)
+		return 0;
+
+	return rsnd_gen2_dma_addr(priv, mod, is_play, is_from);
+}
+
+#define MOD_MAX 4 /* MEM/SSI/SRC/DVC */
 static void rsnd_dma_of_path(struct rsnd_dma *dma,
 			     int is_play,
 			     struct rsnd_mod **mod_from,

commit bfe834be9525a82c8a40380c7df8ca3b149e9c93
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Feb 20 10:25:55 2015 +0000

    ASoC: rsnd: add dma.c for Audio DMAC / Audio DMAC peri peri
    
    Renesas sound driver had been assumed that Audio DMAC /
    Audio DMAC peri peri are implemented by DMAEngine. But, result of DMA
    ML discussion, it was concluded that it is not a general purpose DMAC.
    And it should be moved from current DMAEngine to rsnd driver.
    So, Audio DMAC peri peri become non DMAEngine.
    
    OTOH, ALSA SoC has soc-generic-dmaengine-pcm implementation. but it
    seems difficult to use this generic implementation on rsnd driver at
    this point, since it needs to fallback to PIO mode if DMA can't use.
    and additionally it needs 2 DMAC (= Audio DMAC / Audio DMAC peri peri).
    These are not "generic" feature.
    
    Of course I will try to use this generic dmaengine in the future somehow,
    but just use current style at this point until it can formally use 2 DMACs.
    This patch adds new dma.c and moves current dma code to dma.c from core.c.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/dma.c b/sound/soc/sh/rcar/dma.c
new file mode 100644
index 000000000000..37acd409e88c
--- /dev/null
+++ b/sound/soc/sh/rcar/dma.c
@@ -0,0 +1,231 @@
+/*
+ * Renesas R-Car Audio DMAC support
+ *
+ * Copyright (C) 2015 Renesas Electronics Corp.
+ * Copyright (c) 2015 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "rsnd.h"
+
+static void rsnd_dma_complete(void *data)
+{
+	struct rsnd_dma *dma = (struct rsnd_dma *)data;
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+
+	/*
+	 * Renesas sound Gen1 needs 1 DMAC,
+	 * Gen2 needs 2 DMAC.
+	 * In Gen2 case, it are Audio-DMAC, and Audio-DMAC-peri-peri.
+	 * But, Audio-DMAC-peri-peri doesn't have interrupt,
+	 * and this driver is assuming that here.
+	 *
+	 * If Audio-DMAC-peri-peri has interrpt,
+	 * rsnd_dai_pointer_update() will be called twice,
+	 * ant it will breaks io->byte_pos
+	 */
+
+	rsnd_dai_pointer_update(io, io->byte_per_period);
+}
+
+#define DMA_NAME_SIZE 16
+#define MOD_MAX 4 /* MEM/SSI/SRC/DVC */
+static int _rsnd_dma_of_name(char *dma_name, struct rsnd_mod *mod)
+{
+	if (mod)
+		return snprintf(dma_name, DMA_NAME_SIZE / 2, "%s%d",
+				rsnd_mod_dma_name(mod), rsnd_mod_id(mod));
+	else
+		return snprintf(dma_name, DMA_NAME_SIZE / 2, "mem");
+
+}
+
+static void rsnd_dma_of_name(struct rsnd_mod *mod_from,
+			     struct rsnd_mod *mod_to,
+			     char *dma_name)
+{
+	int index = 0;
+
+	index = _rsnd_dma_of_name(dma_name + index, mod_from);
+	*(dma_name + index++) = '_';
+	index = _rsnd_dma_of_name(dma_name + index, mod_to);
+}
+
+void rsnd_dma_stop(struct rsnd_dma *dma)
+{
+	dmaengine_terminate_all(dma->chan);
+}
+
+void rsnd_dma_start(struct rsnd_dma *dma)
+{
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	struct snd_pcm_substream *substream = io->substream;
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct dma_async_tx_descriptor *desc;
+
+	desc = dmaengine_prep_dma_cyclic(dma->chan,
+					 (dma->addr) ? dma->addr :
+					 substream->runtime->dma_addr,
+					 snd_pcm_lib_buffer_bytes(substream),
+					 snd_pcm_lib_period_bytes(substream),
+					 dma->dir,
+					 DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+
+	if (!desc) {
+		dev_err(dev, "dmaengine_prep_slave_sg() fail\n");
+		return;
+	}
+
+	desc->callback		= rsnd_dma_complete;
+	desc->callback_param	= dma;
+
+	if (dmaengine_submit(desc) < 0) {
+		dev_err(dev, "dmaengine_submit() fail\n");
+		return;
+	}
+
+	dma_async_issue_pending(dma->chan);
+}
+
+static void rsnd_dma_of_path(struct rsnd_dma *dma,
+			     int is_play,
+			     struct rsnd_mod **mod_from,
+			     struct rsnd_mod **mod_to);
+
+int rsnd_dma_init(struct rsnd_priv *priv, struct rsnd_dma *dma, int id)
+{
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct dma_slave_config cfg = {};
+	struct rsnd_mod *mod = rsnd_dma_to_mod(dma);
+	struct rsnd_mod *mod_from;
+	struct rsnd_mod *mod_to;
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(mod);
+	int is_play = rsnd_io_is_play(io);
+	char dma_name[DMA_NAME_SIZE];
+	dma_cap_mask_t mask;
+	int ret;
+
+	if (dma->chan) {
+		dev_err(dev, "it already has dma channel\n");
+		return -EIO;
+	}
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	rsnd_dma_of_path(dma, is_play, &mod_from, &mod_to);
+	rsnd_dma_of_name(mod_from, mod_to, dma_name);
+
+	cfg.direction	= is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
+	cfg.src_addr	= rsnd_gen_dma_addr(priv, mod_from, is_play, 1);
+	cfg.dst_addr	= rsnd_gen_dma_addr(priv, mod_to,   is_play, 0);
+	cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	dev_dbg(dev, "dma : %s %pad -> %pad\n",
+		dma_name, &cfg.src_addr, &cfg.dst_addr);
+
+	dma->chan = dma_request_slave_channel_compat(mask, shdma_chan_filter,
+						     (void *)id, dev,
+						     dma_name);
+	if (!dma->chan) {
+		dev_err(dev, "can't get dma channel\n");
+		goto rsnd_dma_channel_err;
+	}
+
+	ret = dmaengine_slave_config(dma->chan, &cfg);
+	if (ret < 0)
+		goto rsnd_dma_init_err;
+
+	dma->addr = is_play ? cfg.src_addr : cfg.dst_addr;
+	dma->dir = is_play ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
+
+	return 0;
+
+rsnd_dma_init_err:
+	rsnd_dma_quit(dma);
+rsnd_dma_channel_err:
+
+	/*
+	 * DMA failed. try to PIO mode
+	 * see
+	 *	rsnd_ssi_fallback()
+	 *	rsnd_rdai_continuance_probe()
+	 */
+	return -EAGAIN;
+}
+
+void rsnd_dma_quit(struct rsnd_dma *dma)
+{
+	if (dma->chan)
+		dma_release_channel(dma->chan);
+
+	dma->chan = NULL;
+}
+
+static void rsnd_dma_of_path(struct rsnd_dma *dma,
+			     int is_play,
+			     struct rsnd_mod **mod_from,
+			     struct rsnd_mod **mod_to)
+{
+	struct rsnd_mod *this = rsnd_dma_to_mod(dma);
+	struct rsnd_dai_stream *io = rsnd_mod_to_io(this);
+	struct rsnd_mod *ssi = rsnd_io_to_mod_ssi(io);
+	struct rsnd_mod *src = rsnd_io_to_mod_src(io);
+	struct rsnd_mod *dvc = rsnd_io_to_mod_dvc(io);
+	struct rsnd_mod *mod[MOD_MAX];
+	int i, index;
+
+
+	for (i = 0; i < MOD_MAX; i++)
+		mod[i] = NULL;
+
+	/*
+	 * in play case...
+	 *
+	 * src -> dst
+	 *
+	 * mem -> SSI
+	 * mem -> SRC -> SSI
+	 * mem -> SRC -> DVC -> SSI
+	 */
+	mod[0] = NULL; /* for "mem" */
+	index = 1;
+	for (i = 1; i < MOD_MAX; i++) {
+		if (!src) {
+			mod[i] = ssi;
+		} else if (!dvc) {
+			mod[i] = src;
+			src = NULL;
+		} else {
+			if ((!is_play) && (this == src))
+				this = dvc;
+
+			mod[i] = (is_play) ? src : dvc;
+			i++;
+			mod[i] = (is_play) ? dvc : src;
+			src = NULL;
+			dvc = NULL;
+		}
+
+		if (mod[i] == this)
+			index = i;
+
+		if (mod[i] == ssi)
+			break;
+	}
+
+	if (is_play) {
+		*mod_from = mod[index - 1];
+		*mod_to   = mod[index];
+	} else {
+		*mod_from = mod[index];
+		*mod_to   = mod[index - 1];
+	}
+}
+
