commit 7e7fe06de376e9874f4399dac81d65ea9b0a9507
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 30 07:46:05 2018 +0000

    ASoC: rsnd: move .get_status under rsnd_mod_ops
    
    Each mod needs to have .get_status, but current driver is handling it
    under rsnd_mod, instead of rsnd_mod_ops.
    It is not any make sence. This patch moves it to rsnd_mod_ops, and
    tidyup its parameter order to align to other callback functions.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 8e3b57eaa708..a3e0370f5704 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -256,6 +256,7 @@ static struct rsnd_mod_ops rsnd_mix_ops = {
 	.init		= rsnd_mix_init,
 	.quit		= rsnd_mix_quit,
 	.pcm_new	= rsnd_mix_pcm_new,
+	.get_status	= rsnd_mod_get_status,
 };
 
 struct rsnd_mod *rsnd_mix_mod_get(struct rsnd_priv *priv, int id)
@@ -315,7 +316,7 @@ int rsnd_mix_probe(struct rsnd_priv *priv)
 		}
 
 		ret = rsnd_mod_init(priv, rsnd_mod_get(mix), &rsnd_mix_ops,
-				    clk, rsnd_mod_get_status, RSND_MOD_MIX, i);
+				    clk, RSND_MOD_MIX, i);
 		if (ret) {
 			of_node_put(np);
 			goto rsnd_mix_probe_done;

commit 1e0edd4deadbbacd3b35179c233efa26624ab2af
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jun 12 05:58:38 2018 +0000

    ASoC: rsnd: convert to SPDX identifiers
    
    Tidyup incoherence between MODULE_LICENSE and header license, too
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 1881b2de9126..8e3b57eaa708 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -1,12 +1,8 @@
-/*
- * mix.c
- *
- * Copyright (c) 2015 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
+// SPDX-License-Identifier: GPL-2.0
+//
+// mix.c
+//
+// Copyright (c) 2015 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
 
 /*
  *		    CTUn	MIXn

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 7998380766f6..1881b2de9126 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -294,7 +294,7 @@ int rsnd_mix_probe(struct rsnd_priv *priv)
 		goto rsnd_mix_probe_done;
 	}
 
-	mix	= devm_kzalloc(dev, sizeof(*mix) * nr, GFP_KERNEL);
+	mix	= devm_kcalloc(dev, nr, sizeof(*mix), GFP_KERNEL);
 	if (!mix) {
 		ret = -ENOMEM;
 		goto rsnd_mix_probe_done;

commit 3a9fa27be507b19107a8b3fe03a67e8145aea88c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 11 04:42:34 2017 +0000

    ASoC: rsnd: add rsnd_kctrl_xxx() macro
    
    Current CTU/MIX/DVC are directly using rsnd_kctrl_cfg_m/s to control
    val etc, but it is difficult to read/understand.
    And there was no uniformity in access method.
    This patch adds new rsnd_kctrl_xxx() and implements uniformed access
    method.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 912cfec49038..7998380766f6 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -84,7 +84,7 @@ static void rsnd_mix_halt(struct rsnd_mod *mod)
 
 #define rsnd_mix_get_vol(mix, X) \
 	rsnd_flags_has(mix, HAS_VOL##X) ? \
-		(VOL_MAX - mix->volume##X.cfg.val[0]) : 0
+		(VOL_MAX - rsnd_kctrl_vals(mix->volume##X)) : 0
 static void rsnd_mix_volume_parameter(struct rsnd_dai_stream *io,
 				      struct rsnd_mod *mod)
 {
@@ -116,9 +116,9 @@ static void rsnd_mix_volume_init(struct rsnd_dai_stream *io,
 	rsnd_mod_write(mod, MIX_ADINR, rsnd_runtime_channel_after_ctu(io));
 
 	/* volume step */
-	rsnd_mod_write(mod, MIX_MIXMR, mix->ren.cfg.val[0]);
-	rsnd_mod_write(mod, MIX_MVPDR, mix->rup.cfg.val[0] << 8 |
-				       mix->rdw.cfg.val[0]);
+	rsnd_mod_write(mod, MIX_MIXMR, rsnd_kctrl_vals(mix->ren));
+	rsnd_mod_write(mod, MIX_MVPDR, rsnd_kctrl_vals(mix->rup) << 8 |
+				       rsnd_kctrl_vals(mix->rdw));
 
 	/* common volume parameter */
 	rsnd_mix_volume_parameter(io, mod);
@@ -217,7 +217,7 @@ static int rsnd_mix_pcm_new(struct rsnd_mod *mod,
 			       volume, VOL_MAX);
 	if (ret < 0)
 		return ret;
-	volume->cfg.val[0] = VOL_MAX;
+	rsnd_kctrl_vals(*volume) = VOL_MAX;
 
 	if (rsnd_flags_has(mix, ONCE_KCTRL_INITIALIZED))
 		return ret;

commit 3e3c9ee1e4b3d0ef1f68f2037752196e7260bad9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sun Oct 1 23:49:18 2017 +0000

    ASoC: rsnd: add MIX Volume Ramp support
    
    Both DVC/MIX have Volume Ramp Control. This patch supprts MIX
    Volume Ramp. One note is that main purpose of MIX Volume Ramp
    is to reduce noise, thus, MIX Ramp range is very few if you
    compare to DVC Volume Ramp (DVC = 5bit, MIX = 4bit).
    
    You can use MIX Volume Ranp like below
            amixer set "MIX Ramp Up Rate"   "0.125 dB/1 step"
            amixer set "MIX Ramp Down Rate" "0.125 dB/1 step"
            amixer set "MIX Ramp" on
            aplay xxx.wav &
            amixer set "MIX",0  80%  // DAI0 Volume Down
            amixer set "MIX",1 100%  // DAI1 Volume Up
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 6c4826c189a4..912cfec49038 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -7,6 +7,33 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+
+/*
+ *		    CTUn	MIXn
+ *		    +------+	+------+
+ * [SRC3 / SRC6] -> |CTU n0| ->	[MIX n0| ->
+ * [SRC4 / SRC9] -> |CTU n1| ->	[MIX n1| ->
+ * [SRC0 / SRC1] -> |CTU n2| ->	[MIX n2| ->
+ * [SRC2 / SRC5] -> |CTU n3| ->	[MIX n3| ->
+ *		    +------+	+------+
+ *
+ * ex)
+ *	DAI0 : playback = <&src0 &ctu02 &mix0 &dvc0 &ssi0>;
+ *	DAI1 : playback = <&src2 &ctu03 &mix0 &dvc0 &ssi0>;
+ *
+ * MIX Volume
+ *	amixer set "MIX",0  100%  // DAI0 Volume
+ *	amixer set "MIX",1  100%  // DAI1 Volume
+ *
+ * Volume Ramp
+ *	amixer set "MIX Ramp Up Rate"   "0.125 dB/1 step"
+ *	amixer set "MIX Ramp Down Rate" "4 dB/1 step"
+ *	amixer set "MIX Ramp" on
+ *	aplay xxx.wav &
+ *	amixer set "MIX",0  80%  // DAI0 Volume Down
+ *	amixer set "MIX",1 100%  // DAI1 Volume Up
+ */
+
 #include "rsnd.h"
 
 #define MIX_NAME_SIZE	16
@@ -14,8 +41,27 @@
 
 struct rsnd_mix {
 	struct rsnd_mod mod;
+	struct rsnd_kctrl_cfg_s volumeA; /* MDBAR */
+	struct rsnd_kctrl_cfg_s volumeB; /* MDBBR */
+	struct rsnd_kctrl_cfg_s volumeC; /* MDBCR */
+	struct rsnd_kctrl_cfg_s volumeD; /* MDBDR */
+	struct rsnd_kctrl_cfg_s ren;	/* Ramp Enable */
+	struct rsnd_kctrl_cfg_s rup;	/* Ramp Rate Up */
+	struct rsnd_kctrl_cfg_s rdw;	/* Ramp Rate Down */
+	u32 flags;
 };
 
+#define ONCE_KCTRL_INITIALIZED		(1 << 0)
+#define HAS_VOLA			(1 << 1)
+#define HAS_VOLB			(1 << 2)
+#define HAS_VOLC			(1 << 3)
+#define HAS_VOLD			(1 << 4)
+
+#define VOL_MAX				0x3ff
+
+#define rsnd_mod_to_mix(_mod)	\
+	container_of((_mod), struct rsnd_mix, mod)
+
 #define rsnd_mix_get(priv, id) ((struct rsnd_mix *)(priv->mix) + id)
 #define rsnd_mix_nr(priv) ((priv)->mix_nr)
 #define for_each_rsnd_mix(pos, priv, i)					\
@@ -36,26 +82,43 @@ static void rsnd_mix_halt(struct rsnd_mod *mod)
 	rsnd_mod_write(mod, MIX_SWRSR, 0);
 }
 
+#define rsnd_mix_get_vol(mix, X) \
+	rsnd_flags_has(mix, HAS_VOL##X) ? \
+		(VOL_MAX - mix->volume##X.cfg.val[0]) : 0
 static void rsnd_mix_volume_parameter(struct rsnd_dai_stream *io,
 				      struct rsnd_mod *mod)
 {
-	rsnd_mod_write(mod, MIX_MDBAR, 0);
-	rsnd_mod_write(mod, MIX_MDBBR, 0);
-	rsnd_mod_write(mod, MIX_MDBCR, 0);
-	rsnd_mod_write(mod, MIX_MDBDR, 0);
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_mix *mix = rsnd_mod_to_mix(mod);
+	u32 volA = rsnd_mix_get_vol(mix, A);
+	u32 volB = rsnd_mix_get_vol(mix, B);
+	u32 volC = rsnd_mix_get_vol(mix, C);
+	u32 volD = rsnd_mix_get_vol(mix, D);
+
+	dev_dbg(dev, "MIX A/B/C/D = %02x/%02x/%02x/%02x\n",
+		volA, volB, volC, volD);
+
+	rsnd_mod_write(mod, MIX_MDBAR, volA);
+	rsnd_mod_write(mod, MIX_MDBBR, volB);
+	rsnd_mod_write(mod, MIX_MDBCR, volC);
+	rsnd_mod_write(mod, MIX_MDBDR, volD);
 }
 
 static void rsnd_mix_volume_init(struct rsnd_dai_stream *io,
 				 struct rsnd_mod *mod)
 {
+	struct rsnd_mix *mix = rsnd_mod_to_mix(mod);
+
 	rsnd_mod_write(mod, MIX_MIXIR, 1);
 
 	/* General Information */
 	rsnd_mod_write(mod, MIX_ADINR, rsnd_runtime_channel_after_ctu(io));
 
 	/* volume step */
-	rsnd_mod_write(mod, MIX_MIXMR, 0);
-	rsnd_mod_write(mod, MIX_MVPDR, 0);
+	rsnd_mod_write(mod, MIX_MIXMR, mix->ren.cfg.val[0]);
+	rsnd_mod_write(mod, MIX_MVPDR, mix->rup.cfg.val[0] << 8 |
+				       mix->rdw.cfg.val[0]);
 
 	/* common volume parameter */
 	rsnd_mix_volume_parameter(io, mod);
@@ -109,11 +172,94 @@ static int rsnd_mix_quit(struct rsnd_mod *mod,
 	return 0;
 }
 
+static int rsnd_mix_pcm_new(struct rsnd_mod *mod,
+			    struct rsnd_dai_stream *io,
+			    struct snd_soc_pcm_runtime *rtd)
+{
+	struct rsnd_priv *priv = rsnd_mod_to_priv(mod);
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_mix *mix = rsnd_mod_to_mix(mod);
+	struct rsnd_mod *src_mod = rsnd_io_to_mod_src(io);
+	struct rsnd_kctrl_cfg_s *volume;
+	int ret;
+
+	switch (rsnd_mod_id(src_mod)) {
+	case 3:
+	case 6:	/* MDBAR */
+		volume = &mix->volumeA;
+		rsnd_flags_set(mix, HAS_VOLA);
+		break;
+	case 4:
+	case 9:	/* MDBBR */
+		volume = &mix->volumeB;
+		rsnd_flags_set(mix, HAS_VOLB);
+		break;
+	case 0:
+	case 1:	/* MDBCR */
+		volume = &mix->volumeC;
+		rsnd_flags_set(mix, HAS_VOLC);
+		break;
+	case 2:
+	case 5:	/* MDBDR */
+		volume = &mix->volumeD;
+		rsnd_flags_set(mix, HAS_VOLD);
+		break;
+	default:
+		dev_err(dev, "unknown SRC is connected\n");
+		return -EINVAL;
+	}
+
+	/* Volume */
+	ret = rsnd_kctrl_new_s(mod, io, rtd,
+			       "MIX Playback Volume",
+			       rsnd_kctrl_accept_anytime,
+			       rsnd_mix_volume_update,
+			       volume, VOL_MAX);
+	if (ret < 0)
+		return ret;
+	volume->cfg.val[0] = VOL_MAX;
+
+	if (rsnd_flags_has(mix, ONCE_KCTRL_INITIALIZED))
+		return ret;
+
+	/* Ramp */
+	ret = rsnd_kctrl_new_s(mod, io, rtd,
+			       "MIX Ramp Switch",
+			       rsnd_kctrl_accept_anytime,
+			       rsnd_mix_volume_update,
+			       &mix->ren, 1);
+	if (ret < 0)
+		return ret;
+
+	ret = rsnd_kctrl_new_e(mod, io, rtd,
+			       "MIX Ramp Up Rate",
+			       rsnd_kctrl_accept_anytime,
+			       rsnd_mix_volume_update,
+			       &mix->rup,
+			       volume_ramp_rate,
+			       VOLUME_RAMP_MAX_MIX);
+	if (ret < 0)
+		return ret;
+
+	ret = rsnd_kctrl_new_e(mod, io, rtd,
+			       "MIX Ramp Down Rate",
+			       rsnd_kctrl_accept_anytime,
+			       rsnd_mix_volume_update,
+			       &mix->rdw,
+			       volume_ramp_rate,
+			       VOLUME_RAMP_MAX_MIX);
+
+	rsnd_flags_set(mix, ONCE_KCTRL_INITIALIZED);
+
+	return ret;
+}
+
 static struct rsnd_mod_ops rsnd_mix_ops = {
 	.name		= MIX_NAME,
 	.probe		= rsnd_mix_probe_,
 	.init		= rsnd_mix_init,
 	.quit		= rsnd_mix_quit,
+	.pcm_new	= rsnd_mix_pcm_new,
 };
 
 struct rsnd_mod *rsnd_mix_mod_get(struct rsnd_priv *priv, int id)

commit 53ba2aa314164f7fcd3acf9594313811256a52c4
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sat Jul 15 09:19:07 2017 +0200

    ASoC: rsnd: add missing of_node_put
    
    for_each_child_of_node performs an of_node_get on each iteration, so a
    jump out of the loop requires an of_node_put.
    
    The semantic patch that fixes this problem is as follows
    (http://coccinelle.lip6.fr):
    
    // <smpl>
    @@
    local idexpression n;
    expression e,e1;
    identifier l;
    @@
    
     for_each_child_of_node(e1,n) {
       ...
    (
       of_node_put(n);
    |
       e = n
    |
    +  of_node_put(n);
    ?  goto l;
    )
       ...
     }
    ...
    l: ... when != n
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 195fc7bb22af..6c4826c189a4 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -168,13 +168,16 @@ int rsnd_mix_probe(struct rsnd_priv *priv)
 		clk = devm_clk_get(dev, name);
 		if (IS_ERR(clk)) {
 			ret = PTR_ERR(clk);
+			of_node_put(np);
 			goto rsnd_mix_probe_done;
 		}
 
 		ret = rsnd_mod_init(priv, rsnd_mod_get(mix), &rsnd_mix_ops,
 				    clk, rsnd_mod_get_status, RSND_MOD_MIX, i);
-		if (ret)
+		if (ret) {
+			of_node_put(np);
 			goto rsnd_mix_probe_done;
+		}
 
 		i++;
 	}

commit eed76bb811cd143119b4bdeca88606685222e687
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Feb 25 05:54:58 2016 +0000

    ASoC: rsnd: add rsnd_runtime_channel_xxx()
    
    Current SSI is supporting Normal SSI/Multi mode SSI/TDM mode SSI
    and its behavior is based on input channels.
    This input channel might be converted by CTU,
    and SSI needs to be Multi SSI mode / TDM SSI mode if 6ch input
    
    EX) 6ch input, CTU for 2ch, playback
    
     6ch    6ch    2ch    2ch    2ch     2ch
     -> SRC -> CTU -> MIX -> DVC -> SSIU -> SSI
    
    EX) 6ch input, no CTU, Multi SSI, playback
    
     6ch    6ch    6ch    6ch    6ch     2ch
     -> SRC -> CTU -> MIX -> DVC -> SSIU -> SSI0/SSI1/SSI2
    
    Current driver is using rsnd_get_adinr_chan() / rsnd_get_slot_width()
    for this purpose, but it is complicated enough without meaning.
    This patch adds new rsnd_runtime_channel_xxx() which is caring
    CTU/Multi SSI.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index e0e337ad4206..195fc7bb22af 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -51,7 +51,7 @@ static void rsnd_mix_volume_init(struct rsnd_dai_stream *io,
 	rsnd_mod_write(mod, MIX_MIXIR, 1);
 
 	/* General Information */
-	rsnd_mod_write(mod, MIX_ADINR, rsnd_get_adinr_chan(mod, io));
+	rsnd_mod_write(mod, MIX_ADINR, rsnd_runtime_channel_after_ctu(io));
 
 	/* volume step */
 	rsnd_mod_write(mod, MIX_MIXMR, 0);

commit 5ba17b42e1755c3c5cfe96370cfd47f34d01f62c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 21 01:58:07 2016 +0000

    ASoC: rsnd: each mod has status again for CTU/MUX support
    
    SSI will be used as normal SSI or as clock parent SSI. Therefor,
    rsnd driver wants to control SSI and parent SSI separately. Otherwise it
    can't use Playback/Capture in the same time.
    And it has been done by c2dc47d5cf("ASoC: rsnd: rsnd_dai_stream has each
    mod's status insted of rsnd_mod") before.
    
    OTOH, rsnd driver doesn't want to control CTU/MUX/DVC/SSIU/SSI in
    separately. Otherwise, these will be re-initialized during playing if
    MUX merges 2 sounds.
    Because of these picky reasons, this patch re-defines status on each mod,
    and add new parent_ssi_status on rsnd_dai_stream.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 65542b6a89e9..e0e337ad4206 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -172,7 +172,7 @@ int rsnd_mix_probe(struct rsnd_priv *priv)
 		}
 
 		ret = rsnd_mod_init(priv, rsnd_mod_get(mix), &rsnd_mix_ops,
-				    clk, RSND_MOD_MIX, i);
+				    clk, rsnd_mod_get_status, RSND_MOD_MIX, i);
 		if (ret)
 			goto rsnd_mix_probe_done;
 

commit 2b235a3da5560d65df6865ea436389e55a0f41ad
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 14 12:05:28 2015 +0000

    rcar: mux: Avoid use of ret uninitialised
    
    We use ret as the return value from the rsnd_mix_probe() but if there
    are no child nodes and no errors then we will never initialize ret leading
    to build warnings. Ensure ret is initialized before we iterate over the
    child nodes to avoid this.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index b34957ab75b9..65542b6a89e9 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -158,6 +158,7 @@ int rsnd_mix_probe(struct rsnd_priv *priv)
 	priv->mix	= mix;
 
 	i = 0;
+	ret = 0;
 	for_each_child_of_node(node, np) {
 		mix = rsnd_mix_get(priv, i);
 

commit 95e6b0ddb002e0dc89fef99b31685197da2eca9e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 30 08:51:52 2015 +0000

    ASoC: rsnd: mix: add rsnd_mix_halt()
    
    Based on datasheet process
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index b2f22bd7e3a9..b34957ab75b9 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -30,6 +30,12 @@ static void rsnd_mix_activation(struct rsnd_mod *mod)
 	rsnd_mod_write(mod, MIX_SWRSR, 1);
 }
 
+static void rsnd_mix_halt(struct rsnd_mod *mod)
+{
+	rsnd_mod_write(mod, MIX_MIXIR, 1);
+	rsnd_mod_write(mod, MIX_SWRSR, 0);
+}
+
 static void rsnd_mix_volume_parameter(struct rsnd_dai_stream *io,
 				      struct rsnd_mod *mod)
 {
@@ -96,6 +102,8 @@ static int rsnd_mix_quit(struct rsnd_mod *mod,
 			 struct rsnd_dai_stream *io,
 			 struct rsnd_priv *priv)
 {
+	rsnd_mix_halt(mod);
+
 	rsnd_mod_power_off(mod);
 
 	return 0;

commit 4fe32521d706e3541095ef173669e46666df2865
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 30 08:50:51 2015 +0000

    ASoC: rsnd: mix: rename rsnd_mix_soft_reset() to rsnd_mix_activation()
    
    Based on datasheet naming
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 57ac453adcef..b2f22bd7e3a9 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -24,7 +24,7 @@ struct rsnd_mix {
 		     ((pos) = (struct rsnd_mix *)(priv)->mix + i);	\
 	     i++)
 
-static void rsnd_mix_soft_reset(struct rsnd_mod *mod)
+static void rsnd_mix_activation(struct rsnd_mod *mod)
 {
 	rsnd_mod_write(mod, MIX_SWRSR, 0);
 	rsnd_mod_write(mod, MIX_SWRSR, 1);
@@ -83,7 +83,7 @@ static int rsnd_mix_init(struct rsnd_mod *mod,
 {
 	rsnd_mod_power_on(mod);
 
-	rsnd_mix_soft_reset(mod);
+	rsnd_mix_activation(mod);
 
 	rsnd_mix_volume_init(io, mod);
 

commit 2ea6b0749c366787dbf6e87c7642e23b448ca63b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:14:12 2015 +0000

    ASoC: rsnd: remove struct platform_device from probe/remove parameter
    
    Current Renesas sound driver requests struct platform_device on
    probe/remove for each modules. But driver can get it by
    rsnd_priv_to_pdev(). This patch removes unnecessary parameter
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 897e4f3d4c24..57ac453adcef 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -116,8 +116,7 @@ struct rsnd_mod *rsnd_mix_mod_get(struct rsnd_priv *priv, int id)
 	return rsnd_mod_get(rsnd_mix_get(priv, id));
 }
 
-int rsnd_mix_probe(struct platform_device *pdev,
-		   struct rsnd_priv *priv)
+int rsnd_mix_probe(struct rsnd_priv *priv)
 {
 	struct device_node *node;
 	struct device_node *np;
@@ -177,8 +176,7 @@ int rsnd_mix_probe(struct platform_device *pdev,
 	return ret;
 }
 
-void rsnd_mix_remove(struct platform_device *pdev,
-		     struct rsnd_priv *priv)
+void rsnd_mix_remove(struct rsnd_priv *priv)
 {
 	struct rsnd_mix *mix;
 	int i;

commit e797f58ead6069478e535ae62b180da87b28a84f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:13:33 2015 +0000

    ASoC: rsnd: remove struct rsnd_of_data
    
    No board is using Renesas sound driver via platform boot now.
    This means all user is using DT boot. Platform boot support is
    no longer needed. But, it strongly depends on platform boot style.
    Now, platform boot style was removed from driver.
    This is cleanup patch, and remove pointless struct rsnd_of_data
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 8b615c7aecb4..897e4f3d4c24 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -117,7 +117,6 @@ struct rsnd_mod *rsnd_mix_mod_get(struct rsnd_priv *priv, int id)
 }
 
 int rsnd_mix_probe(struct platform_device *pdev,
-		   const struct rsnd_of_data *of_data,
 		   struct rsnd_priv *priv)
 {
 	struct device_node *node;

commit c7fe4be840026d7cdb0676e1d52b9f82e8b32d41
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:12:32 2015 +0000

    ASoC: rsnd: remove platform boot support from mix.c
    
    No board is using Renesas sound driver via platform boot now.
    This means all user is using DT boot. Platform boot support is
    no longer needed. But, it strongly depends on platform boot style.
    This patch removes platform boot support from mix.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 195bc748a32f..8b615c7aecb4 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -13,10 +13,10 @@
 #define MIX_NAME "mix"
 
 struct rsnd_mix {
-	struct rsnd_mix_platform_info *info; /* rcar_snd.h */
 	struct rsnd_mod mod;
 };
 
+#define rsnd_mix_get(priv, id) ((struct rsnd_mix *)(priv->mix) + id)
 #define rsnd_mix_nr(priv) ((priv)->mix_nr)
 #define for_each_rsnd_mix(pos, priv, i)					\
 	for ((i) = 0;							\
@@ -24,7 +24,6 @@ struct rsnd_mix {
 		     ((pos) = (struct rsnd_mix *)(priv)->mix + i);	\
 	     i++)
 
-
 static void rsnd_mix_soft_reset(struct rsnd_mod *mod)
 {
 	rsnd_mod_write(mod, MIX_SWRSR, 0);
@@ -114,51 +113,15 @@ struct rsnd_mod *rsnd_mix_mod_get(struct rsnd_priv *priv, int id)
 	if (WARN_ON(id < 0 || id >= rsnd_mix_nr(priv)))
 		id = 0;
 
-	return rsnd_mod_get((struct rsnd_mix *)(priv->mix) + id);
-}
-
-static void rsnd_of_parse_mix(struct platform_device *pdev,
-			      const struct rsnd_of_data *of_data,
-			      struct rsnd_priv *priv)
-{
-	struct device_node *node;
-	struct rsnd_mix_platform_info *mix_info;
-	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
-	struct device *dev = &pdev->dev;
-	int nr;
-
-	if (!of_data)
-		return;
-
-	node = rsnd_mix_of_node(priv);
-	if (!node)
-		return;
-
-	nr = of_get_child_count(node);
-	if (!nr)
-		goto rsnd_of_parse_mix_end;
-
-	mix_info = devm_kzalloc(dev,
-				sizeof(struct rsnd_mix_platform_info) * nr,
-				GFP_KERNEL);
-	if (!mix_info) {
-		dev_err(dev, "mix info allocation error\n");
-		goto rsnd_of_parse_mix_end;
-	}
-
-	info->mix_info		= mix_info;
-	info->mix_info_nr	= nr;
-
-rsnd_of_parse_mix_end:
-	of_node_put(node);
-
+	return rsnd_mod_get(rsnd_mix_get(priv, id));
 }
 
 int rsnd_mix_probe(struct platform_device *pdev,
 		   const struct rsnd_of_data *of_data,
 		   struct rsnd_priv *priv)
 {
-	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
+	struct device_node *node;
+	struct device_node *np;
 	struct device *dev = rsnd_priv_to_dev(priv);
 	struct rsnd_mix *mix;
 	struct clk *clk;
@@ -169,36 +132,50 @@ int rsnd_mix_probe(struct platform_device *pdev,
 	if (rsnd_is_gen1(priv))
 		return 0;
 
-	rsnd_of_parse_mix(pdev, of_data, priv);
+	node = rsnd_mix_of_node(priv);
+	if (!node)
+		return 0; /* not used is not error */
 
-	nr = info->mix_info_nr;
-	if (!nr)
-		return 0;
+	nr = of_get_child_count(node);
+	if (!nr) {
+		ret = -EINVAL;
+		goto rsnd_mix_probe_done;
+	}
 
 	mix	= devm_kzalloc(dev, sizeof(*mix) * nr, GFP_KERNEL);
-	if (!mix)
-		return -ENOMEM;
+	if (!mix) {
+		ret = -ENOMEM;
+		goto rsnd_mix_probe_done;
+	}
 
 	priv->mix_nr	= nr;
 	priv->mix	= mix;
 
-	for_each_rsnd_mix(mix, priv, i) {
+	i = 0;
+	for_each_child_of_node(node, np) {
+		mix = rsnd_mix_get(priv, i);
+
 		snprintf(name, MIX_NAME_SIZE, "%s.%d",
 			 MIX_NAME, i);
 
 		clk = devm_clk_get(dev, name);
-		if (IS_ERR(clk))
-			return PTR_ERR(clk);
-
-		mix->info = &info->mix_info[i];
+		if (IS_ERR(clk)) {
+			ret = PTR_ERR(clk);
+			goto rsnd_mix_probe_done;
+		}
 
 		ret = rsnd_mod_init(priv, rsnd_mod_get(mix), &rsnd_mix_ops,
 				    clk, RSND_MOD_MIX, i);
 		if (ret)
-			return ret;
+			goto rsnd_mix_probe_done;
+
+		i++;
 	}
 
-	return 0;
+rsnd_mix_probe_done:
+	of_node_put(node);
+
+	return ret;
 }
 
 void rsnd_mix_remove(struct platform_device *pdev,

commit 94e2710cd2ce447cde879177d869b9ac231bc459
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 05:11:18 2015 +0000

    ASoC: rsnd: remove platform boot support from core.c
    
    No board is using Renesas sound driver via platform boot now.
    This means all user is using DT boot. Platform boot support is
    no longer needed. But, it strongly depends on platform boot style.
    This patch removes platform boot support from core.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 2baa2d79bfc0..195bc748a32f 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -130,7 +130,7 @@ static void rsnd_of_parse_mix(struct platform_device *pdev,
 	if (!of_data)
 		return;
 
-	node = of_get_child_by_name(dev->of_node, "rcar_sound,mix");
+	node = rsnd_mix_of_node(priv);
 	if (!node)
 		return;
 

commit 13e0d17d08d1d651aa119c286f74cf366caf09dd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 4 08:44:32 2015 +0000

    ASoC: rsnd: MIX settings matches to datasheet
    
    Current MIX settings order was rough.
    This patch makes it match to datasheet.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index bcbd821981a9..2baa2d79bfc0 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -31,24 +31,41 @@ static void rsnd_mix_soft_reset(struct rsnd_mod *mod)
 	rsnd_mod_write(mod, MIX_SWRSR, 1);
 }
 
-#define rsnd_mix_initialize_lock(mod)	__rsnd_mix_initialize_lock(mod, 1)
-#define rsnd_mix_initialize_unlock(mod)	__rsnd_mix_initialize_lock(mod, 0)
-static void __rsnd_mix_initialize_lock(struct rsnd_mod *mod, u32 enable)
+static void rsnd_mix_volume_parameter(struct rsnd_dai_stream *io,
+				      struct rsnd_mod *mod)
 {
-	rsnd_mod_write(mod, MIX_MIXIR, enable);
+	rsnd_mod_write(mod, MIX_MDBAR, 0);
+	rsnd_mod_write(mod, MIX_MDBBR, 0);
+	rsnd_mod_write(mod, MIX_MDBCR, 0);
+	rsnd_mod_write(mod, MIX_MDBDR, 0);
+}
+
+static void rsnd_mix_volume_init(struct rsnd_dai_stream *io,
+				 struct rsnd_mod *mod)
+{
+	rsnd_mod_write(mod, MIX_MIXIR, 1);
+
+	/* General Information */
+	rsnd_mod_write(mod, MIX_ADINR, rsnd_get_adinr_chan(mod, io));
+
+	/* volume step */
+	rsnd_mod_write(mod, MIX_MIXMR, 0);
+	rsnd_mod_write(mod, MIX_MVPDR, 0);
+
+	/* common volume parameter */
+	rsnd_mix_volume_parameter(io, mod);
+
+	rsnd_mod_write(mod, MIX_MIXIR, 0);
 }
 
 static void rsnd_mix_volume_update(struct rsnd_dai_stream *io,
 				  struct rsnd_mod *mod)
 {
-
 	/* Disable MIX dB setting */
 	rsnd_mod_write(mod, MIX_MDBER, 0);
 
-	rsnd_mod_write(mod, MIX_MDBAR, 0);
-	rsnd_mod_write(mod, MIX_MDBBR, 0);
-	rsnd_mod_write(mod, MIX_MDBCR, 0);
-	rsnd_mod_write(mod, MIX_MDBDR, 0);
+	/* common volume parameter */
+	rsnd_mix_volume_parameter(io, mod);
 
 	/* Enable MIX dB setting */
 	rsnd_mod_write(mod, MIX_MDBER, 1);
@@ -69,18 +86,10 @@ static int rsnd_mix_init(struct rsnd_mod *mod,
 
 	rsnd_mix_soft_reset(mod);
 
-	rsnd_mix_initialize_lock(mod);
-
-	rsnd_mod_write(mod, MIX_ADINR, rsnd_get_adinr_chan(mod, io));
-
-	/* volume step */
-	rsnd_mod_write(mod, MIX_MIXMR, 0);
-	rsnd_mod_write(mod, MIX_MVPDR, 0);
+	rsnd_mix_volume_init(io, mod);
 
 	rsnd_mix_volume_update(io, mod);
 
-	rsnd_mix_initialize_unlock(mod);
-
 	return 0;
 }
 

commit 1b2ca0adf1a0cb3aa766259650eddd25b44486b7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 26 08:43:21 2015 +0000

    ASoC: rsnd: use mod base common method on CMD
    
    Renesas sound needs many devices
    (SSI/SSIU/SRC/CTU/MIX/DVC/CMD/AudioDMAC/AudioDMACpp).
    SSI/SRC/CTU/MIX/DVC are implemented as module.
    SSI parent, SSIU are implemented as part of SSI
    CMD is implemented as part of CTU/MIX/DVC
    AudioDMAC/AudioDMACpp are implemented as part of SSI/SRC
    It is nice sense that these all devices are implemented as mod.
    
    This patch makes CMD mod base common method
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 953dd0be9b60..bcbd821981a9 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -54,6 +54,13 @@ static void rsnd_mix_volume_update(struct rsnd_dai_stream *io,
 	rsnd_mod_write(mod, MIX_MDBER, 1);
 }
 
+static int rsnd_mix_probe_(struct rsnd_mod *mod,
+			   struct rsnd_dai_stream *io,
+			   struct rsnd_priv *priv)
+{
+	return rsnd_cmd_attach(io, rsnd_mod_id(mod));
+}
+
 static int rsnd_mix_init(struct rsnd_mod *mod,
 			 struct rsnd_dai_stream *io,
 			 struct rsnd_priv *priv)
@@ -66,8 +73,6 @@ static int rsnd_mix_init(struct rsnd_mod *mod,
 
 	rsnd_mod_write(mod, MIX_ADINR, rsnd_get_adinr_chan(mod, io));
 
-	rsnd_path_parse(priv, io);
-
 	/* volume step */
 	rsnd_mod_write(mod, MIX_MIXMR, 0);
 	rsnd_mod_write(mod, MIX_MVPDR, 0);
@@ -90,6 +95,7 @@ static int rsnd_mix_quit(struct rsnd_mod *mod,
 
 static struct rsnd_mod_ops rsnd_mix_ops = {
 	.name		= MIX_NAME,
+	.probe		= rsnd_mix_probe_,
 	.init		= rsnd_mix_init,
 	.quit		= rsnd_mix_quit,
 };

commit c9929345018927acaf52c14c57d78116067be6c9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Oct 22 03:15:04 2015 +0000

    ASoC: rsnd: rename rsnd_mod_hw_start/stop to rsnd_mod_power_on/off
    
    rsnd_mod_hw_start/stop were unclear naming.
    It became rsnd_mod_power_on/off by this patch
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index ac2687d9ee55..953dd0be9b60 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -58,7 +58,7 @@ static int rsnd_mix_init(struct rsnd_mod *mod,
 			 struct rsnd_dai_stream *io,
 			 struct rsnd_priv *priv)
 {
-	rsnd_mod_hw_start(mod);
+	rsnd_mod_power_on(mod);
 
 	rsnd_mix_soft_reset(mod);
 
@@ -83,7 +83,7 @@ static int rsnd_mix_quit(struct rsnd_mod *mod,
 			 struct rsnd_dai_stream *io,
 			 struct rsnd_priv *priv)
 {
-	rsnd_mod_hw_stop(mod);
+	rsnd_mod_power_off(mod);
 
 	return 0;
 }

commit 8a98b4223d0eab88bba5eb215b275da4ff6ed99c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Oct 15 03:25:28 2015 +0000

    ASoC: rsnd: Gen1 probe is not error
    
    Probing from Gen1 is not error. This patch fixup it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 8544403ffb26..ac2687d9ee55 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -151,10 +151,8 @@ int rsnd_mix_probe(struct platform_device *pdev,
 	int i, nr, ret;
 
 	/* This driver doesn't support Gen1 at this point */
-	if (rsnd_is_gen1(priv)) {
-		dev_warn(dev, "MIX is not supported on Gen1\n");
-		return -EINVAL;
-	}
+	if (rsnd_is_gen1(priv))
+		return 0;
 
 	rsnd_of_parse_mix(pdev, of_data, priv);
 

commit b76e218ae5e5e8d8025b75066e82ad0674e2e845
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 10 07:02:21 2015 +0000

    ASoC: rsnd: add rsnd_mod_get() macro and use it
    
    Renesas sound driver has SSI/SRC/DVC/CTU/MIX, and these are controlled
    as modules. And these module are member of each modules's private data.
    It used own method to get module pointer, but Let's use common method
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
index 0d5c102db6f5..8544403ffb26 100644
--- a/sound/soc/sh/rcar/mix.c
+++ b/sound/soc/sh/rcar/mix.c
@@ -99,7 +99,7 @@ struct rsnd_mod *rsnd_mix_mod_get(struct rsnd_priv *priv, int id)
 	if (WARN_ON(id < 0 || id >= rsnd_mix_nr(priv)))
 		id = 0;
 
-	return &((struct rsnd_mix *)(priv->mix) + id)->mod;
+	return rsnd_mod_get((struct rsnd_mix *)(priv->mix) + id);
 }
 
 static void rsnd_of_parse_mix(struct platform_device *pdev,
@@ -179,7 +179,7 @@ int rsnd_mix_probe(struct platform_device *pdev,
 
 		mix->info = &info->mix_info[i];
 
-		ret = rsnd_mod_init(priv, &mix->mod, &rsnd_mix_ops,
+		ret = rsnd_mod_init(priv, rsnd_mod_get(mix), &rsnd_mix_ops,
 				    clk, RSND_MOD_MIX, i);
 		if (ret)
 			return ret;
@@ -195,6 +195,6 @@ void rsnd_mix_remove(struct platform_device *pdev,
 	int i;
 
 	for_each_rsnd_mix(mix, priv, i) {
-		rsnd_mod_quit(&mix->mod);
+		rsnd_mod_quit(rsnd_mod_get(mix));
 	}
 }

commit 70fb10529f61c31c26397a02091177bedd23217d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:17:36 2015 +0000

    ASoC: rsnd: add MIX (Mixer) support
    
    This patch adds MIX (Mixer) initial support for rsnd driver.
    It is assuming that this MIX is used via DPCM.
    
    This is sample code for playback.
    
            CPU0  : [MEM] -> [SRC1] -> [CTU02] -+
                                                |
                                                +-> [MIX0] -> [DVC0] -> [SSI0]
                                                |
            CPU1  : [MEM] -> [SRC2] -> [CTU03] -+
    
            sound {
                    compatible = "renesas,rsrc-card";
    
                    ...
    
                    cpu@0 {
                            sound-dai = <&rcar_sound 0>;
                    };
    
                    cpu@1 {
                            sound-dai = <&rcar_sound 1>;
                    };
    
                    codec {
                            ...
                    };
            };
    
            rcar_sound {
    
                    ...
    
                    rcar_sound,dai {
                            dai0 {
                                    playback = <&src1 &ctu02 &mix0 &dvc0 &ssi0>;
                            };
                            dai1 {
                                    playback = <&src2 &ctu03 &mix0 &dvc0 &ssi0>;
                            };
                    };
            };
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/sh/rcar/mix.c b/sound/soc/sh/rcar/mix.c
new file mode 100644
index 000000000000..0d5c102db6f5
--- /dev/null
+++ b/sound/soc/sh/rcar/mix.c
@@ -0,0 +1,200 @@
+/*
+ * mix.c
+ *
+ * Copyright (c) 2015 Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "rsnd.h"
+
+#define MIX_NAME_SIZE	16
+#define MIX_NAME "mix"
+
+struct rsnd_mix {
+	struct rsnd_mix_platform_info *info; /* rcar_snd.h */
+	struct rsnd_mod mod;
+};
+
+#define rsnd_mix_nr(priv) ((priv)->mix_nr)
+#define for_each_rsnd_mix(pos, priv, i)					\
+	for ((i) = 0;							\
+	     ((i) < rsnd_mix_nr(priv)) &&				\
+		     ((pos) = (struct rsnd_mix *)(priv)->mix + i);	\
+	     i++)
+
+
+static void rsnd_mix_soft_reset(struct rsnd_mod *mod)
+{
+	rsnd_mod_write(mod, MIX_SWRSR, 0);
+	rsnd_mod_write(mod, MIX_SWRSR, 1);
+}
+
+#define rsnd_mix_initialize_lock(mod)	__rsnd_mix_initialize_lock(mod, 1)
+#define rsnd_mix_initialize_unlock(mod)	__rsnd_mix_initialize_lock(mod, 0)
+static void __rsnd_mix_initialize_lock(struct rsnd_mod *mod, u32 enable)
+{
+	rsnd_mod_write(mod, MIX_MIXIR, enable);
+}
+
+static void rsnd_mix_volume_update(struct rsnd_dai_stream *io,
+				  struct rsnd_mod *mod)
+{
+
+	/* Disable MIX dB setting */
+	rsnd_mod_write(mod, MIX_MDBER, 0);
+
+	rsnd_mod_write(mod, MIX_MDBAR, 0);
+	rsnd_mod_write(mod, MIX_MDBBR, 0);
+	rsnd_mod_write(mod, MIX_MDBCR, 0);
+	rsnd_mod_write(mod, MIX_MDBDR, 0);
+
+	/* Enable MIX dB setting */
+	rsnd_mod_write(mod, MIX_MDBER, 1);
+}
+
+static int rsnd_mix_init(struct rsnd_mod *mod,
+			 struct rsnd_dai_stream *io,
+			 struct rsnd_priv *priv)
+{
+	rsnd_mod_hw_start(mod);
+
+	rsnd_mix_soft_reset(mod);
+
+	rsnd_mix_initialize_lock(mod);
+
+	rsnd_mod_write(mod, MIX_ADINR, rsnd_get_adinr_chan(mod, io));
+
+	rsnd_path_parse(priv, io);
+
+	/* volume step */
+	rsnd_mod_write(mod, MIX_MIXMR, 0);
+	rsnd_mod_write(mod, MIX_MVPDR, 0);
+
+	rsnd_mix_volume_update(io, mod);
+
+	rsnd_mix_initialize_unlock(mod);
+
+	return 0;
+}
+
+static int rsnd_mix_quit(struct rsnd_mod *mod,
+			 struct rsnd_dai_stream *io,
+			 struct rsnd_priv *priv)
+{
+	rsnd_mod_hw_stop(mod);
+
+	return 0;
+}
+
+static struct rsnd_mod_ops rsnd_mix_ops = {
+	.name		= MIX_NAME,
+	.init		= rsnd_mix_init,
+	.quit		= rsnd_mix_quit,
+};
+
+struct rsnd_mod *rsnd_mix_mod_get(struct rsnd_priv *priv, int id)
+{
+	if (WARN_ON(id < 0 || id >= rsnd_mix_nr(priv)))
+		id = 0;
+
+	return &((struct rsnd_mix *)(priv->mix) + id)->mod;
+}
+
+static void rsnd_of_parse_mix(struct platform_device *pdev,
+			      const struct rsnd_of_data *of_data,
+			      struct rsnd_priv *priv)
+{
+	struct device_node *node;
+	struct rsnd_mix_platform_info *mix_info;
+	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
+	struct device *dev = &pdev->dev;
+	int nr;
+
+	if (!of_data)
+		return;
+
+	node = of_get_child_by_name(dev->of_node, "rcar_sound,mix");
+	if (!node)
+		return;
+
+	nr = of_get_child_count(node);
+	if (!nr)
+		goto rsnd_of_parse_mix_end;
+
+	mix_info = devm_kzalloc(dev,
+				sizeof(struct rsnd_mix_platform_info) * nr,
+				GFP_KERNEL);
+	if (!mix_info) {
+		dev_err(dev, "mix info allocation error\n");
+		goto rsnd_of_parse_mix_end;
+	}
+
+	info->mix_info		= mix_info;
+	info->mix_info_nr	= nr;
+
+rsnd_of_parse_mix_end:
+	of_node_put(node);
+
+}
+
+int rsnd_mix_probe(struct platform_device *pdev,
+		   const struct rsnd_of_data *of_data,
+		   struct rsnd_priv *priv)
+{
+	struct rcar_snd_info *info = rsnd_priv_to_info(priv);
+	struct device *dev = rsnd_priv_to_dev(priv);
+	struct rsnd_mix *mix;
+	struct clk *clk;
+	char name[MIX_NAME_SIZE];
+	int i, nr, ret;
+
+	/* This driver doesn't support Gen1 at this point */
+	if (rsnd_is_gen1(priv)) {
+		dev_warn(dev, "MIX is not supported on Gen1\n");
+		return -EINVAL;
+	}
+
+	rsnd_of_parse_mix(pdev, of_data, priv);
+
+	nr = info->mix_info_nr;
+	if (!nr)
+		return 0;
+
+	mix	= devm_kzalloc(dev, sizeof(*mix) * nr, GFP_KERNEL);
+	if (!mix)
+		return -ENOMEM;
+
+	priv->mix_nr	= nr;
+	priv->mix	= mix;
+
+	for_each_rsnd_mix(mix, priv, i) {
+		snprintf(name, MIX_NAME_SIZE, "%s.%d",
+			 MIX_NAME, i);
+
+		clk = devm_clk_get(dev, name);
+		if (IS_ERR(clk))
+			return PTR_ERR(clk);
+
+		mix->info = &info->mix_info[i];
+
+		ret = rsnd_mod_init(priv, &mix->mod, &rsnd_mix_ops,
+				    clk, RSND_MOD_MIX, i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+void rsnd_mix_remove(struct platform_device *pdev,
+		     struct rsnd_priv *priv)
+{
+	struct rsnd_mix *mix;
+	int i;
+
+	for_each_rsnd_mix(mix, priv, i) {
+		rsnd_mod_quit(&mix->mod);
+	}
+}
