commit d1aaa2e68619ca4c1cc05ce7bc029cda5a8cbe87
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 2 06:21:54 2018 +0000

    ASoC: soc-io.c: convert to SPDX identifiers
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 026cd5347e53..1ff9175e9d5e 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -1,15 +1,10 @@
-/*
- * soc-io.c  --  ASoC register I/O helpers
- *
- * Copyright 2009-2011 Wolfson Microelectronics PLC.
- *
- * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- */
+// SPDX-License-Identifier: GPL-2.0+
+//
+// soc-io.c  --  ASoC register I/O helpers
+//
+// Copyright 2009-2011 Wolfson Microelectronics PLC.
+//
+// Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 
 #include <linux/i2c.h>
 #include <linux/spi/spi.h>

commit 999f7f5af8eb7766f68d925a22bf296011abc84c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 8 03:20:24 2018 +0000

    ASoC: remove Codec related code
    
    Now no one is using Codec related code.
    Let's remove all
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index c92a04bac3c5..026cd5347e53 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -32,8 +32,6 @@ int snd_soc_component_read(struct snd_soc_component *component,
 
 	if (component->regmap)
 		ret = regmap_read(component->regmap, reg, val);
-	else if (component->read)
-		ret = component->read(component, reg, val);
 	else if (component->driver->read) {
 		*val = component->driver->read(component, reg);
 		ret = 0;
@@ -72,8 +70,6 @@ int snd_soc_component_write(struct snd_soc_component *component,
 {
 	if (component->regmap)
 		return regmap_write(component->regmap, reg, val);
-	else if (component->write)
-		return component->write(component, reg, val);
 	else if (component->driver->write)
 		return component->driver->write(component, reg, val);
 	else
@@ -209,61 +205,3 @@ int snd_soc_component_test_bits(struct snd_soc_component *component,
 	return old != new;
 }
 EXPORT_SYMBOL_GPL(snd_soc_component_test_bits);
-
-unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
-{
-	unsigned int val;
-	int ret;
-
-	ret = snd_soc_component_read(&codec->component, reg, &val);
-	if (ret < 0)
-		return -1;
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(snd_soc_read);
-
-int snd_soc_write(struct snd_soc_codec *codec, unsigned int reg,
-	unsigned int val)
-{
-	return snd_soc_component_write(&codec->component, reg, val);
-}
-EXPORT_SYMBOL_GPL(snd_soc_write);
-
-/**
- * snd_soc_update_bits - update codec register bits
- * @codec: audio codec
- * @reg: codec register
- * @mask: register mask
- * @value: new value
- *
- * Writes new register value.
- *
- * Returns 1 for change, 0 for no change, or negative error code.
- */
-int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned int reg,
-				unsigned int mask, unsigned int value)
-{
-	return snd_soc_component_update_bits(&codec->component, reg, mask,
-		value);
-}
-EXPORT_SYMBOL_GPL(snd_soc_update_bits);
-
-/**
- * snd_soc_test_bits - test register for change
- * @codec: audio codec
- * @reg: codec register
- * @mask: register mask
- * @value: new value
- *
- * Tests a register with a new value and checks if the new value is
- * different from the old value.
- *
- * Returns 1 for change else 0.
- */
-int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned int reg,
-				unsigned int mask, unsigned int value)
-{
-	return snd_soc_component_test_bits(&codec->component, reg, mask, value);
-}
-EXPORT_SYMBOL_GPL(snd_soc_test_bits);

commit ef050bece1b5564b2c7135ceadc0d5ffdcf152f7
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Tue Apr 24 16:39:02 2018 +0100

    ASoC: Remove platform code now everything is componentised
    
    As all drivers have been moved over to the new generic component
    code remove the now unused platform specific code.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index d36a192fbece..c92a04bac3c5 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -267,24 +267,3 @@ int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned int reg,
 	return snd_soc_component_test_bits(&codec->component, reg, mask, value);
 }
 EXPORT_SYMBOL_GPL(snd_soc_test_bits);
-
-int snd_soc_platform_read(struct snd_soc_platform *platform,
-					unsigned int reg)
-{
-	unsigned int val;
-	int ret;
-
-	ret = snd_soc_component_read(&platform->component, reg, &val);
-	if (ret < 0)
-		return -1;
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(snd_soc_platform_read);
-
-int snd_soc_platform_write(struct snd_soc_platform *platform,
-					 unsigned int reg, unsigned int val)
-{
-	return snd_soc_component_write(&platform->component, reg, val);
-}
-EXPORT_SYMBOL_GPL(snd_soc_platform_write);

commit dead99e8579b6e2ebdf1e9c819e67d7f4a5cedbb
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Mon Mar 12 16:24:23 2018 +0200

    ASoC: soc-io: Fix snd_soc_component_update_bits_legacy
    
    After the codec to component conversion codecs with custom read/write
    function will no longer able to use update_bits as their io callbacks are
    registered at component->driver level and not in component level.
    
    To not complicate the code further, lets just use the
    snd_soc_component_read/snd_soc_component_write function and let them sort
    out the correct io function to call.
    
    Fixes: d0ff8ba57d965 ("ASoC: add Component level .read/.write")
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 2bc1c4c17896..d36a192fbece 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -88,19 +88,16 @@ static int snd_soc_component_update_bits_legacy(
 	unsigned int old, new;
 	int ret;
 
-	if (!component->read || !component->write)
-		return -EIO;
-
 	mutex_lock(&component->io_mutex);
 
-	ret = component->read(component, reg, &old);
+	ret = snd_soc_component_read(component, reg, &old);
 	if (ret < 0)
 		goto out_unlock;
 
 	new = (old & ~mask) | (val & mask);
 	*change = old != new;
 	if (*change)
-		ret = component->write(component, reg, new);
+		ret = snd_soc_component_write(component, reg, new);
 out_unlock:
 	mutex_unlock(&component->io_mutex);
 

commit d0ff8ba57d9654e6f7a2e18f192bac3b93268fef
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jan 16 02:00:59 2018 +0000

    ASoC: add Component level .read/.write
    
    In current ALSA SoC, Codec only has .read/.write callback.
    Codec will be merged into Component in next generation ALSA SoC,
    thus current Codec specific feature need to be merged into it.
    This is glue patch for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 20340ade20a7..2bc1c4c17896 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -34,6 +34,10 @@ int snd_soc_component_read(struct snd_soc_component *component,
 		ret = regmap_read(component->regmap, reg, val);
 	else if (component->read)
 		ret = component->read(component, reg, val);
+	else if (component->driver->read) {
+		*val = component->driver->read(component, reg);
+		ret = 0;
+	}
 	else
 		ret = -EIO;
 
@@ -70,6 +74,8 @@ int snd_soc_component_write(struct snd_soc_component *component,
 		return regmap_write(component->regmap, reg, val);
 	else if (component->write)
 		return component->write(component, reg, val);
+	else if (component->driver->write)
+		return component->driver->write(component, reg, val);
 	else
 		return -EIO;
 }

commit 738b49efe6c6ba485e2b45265db535c58bbd54e7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 6 01:48:19 2017 +0000

    ASoC: add snd_soc_component_read32
    
    Current codec drivers are using snd_soc_read(). It will be replaced
    into snd_soc_component_read(), but these 2 are using different style.
    For example, it will be
    
            - val = snd_soc_read(xxx, reg);
            + ret = snd_soc_component_read(xxx, reg, &val);
            + if (ret < 0) {
            +       ...
            + }
    
    To more smooth replace, let's add snd_soc_component_read32
    which is copied from snd_soc_read()
    
            - val = snd_soc_read(xxx, reg);
            + val = snd_soc_component_read32(xxx, reg);
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 9b3939049cef..20340ade20a7 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -41,6 +41,20 @@ int snd_soc_component_read(struct snd_soc_component *component,
 }
 EXPORT_SYMBOL_GPL(snd_soc_component_read);
 
+unsigned int snd_soc_component_read32(struct snd_soc_component *component,
+				      unsigned int reg)
+{
+	unsigned int val;
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret < 0)
+		return -1;
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_read32);
+
 /**
  * snd_soc_component_write() - Write register value
  * @component: Component to write to

commit 886f5692253de1a9509f5cb708432b2157afb57c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:28 2014 +0200

    ASoC: Automatically initialize regmap for all components
    
    So far regmap is only automatically initialized for CODECs. Now that we have the
    infrastructure in place to let components have DAPM widgets and controls that
    want to use the generic regmap based IO also make sure to automatically
    initialize regmap for all components.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 7767fbd73eb7..9b3939049cef 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -271,31 +271,3 @@ int snd_soc_platform_write(struct snd_soc_platform *platform,
 	return snd_soc_component_write(&platform->component, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_platform_write);
-
-/**
- * snd_soc_component_init_io() - Initialize regmap IO
- *
- * @component: component to initialize
- * @regmap: regmap instance to use for IO operations
- *
- * Return: 0 on success, a negative error code otherwise
- */
-int snd_soc_component_init_io(struct snd_soc_component *component,
-	struct regmap *regmap)
-{
-	int ret;
-
-	if (!regmap)
-		return -EINVAL;
-
-	ret = regmap_get_val_bytes(regmap);
-	/* Errors are legitimate for non-integer byte
-	 * multiples */
-	if (ret > 0)
-		component->val_bytes = ret;
-
-	component->regmap = regmap;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_component_init_io);

commit 111c0cf566777ebbe026228b72df95788e771831
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Apr 22 13:23:17 2014 +0200

    ASoC: Remove ASoC level IO tracing
    
    The ASoC framework is in the process of migrating all IO operations to regmap.
    regmap has its own more sophisticated tracing infrastructure for IO operations,
    which means that the ASoC level IO tracing becomes redundant, hence this patch
    removes them. There are still a handful of ASoC drivers left that do not use
    regmap yet, but hopefully the removal of the ASoC IO tracing will be an
    additional incentive to switch to regmap.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 2ead9edd0d63..7767fbd73eb7 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -17,8 +17,6 @@
 #include <linux/export.h>
 #include <sound/soc.h>
 
-#include <trace/events/asoc.h>
-
 /**
  * snd_soc_component_read() - Read register value
  * @component: Component to read from
@@ -39,8 +37,6 @@ int snd_soc_component_read(struct snd_soc_component *component,
 	else
 		ret = -EIO;
 
-	dev_dbg(component->dev, "read %x => %x\n", reg, *val);
-
 	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_component_read);
@@ -56,8 +52,6 @@ EXPORT_SYMBOL_GPL(snd_soc_component_read);
 int snd_soc_component_write(struct snd_soc_component *component,
 	unsigned int reg, unsigned int val)
 {
-	dev_dbg(component->dev, "write %x = %x\n", reg, val);
-
 	if (component->regmap)
 		return regmap_write(component->regmap, reg, val);
 	else if (component->write)
@@ -207,7 +201,6 @@ unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
 	ret = snd_soc_component_read(&codec->component, reg, &val);
 	if (ret < 0)
 		return -1;
-	trace_snd_soc_reg_read(codec, reg, val);
 
 	return val;
 }
@@ -216,7 +209,6 @@ EXPORT_SYMBOL_GPL(snd_soc_read);
 int snd_soc_write(struct snd_soc_codec *codec, unsigned int reg,
 	unsigned int val)
 {
-	trace_snd_soc_reg_write(codec, reg, val);
 	return snd_soc_component_write(&codec->component, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_write);
@@ -269,8 +261,6 @@ int snd_soc_platform_read(struct snd_soc_platform *platform,
 	if (ret < 0)
 		return -1;
 
-	trace_snd_soc_preg_read(platform, reg, val);
-
 	return val;
 }
 EXPORT_SYMBOL_GPL(snd_soc_platform_read);
@@ -278,7 +268,6 @@ EXPORT_SYMBOL_GPL(snd_soc_platform_read);
 int snd_soc_platform_write(struct snd_soc_platform *platform,
 					 unsigned int reg, unsigned int val)
 {
-	trace_snd_soc_preg_write(platform, reg, val);
 	return snd_soc_component_write(&platform->component, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_platform_write);

commit b0a9f8e06cb214040da5ccfcc3c2a01174710e34
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Apr 22 13:23:15 2014 +0200

    ASoC: Remove snd_soc_update_bits_locked()
    
    There are no users of snd_soc_update_bits_locked() left and it is identical to
    snd_soc_update_bits(). So it can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index ac64fd7252b2..2ead9edd0d63 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -240,26 +240,6 @@ int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned int reg,
 }
 EXPORT_SYMBOL_GPL(snd_soc_update_bits);
 
-/**
- * snd_soc_update_bits_locked - update codec register bits
- * @codec: audio codec
- * @reg: codec register
- * @mask: register mask
- * @value: new value
- *
- * Writes new register value, and takes the codec mutex.
- *
- * Returns 1 for change else 0.
- */
-int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
-			       unsigned int reg, unsigned int mask,
-			       unsigned int value)
-{
-	return snd_soc_component_update_bits(&codec->component, reg, mask,
-		value);
-}
-EXPORT_SYMBOL_GPL(snd_soc_update_bits_locked);
-
 /**
  * snd_soc_test_bits - test register for change
  * @codec: audio codec

commit e2c330b9b5665006c99327c05bc22f7a8e471043
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Apr 22 13:23:13 2014 +0200

    ASoC: Move IO abstraction to the component level
    
    We currently have two very similar IO abstractions in ASoC, one for CODECs, the
    other for platforms. Moving this to the component level will allow us to unify
    those two. It will also enable us to move the standard kcontrol helpers as well
    as DAPM support to the component level.
    
    The new component level abstraction layer is primarily build around regmap.
    There is a per component pointer for the regmap instance for the underlying
    device. There are four new function snd_soc_component_read(),
    snd_soc_component_write(), snd_soc_component_update_bits() and
    snd_soc_component_update_bits_async(). They have the same signature as their
    regmap counter-part and will internally forward the call one-to-one to regmap.
    If the component it not using regmap it will fallback to using the custom IO
    callbacks. This is done to be able to support drivers that haven't been
    converted to regmap yet, but it is expected that this will eventually be removed
    in the future once all component drivers have been converted to regmap.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index dc0c09d2682a..ac64fd7252b2 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -19,24 +19,205 @@
 
 #include <trace/events/asoc.h>
 
-unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
+/**
+ * snd_soc_component_read() - Read register value
+ * @component: Component to read from
+ * @reg: Register to read
+ * @val: Pointer to where the read value is stored
+ *
+ * Return: 0 on success, a negative error code otherwise.
+ */
+int snd_soc_component_read(struct snd_soc_component *component,
+	unsigned int reg, unsigned int *val)
+{
+	int ret;
+
+	if (component->regmap)
+		ret = regmap_read(component->regmap, reg, val);
+	else if (component->read)
+		ret = component->read(component, reg, val);
+	else
+		ret = -EIO;
+
+	dev_dbg(component->dev, "read %x => %x\n", reg, *val);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_read);
+
+/**
+ * snd_soc_component_write() - Write register value
+ * @component: Component to write to
+ * @reg: Register to write
+ * @val: Value to write to the register
+ *
+ * Return: 0 on success, a negative error code otherwise.
+ */
+int snd_soc_component_write(struct snd_soc_component *component,
+	unsigned int reg, unsigned int val)
 {
-	unsigned int ret;
+	dev_dbg(component->dev, "write %x = %x\n", reg, val);
 
-	ret = codec->read(codec, reg);
-	dev_dbg(codec->dev, "read %x => %x\n", reg, ret);
-	trace_snd_soc_reg_read(codec, reg, ret);
+	if (component->regmap)
+		return regmap_write(component->regmap, reg, val);
+	else if (component->write)
+		return component->write(component, reg, val);
+	else
+		return -EIO;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_write);
+
+static int snd_soc_component_update_bits_legacy(
+	struct snd_soc_component *component, unsigned int reg,
+	unsigned int mask, unsigned int val, bool *change)
+{
+	unsigned int old, new;
+	int ret;
+
+	if (!component->read || !component->write)
+		return -EIO;
+
+	mutex_lock(&component->io_mutex);
+
+	ret = component->read(component, reg, &old);
+	if (ret < 0)
+		goto out_unlock;
+
+	new = (old & ~mask) | (val & mask);
+	*change = old != new;
+	if (*change)
+		ret = component->write(component, reg, new);
+out_unlock:
+	mutex_unlock(&component->io_mutex);
 
 	return ret;
 }
+
+/**
+ * snd_soc_component_update_bits() - Perform read/modify/write cycle
+ * @component: Component to update
+ * @reg: Register to update
+ * @mask: Mask that specifies which bits to update
+ * @val: New value for the bits specified by mask
+ *
+ * Return: 1 if the operation was successful and the value of the register
+ * changed, 0 if the operation was successful, but the value did not change.
+ * Returns a negative error code otherwise.
+ */
+int snd_soc_component_update_bits(struct snd_soc_component *component,
+	unsigned int reg, unsigned int mask, unsigned int val)
+{
+	bool change;
+	int ret;
+
+	if (component->regmap)
+		ret = regmap_update_bits_check(component->regmap, reg, mask,
+			val, &change);
+	else
+		ret = snd_soc_component_update_bits_legacy(component, reg,
+			mask, val, &change);
+
+	if (ret < 0)
+		return ret;
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_update_bits);
+
+/**
+ * snd_soc_component_update_bits_async() - Perform asynchronous
+ *  read/modify/write cycle
+ * @component: Component to update
+ * @reg: Register to update
+ * @mask: Mask that specifies which bits to update
+ * @val: New value for the bits specified by mask
+ *
+ * This function is similar to snd_soc_component_update_bits(), but the update
+ * operation is scheduled asynchronously. This means it may not be completed
+ * when the function returns. To make sure that all scheduled updates have been
+ * completed snd_soc_component_async_complete() must be called.
+ *
+ * Return: 1 if the operation was successful and the value of the register
+ * changed, 0 if the operation was successful, but the value did not change.
+ * Returns a negative error code otherwise.
+ */
+int snd_soc_component_update_bits_async(struct snd_soc_component *component,
+	unsigned int reg, unsigned int mask, unsigned int val)
+{
+	bool change;
+	int ret;
+
+	if (component->regmap)
+		ret = regmap_update_bits_check_async(component->regmap, reg,
+			mask, val, &change);
+	else
+		ret = snd_soc_component_update_bits_legacy(component, reg,
+			mask, val, &change);
+
+	if (ret < 0)
+		return ret;
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_update_bits_async);
+
+/**
+ * snd_soc_component_async_complete() - Ensure asynchronous I/O has completed
+ * @component: Component for which to wait
+ *
+ * This function blocks until all asynchronous I/O which has previously been
+ * scheduled using snd_soc_component_update_bits_async() has completed.
+ */
+void snd_soc_component_async_complete(struct snd_soc_component *component)
+{
+	if (component->regmap)
+		regmap_async_complete(component->regmap);
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_async_complete);
+
+/**
+ * snd_soc_component_test_bits - Test register for change
+ * @component: component
+ * @reg: Register to test
+ * @mask: Mask that specifies which bits to test
+ * @value: Value to test against
+ *
+ * Tests a register with a new value and checks if the new value is
+ * different from the old value.
+ *
+ * Return: 1 for change, otherwise 0.
+ */
+int snd_soc_component_test_bits(struct snd_soc_component *component,
+	unsigned int reg, unsigned int mask, unsigned int value)
+{
+	unsigned int old, new;
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &old);
+	if (ret < 0)
+		return ret;
+	new = (old & ~mask) | value;
+	return old != new;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_test_bits);
+
+unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	unsigned int val;
+	int ret;
+
+	ret = snd_soc_component_read(&codec->component, reg, &val);
+	if (ret < 0)
+		return -1;
+	trace_snd_soc_reg_read(codec, reg, val);
+
+	return val;
+}
 EXPORT_SYMBOL_GPL(snd_soc_read);
 
 int snd_soc_write(struct snd_soc_codec *codec, unsigned int reg,
 	unsigned int val)
 {
-	dev_dbg(codec->dev, "write %x = %x\n", reg, val);
 	trace_snd_soc_reg_write(codec, reg, val);
-	return codec->write(codec, reg, val);
+	return snd_soc_component_write(&codec->component, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_write);
 
@@ -54,29 +235,8 @@ EXPORT_SYMBOL_GPL(snd_soc_write);
 int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value)
 {
-	bool change;
-	unsigned int old, new;
-	int ret;
-
-	if (codec->using_regmap) {
-		ret = regmap_update_bits_check(codec->control_data, reg,
-					       mask, value, &change);
-	} else {
-		ret = snd_soc_read(codec, reg);
-		if (ret < 0)
-			return ret;
-
-		old = ret;
-		new = (old & ~mask) | (value & mask);
-		change = old != new;
-		if (change)
-			ret = snd_soc_write(codec, reg, new);
-	}
-
-	if (ret < 0)
-		return ret;
-
-	return change;
+	return snd_soc_component_update_bits(&codec->component, reg, mask,
+		value);
 }
 EXPORT_SYMBOL_GPL(snd_soc_update_bits);
 
@@ -95,13 +255,8 @@ int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
 			       unsigned int reg, unsigned int mask,
 			       unsigned int value)
 {
-	int change;
-
-	mutex_lock(&codec->mutex);
-	change = snd_soc_update_bits(codec, reg, mask, value);
-	mutex_unlock(&codec->mutex);
-
-	return change;
+	return snd_soc_component_update_bits(&codec->component, reg, mask,
+		value);
 }
 EXPORT_SYMBOL_GPL(snd_soc_update_bits_locked);
 
@@ -120,115 +275,58 @@ EXPORT_SYMBOL_GPL(snd_soc_update_bits_locked);
 int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value)
 {
-	int change;
-	unsigned int old, new;
-
-	old = snd_soc_read(codec, reg);
-	new = (old & ~mask) | value;
-	change = old != new;
-
-	return change;
+	return snd_soc_component_test_bits(&codec->component, reg, mask, value);
 }
 EXPORT_SYMBOL_GPL(snd_soc_test_bits);
 
 int snd_soc_platform_read(struct snd_soc_platform *platform,
 					unsigned int reg)
 {
-	unsigned int ret;
+	unsigned int val;
+	int ret;
 
-	if (!platform->driver->read) {
-		dev_err(platform->dev, "ASoC: platform has no read back\n");
+	ret = snd_soc_component_read(&platform->component, reg, &val);
+	if (ret < 0)
 		return -1;
-	}
 
-	ret = platform->driver->read(platform, reg);
-	dev_dbg(platform->dev, "read %x => %x\n", reg, ret);
-	trace_snd_soc_preg_read(platform, reg, ret);
+	trace_snd_soc_preg_read(platform, reg, val);
 
-	return ret;
+	return val;
 }
 EXPORT_SYMBOL_GPL(snd_soc_platform_read);
 
 int snd_soc_platform_write(struct snd_soc_platform *platform,
 					 unsigned int reg, unsigned int val)
 {
-	if (!platform->driver->write) {
-		dev_err(platform->dev, "ASoC: platform has no write back\n");
-		return -1;
-	}
-
-	dev_dbg(platform->dev, "write %x = %x\n", reg, val);
 	trace_snd_soc_preg_write(platform, reg, val);
-	return platform->driver->write(platform, reg, val);
+	return snd_soc_component_write(&platform->component, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_platform_write);
 
-#ifdef CONFIG_REGMAP
-static int hw_write(struct snd_soc_codec *codec, unsigned int reg,
-		    unsigned int value)
-{
-	return regmap_write(codec->control_data, reg, value);
-}
-
-static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
-{
-	int ret;
-	unsigned int val;
-
-	ret = regmap_read(codec->control_data, reg, &val);
-	if (ret == 0)
-		return val;
-	else
-		return -1;
-}
-
 /**
- * snd_soc_codec_set_cache_io: Set up standard I/O functions.
- *
- * @codec: CODEC to configure.
- * @map: Register map to write to
+ * snd_soc_component_init_io() - Initialize regmap IO
  *
- * Register formats are frequently shared between many I2C and SPI
- * devices.  In order to promote code reuse the ASoC core provides
- * some standard implementations of CODEC read and write operations
- * which can be set up using this function.
+ * @component: component to initialize
+ * @regmap: regmap instance to use for IO operations
  *
- * The caller is responsible for allocating and initialising the
- * actual cache.
- *
- * Note that at present this code cannot be used by CODECs with
- * volatile registers.
+ * Return: 0 on success, a negative error code otherwise
  */
-int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
-			       struct regmap *regmap)
+int snd_soc_component_init_io(struct snd_soc_component *component,
+	struct regmap *regmap)
 {
 	int ret;
 
 	if (!regmap)
 		return -EINVAL;
 
-	/* Device has made its own regmap arrangements */
-	codec->control_data = regmap;
-
-	codec->write = hw_write;
-	codec->read = hw_read;
-
-	ret = regmap_get_val_bytes(codec->control_data);
+	ret = regmap_get_val_bytes(regmap);
 	/* Errors are legitimate for non-integer byte
 	 * multiples */
 	if (ret > 0)
-		codec->val_bytes = ret;
+		component->val_bytes = ret;
 
-	codec->using_regmap = true;
+	component->regmap = regmap;
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_codec_set_cache_io);
-#else
-int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
-			       struct regmap *regmap)
-{
-	return -ENOTSUPP;
-}
-EXPORT_SYMBOL_GPL(snd_soc_codec_set_cache_io);
-#endif
+EXPORT_SYMBOL_GPL(snd_soc_component_init_io);

commit 2b17ef4071d37ef5e357a4ec75686315cfa9d3e6
Merge: 66097ca78899 8ab1a06497a1 ab2874a8faac 3477501274b7 7a34b1c1dff7
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Apr 22 13:22:52 2014 +0100

    Merge branches 'topic/sta350', 'topic/core', 'topic/dapm' and 'topic/cache' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-component

commit ab2874a8faac9db00eb03ec831b9a983627fb2d1
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Apr 19 10:43:57 2014 +0200

    ASoC: Change return type of snd_soc_write() to int
    
    The CODEC's write callback can return a negative error code, make sure to pass
    that on correctly.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 31ddd52c72fc..5fb85783b044 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -31,8 +31,8 @@ unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
 }
 EXPORT_SYMBOL_GPL(snd_soc_read);
 
-unsigned int snd_soc_write(struct snd_soc_codec *codec,
-			   unsigned int reg, unsigned int val)
+int snd_soc_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int val)
 {
 	dev_dbg(codec->dev, "write %x = %x\n", reg, val);
 	trace_snd_soc_reg_write(codec, reg, val);

commit aa0258adf6078a41a3db06f4e498253aff64d151
Merge: 1a39019e939f b37f1d123c69
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Apr 14 17:42:28 2014 +0100

    Merge branch 'topic/component' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-core
    
    Conflicts:
            sound/soc/soc-core.c

commit 96241c83293de346037b9a85e321f52ace210926
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Mar 18 09:02:07 2014 +0100

    ASoC: Move IO functions to soc-io.c
    
    soc-core.c is getting quite crowded. Move all IO related functions that are
    still in soc-core.c to soc-io.c
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 260efc8466fc..bfd7206c178f 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -19,6 +19,150 @@
 
 #include <trace/events/asoc.h>
 
+unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	unsigned int ret;
+
+	ret = codec->read(codec, reg);
+	dev_dbg(codec->dev, "read %x => %x\n", reg, ret);
+	trace_snd_soc_reg_read(codec, reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_read);
+
+unsigned int snd_soc_write(struct snd_soc_codec *codec,
+			   unsigned int reg, unsigned int val)
+{
+	dev_dbg(codec->dev, "write %x = %x\n", reg, val);
+	trace_snd_soc_reg_write(codec, reg, val);
+	return codec->write(codec, reg, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_write);
+
+/**
+ * snd_soc_update_bits - update codec register bits
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value.
+ *
+ * Returns 1 for change, 0 for no change, or negative error code.
+ */
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned int mask, unsigned int value)
+{
+	bool change;
+	unsigned int old, new;
+	int ret;
+
+	if (codec->using_regmap) {
+		ret = regmap_update_bits_check(codec->control_data, reg,
+					       mask, value, &change);
+	} else {
+		ret = snd_soc_read(codec, reg);
+		if (ret < 0)
+			return ret;
+
+		old = ret;
+		new = (old & ~mask) | (value & mask);
+		change = old != new;
+		if (change)
+			ret = snd_soc_write(codec, reg, new);
+	}
+
+	if (ret < 0)
+		return ret;
+
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_update_bits);
+
+/**
+ * snd_soc_update_bits_locked - update codec register bits
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value, and takes the codec mutex.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
+			       unsigned short reg, unsigned int mask,
+			       unsigned int value)
+{
+	int change;
+
+	mutex_lock(&codec->mutex);
+	change = snd_soc_update_bits(codec, reg, mask, value);
+	mutex_unlock(&codec->mutex);
+
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_update_bits_locked);
+
+/**
+ * snd_soc_test_bits - test register for change
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Tests a register with a new value and checks if the new value is
+ * different from the old value.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned int mask, unsigned int value)
+{
+	int change;
+	unsigned int old, new;
+
+	old = snd_soc_read(codec, reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_test_bits);
+
+int snd_soc_platform_read(struct snd_soc_platform *platform,
+					unsigned int reg)
+{
+	unsigned int ret;
+
+	if (!platform->driver->read) {
+		dev_err(platform->dev, "ASoC: platform has no read back\n");
+		return -1;
+	}
+
+	ret = platform->driver->read(platform, reg);
+	dev_dbg(platform->dev, "read %x => %x\n", reg, ret);
+	trace_snd_soc_preg_read(platform, reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_platform_read);
+
+int snd_soc_platform_write(struct snd_soc_platform *platform,
+					 unsigned int reg, unsigned int val)
+{
+	if (!platform->driver->write) {
+		dev_err(platform->dev, "ASoC: platform has no write back\n");
+		return -1;
+	}
+
+	dev_dbg(platform->dev, "write %x = %x\n", reg, val);
+	trace_snd_soc_preg_write(platform, reg, val);
+	return platform->driver->write(platform, reg, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_platform_write);
+
 #ifdef CONFIG_REGMAP
 static int hw_write(struct snd_soc_codec *codec, unsigned int reg,
 		    unsigned int value)

commit a39f75f7907fa3a708751dc283e3ab3e7da526b8
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Wed Mar 26 13:40:23 2014 +0800

    ASoC: core: Move the default regmap I/O setting to snd_soc_register_codec()
    
    Add the default regmap I/O setting to snd_soc_register_codec() while
    the CODEC is initialising, which will be called by CODEC driver device
    probe(), and then we can make XXX_set_cache_io() go away entirely from each
    CODEC ASoC probe.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 260efc8466fc..6480e8f29310 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -60,14 +60,11 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 {
 	int ret;
 
-	/* Device has made its own regmap arrangements */
 	if (!regmap)
-		codec->control_data = dev_get_regmap(codec->dev, NULL);
-	else
-		codec->control_data = regmap;
+		return -EINVAL;
 
-	if (IS_ERR(codec->control_data))
-		return PTR_ERR(codec->control_data);
+	/* Device has made its own regmap arrangements */
+	codec->control_data = regmap;
 
 	codec->write = hw_write;
 	codec->read = hw_read;

commit 657254714ad2ba69b73fcb02f0b1db378b1f220e
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Feb 20 09:08:43 2014 +0900

    ASoC: io: Remove support for ASoC cache in conjunction with regmap
    
    Since all regmap CODECs should be (and are) using the more advance regmap
    cache infrastructure remove the code which supports that and just proxy
    I/O straight through to regmap.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 8aa086996866..260efc8466fc 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -23,21 +23,6 @@
 static int hw_write(struct snd_soc_codec *codec, unsigned int reg,
 		    unsigned int value)
 {
-	int ret;
-
-	if (!snd_soc_codec_volatile_register(codec, reg) &&
-	    reg < codec->driver->reg_cache_size &&
-	    !codec->cache_bypass) {
-		ret = snd_soc_cache_write(codec, reg, value);
-		if (ret < 0)
-			return -1;
-	}
-
-	if (codec->cache_only) {
-		codec->cache_sync = 1;
-		return 0;
-	}
-
 	return regmap_write(codec->control_data, reg, value);
 }
 
@@ -46,23 +31,11 @@ static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
 	int ret;
 	unsigned int val;
 
-	if (reg >= codec->driver->reg_cache_size ||
-	    snd_soc_codec_volatile_register(codec, reg) ||
-	    codec->cache_bypass) {
-		if (codec->cache_only)
-			return -1;
-
-		ret = regmap_read(codec->control_data, reg, &val);
-		if (ret == 0)
-			return val;
-		else
-			return -1;
-	}
-
-	ret = snd_soc_cache_read(codec, reg, &val);
-	if (ret < 0)
+	ret = regmap_read(codec->control_data, reg, &val);
+	if (ret == 0)
+		return val;
+	else
 		return -1;
-	return val;
 }
 
 /**

commit 092eba937d948a76ff55825922eff4df010f6a17
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Tue Mar 11 12:43:21 2014 +0800

    ASoC: io: New signature for snd_soc_codec_set_cache_io()
    
    Now that all users have been converted to regmap and the config.reg_bits
    and config.val_bits can be setted by each user through regmap core API.
    So these two params are redundant here.
    
    Since the only control type that left is SND_SOC_REGMAP, so remove it. Drop
    the control params and add struct regmap *regmap to simplify the code.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 18353f111b6a..8aa086996866 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -69,9 +69,7 @@ static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
  * snd_soc_codec_set_cache_io: Set up standard I/O functions.
  *
  * @codec: CODEC to configure.
- * @addr_bits: Number of bits of register address data.
- * @data_bits: Number of bits of data per register.
- * @control: Control bus used.
+ * @map: Register map to write to
  *
  * Register formats are frequently shared between many I2C and SPI
  * devices.  In order to promote code reuse the ASoC core provides
@@ -85,41 +83,36 @@ static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
  * volatile registers.
  */
 int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
-			       int addr_bits, int data_bits,
-			       enum snd_soc_control_type control)
+			       struct regmap *regmap)
 {
 	int ret;
 
+	/* Device has made its own regmap arrangements */
+	if (!regmap)
+		codec->control_data = dev_get_regmap(codec->dev, NULL);
+	else
+		codec->control_data = regmap;
+
+	if (IS_ERR(codec->control_data))
+		return PTR_ERR(codec->control_data);
+
 	codec->write = hw_write;
 	codec->read = hw_read;
 
-	switch (control) {
-	case SND_SOC_REGMAP:
-		/* Device has made its own regmap arrangements */
-		codec->using_regmap = true;
-		if (!codec->control_data)
-			codec->control_data = dev_get_regmap(codec->dev, NULL);
-
-		if (codec->control_data) {
-			ret = regmap_get_val_bytes(codec->control_data);
-			/* Errors are legitimate for non-integer byte
-			 * multiples */
-			if (ret > 0)
-				codec->val_bytes = ret;
-		}
-		break;
-
-	default:
-		return -EINVAL;
-	}
+	ret = regmap_get_val_bytes(codec->control_data);
+	/* Errors are legitimate for non-integer byte
+	 * multiples */
+	if (ret > 0)
+		codec->val_bytes = ret;
+
+	codec->using_regmap = true;
 
-	return PTR_ERR_OR_ZERO(codec->control_data);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_cache_io);
 #else
 int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
-			       int addr_bits, int data_bits,
-			       enum snd_soc_control_type control)
+			       struct regmap *regmap)
 {
 	return -ENOTSUPP;
 }

commit 9aa8210d40c2140daf655c5299557bd68362399a
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Feb 27 17:49:51 2014 +0800

    ASoC: io: Clean up snd_soc_codec_set_cache_io()
    
    Now that all users have been converted to regmap and the config.reg_bits
    and config.val_bits can be setted by each user through regmap core API.
    So these two params are redundant here.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index add99e2f7996..18353f111b6a 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -88,16 +88,11 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 			       int addr_bits, int data_bits,
 			       enum snd_soc_control_type control)
 {
-	struct regmap_config config;
 	int ret;
 
-	memset(&config, 0, sizeof(config));
 	codec->write = hw_write;
 	codec->read = hw_read;
 
-	config.reg_bits = addr_bits;
-	config.val_bits = data_bits;
-
 	switch (control) {
 	case SND_SOC_REGMAP:
 		/* Device has made its own regmap arrangements */

commit 56b2f349137bfdd23e498f12a97fe3d6139c097b
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Feb 20 09:06:30 2014 +0900

    ASoC: io: Remove SND_SOC_I2C
    
    Now that all users have been converted to regmap we can eliminate the ASoC
    level wrapper for I2C I/O reducing the amount of duplicated functionality.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 3a0d99edf030..add99e2f7996 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -99,13 +99,6 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 	config.val_bits = data_bits;
 
 	switch (control) {
-#if IS_ENABLED(CONFIG_REGMAP_I2C)
-	case SND_SOC_I2C:
-		codec->control_data = regmap_init_i2c(to_i2c_client(codec->dev),
-						      &config);
-		break;
-#endif
-
 	case SND_SOC_REGMAP:
 		/* Device has made its own regmap arrangements */
 		codec->using_regmap = true;

commit 7b80300e749c2865fbfc23870d3b8f3186956fc0
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Feb 16 10:04:43 2014 +0800

    ASoC: io: Remove SPI support
    
    All ASoC CODEC drivers that use SPI have now been converted to use regmap
    so we can delete SND_SOC_SPI, preventing any new users being added.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index aa886cca3ecf..3a0d99edf030 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -106,13 +106,6 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 		break;
 #endif
 
-#if IS_ENABLED(CONFIG_REGMAP_SPI)
-	case SND_SOC_SPI:
-		codec->control_data = regmap_init_spi(to_spi_device(codec->dev),
-						      &config);
-		break;
-#endif
-
 	case SND_SOC_REGMAP:
 		/* Device has made its own regmap arrangements */
 		codec->using_regmap = true;

commit 4d9127faa864e7068d7e06527dfdf099ad06f64a
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Wed Nov 20 15:37:42 2013 -0200

    ASoC: soc-io: Use IS_ENABLED() macro
    
    Using the IS_ENABLED() macro can make the code shorter and simpler.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 4f11d23f2062..aa886cca3ecf 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -99,14 +99,14 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 	config.val_bits = data_bits;
 
 	switch (control) {
-#if defined(CONFIG_REGMAP_I2C) || defined(CONFIG_REGMAP_I2C_MODULE)
+#if IS_ENABLED(CONFIG_REGMAP_I2C)
 	case SND_SOC_I2C:
 		codec->control_data = regmap_init_i2c(to_i2c_client(codec->dev),
 						      &config);
 		break;
 #endif
 
-#if defined(CONFIG_REGMAP_SPI) || defined(CONFIG_REGMAP_SPI_MODULE)
+#if IS_ENABLED(CONFIG_REGMAP_SPI)
 	case SND_SOC_SPI:
 		codec->control_data = regmap_init_spi(to_spi_device(codec->dev),
 						      &config);

commit 2a1212a8342c469cee240cf69fe3001b898cda8e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 31 20:31:12 2013 +0200

    ASoC: Remove snd_soc_bulk_write_raw()
    
    No users of snd_soc_bulk_write_raw() are left and new drivers are going to use
    regmap directly for this, so the function can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 122c0c18b9dd..4f11d23f2062 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -65,31 +65,6 @@ static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
 	return val;
 }
 
-/* Primitive bulk write support for soc-cache.  The data pointed to by
- * `data' needs to already be in the form the hardware expects.  Any
- * data written through this function will not go through the cache as
- * it only handles writing to volatile or out of bounds registers.
- *
- * This is currently only supported for devices using the regmap API
- * wrappers.
- */
-static int snd_soc_hw_bulk_write_raw(struct snd_soc_codec *codec,
-				     unsigned int reg,
-				     const void *data, size_t len)
-{
-	/* To ensure that we don't get out of sync with the cache, check
-	 * whether the base register is volatile or if we've directly asked
-	 * to bypass the cache.  Out of bounds registers are considered
-	 * volatile.
-	 */
-	if (!codec->cache_bypass
-	    && !snd_soc_codec_volatile_register(codec, reg)
-	    && reg < codec->driver->reg_cache_size)
-		return -EINVAL;
-
-	return regmap_raw_write(codec->control_data, reg, data, len);
-}
-
 /**
  * snd_soc_codec_set_cache_io: Set up standard I/O functions.
  *
@@ -119,7 +94,6 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 	memset(&config, 0, sizeof(config));
 	codec->write = hw_write;
 	codec->read = hw_read;
-	codec->bulk_write_raw = snd_soc_hw_bulk_write_raw;
 
 	config.reg_bits = addr_bits;
 	config.val_bits = data_bits;

commit 8c6ffba0eddc8c110dbf444f51354ce42069abfc
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Jul 15 11:20:32 2013 +0930

    PTR_RET is now PTR_ERR_OR_ZERO(): Replace most.
    
    Sweep of the simple cases.
    
    Cc: netdev@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 8ca9ecc5ac57..122c0c18b9dd 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -158,7 +158,7 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 		return -EINVAL;
 	}
 
-	return PTR_RET(codec->control_data);
+	return PTR_ERR_OR_ZERO(codec->control_data);
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_cache_io);
 #else

commit 36300fd09823be8f7d6feaaa79ddbf54cf205378
Author: Alexandru Gheorghiu <gheorghiuandru@gmail.com>
Date:   Mon Mar 25 16:33:59 2013 +0200

    ASoC: core: Use PTR_RET function
    
    Used PTR_RET function instead of IS_ERR and PTR_ERR.
    Patch found using coccinelle.
    
    Signed-off-by: Alexandru Gheorghiu <gheorghiuandru@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 29183ef2b93d..8ca9ecc5ac57 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -158,10 +158,7 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 		return -EINVAL;
 	}
 
-	if (IS_ERR(codec->control_data))
-		return PTR_ERR(codec->control_data);
-
-	return 0;
+	return PTR_RET(codec->control_data);
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_cache_io);
 #else

commit 9dfdd5abcf2b350d4fdb207c0dff3194e2fd73db
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jun 22 12:40:52 2012 +0100

    ASoC: io: Don't dereference regmap if we failed to get one
    
    Avoids a crash in invalid configurations.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 44d0174b4d97..29183ef2b93d 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -145,10 +145,13 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 		if (!codec->control_data)
 			codec->control_data = dev_get_regmap(codec->dev, NULL);
 
-		ret = regmap_get_val_bytes(codec->control_data);
-		/* Errors are legitimate for non-integer byte multiples */
-		if (ret > 0)
-			codec->val_bytes = ret;
+		if (codec->control_data) {
+			ret = regmap_get_val_bytes(codec->control_data);
+			/* Errors are legitimate for non-integer byte
+			 * multiples */
+			if (ret > 0)
+				codec->val_bytes = ret;
+		}
 		break;
 
 	default:

commit 210cb67cb5b9f9a23b7ce91de50bab357440ba9d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue May 8 17:46:36 2012 +0100

    ASoC: io: Use dev_get_regmap() if driver doesn't provide a regmap
    
    Less error prone and one less line of code in drivers.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 4d8dc6a27d4d..44d0174b4d97 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -142,6 +142,8 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 	case SND_SOC_REGMAP:
 		/* Device has made its own regmap arrangements */
 		codec->using_regmap = true;
+		if (!codec->control_data)
+			codec->control_data = dev_get_regmap(codec->dev, NULL);
 
 		ret = regmap_get_val_bytes(codec->control_data);
 		/* Errors are legitimate for non-integer byte multiples */

commit 2b4bdee2920fb3894f9116f76343f8b31f9e4da8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Feb 17 14:33:29 2012 -0800

    ASoC: io: Retrieve val_bytes from the regmap API
    
    Allow us to build infrastructure which needs to know the size of a value
    without requiring regmap based drivers to supply this information to both
    ASoC and regmap by asking regmap for the value.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 39ba5070ff92..4d8dc6a27d4d 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -114,6 +114,7 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 			       enum snd_soc_control_type control)
 {
 	struct regmap_config config;
+	int ret;
 
 	memset(&config, 0, sizeof(config));
 	codec->write = hw_write;
@@ -141,6 +142,11 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 	case SND_SOC_REGMAP:
 		/* Device has made its own regmap arrangements */
 		codec->using_regmap = true;
+
+		ret = regmap_get_val_bytes(codec->control_data);
+		/* Errors are legitimate for non-integer byte multiples */
+		if (ret > 0)
+			codec->val_bytes = ret;
 		break;
 
 	default:

commit 8a713da8d1ce9ceaf738b32e2b24f22d4432f886
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Dec 3 12:33:55 2011 +0000

    ASoC: Use regmap update bits operation for drivers using regmap
    
    If a driver is using regmap directly ensure that we're coherent with
    non-ASoC register updates by using the regmap API directly to do our
    read/modify/write cycles. This will bypass the ASoC cache but drivers
    using regmap directly should not be using the ASoC cache.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index c8610cbf34a5..39ba5070ff92 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -140,6 +140,7 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 
 	case SND_SOC_REGMAP:
 		/* Device has made its own regmap arrangements */
+		codec->using_regmap = true;
 		break;
 
 	default:

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index dd89933e2c72..c8610cbf34a5 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -14,6 +14,7 @@
 #include <linux/i2c.h>
 #include <linux/spi/spi.h>
 #include <linux/regmap.h>
+#include <linux/export.h>
 #include <sound/soc.h>
 
 #include <trace/events/asoc.h>

commit 3ebb5c9b1056b7eaae3e5dd11b97e2830797e51c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Oct 9 14:06:13 2011 +0100

    ASoC: Squash error codes from regmap down to -1 on read
    
    The ASoC code always uses -1 as the error code due to reporting errors in
    band with the value. Ensure we don't confuse anything by making sure we
    don't pass actual error codes back into the rest of the code on read.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 66fcccd79efe..dd89933e2c72 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -55,7 +55,7 @@ static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
 		if (ret == 0)
 			return val;
 		else
-			return ret;
+			return -1;
 	}
 
 	ret = snd_soc_cache_read(codec, reg, &val);

commit 4835ff9aca639107ca0233c10aa854d460c8797d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Aug 13 11:50:48 2011 +0900

    ASoC: Support !CONFIG_REGMAP builds
    
    Since we changed regmap to be selected and register per bus rather than
    via the core only we can't rely on it being enabled by the ASoC core.
    Support compiling it out.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reported-by: Axel Lin <axel.lin@gmail.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 22b64317182b..66fcccd79efe 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -18,6 +18,7 @@
 
 #include <trace/events/asoc.h>
 
+#ifdef CONFIG_REGMAP
 static int hw_write(struct snd_soc_codec *codec, unsigned int reg,
 		    unsigned int value)
 {
@@ -150,4 +151,12 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_cache_io);
-
+#else
+int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
+			       int addr_bits, int data_bits,
+			       enum snd_soc_control_type control)
+{
+	return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(snd_soc_codec_set_cache_io);
+#endif

commit 81bca7624db4720db686fa38435c39ea95b7be8f
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Aug 11 11:59:11 2011 -0600

    ASoC: soc-io: Fix CONFIG_REGMAP_I2C/SPI guards to support regmap modules
    
    When CONFIG_REGMAP_I2C/SPI are m, CONFIG_REGMAP_I2C_MODULE is set in the
    pre-processor instead of CONFIG_REGMAP_I2C. This removes SND_SOC_I2C as a
    valid option for snd_soc_codec_set_cache_io()'s control parameter, and
    causes any ASoC regmap-using codec built as a module to fail to initialize.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index be5aac3d7a1b..22b64317182b 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -122,14 +122,14 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 	config.val_bits = data_bits;
 
 	switch (control) {
-#ifdef CONFIG_REGMAP_I2C
+#if defined(CONFIG_REGMAP_I2C) || defined(CONFIG_REGMAP_I2C_MODULE)
 	case SND_SOC_I2C:
 		codec->control_data = regmap_init_i2c(to_i2c_client(codec->dev),
 						      &config);
 		break;
 #endif
 
-#ifdef CONFIG_REGMAP_SPI
+#if defined(CONFIG_REGMAP_SPI) || defined(CONFIG_REGMAP_SPI_MODULE)
 	case SND_SOC_SPI:
 		codec->control_data = regmap_init_spi(to_spi_device(codec->dev),
 						      &config);

commit f024d9a0854cb3f2d09603d1ed3a52f04778330d
Author: Axel Lin <axel.lin@gmail.com>
Date:   Wed Aug 10 16:24:12 2011 +0800

    ASoC: soc-io: Add CONFIG_REGMAP_I2C/CONFIG_REGMAP_SPI guards for regmap_init_i2c/regmap_init_spi
    
    In the case of "make da8xx_omapl_defconfig;make", the SPI support is disabled.
    Thus calling regmap_init_spi in soc-io.c has below build error.
    
    ERROR: "regmap_init_spi" [sound/soc/snd-soc-core.ko] undefined!
    make[1]: *** [__modpost] Error 1
    make: *** [modules] Error 2
    
    This patch fixes the build error by adding CONFIG_REGMAP_I2C/CONFIG_REGMAP_SPI
    guards for regmap_init_i2c/regmap_init_spi.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index e471ed667fe9..be5aac3d7a1b 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -122,15 +122,19 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 	config.val_bits = data_bits;
 
 	switch (control) {
+#ifdef CONFIG_REGMAP_I2C
 	case SND_SOC_I2C:
 		codec->control_data = regmap_init_i2c(to_i2c_client(codec->dev),
 						      &config);
 		break;
+#endif
 
+#ifdef CONFIG_REGMAP_SPI
 	case SND_SOC_SPI:
 		codec->control_data = regmap_init_spi(to_spi_device(codec->dev),
 						      &config);
 		break;
+#endif
 
 	case SND_SOC_REGMAP:
 		/* Device has made its own regmap arrangements */

commit 0671da189c1d75eec5f6aba786d57d25209dd2bc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jul 24 12:23:37 2011 +0100

    ASoC: Add regmap as a control type
    
    Allow drivers to set up their own regmap API structures. This is mainly
    useful with MFDs where the core driver will have set up regmap at the
    minute, though it may make sense to push the existing regmap setup out
    of the core into the drivers.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index b56e1c4bb9e6..e471ed667fe9 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -132,6 +132,10 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 						      &config);
 		break;
 
+	case SND_SOC_REGMAP:
+		/* Device has made its own regmap arrangements */
+		break;
+
 	default:
 		return -EINVAL;
 	}

commit be3ea3b9e8df64acb3606055c01291f0b58876a6
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jun 13 19:35:29 2011 +0100

    ASoC: Use new register map API for ASoC generic physical I/O
    
    Remove all the ASoC specific physical I/O code and replace it with calls
    into the regmap API. The bulk write code can only be used safely if all
    regmap calls are locked with the CODEC lock, we need to add bulk support
    to the regmap API or replace the code with an open coded loop (though
    currently it has no users...).
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index cca490c80589..b56e1c4bb9e6 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -13,26 +13,13 @@
 
 #include <linux/i2c.h>
 #include <linux/spi/spi.h>
+#include <linux/regmap.h>
 #include <sound/soc.h>
 
 #include <trace/events/asoc.h>
 
-#ifdef CONFIG_SPI_MASTER
-static int do_spi_write(void *control, const char *data, int len)
-{
-	struct spi_device *spi = control;
-	int ret;
-
-	ret = spi_write(spi, data, len);
-	if (ret < 0)
-		return ret;
-
-	return len;
-}
-#endif
-
-static int do_hw_write(struct snd_soc_codec *codec, unsigned int reg,
-		       unsigned int value, const void *data, int len)
+static int hw_write(struct snd_soc_codec *codec, unsigned int reg,
+		    unsigned int value)
 {
 	int ret;
 
@@ -49,13 +36,7 @@ static int do_hw_write(struct snd_soc_codec *codec, unsigned int reg,
 		return 0;
 	}
 
-	ret = codec->hw_write(codec->control_data, data, len);
-	if (ret == len)
-		return 0;
-	if (ret < 0)
-		return ret;
-	else
-		return -EIO;
+	return regmap_write(codec->control_data, reg, value);
 }
 
 static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
@@ -69,8 +50,11 @@ static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
 		if (codec->cache_only)
 			return -1;
 
-		BUG_ON(!codec->hw_read);
-		return codec->hw_read(codec, reg);
+		ret = regmap_read(codec->control_data, reg, &val);
+		if (ret == 0)
+			return val;
+		else
+			return ret;
 	}
 
 	ret = snd_soc_cache_read(codec, reg, &val);
@@ -79,183 +63,18 @@ static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
 	return val;
 }
 
-static int snd_soc_4_12_write(struct snd_soc_codec *codec, unsigned int reg,
-			      unsigned int value)
-{
-	u16 data;
-
-	data = cpu_to_be16((reg << 12) | (value & 0xffffff));
-
-	return do_hw_write(codec, reg, value, &data, 2);
-}
-
-static int snd_soc_7_9_write(struct snd_soc_codec *codec, unsigned int reg,
-			     unsigned int value)
-{
-	u16 data;
-
-	data = cpu_to_be16((reg << 9) | (value & 0x1ff));
-
-	return do_hw_write(codec, reg, value, &data, 2);
-}
-
-static int snd_soc_8_8_write(struct snd_soc_codec *codec, unsigned int reg,
-			     unsigned int value)
-{
-	u8 data[2];
-
-	reg &= 0xff;
-	data[0] = reg;
-	data[1] = value & 0xff;
-
-	return do_hw_write(codec, reg, value, data, 2);
-}
-
-static int snd_soc_8_16_write(struct snd_soc_codec *codec, unsigned int reg,
-			      unsigned int value)
-{
-	u8 data[3];
-	u16 val = cpu_to_be16(value);
-
-	data[0] = reg;
-	memcpy(&data[1], &val, sizeof(val));
-
-	return do_hw_write(codec, reg, value, data, 3);
-}
-
-#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
-static unsigned int do_i2c_read(struct snd_soc_codec *codec,
-				void *reg, int reglen,
-				void *data, int datalen)
-{
-	struct i2c_msg xfer[2];
-	int ret;
-	struct i2c_client *client = codec->control_data;
-
-	/* Write register */
-	xfer[0].addr = client->addr;
-	xfer[0].flags = 0;
-	xfer[0].len = reglen;
-	xfer[0].buf = reg;
-
-	/* Read data */
-	xfer[1].addr = client->addr;
-	xfer[1].flags = I2C_M_RD;
-	xfer[1].len = datalen;
-	xfer[1].buf = data;
-
-	ret = i2c_transfer(client->adapter, xfer, 2);
-	if (ret == 2)
-		return 0;
-	else if (ret < 0)
-		return ret;
-	else
-		return -EIO;
-}
-#endif
-
-#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
-static unsigned int snd_soc_8_8_read_i2c(struct snd_soc_codec *codec,
-					 unsigned int r)
-{
-	u8 reg = r;
-	u8 data;
-	int ret;
-
-	ret = do_i2c_read(codec, &reg, 1, &data, 1);
-	if (ret < 0)
-		return 0;
-	return data;
-}
-#else
-#define snd_soc_8_8_read_i2c NULL
-#endif
-
-#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
-static unsigned int snd_soc_8_16_read_i2c(struct snd_soc_codec *codec,
-					  unsigned int r)
-{
-	u8 reg = r;
-	u16 data;
-	int ret;
-
-	ret = do_i2c_read(codec, &reg, 1, &data, 2);
-	if (ret < 0)
-		return 0;
-	return (data >> 8) | ((data & 0xff) << 8);
-}
-#else
-#define snd_soc_8_16_read_i2c NULL
-#endif
-
-#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
-static unsigned int snd_soc_16_8_read_i2c(struct snd_soc_codec *codec,
-					  unsigned int r)
-{
-	u16 reg = r;
-	u8 data;
-	int ret;
-
-	ret = do_i2c_read(codec, &reg, 2, &data, 1);
-	if (ret < 0)
-		return 0;
-	return data;
-}
-#else
-#define snd_soc_16_8_read_i2c NULL
-#endif
-
-static int snd_soc_16_8_write(struct snd_soc_codec *codec, unsigned int reg,
-			      unsigned int value)
-{
-	u8 data[3];
-	u16 rval = cpu_to_be16(reg);
-
-	memcpy(data, &rval, sizeof(rval));
-	data[2] = value;
-
-	return do_hw_write(codec, reg, value, data, 3);
-}
-
-#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
-static unsigned int snd_soc_16_16_read_i2c(struct snd_soc_codec *codec,
-					   unsigned int r)
-{
-	u16 reg = cpu_to_be16(r);
-	u16 data;
-	int ret;
-
-	ret = do_i2c_read(codec, &reg, 2, &data, 2);
-	if (ret < 0)
-		return 0;
-	return be16_to_cpu(data);
-}
-#else
-#define snd_soc_16_16_read_i2c NULL
-#endif
-
-static int snd_soc_16_16_write(struct snd_soc_codec *codec, unsigned int reg,
-			       unsigned int value)
-{
-	u16 data[2];
-
-	data[0] = cpu_to_be16(reg);
-	data[1] = cpu_to_be16(value);
-
-	return do_hw_write(codec, reg, value, data, sizeof(data));
-}
-
 /* Primitive bulk write support for soc-cache.  The data pointed to by
- * `data' needs to already be in the form the hardware expects
- * including any leading register specific data.  Any data written
- * through this function will not go through the cache as it only
- * handles writing to volatile or out of bounds registers.
+ * `data' needs to already be in the form the hardware expects.  Any
+ * data written through this function will not go through the cache as
+ * it only handles writing to volatile or out of bounds registers.
+ *
+ * This is currently only supported for devices using the regmap API
+ * wrappers.
  */
-static int snd_soc_hw_bulk_write_raw(struct snd_soc_codec *codec, unsigned int reg,
+static int snd_soc_hw_bulk_write_raw(struct snd_soc_codec *codec,
+				     unsigned int reg,
 				     const void *data, size_t len)
 {
-	int ret;
-
 	/* To ensure that we don't get out of sync with the cache, check
 	 * whether the base register is volatile or if we've directly asked
 	 * to bypass the cache.  Out of bounds registers are considered
@@ -266,66 +85,9 @@ static int snd_soc_hw_bulk_write_raw(struct snd_soc_codec *codec, unsigned int r
 	    && reg < codec->driver->reg_cache_size)
 		return -EINVAL;
 
-	switch (codec->control_type) {
-#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
-	case SND_SOC_I2C:
-		ret = i2c_master_send(to_i2c_client(codec->dev), data, len);
-		break;
-#endif
-#if defined(CONFIG_SPI_MASTER)
-	case SND_SOC_SPI:
-		ret = spi_write(to_spi_device(codec->dev), data, len);
-		break;
-#endif
-	default:
-		BUG();
-	}
-
-	if (ret == len)
-		return 0;
-	if (ret < 0)
-		return ret;
-	else
-		return -EIO;
+	return regmap_raw_write(codec->control_data, reg, data, len);
 }
 
-static struct {
-	int addr_bits;
-	int data_bits;
-	int (*write)(struct snd_soc_codec *codec, unsigned int, unsigned int);
-	unsigned int (*read)(struct snd_soc_codec *, unsigned int);
-	unsigned int (*i2c_read)(struct snd_soc_codec *, unsigned int);
-} io_types[] = {
-	{
-		.addr_bits = 4, .data_bits = 12,
-		.write = snd_soc_4_12_write,
-	},
-	{
-		.addr_bits = 7, .data_bits = 9,
-		.write = snd_soc_7_9_write,
-	},
-	{
-		.addr_bits = 8, .data_bits = 8,
-		.write = snd_soc_8_8_write,
-		.i2c_read = snd_soc_8_8_read_i2c,
-	},
-	{
-		.addr_bits = 8, .data_bits = 16,
-		.write = snd_soc_8_16_write,
-		.i2c_read = snd_soc_8_16_read_i2c,
-	},
-	{
-		.addr_bits = 16, .data_bits = 8,
-		.write = snd_soc_16_8_write,
-		.i2c_read = snd_soc_16_8_read_i2c,
-	},
-	{
-		.addr_bits = 16, .data_bits = 16,
-		.write = snd_soc_16_16_write,
-		.i2c_read = snd_soc_16_16_read_i2c,
-	},
-};
-
 /**
  * snd_soc_codec_set_cache_io: Set up standard I/O functions.
  *
@@ -349,47 +111,34 @@ int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
 			       int addr_bits, int data_bits,
 			       enum snd_soc_control_type control)
 {
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(io_types); i++)
-		if (io_types[i].addr_bits == addr_bits &&
-		    io_types[i].data_bits == data_bits)
-			break;
-	if (i == ARRAY_SIZE(io_types)) {
-		printk(KERN_ERR
-		       "No I/O functions for %d bit address %d bit data\n",
-		       addr_bits, data_bits);
-		return -EINVAL;
-	}
+	struct regmap_config config;
 
-	codec->write = io_types[i].write;
+	memset(&config, 0, sizeof(config));
+	codec->write = hw_write;
 	codec->read = hw_read;
 	codec->bulk_write_raw = snd_soc_hw_bulk_write_raw;
 
+	config.reg_bits = addr_bits;
+	config.val_bits = data_bits;
+
 	switch (control) {
 	case SND_SOC_I2C:
-#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
-		codec->hw_write = (hw_write_t)i2c_master_send;
-#endif
-		if (io_types[i].i2c_read)
-			codec->hw_read = io_types[i].i2c_read;
-
-		codec->control_data = container_of(codec->dev,
-						   struct i2c_client,
-						   dev);
+		codec->control_data = regmap_init_i2c(to_i2c_client(codec->dev),
+						      &config);
 		break;
 
 	case SND_SOC_SPI:
-#ifdef CONFIG_SPI_MASTER
-		codec->hw_write = do_spi_write;
-#endif
-
-		codec->control_data = container_of(codec->dev,
-						   struct spi_device,
-						   dev);
+		codec->control_data = regmap_init_spi(to_spi_device(codec->dev),
+						      &config);
 		break;
+
+	default:
+		return -EINVAL;
 	}
 
+	if (IS_ERR(codec->control_data))
+		return PTR_ERR(codec->control_data);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_cache_io);

commit 65fdd5c05a02b15bbfa5b0f4f050fdb25b9227f1
Merge: 223157121404 e9c039052be5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jun 13 19:21:09 2011 +0100

    Merge branch 'for-3.0' into for-3.1
    
    Trival fixup for move of I/O code into separate file.
    
    Conflicts:
            sound/soc/soc-cache.c

commit 223157121404a7ca4deaf2aa31a57cad8d133d07
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jun 13 18:44:52 2011 +0100

    ASoC: Don't use codec->control_data in bulk write
    
    In order to facilitate merging with the register map I/O replace the use
    of control_data for the bulk writes with direct lookup of the client data
    from the device.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
index 855e5cde2793..df9338aa1a52 100644
--- a/sound/soc/soc-io.c
+++ b/sound/soc/soc-io.c
@@ -269,12 +269,12 @@ static int snd_soc_hw_bulk_write_raw(struct snd_soc_codec *codec, unsigned int r
 	switch (codec->control_type) {
 #if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
 	case SND_SOC_I2C:
-		ret = i2c_master_send(codec->control_data, data, len);
+		ret = i2c_master_send(to_i2c_client(codec->dev), data, len);
 		break;
 #endif
 #if defined(CONFIG_SPI_MASTER)
 	case SND_SOC_SPI:
-		ret = spi_write(codec->control_data, data, len);
+		ret = spi_write(to_spi_device(codec->dev), data, len);
 		break;
 #endif
 	default:

commit 5bef44f9b4849d1c3af4ed2ea93061ff56e68cd7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jun 13 17:49:55 2011 +0100

    ASoC: Move register I/O code into a separate file
    
    For clarity and to help ongoing refactoring in this area create a new file
    to contain the physical I/O functions, separating them out from the cache
    operations.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-io.c b/sound/soc/soc-io.c
new file mode 100644
index 000000000000..855e5cde2793
--- /dev/null
+++ b/sound/soc/soc-io.c
@@ -0,0 +1,399 @@
+/*
+ * soc-io.c  --  ASoC register I/O helpers
+ *
+ * Copyright 2009-2011 Wolfson Microelectronics PLC.
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <sound/soc.h>
+
+#include <trace/events/asoc.h>
+
+#ifdef CONFIG_SPI_MASTER
+static int do_spi_write(void *control, const char *data, int len)
+{
+	struct spi_device *spi = control;
+	int ret;
+
+	ret = spi_write(spi, data, len);
+	if (ret < 0)
+		return ret;
+
+	return len;
+}
+#endif
+
+static int do_hw_write(struct snd_soc_codec *codec, unsigned int reg,
+		       unsigned int value, const void *data, int len)
+{
+	int ret;
+
+	if (!snd_soc_codec_volatile_register(codec, reg) &&
+	    reg < codec->driver->reg_cache_size &&
+	    !codec->cache_bypass) {
+		ret = snd_soc_cache_write(codec, reg, value);
+		if (ret < 0)
+			return -1;
+	}
+
+	if (codec->cache_only) {
+		codec->cache_sync = 1;
+		return 0;
+	}
+
+	ret = codec->hw_write(codec->control_data, data, len);
+	if (ret == len)
+		return 0;
+	if (ret < 0)
+		return ret;
+	else
+		return -EIO;
+}
+
+static unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	int ret;
+	unsigned int val;
+
+	if (reg >= codec->driver->reg_cache_size ||
+	    snd_soc_codec_volatile_register(codec, reg) ||
+	    codec->cache_bypass) {
+		if (codec->cache_only)
+			return -1;
+
+		BUG_ON(!codec->hw_read);
+		return codec->hw_read(codec, reg);
+	}
+
+	ret = snd_soc_cache_read(codec, reg, &val);
+	if (ret < 0)
+		return -1;
+	return val;
+}
+
+static int snd_soc_4_12_write(struct snd_soc_codec *codec, unsigned int reg,
+			      unsigned int value)
+{
+	u16 data;
+
+	data = cpu_to_be16((reg << 12) | (value & 0xffffff));
+
+	return do_hw_write(codec, reg, value, &data, 2);
+}
+
+static int snd_soc_7_9_write(struct snd_soc_codec *codec, unsigned int reg,
+			     unsigned int value)
+{
+	u16 data;
+
+	data = cpu_to_be16((reg << 9) | (value & 0x1ff));
+
+	return do_hw_write(codec, reg, value, &data, 2);
+}
+
+static int snd_soc_8_8_write(struct snd_soc_codec *codec, unsigned int reg,
+			     unsigned int value)
+{
+	u8 data[2];
+
+	reg &= 0xff;
+	data[0] = reg;
+	data[1] = value & 0xff;
+
+	return do_hw_write(codec, reg, value, data, 2);
+}
+
+static int snd_soc_8_16_write(struct snd_soc_codec *codec, unsigned int reg,
+			      unsigned int value)
+{
+	u8 data[3];
+	u16 val = cpu_to_be16(value);
+
+	data[0] = reg;
+	memcpy(&data[1], &val, sizeof(val));
+
+	return do_hw_write(codec, reg, value, data, 3);
+}
+
+#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
+static unsigned int do_i2c_read(struct snd_soc_codec *codec,
+				void *reg, int reglen,
+				void *data, int datalen)
+{
+	struct i2c_msg xfer[2];
+	int ret;
+	struct i2c_client *client = codec->control_data;
+
+	/* Write register */
+	xfer[0].addr = client->addr;
+	xfer[0].flags = 0;
+	xfer[0].len = reglen;
+	xfer[0].buf = reg;
+
+	/* Read data */
+	xfer[1].addr = client->addr;
+	xfer[1].flags = I2C_M_RD;
+	xfer[1].len = datalen;
+	xfer[1].buf = data;
+
+	ret = i2c_transfer(client->adapter, xfer, 2);
+	if (ret == 2)
+		return 0;
+	else if (ret < 0)
+		return ret;
+	else
+		return -EIO;
+}
+#endif
+
+#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
+static unsigned int snd_soc_8_8_read_i2c(struct snd_soc_codec *codec,
+					 unsigned int r)
+{
+	u8 reg = r;
+	u8 data;
+	int ret;
+
+	ret = do_i2c_read(codec, &reg, 1, &data, 1);
+	if (ret < 0)
+		return 0;
+	return data;
+}
+#else
+#define snd_soc_8_8_read_i2c NULL
+#endif
+
+#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
+static unsigned int snd_soc_8_16_read_i2c(struct snd_soc_codec *codec,
+					  unsigned int r)
+{
+	u8 reg = r;
+	u16 data;
+	int ret;
+
+	ret = do_i2c_read(codec, &reg, 1, &data, 2);
+	if (ret < 0)
+		return 0;
+	return (data >> 8) | ((data & 0xff) << 8);
+}
+#else
+#define snd_soc_8_16_read_i2c NULL
+#endif
+
+#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
+static unsigned int snd_soc_16_8_read_i2c(struct snd_soc_codec *codec,
+					  unsigned int r)
+{
+	u16 reg = r;
+	u8 data;
+	int ret;
+
+	ret = do_i2c_read(codec, &reg, 2, &data, 1);
+	if (ret < 0)
+		return 0;
+	return data;
+}
+#else
+#define snd_soc_16_8_read_i2c NULL
+#endif
+
+static int snd_soc_16_8_write(struct snd_soc_codec *codec, unsigned int reg,
+			      unsigned int value)
+{
+	u8 data[3];
+	u16 rval = cpu_to_be16(reg);
+
+	memcpy(data, &rval, sizeof(rval));
+	data[2] = value;
+
+	return do_hw_write(codec, reg, value, data, 3);
+}
+
+#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
+static unsigned int snd_soc_16_16_read_i2c(struct snd_soc_codec *codec,
+					   unsigned int r)
+{
+	u16 reg = cpu_to_be16(r);
+	u16 data;
+	int ret;
+
+	ret = do_i2c_read(codec, &reg, 2, &data, 2);
+	if (ret < 0)
+		return 0;
+	return be16_to_cpu(data);
+}
+#else
+#define snd_soc_16_16_read_i2c NULL
+#endif
+
+static int snd_soc_16_16_write(struct snd_soc_codec *codec, unsigned int reg,
+			       unsigned int value)
+{
+	u16 data[2];
+
+	data[0] = cpu_to_be16(reg);
+	data[1] = cpu_to_be16(value);
+
+	return do_hw_write(codec, reg, value, data, sizeof(data));
+}
+
+/* Primitive bulk write support for soc-cache.  The data pointed to by
+ * `data' needs to already be in the form the hardware expects
+ * including any leading register specific data.  Any data written
+ * through this function will not go through the cache as it only
+ * handles writing to volatile or out of bounds registers.
+ */
+static int snd_soc_hw_bulk_write_raw(struct snd_soc_codec *codec, unsigned int reg,
+				     const void *data, size_t len)
+{
+	int ret;
+
+	/* To ensure that we don't get out of sync with the cache, check
+	 * whether the base register is volatile or if we've directly asked
+	 * to bypass the cache.  Out of bounds registers are considered
+	 * volatile.
+	 */
+	if (!codec->cache_bypass
+	    && !snd_soc_codec_volatile_register(codec, reg)
+	    && reg < codec->driver->reg_cache_size)
+		return -EINVAL;
+
+	switch (codec->control_type) {
+#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
+	case SND_SOC_I2C:
+		ret = i2c_master_send(codec->control_data, data, len);
+		break;
+#endif
+#if defined(CONFIG_SPI_MASTER)
+	case SND_SOC_SPI:
+		ret = spi_write(codec->control_data, data, len);
+		break;
+#endif
+	default:
+		BUG();
+	}
+
+	if (ret == len)
+		return 0;
+	if (ret < 0)
+		return ret;
+	else
+		return -EIO;
+}
+
+static struct {
+	int addr_bits;
+	int data_bits;
+	int (*write)(struct snd_soc_codec *codec, unsigned int, unsigned int);
+	unsigned int (*read)(struct snd_soc_codec *, unsigned int);
+	unsigned int (*i2c_read)(struct snd_soc_codec *, unsigned int);
+} io_types[] = {
+	{
+		.addr_bits = 4, .data_bits = 12,
+		.write = snd_soc_4_12_write,
+	},
+	{
+		.addr_bits = 7, .data_bits = 9,
+		.write = snd_soc_7_9_write,
+	},
+	{
+		.addr_bits = 8, .data_bits = 8,
+		.write = snd_soc_8_8_write,
+		.i2c_read = snd_soc_8_8_read_i2c,
+	},
+	{
+		.addr_bits = 8, .data_bits = 16,
+		.write = snd_soc_8_16_write,
+		.i2c_read = snd_soc_8_16_read_i2c,
+	},
+	{
+		.addr_bits = 16, .data_bits = 8,
+		.write = snd_soc_16_8_write,
+		.i2c_read = snd_soc_16_8_read_i2c,
+	},
+	{
+		.addr_bits = 16, .data_bits = 16,
+		.write = snd_soc_16_16_write,
+		.i2c_read = snd_soc_16_16_read_i2c,
+	},
+};
+
+/**
+ * snd_soc_codec_set_cache_io: Set up standard I/O functions.
+ *
+ * @codec: CODEC to configure.
+ * @addr_bits: Number of bits of register address data.
+ * @data_bits: Number of bits of data per register.
+ * @control: Control bus used.
+ *
+ * Register formats are frequently shared between many I2C and SPI
+ * devices.  In order to promote code reuse the ASoC core provides
+ * some standard implementations of CODEC read and write operations
+ * which can be set up using this function.
+ *
+ * The caller is responsible for allocating and initialising the
+ * actual cache.
+ *
+ * Note that at present this code cannot be used by CODECs with
+ * volatile registers.
+ */
+int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,
+			       int addr_bits, int data_bits,
+			       enum snd_soc_control_type control)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(io_types); i++)
+		if (io_types[i].addr_bits == addr_bits &&
+		    io_types[i].data_bits == data_bits)
+			break;
+	if (i == ARRAY_SIZE(io_types)) {
+		printk(KERN_ERR
+		       "No I/O functions for %d bit address %d bit data\n",
+		       addr_bits, data_bits);
+		return -EINVAL;
+	}
+
+	codec->write = io_types[i].write;
+	codec->read = hw_read;
+	codec->bulk_write_raw = snd_soc_hw_bulk_write_raw;
+
+	switch (control) {
+	case SND_SOC_CUSTOM:
+		break;
+
+	case SND_SOC_I2C:
+#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))
+		codec->hw_write = (hw_write_t)i2c_master_send;
+#endif
+		if (io_types[i].i2c_read)
+			codec->hw_read = io_types[i].i2c_read;
+
+		codec->control_data = container_of(codec->dev,
+						   struct i2c_client,
+						   dev);
+		break;
+
+	case SND_SOC_SPI:
+#ifdef CONFIG_SPI_MASTER
+		codec->hw_write = do_spi_write;
+#endif
+
+		codec->control_data = container_of(codec->dev,
+						   struct spi_device,
+						   dev);
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_codec_set_cache_io);
+
