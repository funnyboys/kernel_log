commit 99396e3883672a9073e7458b40504d647351b54f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 23 14:21:35 2020 +0900

    ASoC: ux500: use asoc_rtd_to_cpu() / asoc_rtd_to_codec() macro for DAI pointer
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/871rpjir34.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 9445dbe8e039..39b96c132bc8 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -46,7 +46,7 @@ static const struct snd_pcm_hardware ux500_pcm_hw = {
 static struct dma_chan *ux500_pcm_request_chan(struct snd_soc_pcm_runtime *rtd,
 	struct snd_pcm_substream *substream)
 {
-	struct snd_soc_dai *dai = rtd->cpu_dai;
+	struct snd_soc_dai *dai = asoc_rtd_to_cpu(rtd, 0);
 	u16 per_data_width, mem_data_width;
 	struct stedma40_chan_cfg *dma_cfg;
 	struct ux500_msp_dma_params *dma_params;
@@ -86,7 +86,7 @@ static int ux500_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 		struct dma_slave_config *slave_config)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct msp_i2s_platform_data *pdata = rtd->cpu_dai->dev->platform_data;
+	struct msp_i2s_platform_data *pdata = asoc_rtd_to_cpu(rtd, 0)->dev->platform_data;
 	struct snd_dmaengine_dai_dma_data *snd_dma_params;
 	struct ux500_msp_dma_params *ste_dma_params;
 	dma_addr_t dma_addr;
@@ -94,11 +94,11 @@ static int ux500_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 
 	if (pdata) {
 		ste_dma_params =
-			snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+			snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);
 		dma_addr = ste_dma_params->tx_rx_addr;
 	} else {
 		snd_dma_params =
-			snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+			snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);
 		dma_addr = snd_dma_params->addr;
 	}
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index d35ba7700f46..9445dbe8e039 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) ST-Ericsson SA 2012
  *
@@ -6,10 +7,6 @@
  *         for ST-Ericsson.
  *
  * License terms:
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
  */
 
 #include <asm/page.h>

commit 1783c9d7cb7bc3181b9271665959b87280d98d8e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 10 17:34:45 2018 +0100

    ASoC: ux500: add MODULE_LICENSE tag
    
    This adds MODULE_LICENSE/AUTHOR/DESCRIPTION tags to the ux500
    platform drivers, to avoid these build warnings:
    
    WARNING: modpost: missing MODULE_LICENSE() in sound/soc/ux500/snd-soc-ux500-plat-dma.o
    WARNING: modpost: missing MODULE_LICENSE() in sound/soc/ux500/snd-soc-ux500-mach-mop500.o
    
    The company no longer exists, so the email addresses of the authors
    don't work any more, but I've added them anyway for consistency.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index f12c01dddc8d..d35ba7700f46 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -165,3 +165,8 @@ int ux500_pcm_unregister_platform(struct platform_device *pdev)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ux500_pcm_unregister_platform);
+
+MODULE_AUTHOR("Ola Lilja");
+MODULE_AUTHOR("Roger Nilsson");
+MODULE_DESCRIPTION("ASoC UX500 driver");
+MODULE_LICENSE("GPL v2");

commit acde50a7bf1fd6ae0baa4402f0a02c4b1bd4c990
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 27 12:44:25 2015 +0200

    ASoC: dmaengine_pcm: Make FLAG_NO_RESIDUE internal
    
    Whether residue can be reported or not is not a property of the audio
    controller but of the DMA controller. The FLAG_NO_RESIDUE was initially
    added when the DMAengine framework had no support for describing the residue
    reporting capabilities of the controller. Support for this was added quite a
    while ago and recently the DMAengine framework started to complain if a
    driver does not describe its capabilities and a lot of patches have been
    merged that add support for this where it was missing. So it should be safe
    to assume that driver on actively used platforms properly implement the DMA
    capabilities API.
    
    This patch makes the FLAG_NO_RESIDUE internal and no longer allows audio
    controller drivers to manually set the flag. If a DMA driver against
    expectations does not support reporting its capabilities for now the generic
    DMAengine PCM driver will now emit a warning and simply assume that residue
    reporting is not supported. In the future this might be changed to aborting
    with an error.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 51a66a87305a..f12c01dddc8d 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -147,7 +147,6 @@ int ux500_pcm_register_platform(struct platform_device *pdev)
 		pcm_config = &ux500_dmaengine_pcm_config;
 
 	ret = snd_dmaengine_pcm_register(&pdev->dev, pcm_config,
-					 SND_DMAENGINE_PCM_FLAG_NO_RESIDUE |
 					 SND_DMAENGINE_PCM_FLAG_COMPAT);
 	if (ret < 0) {
 		dev_err(&pdev->dev,

commit df021a72c92e8b9fe9b5d3f11105125484e8751f
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jan 6 14:19:15 2014 +0100

    ASoC: ux500: Don't set unused struct snd_pcm_hardware fields
    
    The ASoC core assumes that the PCM component of the ASoC card transparently
    moves data around and does not impose any restrictions on the memory layout or
    the transfer speed. It ignores all fields from the snd_pcm_hardware struct for
    the PCM driver that are related to this. Setting these fields in the PCM driver
    might suggest otherwise though, so rather not set them.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 55a8634cc3da..51a66a87305a 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -28,12 +28,6 @@
 #include "ux500_msp_i2s.h"
 #include "ux500_pcm.h"
 
-#define UX500_PLATFORM_MIN_RATE 8000
-#define UX500_PLATFORM_MAX_RATE 48000
-
-#define UX500_PLATFORM_MIN_CHANNELS 1
-#define UX500_PLATFORM_MAX_CHANNELS 8
-
 #define UX500_PLATFORM_PERIODS_BYTES_MIN	128
 #define UX500_PLATFORM_PERIODS_BYTES_MAX	(64 * PAGE_SIZE)
 #define UX500_PLATFORM_PERIODS_MIN		2
@@ -45,15 +39,6 @@ static const struct snd_pcm_hardware ux500_pcm_hw = {
 		SNDRV_PCM_INFO_MMAP |
 		SNDRV_PCM_INFO_RESUME |
 		SNDRV_PCM_INFO_PAUSE,
-	.formats = SNDRV_PCM_FMTBIT_S16_LE |
-		SNDRV_PCM_FMTBIT_U16_LE |
-		SNDRV_PCM_FMTBIT_S16_BE |
-		SNDRV_PCM_FMTBIT_U16_BE,
-	.rates = SNDRV_PCM_RATE_KNOT,
-	.rate_min = UX500_PLATFORM_MIN_RATE,
-	.rate_max = UX500_PLATFORM_MAX_RATE,
-	.channels_min = UX500_PLATFORM_MIN_CHANNELS,
-	.channels_max = UX500_PLATFORM_MAX_CHANNELS,
 	.buffer_bytes_max = UX500_PLATFORM_BUFFER_BYTES_MAX,
 	.period_bytes_min = UX500_PLATFORM_PERIODS_BYTES_MIN,
 	.period_bytes_max = UX500_PLATFORM_PERIODS_BYTES_MAX,

commit 86a3fdfc63402ffbcee226c4a2503eee14a41afe
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Dec 19 15:55:07 2013 +0000

    ASoC: ux500_pcm: Differentiate between pdata and DT initialisation
    
    If booting with full DT support (i.e. DMA too, the last piece of the
    puzzle), then we don't need to use the compatible_request_channel call
    back or require some of the historical bumph which probably isn't
    required by a platform data start-up now either. This will also be
    ripped out in upcoming commits.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 3d1c342245f0..55a8634cc3da 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -145,15 +145,25 @@ static const struct snd_dmaengine_pcm_config ux500_dmaengine_pcm_config = {
 	.prepare_slave_config = ux500_pcm_prepare_slave_config,
 };
 
+static const struct snd_dmaengine_pcm_config ux500_dmaengine_of_pcm_config = {
+	.compat_request_channel = ux500_pcm_request_chan,
+	.prepare_slave_config = ux500_pcm_prepare_slave_config,
+};
+
 int ux500_pcm_register_platform(struct platform_device *pdev)
 {
+	const struct snd_dmaengine_pcm_config *pcm_config;
+	struct device_node *np = pdev->dev.of_node;
 	int ret;
 
-	ret = snd_dmaengine_pcm_register(&pdev->dev,
-			&ux500_dmaengine_pcm_config,
-			SND_DMAENGINE_PCM_FLAG_NO_RESIDUE |
-			SND_DMAENGINE_PCM_FLAG_COMPAT |
-			SND_DMAENGINE_PCM_FLAG_NO_DT);
+	if (np)
+		pcm_config = &ux500_dmaengine_of_pcm_config;
+	else
+		pcm_config = &ux500_dmaengine_pcm_config;
+
+	ret = snd_dmaengine_pcm_register(&pdev->dev, pcm_config,
+					 SND_DMAENGINE_PCM_FLAG_NO_RESIDUE |
+					 SND_DMAENGINE_PCM_FLAG_COMPAT);
 	if (ret < 0) {
 		dev_err(&pdev->dev,
 			"%s: ERROR: Failed to register platform '%s' (%d)!\n",

commit ead20611a212db8ab4392cfc28092c9c849c69a4
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Dec 19 15:55:06 2013 +0000

    ASoC: ux500_pcm: Take out pointless dev_dbg() call
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 8b53f22edcaf..3d1c342245f0 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -65,14 +65,10 @@ static struct dma_chan *ux500_pcm_request_chan(struct snd_soc_pcm_runtime *rtd,
 	struct snd_pcm_substream *substream)
 {
 	struct snd_soc_dai *dai = rtd->cpu_dai;
-	struct device *dev = dai->dev;
 	u16 per_data_width, mem_data_width;
 	struct stedma40_chan_cfg *dma_cfg;
 	struct ux500_msp_dma_params *dma_params;
 
-	dev_dbg(dev, "%s: MSP %d (%s): Enter.\n", __func__, dai->id,
-		snd_pcm_stream_str(substream));
-
 	dma_params = snd_soc_dai_get_dma_data(dai, substream);
 	dma_cfg = dma_params->dma_cfg;
 

commit f6c377520c26297cc870173df3cd0acdef08bc1c
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Dec 19 15:55:03 2013 +0000

    ASoC: ux500_pcm: Expect different saved DMA data when obtaining from DAI store
    
    In preparation for full Device Tree enablement we must differentiate
    between the two varying ways DMA data can be held in the DAI store. If
    we're booting with Device Tree the provided 'snd_dmaengine_dai_dma_data'
    data structure shall be used, whereas in order to avoid breaking legacy
    platform data we also need to be able to translate DMA data stored using
    the UX500 specific 'ux500_msp_dma_params' method.
    
    Once we move over to solely use Device Tree, we can enforce the use of
    'snd_dmaengine_dai_dma_data' and this code can be removed altogether.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 32d457232110..8b53f22edcaf 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -108,10 +108,21 @@ static int ux500_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 		struct dma_slave_config *slave_config)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct ux500_msp_dma_params *dma_params;
+	struct msp_i2s_platform_data *pdata = rtd->cpu_dai->dev->platform_data;
+	struct snd_dmaengine_dai_dma_data *snd_dma_params;
+	struct ux500_msp_dma_params *ste_dma_params;
+	dma_addr_t dma_addr;
 	int ret;
 
-	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	if (pdata) {
+		ste_dma_params =
+			snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+		dma_addr = ste_dma_params->tx_rx_addr;
+	} else {
+		snd_dma_params =
+			snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+		dma_addr = snd_dma_params->addr;
+	}
 
 	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
 	if (ret)
@@ -124,9 +135,9 @@ static int ux500_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 	slave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		slave_config->dst_addr = dma_params->tx_rx_addr;
+		slave_config->dst_addr = dma_addr;
 	else
-		slave_config->src_addr = dma_params->tx_rx_addr;
+		slave_config->src_addr = dma_addr;
 
 	return 0;
 }

commit 609a3050b8a516d12cf6dc0e8beb5875ededad3d
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Dec 19 15:55:02 2013 +0000

    ASoC: ux500_pcm: Stop pretending that we support varying address widths
    
    The Slave Config's addr_width attribute is populated by data_width of
    dma_cfg, which in turn is derived from dma_params' data_size attribute
    and that comes from the slot_width which is always 16 bits (2 Bytes).
    We're cutting out the middle man here and just setting the DMA Slave
    Config directly.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index ce554de5d9dc..32d457232110 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -109,20 +109,19 @@ static int ux500_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct ux500_msp_dma_params *dma_params;
-	struct stedma40_chan_cfg *dma_cfg;
 	int ret;
 
 	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
-	dma_cfg = dma_params->dma_cfg;
 
 	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
 	if (ret)
 		return ret;
 
 	slave_config->dst_maxburst = 4;
-	slave_config->dst_addr_width = dma_cfg->dst_info.data_width;
 	slave_config->src_maxburst = 4;
-	slave_config->src_addr_width = dma_cfg->src_info.data_width;
+
+	slave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	slave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		slave_config->dst_addr = dma_params->tx_rx_addr;

commit 1286da8bc009cb2aee7f285e94623fc974c0c983
Merge: 9e220385c4eb 1ba65ae4bdbd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 19:52:22 2013 -0700

    Merge tag 'sound-3.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "A relative calm release at this time with a flat diffstat.  The only
      significant change in the ALSA core side is the support for more than
      32 card instances, configurable via kconfig.  Other than that, in both
      ASoC and other parts, mostly some improvements and fixes on the driver
      side.
    
       - hda: More quirks for ALC269-variants on Dell & co, VIA codec fixes
       - hda: Haswell HDMI audio fixes, runtime PM improvements
       - hda: Intel BayTrail support, ALC5505 DSP support
       - es1968: MediaForte M56VAP support
       - usb-audio: Improved support for Yamaha/Roland devices
       - usb-audio: M2Tech hiFace, Audio Advantage Micro II support
       - hdspm: wordclock fixes
       - ASoC: Pending fixes for WM8962
       - ASoC: Cleanups and fixes for Blackfin, SGTL5000 and UX500
       - ASoC: Generalisation of the Bluetooth and HDMI stub drivers
       - ASoC: SSM2518 and RT5640 codec drivers.
       - ASoC: Tegra CPUs with RT5640 machine driver
       - ASoC: AC'97 refactoring bug fixes
       - ASoC: ADAU1701 driver fixes
       - Clean up of *_set_drvdata() in a wide range of drivers"
    
    * tag 'sound-3.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (284 commits)
      ALSA: vmaster: Fix the regression of missing vmaster hook call
      ALSA: hda - Add Dell SSID to support Headset Mic recording
      ASoC: adau1701: remove control_data assignment
      ASoC: adau1701: more direct regmap usage
      ASoC: ac97: fixup multi-platform AC'97 module build failure
      ASoC: pxa2xx: fixup multi-platform AC'97 build failures
      ASoC: tegra20-ac97: Remove unused variable
      ASoC: tegra20-ac97: Remove duplicate error message
      ALSA: usb-audio: Add Audio Advantage Micro II
      ASoC: tas5086: fix Mid-Z implementation
      ASoC: tas5086: fix TAS5086_CLOCK_CONTROL register size
      ALSA: Replace the magic number 44 with const
      ALSA: hda - Fix the max length of control name in generic parser
      ALSA: hda - Guess what, it's two more Dell headset mic quirks
      ALSA: hda - Yet another Dell headset mic quirk
      ALSA: hda - Add support for ALC5505 DSP power-save mode
      ASoC: mfld: Remove unused variable
      ALSA: usb-audio: add quirks for Roland QUAD/OCTO-CAPTURE
      ALSA: usb-audio: claim autodetected PCM interfaces all at once
      ALSA: usb-audio: remove superfluous Roland quirks
      ...

commit eef6473ff3ce2383febebd2e799beceaece9adda
Author: Fabio Baltieri <fabio.baltieri@linaro.org>
Date:   Wed Jun 12 09:57:59 2013 +0200

    ASoC: ux500: Add DMA slave config prepare routine
    
    Implement a DMA slave config prepare routine, as until now the MSP
    driver depended on the DMA controller completing the channel
    configuration on its own, but this is not the case anymore since the
    recent DMA driver updates.
    
    Signed-off-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index b6e5ae277299..5f01c19776bf 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -103,10 +103,40 @@ static struct dma_chan *ux500_pcm_request_chan(struct snd_soc_pcm_runtime *rtd,
 	return snd_dmaengine_pcm_request_channel(stedma40_filter, dma_cfg);
 }
 
+static int ux500_pcm_prepare_slave_config(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct dma_slave_config *slave_config)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct ux500_msp_dma_params *dma_params;
+	struct stedma40_chan_cfg *dma_cfg;
+	int ret;
+
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	dma_cfg = dma_params->dma_cfg;
+
+	ret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);
+	if (ret)
+		return ret;
+
+	slave_config->dst_maxburst = 4;
+	slave_config->dst_addr_width = dma_cfg->dst_info.data_width;
+	slave_config->src_maxburst = 4;
+	slave_config->src_addr_width = dma_cfg->src_info.data_width;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		slave_config->dst_addr = dma_params->tx_rx_addr;
+	else
+		slave_config->src_addr = dma_params->tx_rx_addr;
+
+	return 0;
+}
+
 static const struct snd_dmaengine_pcm_config ux500_dmaengine_pcm_config = {
 	.pcm_hardware = &ux500_pcm_hw,
 	.compat_request_channel = ux500_pcm_request_chan,
 	.prealloc_buffer_size = 128 * 1024,
+	.prepare_slave_config = ux500_pcm_prepare_slave_config,
 };
 
 int ux500_pcm_register_platform(struct platform_device *pdev)

commit 43f2e1a3be5d83004f09bcb53c46f273e7473a00
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed May 15 11:51:57 2013 +0200

    dmaengine: ste_dma40: Convert data_width from register bit format to value
    
    When a DMA client requests and configures a DMA channel, it requests
    data_width in Bytes. The DMA40 driver then swiftly converts it over to
    the necessary register bit value. Unfortunately, for any subsequent
    calculations we have to shift '1' by the bit pattern (1 << data_width)
    times to make any sense of it.
    
    This patch flips the semantics on its head and only converts the value
    to its respective register bit pattern when writing to registers. This
    way we can use the true data_width (in Bytes) value.
    
    Cc: Dan Williams <djbw@fb.com>
    Cc: Per Forlin <per.forlin@stericsson.com>
    Cc: Rabin Vincent <rabin@rab.in>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index b6e5ae277299..31f9bbc74521 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -76,20 +76,20 @@ static struct dma_chan *ux500_pcm_request_chan(struct snd_soc_pcm_runtime *rtd,
 	dma_params = snd_soc_dai_get_dma_data(dai, substream);
 	dma_cfg = dma_params->dma_cfg;
 
-	mem_data_width = STEDMA40_HALFWORD_WIDTH;
+	mem_data_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 
 	switch (dma_params->data_size) {
 	case 32:
-		per_data_width = STEDMA40_WORD_WIDTH;
+		per_data_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 		break;
 	case 16:
-		per_data_width = STEDMA40_HALFWORD_WIDTH;
+		per_data_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 		break;
 	case 8:
-		per_data_width = STEDMA40_BYTE_WIDTH;
+		per_data_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
 		break;
 	default:
-		per_data_width = STEDMA40_WORD_WIDTH;
+		per_data_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	}
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {

commit 22f38f792ec53e2a93be13ecb609bbe911ed8ff9
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 15 19:20:04 2013 +0200

    ASoC: ux500: Use generic dmaengine PCM
    
    Use the generic dmaengine PCM driver instead of a custom implemention.  There is
    a minor functional change, the ux500 PCM driver did not preallocate the audio
    buffer, while the generic dmaengine PCM driver will do this.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index a7d4f04e5964..b6e5ae277299 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -40,7 +40,7 @@
 #define UX500_PLATFORM_PERIODS_MAX		48
 #define UX500_PLATFORM_BUFFER_BYTES_MAX		(2048 * PAGE_SIZE)
 
-static struct snd_pcm_hardware ux500_pcm_hw = {
+static const struct snd_pcm_hardware ux500_pcm_hw = {
 	.info = SNDRV_PCM_INFO_INTERLEAVED |
 		SNDRV_PCM_INFO_MMAP |
 		SNDRV_PCM_INFO_RESUME |
@@ -61,43 +61,23 @@ static struct snd_pcm_hardware ux500_pcm_hw = {
 	.periods_max = UX500_PLATFORM_PERIODS_MAX,
 };
 
-static void ux500_pcm_dma_hw_free(struct device *dev,
-				struct snd_pcm_substream *substream)
+static struct dma_chan *ux500_pcm_request_chan(struct snd_soc_pcm_runtime *rtd,
+	struct snd_pcm_substream *substream)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_dma_buffer *buf = runtime->dma_buffer_p;
-
-	if (runtime->dma_area == NULL)
-		return;
-
-	if (buf != &substream->dma_buffer) {
-		dma_free_coherent(buf->dev.dev, buf->bytes, buf->area,
-				buf->addr);
-		kfree(runtime->dma_buffer_p);
-	}
-
-	snd_pcm_set_runtime_buffer(substream, NULL);
-}
-
-static int ux500_pcm_open(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_dai *dai = rtd->cpu_dai;
 	struct device *dev = dai->dev;
-	int ret;
-	struct ux500_msp_dma_params *dma_params;
 	u16 per_data_width, mem_data_width;
 	struct stedma40_chan_cfg *dma_cfg;
+	struct ux500_msp_dma_params *dma_params;
 
 	dev_dbg(dev, "%s: MSP %d (%s): Enter.\n", __func__, dai->id,
 		snd_pcm_stream_str(substream));
 
-	dev_dbg(dev, "%s: Set runtime hwparams.\n", __func__);
-	snd_soc_set_runtime_hwparams(substream, &ux500_pcm_hw);
+	dma_params = snd_soc_dai_get_dma_data(dai, substream);
+	dma_cfg = dma_params->dma_cfg;
 
 	mem_data_width = STEDMA40_HALFWORD_WIDTH;
 
-	dma_params = snd_soc_dai_get_dma_data(dai, substream);
 	switch (dma_params->data_size) {
 	case 32:
 		per_data_width = STEDMA40_WORD_WIDTH;
@@ -110,13 +90,8 @@ static int ux500_pcm_open(struct snd_pcm_substream *substream)
 		break;
 	default:
 		per_data_width = STEDMA40_WORD_WIDTH;
-		dev_warn(rtd->platform->dev,
-			"%s: Unknown data-size (%d)! Assuming 32 bits.\n",
-			__func__, dma_params->data_size);
 	}
 
-	dma_cfg = dma_params->dma_cfg;
-
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		dma_cfg->src_info.data_width = mem_data_width;
 		dma_cfg->dst_info.data_width = per_data_width;
@@ -125,123 +100,24 @@ static int ux500_pcm_open(struct snd_pcm_substream *substream)
 		dma_cfg->dst_info.data_width = mem_data_width;
 	}
 
-	ret = snd_dmaengine_pcm_open_request_chan(substream, stedma40_filter,
-			dma_cfg);
-	if (ret) {
-		dev_dbg(dai->dev,
-			"%s: ERROR: snd_dmaengine_pcm_open failed (%d)!\n",
-			__func__, ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int ux500_pcm_hw_params(struct snd_pcm_substream *substream,
-			struct snd_pcm_hw_params *hw_params)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_dma_buffer *buf = runtime->dma_buffer_p;
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	int ret = 0;
-	int size;
-
-	dev_dbg(rtd->platform->dev, "%s: Enter\n", __func__);
-
-	size = params_buffer_bytes(hw_params);
-
-	if (buf) {
-		if (buf->bytes >= size)
-			goto out;
-		ux500_pcm_dma_hw_free(NULL, substream);
-	}
-
-	if (substream->dma_buffer.area != NULL &&
-		substream->dma_buffer.bytes >= size) {
-		buf = &substream->dma_buffer;
-	} else {
-		buf = kmalloc(sizeof(struct snd_dma_buffer), GFP_KERNEL);
-		if (!buf)
-			goto nomem;
-
-		buf->dev.type = SNDRV_DMA_TYPE_DEV;
-		buf->dev.dev = NULL;
-		buf->area = dma_alloc_coherent(NULL, size, &buf->addr,
-					GFP_KERNEL);
-		buf->bytes = size;
-		buf->private_data = NULL;
-
-		if (!buf->area)
-			goto free;
-	}
-	snd_pcm_set_runtime_buffer(substream, buf);
-	ret = 1;
- out:
-	runtime->dma_bytes = size;
-	return ret;
-
- free:
-	kfree(buf);
- nomem:
-	return -ENOMEM;
-}
-
-static int ux500_pcm_hw_free(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-
-	dev_dbg(rtd->platform->dev, "%s: Enter\n", __func__);
-
-	ux500_pcm_dma_hw_free(NULL, substream);
-
-	return 0;
+	return snd_dmaengine_pcm_request_channel(stedma40_filter, dma_cfg);
 }
 
-static int ux500_pcm_mmap(struct snd_pcm_substream *substream,
-			struct vm_area_struct *vma)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-
-	dev_dbg(rtd->platform->dev, "%s: Enter.\n", __func__);
-
-	return dma_mmap_coherent(NULL, vma, runtime->dma_area,
-				runtime->dma_addr, runtime->dma_bytes);
-}
-
-static struct snd_pcm_ops ux500_pcm_ops = {
-	.open		= ux500_pcm_open,
-	.close		= snd_dmaengine_pcm_close_release_chan,
-	.ioctl		= snd_pcm_lib_ioctl,
-	.hw_params	= ux500_pcm_hw_params,
-	.hw_free	= ux500_pcm_hw_free,
-	.trigger	= snd_dmaengine_pcm_trigger,
-	.pointer	= snd_dmaengine_pcm_pointer_no_residue,
-	.mmap		= ux500_pcm_mmap
-};
-
-int ux500_pcm_new(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_pcm *pcm = rtd->pcm;
-
-	dev_dbg(rtd->platform->dev, "%s: Enter (id = '%s').\n", __func__,
-		pcm->id);
-
-	pcm->info_flags = 0;
-
-	return 0;
-}
-
-static struct snd_soc_platform_driver ux500_pcm_soc_drv = {
-	.ops		= &ux500_pcm_ops,
-	.pcm_new        = ux500_pcm_new,
+static const struct snd_dmaengine_pcm_config ux500_dmaengine_pcm_config = {
+	.pcm_hardware = &ux500_pcm_hw,
+	.compat_request_channel = ux500_pcm_request_chan,
+	.prealloc_buffer_size = 128 * 1024,
 };
 
 int ux500_pcm_register_platform(struct platform_device *pdev)
 {
 	int ret;
 
-	ret = snd_soc_register_platform(&pdev->dev, &ux500_pcm_soc_drv);
+	ret = snd_dmaengine_pcm_register(&pdev->dev,
+			&ux500_dmaengine_pcm_config,
+			SND_DMAENGINE_PCM_FLAG_NO_RESIDUE |
+			SND_DMAENGINE_PCM_FLAG_COMPAT |
+			SND_DMAENGINE_PCM_FLAG_NO_DT);
 	if (ret < 0) {
 		dev_err(&pdev->dev,
 			"%s: ERROR: Failed to register platform '%s' (%d)!\n",
@@ -255,8 +131,7 @@ EXPORT_SYMBOL_GPL(ux500_pcm_register_platform);
 
 int ux500_pcm_unregister_platform(struct platform_device *pdev)
 {
-	snd_soc_unregister_platform(&pdev->dev);
-
+	snd_dmaengine_pcm_unregister(&pdev->dev);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ux500_pcm_unregister_platform);

commit 7c1c1d4a7b4ca1266057a3632d27450f5575caf9
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 15 19:19:48 2013 +0200

    ASoC: dmaengine-pcm: Make requesting the DMA channel at PCM open optional
    
    Refactor the dmaengine PCM library to allow the DMA channel to be requested
    before opening a PCM substream. snd_dmaengine_pcm_open() now expects a DMA
    channel instead of a filter function and filter parameter as its parameters.
    snd_dmaengine_pcm_close() is updated to not release the DMA channel. This allows
    a dmaengine based PCM driver to request its channels before the substream is
    opened.
    
    The patch also introduces two new functions, snd_dmaengine_pcm_open_request_chan()
    and snd_dmaengine_pcm_close_release_chan(), which have the same signature and
    behaviour of the old snd_dmaengine_pcm_{open,close}() and internally use the new
    variants of these functions. All users of snd_dmaengine_pcm_{open,close}() are
    updated to use snd_dmaengine_pcm_open_request_chan() and
    snd_dmaengine_pcm_close_release_chan().
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 09b5364e5095..a7d4f04e5964 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -125,8 +125,8 @@ static int ux500_pcm_open(struct snd_pcm_substream *substream)
 		dma_cfg->dst_info.data_width = mem_data_width;
 	}
 
-
-	ret = snd_dmaengine_pcm_open(substream, stedma40_filter, dma_cfg);
+	ret = snd_dmaengine_pcm_open_request_chan(substream, stedma40_filter,
+			dma_cfg);
 	if (ret) {
 		dev_dbg(dai->dev,
 			"%s: ERROR: snd_dmaengine_pcm_open failed (%d)!\n",
@@ -211,7 +211,7 @@ static int ux500_pcm_mmap(struct snd_pcm_substream *substream,
 
 static struct snd_pcm_ops ux500_pcm_ops = {
 	.open		= ux500_pcm_open,
-	.close		= snd_dmaengine_pcm_close,
+	.close		= snd_dmaengine_pcm_close_release_chan,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= ux500_pcm_hw_params,
 	.hw_free	= ux500_pcm_hw_free,

commit 69b6f19622ce0aef41df884b75e3f789c64b89c0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Apr 3 11:02:55 2013 +0200

    ASoC: ux500_pcm: Use the same snd_pcm_hardware for playback and capture
    
    The snd_pcm_hardware structs for playback and capture in the ux500 PCM are
    identical, so remove one of them and use the same snd_pcm_hardware struct for
    both playback and capture. Also move the defines used to initialize the
    snd_pcm_hardware fields from ux500_pcm.h to ux500_pcm.c since that's the only
    place where they are used.
    
    Also drop the assignment of the snd_pcm_hardware struct to runtime->hw since
    that is what the call to snd_soc_set_runtime_hwparams() right above it already
    does, so the second assignment is redundant.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 1ab36fa845cd..09b5364e5095 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -28,28 +28,19 @@
 #include "ux500_msp_i2s.h"
 #include "ux500_pcm.h"
 
-static struct snd_pcm_hardware ux500_pcm_hw_playback = {
-	.info = SNDRV_PCM_INFO_INTERLEAVED |
-		SNDRV_PCM_INFO_MMAP |
-		SNDRV_PCM_INFO_RESUME |
-		SNDRV_PCM_INFO_PAUSE,
-	.formats = SNDRV_PCM_FMTBIT_S16_LE |
-		SNDRV_PCM_FMTBIT_U16_LE |
-		SNDRV_PCM_FMTBIT_S16_BE |
-		SNDRV_PCM_FMTBIT_U16_BE,
-	.rates = SNDRV_PCM_RATE_KNOT,
-	.rate_min = UX500_PLATFORM_MIN_RATE_PLAYBACK,
-	.rate_max = UX500_PLATFORM_MAX_RATE_PLAYBACK,
-	.channels_min = UX500_PLATFORM_MIN_CHANNELS,
-	.channels_max = UX500_PLATFORM_MAX_CHANNELS,
-	.buffer_bytes_max = UX500_PLATFORM_BUFFER_BYTES_MAX,
-	.period_bytes_min = UX500_PLATFORM_PERIODS_BYTES_MIN,
-	.period_bytes_max = UX500_PLATFORM_PERIODS_BYTES_MAX,
-	.periods_min = UX500_PLATFORM_PERIODS_MIN,
-	.periods_max = UX500_PLATFORM_PERIODS_MAX,
-};
+#define UX500_PLATFORM_MIN_RATE 8000
+#define UX500_PLATFORM_MAX_RATE 48000
+
+#define UX500_PLATFORM_MIN_CHANNELS 1
+#define UX500_PLATFORM_MAX_CHANNELS 8
+
+#define UX500_PLATFORM_PERIODS_BYTES_MIN	128
+#define UX500_PLATFORM_PERIODS_BYTES_MAX	(64 * PAGE_SIZE)
+#define UX500_PLATFORM_PERIODS_MIN		2
+#define UX500_PLATFORM_PERIODS_MAX		48
+#define UX500_PLATFORM_BUFFER_BYTES_MAX		(2048 * PAGE_SIZE)
 
-static struct snd_pcm_hardware ux500_pcm_hw_capture = {
+static struct snd_pcm_hardware ux500_pcm_hw = {
 	.info = SNDRV_PCM_INFO_INTERLEAVED |
 		SNDRV_PCM_INFO_MMAP |
 		SNDRV_PCM_INFO_RESUME |
@@ -59,8 +50,8 @@ static struct snd_pcm_hardware ux500_pcm_hw_capture = {
 		SNDRV_PCM_FMTBIT_S16_BE |
 		SNDRV_PCM_FMTBIT_U16_BE,
 	.rates = SNDRV_PCM_RATE_KNOT,
-	.rate_min = UX500_PLATFORM_MIN_RATE_CAPTURE,
-	.rate_max = UX500_PLATFORM_MAX_RATE_CAPTURE,
+	.rate_min = UX500_PLATFORM_MIN_RATE,
+	.rate_max = UX500_PLATFORM_MAX_RATE,
 	.channels_min = UX500_PLATFORM_MIN_CHANNELS,
 	.channels_max = UX500_PLATFORM_MAX_CHANNELS,
 	.buffer_bytes_max = UX500_PLATFORM_BUFFER_BYTES_MAX,
@@ -90,8 +81,6 @@ static void ux500_pcm_dma_hw_free(struct device *dev,
 
 static int ux500_pcm_open(struct snd_pcm_substream *substream)
 {
-	int stream_id = substream->pstr->stream;
-	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_dai *dai = rtd->cpu_dai;
 	struct device *dev = dai->dev;
@@ -104,17 +93,7 @@ static int ux500_pcm_open(struct snd_pcm_substream *substream)
 		snd_pcm_stream_str(substream));
 
 	dev_dbg(dev, "%s: Set runtime hwparams.\n", __func__);
-	if (stream_id == SNDRV_PCM_STREAM_PLAYBACK)
-		snd_soc_set_runtime_hwparams(substream,
-					&ux500_pcm_hw_playback);
-	else
-		snd_soc_set_runtime_hwparams(substream,
-					&ux500_pcm_hw_capture);
-
-	dev_dbg(dev, "%s: Set hw-struct for %s.\n", __func__,
-		snd_pcm_stream_str(substream));
-	runtime->hw = (stream_id == SNDRV_PCM_STREAM_PLAYBACK) ?
-		ux500_pcm_hw_playback : ux500_pcm_hw_capture;
+	snd_soc_set_runtime_hwparams(substream, &ux500_pcm_hw);
 
 	mem_data_width = STEDMA40_HALFWORD_WIDTH;
 

commit ebd59b07ecd9d35d5bc88c91a4878fbb4549ed42
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Mar 22 14:12:07 2013 +0100

    ASoC: ux500_pcm: No need to use snd_dmaengine_pcm_set_data()
    
    The driver never uses snd_dmaengine_pcm_get_data(), so there is no need to use
    snd_dmaengine_pcm_set_data().
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Ola Lilja <ola.o.lilja@stericsson.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index d000ba271cab..1ab36fa845cd 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -155,8 +155,6 @@ static int ux500_pcm_open(struct snd_pcm_substream *substream)
 		return ret;
 	}
 
-	snd_dmaengine_pcm_set_data(substream, dma_cfg);
-
 	return 0;
 }
 

commit 8c4e56fd5595105128077c2bbdfde3c15a4c2d91
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Mar 22 14:12:05 2013 +0100

    ASoC: ux500_pcm: No need to wrap snd_dmaengine_pcm_close()
    
    If a PCM driver using the dmaengine PCM helper functions doesn't need to do
    anything special in its pcm_close callback, snd_dmaengine_pcm_close can be used
    directly for as the pcm_close callback and there is no need to wrap it in a
    custom function.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Ola Lilja <ola.o.lilja@stericsson.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 375ca6ba3ebb..d000ba271cab 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -160,18 +160,6 @@ static int ux500_pcm_open(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static int ux500_pcm_close(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *dai = rtd->cpu_dai;
-
-	dev_dbg(dai->dev, "%s: Enter\n", __func__);
-
-	snd_dmaengine_pcm_close(substream);
-
-	return 0;
-}
-
 static int ux500_pcm_hw_params(struct snd_pcm_substream *substream,
 			struct snd_pcm_hw_params *hw_params)
 {
@@ -246,7 +234,7 @@ static int ux500_pcm_mmap(struct snd_pcm_substream *substream,
 
 static struct snd_pcm_ops ux500_pcm_ops = {
 	.open		= ux500_pcm_open,
-	.close		= ux500_pcm_close,
+	.close		= snd_dmaengine_pcm_close,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= ux500_pcm_hw_params,
 	.hw_free	= ux500_pcm_hw_free,

commit cb20d5757bbe79d9c9e4210e232934792be2336e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Mar 22 14:12:01 2013 +0100

    ASoC: ux500_pcm: Remove duplicated SNDRV_PCM_HW_PARAM_PERIODS constraint
    
    The generic dmaengine based PCM driver code takes care of setting this
    constraint, there is no need of doing it manually in the ux500 driver.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Ola Lilja <ola.o.lilja@stericsson.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 846fa82a58d0..375ca6ba3ebb 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -111,15 +111,6 @@ static int ux500_pcm_open(struct snd_pcm_substream *substream)
 		snd_soc_set_runtime_hwparams(substream,
 					&ux500_pcm_hw_capture);
 
-	/* ensure that buffer size is a multiple of period size */
-	ret = snd_pcm_hw_constraint_integer(runtime,
-					SNDRV_PCM_HW_PARAM_PERIODS);
-	if (ret < 0) {
-		dev_err(dev, "%s: Error: snd_pcm_hw_constraints failed (%d)\n",
-			__func__, ret);
-		return ret;
-	}
-
 	dev_dbg(dev, "%s: Set hw-struct for %s.\n", __func__,
 		snd_pcm_stream_str(substream));
 	runtime->hw = (stream_id == SNDRV_PCM_STREAM_PLAYBACK) ?

commit 046e7d685bc370fd4c879ab6635ad3f69e6673d1
Merge: fe504c5c745a 6eb827d23577
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 11:51:23 2012 -0800

    Merge tag 'sound-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This update contains a fairly wide range of changes all over in sound
      subdirectory, mainly because of UAPI header moves by David and __dev*
      annotation removals by Bill.  Other highlights are:
    
       - Introduced the support for wallclock timestamps in ALSA PCM core
    
       - Add the poll loop implementation for HD-audio jack detection
    
       - Yet more VGA-switcheroo fixes for HD-audio
    
       - New VIA HD-audio codec support
    
       - More fixes on resource management in USB audio and MIDI drivers
    
       - More quirks for USB-audio ASUS Xonar U3, Reloop Play, Focusrite,
         Roland VG-99, etc
    
       - Add support for FastTrack C400 usb-audio
    
       - Clean ups in many drivers regarding firmware loading
    
       - Add PSC724 Ultiimate Edge support to ice1712
    
       - A few hdspm driver updates
    
       - New Stanton SCS.1d/1m FireWire driver
    
       - Standardisation of the logging in ASoC codes
    
       - DT and dmaengine support for ASoC Atmel
    
       - Support for Wolfson ADSP cores
    
       - New drivers for Freescale/iVeia P1022 and Maxim MAX98090
    
       - Lots of other ASoC driver fixes and developments"
    
    Fix up trivial conflicts.  And go out on a limb and assume the dts file
    'status' field of one of the conflicting things was supposed to be
    "disabled", not "disable" like in pretty much all other cases.
    
    * tag 'sound-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (341 commits)
      ALSA: hda - Move runtime PM check to runtime_idle callback
      ALSA: hda - Add stereo-dmic fixup for Acer Aspire One 522
      ALSA: hda - Avoid doubly suspend after vga switcheroo
      ALSA: usb-audio: Enable S/PDIF on the ASUS Xonar U3
      ALSA: hda - Check validity of CORB/RIRB WP reads
      ALSA: hda - use usleep_range in link reset and change timeout check
      ALSA: HDA: VIA: Add support for codec VT1808.
      ALSA: HDA: VIA Add support for codec VT1705CF.
      ASoC: codecs: remove __dev* attributes
      ASoC: utils: remove __dev* attributes
      ASoC: ux500: remove __dev* attributes
      ASoC: txx9: remove __dev* attributes
      ASoC: tegra: remove __dev* attributes
      ASoC: spear: remove __dev* attributes
      ASoC: sh: remove __dev* attributes
      ASoC: s6000: remove __dev* attributes
      ASoC: OMAP: remove __dev* attributes
      ASoC: nuc900: remove __dev* attributes
      ASoC: mxs: remove __dev* attributes
      ASoC: kirkwood: remove __dev* attributes
      ...

commit da794876f27c48ba67a6b3295ded27bbd81ba7e4
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Dec 7 09:26:35 2012 -0500

    ASoC: ux500: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 894c9f4bb9f6..c6821a5ab0fb 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -282,7 +282,7 @@ static struct snd_soc_platform_driver ux500_pcm_soc_drv = {
 	.pcm_new        = ux500_pcm_new,
 };
 
-int __devinit ux500_pcm_register_platform(struct platform_device *pdev)
+int ux500_pcm_register_platform(struct platform_device *pdev)
 {
 	int ret;
 
@@ -298,7 +298,7 @@ int __devinit ux500_pcm_register_platform(struct platform_device *pdev)
 }
 EXPORT_SYMBOL_GPL(ux500_pcm_register_platform);
 
-int __devexit ux500_pcm_unregister_platform(struct platform_device *pdev)
+int ux500_pcm_unregister_platform(struct platform_device *pdev)
 {
 	snd_soc_unregister_platform(&pdev->dev);
 

commit 1428c20f7c38e9fbf59923d1b9615ebdaf2862b7
Author: Lee Jones <lee.jones@linaro.org>
Date:   Fri Nov 23 13:05:41 2012 +0000

    ASoC: Ux500: Initialise PCM from MSP probe rather than as a device
    
    The PCM is a pseudo-device. It doesn't have any of it's own registers
    or hardware. It rather acts as a layer of abstraction for DMA
    transfers. Hence, instead of classifying it as a device in its own
    right, we call the initialisation from the MSP driver.
    
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Ola LILJA2 <ola.o.lilja@stericsson.com>
    Cc: alsa-devel@alsa-project.org
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 1a04e248453c..894c9f4bb9f6 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -282,7 +282,7 @@ static struct snd_soc_platform_driver ux500_pcm_soc_drv = {
 	.pcm_new        = ux500_pcm_new,
 };
 
-static int __devexit ux500_pcm_drv_probe(struct platform_device *pdev)
+int __devinit ux500_pcm_register_platform(struct platform_device *pdev)
 {
 	int ret;
 
@@ -296,23 +296,12 @@ static int __devexit ux500_pcm_drv_probe(struct platform_device *pdev)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ux500_pcm_register_platform);
 
-static int __devinit ux500_pcm_drv_remove(struct platform_device *pdev)
+int __devexit ux500_pcm_unregister_platform(struct platform_device *pdev)
 {
 	snd_soc_unregister_platform(&pdev->dev);
 
 	return 0;
 }
-
-static struct platform_driver ux500_pcm_driver = {
-	.driver = {
-		.name = "ux500-pcm",
-		.owner = THIS_MODULE,
-	},
-
-	.probe = ux500_pcm_drv_probe,
-	.remove = __devexit_p(ux500_pcm_drv_remove),
-};
-module_platform_driver(ux500_pcm_driver);
-
-MODULE_LICENSE("GPL v2");
+EXPORT_SYMBOL_GPL(ux500_pcm_unregister_platform);

commit 865fab601b8f910b2c634cf4c9211176f2c71cad
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Oct 18 14:20:16 2012 +0200

    ARM: plat-nomadik: move DMA40 header to <linux/platform_data>
    
    This moves the DMA40 platform data header from <plat/ste_dma40.h>
    to <linux/platform_data/dma-ste-dma40.h> where is belongs.
    
    Cc: Dan Williams <djbw@fb.com>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Ola Lilja <ola.o.lilja@stericsson.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Andreas Westin <andreas.westin@stericsson.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 1a04e248453c..b55b79f7536c 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -18,8 +18,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/dmaengine.h>
 #include <linux/slab.h>
-
-#include <plat/ste_dma40.h>
+#include <linux/platform_data/dma-ste-dma40.h>
 
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>

commit 9883ab229d61b884323f9186b1bd4a41373a491b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 11 20:11:41 2012 +0200

    ASoC: dmaengine-pcm: Rename and deprecate snd_dmaengine_pcm_pointer
    
    Currently the sound dmaengine pcm helper functions implement the pcm_pointer
    callback by trying to count the number of elapsed periods. This is done by
    advancing the stream position in the dmaengine callback by one period.
    Unfortunately there is no guarantee that the callback will be called for each
    elapsed period. It may be possible that under high system load it is only called
    once for multiple elapsed periods. This patch renames the current implementation
    and documents its shortcomings and that it should not be used anymore in new
    drivers.
    
    The next patch will introduce a new snd_dmaengine_pcm_pointer which will be
    implemented based on querying the current stream position from the dma device.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by Vinod Koul <vinod.koul@linux.intel.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 97d8e4de29c2..1a04e248453c 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -261,7 +261,7 @@ static struct snd_pcm_ops ux500_pcm_ops = {
 	.hw_params	= ux500_pcm_hw_params,
 	.hw_free	= ux500_pcm_hw_free,
 	.trigger	= snd_dmaengine_pcm_trigger,
-	.pointer	= snd_dmaengine_pcm_pointer,
+	.pointer	= snd_dmaengine_pcm_pointer_no_residue,
 	.mmap		= ux500_pcm_mmap
 };
 

commit 85f243912b99b053ce0624c30609f5d8fd4445d2
Author: Ola Lilja <ola.o.lilja@stericsson.com>
Date:   Wed Jun 13 10:09:51 2012 +0200

    ASoC: Ux500: Correct license strings
    
    GPLv2 -> GPL v2
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Ola Lilja <ola.o.lilja@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
index 66b080e5de96..97d8e4de29c2 100644
--- a/sound/soc/ux500/ux500_pcm.c
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -315,4 +315,4 @@ static struct platform_driver ux500_pcm_driver = {
 };
 module_platform_driver(ux500_pcm_driver);
 
-MODULE_LICENSE("GPLv2");
+MODULE_LICENSE("GPL v2");

commit 01a0c1139c2bd075d005253093e7060022c5d0cb
Author: Ola Lilja <ola.o.lilja@stericsson.com>
Date:   Thu May 24 15:26:32 2012 +0200

    ASoC: Ux500: Add platform-driver
    
    Add platform-driver handling all DMA-activities.
    
    Signed-off-by: Ola Lilja <ola.o.lilja@stericsson.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/ux500/ux500_pcm.c b/sound/soc/ux500/ux500_pcm.c
new file mode 100644
index 000000000000..66b080e5de96
--- /dev/null
+++ b/sound/soc/ux500/ux500_pcm.c
@@ -0,0 +1,318 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2012
+ *
+ * Author: Ola Lilja <ola.o.lilja@stericsson.com>,
+ *         Roger Nilsson <roger.xr.nilsson@stericsson.com>
+ *         for ST-Ericsson.
+ *
+ * License terms:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <asm/page.h>
+
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/slab.h>
+
+#include <plat/ste_dma40.h>
+
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "ux500_msp_i2s.h"
+#include "ux500_pcm.h"
+
+static struct snd_pcm_hardware ux500_pcm_hw_playback = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_RESUME |
+		SNDRV_PCM_INFO_PAUSE,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE |
+		SNDRV_PCM_FMTBIT_U16_LE |
+		SNDRV_PCM_FMTBIT_S16_BE |
+		SNDRV_PCM_FMTBIT_U16_BE,
+	.rates = SNDRV_PCM_RATE_KNOT,
+	.rate_min = UX500_PLATFORM_MIN_RATE_PLAYBACK,
+	.rate_max = UX500_PLATFORM_MAX_RATE_PLAYBACK,
+	.channels_min = UX500_PLATFORM_MIN_CHANNELS,
+	.channels_max = UX500_PLATFORM_MAX_CHANNELS,
+	.buffer_bytes_max = UX500_PLATFORM_BUFFER_BYTES_MAX,
+	.period_bytes_min = UX500_PLATFORM_PERIODS_BYTES_MIN,
+	.period_bytes_max = UX500_PLATFORM_PERIODS_BYTES_MAX,
+	.periods_min = UX500_PLATFORM_PERIODS_MIN,
+	.periods_max = UX500_PLATFORM_PERIODS_MAX,
+};
+
+static struct snd_pcm_hardware ux500_pcm_hw_capture = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_RESUME |
+		SNDRV_PCM_INFO_PAUSE,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE |
+		SNDRV_PCM_FMTBIT_U16_LE |
+		SNDRV_PCM_FMTBIT_S16_BE |
+		SNDRV_PCM_FMTBIT_U16_BE,
+	.rates = SNDRV_PCM_RATE_KNOT,
+	.rate_min = UX500_PLATFORM_MIN_RATE_CAPTURE,
+	.rate_max = UX500_PLATFORM_MAX_RATE_CAPTURE,
+	.channels_min = UX500_PLATFORM_MIN_CHANNELS,
+	.channels_max = UX500_PLATFORM_MAX_CHANNELS,
+	.buffer_bytes_max = UX500_PLATFORM_BUFFER_BYTES_MAX,
+	.period_bytes_min = UX500_PLATFORM_PERIODS_BYTES_MIN,
+	.period_bytes_max = UX500_PLATFORM_PERIODS_BYTES_MAX,
+	.periods_min = UX500_PLATFORM_PERIODS_MIN,
+	.periods_max = UX500_PLATFORM_PERIODS_MAX,
+};
+
+static void ux500_pcm_dma_hw_free(struct device *dev,
+				struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dma_buffer *buf = runtime->dma_buffer_p;
+
+	if (runtime->dma_area == NULL)
+		return;
+
+	if (buf != &substream->dma_buffer) {
+		dma_free_coherent(buf->dev.dev, buf->bytes, buf->area,
+				buf->addr);
+		kfree(runtime->dma_buffer_p);
+	}
+
+	snd_pcm_set_runtime_buffer(substream, NULL);
+}
+
+static int ux500_pcm_open(struct snd_pcm_substream *substream)
+{
+	int stream_id = substream->pstr->stream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *dai = rtd->cpu_dai;
+	struct device *dev = dai->dev;
+	int ret;
+	struct ux500_msp_dma_params *dma_params;
+	u16 per_data_width, mem_data_width;
+	struct stedma40_chan_cfg *dma_cfg;
+
+	dev_dbg(dev, "%s: MSP %d (%s): Enter.\n", __func__, dai->id,
+		snd_pcm_stream_str(substream));
+
+	dev_dbg(dev, "%s: Set runtime hwparams.\n", __func__);
+	if (stream_id == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_set_runtime_hwparams(substream,
+					&ux500_pcm_hw_playback);
+	else
+		snd_soc_set_runtime_hwparams(substream,
+					&ux500_pcm_hw_capture);
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+		dev_err(dev, "%s: Error: snd_pcm_hw_constraints failed (%d)\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_dbg(dev, "%s: Set hw-struct for %s.\n", __func__,
+		snd_pcm_stream_str(substream));
+	runtime->hw = (stream_id == SNDRV_PCM_STREAM_PLAYBACK) ?
+		ux500_pcm_hw_playback : ux500_pcm_hw_capture;
+
+	mem_data_width = STEDMA40_HALFWORD_WIDTH;
+
+	dma_params = snd_soc_dai_get_dma_data(dai, substream);
+	switch (dma_params->data_size) {
+	case 32:
+		per_data_width = STEDMA40_WORD_WIDTH;
+		break;
+	case 16:
+		per_data_width = STEDMA40_HALFWORD_WIDTH;
+		break;
+	case 8:
+		per_data_width = STEDMA40_BYTE_WIDTH;
+		break;
+	default:
+		per_data_width = STEDMA40_WORD_WIDTH;
+		dev_warn(rtd->platform->dev,
+			"%s: Unknown data-size (%d)! Assuming 32 bits.\n",
+			__func__, dma_params->data_size);
+	}
+
+	dma_cfg = dma_params->dma_cfg;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dma_cfg->src_info.data_width = mem_data_width;
+		dma_cfg->dst_info.data_width = per_data_width;
+	} else {
+		dma_cfg->src_info.data_width = per_data_width;
+		dma_cfg->dst_info.data_width = mem_data_width;
+	}
+
+
+	ret = snd_dmaengine_pcm_open(substream, stedma40_filter, dma_cfg);
+	if (ret) {
+		dev_dbg(dai->dev,
+			"%s: ERROR: snd_dmaengine_pcm_open failed (%d)!\n",
+			__func__, ret);
+		return ret;
+	}
+
+	snd_dmaengine_pcm_set_data(substream, dma_cfg);
+
+	return 0;
+}
+
+static int ux500_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *dai = rtd->cpu_dai;
+
+	dev_dbg(dai->dev, "%s: Enter\n", __func__);
+
+	snd_dmaengine_pcm_close(substream);
+
+	return 0;
+}
+
+static int ux500_pcm_hw_params(struct snd_pcm_substream *substream,
+			struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dma_buffer *buf = runtime->dma_buffer_p;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int ret = 0;
+	int size;
+
+	dev_dbg(rtd->platform->dev, "%s: Enter\n", __func__);
+
+	size = params_buffer_bytes(hw_params);
+
+	if (buf) {
+		if (buf->bytes >= size)
+			goto out;
+		ux500_pcm_dma_hw_free(NULL, substream);
+	}
+
+	if (substream->dma_buffer.area != NULL &&
+		substream->dma_buffer.bytes >= size) {
+		buf = &substream->dma_buffer;
+	} else {
+		buf = kmalloc(sizeof(struct snd_dma_buffer), GFP_KERNEL);
+		if (!buf)
+			goto nomem;
+
+		buf->dev.type = SNDRV_DMA_TYPE_DEV;
+		buf->dev.dev = NULL;
+		buf->area = dma_alloc_coherent(NULL, size, &buf->addr,
+					GFP_KERNEL);
+		buf->bytes = size;
+		buf->private_data = NULL;
+
+		if (!buf->area)
+			goto free;
+	}
+	snd_pcm_set_runtime_buffer(substream, buf);
+	ret = 1;
+ out:
+	runtime->dma_bytes = size;
+	return ret;
+
+ free:
+	kfree(buf);
+ nomem:
+	return -ENOMEM;
+}
+
+static int ux500_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	dev_dbg(rtd->platform->dev, "%s: Enter\n", __func__);
+
+	ux500_pcm_dma_hw_free(NULL, substream);
+
+	return 0;
+}
+
+static int ux500_pcm_mmap(struct snd_pcm_substream *substream,
+			struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	dev_dbg(rtd->platform->dev, "%s: Enter.\n", __func__);
+
+	return dma_mmap_coherent(NULL, vma, runtime->dma_area,
+				runtime->dma_addr, runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops ux500_pcm_ops = {
+	.open		= ux500_pcm_open,
+	.close		= ux500_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= ux500_pcm_hw_params,
+	.hw_free	= ux500_pcm_hw_free,
+	.trigger	= snd_dmaengine_pcm_trigger,
+	.pointer	= snd_dmaengine_pcm_pointer,
+	.mmap		= ux500_pcm_mmap
+};
+
+int ux500_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_pcm *pcm = rtd->pcm;
+
+	dev_dbg(rtd->platform->dev, "%s: Enter (id = '%s').\n", __func__,
+		pcm->id);
+
+	pcm->info_flags = 0;
+
+	return 0;
+}
+
+static struct snd_soc_platform_driver ux500_pcm_soc_drv = {
+	.ops		= &ux500_pcm_ops,
+	.pcm_new        = ux500_pcm_new,
+};
+
+static int __devexit ux500_pcm_drv_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = snd_soc_register_platform(&pdev->dev, &ux500_pcm_soc_drv);
+	if (ret < 0) {
+		dev_err(&pdev->dev,
+			"%s: ERROR: Failed to register platform '%s' (%d)!\n",
+			__func__, pdev->name, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int __devinit ux500_pcm_drv_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+
+	return 0;
+}
+
+static struct platform_driver ux500_pcm_driver = {
+	.driver = {
+		.name = "ux500-pcm",
+		.owner = THIS_MODULE,
+	},
+
+	.probe = ux500_pcm_drv_probe,
+	.remove = __devexit_p(ux500_pcm_drv_remove),
+};
+module_platform_driver(ux500_pcm_driver);
+
+MODULE_LICENSE("GPLv2");
