commit 1a8f0a3c13c136951de7ea24ccb148e745db98a2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 2 06:26:27 2018 +0000

    ASoC: ac97: convert to SPDX identifiers
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index 3f424f214bca..c086786e4471 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -1,20 +1,15 @@
-/*
- * soc-ac97.c  --  ALSA SoC Audio Layer AC97 support
- *
- * Copyright 2005 Wolfson Microelectronics PLC.
- * Copyright 2005 Openedhand Ltd.
- * Copyright (C) 2010 Slimlogic Ltd.
- * Copyright (C) 2010 Texas Instruments Inc.
- *
- * Author: Liam Girdwood <lrg@slimlogic.co.uk>
- *         with code, comments and ideas from :-
- *         Richard Purdie <richard@openedhand.com>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- */
+// SPDX-License-Identifier: GPL-2.0+
+//
+// soc-ac97.c  --  ALSA SoC Audio Layer AC97 support
+//
+// Copyright 2005 Wolfson Microelectronics PLC.
+// Copyright 2005 Openedhand Ltd.
+// Copyright (C) 2010 Slimlogic Ltd.
+// Copyright (C) 2010 Texas Instruments Inc.
+//
+// Author: Liam Girdwood <lrg@slimlogic.co.uk>
+//         with code, comments and ideas from :-
+//         Richard Purdie <richard@openedhand.com>
 
 #include <linux/ctype.h>
 #include <linux/delay.h>

commit c95869e5c04fb0000370e7310dc892b417b8128a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 29 02:58:25 2018 +0000

    ASoC: ac97: replace codec to component
    
    Now we can replace Codec to Component. Let's do it.
    
    Note:
            xxx_codec_xxx()         ->      xxx_component_xxx()
            .idle_bias_off = 0      ->      .idle_bias_on = 1
            .ignore_pmdown_time = 0 ->      .use_pmdown_time = 1
            -                       ->      .endianness = 1
            -                       ->      .non_legacy_dai_naming = 1
    
    To keep compatibilty, this patch adds snd_soc_xxx_ac97_codec()
    macro. These will be removed when all codec code was removed.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index 36dae41f65fc..3f424f214bca 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -44,7 +44,7 @@ struct snd_ac97_gpio_priv {
 	struct gpio_chip gpio_chip;
 #endif
 	unsigned int gpios_set;
-	struct snd_soc_codec *codec;
+	struct snd_soc_component *component;
 };
 
 static struct snd_ac97_bus soc_ac97_bus = {
@@ -57,11 +57,11 @@ static void soc_ac97_device_release(struct device *dev)
 }
 
 #ifdef CONFIG_GPIOLIB
-static inline struct snd_soc_codec *gpio_to_codec(struct gpio_chip *chip)
+static inline struct snd_soc_component *gpio_to_component(struct gpio_chip *chip)
 {
 	struct snd_ac97_gpio_priv *gpio_priv = gpiochip_get_data(chip);
 
-	return gpio_priv->codec;
+	return gpio_priv->component;
 }
 
 static int snd_soc_ac97_gpio_request(struct gpio_chip *chip, unsigned offset)
@@ -75,20 +75,22 @@ static int snd_soc_ac97_gpio_request(struct gpio_chip *chip, unsigned offset)
 static int snd_soc_ac97_gpio_direction_in(struct gpio_chip *chip,
 					  unsigned offset)
 {
-	struct snd_soc_codec *codec = gpio_to_codec(chip);
+	struct snd_soc_component *component = gpio_to_component(chip);
 
-	dev_dbg(codec->dev, "set gpio %d to output\n", offset);
-	return snd_soc_update_bits(codec, AC97_GPIO_CFG,
+	dev_dbg(component->dev, "set gpio %d to output\n", offset);
+	return snd_soc_component_update_bits(component, AC97_GPIO_CFG,
 				   1 << offset, 1 << offset);
 }
 
 static int snd_soc_ac97_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
-	struct snd_soc_codec *codec = gpio_to_codec(chip);
+	struct snd_soc_component *component = gpio_to_component(chip);
 	int ret;
 
-	ret = snd_soc_read(codec, AC97_GPIO_STATUS);
-	dev_dbg(codec->dev, "get gpio %d : %d\n", offset,
+	if (snd_soc_component_read(component, AC97_GPIO_STATUS, &ret) < 0)
+		ret = -1;
+
+	dev_dbg(component->dev, "get gpio %d : %d\n", offset,
 		ret < 0 ? ret : ret & (1 << offset));
 
 	return ret < 0 ? ret : !!(ret & (1 << offset));
@@ -98,22 +100,24 @@ static void snd_soc_ac97_gpio_set(struct gpio_chip *chip, unsigned offset,
 				  int value)
 {
 	struct snd_ac97_gpio_priv *gpio_priv = gpiochip_get_data(chip);
-	struct snd_soc_codec *codec = gpio_to_codec(chip);
+	struct snd_soc_component *component = gpio_to_component(chip);
 
 	gpio_priv->gpios_set &= ~(1 << offset);
 	gpio_priv->gpios_set |= (!!value) << offset;
-	snd_soc_write(codec, AC97_GPIO_STATUS, gpio_priv->gpios_set);
-	dev_dbg(codec->dev, "set gpio %d to %d\n", offset, !!value);
+	snd_soc_component_write(component, AC97_GPIO_STATUS,
+				gpio_priv->gpios_set);
+	dev_dbg(component->dev, "set gpio %d to %d\n", offset, !!value);
 }
 
 static int snd_soc_ac97_gpio_direction_out(struct gpio_chip *chip,
 				     unsigned offset, int value)
 {
-	struct snd_soc_codec *codec = gpio_to_codec(chip);
+	struct snd_soc_component *component = gpio_to_component(chip);
 
-	dev_dbg(codec->dev, "set gpio %d to output\n", offset);
+	dev_dbg(component->dev, "set gpio %d to output\n", offset);
 	snd_soc_ac97_gpio_set(chip, offset, value);
-	return snd_soc_update_bits(codec, AC97_GPIO_CFG, 1 << offset, 0);
+	return snd_soc_component_update_bits(component, AC97_GPIO_CFG,
+					     1 << offset, 0);
 }
 
 static const struct gpio_chip snd_soc_ac97_gpio_chip = {
@@ -128,24 +132,24 @@ static const struct gpio_chip snd_soc_ac97_gpio_chip = {
 };
 
 static int snd_soc_ac97_init_gpio(struct snd_ac97 *ac97,
-				  struct snd_soc_codec *codec)
+				  struct snd_soc_component *component)
 {
 	struct snd_ac97_gpio_priv *gpio_priv;
 	int ret;
 
-	gpio_priv = devm_kzalloc(codec->dev, sizeof(*gpio_priv), GFP_KERNEL);
+	gpio_priv = devm_kzalloc(component->dev, sizeof(*gpio_priv), GFP_KERNEL);
 	if (!gpio_priv)
 		return -ENOMEM;
 	ac97->gpio_priv = gpio_priv;
-	gpio_priv->codec = codec;
+	gpio_priv->component = component;
 	gpio_priv->gpio_chip = snd_soc_ac97_gpio_chip;
 	gpio_priv->gpio_chip.ngpio = AC97_NUM_GPIOS;
-	gpio_priv->gpio_chip.parent = codec->dev;
+	gpio_priv->gpio_chip.parent = component->dev;
 	gpio_priv->gpio_chip.base = -1;
 
 	ret = gpiochip_add_data(&gpio_priv->gpio_chip, gpio_priv);
 	if (ret != 0)
-		dev_err(codec->dev, "Failed to add GPIOs: %d\n", ret);
+		dev_err(component->dev, "Failed to add GPIOs: %d\n", ret);
 	return ret;
 }
 
@@ -155,7 +159,7 @@ static void snd_soc_ac97_free_gpio(struct snd_ac97 *ac97)
 }
 #else
 static int snd_soc_ac97_init_gpio(struct snd_ac97 *ac97,
-				  struct snd_soc_codec *codec)
+				  struct snd_soc_component *component)
 {
 	return 0;
 }
@@ -166,8 +170,8 @@ static void snd_soc_ac97_free_gpio(struct snd_ac97 *ac97)
 #endif
 
 /**
- * snd_soc_alloc_ac97_codec() - Allocate new a AC'97 device
- * @codec: The CODEC for which to create the AC'97 device
+ * snd_soc_alloc_ac97_component() - Allocate new a AC'97 device
+ * @component: The COMPONENT for which to create the AC'97 device
  *
  * Allocated a new snd_ac97 device and intializes it, but does not yet register
  * it. The caller is responsible to either call device_add(&ac97->dev) to
@@ -175,7 +179,7 @@ static void snd_soc_ac97_free_gpio(struct snd_ac97 *ac97)
  *
  * Returns: A snd_ac97 device or a PTR_ERR in case of an error.
  */
-struct snd_ac97 *snd_soc_alloc_ac97_codec(struct snd_soc_codec *codec)
+struct snd_ac97 *snd_soc_alloc_ac97_component(struct snd_soc_component *component)
 {
 	struct snd_ac97 *ac97;
 
@@ -187,26 +191,26 @@ struct snd_ac97 *snd_soc_alloc_ac97_codec(struct snd_soc_codec *codec)
 	ac97->num = 0;
 
 	ac97->dev.bus = &ac97_bus_type;
-	ac97->dev.parent = codec->component.card->dev;
+	ac97->dev.parent = component->card->dev;
 	ac97->dev.release = soc_ac97_device_release;
 
 	dev_set_name(&ac97->dev, "%d-%d:%s",
-		     codec->component.card->snd_card->number, 0,
-		     codec->component.name);
+		     component->card->snd_card->number, 0,
+		     component->name);
 
 	device_initialize(&ac97->dev);
 
 	return ac97;
 }
-EXPORT_SYMBOL(snd_soc_alloc_ac97_codec);
+EXPORT_SYMBOL(snd_soc_alloc_ac97_component);
 
 /**
- * snd_soc_new_ac97_codec - initailise AC97 device
- * @codec: audio codec
+ * snd_soc_new_ac97_component - initailise AC97 device
+ * @component: audio component
  * @id: The expected device ID
  * @id_mask: Mask that is applied to the device ID before comparing with @id
  *
- * Initialises AC97 codec resources for use by ad-hoc devices only.
+ * Initialises AC97 component resources for use by ad-hoc devices only.
  *
  * If @id is not 0 this function will reset the device, then read the ID from
  * the device and check if it matches the expected ID. If it doesn't match an
@@ -214,20 +218,20 @@ EXPORT_SYMBOL(snd_soc_alloc_ac97_codec);
  *
  * Returns: A PTR_ERR() on failure or a valid snd_ac97 struct on success.
  */
-struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+struct snd_ac97 *snd_soc_new_ac97_component(struct snd_soc_component *component,
 	unsigned int id, unsigned int id_mask)
 {
 	struct snd_ac97 *ac97;
 	int ret;
 
-	ac97 = snd_soc_alloc_ac97_codec(codec);
+	ac97 = snd_soc_alloc_ac97_component(component);
 	if (IS_ERR(ac97))
 		return ac97;
 
 	if (id) {
 		ret = snd_ac97_reset(ac97, false, id, id_mask);
 		if (ret < 0) {
-			dev_err(codec->dev, "Failed to reset AC97 device: %d\n",
+			dev_err(component->dev, "Failed to reset AC97 device: %d\n",
 				ret);
 			goto err_put_device;
 		}
@@ -237,7 +241,7 @@ struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 	if (ret)
 		goto err_put_device;
 
-	ret = snd_soc_ac97_init_gpio(ac97, codec);
+	ret = snd_soc_ac97_init_gpio(ac97, component);
 	if (ret)
 		goto err_put_device;
 
@@ -247,22 +251,22 @@ struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 	put_device(&ac97->dev);
 	return ERR_PTR(ret);
 }
-EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
+EXPORT_SYMBOL_GPL(snd_soc_new_ac97_component);
 
 /**
- * snd_soc_free_ac97_codec - free AC97 codec device
+ * snd_soc_free_ac97_component - free AC97 component device
  * @ac97: snd_ac97 device to be freed
  *
- * Frees AC97 codec device resources.
+ * Frees AC97 component device resources.
  */
-void snd_soc_free_ac97_codec(struct snd_ac97 *ac97)
+void snd_soc_free_ac97_component(struct snd_ac97 *ac97)
 {
 	snd_soc_ac97_free_gpio(ac97);
 	device_del(&ac97->dev);
 	ac97->bus = NULL;
 	put_device(&ac97->dev);
 }
-EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
+EXPORT_SYMBOL_GPL(snd_soc_free_ac97_component);
 
 static struct snd_ac97_reset_cfg snd_ac97_rst_cfg;
 

commit 8abab35f9a58e15b1f90a1371da69a207e40fc3b
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Jan 12 11:38:15 2017 +0000

    ASoC: Fixup some small kernel-doc typos
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index 6c8b0b0c56ec..36dae41f65fc 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -251,7 +251,7 @@ EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
 
 /**
  * snd_soc_free_ac97_codec - free AC97 codec device
- * @codec: audio codec
+ * @ac97: snd_ac97 device to be freed
  *
  * Frees AC97 codec device resources.
  */

commit 52abe54138d9b14b4a0a17742a53d2411bc5b167
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Sep 11 14:14:41 2016 +0200

    ASoC: ac97: constify gpio_chip structures
    
    These structures are only used to copy into other structures, so declare
    them as const.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct gpio_chip i@p = { ... };
    
    @ok@
    identifier r.i;
    expression e;
    position p;
    @@
    e = i@p;
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.i;
    struct gpio_chip e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct gpio_chip i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index bc4a55bb3fd9..6c8b0b0c56ec 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -116,7 +116,7 @@ static int snd_soc_ac97_gpio_direction_out(struct gpio_chip *chip,
 	return snd_soc_update_bits(codec, AC97_GPIO_CFG, 1 << offset, 0);
 }
 
-static struct gpio_chip snd_soc_ac97_gpio_chip = {
+static const struct gpio_chip snd_soc_ac97_gpio_chip = {
 	.label			= "snd_soc_ac97",
 	.owner			= THIS_MODULE,
 	.request		= snd_soc_ac97_gpio_request,

commit f7cb5120c4e0de10c3e069f5318417da0326fb45
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 8 23:48:29 2015 +0100

    ASoC: ac97: use gpiochip data pointer
    
    This makes the driver use the data pointer added to the gpio_chip
    to store a pointer to the state container instead of relying on
    container_of().
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: alsa-devel@alsa-project.org
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index 7e0acd83b0e6..bc4a55bb3fd9 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -59,8 +59,7 @@ static void soc_ac97_device_release(struct device *dev)
 #ifdef CONFIG_GPIOLIB
 static inline struct snd_soc_codec *gpio_to_codec(struct gpio_chip *chip)
 {
-	struct snd_ac97_gpio_priv *gpio_priv =
-		container_of(chip, struct snd_ac97_gpio_priv, gpio_chip);
+	struct snd_ac97_gpio_priv *gpio_priv = gpiochip_get_data(chip);
 
 	return gpio_priv->codec;
 }
@@ -98,8 +97,7 @@ static int snd_soc_ac97_gpio_get(struct gpio_chip *chip, unsigned offset)
 static void snd_soc_ac97_gpio_set(struct gpio_chip *chip, unsigned offset,
 				  int value)
 {
-	struct snd_ac97_gpio_priv *gpio_priv =
-		container_of(chip, struct snd_ac97_gpio_priv, gpio_chip);
+	struct snd_ac97_gpio_priv *gpio_priv = gpiochip_get_data(chip);
 	struct snd_soc_codec *codec = gpio_to_codec(chip);
 
 	gpio_priv->gpios_set &= ~(1 << offset);
@@ -145,7 +143,7 @@ static int snd_soc_ac97_init_gpio(struct snd_ac97 *ac97,
 	gpio_priv->gpio_chip.parent = codec->dev;
 	gpio_priv->gpio_chip.base = -1;
 
-	ret = gpiochip_add(&gpio_priv->gpio_chip);
+	ret = gpiochip_add_data(&gpio_priv->gpio_chip, gpio_priv);
 	if (ret != 0)
 		dev_err(codec->dev, "Failed to add GPIOs: %d\n", ret);
 	return ret;

commit 58cf279acac3080ce03eeea5ca268210b3165fe1
Merge: 6606b342febf c474e348778b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 17 12:32:01 2016 -0800

    Merge tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "Here is the bulk of GPIO changes for v4.5.
    
      Notably there are big refactorings mostly by myself, aimed at getting
      the gpio_chip into a shape that makes me believe I can proceed to
      preserve state for a proper userspace ABI (character device) that has
      already been proposed once, but resulted in the feedback that I need
      to go back and restructure stuff.  So I've been restructuring stuff.
      On the way I ran into brokenness (return code from the get_value()
      callback) and had to fix it.  Also, refactored generic GPIO to be
      simpler.
    
      Some of that is still waiting to trickle down from the subsystems all
      over the kernel that provide random gpio_chips, I've touched every
      single GPIO driver in the kernel now, oh man I didn't know I was
      responsible for so much...
    
      Apart from that we're churning along as usual.
    
      I took some effort to test and retest so it should merge nicely and we
      shook out a couple of bugs in -next.
    
      Infrastructural changes:
    
       - In struct gpio_chip, rename the .dev node to .parent to better
         reflect the fact that this is not the GPIO struct device
         abstraction.  We will add that soon so this would be totallt
         confusing.
    
       - It was noted that the driver .get_value() callbacks was sometimes
         reporting negative -ERR values to the gpiolib core, expecting them
         to be propagated to consumer gpiod_get_value() and gpio_get_value()
         calls.  This was not happening, so as there was a mess of drivers
         returning negative errors and some returning "anything else than
         zero" to indicate that a line was active.  As some would have bit
         31 set to indicate "line active" it clashed with negative error
         codes.  This is fixed by the largeish series clamping values in all
         drivers with !!value to [0,1] and then augmenting the code to
         propagate error codes to consumers.  (Includes some ACKed patches
         in other subsystems.)
    
       - Add a void *data pointer to struct gpio_chip.  The container_of()
         design pattern is indeed very nice, but we want to reform the
         struct gpio_chip to be a non-volative, stateless business, and keep
         states internal to the gpiolib to be able to hold on to the state
         when adding a proper userspace ABI (character device) further down
         the road.  To achieve this, drivers need a handle at the internal
         state that is not dependent on their struct gpio_chip() so we add
         gpiochip_add_data() and gpiochip_get_data() following the pattern
         of many other subsystems.  All the "use gpiochip data pointer"
         patches transforms drivers to this scheme.
    
       - The Generic GPIO chip header has been merged into the general
         <linux/gpio/driver.h> header, and the custom header for that
         removed.  Instead of having a separate mm_gpio_chip struct for
         these generic drivers, merge that into struct gpio_chip,
         simplifying the code and removing the need for separate and
         confusing includes.
    
      Misc improvements:
    
       - Stabilize the way GPIOs are looked up from the ACPI legacy
         specification.
    
       - Incremental driver features for PXA, PCA953X, Lantiq (patches from
         the OpenWRT community), RCAR, Zynq, PL061, 104-idi-48
    
      New drivers:
    
       - Add a GPIO chip to the ALSA SoC AC97 driver.
    
       - Add a new Broadcom NSP SoC driver (this lands in the pinctrl dir,
         but the branch is merged here too to account for infrastructural
         changes).
    
       - The sx150x driver now supports the sx1502"
    
    * tag 'gpio-v4.5-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (220 commits)
      gpio: generic: make bgpio_pdata always visible
      gpiolib: fix chip order in gpio list
      gpio: mpc8xxx: Do not use gpiochip_get_data() in mpc8xxx_gpio_save_regs()
      gpio: mm-lantiq: Do not use gpiochip_get_data() in ltq_mm_save_regs()
      gpio: brcmstb: Allow building driver for BMIPS_GENERIC
      gpio: brcmstb: Set endian flags for big-endian MIPS
      gpio: moxart: fix build regression
      gpio: xilinx: Do not use gpiochip_get_data() in xgpio_save_regs()
      leds: pca9532: use gpiochip data pointer
      leds: tca6507: use gpiochip data pointer
      hid: cp2112: use gpiochip data pointer
      bcma: gpio: use gpiochip data pointer
      avr32: gpio: use gpiochip data pointer
      video: fbdev: via: use gpiochip data pointer
      gpio: pch: Optimize pch_gpio_get()
      Revert "pinctrl: lantiq: Implement gpio_chip.to_irq"
      pinctrl: nsp-gpio: use gpiochip data pointer
      pinctrl: vt8500-wmt: use gpiochip data pointer
      pinctrl: exynos5440: use gpiochip data pointer
      pinctrl: at91-pio4: use gpiochip data pointer
      ...

commit 34015f5e56c71bbdcf7189430ffb63ea67656a35
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 22 15:51:39 2015 +0100

    ASoC: ac97: Be sure to clamp return value
    
    As we want gpio_chip .get() calls to be able to return negative
    error codes and propagate to drivers, we need to go over all
    drivers and make sure their return values are clamped to [0,1].
    We do this by using the ret = !!(val) design pattern.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index ae563e379a72..733f5128eeff 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -92,7 +92,7 @@ static int snd_soc_ac97_gpio_get(struct gpio_chip *chip, unsigned offset)
 	dev_dbg(codec->dev, "get gpio %d : %d\n", offset,
 		ret < 0 ? ret : ret & (1 << offset));
 
-	return ret < 0 ? ret : ret & (1 << offset);
+	return ret < 0 ? ret : !!(ret & (1 << offset));
 }
 
 static void snd_soc_ac97_gpio_set(struct gpio_chip *chip, unsigned offset,

commit a1eb9d5751220433998ae2e66216288161b1355b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Dec 7 13:32:28 2015 +0100

    ASoC: ac97: fix parent assignment
    
    Upstream GPIO has substituted .dev for .parent in struct gpio_chip.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index ae563e379a72..a2012652f212 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -142,7 +142,7 @@ static int snd_soc_ac97_init_gpio(struct snd_ac97 *ac97,
 	gpio_priv->codec = codec;
 	gpio_priv->gpio_chip = snd_soc_ac97_gpio_chip;
 	gpio_priv->gpio_chip.ngpio = AC97_NUM_GPIOS;
-	gpio_priv->gpio_chip.dev = codec->dev;
+	gpio_priv->gpio_chip.parent = codec->dev;
 	gpio_priv->gpio_chip.base = -1;
 
 	ret = gpiochip_add(&gpio_priv->gpio_chip);

commit 9bf5c3d11f1fbaf43399d189f05fb20ceb46ee5d
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Wed Nov 11 13:12:51 2015 +0100

    ASoC: ac97: add gpio chip
    
    The AC97 specification provides a guide for 16 GPIOs in the codecs. If
    the gpiolib is compiled in the kernel, declare a gpio chip.
    
    This was tested with a pxa27x board (mioa701) and a wm9713 codec.
    
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index d40efc9fe0a9..ae563e379a72 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -20,6 +20,7 @@
 #include <linux/delay.h>
 #include <linux/export.h>
 #include <linux/gpio.h>
+#include <linux/gpio/driver.h>
 #include <linux/init.h>
 #include <linux/of_gpio.h>
 #include <linux/of.h>
@@ -38,6 +39,14 @@ struct snd_ac97_reset_cfg {
 	int gpio_reset;
 };
 
+struct snd_ac97_gpio_priv {
+#ifdef CONFIG_GPIOLIB
+	struct gpio_chip gpio_chip;
+#endif
+	unsigned int gpios_set;
+	struct snd_soc_codec *codec;
+};
+
 static struct snd_ac97_bus soc_ac97_bus = {
 	.ops = NULL, /* Gets initialized in snd_soc_set_ac97_ops() */
 };
@@ -47,6 +56,117 @@ static void soc_ac97_device_release(struct device *dev)
 	kfree(to_ac97_t(dev));
 }
 
+#ifdef CONFIG_GPIOLIB
+static inline struct snd_soc_codec *gpio_to_codec(struct gpio_chip *chip)
+{
+	struct snd_ac97_gpio_priv *gpio_priv =
+		container_of(chip, struct snd_ac97_gpio_priv, gpio_chip);
+
+	return gpio_priv->codec;
+}
+
+static int snd_soc_ac97_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	if (offset >= AC97_NUM_GPIOS)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int snd_soc_ac97_gpio_direction_in(struct gpio_chip *chip,
+					  unsigned offset)
+{
+	struct snd_soc_codec *codec = gpio_to_codec(chip);
+
+	dev_dbg(codec->dev, "set gpio %d to output\n", offset);
+	return snd_soc_update_bits(codec, AC97_GPIO_CFG,
+				   1 << offset, 1 << offset);
+}
+
+static int snd_soc_ac97_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct snd_soc_codec *codec = gpio_to_codec(chip);
+	int ret;
+
+	ret = snd_soc_read(codec, AC97_GPIO_STATUS);
+	dev_dbg(codec->dev, "get gpio %d : %d\n", offset,
+		ret < 0 ? ret : ret & (1 << offset));
+
+	return ret < 0 ? ret : ret & (1 << offset);
+}
+
+static void snd_soc_ac97_gpio_set(struct gpio_chip *chip, unsigned offset,
+				  int value)
+{
+	struct snd_ac97_gpio_priv *gpio_priv =
+		container_of(chip, struct snd_ac97_gpio_priv, gpio_chip);
+	struct snd_soc_codec *codec = gpio_to_codec(chip);
+
+	gpio_priv->gpios_set &= ~(1 << offset);
+	gpio_priv->gpios_set |= (!!value) << offset;
+	snd_soc_write(codec, AC97_GPIO_STATUS, gpio_priv->gpios_set);
+	dev_dbg(codec->dev, "set gpio %d to %d\n", offset, !!value);
+}
+
+static int snd_soc_ac97_gpio_direction_out(struct gpio_chip *chip,
+				     unsigned offset, int value)
+{
+	struct snd_soc_codec *codec = gpio_to_codec(chip);
+
+	dev_dbg(codec->dev, "set gpio %d to output\n", offset);
+	snd_soc_ac97_gpio_set(chip, offset, value);
+	return snd_soc_update_bits(codec, AC97_GPIO_CFG, 1 << offset, 0);
+}
+
+static struct gpio_chip snd_soc_ac97_gpio_chip = {
+	.label			= "snd_soc_ac97",
+	.owner			= THIS_MODULE,
+	.request		= snd_soc_ac97_gpio_request,
+	.direction_input	= snd_soc_ac97_gpio_direction_in,
+	.get			= snd_soc_ac97_gpio_get,
+	.direction_output	= snd_soc_ac97_gpio_direction_out,
+	.set			= snd_soc_ac97_gpio_set,
+	.can_sleep		= 1,
+};
+
+static int snd_soc_ac97_init_gpio(struct snd_ac97 *ac97,
+				  struct snd_soc_codec *codec)
+{
+	struct snd_ac97_gpio_priv *gpio_priv;
+	int ret;
+
+	gpio_priv = devm_kzalloc(codec->dev, sizeof(*gpio_priv), GFP_KERNEL);
+	if (!gpio_priv)
+		return -ENOMEM;
+	ac97->gpio_priv = gpio_priv;
+	gpio_priv->codec = codec;
+	gpio_priv->gpio_chip = snd_soc_ac97_gpio_chip;
+	gpio_priv->gpio_chip.ngpio = AC97_NUM_GPIOS;
+	gpio_priv->gpio_chip.dev = codec->dev;
+	gpio_priv->gpio_chip.base = -1;
+
+	ret = gpiochip_add(&gpio_priv->gpio_chip);
+	if (ret != 0)
+		dev_err(codec->dev, "Failed to add GPIOs: %d\n", ret);
+	return ret;
+}
+
+static void snd_soc_ac97_free_gpio(struct snd_ac97 *ac97)
+{
+	gpiochip_remove(&ac97->gpio_priv->gpio_chip);
+}
+#else
+static int snd_soc_ac97_init_gpio(struct snd_ac97 *ac97,
+				  struct snd_soc_codec *codec)
+{
+	return 0;
+}
+
+static void snd_soc_ac97_free_gpio(struct snd_ac97 *ac97)
+{
+}
+#endif
+
 /**
  * snd_soc_alloc_ac97_codec() - Allocate new a AC'97 device
  * @codec: The CODEC for which to create the AC'97 device
@@ -119,6 +239,10 @@ struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 	if (ret)
 		goto err_put_device;
 
+	ret = snd_soc_ac97_init_gpio(ac97, codec);
+	if (ret)
+		goto err_put_device;
+
 	return ac97;
 
 err_put_device:
@@ -135,6 +259,7 @@ EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
  */
 void snd_soc_free_ac97_codec(struct snd_ac97 *ac97)
 {
+	snd_soc_ac97_free_gpio(ac97);
 	device_del(&ac97->dev);
 	ac97->bus = NULL;
 	put_device(&ac97->dev);

commit 7361fbeaeaab5282bbfc88f1f6fe4cf034f7623c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Jul 21 21:53:01 2015 +0200

    ASoC: ac97: Add support for resetting device before registration
    
    AC97 devices need to be initially reset before they can be used. Currently
    each driver does this on its own.
    
    Add support for resetting the device to core in snd_soc_new_ac97_codec().
    If the caller supplies a device ID and device ID mask the function will
    reset the device and verify that it has the correct ID, if it does not a
    error is returned.
    
    This will allow to remove custom code with similar functionality from
    individual drivers.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index 08d7259bbaab..d40efc9fe0a9 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -85,10 +85,19 @@ EXPORT_SYMBOL(snd_soc_alloc_ac97_codec);
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec
+ * @id: The expected device ID
+ * @id_mask: Mask that is applied to the device ID before comparing with @id
  *
  * Initialises AC97 codec resources for use by ad-hoc devices only.
+ *
+ * If @id is not 0 this function will reset the device, then read the ID from
+ * the device and check if it matches the expected ID. If it doesn't match an
+ * error will be returned and device will not be registered.
+ *
+ * Returns: A PTR_ERR() on failure or a valid snd_ac97 struct on success.
  */
-struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec)
+struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	unsigned int id, unsigned int id_mask)
 {
 	struct snd_ac97 *ac97;
 	int ret;
@@ -97,13 +106,24 @@ struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec)
 	if (IS_ERR(ac97))
 		return ac97;
 
-	ret = device_add(&ac97->dev);
-	if (ret) {
-		put_device(&ac97->dev);
-		return ERR_PTR(ret);
+	if (id) {
+		ret = snd_ac97_reset(ac97, false, id, id_mask);
+		if (ret < 0) {
+			dev_err(codec->dev, "Failed to reset AC97 device: %d\n",
+				ret);
+			goto err_put_device;
+		}
 	}
 
+	ret = device_add(&ac97->dev);
+	if (ret)
+		goto err_put_device;
+
 	return ac97;
+
+err_put_device:
+	put_device(&ac97->dev);
+	return ERR_PTR(ret);
 }
 EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
 

commit 47e039413cacee70229ebbf6de5a8e3b27e6f057
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 23 16:21:36 2015 +0100

    ASoC: Add support for allocating AC'97 device before registering it
    
    In some cases it is necessary to before additional operations after the
    device has been initialized and before the device is registered. This can
    for example be resetting the device.
    
    This patch introduces a new function snd_soc_alloc_ac97_codec() which is
    similar to snd_soc_new_ac97_codec() except that it does not register the
    device. Any users of snd_soc_alloc_ac97_codec() are responsible for calling
    device_add() manually.
    
    Fixes: 6794f709b712 ("ASoC: ac97: Drop delayed device registration")
    Reported-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Tested-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index 2e10e9a38376..08d7259bbaab 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -48,15 +48,18 @@ static void soc_ac97_device_release(struct device *dev)
 }
 
 /**
- * snd_soc_new_ac97_codec - initailise AC97 device
- * @codec: audio codec
+ * snd_soc_alloc_ac97_codec() - Allocate new a AC'97 device
+ * @codec: The CODEC for which to create the AC'97 device
  *
- * Initialises AC97 codec resources for use by ad-hoc devices only.
+ * Allocated a new snd_ac97 device and intializes it, but does not yet register
+ * it. The caller is responsible to either call device_add(&ac97->dev) to
+ * register the device, or to call put_device(&ac97->dev) to free the device.
+ *
+ * Returns: A snd_ac97 device or a PTR_ERR in case of an error.
  */
-struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec)
+struct snd_ac97 *snd_soc_alloc_ac97_codec(struct snd_soc_codec *codec)
 {
 	struct snd_ac97 *ac97;
-	int ret;
 
 	ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
 	if (ac97 == NULL)
@@ -73,7 +76,28 @@ struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec)
 		     codec->component.card->snd_card->number, 0,
 		     codec->component.name);
 
-	ret = device_register(&ac97->dev);
+	device_initialize(&ac97->dev);
+
+	return ac97;
+}
+EXPORT_SYMBOL(snd_soc_alloc_ac97_codec);
+
+/**
+ * snd_soc_new_ac97_codec - initailise AC97 device
+ * @codec: audio codec
+ *
+ * Initialises AC97 codec resources for use by ad-hoc devices only.
+ */
+struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec)
+{
+	struct snd_ac97 *ac97;
+	int ret;
+
+	ac97 = snd_soc_alloc_ac97_codec(codec);
+	if (IS_ERR(ac97))
+		return ac97;
+
+	ret = device_add(&ac97->dev);
 	if (ret) {
 		put_device(&ac97->dev);
 		return ERR_PTR(ret);

commit 358a8bb5628420529e4f0b77068155ca8fa8973b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:53 2014 +0100

    ASoC: ac97: Push snd_ac97 pointer to the driver level
    
    Now that the ASoC core no longer needs a handle to the AC'97 device that is
    associated with a CODEC we can remove it from the snd_soc_codec struct and
    push it into the individual driver state structs like we do for other
    communication buses. Doing so creates a clean separation between the AC'97
    bus support and the ASoC core.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index 920d76c43827..2e10e9a38376 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -53,30 +53,33 @@ static void soc_ac97_device_release(struct device *dev)
  *
  * Initialises AC97 codec resources for use by ad-hoc devices only.
  */
-int snd_soc_new_ac97_codec(struct snd_soc_codec *codec)
+struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec)
 {
+	struct snd_ac97 *ac97;
 	int ret;
 
-	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
-	if (codec->ac97 == NULL)
-		return -ENOMEM;
+	ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
+	if (ac97 == NULL)
+		return ERR_PTR(-ENOMEM);
 
-	codec->ac97->bus = &soc_ac97_bus;
-	codec->ac97->num = 0;
+	ac97->bus = &soc_ac97_bus;
+	ac97->num = 0;
 
-	codec->ac97->dev.bus = &ac97_bus_type;
-	codec->ac97->dev.parent = codec->component.card->dev;
-	codec->ac97->dev.release = soc_ac97_device_release;
+	ac97->dev.bus = &ac97_bus_type;
+	ac97->dev.parent = codec->component.card->dev;
+	ac97->dev.release = soc_ac97_device_release;
 
-	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
+	dev_set_name(&ac97->dev, "%d-%d:%s",
 		     codec->component.card->snd_card->number, 0,
 		     codec->component.name);
 
-	ret = device_register(&codec->ac97->dev);
-	if (ret)
-		put_device(&codec->ac97->dev);
+	ret = device_register(&ac97->dev);
+	if (ret) {
+		put_device(&ac97->dev);
+		return ERR_PTR(ret);
+	}
 
-	return ret;
+	return ac97;
 }
 EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
 
@@ -86,12 +89,11 @@ EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
  *
  * Frees AC97 codec device resources.
  */
-void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
+void snd_soc_free_ac97_codec(struct snd_ac97 *ac97)
 {
-	device_del(&codec->ac97->dev);
-	codec->ac97->bus = NULL;
-	put_device(&codec->ac97->dev);
-	codec->ac97 = NULL;
+	device_del(&ac97->dev);
+	ac97->bus = NULL;
+	put_device(&ac97->dev);
 }
 EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
 

commit 6794f709b7124ff1e574c4f4c9494418ab56c4b4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:50 2014 +0100

    ASoC: ac97: Drop delayed device registration
    
    We have all the information and dependencies we need to initialize and
    register the device available in snd_soc_new_ac97_codec(). So there is no
    need to delay the device registration until after the card itself as been
    registered.
    
    This makes the code significantly simpler and also makes it possible to use
    the AC'97 device in the CODECs probe function. The later will be required to
    be able to convert the AC'97 CODEC drivers to regmap.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index f2ed77b5169a..920d76c43827 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -42,80 +42,6 @@ static struct snd_ac97_bus soc_ac97_bus = {
 	.ops = NULL, /* Gets initialized in snd_soc_set_ac97_ops() */
 };
 
-/* register ac97 codec to bus */
-static int soc_register_ac97_codec(struct snd_soc_codec *codec,
-	struct snd_soc_dai *codec_dai)
-{
-	int ret;
-
-	/* Only instantiate AC97 if not already done by the adaptor
-	 * for the generic AC97 subsystem.
-	 */
-	if (!codec_dai->driver->ac97_control || codec->ac97_registered)
-		return 0;
-
-	/*
-	 * It is possible that the AC97 device is already registered to
-	 * the device subsystem. This happens when the device is created
-	 * via snd_ac97_mixer(). Currently only SoC codec that does so
-	 * is the generic AC97 glue but others migh emerge.
-	 *
-	 * In those cases we don't try to register the device again.
-	 */
-	if (!codec->ac97_created)
-		return 0;
-
-	codec->ac97->dev.bus = &ac97_bus_type;
-	codec->ac97->dev.parent = codec->component.card->dev;
-
-	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
-		     codec->component.card->snd_card->number, 0,
-		     codec->component.name);
-	ret = device_add(&codec->ac97->dev);
-	if (ret < 0) {
-		dev_err(codec->dev, "ASoC: AC97 device register failed: %d\n",
-			ret);
-		return ret;
-	}
-	codec->ac97_registered = 1;
-
-	return 0;
-}
-
-static void soc_unregister_ac97_codec(struct snd_soc_codec *codec)
-{
-	if (!codec->ac97_registered)
-		return;
-	device_del(&codec->ac97->dev);
-	codec->ac97_registered = 0;
-}
-
-static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
-{
-	int i, ret;
-
-	for (i = 0; i < rtd->num_codecs; i++) {
-		struct snd_soc_dai *codec_dai = rtd->codec_dais[i];
-
-		ret = soc_register_ac97_codec(codec_dai->codec, codec_dai);
-		if (ret) {
-			while (--i >= 0)
-				soc_unregister_ac97_codec(codec_dai->codec);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static void soc_unregister_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
-{
-	int i;
-
-	for (i = 0; i < rtd->num_codecs; i++)
-		soc_unregister_ac97_codec(rtd->codec_dais[i]->codec);
-}
-
 static void soc_ac97_device_release(struct device *dev)
 {
 	kfree(to_ac97_t(dev));
@@ -129,22 +55,28 @@ static void soc_ac97_device_release(struct device *dev)
  */
 int snd_soc_new_ac97_codec(struct snd_soc_codec *codec)
 {
+	int ret;
+
 	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
 	if (codec->ac97 == NULL)
 		return -ENOMEM;
 
 	codec->ac97->bus = &soc_ac97_bus;
 	codec->ac97->num = 0;
+
+	codec->ac97->dev.bus = &ac97_bus_type;
+	codec->ac97->dev.parent = codec->component.card->dev;
 	codec->ac97->dev.release = soc_ac97_device_release;
 
-	/*
-	 * Mark the AC97 device to be created by us. This way we ensure that the
-	 * device will be registered with the device subsystem later on.
-	 */
-	codec->ac97_created = 1;
-	device_initialize(&codec->ac97->dev);
+	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
+		     codec->component.card->snd_card->number, 0,
+		     codec->component.name);
+
+	ret = device_register(&codec->ac97->dev);
+	if (ret)
+		put_device(&codec->ac97->dev);
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
 
@@ -156,11 +88,10 @@ EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
  */
 void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 {
-	soc_unregister_ac97_codec(codec);
+	device_del(&codec->ac97->dev);
 	codec->ac97->bus = NULL;
 	put_device(&codec->ac97->dev);
 	codec->ac97 = NULL;
-	codec->ac97_created = 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
 
@@ -321,24 +252,3 @@ int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops_of_reset);
-
-int snd_soc_ac97_register_dai_links(struct snd_soc_card *card)
-{
-	int i;
-	int ret;
-
-	/* register any AC97 codecs */
-	for (i = 0; i < card->num_rtd; i++) {
-		ret = soc_register_ac97_dai_link(&card->rtd[i]);
-		if (ret < 0)
-			goto err;
-	}
-
-	return 0;
-err:
-	dev_err(card->dev,
-		"ASoC: failed to register AC97: %d\n", ret);
-	while (--i >= 0)
-		soc_unregister_ac97_dai_link(&card->rtd[i]);
-	return ret;
-}

commit ca005f324ee38308b319c693f40523d959027acf
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:49 2014 +0100

    ASoC: ac97: Drop support for setting platform data via the CPU DAI
    
    This has no users since commit f0fba2ad1b6b ("ASoC: multi-component - ASoC
    Multi-Component Support") which was almost 5 years ago. Given that this runs
    after CODEC probe functions have been run it also doesn't seem to be that
    useful.
    
    So drop it altogether to make the code simpler.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index b5d23c976662..f2ed77b5169a 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -342,15 +342,3 @@ int snd_soc_ac97_register_dai_links(struct snd_soc_card *card)
 		soc_unregister_ac97_dai_link(&card->rtd[i]);
 	return ret;
 }
-
-void snd_soc_ac97_add_pdata(struct snd_soc_pcm_runtime *rtd)
-{
-	unsigned int i;
-
-	/* add platform data for AC97 devices */
-	for (i = 0; i < rtd->num_codecs; i++) {
-		if (rtd->codec_dais[i]->driver->ac97_control)
-			snd_ac97_dev_add_pdata(rtd->codec_dais[i]->codec->ac97,
-					       rtd->cpu_dai->ac97_pdata);
-	}
-}

commit bdfd60e3c0affb914549f1d22e8aeef71e7828e6
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:48 2014 +0100

    ASoC: ac97: Merge soc_ac97_dev_{un,}register()/soc_{un,}register_ac97_codec()
    
    soc_{un,}register_ac97_codec() is just a simple wrapper around
    soc_ac97_dev_{un,}register(). There is no need to split these up into two
    different sets of functions.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index dbfca7e7dddb..b5d23c976662 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -42,18 +42,28 @@ static struct snd_ac97_bus soc_ac97_bus = {
 	.ops = NULL, /* Gets initialized in snd_soc_set_ac97_ops() */
 };
 
-/* unregister ac97 codec */
-static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
-{
-	if (codec->ac97->dev.bus)
-		device_del(&codec->ac97->dev);
-	return 0;
-}
-
 /* register ac97 codec to bus */
-static int soc_ac97_dev_register(struct snd_soc_codec *codec)
+static int soc_register_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_soc_dai *codec_dai)
 {
-	int err;
+	int ret;
+
+	/* Only instantiate AC97 if not already done by the adaptor
+	 * for the generic AC97 subsystem.
+	 */
+	if (!codec_dai->driver->ac97_control || codec->ac97_registered)
+		return 0;
+
+	/*
+	 * It is possible that the AC97 device is already registered to
+	 * the device subsystem. This happens when the device is created
+	 * via snd_ac97_mixer(). Currently only SoC codec that does so
+	 * is the generic AC97 glue but others migh emerge.
+	 *
+	 * In those cases we don't try to register the device again.
+	 */
+	if (!codec->ac97_created)
+		return 0;
 
 	codec->ac97->dev.bus = &ac97_bus_type;
 	codec->ac97->dev.parent = codec->component.card->dev;
@@ -61,53 +71,23 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
 		     codec->component.card->snd_card->number, 0,
 		     codec->component.name);
-	err = device_add(&codec->ac97->dev);
-	if (err < 0) {
-		dev_err(codec->dev, "ASoC: Can't register ac97 bus\n");
-		codec->ac97->dev.bus = NULL;
-		return err;
+	ret = device_add(&codec->ac97->dev);
+	if (ret < 0) {
+		dev_err(codec->dev, "ASoC: AC97 device register failed: %d\n",
+			ret);
+		return ret;
 	}
-	return 0;
-}
-
-static int soc_register_ac97_codec(struct snd_soc_codec *codec,
-				   struct snd_soc_dai *codec_dai)
-{
-	int ret;
+	codec->ac97_registered = 1;
 
-	/* Only instantiate AC97 if not already done by the adaptor
-	 * for the generic AC97 subsystem.
-	 */
-	if (codec_dai->driver->ac97_control && !codec->ac97_registered) {
-		/*
-		 * It is possible that the AC97 device is already registered to
-		 * the device subsystem. This happens when the device is created
-		 * via snd_ac97_mixer(). Currently only SoC codec that does so
-		 * is the generic AC97 glue but others migh emerge.
-		 *
-		 * In those cases we don't try to register the device again.
-		 */
-		if (!codec->ac97_created)
-			return 0;
-
-		ret = soc_ac97_dev_register(codec);
-		if (ret < 0) {
-			dev_err(codec->dev,
-				"ASoC: AC97 device register failed: %d\n", ret);
-			return ret;
-		}
-
-		codec->ac97_registered = 1;
-	}
 	return 0;
 }
 
 static void soc_unregister_ac97_codec(struct snd_soc_codec *codec)
 {
-	if (codec->ac97_registered) {
-		soc_ac97_dev_unregister(codec);
-		codec->ac97_registered = 0;
-	}
+	if (!codec->ac97_registered)
+		return;
+	device_del(&codec->ac97->dev);
+	codec->ac97_registered = 0;
 }
 
 static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)

commit eda1a701fd9589b6ed15b109558bd4f6202e3829
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:47 2014 +0100

    ASoC: ac97: Use static ac97_bus
    
    We always pass soc_ac97_ops to snd_soc_new_ac97_codec(). So instead of
    allocating a snd_ac97_bus in snd_soc_new_ac97_codec() just use a static one
    that gets initialized when snd_soc_set_ac97_ops() is called.
    
    Also drop the device number parameter from snd_soc_new_ac97_codec(). We
    currently only support one device per bus and all drivers pass 0 for the
    device number. And if we should ever support multiple devices per bus it
    wouldn't be up to individual AC'97 device drivers to pick their number, but
    rather either the AC'97 adapter driver or the core code will assign them.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
index da7b031a6eea..dbfca7e7dddb 100644
--- a/sound/soc/soc-ac97.c
+++ b/sound/soc/soc-ac97.c
@@ -38,6 +38,10 @@ struct snd_ac97_reset_cfg {
 	int gpio_reset;
 };
 
+static struct snd_ac97_bus soc_ac97_bus = {
+	.ops = NULL, /* Gets initialized in snd_soc_set_ac97_ops() */
+};
+
 /* unregister ac97 codec */
 static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
 {
@@ -140,27 +144,17 @@ static void soc_ac97_device_release(struct device *dev)
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec
- * @ops: AC97 bus operations
- * @num: AC97 codec number
  *
  * Initialises AC97 codec resources for use by ad-hoc devices only.
  */
-int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
-	struct snd_ac97_bus_ops *ops, int num)
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec)
 {
 	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
 	if (codec->ac97 == NULL)
 		return -ENOMEM;
 
-	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
-	if (codec->ac97->bus == NULL) {
-		kfree(codec->ac97);
-		codec->ac97 = NULL;
-		return -ENOMEM;
-	}
-
-	codec->ac97->bus->ops = ops;
-	codec->ac97->num = num;
+	codec->ac97->bus = &soc_ac97_bus;
+	codec->ac97->num = 0;
 	codec->ac97->dev.release = soc_ac97_device_release;
 
 	/*
@@ -183,7 +177,6 @@ EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
 void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 {
 	soc_unregister_ac97_codec(codec);
-	kfree(codec->ac97->bus);
 	codec->ac97->bus = NULL;
 	put_device(&codec->ac97->dev);
 	codec->ac97 = NULL;
@@ -314,6 +307,7 @@ int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
 		return -EBUSY;
 
 	soc_ac97_ops = ops;
+	soc_ac97_bus.ops = ops;
 
 	return 0;
 }

commit 336b8423e285174ebecf02a743d69913b83bbc48
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:46 2014 +0100

    ASoC: Move AC'97 support to its own file
    
    Currently the AC'97 support is splattered all throughout soc-core.c. Some
    parts are #ifdef'd some parts are not. This patch moves the AC'97 support to
    its own file, this should make the code a bit more clearer and also makes it
    possible to easily not compile it into the kernel when not needed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-ac97.c b/sound/soc/soc-ac97.c
new file mode 100644
index 000000000000..da7b031a6eea
--- /dev/null
+++ b/sound/soc/soc-ac97.c
@@ -0,0 +1,382 @@
+/*
+ * soc-ac97.c  --  ALSA SoC Audio Layer AC97 support
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ * Copyright (C) 2010 Slimlogic Ltd.
+ * Copyright (C) 2010 Texas Instruments Inc.
+ *
+ * Author: Liam Girdwood <lrg@slimlogic.co.uk>
+ *         with code, comments and ideas from :-
+ *         Richard Purdie <richard@openedhand.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/export.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/of_gpio.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/slab.h>
+#include <sound/ac97_codec.h>
+#include <sound/soc.h>
+
+struct snd_ac97_reset_cfg {
+	struct pinctrl *pctl;
+	struct pinctrl_state *pstate_reset;
+	struct pinctrl_state *pstate_warm_reset;
+	struct pinctrl_state *pstate_run;
+	int gpio_sdata;
+	int gpio_sync;
+	int gpio_reset;
+};
+
+/* unregister ac97 codec */
+static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
+{
+	if (codec->ac97->dev.bus)
+		device_del(&codec->ac97->dev);
+	return 0;
+}
+
+/* register ac97 codec to bus */
+static int soc_ac97_dev_register(struct snd_soc_codec *codec)
+{
+	int err;
+
+	codec->ac97->dev.bus = &ac97_bus_type;
+	codec->ac97->dev.parent = codec->component.card->dev;
+
+	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
+		     codec->component.card->snd_card->number, 0,
+		     codec->component.name);
+	err = device_add(&codec->ac97->dev);
+	if (err < 0) {
+		dev_err(codec->dev, "ASoC: Can't register ac97 bus\n");
+		codec->ac97->dev.bus = NULL;
+		return err;
+	}
+	return 0;
+}
+
+static int soc_register_ac97_codec(struct snd_soc_codec *codec,
+				   struct snd_soc_dai *codec_dai)
+{
+	int ret;
+
+	/* Only instantiate AC97 if not already done by the adaptor
+	 * for the generic AC97 subsystem.
+	 */
+	if (codec_dai->driver->ac97_control && !codec->ac97_registered) {
+		/*
+		 * It is possible that the AC97 device is already registered to
+		 * the device subsystem. This happens when the device is created
+		 * via snd_ac97_mixer(). Currently only SoC codec that does so
+		 * is the generic AC97 glue but others migh emerge.
+		 *
+		 * In those cases we don't try to register the device again.
+		 */
+		if (!codec->ac97_created)
+			return 0;
+
+		ret = soc_ac97_dev_register(codec);
+		if (ret < 0) {
+			dev_err(codec->dev,
+				"ASoC: AC97 device register failed: %d\n", ret);
+			return ret;
+		}
+
+		codec->ac97_registered = 1;
+	}
+	return 0;
+}
+
+static void soc_unregister_ac97_codec(struct snd_soc_codec *codec)
+{
+	if (codec->ac97_registered) {
+		soc_ac97_dev_unregister(codec);
+		codec->ac97_registered = 0;
+	}
+}
+
+static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_dai *codec_dai = rtd->codec_dais[i];
+
+		ret = soc_register_ac97_codec(codec_dai->codec, codec_dai);
+		if (ret) {
+			while (--i >= 0)
+				soc_unregister_ac97_codec(codec_dai->codec);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void soc_unregister_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	int i;
+
+	for (i = 0; i < rtd->num_codecs; i++)
+		soc_unregister_ac97_codec(rtd->codec_dais[i]->codec);
+}
+
+static void soc_ac97_device_release(struct device *dev)
+{
+	kfree(to_ac97_t(dev));
+}
+
+/**
+ * snd_soc_new_ac97_codec - initailise AC97 device
+ * @codec: audio codec
+ * @ops: AC97 bus operations
+ * @num: AC97 codec number
+ *
+ * Initialises AC97 codec resources for use by ad-hoc devices only.
+ */
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num)
+{
+	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
+	if (codec->ac97 == NULL)
+		return -ENOMEM;
+
+	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
+	if (codec->ac97->bus == NULL) {
+		kfree(codec->ac97);
+		codec->ac97 = NULL;
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus->ops = ops;
+	codec->ac97->num = num;
+	codec->ac97->dev.release = soc_ac97_device_release;
+
+	/*
+	 * Mark the AC97 device to be created by us. This way we ensure that the
+	 * device will be registered with the device subsystem later on.
+	 */
+	codec->ac97_created = 1;
+	device_initialize(&codec->ac97->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
+
+/**
+ * snd_soc_free_ac97_codec - free AC97 codec device
+ * @codec: audio codec
+ *
+ * Frees AC97 codec device resources.
+ */
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
+{
+	soc_unregister_ac97_codec(codec);
+	kfree(codec->ac97->bus);
+	codec->ac97->bus = NULL;
+	put_device(&codec->ac97->dev);
+	codec->ac97 = NULL;
+	codec->ac97_created = 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
+
+static struct snd_ac97_reset_cfg snd_ac97_rst_cfg;
+
+static void snd_soc_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_warm_reset);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 1);
+
+	udelay(10);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
+	msleep(2);
+}
+
+static void snd_soc_ac97_reset(struct snd_ac97 *ac97)
+{
+	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_reset);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sdata, 0);
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 0);
+
+	udelay(10);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 1);
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
+	msleep(2);
+}
+
+static int snd_soc_ac97_parse_pinctl(struct device *dev,
+		struct snd_ac97_reset_cfg *cfg)
+{
+	struct pinctrl *p;
+	struct pinctrl_state *state;
+	int gpio;
+	int ret;
+
+	p = devm_pinctrl_get(dev);
+	if (IS_ERR(p)) {
+		dev_err(dev, "Failed to get pinctrl\n");
+		return PTR_ERR(p);
+	}
+	cfg->pctl = p;
+
+	state = pinctrl_lookup_state(p, "ac97-reset");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-reset\n");
+		return PTR_ERR(state);
+	}
+	cfg->pstate_reset = state;
+
+	state = pinctrl_lookup_state(p, "ac97-warm-reset");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-warm-reset\n");
+		return PTR_ERR(state);
+	}
+	cfg->pstate_warm_reset = state;
+
+	state = pinctrl_lookup_state(p, "ac97-running");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-running\n");
+		return PTR_ERR(state);
+	}
+	cfg->pstate_run = state;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 0);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-sync gpio\n");
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link sync");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-sync gpio\n");
+		return ret;
+	}
+	cfg->gpio_sync = gpio;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 1);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-sdata gpio %d\n", gpio);
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link sdata");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-sdata gpio\n");
+		return ret;
+	}
+	cfg->gpio_sdata = gpio;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 2);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-reset gpio\n");
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link reset");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-reset gpio\n");
+		return ret;
+	}
+	cfg->gpio_reset = gpio;
+
+	return 0;
+}
+
+struct snd_ac97_bus_ops *soc_ac97_ops;
+EXPORT_SYMBOL_GPL(soc_ac97_ops);
+
+int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
+{
+	if (ops == soc_ac97_ops)
+		return 0;
+
+	if (soc_ac97_ops && ops)
+		return -EBUSY;
+
+	soc_ac97_ops = ops;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops);
+
+/**
+ * snd_soc_set_ac97_ops_of_reset - Set ac97 ops with generic ac97 reset functions
+ *
+ * This function sets the reset and warm_reset properties of ops and parses
+ * the device node of pdev to get pinctrl states and gpio numbers to use.
+ */
+int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
+		struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct snd_ac97_reset_cfg cfg;
+	int ret;
+
+	ret = snd_soc_ac97_parse_pinctl(dev, &cfg);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_set_ac97_ops(ops);
+	if (ret)
+		return ret;
+
+	ops->warm_reset = snd_soc_ac97_warm_reset;
+	ops->reset = snd_soc_ac97_reset;
+
+	snd_ac97_rst_cfg = cfg;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops_of_reset);
+
+int snd_soc_ac97_register_dai_links(struct snd_soc_card *card)
+{
+	int i;
+	int ret;
+
+	/* register any AC97 codecs */
+	for (i = 0; i < card->num_rtd; i++) {
+		ret = soc_register_ac97_dai_link(&card->rtd[i]);
+		if (ret < 0)
+			goto err;
+	}
+
+	return 0;
+err:
+	dev_err(card->dev,
+		"ASoC: failed to register AC97: %d\n", ret);
+	while (--i >= 0)
+		soc_unregister_ac97_dai_link(&card->rtd[i]);
+	return ret;
+}
+
+void snd_soc_ac97_add_pdata(struct snd_soc_pcm_runtime *rtd)
+{
+	unsigned int i;
+
+	/* add platform data for AC97 devices */
+	for (i = 0; i < rtd->num_codecs; i++) {
+		if (rtd->codec_dais[i]->driver->ac97_control)
+			snd_ac97_dev_add_pdata(rtd->codec_dais[i]->codec->ac97,
+					       rtd->cpu_dai->ac97_pdata);
+	}
+}
