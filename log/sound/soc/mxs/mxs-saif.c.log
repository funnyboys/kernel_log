commit da33574f7f1c110ec58ea43251a9a85801d6e015
Author: Tang Bin <tangbin@cmss.chinamobile.com>
Date:   Wed Apr 29 17:38:23 2020 +0800

    ASoC: mxs-saif: Fix unused assignment
    
    Delete unused initialized value, because 'ret' will be assigined
    by the function of_alias_get_id().
    
    Signed-off-by: Zhang Shengju <zhangshengju@cmss.chinamobile.com>
    Signed-off-by: Tang Bin <tangbin@cmss.chinamobile.com>
    Link: https://lore.kernel.org/r/20200429093823.1372-1-tangbin@cmss.chinamobile.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 64c095b91d35..07f8cf9980e3 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -733,7 +733,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct mxs_saif *saif;
-	int irq, ret = 0;
+	int irq, ret;
 	struct device_node *master;
 
 	saif = devm_kzalloc(&pdev->dev, sizeof(*saif), GFP_KERNEL);

commit e66f385354b3bd29b713d8ab8556aa889723928f
Author: Tang Bin <tangbin@cmss.chinamobile.com>
Date:   Mon Apr 20 22:25:09 2020 +0800

    ASoC: mxs-saif: Avoid unnecessary check
    
    The function mxs_saif_probe() is only called with an
    openfirmware platform device. Therefore there is no
    need to check that it has an openfirmware node.
    
    Signed-off-by: Shengju Zhang <zhangshengju@cmss.chinamobile.com>
    Signed-off-by: Tang Bin <tangbin@cmss.chinamobile.com>
    Link: https://lore.kernel.org/r/20200420142509.9728-1-tangbin@cmss.chinamobile.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 1e38ce858326..64c095b91d35 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -736,9 +736,6 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	int irq, ret = 0;
 	struct device_node *master;
 
-	if (!np)
-		return -EINVAL;
-
 	saif = devm_kzalloc(&pdev->dev, sizeof(*saif), GFP_KERNEL);
 	if (!saif)
 		return -ENOMEM;

commit cf9441adb1a35506d7606866c382b9d8614169b5
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Tue Jul 30 11:15:49 2019 -0700

    ASoC: Remove dev_err() usage after platform_get_irq()
    
    We don't need dev_err() messages when platform_get_irq() fails now that
    platform_get_irq() prints an error message itself when something goes
    wrong. Let's remove these prints with a simple semantic patch.
    
    // <smpl>
    @@
    expression ret;
    struct platform_device *E;
    @@
    
    ret =
    (
    platform_get_irq(E, ...)
    |
    platform_get_irq_byname(E, ...)
    );
    
    if ( \( ret < 0 \| ret <= 0 \) )
    {
    (
    -if (ret != -EPROBE_DEFER)
    -{ ...
    -dev_err(...);
    -... }
    |
    ...
    -dev_err(...);
    )
    ...
    }
    // </smpl>
    
    While we're here, remove braces on if statements that only have one
    statement (manually).
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Cc: alsa-devel@alsa-project.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20190730181557.90391-50-swboyd@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index a2c79426513b..1e38ce858326 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -790,12 +790,8 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		return PTR_ERR(saif->base);
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		ret = irq;
-		dev_err(&pdev->dev, "failed to get irq resource: %d\n",
-			ret);
-		return ret;
-	}
+	if (irq < 0)
+		return irq;
 
 	saif->dev = &pdev->dev;
 	ret = devm_request_irq(&pdev->dev, irq, mxs_saif_irq, 0,

commit 1327bfe2887c0e29bcdc0c5c3e445da107ccb4e2
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sat Jul 27 23:07:15 2019 +0800

    ASoC: mxs-saif: use devm_platform_ioremap_resource() to simplify code
    
    Use devm_platform_ioremap_resource() to simplify the code a bit.
    This is detected by coccinelle.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lore.kernel.org/r/20190727150738.54764-12-yuehaibing@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 269b6d6df250..a2c79426513b 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -732,7 +732,6 @@ static int mxs_saif_mclk_init(struct platform_device *pdev)
 static int mxs_saif_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
-	struct resource *iores;
 	struct mxs_saif *saif;
 	int irq, ret = 0;
 	struct device_node *master;
@@ -786,9 +785,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	iores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
-	saif->base = devm_ioremap_resource(&pdev->dev, iores);
+	saif->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(saif->base))
 		return PTR_ERR(saif->base);
 

commit 16216333235adf51093d0330a934a7e4a03134fe
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:31 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 1
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin street fifth floor boston ma 02110 1301 usa
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option [no]_[pad]_[ctrl] any later version this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin street fifth floor boston ma
      02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 176 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154040.652910950@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 2bbb92ed96c8..269b6d6df250 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -1,19 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright 2011 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #include <linux/module.h>

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 156aa7c00787..2bbb92ed96c8 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -26,6 +26,7 @@
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
+#include <linux/io.h>
 #include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>

commit 0d97ee867958a092f02e9cd7c865c278bcec18a6
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Jul 25 15:44:33 2017 +0530

    ASoC: mxs-saif: Handle return value of clk_prepare_enable/clk_prepare.
    
    clk_prepare_enable() and clk_prepare() can fail here and
    we must check its return value.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index b42f301c6b96..156aa7c00787 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -125,7 +125,9 @@ static int mxs_saif_set_clk(struct mxs_saif *saif,
 	 *
 	 * If MCLK is not used, we just set saif clk to 512*fs.
 	 */
-	clk_prepare_enable(master_saif->clk);
+	ret = clk_prepare_enable(master_saif->clk);
+	if (ret)
+		return ret;
 
 	if (master_saif->mclk_in_use) {
 		switch (mclk / rate) {
@@ -388,6 +390,7 @@ static int mxs_saif_startup(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *cpu_dai)
 {
 	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret;
 
 	/* clear error status to 0 for each re-open */
 	saif->fifo_underrun = 0;
@@ -401,7 +404,9 @@ static int mxs_saif_startup(struct snd_pcm_substream *substream,
 	__raw_writel(BM_SAIF_CTRL_CLKGATE,
 		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
 
-	clk_prepare(saif->clk);
+	ret = clk_prepare(saif->clk);
+	if (ret)
+		return ret;
 
 	return 0;
 }
@@ -468,7 +473,9 @@ static int mxs_saif_hw_params(struct snd_pcm_substream *substream,
 		if (ret)
 			return ret;
 
-		clk_prepare(master_saif->clk);
+		ret = clk_prepare(master_saif->clk);
+		if (ret)
+			return ret;
 	}
 
 	scr = __raw_readl(saif->base + SAIF_CTRL);

commit bcb8c270829a639b8b838809d7c2b540e65f4e01
Author: Jörg Krause <jk@lintech.de>
Date:   Fri Jan 13 21:44:27 2017 +0100

    ASoC: mxs-saif: fix setting master base rate
    
    The SAIF base oversample rates are either 512*fs or 384*fs. An additional
    divider exists within the SAIF to generate sub-multiples of these two base
    rates if MCLK is required by the codec.
    
     * The sub-rates for the 512x base rate are: 256x, 128x, 64x, and 32x.
     * The sub-rates for the 384x base rate are: 192x, 96x, and 48x.
    
    Setting the base rate depending on the modulo operation with 32 and 48
    give wrong results for some mclk.
    
    If mclk=18.432MHz both modulo operations results in 0. As testing the
    result with 32 is done first, a wrong base rate of 512*fs is set instead
    of the correct 384*fs.
    
    Fix this by setting the base rate depending on the calculated sub-rate.
    
    Signed-off-by: Jörg Krause <joerg.krause@embedded.rocks>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 9012a2036131..b42f301c6b96 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -119,23 +119,33 @@ static int mxs_saif_set_clk(struct mxs_saif *saif,
 	 * Set SAIF clock
 	 *
 	 * The SAIF clock should be either 384*fs or 512*fs.
-	 * If MCLK is used, the SAIF clk ratio need to match mclk ratio.
-	 *  For 32x mclk, set saif clk as 512*fs.
-	 *  For 48x mclk, set saif clk as 384*fs.
+	 * If MCLK is used, the SAIF clk ratio needs to match mclk ratio.
+	 *  For 256x, 128x, 64x, and 32x sub-rates, set saif clk as 512*fs.
+	 *  For 192x, 96x, and 48x sub-rates, set saif clk as 384*fs.
 	 *
 	 * If MCLK is not used, we just set saif clk to 512*fs.
 	 */
 	clk_prepare_enable(master_saif->clk);
 
 	if (master_saif->mclk_in_use) {
-		if (mclk % 32 == 0) {
+		switch (mclk / rate) {
+		case 32:
+		case 64:
+		case 128:
+		case 256:
+		case 512:
 			scr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;
 			ret = clk_set_rate(master_saif->clk, 512 * rate);
-		} else if (mclk % 48 == 0) {
+			break;
+		case 48:
+		case 96:
+		case 192:
+		case 384:
 			scr |= BM_SAIF_CTRL_BITCLK_BASE_RATE;
 			ret = clk_set_rate(master_saif->clk, 384 * rate);
-		} else {
-			/* SAIF MCLK should be either 32x or 48x */
+			break;
+		default:
+			/* SAIF MCLK should be a sub-rate of 512x or 384x */
 			clk_disable_unprepare(master_saif->clk);
 			return -EINVAL;
 		}

commit b25658ed7d24cd8b1f9a72148e80e216b6a0c17a
Author: Jörg Krause <joerg.krause@embedded.rocks>
Date:   Fri Jan 13 21:44:28 2017 +0100

    ASoC: mxs-saif: fix setting SAIF1 register
    
    If SAIF0 is used in master and SAIF1 in slave mode setting the SAIF1
    register in mxs_saif_set_dai_fmt() does not have any effect on the
    interface as the clk gate needs to be cleared before the register can be
    written.
    
    Signed-off-by: Jörg Krause <joerg.krause@embedded.rocks>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index a002ab892772..9012a2036131 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -299,6 +299,16 @@ static int mxs_saif_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
 		return -EBUSY;
 	}
 
+	/* If SAIF1 is configured as slave, the clk gate needs to be cleared
+	 * before the register can be written.
+	 */
+	if (saif->id != saif->master_id) {
+		__raw_writel(BM_SAIF_CTRL_SFTRST,
+			saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+		__raw_writel(BM_SAIF_CTRL_CLKGATE,
+			saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+	}
+
 	scr0 = __raw_readl(saif->base + SAIF_CTRL);
 	scr0 = scr0 & ~BM_SAIF_CTRL_BITCLK_EDGE & ~BM_SAIF_CTRL_LRCLK_POLARITY \
 		& ~BM_SAIF_CTRL_JUSTIFY & ~BM_SAIF_CTRL_DELAY;

commit e1b790a8720192e1cfdd46a9b20d0f56de99c73d
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Sat Oct 15 00:53:36 2016 +0300

    SoC: mxs-saif: check validity of ids in mxs_saif_probe()
    
    There is a check for validity of one of ids in mxs_saif_probe(),
    while array dereferece is made by the other id.
    
    The patch adds the check for the second saif id.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 13631003cb7c..a002ab892772 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -735,6 +735,11 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	else
 		saif->id = ret;
 
+	if (saif->id >= ARRAY_SIZE(mxs_saif)) {
+		dev_err(&pdev->dev, "get wrong saif id\n");
+		return -EINVAL;
+	}
+
 	/*
 	 * If there is no "fsl,saif-master" phandle, it's a saif
 	 * master.  Otherwise, it's a slave and its phandle points
@@ -749,11 +754,11 @@ static int mxs_saif_probe(struct platform_device *pdev)
 			return ret;
 		else
 			saif->master_id = ret;
-	}
 
-	if (saif->master_id >= ARRAY_SIZE(mxs_saif)) {
-		dev_err(&pdev->dev, "get wrong master id\n");
-		return -EINVAL;
+		if (saif->master_id >= ARRAY_SIZE(mxs_saif)) {
+			dev_err(&pdev->dev, "get wrong master id\n");
+			return -EINVAL;
+		}
 	}
 
 	mxs_saif[saif->id] = saif;

commit 88f183484a9419910737cde211f7dbb184171d66
Merge: ab96d9d60367 e354d86e5516 05f5afd3f0d9 436e056c4ba3 45d5eb3a342f e04fadaa169b
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Mar 13 15:17:18 2016 +0700

    Merge remote-tracking branches 'asoc/topic/max98926', 'asoc/topic/mtk', 'asoc/topic/mxs-saif', 'asoc/topic/nau8825' and 'asoc/topic/omap' into asoc-next

commit 436e056c4ba368f13a5709a5a4a7f26fc238a5a6
Author: Mans Rullgard <mans@mansr.com>
Date:   Wed Feb 3 13:18:20 2016 +0000

    ASoC: mxs-saif: check BUSY bit in hw_params() only if not mclk_in_use
    
    If something else, typically a codec, has enabled mclk, the BUSY
    bit may be set when hw_params() is called without this being an
    error.  This check thus causes intermittent failures to configure
    the sound device when used in such a manner.  Fix this by making
    the test conditional on !saif->mclk_in_use.
    
    Signed-off-by: Mans Rullgard <mans@mansr.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index c866ade28ad0..cd04eb7ee753 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -408,7 +408,7 @@ static int mxs_saif_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	stat = __raw_readl(saif->base + SAIF_STAT);
-	if (stat & BM_SAIF_STAT_BUSY) {
+	if (!saif->mclk_in_use && (stat & BM_SAIF_STAT_BUSY)) {
 		dev_err(cpu_dai->dev, "error: busy\n");
 		return -EBUSY;
 	}

commit f212c6d8c2b21c1e1d0158d38a7c37f4427f3848
Author: Mans Rullgard <mans@mansr.com>
Date:   Thu Jan 21 14:55:56 2016 +0000

    ASoC: mxs-saif: fix clk_prepare() without matching clk_unprepare()
    
    The clk_prepare() call in hw_params() has no matching clk_unprepare(),
    leaving the clk with an ever-increasing prepare count.  Moreover,
    hw_params() can be called multiple times which would again leave us
    with a runaway prepare count.  Fix this by moving the clk_prepare()
    call to the startup() function and adding a shutdown() function with
    a matching clk_unprepare() as these operations are already correctly
    bracketed by soc-core.
    
    Signed-off-by: Mans Rullgard <mans@mansr.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index c866ade28ad0..a6c7b8d87cd2 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -381,9 +381,19 @@ static int mxs_saif_startup(struct snd_pcm_substream *substream,
 	__raw_writel(BM_SAIF_CTRL_CLKGATE,
 		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
 
+	clk_prepare(saif->clk);
+
 	return 0;
 }
 
+static void mxs_saif_shutdown(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *cpu_dai)
+{
+	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+
+	clk_unprepare(saif->clk);
+}
+
 /*
  * Should only be called when port is inactive.
  * although can be called multiple times by upper layers.
@@ -424,8 +434,6 @@ static int mxs_saif_hw_params(struct snd_pcm_substream *substream,
 		return ret;
 	}
 
-	/* prepare clk in hw_param, enable in trigger */
-	clk_prepare(saif->clk);
 	if (saif != master_saif) {
 		/*
 		* Set an initial clock rate for the saif internal logic to work
@@ -611,6 +619,7 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 
 static const struct snd_soc_dai_ops mxs_saif_dai_ops = {
 	.startup = mxs_saif_startup,
+	.shutdown = mxs_saif_shutdown,
 	.trigger = mxs_saif_trigger,
 	.prepare = mxs_saif_prepare,
 	.hw_params = mxs_saif_hw_params,

commit 5396ecf7b1920595deec83b902502bd3d2da184e
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Tue Dec 30 12:11:36 2014 -0200

    ASoC: mxs-saif: Do not store the irq number in the private structure
    
    The irq number is only used inside the probe function, so there is really no
    need to store it in the private structure.
    
    Use a local 'irq' variable to hold the the irq number instead.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index d9865082160c..c866ade28ad0 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -710,7 +710,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	struct resource *iores;
 	struct mxs_saif *saif;
-	int ret = 0;
+	int irq, ret = 0;
 	struct device_node *master;
 
 	if (!np)
@@ -763,16 +763,16 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	if (IS_ERR(saif->base))
 		return PTR_ERR(saif->base);
 
-	saif->irq = platform_get_irq(pdev, 0);
-	if (saif->irq < 0) {
-		ret = saif->irq;
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		ret = irq;
 		dev_err(&pdev->dev, "failed to get irq resource: %d\n",
 			ret);
 		return ret;
 	}
 
 	saif->dev = &pdev->dev;
-	ret = devm_request_irq(&pdev->dev, saif->irq, mxs_saif_irq, 0,
+	ret = devm_request_irq(&pdev->dev, irq, mxs_saif_irq, 0,
 			       dev_name(&pdev->dev), saif);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to request irq\n");

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 8c2727f97b4825adaad43bf98632abc9940345a4
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Mon Nov 10 17:49:30 2014 -0200

    ASoC: mxs: mxs-saif: Register the irq with the device name
    
    Instead of registering the irq name with the driver name, it's better to pass
    the device name so that we have a more explicit indication as to what saif
    instance the irq is related:
    
    $ cat /proc/interrupts
               CPU0
    ...
    214:          4         -  59  80042000.saif
    215:          0         -  58  80046000.saif
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 231d7e7b0711..83b2fea09219 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -773,7 +773,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 
 	saif->dev = &pdev->dev;
 	ret = devm_request_irq(&pdev->dev, saif->irq, mxs_saif_irq, 0,
-			       "mxs-saif", saif);
+			       dev_name(&pdev->dev), saif);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to request irq\n");
 		return ret;

commit 38b089d78b3084fa100315e5f167d8019e446eae
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:22:10 2014 +0200

    ASoC: mxs: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 231d7e7b0711..eade2742a937 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -815,7 +815,6 @@ static struct platform_driver mxs_saif_driver = {
 
 	.driver = {
 		.name = "mxs-saif",
-		.owner = THIS_MODULE,
 		.of_match_table = mxs_saif_dt_ids,
 	},
 };

commit 2cde51fbd0f310c8a2c5f977e665c0ac3945b46d
Merge: 7471c5c9f58e c097d5fdf3b5 74c375cb85d7 04c3a852f51f 5095f55d7cc3 4f534777c130 2f54d2a1cf7e 56d37d85438d 192043cf6089 f467a0f513ad bbe580302d33 3990c516de66 d754fa9ad18d 516ea4b58433 69ae8489076f 25c1a63f43ca f52c91921553 111bd7b18e13 aafa85e71a75 dd407a324323 71467e46414d 0f7f3d1f17c2 8778ac6be25a 0406a40a095c 308a0f3f24db 2650bc4f6d0c 8cb7a36eb3a8 323702b4e06d ef749400434c 3cec159cfb3f 72aa62bed3ea 328089a47112 11db0da831b1 e1771bcf99b0 f60e5473e678 a010ff628c09 5e8154332f48 58381da68774 626bcacb89f9 38136bde7691 06b2bd23057f 8c5178fca4ce 8e6ad35a31e7 008ef947d0c5 f58c4fc4a3bf 2309d6757900 5c1537163ce7 b65ab73e5d62 26090a834b49 9ea6fbc66d15 2c4864334c4d 1769267bb013 f3f9a60f7947 f25cf3496982 3f3002692ce8 fbbf7fea8e80 c3e8494c001c e40e0b5da87b 50c969732043 63587116811b 0112b62b12e1 a0a05916cf67 b888edbc68fb d44008b35858 9a199b8e9933 784cbf8ab464
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 2 13:01:55 2014 +0000

    Merge remote-tracking branches 'asoc/topic/ad1836', 'asoc/topic/ad193x', 'asoc/topic/adav80x', 'asoc/topic/adsp', 'asoc/topic/ak4641', 'asoc/topic/ak4642', 'asoc/topic/arizona', 'asoc/topic/atmel', 'asoc/topic/au1x', 'asoc/topic/axi', 'asoc/topic/bcm2835', 'asoc/topic/blackfin', 'asoc/topic/cs4271', 'asoc/topic/cs42l52', 'asoc/topic/da7210', 'asoc/topic/davinci', 'asoc/topic/ep93xx', 'asoc/topic/fsl', 'asoc/topic/fsl-mxs', 'asoc/topic/generic', 'asoc/topic/hdmi', 'asoc/topic/jack', 'asoc/topic/jz4740', 'asoc/topic/max98090', 'asoc/topic/mxs', 'asoc/topic/omap', 'asoc/topic/pxa', 'asoc/topic/rcar', 'asoc/topic/s6000', 'asoc/topic/sai', 'asoc/topic/samsung', 'asoc/topic/sgtl5000', 'asoc/topic/spear', 'asoc/topic/ssm2518', 'asoc/topic/ssm2602', 'asoc/topic/tegra', 'asoc/topic/tlv320aic3x', 'asoc/topic/twl6040', 'asoc/topic/txx9', 'asoc/topic/uda1380', 'asoc/topic/width', 'asoc/topic/wm8510', 'asoc/topic/wm8523', 'asoc/topic/wm8580', 'asoc/topic/wm8711', 'asoc/topic/wm8728', 'asoc/topic/wm8731', 'asoc/topic/wm8741', 'asoc/topic/wm8750', 'asoc/topic/wm8753', 'asoc/topic/wm8776', 'asoc/topic/wm8804', 'asoc/topic/wm8900', 'asoc/topic/wm8901', 'asoc/topic/wm8940', 'asoc/topic/wm8962', 'asoc/topic/wm8974', 'asoc/topic/wm8985', 'asoc/topic/wm8988', 'asoc/topic/wm8990', 'asoc/topic/wm8991', 'asoc/topic/wm8994', 'asoc/topic/wm8995', 'asoc/topic/wm9081' and 'asoc/topic/x86' into asoc-next

commit 05004cb4cd06127bb8ff70d5ab5a915103828e9d
Author: Matthew Garrett <matthew.garrett@nebula.com>
Date:   Wed Dec 18 13:50:10 2013 +0000

    ASoC: fsl/mxs: Remove unnecessarily gendered language
    
    The kernel as a number of cases of gendered language. The majority of these
    refer to objects that don't have gender in English, and so I've replaced
    them with "it" and "its". Some refer to people (developers or users), and
    I've replaced these with the singular "they" variant. Some are simply
    typos that I've fixed up.
    
    I've left cases where gendered language was used to refer to specific
    individuals, was a quote or is part of license text.
    
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 54e622acac33..d6cb9a51dd57 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -50,9 +50,9 @@ static struct mxs_saif *mxs_saif[2];
  * This also means that both SAIFs must operate at the same sample rate.
  *
  * We abstract this as each saif has a master, the master could be
- * himself or other saifs. In the generic saif driver, saif does not need
- * to know the different clkmux. Saif only needs to know who is his master
- * and operating his master to generate the proper clock rate for him.
+ * itself or other saifs. In the generic saif driver, saif does not need
+ * to know the different clkmux. Saif only needs to know who is its master
+ * and operating its master to generate the proper clock rate for it.
  * The master id is provided in mach-specific layer according to different
  * clkmux setting.
  */
@@ -76,7 +76,7 @@ static int mxs_saif_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
  * Since SAIF may work on EXTMASTER mode, IOW, it's working BITCLK&LRCLK
  * is provided by other SAIF, we provide a interface here to get its master
  * from its master_id.
- * Note that the master could be himself.
+ * Note that the master could be itself.
  */
 static inline struct mxs_saif *mxs_saif_get_master(struct mxs_saif * saif)
 {
@@ -516,7 +516,7 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 		}
 
 		/*
-		 * If the saif's master is not himself, we also need to enable
+		 * If the saif's master is not itself, we also need to enable
 		 * itself clk for its internal basic logic to work.
 		 */
 		if (saif != master_saif) {

commit dd407a3243234c6a17ba624d698e6824067003c9
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Dec 18 13:50:10 2013 +0000

    ASoC: fsl/mxs: Remove unnecessarily gendered language
    
    The kernel as a number of cases of gendered language. The majority of these
    refer to objects that don't have gender in English, and so I've replaced
    them with "it" and "its". Some refer to people (developers or users), and
    I've replaced these with the singular "they" variant. Some are simply
    typos that I've fixed up.
    
    I've left cases where gendered language was used to refer to specific
    individuals, was a quote or is part of license text.
    
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 54e622acac33..d6cb9a51dd57 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -50,9 +50,9 @@ static struct mxs_saif *mxs_saif[2];
  * This also means that both SAIFs must operate at the same sample rate.
  *
  * We abstract this as each saif has a master, the master could be
- * himself or other saifs. In the generic saif driver, saif does not need
- * to know the different clkmux. Saif only needs to know who is his master
- * and operating his master to generate the proper clock rate for him.
+ * itself or other saifs. In the generic saif driver, saif does not need
+ * to know the different clkmux. Saif only needs to know who is its master
+ * and operating its master to generate the proper clock rate for it.
  * The master id is provided in mach-specific layer according to different
  * clkmux setting.
  */
@@ -76,7 +76,7 @@ static int mxs_saif_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
  * Since SAIF may work on EXTMASTER mode, IOW, it's working BITCLK&LRCLK
  * is provided by other SAIF, we provide a interface here to get its master
  * from its master_id.
- * Note that the master could be himself.
+ * Note that the master could be itself.
  */
 static inline struct mxs_saif *mxs_saif_get_master(struct mxs_saif * saif)
 {
@@ -516,7 +516,7 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 		}
 
 		/*
-		 * If the saif's master is not himself, we also need to enable
+		 * If the saif's master is not itself, we also need to enable
 		 * itself clk for its internal basic logic to work.
 		 */
 		if (saif != master_saif) {

commit 2650bc4f6d0c36f1219d2070485cc2980a88fab3
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Nov 28 08:50:37 2013 +0100

    ASoC: mxs: Use devm_snd_dmaengine_pcm_register()
    
    Makes the code shorter.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 54e622acac33..92db74dc3177 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -804,13 +804,6 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int mxs_saif_remove(struct platform_device *pdev)
-{
-	mxs_pcm_platform_unregister(&pdev->dev);
-
-	return 0;
-}
-
 static const struct of_device_id mxs_saif_dt_ids[] = {
 	{ .compatible = "fsl,imx28-saif", },
 	{ /* sentinel */ }
@@ -819,7 +812,6 @@ MODULE_DEVICE_TABLE(of, mxs_saif_dt_ids);
 
 static struct platform_driver mxs_saif_driver = {
 	.probe = mxs_saif_probe,
-	.remove = mxs_saif_remove,
 
 	.driver = {
 		.name = "mxs-saif",

commit 10abe843d5f08793fb684eaef3739f3c26635e42
Merge: 07797e9bb67f 863ebddec85c
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Oct 24 11:24:09 2013 +0100

    Merge remote-tracking branch 'asoc/topic/mxs' into asoc-next

commit 863ebddec85c5ce2fb2e7742e8834a3bd69a2512
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Fri Oct 11 12:11:04 2013 +0200

    ASoC: mxs-saif: Handle errors in trigger function
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index c8ead011c95b..fc3d89b75d48 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -494,6 +494,7 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
 	struct mxs_saif *master_saif;
 	u32 delay;
+	int ret;
 
 	master_saif = mxs_saif_get_master(saif);
 	if (!master_saif)
@@ -508,21 +509,32 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 
 		dev_dbg(cpu_dai->dev, "start\n");
 
-		clk_enable(master_saif->clk);
-		if (!master_saif->mclk_in_use)
-			__raw_writel(BM_SAIF_CTRL_RUN,
-				master_saif->base + SAIF_CTRL + MXS_SET_ADDR);
+		ret = clk_enable(master_saif->clk);
+		if (ret) {
+			dev_err(saif->dev, "Failed to enable master clock\n");
+			return ret;
+		}
 
 		/*
 		 * If the saif's master is not himself, we also need to enable
 		 * itself clk for its internal basic logic to work.
 		 */
 		if (saif != master_saif) {
-			clk_enable(saif->clk);
+			ret = clk_enable(saif->clk);
+			if (ret) {
+				dev_err(saif->dev, "Failed to enable master clock\n");
+				clk_disable(master_saif->clk);
+				return ret;
+			}
+
 			__raw_writel(BM_SAIF_CTRL_RUN,
 				saif->base + SAIF_CTRL + MXS_SET_ADDR);
 		}
 
+		if (!master_saif->mclk_in_use)
+			__raw_writel(BM_SAIF_CTRL_RUN,
+				master_saif->base + SAIF_CTRL + MXS_SET_ADDR);
+
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			/*
 			 * write data to saif data register to trigger

commit 88cf632a135188db35b4db412a06b155fa444eb1
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Fri Oct 11 12:11:03 2013 +0200

    ASoC: mxs-saif: Store saif state
    
    Trigger commands may be passed multiple times. To avoid errors with
    clk_enable/disable, store the saif state and return if saif is already
    running/stopped.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index b56b8a0e8deb..c8ead011c95b 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -503,6 +503,9 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (saif->state == MXS_SAIF_STATE_RUNNING)
+			return 0;
+
 		dev_dbg(cpu_dai->dev, "start\n");
 
 		clk_enable(master_saif->clk);
@@ -543,6 +546,7 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 		}
 
 		master_saif->ongoing = 1;
+		saif->state = MXS_SAIF_STATE_RUNNING;
 
 		dev_dbg(saif->dev, "CTRL 0x%x STAT 0x%x\n",
 			__raw_readl(saif->base + SAIF_CTRL),
@@ -555,6 +559,9 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (saif->state == MXS_SAIF_STATE_STOPPED)
+			return 0;
+
 		dev_dbg(cpu_dai->dev, "stop\n");
 
 		/* wait a while for the current sample to complete */
@@ -575,6 +582,7 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 		}
 
 		master_saif->ongoing = 0;
+		saif->state = MXS_SAIF_STATE_STOPPED;
 
 		break;
 	default:

commit fcd70eb50e2d572a67839410aa30f6b545355980
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Sep 17 10:20:09 2013 +0530

    ASoC: mxs-saif: Use devm_snd_soc_register_component
    
    devm_snd_soc_register_component makes code simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index b56b8a0e8deb..14152f6f70dd 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -768,8 +768,8 @@ static int mxs_saif_probe(struct platform_device *pdev)
 			dev_warn(&pdev->dev, "failed to init clocks\n");
 	}
 
-	ret = snd_soc_register_component(&pdev->dev, &mxs_saif_component,
-					 &mxs_saif_dai, 1);
+	ret = devm_snd_soc_register_component(&pdev->dev, &mxs_saif_component,
+					      &mxs_saif_dai, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "register DAI failed\n");
 		return ret;
@@ -778,21 +778,15 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	ret = mxs_pcm_platform_register(&pdev->dev);
 	if (ret) {
 		dev_err(&pdev->dev, "register PCM failed: %d\n", ret);
-		goto failed_pdev_alloc;
+		return ret;
 	}
 
 	return 0;
-
-failed_pdev_alloc:
-	snd_soc_unregister_component(&pdev->dev);
-
-	return ret;
 }
 
 static int mxs_saif_remove(struct platform_device *pdev)
 {
 	mxs_pcm_platform_unregister(&pdev->dev);
-	snd_soc_unregister_component(&pdev->dev);
 
 	return 0;
 }

commit 204f029155e7da98b59e6969cf29e210bbe84de5
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Jul 19 12:10:18 2013 +0100

    ASoC: mxs: Remove unneeded mach-types.h inclusions
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 54511c5e6a7c..b56b8a0e8deb 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -31,7 +31,6 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
-#include <asm/mach-types.h>
 
 #include "mxs-saif.h"
 

commit 1b36881105249c8a3a0e56434e43d3e2fbbef704
Merge: 986a622df307 7c9e6150f2e7
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jul 4 18:30:02 2013 +0100

    Merge remote-tracking branch 'asoc/fix/mxs' into asoc-linus

commit 7c9e6150f2e7cbd60e0bc9a19118ca1dc97d2780
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Mon Jul 1 16:16:10 2013 +0800

    ASoC: mxs: register saif mclk to clock framework
    
    Mostly the mxs system design uses saif0 mclk output as the clock source
    of codec.  Since the mclk is implemented as a general divider with the
    saif clk as the parent clock, let's register the mclk as a basic
    clk-divider to common clock framework.  Then with it being a clock
    provdier, clk_get() call in codec driver probe function will just work.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index d31dc52fa862..9ad6dccf791d 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -24,6 +24,7 @@
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/time.h>
 #include <linux/fsl/mxs-dma.h>
@@ -662,6 +663,33 @@ static irqreturn_t mxs_saif_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static int mxs_saif_mclk_init(struct platform_device *pdev)
+{
+	struct mxs_saif *saif = platform_get_drvdata(pdev);
+	struct device_node *np = pdev->dev.of_node;
+	struct clk *clk;
+	int ret;
+
+	clk = clk_register_divider(&pdev->dev, "mxs_saif_mclk",
+				   __clk_get_name(saif->clk), 0,
+				   saif->base + SAIF_CTRL,
+				   BP_SAIF_CTRL_BITCLK_MULT_RATE, 3,
+				   0, NULL);
+	if (IS_ERR(clk)) {
+		ret = PTR_ERR(clk);
+		if (ret == -EEXIST)
+			return 0;
+		dev_err(&pdev->dev, "failed to register mclk: %d\n", ret);
+		return PTR_ERR(clk);
+	}
+
+	ret = of_clk_add_provider(np, of_clk_src_simple_get, clk);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 static int mxs_saif_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -769,6 +797,13 @@ static int mxs_saif_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, saif);
 
+	/* We only support saif0 being tx and clock master */
+	if (saif->id == 0) {
+		ret = mxs_saif_mclk_init(pdev);
+		if (ret)
+			dev_warn(&pdev->dev, "failed to init clocks\n");
+	}
+
 	ret = snd_soc_register_component(&pdev->dev, &mxs_saif_component,
 					 &mxs_saif_dai, 1);
 	if (ret) {

commit 62477adf5f4ede918a97e648a5173b00bbbb17cc
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Mon May 13 13:30:56 2013 +0800

    ASoC: mxs: move to use generic DMA helper
    
    With mxs-dma converted to generic DMA bindings, let's move mxs-pcm to
    use it by removing flages SND_DMAENGINE_PCM_FLAG_NO_DT and
    SND_DMAENGINE_PCM_FLAG_COMPAT.  As the result, those mxs custom dma
    params code can be removed now.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 71a972f5af97..49d870034bc3 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -26,7 +26,6 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/time.h>
-#include <linux/fsl/mxs-dma.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -604,8 +603,6 @@ static int mxs_saif_dai_probe(struct snd_soc_dai *dai)
 	struct mxs_saif *saif = dev_get_drvdata(dai->dev);
 
 	snd_soc_dai_set_drvdata(dai, saif);
-	dai->playback_dma_data = &saif->dma_param;
-	dai->capture_dma_data = &saif->dma_param;
 
 	return 0;
 }
@@ -664,7 +661,7 @@ static irqreturn_t mxs_saif_irq(int irq, void *dev_id)
 static int mxs_saif_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
-	struct resource *iores, *dmares;
+	struct resource *iores;
 	struct mxs_saif *saif;
 	int ret = 0;
 	struct device_node *master;
@@ -719,22 +716,6 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	if (IS_ERR(saif->base))
 		return PTR_ERR(saif->base);
 
-	dmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);
-	if (!dmares) {
-		/*
-		 * TODO: This is a temporary solution and should be changed
-		 * to use generic DMA binding later when the helplers get in.
-		 */
-		ret = of_property_read_u32(np, "fsl,saif-dma-channel",
-					   &saif->dma_param.chan_num);
-		if (ret) {
-			dev_err(&pdev->dev, "failed to get dma channel\n");
-			return ret;
-		}
-	} else {
-		saif->dma_param.chan_num = dmares->start;
-	}
-
 	saif->irq = platform_get_irq(pdev, 0);
 	if (saif->irq < 0) {
 		ret = saif->irq;
@@ -751,14 +732,6 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	saif->dma_param.dma_data.chan_irq = platform_get_irq(pdev, 1);
-	if (saif->dma_param.dma_data.chan_irq < 0) {
-		ret = saif->dma_param.dma_data.chan_irq;
-		dev_err(&pdev->dev, "failed to get dma irq resource: %d\n",
-			ret);
-		return ret;
-	}
-
 	platform_set_drvdata(pdev, saif);
 
 	ret = snd_soc_register_component(&pdev->dev, &mxs_saif_component,

commit e76af6d189075a0ca59bc654157e80da53559fb0
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Mon May 6 15:06:01 2013 -0300

    ASoC: mxs: mxs-saif: Let device core handle pinctrl
    
    Since commit ab78029 (drivers/pinctrl: grab default handles from device core),
    we can rely on device core for handling pinctrl.
    
    So remove devm_pinctrl_get_select_default() from the driver.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index d31dc52fa862..71a972f5af97 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -27,7 +27,6 @@
 #include <linux/delay.h>
 #include <linux/time.h>
 #include <linux/fsl/mxs-dma.h>
-#include <linux/pinctrl/consumer.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -667,7 +666,6 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	struct resource *iores, *dmares;
 	struct mxs_saif *saif;
-	struct pinctrl *pinctrl;
 	int ret = 0;
 	struct device_node *master;
 
@@ -707,12 +705,6 @@ static int mxs_saif_probe(struct platform_device *pdev)
 
 	mxs_saif[saif->id] = saif;
 
-	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
-	if (IS_ERR(pinctrl)) {
-		ret = PTR_ERR(pinctrl);
-		return ret;
-	}
-
 	saif->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(saif->clk)) {
 		ret = PTR_ERR(saif->clk);

commit 9992ba72327fa0d8bdc9fb624e80f5cce338a711
Merge: 00fdffb51311 4ca231b2e6ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 3 09:10:23 2013 -0700

    Merge tag 'sound-3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "Mostly many small changes spread as seen in diffstat in sound/*
      directory by this update.  A significant change in the subsystem level
      is the introduction of snd_soc_component, which will help more generic
      handling of SoC and off-SoC components.
    
      Also, snd_BUG_ON() macro is enabled unconditionally now due to its
      misuses, so people might hit kernel warnings (it's a good thing for
      us).
    
       - compress-offload: support for capture by Charles Keepax
       - HD-audio: codec delay support by Dylan Reid
       - HD-audio: improvements/fixes in generic parser: better headphone
         mic and headset mic support, jack_modes hint consolidation, proper
         beep attach/detachment, generalized power filter controls by David
         Henningsson, et al
       - HD-audio: Improved management of HDMI codec pins/converters
       - HD-audio: Better pin/DAC assignment for VIA codecs
       - HD-audio: Haswell HDMI workarounds
       - HD-audio: ALC268 codec support, a few new quirks for Chromebooks
       - USB: regression fixes: USB-MIDI autopm fix, the recent ISO latency
         fix by Clemens Ladisch
       - USB: support for DSD formats by Daniel Mack
       - USB: A few UAC2 device endian/cock fixes by Eldad Zack
       - USB: quirks for Emu 192kHz support, Novation Twitch DJ controller,
         Yamaha THRxx devices
       - HDSPM: updates for TCO controls by Adrian Knoth
       - ASoC: Add a snd_soc_component object type for generic handling of
         SoC and off-SoC components by Kuninori Morimoto,
       - dmaengine: a large set of cleanups and conversions by Lars-Peter
         Clausen
       - ASoC DAPM: performance optimizations from Ryo Tsutsui
       - ASoC DAPM: support for mixer control sharing by Stephen Warren
       - ASoC: multiplatform ARM cleanups from Arnd Bergmann
       - ASoC: new codec drivers for AK5385 and TAS5086 from Daniel Mack"
    
    * tag 'sound-3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (315 commits)
      ALSA: usb-audio: caiaq: fix endianness bug in snd_usb_caiaq_maschine_dispatch
      ALSA: asihpi: add format support check in snd_card_asihpi_capture_formats
      ALSA: pcm_format_to_bits strong-typed conversion
      ALSA: compress: fix the states to check for allowing read
      ALSA: hda - Move Thinkpad X220 to use auto parser
      ALSA: USB: adjust for changed 3.8 USB API
      ALSA: usb - Avoid unnecessary sample rate changes on USB 2.0 clock sources
      sound: oss/dmabuf: use dma_map_single
      ALSA: ali5451: use mdelay instead of large udelay constants
      ALSA: hda - Add the support for ALC286 codec
      ALSA: usb-audio: USB quirk for Yamaha THR10C
      ALSA: usb-audio: USB quirk for Yamaha THR5A
      ALSA: usb-audio: USB quirk for Yamaha THR10
      ALSA: usb-audio: Fix autopm error during probing
      ALSA: snd-usb: try harder to find USB_DT_CS_ENDPOINT
      ALSA: sound kconfig typo
      ALSA: emu10k1: Fix dock firmware loading
      ASoC: ux500: forward declare msp_i2s_platform_data
      ASoC: davinci-mcasp: Add Support BCLK-to-LRCLK ratio for TDM modes
      ASoC: davinci-pcm, davinci-mcasp: Clean up active_serializers
      ...

commit 9eb8ae727dcb9f2530a895ee6b3496592853709d
Merge: 5561f17f2629 6f1fd93e304f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 23 19:26:00 2013 +0100

    Merge remote-tracking branch 'asoc/topic/dma' into asoc-next

commit 8c1bb4ecbca575ec89310a50c3d3dd475bf81fd0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Apr 20 19:29:02 2013 +0200

    ASoC: mxs: Setup dma data in DAI probe
    
    This allows us to access the DAI DMA data when we create the PCM. We'll use
    this when converting mxs to generic DMA engine PCM driver.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index f13bd8730b0f..d796a393968d 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -369,7 +369,6 @@ static int mxs_saif_startup(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *cpu_dai)
 {
 	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
-	snd_soc_dai_set_dma_data(cpu_dai, substream, &saif->dma_param);
 
 	/* clear error status to 0 for each re-open */
 	saif->fifo_underrun = 0;
@@ -605,6 +604,8 @@ static int mxs_saif_dai_probe(struct snd_soc_dai *dai)
 	struct mxs_saif *saif = dev_get_drvdata(dai->dev);
 
 	snd_soc_dai_set_drvdata(dai, saif);
+	dai->playback_dma_data = &saif->dma_param;
+	dai->capture_dma_data = &saif->dma_param;
 
 	return 0;
 }

commit 38e8c895d33b0642dc341f83cce0adde4cffbc82
Merge: d66e065c5b8b 69b6f19622ce
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Apr 12 13:57:04 2013 +0100

    Merge remote-tracking branch 'asoc/topic/dma' into asoc-next

commit 114fe75defb04c03c100ed22617108165d546abe
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Mar 28 23:21:16 2013 +0800

    ASoC: mxs-saif: remove mach header inclusion
    
    The header <mach/hardware.h> is not needed at all, and <mach/mxs.h> is
    needed only for macros MXS_SET_ADDR and MXS_CLR_ADDR.  Define the macros
    and remove the mach header inclusions.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 3a2aa1d19b93..41a6136e3535 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -33,11 +33,12 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <asm/mach-types.h>
-#include <mach/hardware.h>
-#include <mach/mxs.h>
 
 #include "mxs-saif.h"
 
+#define MXS_SET_ADDR	0x4
+#define MXS_CLR_ADDR	0x8
+
 static struct mxs_saif *mxs_saif[2];
 
 /*

commit 026240bb155bb8f83b9425812f52661fcbaa0629
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 21 03:33:02 2013 -0700

    ASoC: switch over to use snd_soc_register_component() on mxs saif
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 3a2aa1d19b93..3e78ba866681 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -627,6 +627,10 @@ static struct snd_soc_dai_driver mxs_saif_dai = {
 	.ops = &mxs_saif_dai_ops,
 };
 
+static const struct snd_soc_component_driver mxs_saif_component = {
+	.name		= "mxs-saif",
+};
+
 static irqreturn_t mxs_saif_irq(int irq, void *dev_id)
 {
 	struct mxs_saif *saif = dev_id;
@@ -763,7 +767,8 @@ static int mxs_saif_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, saif);
 
-	ret = snd_soc_register_dai(&pdev->dev, &mxs_saif_dai);
+	ret = snd_soc_register_component(&pdev->dev, &mxs_saif_component,
+					 &mxs_saif_dai, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "register DAI failed\n");
 		return ret;
@@ -778,7 +783,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	return 0;
 
 failed_pdev_alloc:
-	snd_soc_unregister_dai(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
 
 	return ret;
 }
@@ -786,7 +791,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 static int mxs_saif_remove(struct platform_device *pdev)
 {
 	mxs_pcm_platform_unregister(&pdev->dev);
-	snd_soc_unregister_dai(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
 
 	return 0;
 }

commit b7e5e91210fc9d40f93f87e386823e4ba9b32805
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Mar 22 14:12:13 2013 +0100

    ASoC: mxs: Embed the mxs_dma_data struct in the mxs_pcm_dma_params struct
    
    Currently the mxs_dma_data struct, which gets passed to the dmaengine driver, is
    allocated in the pcm driver's open callback. The mxs_dma_data struct has exactly
    one field which is initialized from the the same field in the mxs_pcm_dma_params
    struct. The mxs_pcm_dma_params struct gets passed to the pcm driver from the dai
    driver. Instead of taking this indirection embed the mxs_dma_data struct
    directly in the mxs_pcm_dma_params struct. This allows us to simplify the pcm
    driver quite a bit, since we don't have to care about memory managing the
    mxs_dma_data struct anymore.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 3a2aa1d19b93..f13bd8730b0f 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -753,9 +753,9 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	saif->dma_param.chan_irq = platform_get_irq(pdev, 1);
-	if (saif->dma_param.chan_irq < 0) {
-		ret = saif->dma_param.chan_irq;
+	saif->dma_param.dma_data.chan_irq = platform_get_irq(pdev, 1);
+	if (saif->dma_param.dma_data.chan_irq < 0) {
+		ret = saif->dma_param.dma_data.chan_irq;
 		dev_err(&pdev->dev, "failed to get dma irq resource: %d\n",
 			ret);
 		return ret;

commit 06991c28f37ad68e5c03777f5c3b679b56e3dac1
Merge: 460dc1eecf37 74fef7a8fd1d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 12:05:51 2013 -0800

    Merge tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core patches from Greg Kroah-Hartman:
     "Here is the big driver core merge for 3.9-rc1
    
      There are two major series here, both of which touch lots of drivers
      all over the kernel, and will cause you some merge conflicts:
    
       - add a new function called devm_ioremap_resource() to properly be
         able to check return values.
    
       - remove CONFIG_EXPERIMENTAL
    
      Other than those patches, there's not much here, some minor fixes and
      updates"
    
    Fix up trivial conflicts
    
    * tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (221 commits)
      base: memory: fix soft/hard_offline_page permissions
      drivercore: Fix ordering between deferred_probe and exiting initcalls
      backlight: fix class_find_device() arguments
      TTY: mark tty_get_device call with the proper const values
      driver-core: constify data for class_find_device()
      firmware: Ignore abort check when no user-helper is used
      firmware: Reduce ifdef CONFIG_FW_LOADER_USER_HELPER
      firmware: Make user-mode helper optional
      firmware: Refactoring for splitting user-mode helper code
      Driver core: treat unregistered bus_types as having no devices
      watchdog: Convert to devm_ioremap_resource()
      thermal: Convert to devm_ioremap_resource()
      spi: Convert to devm_ioremap_resource()
      power: Convert to devm_ioremap_resource()
      mtd: Convert to devm_ioremap_resource()
      mmc: Convert to devm_ioremap_resource()
      mfd: Convert to devm_ioremap_resource()
      media: Convert to devm_ioremap_resource()
      iommu: Convert to devm_ioremap_resource()
      drm: Convert to devm_ioremap_resource()
      ...

commit b25b5aa06667b01fee8fe2648d4ea9db32c87d1a
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Jan 21 11:09:26 2013 +0100

    ASoC: Convert to devm_ioremap_resource()
    
    Convert all uses of devm_request_and_ioremap() to the newly introduced
    devm_ioremap_resource() which provides more consistent error handling.
    
    devm_ioremap_resource() provides its own error messages so all explicit
    error messages can be removed from the failure code paths.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 365d9d27a321..b327709eb192 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -724,11 +724,9 @@ static int mxs_saif_probe(struct platform_device *pdev)
 
 	iores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
-	saif->base = devm_request_and_ioremap(&pdev->dev, iores);
-	if (!saif->base) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-		return -ENODEV;
-	}
+	saif->base = devm_ioremap_resource(&pdev->dev, iores);
+	if (IS_ERR(saif->base))
+		return PTR_ERR(saif->base);
 
 	dmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);
 	if (!dmares) {

commit 324a7fb02b9e7a226916e3593f756cd85312bae8
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Tue Jan 8 10:45:04 2013 -0200

    ASoC: mxs-saif: Use a signed integer for error value
    
    saif->id and saif->master_id are unsigned, so they can not be negative.
    
    Fix the following warning when building with W=1 option:
    
    sound/soc/mxs/mxs-saif.c: In function 'mxs_saif_probe':
    sound/soc/mxs/mxs-saif.c:676:2: warning: comparison of unsigned expression < 0 is always false [-Wtype-limits]
    sound/soc/mxs/mxs-saif.c:688:3: warning: comparison of unsigned expression < 0 is always false [-Wtype-limits]
    sound/soc/mxs/mxs-saif.c:692:2: warning: comparison of unsigned expression < 0 is always false [-Wtype-limits]
    
    Use a signed variable 'ret' to handle the error values.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 752675da0658..e70e6c844f96 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -672,9 +672,12 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	if (!saif)
 		return -ENOMEM;
 
-	saif->id = of_alias_get_id(np, "saif");
-	if (saif->id < 0)
-		return saif->id;
+	ret = of_alias_get_id(np, "saif");
+	if (ret < 0)
+		return ret;
+	else
+		saif->id = ret;
+
 	/*
 	 * If there is no "fsl,saif-master" phandle, it's a saif
 	 * master.  Otherwise, it's a slave and its phandle points
@@ -684,12 +687,14 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	if (!master) {
 		saif->master_id = saif->id;
 	} else {
-		saif->master_id = of_alias_get_id(master, "saif");
-		if (saif->master_id < 0)
-			return saif->master_id;
+		ret = of_alias_get_id(master, "saif");
+		if (ret < 0)
+			return ret;
+		else
+			saif->master_id = ret;
 	}
 
-	if (saif->master_id < 0 || saif->master_id >= ARRAY_SIZE(mxs_saif)) {
+	if (saif->master_id >= ARRAY_SIZE(mxs_saif)) {
 		dev_err(&pdev->dev, "get wrong master id\n");
 		return -EINVAL;
 	}

commit 4498a3cae5012979bbf3be2064c5ca00fe29109b
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Wed Nov 14 18:28:58 2012 -0200

    ASoC: mxs-saif: Remove platform data
    
    All MXS users have been converted to device tree and the board files have been
    removed.
    
    No need to keep platform data in the driver.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 365d9d27a321..752675da0658 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -32,7 +32,6 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
-#include <sound/saif.h>
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
 #include <mach/mxs.h>
@@ -662,43 +661,32 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	struct resource *iores, *dmares;
 	struct mxs_saif *saif;
-	struct mxs_saif_platform_data *pdata;
 	struct pinctrl *pinctrl;
 	int ret = 0;
+	struct device_node *master;
 
-
-	if (!np && pdev->id >= ARRAY_SIZE(mxs_saif))
+	if (!np)
 		return -EINVAL;
 
 	saif = devm_kzalloc(&pdev->dev, sizeof(*saif), GFP_KERNEL);
 	if (!saif)
 		return -ENOMEM;
 
-	if (np) {
-		struct device_node *master;
-		saif->id = of_alias_get_id(np, "saif");
-		if (saif->id < 0)
-			return saif->id;
-		/*
-		 * If there is no "fsl,saif-master" phandle, it's a saif
-		 * master.  Otherwise, it's a slave and its phandle points
-		 * to the master.
-		 */
-		master = of_parse_phandle(np, "fsl,saif-master", 0);
-		if (!master) {
-			saif->master_id = saif->id;
-		} else {
-			saif->master_id = of_alias_get_id(master, "saif");
-			if (saif->master_id < 0)
-				return saif->master_id;
-		}
+	saif->id = of_alias_get_id(np, "saif");
+	if (saif->id < 0)
+		return saif->id;
+	/*
+	 * If there is no "fsl,saif-master" phandle, it's a saif
+	 * master.  Otherwise, it's a slave and its phandle points
+	 * to the master.
+	 */
+	master = of_parse_phandle(np, "fsl,saif-master", 0);
+	if (!master) {
+		saif->master_id = saif->id;
 	} else {
-		saif->id = pdev->id;
-		pdata = pdev->dev.platform_data;
-		if (pdata && !pdata->master_mode)
-			saif->master_id = pdata->master_id;
-		else
-			saif->master_id = saif->id;
+		saif->master_id = of_alias_get_id(master, "saif");
+		if (saif->master_id < 0)
+			return saif->master_id;
 	}
 
 	if (saif->master_id < 0 || saif->master_id >= ARRAY_SIZE(mxs_saif)) {

commit fd582736aba64e0fe4995d47c4a1b1ade7600d74
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Dec 7 09:26:27 2012 -0500

    ASoC: mxs: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index b304e375568a..365d9d27a321 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -657,7 +657,7 @@ static irqreturn_t mxs_saif_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int __devinit mxs_saif_probe(struct platform_device *pdev)
+static int mxs_saif_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct resource *iores, *dmares;
@@ -792,7 +792,7 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit mxs_saif_remove(struct platform_device *pdev)
+static int mxs_saif_remove(struct platform_device *pdev)
 {
 	mxs_pcm_platform_unregister(&pdev->dev);
 	snd_soc_unregister_dai(&pdev->dev);
@@ -808,7 +808,7 @@ MODULE_DEVICE_TABLE(of, mxs_saif_dt_ids);
 
 static struct platform_driver mxs_saif_driver = {
 	.probe = mxs_saif_probe,
-	.remove = __devexit_p(mxs_saif_remove),
+	.remove = mxs_saif_remove,
 
 	.driver = {
 		.name = "mxs-saif",

commit cf7d0f09bacb9849ecca91f73b631fc6634df70c
Author: Lothar Waßmann <LW@KARO-electronics.de>
Date:   Thu Nov 22 13:31:09 2012 +0100

    ASoC: mxs-saif: export mxs_saif_put_mclk,mxs_saif_get_mclk
    
    Signed-off-by: Lothar Waßmann <LW@KARO-electronics.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index c294fbb523fc..b304e375568a 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -229,6 +229,7 @@ int mxs_saif_put_mclk(unsigned int saif_id)
 	saif->mclk_in_use = 0;
 	return 0;
 }
+EXPORT_SYMBOL_GPL(mxs_saif_put_mclk);
 
 /*
  * Get MCLK and set clock rate, then enable it
@@ -282,6 +283,7 @@ int mxs_saif_get_mclk(unsigned int saif_id, unsigned int mclk,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(mxs_saif_get_mclk);
 
 /*
  * SAIF DAI format configuration.

commit f55f14752ecaccf7d6a52fd13929b73fcb191f19
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Thu Nov 1 15:57:11 2012 -0200

    ASoC: mxs-saif: Fix channel swap for 24-bit format
    
    Playing 24-bit format file leads to channel swap on mx28 and the reason is that
    the current driver performs one write/read to/from the SAIF_DATA register to
    trigger the transfer.
    
    This approach works fine for S16_LE case because SAIF_DATA is a 32-bit register
    and thus is capable of storing the 16-bit left and right channels, but for the
    S24_LE case it can only store one channel, so in order to not lose the FIFO sync
    an extra read/write is needed.
    
    Reported-by: Dan Winner <DWinner@tc-helicon.com>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Tested-by: Dan Winner <DWinner@tc-helicon.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 93380cc7cf97..c294fbb523fc 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -523,16 +523,24 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			/*
-			 * write a data to saif data register to trigger
-			 * the transfer
+			 * write data to saif data register to trigger
+			 * the transfer.
+			 * For 24-bit format the 32-bit FIFO register stores
+			 * only one channel, so we need to write twice.
+			 * This is also safe for the other non 24-bit formats.
 			 */
 			__raw_writel(0, saif->base + SAIF_DATA);
+			__raw_writel(0, saif->base + SAIF_DATA);
 		} else {
 			/*
-			 * read a data from saif data register to trigger
-			 * the receive
+			 * read data from saif data register to trigger
+			 * the receive.
+			 * For 24-bit format the 32-bit FIFO register stores
+			 * only one channel, so we need to read twice.
+			 * This is also safe for the other non 24-bit formats.
 			 */
 			__raw_readl(saif->base + SAIF_DATA);
+			__raw_readl(saif->base + SAIF_DATA);
 		}
 
 		master_saif->ongoing = 1;

commit 9f4c3f1cde541d477633479a0203ef8a834ee5f9
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Wed Oct 31 01:20:05 2012 -0200

    ASoC: mxs-saif: Add MODULE_ALIAS
    
    Add MODULE_ALIAS information.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index aa037b292f3d..93380cc7cf97 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -812,3 +812,4 @@ module_platform_driver(mxs_saif_driver);
 MODULE_AUTHOR("Freescale Semiconductor, Inc.");
 MODULE_DESCRIPTION("MXS ASoC SAIF driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:mxs-saif");

commit 730963f8190b7650b0445a76e701fdef20c31cfb
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Tue Aug 7 01:29:43 2012 -0300

    ASoC: mxs-saif: Use devm_clk_get()
    
    Using devm_clk_get can make the code simpler and smaller.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index b3030718c228..aa037b292f3d 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -704,7 +704,7 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	saif->clk = clk_get(&pdev->dev, NULL);
+	saif->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(saif->clk)) {
 		ret = PTR_ERR(saif->clk);
 		dev_err(&pdev->dev, "Cannot get the clock: %d\n",
@@ -717,8 +717,7 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 	saif->base = devm_request_and_ioremap(&pdev->dev, iores);
 	if (!saif->base) {
 		dev_err(&pdev->dev, "ioremap failed\n");
-		ret = -ENODEV;
-		goto failed_get_resource;
+		return -ENODEV;
 	}
 
 	dmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);
@@ -731,7 +730,7 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 					   &saif->dma_param.chan_num);
 		if (ret) {
 			dev_err(&pdev->dev, "failed to get dma channel\n");
-			goto failed_get_resource;
+			return ret;
 		}
 	} else {
 		saif->dma_param.chan_num = dmares->start;
@@ -742,7 +741,7 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 		ret = saif->irq;
 		dev_err(&pdev->dev, "failed to get irq resource: %d\n",
 			ret);
-		goto failed_get_resource;
+		return ret;
 	}
 
 	saif->dev = &pdev->dev;
@@ -750,7 +749,7 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 			       "mxs-saif", saif);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to request irq\n");
-		goto failed_get_resource;
+		return ret;
 	}
 
 	saif->dma_param.chan_irq = platform_get_irq(pdev, 1);
@@ -758,7 +757,7 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 		ret = saif->dma_param.chan_irq;
 		dev_err(&pdev->dev, "failed to get dma irq resource: %d\n",
 			ret);
-		goto failed_get_resource;
+		return ret;
 	}
 
 	platform_set_drvdata(pdev, saif);
@@ -766,7 +765,7 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 	ret = snd_soc_register_dai(&pdev->dev, &mxs_saif_dai);
 	if (ret) {
 		dev_err(&pdev->dev, "register DAI failed\n");
-		goto failed_get_resource;
+		return ret;
 	}
 
 	ret = mxs_pcm_platform_register(&pdev->dev);
@@ -779,19 +778,14 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 
 failed_pdev_alloc:
 	snd_soc_unregister_dai(&pdev->dev);
-failed_get_resource:
-	clk_put(saif->clk);
 
 	return ret;
 }
 
 static int __devexit mxs_saif_remove(struct platform_device *pdev)
 {
-	struct mxs_saif *saif = platform_get_drvdata(pdev);
-
 	mxs_pcm_platform_unregister(&pdev->dev);
 	snd_soc_unregister_dai(&pdev->dev);
-	clk_put(saif->clk);
 
 	return 0;
 }

commit d0ba4c014934cb56f1eabb481ff8026b6d49d33c
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Fri Jul 20 17:20:25 2012 +0800

    ASoC: mxs-saif: set a base clock rate for EXTMASTER mode work
    
    Set an initial clock rate for the saif internal logic to work
    properly. This is important when working in EXTMASTER mode that
    uses the other saif's BITCLK&LRCLK but it still needs a basic
    clock which should be fast enough for the internal logic.
    
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index fdbb36aa9cf5..b3030718c228 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -427,8 +427,22 @@ static int mxs_saif_hw_params(struct snd_pcm_substream *substream,
 
 	/* prepare clk in hw_param, enable in trigger */
 	clk_prepare(saif->clk);
-	if (saif != master_saif)
+	if (saif != master_saif) {
+		/*
+		* Set an initial clock rate for the saif internal logic to work
+		* properly. This is important when working in EXTMASTER mode
+		* that uses the other saif's BITCLK&LRCLK but it still needs a
+		* basic clock which should be fast enough for the internal
+		* logic.
+		*/
+		clk_enable(saif->clk);
+		ret = clk_set_rate(saif->clk, 24000000);
+		clk_disable(saif->clk);
+		if (ret)
+			return ret;
+
 		clk_prepare(master_saif->clk);
+	}
 
 	scr = __raw_readl(saif->base + SAIF_CTRL);
 

commit c2e1d9073fc98f471067c0257a31b4818306ebe1
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Fri Jul 20 17:20:24 2012 +0800

    ASoC: mxs-saif: fix clock prepare and enable unbalance issue
    
    Currently we directly call a clock_enable in trigger function without
    a clk_prepare as pair first.
    This will cause system hang immediately when run capture because
    the clock was not prepared(playback does not hang because the clock was
    prepared already by get_mclk before), a warning message in clock framework
    may cause a deadlock to reclaim clock lock (see: pl011_console_write).
    
    Here we prepare clock first in hw_param, then enable it in trigger
    function to guarantee the balance.
    
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index aba71bfa33b1..fdbb36aa9cf5 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -394,9 +394,14 @@ static int mxs_saif_hw_params(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *cpu_dai)
 {
 	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+	struct mxs_saif *master_saif;
 	u32 scr, stat;
 	int ret;
 
+	master_saif = mxs_saif_get_master(saif);
+	if (!master_saif)
+		return -EINVAL;
+
 	/* mclk should already be set */
 	if (!saif->mclk && saif->mclk_in_use) {
 		dev_err(cpu_dai->dev, "set mclk first\n");
@@ -420,6 +425,11 @@ static int mxs_saif_hw_params(struct snd_pcm_substream *substream,
 		return ret;
 	}
 
+	/* prepare clk in hw_param, enable in trigger */
+	clk_prepare(saif->clk);
+	if (saif != master_saif)
+		clk_prepare(master_saif->clk);
+
 	scr = __raw_readl(saif->base + SAIF_CTRL);
 
 	scr &= ~BM_SAIF_CTRL_WORD_LENGTH;

commit 2e341ca686042aa464efa755447e7bcee91d1eb6
Merge: 927ad5510317 85e184e4c3cd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 23 13:05:43 2012 -0700

    Merge tag 'sound-3.5' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This is the first big chunk for 3.5 merges of sound stuff.
    
      There are a few big changes in different areas.  First off, the
      streaming logic of USB-audio endpoints has been largely rewritten for
      the better support of "implicit feedback".  If anything about USB got
      broken, this change has to be checked.
    
      For HD-audio, the resume procedure was changed; instead of delaying
      the resume of the hardware until the first use, now waking up
      immediately at resume.  This is for buggy BIOS.
    
      For ASoC, dynamic PCM support and the improved support for digital
      links between off-SoC devices are major framework changes.
    
      Some highlights are below:
    
      * HD-audio
       - Avoid accesses of invalid pin-control bits that may stall the codec
       - V-ref setup cleanups
       - Fix the races in power-saving code
       - Fix the races in codec cache hashes and connection lists
       - Split some common codes for BIOS auto-parser to hda_auto_parser.c
       - Changed the PM resume code to wake up immediately for buggy BIOS
       - Creative SoundCore3D support
       - Add Conexant CX20751/2/3/4 codec support
    
      * ASoC
       - Dynamic PCM support, allowing support for SoCs with internal
         routing through components with tight sequencing and formatting
         constraints within their internal paths or where there are multiple
         components connected with CPU managed DMA controllers inside the
         SoC.
       - Greatly improved support for direct digital links between off-SoC
         devices, providing a much simpler way of connecting things like
         digital basebands to CODECs.
       - Much more fine grained and robust locking, cleaning up some of the
         confusion that crept in with multi-component.
       - CPU support for nVidia Tegra 30 I2S and audio hub controllers and
         ST-Ericsson MSP I2S controolers
       - New CODEC drivers for Cirrus CS42L52, LAPIS Semiconductor ML26124,
         Texas Instruments LM49453.
       - Some regmap changes needed by the Tegra I2S driver.
       - mc13783 audio support.
    
      * Misc
       - Rewrite with module_pci_driver()
       - Xonar DGX support for snd-oxygen
       - Improvement of packet handling in snd-firewire driver
       - New USB-endpoint streaming logic
       - Enhanced M-audio FTU quirks and relevant cleanups
       - Increment the support of OSS devices to 256
       - snd-aloop accuracy improvement
    
      There are a few more pending changes for 3.5, but they will be sent
      slightly later as partly depending on the changes of DRM."
    
    Fix up conflicts in regmap (due to duplicate patches, with some further
    updates then having already come in from the regmap tree).  Also some
    fairly trivial context conflicts in the imx and mcx soc drivers.
    
    * tag 'sound-3.5' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (280 commits)
      ALSA: snd-usb: fix stream info output in /proc
      ALSA: pcm - Add proper state checks to snd_pcm_drain()
      ALSA: sh: Fix up namespace collision in sh_dac_audio.
      ALSA: hda/realtek - Fix unused variable compile warning
      ASoC: sh: fsi: enable chip specific data transfer mode
      ASoC: sh: fsi: call fsi_hw_startup/shutdown from fsi_dai_trigger()
      ASoC: sh: fsi: use same format for IN/OUT
      ASoC: sh: fsi: add fsi_version() and removed meaningless version check
      ASoC: sh: fsi: use register field macro name on IN/OUT_DMAC
      ASoC: tegra: Add machine driver for WM8753 codec
      ALSA: hda - Fix possible races of accesses to connection list array
      ASoC: OMAP: HDMI: Introduce codec
      ARM: mx31_3ds: Add sound support
      ASoC: imx-mc13783 cleanup
      mx31moboard: Add sound support
      ASoC: mc13783 codec cleanups
      ASoC: add imx-mc13783 sound support
      ASoC: Add mc13783 codec
      mfd: mc13xxx: add codec platform data
      ASoC: don't flip master of DT-instantiated DAI links
      ...

commit 08641c7c74dddfcd726512edfaa3b4cbe42e523e
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Fri May 11 22:24:17 2012 +0800

    ASoC: mxs: add device tree support for mxs-saif
    
    Add device tree probe for mxs-saif driver.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 356aad83c1fe..064274880673 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -18,6 +18,8 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
@@ -622,34 +624,54 @@ static irqreturn_t mxs_saif_irq(int irq, void *dev_id)
 
 static int __devinit mxs_saif_probe(struct platform_device *pdev)
 {
+	struct device_node *np = pdev->dev.of_node;
 	struct resource *iores, *dmares;
 	struct mxs_saif *saif;
 	struct mxs_saif_platform_data *pdata;
 	int ret = 0;
 
-	if (pdev->id >= ARRAY_SIZE(mxs_saif))
+
+	if (!np && pdev->id >= ARRAY_SIZE(mxs_saif))
 		return -EINVAL;
 
 	saif = devm_kzalloc(&pdev->dev, sizeof(*saif), GFP_KERNEL);
 	if (!saif)
 		return -ENOMEM;
 
-	mxs_saif[pdev->id] = saif;
-	saif->id = pdev->id;
-
-	pdata = pdev->dev.platform_data;
-	if (pdata && !pdata->master_mode) {
-		saif->master_id = pdata->master_id;
-		if (saif->master_id < 0 ||
-			saif->master_id >= ARRAY_SIZE(mxs_saif) ||
-			saif->master_id == saif->id) {
-			dev_err(&pdev->dev, "get wrong master id\n");
-			return -EINVAL;
+	if (np) {
+		struct device_node *master;
+		saif->id = of_alias_get_id(np, "saif");
+		if (saif->id < 0)
+			return saif->id;
+		/*
+		 * If there is no "fsl,saif-master" phandle, it's a saif
+		 * master.  Otherwise, it's a slave and its phandle points
+		 * to the master.
+		 */
+		master = of_parse_phandle(np, "fsl,saif-master", 0);
+		if (!master) {
+			saif->master_id = saif->id;
+		} else {
+			saif->master_id = of_alias_get_id(master, "saif");
+			if (saif->master_id < 0)
+				return saif->master_id;
 		}
 	} else {
-		saif->master_id = saif->id;
+		saif->id = pdev->id;
+		pdata = pdev->dev.platform_data;
+		if (pdata && !pdata->master_mode)
+			saif->master_id = pdata->master_id;
+		else
+			saif->master_id = saif->id;
+	}
+
+	if (saif->master_id < 0 || saif->master_id >= ARRAY_SIZE(mxs_saif)) {
+		dev_err(&pdev->dev, "get wrong master id\n");
+		return -EINVAL;
 	}
 
+	mxs_saif[saif->id] = saif;
+
 	saif->clk = clk_get(&pdev->dev, NULL);
 	if (IS_ERR(saif->clk)) {
 		ret = PTR_ERR(saif->clk);
@@ -669,12 +691,19 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 
 	dmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);
 	if (!dmares) {
-		ret = -ENODEV;
-		dev_err(&pdev->dev, "failed to get dma resource: %d\n",
-			ret);
-		goto failed_get_resource;
+		/*
+		 * TODO: This is a temporary solution and should be changed
+		 * to use generic DMA binding later when the helplers get in.
+		 */
+		ret = of_property_read_u32(np, "fsl,saif-dma-channel",
+					   &saif->dma_param.chan_num);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to get dma channel\n");
+			goto failed_get_resource;
+		}
+	} else {
+		saif->dma_param.chan_num = dmares->start;
 	}
-	saif->dma_param.chan_num = dmares->start;
 
 	saif->irq = platform_get_irq(pdev, 0);
 	if (saif->irq < 0) {
@@ -735,6 +764,12 @@ static int __devexit mxs_saif_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id mxs_saif_dt_ids[] = {
+	{ .compatible = "fsl,imx28-saif", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, mxs_saif_dt_ids);
+
 static struct platform_driver mxs_saif_driver = {
 	.probe = mxs_saif_probe,
 	.remove = __devexit_p(mxs_saif_remove),
@@ -742,6 +777,7 @@ static struct platform_driver mxs_saif_driver = {
 	.driver = {
 		.name = "mxs-saif",
 		.owner = THIS_MODULE,
+		.of_match_table = mxs_saif_dt_ids,
 	},
 };
 

commit 4da3fe7851f9288c2479186d390b0de28d51bdb0
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Fri May 11 22:24:16 2012 +0800

    ASoC: mxs: mxs-pcm does not need to be a plaform_driver
    
    Same as the commit 518de86 (ASoC: tegra: register 'platform' from DAIs,
    get rid of pdev), it makes mxs-pcm not a platform_driver but helper to
    register "platform", so that the platform_device for mxs-pcm can be
    saved completely.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index a7b8657690a9..356aad83c1fe 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -708,24 +708,14 @@ static int __devinit mxs_saif_probe(struct platform_device *pdev)
 		goto failed_get_resource;
 	}
 
-	saif->soc_platform_pdev = platform_device_alloc(
-					"mxs-pcm-audio", pdev->id);
-	if (!saif->soc_platform_pdev) {
-		ret = -ENOMEM;
-		goto failed_pdev_alloc;
-	}
-
-	platform_set_drvdata(saif->soc_platform_pdev, saif);
-	ret = platform_device_add(saif->soc_platform_pdev);
+	ret = mxs_pcm_platform_register(&pdev->dev);
 	if (ret) {
-		dev_err(&pdev->dev, "failed to add soc platform device\n");
-		goto failed_pdev_add;
+		dev_err(&pdev->dev, "register PCM failed: %d\n", ret);
+		goto failed_pdev_alloc;
 	}
 
 	return 0;
 
-failed_pdev_add:
-	platform_device_put(saif->soc_platform_pdev);
 failed_pdev_alloc:
 	snd_soc_unregister_dai(&pdev->dev);
 failed_get_resource:
@@ -738,7 +728,7 @@ static int __devexit mxs_saif_remove(struct platform_device *pdev)
 {
 	struct mxs_saif *saif = platform_get_drvdata(pdev);
 
-	platform_device_unregister(saif->soc_platform_pdev);
+	mxs_pcm_platform_unregister(&pdev->dev);
 	snd_soc_unregister_dai(&pdev->dev);
 	clk_put(saif->clk);
 

commit f755865f9082a6632f06b8314068a883508d91ca
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sun May 6 23:00:50 2012 +0800

    ASoC: mxs-saif: adopt pinctrl support
    
    Cc: alsa-devel@alsa-project.org
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 53f4fd8feced..7fd224bb7324 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -25,6 +25,7 @@
 #include <linux/delay.h>
 #include <linux/time.h>
 #include <linux/fsl/mxs-dma.h>
+#include <linux/pinctrl/consumer.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -625,6 +626,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	struct resource *iores, *dmares;
 	struct mxs_saif *saif;
 	struct mxs_saif_platform_data *pdata;
+	struct pinctrl *pinctrl;
 	int ret = 0;
 
 	if (pdev->id >= ARRAY_SIZE(mxs_saif))
@@ -650,6 +652,12 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		saif->master_id = saif->id;
 	}
 
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		ret = PTR_ERR(pinctrl);
+		return ret;
+	}
+
 	saif->clk = clk_get(&pdev->dev, NULL);
 	if (IS_ERR(saif->clk)) {
 		ret = PTR_ERR(saif->clk);

commit 9d0403e8a16bc9790ab4211b8289836c8765aa0f
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu May 10 16:42:08 2012 +0800

    ASoC: mxs: add __devinit for mxs_saif_probe
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 53f4fd8feced..a7b8657690a9 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -620,7 +620,7 @@ static irqreturn_t mxs_saif_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int mxs_saif_probe(struct platform_device *pdev)
+static int __devinit mxs_saif_probe(struct platform_device *pdev)
 {
 	struct resource *iores, *dmares;
 	struct mxs_saif *saif;

commit 623ff7739e7c00fa3d55dbfd42a492a68298fd7a
Merge: c39e8ede284f 7b0e67f604e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 30 17:31:56 2012 -0700

    Merge tag 'for-linus-3.4' of git://git.infradead.org/mtd-2.6
    
    Pull MTD changes from David Woodhouse:
     - Artem's cleanup of the MTD API continues apace.
     - Fixes and improvements for ST FSMC and SuperH FLCTL NAND, amongst
       others.
     - More work on DiskOnChip G3, new driver for DiskOnChip G4.
     - Clean up debug/warning printks in JFFS2 to use pr_<level>.
    
    Fix up various trivial conflicts, largely due to changes in calling
    conventions for things like dmaengine_prep_slave_sg() (new inline
    wrapper to hide new parameter, clashing with rewrite of previously last
    parameter that used to be an 'append' flag, and is now a bitmap of
    'unsigned long flags').
    
    (Also some header file fallout - like so many merges this merge window -
    and silly conflicts with sparse fixes)
    
    * tag 'for-linus-3.4' of git://git.infradead.org/mtd-2.6: (120 commits)
      mtd: docg3 add protection against concurrency
      mtd: docg3 refactor cascade floors structure
      mtd: docg3 increase write/erase timeout
      mtd: docg3 fix inbound calculations
      mtd: nand: gpmi: fix function annotations
      mtd: phram: fix section mismatch for phram_setup
      mtd: unify initialization of erase_info->fail_addr
      mtd: support ONFI multi lun NAND
      mtd: sm_ftl: fix typo in major number.
      mtd: add device-tree support to spear_smi
      mtd: spear_smi: Remove default partition information from driver
      mtd: Add device-tree support to fsmc_nand
      mtd: fix section mismatch for doc_probe_device
      mtd: nand/fsmc: Remove sparse warnings and errors
      mtd: nand/fsmc: Add DMA support
      mtd: nand/fsmc: Access the NAND device word by word whenever possible
      mtd: nand/fsmc: Use dev_err to report error scenario
      mtd: nand/fsmc: Use devm routines
      mtd: nand/fsmc: Modify fsmc driver to accept nand timing parameters via platform
      mtd: fsmc_nand: add pm callbacks to support hibernation
      ...

commit 3946860409130038ef6e0e5c50f2203053eae2b7
Author: Huang Shijie <b32955@freescale.com>
Date:   Thu Feb 16 14:17:32 2012 +0800

    mxs-dma : move the mxs dma.h to a more common place
    
    Move the header to a more common place.
    The mxs dma engine is not only used in mx23/mx28, but also used
    in mx50/mx6q.  It will also be used in the future chips.
    
    Rename it to mxs-dma.h, and create a new folder include/linux/fsl/ to
    store the Freescale's header files.
    
    change mxs-dma driver, mxs-mmc driver, gpmi-nand driver, mxs-saif driver
    to the new header file.
    
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Acked-by: Vinod Koul <vinod.koul@linux.intel.com>
    Acked-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index f204dbac11d4..ce591123d994 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -24,12 +24,12 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/time.h>
+#include <linux/fsl/mxs-dma.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/saif.h>
-#include <mach/dma.h>
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
 #include <mach/mxs.h>

commit 830eb8767d76b058118be74deac13e5f30b67892
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Feb 10 09:17:01 2012 +0100

    ASoC: mxs-saif: use devm_ functions
    
    The various devm_ functions allocate memory that is released when a driver
    detaches.  This patch uses these functions for data that is allocated in
    the probe function of a platform device and is only freed in the remove
    function.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index f204dbac11d4..12be05b16880 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -630,7 +630,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	if (pdev->id >= ARRAY_SIZE(mxs_saif))
 		return -EINVAL;
 
-	saif = kzalloc(sizeof(*saif), GFP_KERNEL);
+	saif = devm_kzalloc(&pdev->dev, sizeof(*saif), GFP_KERNEL);
 	if (!saif)
 		return -ENOMEM;
 
@@ -655,29 +655,16 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		ret = PTR_ERR(saif->clk);
 		dev_err(&pdev->dev, "Cannot get the clock: %d\n",
 			ret);
-		goto failed_clk;
+		return ret;
 	}
 
 	iores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!iores) {
-		ret = -ENODEV;
-		dev_err(&pdev->dev, "failed to get io resource: %d\n",
-			ret);
-		goto failed_get_resource;
-	}
 
-	if (!request_mem_region(iores->start, resource_size(iores),
-				"mxs-saif")) {
-		dev_err(&pdev->dev, "request_mem_region failed\n");
-		ret = -EBUSY;
-		goto failed_get_resource;
-	}
-
-	saif->base = ioremap(iores->start, resource_size(iores));
+	saif->base = devm_request_and_ioremap(&pdev->dev, iores);
 	if (!saif->base) {
 		dev_err(&pdev->dev, "ioremap failed\n");
 		ret = -ENODEV;
-		goto failed_ioremap;
+		goto failed_get_resource;
 	}
 
 	dmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);
@@ -685,7 +672,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		ret = -ENODEV;
 		dev_err(&pdev->dev, "failed to get dma resource: %d\n",
 			ret);
-		goto failed_ioremap;
+		goto failed_get_resource;
 	}
 	saif->dma_param.chan_num = dmares->start;
 
@@ -694,14 +681,15 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		ret = saif->irq;
 		dev_err(&pdev->dev, "failed to get irq resource: %d\n",
 			ret);
-		goto failed_get_irq1;
+		goto failed_get_resource;
 	}
 
 	saif->dev = &pdev->dev;
-	ret = request_irq(saif->irq, mxs_saif_irq, 0, "mxs-saif", saif);
+	ret = devm_request_irq(&pdev->dev, saif->irq, mxs_saif_irq, 0,
+			       "mxs-saif", saif);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to request irq\n");
-		goto failed_get_irq1;
+		goto failed_get_resource;
 	}
 
 	saif->dma_param.chan_irq = platform_get_irq(pdev, 1);
@@ -709,7 +697,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		ret = saif->dma_param.chan_irq;
 		dev_err(&pdev->dev, "failed to get dma irq resource: %d\n",
 			ret);
-		goto failed_get_irq2;
+		goto failed_get_resource;
 	}
 
 	platform_set_drvdata(pdev, saif);
@@ -717,7 +705,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	ret = snd_soc_register_dai(&pdev->dev, &mxs_saif_dai);
 	if (ret) {
 		dev_err(&pdev->dev, "register DAI failed\n");
-		goto failed_register;
+		goto failed_get_resource;
 	}
 
 	saif->soc_platform_pdev = platform_device_alloc(
@@ -740,36 +728,19 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	platform_device_put(saif->soc_platform_pdev);
 failed_pdev_alloc:
 	snd_soc_unregister_dai(&pdev->dev);
-failed_register:
-failed_get_irq2:
-	free_irq(saif->irq, saif);
-failed_get_irq1:
-	iounmap(saif->base);
-failed_ioremap:
-	release_mem_region(iores->start, resource_size(iores));
 failed_get_resource:
 	clk_put(saif->clk);
-failed_clk:
-	kfree(saif);
 
 	return ret;
 }
 
 static int __devexit mxs_saif_remove(struct platform_device *pdev)
 {
-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	struct mxs_saif *saif = platform_get_drvdata(pdev);
 
 	platform_device_unregister(saif->soc_platform_pdev);
-
 	snd_soc_unregister_dai(&pdev->dev);
-
-	iounmap(saif->base);
-	release_mem_region(res->start, resource_size(res));
-	free_irq(saif->irq, saif);
-
 	clk_put(saif->clk);
-	kfree(saif);
 
 	return 0;
 }

commit 6b35f924b80a0e6d71711e66f5b3c16f427f3d2a
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Thu Jan 19 10:23:22 2012 -0200

    ASoC: mxs: Fix mxs-saif timeout
    
    On a mx28evk board the following errors happens on mxs-sgtl5000 probe:
    
    [    0.660000] saif0_clk_set_rate: divider writing timeout
    [    0.670000] mxs-sgtl5000: probe of mxs-sgtl5000.0 failed with error -110
    [    0.670000] ALSA device list:
    [    0.680000]   No soundcards found.
    
    This timeout happens because clk_set_rate will result in writing to the DIV bits
    of register HW_CLKCTRL_SAIF0 with the saif clock gated (CLKGATE bit set to one).
    
    MX28 Reference states the following about CLKGATE:
    
    "The DIV field can change ONLY when this clock gate bit field is low."
    
    So call clk_prepare_enable prior to clk_set_rate to fix this problem.
    
    After this change the mxs-saif driver can be correctly probed and audio is functional.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index dccfb37a9626..f204dbac11d4 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -124,6 +124,8 @@ static int mxs_saif_set_clk(struct mxs_saif *saif,
 	 *
 	 * If MCLK is not used, we just set saif clk to 512*fs.
 	 */
+	clk_prepare_enable(master_saif->clk);
+
 	if (master_saif->mclk_in_use) {
 		if (mclk % 32 == 0) {
 			scr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;
@@ -133,6 +135,7 @@ static int mxs_saif_set_clk(struct mxs_saif *saif,
 			ret = clk_set_rate(master_saif->clk, 384 * rate);
 		} else {
 			/* SAIF MCLK should be either 32x or 48x */
+			clk_disable_unprepare(master_saif->clk);
 			return -EINVAL;
 		}
 	} else {
@@ -140,6 +143,8 @@ static int mxs_saif_set_clk(struct mxs_saif *saif,
 		scr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;
 	}
 
+	clk_disable_unprepare(master_saif->clk);
+
 	if (ret)
 		return ret;
 

commit a429638cac1e5c656818a45aaff78df7b743004e
Merge: 5cf9a4e69c1f 9e4ce164ee3a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 12 08:00:30 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (526 commits)
      ASoC: twl6040 - Add method to query optimum PDM_DL1 gain
      ALSA: hda - Fix the lost power-setup of seconary pins after PM resume
      ALSA: usb-audio: add Yamaha MOX6/MOX8 support
      ALSA: virtuoso: add S/PDIF input support for all Xonars
      ALSA: ice1724 - Support for ooAoo SQ210a
      ALSA: ice1724 - Allow card info based on model only
      ALSA: ice1724 - Create capture pcm only for ADC-enabled configurations
      ALSA: hdspm - Provide unique driver id based on card serial
      ASoC: Dynamically allocate the rtd device for a non-empty release()
      ASoC: Fix recursive dependency due to select ATMEL_SSC in SND_ATMEL_SOC_SSC
      ALSA: hda - Fix the detection of "Loopback Mixing" control for VIA codecs
      ALSA: hda - Return the error from get_wcaps_type() for invalid NIDs
      ALSA: hda - Use auto-parser for HP laptops with cx20459 codec
      ALSA: asihpi - Fix potential Oops in snd_asihpi_cmode_info()
      ALSA: hdsp - Fix potential Oops in snd_hdsp_info_pref_sync_ref()
      ALSA: hda/cirrus - support for iMac12,2 model
      ASoC: cx20442: add bias control over a platform provided regulator
      ALSA: usb-audio - Avoid flood of frame-active debug messages
      ALSA: snd-usb-us122l: Delete calls to preempt_disable
      mfd: Put WM8994 into cache only mode when suspending
      ...
    
    Fix up trivial conflicts in:
     - arch/arm/mach-s3c64xx/mach-crag6410.c:
            renamed speyside_wm8962 to tobermory, added littlemill right
            next to it
     - drivers/base/regmap/{regcache.c,regmap.c}:
            duplicate diff that had already come in with other changes in
            the regmap tree

commit 979ecef5b89a8003902299566d9cdc08de34a3ee
Merge: e8cbce976050 8c3b2296f1aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 9 14:44:15 2012 -0800

    Merge tag 'clk' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    clock management changes for i.MX
    
    Another simple series related to clock management, this time only for
    imx.
    
    * tag 'clk' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: mxs: select HAVE_CLK_PREPARE for clock
      clk: add config option HAVE_CLK_PREPARE into Kconfig
      ASoC: mxs-saif: convert to clk_prepare/clk_unprepare
      video: mxsfb: convert to clk_prepare/clk_unprepare
      serial: mxs-auart: convert to clk_prepare/clk_unprepare
      net: flexcan: convert to clk_prepare/clk_unprepare
      mtd: gpmi-lib: convert to clk_prepare/clk_unprepare
      mmc: mxs-mmc: convert to clk_prepare/clk_unprepare
      dma: mxs-dma: convert to clk_prepare/clk_unprepare
      net: fec: add clk_prepare/clk_unprepare
      ARM: mxs: convert platform code to clk_prepare/clk_unprepare
      clk: add helper functions clk_prepare_enable and clk_disable_unprepare
    
    Fix up trivial conflicts in drivers/net/ethernet/freescale/fec.c due to
    commit 0ebafefcaa7a ("net: fec: add clk_prepare/clk_unprepare") clashing
    trivially with commit e163cc97f9ac ("net/fec: fix the .remove code").

commit 67939b22dadd6c5cbf7a4abe9eaec3a8415569a7
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Dec 20 14:15:44 2011 +0800

    ASoC: mxs-saif: convert to clk_prepare/clk_unprepare
    
    The patch converts mxs-saif driver to clk_prepare/clk_unprepare by
    using helper functions clk_prepare_enable/clk_disable_unprepare.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Dong Aisheng <b29396@freescale.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Marek Vasut <marek.vasut@gmail.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 76dc74d24fc2..ef1abb53af95 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -210,7 +210,7 @@ int mxs_saif_put_mclk(unsigned int saif_id)
 		return -EBUSY;
 	}
 
-	clk_disable(saif->clk);
+	clk_disable_unprepare(saif->clk);
 
 	/* disable MCLK output */
 	__raw_writel(BM_SAIF_CTRL_CLKGATE,
@@ -264,7 +264,7 @@ int mxs_saif_get_mclk(unsigned int saif_id, unsigned int mclk,
 	if (ret)
 		return ret;
 
-	ret = clk_enable(saif->clk);
+	ret = clk_prepare_enable(saif->clk);
 	if (ret)
 		return ret;
 

commit 778825801d9dc3745417d295344b5b1e27de0d86
Author: Dong Aisheng <b29396@freescale.com>
Date:   Tue Nov 22 23:52:21 2011 +0800

    ASoC: mxs-saif: remove function in platform_data
    
    Add master_mode and master_id in platfrom_data since it's board
    specific and board knows it.
    Then we can remove the function pointer in platfrom_data to make
    the driver more devicetree friendly.
    
    Signed-off-by: Dong Aisheng <b29396@freescale.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 76dc74d24fc2..1ef697fe1731 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -625,13 +625,6 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	if (pdev->id >= ARRAY_SIZE(mxs_saif))
 		return -EINVAL;
 
-	pdata = pdev->dev.platform_data;
-	if (pdata && pdata->init) {
-		ret = pdata->init();
-		if (ret)
-			return ret;
-	}
-
 	saif = kzalloc(sizeof(*saif), GFP_KERNEL);
 	if (!saif)
 		return -ENOMEM;
@@ -639,12 +632,17 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	mxs_saif[pdev->id] = saif;
 	saif->id = pdev->id;
 
-	saif->master_id = saif->id;
-	if (pdata && pdata->get_master_id) {
-		saif->master_id = pdata->get_master_id(saif->id);
+	pdata = pdev->dev.platform_data;
+	if (pdata && !pdata->master_mode) {
+		saif->master_id = pdata->master_id;
 		if (saif->master_id < 0 ||
-			saif->master_id >= ARRAY_SIZE(mxs_saif))
+			saif->master_id >= ARRAY_SIZE(mxs_saif) ||
+			saif->master_id == saif->id) {
+			dev_err(&pdev->dev, "get wrong master id\n");
 			return -EINVAL;
+		}
+	} else {
+		saif->master_id = saif->id;
 	}
 
 	saif->clk = clk_get(&pdev->dev, NULL);

commit 85aa0960d8ef22edbb092446559b3b700a5512ef
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Nov 24 14:21:29 2011 +0800

    ASoC: Convert mxs directory to module_platform_driver
    
    Factor out some boilerplate code.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 46d76b52529b..1a13ab8b8e0d 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -781,18 +781,8 @@ static struct platform_driver mxs_saif_driver = {
 	},
 };
 
-static int __init mxs_saif_init(void)
-{
-	return platform_driver_register(&mxs_saif_driver);
-}
-
-static void __exit mxs_saif_exit(void)
-{
-	platform_driver_unregister(&mxs_saif_driver);
-}
+module_platform_driver(mxs_saif_driver);
 
-module_init(mxs_saif_init);
-module_exit(mxs_saif_exit);
 MODULE_AUTHOR("Freescale Semiconductor, Inc.");
 MODULE_DESCRIPTION("MXS ASoC SAIF driver");
 MODULE_LICENSE("GPL");

commit 85e7652d89293a6dab42bfd31f276f8bc072d4c5
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 23 11:40:40 2011 +0100

    ASoC: Constify snd_soc_dai_ops structs
    
    Commit 1ee46ebd("ASoC: Make the DAI ops constant in the DAI structure")
    introduced the possibility to have constant DAI ops structures, yet this is
    barley used in both existing drivers and also new drivers being submitted,
    although none of them modifies its DAI ops structure. The later is not
    surprising since existing drivers are often used as templates for new drivers.
    So this patch just constifies all existing snd_soc_dai_ops structs to eliminate
    the issue altogether.
    
    The patch was generated with the following coccinelle semantic patch:
    // <smpl>
    @@
    identifier ops;
    @@
    -struct snd_soc_dai_ops ops =
    +const struct snd_soc_dai_ops ops =
    { ... };
    // </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 76dc74d24fc2..46d76b52529b 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -550,7 +550,7 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
 	SNDRV_PCM_FMTBIT_S24_LE)
 
-static struct snd_soc_dai_ops mxs_saif_dai_ops = {
+static const struct snd_soc_dai_ops mxs_saif_dai_ops = {
 	.startup = mxs_saif_startup,
 	.trigger = mxs_saif_trigger,
 	.prepare = mxs_saif_prepare,

commit 226d0f22d044f0151287bb7cf334b85182248f0e
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Oct 18 17:06:39 2011 +0200

    ASoC: keep pointer to resource so it can be freed
    
    Add a new variable for storing resources accessed subsequent to the one
    accessed using request_mem_region, so the one accessed using
    request_mem_region can be released if needed.
    
    The resource variable names are also changed to be more descriptive.
    
    This code is also missing some calls to iounmap.
    
    The semantic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    expression E, E1;
    identifier f;
    statement S1,S2,S3;
    @@
    
    if (E == NULL)
    {
      ... when != if (E == NULL || ...) S1 else S2
          when != E = E1
    *E->f
      ... when any
      return ...;
    }
    else S3
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 401944cf4560..76dc74d24fc2 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -617,7 +617,7 @@ static irqreturn_t mxs_saif_irq(int irq, void *dev_id)
 
 static int mxs_saif_probe(struct platform_device *pdev)
 {
-	struct resource *res;
+	struct resource *iores, *dmares;
 	struct mxs_saif *saif;
 	struct mxs_saif_platform_data *pdata;
 	int ret = 0;
@@ -655,35 +655,36 @@ static int mxs_saif_probe(struct platform_device *pdev)
 		goto failed_clk;
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
+	iores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!iores) {
 		ret = -ENODEV;
 		dev_err(&pdev->dev, "failed to get io resource: %d\n",
 			ret);
 		goto failed_get_resource;
 	}
 
-	if (!request_mem_region(res->start, resource_size(res), "mxs-saif")) {
+	if (!request_mem_region(iores->start, resource_size(iores),
+				"mxs-saif")) {
 		dev_err(&pdev->dev, "request_mem_region failed\n");
 		ret = -EBUSY;
 		goto failed_get_resource;
 	}
 
-	saif->base = ioremap(res->start, resource_size(res));
+	saif->base = ioremap(iores->start, resource_size(iores));
 	if (!saif->base) {
 		dev_err(&pdev->dev, "ioremap failed\n");
 		ret = -ENODEV;
 		goto failed_ioremap;
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
-	if (!res) {
+	dmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (!dmares) {
 		ret = -ENODEV;
 		dev_err(&pdev->dev, "failed to get dma resource: %d\n",
 			ret);
 		goto failed_ioremap;
 	}
-	saif->dma_param.chan_num = res->start;
+	saif->dma_param.chan_num = dmares->start;
 
 	saif->irq = platform_get_irq(pdev, 0);
 	if (saif->irq < 0) {
@@ -742,7 +743,7 @@ static int mxs_saif_probe(struct platform_device *pdev)
 failed_get_irq1:
 	iounmap(saif->base);
 failed_ioremap:
-	release_mem_region(res->start, resource_size(res));
+	release_mem_region(iores->start, resource_size(iores));
 failed_get_resource:
 	clk_put(saif->clk);
 failed_clk:

commit 76067540c642b1a14679ab74bd027a074c23e63b
Author: Dong Aisheng <b29396@freescale.com>
Date:   Wed Sep 7 20:51:50 2011 +0800

    ASoC: mxs-saif: add record function
    
    1. add different clkmux mode handling
    SAIF can use two instances to implement full duplex (playback &
    recording) and record saif may work on EXTMASTER mode which is
    using other saif's BITCLK&LRCLK.
    
    The clkmux mode could be set in pdata->init() in mach-specific code.
    For generic saif driver, it only needs to know who is his master
    and the master id is also provided in mach-specific code.
    
    2. support playback and capture simutaneously however the sample
    rates can not be different due to hw limitation.
    
    Signed-off-by: Dong Aisheng <b29396@freescale.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index af5734f6dab7..401944cf4560 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -23,10 +23,12 @@
 #include <linux/dma-mapping.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
+#include <sound/saif.h>
 #include <mach/dma.h>
 #include <asm/mach-types.h>
 #include <mach/hardware.h>
@@ -36,6 +38,24 @@
 
 static struct mxs_saif *mxs_saif[2];
 
+/*
+ * SAIF is a little different with other normal SOC DAIs on clock using.
+ *
+ * For MXS, two SAIF modules are instantiated on-chip.
+ * Each SAIF has a set of clock pins and can be operating in master
+ * mode simultaneously if they are connected to different off-chip codecs.
+ * Also, one of the two SAIFs can master or drive the clock pins while the
+ * other SAIF, in slave mode, receives clocking from the master SAIF.
+ * This also means that both SAIFs must operate at the same sample rate.
+ *
+ * We abstract this as each saif has a master, the master could be
+ * himself or other saifs. In the generic saif driver, saif does not need
+ * to know the different clkmux. Saif only needs to know who is his master
+ * and operating his master to generate the proper clock rate for him.
+ * The master id is provided in mach-specific layer according to different
+ * clkmux setting.
+ */
+
 static int mxs_saif_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
 			int clk_id, unsigned int freq, int dir)
 {
@@ -51,6 +71,17 @@ static int mxs_saif_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
 	return 0;
 }
 
+/*
+ * Since SAIF may work on EXTMASTER mode, IOW, it's working BITCLK&LRCLK
+ * is provided by other SAIF, we provide a interface here to get its master
+ * from its master_id.
+ * Note that the master could be himself.
+ */
+static inline struct mxs_saif *mxs_saif_get_master(struct mxs_saif * saif)
+{
+	return mxs_saif[saif->master_id];
+}
+
 /*
  * Set SAIF clock and MCLK
  */
@@ -60,8 +91,26 @@ static int mxs_saif_set_clk(struct mxs_saif *saif,
 {
 	u32 scr;
 	int ret;
+	struct mxs_saif *master_saif;
 
-	scr = __raw_readl(saif->base + SAIF_CTRL);
+	dev_dbg(saif->dev, "mclk %d rate %d\n", mclk, rate);
+
+	/* Set master saif to generate proper clock */
+	master_saif = mxs_saif_get_master(saif);
+	if (!master_saif)
+		return -EINVAL;
+
+	dev_dbg(saif->dev, "master saif%d\n", master_saif->id);
+
+	/* Checking if can playback and capture simutaneously */
+	if (master_saif->ongoing && rate != master_saif->cur_rate) {
+		dev_err(saif->dev,
+			"can not change clock, master saif%d(rate %d) is ongoing\n",
+			master_saif->id, master_saif->cur_rate);
+		return -EINVAL;
+	}
+
+	scr = __raw_readl(master_saif->base + SAIF_CTRL);
 	scr &= ~BM_SAIF_CTRL_BITCLK_MULT_RATE;
 	scr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;
 
@@ -75,27 +124,29 @@ static int mxs_saif_set_clk(struct mxs_saif *saif,
 	 *
 	 * If MCLK is not used, we just set saif clk to 512*fs.
 	 */
-	if (saif->mclk_in_use) {
+	if (master_saif->mclk_in_use) {
 		if (mclk % 32 == 0) {
 			scr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;
-			ret = clk_set_rate(saif->clk, 512 * rate);
+			ret = clk_set_rate(master_saif->clk, 512 * rate);
 		} else if (mclk % 48 == 0) {
 			scr |= BM_SAIF_CTRL_BITCLK_BASE_RATE;
-			ret = clk_set_rate(saif->clk, 384 * rate);
+			ret = clk_set_rate(master_saif->clk, 384 * rate);
 		} else {
 			/* SAIF MCLK should be either 32x or 48x */
 			return -EINVAL;
 		}
 	} else {
-		ret = clk_set_rate(saif->clk, 512 * rate);
+		ret = clk_set_rate(master_saif->clk, 512 * rate);
 		scr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;
 	}
 
 	if (ret)
 		return ret;
 
-	if (!saif->mclk_in_use) {
-		__raw_writel(scr, saif->base + SAIF_CTRL);
+	master_saif->cur_rate = rate;
+
+	if (!master_saif->mclk_in_use) {
+		__raw_writel(scr, master_saif->base + SAIF_CTRL);
 		return 0;
 	}
 
@@ -137,7 +188,7 @@ static int mxs_saif_set_clk(struct mxs_saif *saif,
 		return -EINVAL;
 	}
 
-	__raw_writel(scr, saif->base + SAIF_CTRL);
+	__raw_writel(scr, master_saif->base + SAIF_CTRL);
 
 	return 0;
 }
@@ -183,6 +234,7 @@ int mxs_saif_get_mclk(unsigned int saif_id, unsigned int mclk,
 	struct mxs_saif *saif = mxs_saif[saif_id];
 	u32 stat;
 	int ret;
+	struct mxs_saif *master_saif;
 
 	if (!saif)
 		return -EINVAL;
@@ -195,6 +247,12 @@ int mxs_saif_get_mclk(unsigned int saif_id, unsigned int mclk,
 	__raw_writel(BM_SAIF_CTRL_CLKGATE,
 		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
 
+	master_saif = mxs_saif_get_master(saif);
+	if (saif != master_saif) {
+		dev_err(saif->dev, "can not get mclk from a non-master saif\n");
+		return -EINVAL;
+	}
+
 	stat = __raw_readl(saif->base + SAIF_STAT);
 	if (stat & BM_SAIF_STAT_BUSY) {
 		dev_err(saif->dev, "error: busy\n");
@@ -278,10 +336,17 @@ static int mxs_saif_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
 	/*
 	 * Note: We simply just support master mode since SAIF TX can only
 	 * work as master.
+	 * Here the master is relative to codec side.
+	 * Saif internally could be slave when working on EXTMASTER mode.
+	 * We just hide this to machine driver.
 	 */
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
-		scr &= ~BM_SAIF_CTRL_SLAVE_MODE;
+		if (saif->id == saif->master_id)
+			scr &= ~BM_SAIF_CTRL_SLAVE_MODE;
+		else
+			scr |= BM_SAIF_CTRL_SLAVE_MODE;
+
 		__raw_writel(scr | scr0, saif->base + SAIF_CTRL);
 		break;
 	default:
@@ -396,6 +461,12 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 				struct snd_soc_dai *cpu_dai)
 {
 	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+	struct mxs_saif *master_saif;
+	u32 delay;
+
+	master_saif = mxs_saif_get_master(saif);
+	if (!master_saif)
+		return -EINVAL;
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -403,10 +474,20 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		dev_dbg(cpu_dai->dev, "start\n");
 
-		clk_enable(saif->clk);
-		if (!saif->mclk_in_use)
+		clk_enable(master_saif->clk);
+		if (!master_saif->mclk_in_use)
+			__raw_writel(BM_SAIF_CTRL_RUN,
+				master_saif->base + SAIF_CTRL + MXS_SET_ADDR);
+
+		/*
+		 * If the saif's master is not himself, we also need to enable
+		 * itself clk for its internal basic logic to work.
+		 */
+		if (saif != master_saif) {
+			clk_enable(saif->clk);
 			__raw_writel(BM_SAIF_CTRL_RUN,
 				saif->base + SAIF_CTRL + MXS_SET_ADDR);
+		}
 
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			/*
@@ -422,20 +503,39 @@ static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
 			__raw_readl(saif->base + SAIF_DATA);
 		}
 
-		dev_dbg(cpu_dai->dev, "CTRL 0x%x STAT 0x%x\n",
+		master_saif->ongoing = 1;
+
+		dev_dbg(saif->dev, "CTRL 0x%x STAT 0x%x\n",
 			__raw_readl(saif->base + SAIF_CTRL),
 			__raw_readl(saif->base + SAIF_STAT));
 
+		dev_dbg(master_saif->dev, "CTRL 0x%x STAT 0x%x\n",
+			__raw_readl(master_saif->base + SAIF_CTRL),
+			__raw_readl(master_saif->base + SAIF_STAT));
 		break;
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		dev_dbg(cpu_dai->dev, "stop\n");
 
-		clk_disable(saif->clk);
-		if (!saif->mclk_in_use)
+		/* wait a while for the current sample to complete */
+		delay = USEC_PER_SEC / master_saif->cur_rate;
+
+		if (!master_saif->mclk_in_use) {
+			__raw_writel(BM_SAIF_CTRL_RUN,
+				master_saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+			udelay(delay);
+		}
+		clk_disable(master_saif->clk);
+
+		if (saif != master_saif) {
 			__raw_writel(BM_SAIF_CTRL_RUN,
 				saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+			udelay(delay);
+			clk_disable(saif->clk);
+		}
+
+		master_saif->ongoing = 0;
 
 		break;
 	default:
@@ -519,16 +619,33 @@ static int mxs_saif_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct mxs_saif *saif;
+	struct mxs_saif_platform_data *pdata;
 	int ret = 0;
 
 	if (pdev->id >= ARRAY_SIZE(mxs_saif))
 		return -EINVAL;
 
+	pdata = pdev->dev.platform_data;
+	if (pdata && pdata->init) {
+		ret = pdata->init();
+		if (ret)
+			return ret;
+	}
+
 	saif = kzalloc(sizeof(*saif), GFP_KERNEL);
 	if (!saif)
 		return -ENOMEM;
 
 	mxs_saif[pdev->id] = saif;
+	saif->id = pdev->id;
+
+	saif->master_id = saif->id;
+	if (pdata && pdata->get_master_id) {
+		saif->master_id = pdata->get_master_id(saif->id);
+		if (saif->master_id < 0 ||
+			saif->master_id >= ARRAY_SIZE(mxs_saif))
+			return -EINVAL;
+	}
 
 	saif->clk = clk_get(&pdev->dev, NULL);
 	if (IS_ERR(saif->clk)) {

commit 0bb98ba2b045e53b4724f34509455b7653c329d3
Author: Julia Lawall <julia@diku.dk>
Date:   Sun Aug 21 13:18:45 2011 +0200

    sound/soc/mxs/mxs-saif.c: add missing kfree
    
    Move the test on pdev->id before the kzalloc to avoid requiring kfree when
    the test fails.  This fix was suggested by Wolfram Sang.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    identifier x;
    expression E1!=0,E2,E3,E4;
    statement S;
    iterator I;
    @@
    
    (
    if (...) { ... when != kfree(x)
                   when != x = E3
                   when != E3 = x
    *  return ...;
     }
    ... when != x = E2
        when != I(...,x,...) S
    if (...) { ... when != x = E4
     kfree(x); ... return ...; }
    )
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Acked-by: Dong Aisheng <b29396@freescale.com>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 530017f7d14a..af5734f6dab7 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -521,12 +521,13 @@ static int mxs_saif_probe(struct platform_device *pdev)
 	struct mxs_saif *saif;
 	int ret = 0;
 
+	if (pdev->id >= ARRAY_SIZE(mxs_saif))
+		return -EINVAL;
+
 	saif = kzalloc(sizeof(*saif), GFP_KERNEL);
 	if (!saif)
 		return -ENOMEM;
 
-	if (pdev->id >= ARRAY_SIZE(mxs_saif))
-		return -EINVAL;
 	mxs_saif[pdev->id] = saif;
 
 	saif->clk = clk_get(&pdev->dev, NULL);

commit bbe8ff5e25afd4d06c8a8bad009aca5f0d0c22ef
Author: Dong Aisheng <b29396@freescale.com>
Date:   Sun Aug 21 23:45:40 2011 +0800

    ASoC: mxs-saif: clear clk gate first before register setting
    
    Saif needs clear clk gate first before writing registers or the write
    will not success.
    
    The original xx_get_mclk function clear clk gate after mclk setting
    that may cause the former mclk setting unwork, then the real output
    mclk maybe inaccurate.
    Placing the clear before setting mclk to avoid such an issue.
    
    We also have to clear clk gate in startup instead of in prepare function.
    
    Signed-off-by: Dong Aisheng <b29396@freescale.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
index 0b3adaec9f4c..530017f7d14a 100644
--- a/sound/soc/mxs/mxs-saif.c
+++ b/sound/soc/mxs/mxs-saif.c
@@ -187,16 +187,20 @@ int mxs_saif_get_mclk(unsigned int saif_id, unsigned int mclk,
 	if (!saif)
 		return -EINVAL;
 
+	/* Clear Reset */
+	__raw_writel(BM_SAIF_CTRL_SFTRST,
+		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+
+	/* FIXME: need clear clk gate for register r/w */
+	__raw_writel(BM_SAIF_CTRL_CLKGATE,
+		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+
 	stat = __raw_readl(saif->base + SAIF_STAT);
 	if (stat & BM_SAIF_STAT_BUSY) {
 		dev_err(saif->dev, "error: busy\n");
 		return -EBUSY;
 	}
 
-	/* Clear Reset */
-	__raw_writel(BM_SAIF_CTRL_SFTRST,
-		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
-
 	saif->mclk_in_use = 1;
 	ret = mxs_saif_set_clk(saif, mclk, rate);
 	if (ret)
@@ -207,8 +211,6 @@ int mxs_saif_get_mclk(unsigned int saif_id, unsigned int mclk,
 		return ret;
 
 	/* enable MCLK output */
-	__raw_writel(BM_SAIF_CTRL_CLKGATE,
-		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
 	__raw_writel(BM_SAIF_CTRL_RUN,
 		saif->base + SAIF_CTRL + MXS_SET_ADDR);
 
@@ -303,6 +305,10 @@ static int mxs_saif_startup(struct snd_pcm_substream *substream,
 	__raw_writel(BM_SAIF_CTRL_SFTRST,
 		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
 
+	/* clear clock gate */
+	__raw_writel(BM_SAIF_CTRL_CLKGATE,
+		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+
 	return 0;
 }
 
@@ -379,10 +385,6 @@ static int mxs_saif_prepare(struct snd_pcm_substream *substream,
 {
 	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
 
-	/* clear clock gate */
-	__raw_writel(BM_SAIF_CTRL_CLKGATE,
-		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
-
 	/* enable FIFO error irqs */
 	__raw_writel(BM_SAIF_CTRL_FIFO_ERROR_IRQ_EN,
 		saif->base + SAIF_CTRL + MXS_SET_ADDR);

commit 2a24f2ce89b6157192c10616492be8a981b0cce8
Author: Dong Aisheng <b29396@freescale.com>
Date:   Thu Jul 21 12:36:56 2011 +0800

    ASoC: mxs: add mxs-saif driver
    
    Signed-off-by: Dong Aisheng <b29396@freescale.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/mxs/mxs-saif.c b/sound/soc/mxs/mxs-saif.c
new file mode 100644
index 000000000000..0b3adaec9f4c
--- /dev/null
+++ b/sound/soc/mxs/mxs-saif.c
@@ -0,0 +1,677 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <mach/dma.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/mxs.h>
+
+#include "mxs-saif.h"
+
+static struct mxs_saif *mxs_saif[2];
+
+static int mxs_saif_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+
+	switch (clk_id) {
+	case MXS_SAIF_MCLK:
+		saif->mclk = freq;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ * Set SAIF clock and MCLK
+ */
+static int mxs_saif_set_clk(struct mxs_saif *saif,
+				  unsigned int mclk,
+				  unsigned int rate)
+{
+	u32 scr;
+	int ret;
+
+	scr = __raw_readl(saif->base + SAIF_CTRL);
+	scr &= ~BM_SAIF_CTRL_BITCLK_MULT_RATE;
+	scr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;
+
+	/*
+	 * Set SAIF clock
+	 *
+	 * The SAIF clock should be either 384*fs or 512*fs.
+	 * If MCLK is used, the SAIF clk ratio need to match mclk ratio.
+	 *  For 32x mclk, set saif clk as 512*fs.
+	 *  For 48x mclk, set saif clk as 384*fs.
+	 *
+	 * If MCLK is not used, we just set saif clk to 512*fs.
+	 */
+	if (saif->mclk_in_use) {
+		if (mclk % 32 == 0) {
+			scr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;
+			ret = clk_set_rate(saif->clk, 512 * rate);
+		} else if (mclk % 48 == 0) {
+			scr |= BM_SAIF_CTRL_BITCLK_BASE_RATE;
+			ret = clk_set_rate(saif->clk, 384 * rate);
+		} else {
+			/* SAIF MCLK should be either 32x or 48x */
+			return -EINVAL;
+		}
+	} else {
+		ret = clk_set_rate(saif->clk, 512 * rate);
+		scr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;
+	}
+
+	if (ret)
+		return ret;
+
+	if (!saif->mclk_in_use) {
+		__raw_writel(scr, saif->base + SAIF_CTRL);
+		return 0;
+	}
+
+	/*
+	 * Program the over-sample rate for MCLK output
+	 *
+	 * The available MCLK range is 32x, 48x... 512x. The rate
+	 * could be from 8kHz to 192kH.
+	 */
+	switch (mclk / rate) {
+	case 32:
+		scr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(4);
+		break;
+	case 64:
+		scr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(3);
+		break;
+	case 128:
+		scr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(2);
+		break;
+	case 256:
+		scr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(1);
+		break;
+	case 512:
+		scr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(0);
+		break;
+	case 48:
+		scr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(3);
+		break;
+	case 96:
+		scr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(2);
+		break;
+	case 192:
+		scr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(1);
+		break;
+	case 384:
+		scr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	__raw_writel(scr, saif->base + SAIF_CTRL);
+
+	return 0;
+}
+
+/*
+ * Put and disable MCLK.
+ */
+int mxs_saif_put_mclk(unsigned int saif_id)
+{
+	struct mxs_saif *saif = mxs_saif[saif_id];
+	u32 stat;
+
+	if (!saif)
+		return -EINVAL;
+
+	stat = __raw_readl(saif->base + SAIF_STAT);
+	if (stat & BM_SAIF_STAT_BUSY) {
+		dev_err(saif->dev, "error: busy\n");
+		return -EBUSY;
+	}
+
+	clk_disable(saif->clk);
+
+	/* disable MCLK output */
+	__raw_writel(BM_SAIF_CTRL_CLKGATE,
+		saif->base + SAIF_CTRL + MXS_SET_ADDR);
+	__raw_writel(BM_SAIF_CTRL_RUN,
+		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+
+	saif->mclk_in_use = 0;
+	return 0;
+}
+
+/*
+ * Get MCLK and set clock rate, then enable it
+ *
+ * This interface is used for codecs who are using MCLK provided
+ * by saif.
+ */
+int mxs_saif_get_mclk(unsigned int saif_id, unsigned int mclk,
+					unsigned int rate)
+{
+	struct mxs_saif *saif = mxs_saif[saif_id];
+	u32 stat;
+	int ret;
+
+	if (!saif)
+		return -EINVAL;
+
+	stat = __raw_readl(saif->base + SAIF_STAT);
+	if (stat & BM_SAIF_STAT_BUSY) {
+		dev_err(saif->dev, "error: busy\n");
+		return -EBUSY;
+	}
+
+	/* Clear Reset */
+	__raw_writel(BM_SAIF_CTRL_SFTRST,
+		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+
+	saif->mclk_in_use = 1;
+	ret = mxs_saif_set_clk(saif, mclk, rate);
+	if (ret)
+		return ret;
+
+	ret = clk_enable(saif->clk);
+	if (ret)
+		return ret;
+
+	/* enable MCLK output */
+	__raw_writel(BM_SAIF_CTRL_CLKGATE,
+		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+	__raw_writel(BM_SAIF_CTRL_RUN,
+		saif->base + SAIF_CTRL + MXS_SET_ADDR);
+
+	return 0;
+}
+
+/*
+ * SAIF DAI format configuration.
+ * Should only be called when port is inactive.
+ */
+static int mxs_saif_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	u32 scr, stat;
+	u32 scr0;
+	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+
+	stat = __raw_readl(saif->base + SAIF_STAT);
+	if (stat & BM_SAIF_STAT_BUSY) {
+		dev_err(cpu_dai->dev, "error: busy\n");
+		return -EBUSY;
+	}
+
+	scr0 = __raw_readl(saif->base + SAIF_CTRL);
+	scr0 = scr0 & ~BM_SAIF_CTRL_BITCLK_EDGE & ~BM_SAIF_CTRL_LRCLK_POLARITY \
+		& ~BM_SAIF_CTRL_JUSTIFY & ~BM_SAIF_CTRL_DELAY;
+	scr = 0;
+
+	/* DAI mode */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		/* data frame low 1clk before data */
+		scr |= BM_SAIF_CTRL_DELAY;
+		scr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		/* data frame high with data */
+		scr &= ~BM_SAIF_CTRL_DELAY;
+		scr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;
+		scr &= ~BM_SAIF_CTRL_JUSTIFY;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* DAI clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		scr |= BM_SAIF_CTRL_BITCLK_EDGE;
+		scr |= BM_SAIF_CTRL_LRCLK_POLARITY;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		scr |= BM_SAIF_CTRL_BITCLK_EDGE;
+		scr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		scr &= ~BM_SAIF_CTRL_BITCLK_EDGE;
+		scr |= BM_SAIF_CTRL_LRCLK_POLARITY;
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+		scr &= ~BM_SAIF_CTRL_BITCLK_EDGE;
+		scr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;
+		break;
+	}
+
+	/*
+	 * Note: We simply just support master mode since SAIF TX can only
+	 * work as master.
+	 */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		scr &= ~BM_SAIF_CTRL_SLAVE_MODE;
+		__raw_writel(scr | scr0, saif->base + SAIF_CTRL);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mxs_saif_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *cpu_dai)
+{
+	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+	snd_soc_dai_set_dma_data(cpu_dai, substream, &saif->dma_param);
+
+	/* clear error status to 0 for each re-open */
+	saif->fifo_underrun = 0;
+	saif->fifo_overrun = 0;
+
+	/* Clear Reset for normal operations */
+	__raw_writel(BM_SAIF_CTRL_SFTRST,
+		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+
+	return 0;
+}
+
+/*
+ * Should only be called when port is inactive.
+ * although can be called multiple times by upper layers.
+ */
+static int mxs_saif_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *cpu_dai)
+{
+	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 scr, stat;
+	int ret;
+
+	/* mclk should already be set */
+	if (!saif->mclk && saif->mclk_in_use) {
+		dev_err(cpu_dai->dev, "set mclk first\n");
+		return -EINVAL;
+	}
+
+	stat = __raw_readl(saif->base + SAIF_STAT);
+	if (stat & BM_SAIF_STAT_BUSY) {
+		dev_err(cpu_dai->dev, "error: busy\n");
+		return -EBUSY;
+	}
+
+	/*
+	 * Set saif clk based on sample rate.
+	 * If mclk is used, we also set mclk, if not, saif->mclk is
+	 * default 0, means not used.
+	 */
+	ret = mxs_saif_set_clk(saif, saif->mclk, params_rate(params));
+	if (ret) {
+		dev_err(cpu_dai->dev, "unable to get proper clk\n");
+		return ret;
+	}
+
+	scr = __raw_readl(saif->base + SAIF_CTRL);
+
+	scr &= ~BM_SAIF_CTRL_WORD_LENGTH;
+	scr &= ~BM_SAIF_CTRL_BITCLK_48XFS_ENABLE;
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		scr |= BF_SAIF_CTRL_WORD_LENGTH(0);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		scr |= BF_SAIF_CTRL_WORD_LENGTH(4);
+		scr |= BM_SAIF_CTRL_BITCLK_48XFS_ENABLE;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		scr |= BF_SAIF_CTRL_WORD_LENGTH(8);
+		scr |= BM_SAIF_CTRL_BITCLK_48XFS_ENABLE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Tx/Rx config */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* enable TX mode */
+		scr &= ~BM_SAIF_CTRL_READ_MODE;
+	} else {
+		/* enable RX mode */
+		scr |= BM_SAIF_CTRL_READ_MODE;
+	}
+
+	__raw_writel(scr, saif->base + SAIF_CTRL);
+	return 0;
+}
+
+static int mxs_saif_prepare(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *cpu_dai)
+{
+	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+
+	/* clear clock gate */
+	__raw_writel(BM_SAIF_CTRL_CLKGATE,
+		saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+
+	/* enable FIFO error irqs */
+	__raw_writel(BM_SAIF_CTRL_FIFO_ERROR_IRQ_EN,
+		saif->base + SAIF_CTRL + MXS_SET_ADDR);
+
+	return 0;
+}
+
+static int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *cpu_dai)
+{
+	struct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dev_dbg(cpu_dai->dev, "start\n");
+
+		clk_enable(saif->clk);
+		if (!saif->mclk_in_use)
+			__raw_writel(BM_SAIF_CTRL_RUN,
+				saif->base + SAIF_CTRL + MXS_SET_ADDR);
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/*
+			 * write a data to saif data register to trigger
+			 * the transfer
+			 */
+			__raw_writel(0, saif->base + SAIF_DATA);
+		} else {
+			/*
+			 * read a data from saif data register to trigger
+			 * the receive
+			 */
+			__raw_readl(saif->base + SAIF_DATA);
+		}
+
+		dev_dbg(cpu_dai->dev, "CTRL 0x%x STAT 0x%x\n",
+			__raw_readl(saif->base + SAIF_CTRL),
+			__raw_readl(saif->base + SAIF_STAT));
+
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev_dbg(cpu_dai->dev, "stop\n");
+
+		clk_disable(saif->clk);
+		if (!saif->mclk_in_use)
+			__raw_writel(BM_SAIF_CTRL_RUN,
+				saif->base + SAIF_CTRL + MXS_CLR_ADDR);
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#define MXS_SAIF_RATES		SNDRV_PCM_RATE_8000_192000
+#define MXS_SAIF_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops mxs_saif_dai_ops = {
+	.startup = mxs_saif_startup,
+	.trigger = mxs_saif_trigger,
+	.prepare = mxs_saif_prepare,
+	.hw_params = mxs_saif_hw_params,
+	.set_sysclk = mxs_saif_set_dai_sysclk,
+	.set_fmt = mxs_saif_set_dai_fmt,
+};
+
+static int mxs_saif_dai_probe(struct snd_soc_dai *dai)
+{
+	struct mxs_saif *saif = dev_get_drvdata(dai->dev);
+
+	snd_soc_dai_set_drvdata(dai, saif);
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver mxs_saif_dai = {
+	.name = "mxs-saif",
+	.probe = mxs_saif_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = MXS_SAIF_RATES,
+		.formats = MXS_SAIF_FORMATS,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = MXS_SAIF_RATES,
+		.formats = MXS_SAIF_FORMATS,
+	},
+	.ops = &mxs_saif_dai_ops,
+};
+
+static irqreturn_t mxs_saif_irq(int irq, void *dev_id)
+{
+	struct mxs_saif *saif = dev_id;
+	unsigned int stat;
+
+	stat = __raw_readl(saif->base + SAIF_STAT);
+	if (!(stat & (BM_SAIF_STAT_FIFO_UNDERFLOW_IRQ |
+			BM_SAIF_STAT_FIFO_OVERFLOW_IRQ)))
+		return IRQ_NONE;
+
+	if (stat & BM_SAIF_STAT_FIFO_UNDERFLOW_IRQ) {
+		dev_dbg(saif->dev, "underrun!!! %d\n", ++saif->fifo_underrun);
+		__raw_writel(BM_SAIF_STAT_FIFO_UNDERFLOW_IRQ,
+				saif->base + SAIF_STAT + MXS_CLR_ADDR);
+	}
+
+	if (stat & BM_SAIF_STAT_FIFO_OVERFLOW_IRQ) {
+		dev_dbg(saif->dev, "overrun!!! %d\n", ++saif->fifo_overrun);
+		__raw_writel(BM_SAIF_STAT_FIFO_OVERFLOW_IRQ,
+				saif->base + SAIF_STAT + MXS_CLR_ADDR);
+	}
+
+	dev_dbg(saif->dev, "SAIF_CTRL %x SAIF_STAT %x\n",
+	       __raw_readl(saif->base + SAIF_CTRL),
+	       __raw_readl(saif->base + SAIF_STAT));
+
+	return IRQ_HANDLED;
+}
+
+static int mxs_saif_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct mxs_saif *saif;
+	int ret = 0;
+
+	saif = kzalloc(sizeof(*saif), GFP_KERNEL);
+	if (!saif)
+		return -ENOMEM;
+
+	if (pdev->id >= ARRAY_SIZE(mxs_saif))
+		return -EINVAL;
+	mxs_saif[pdev->id] = saif;
+
+	saif->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(saif->clk)) {
+		ret = PTR_ERR(saif->clk);
+		dev_err(&pdev->dev, "Cannot get the clock: %d\n",
+			ret);
+		goto failed_clk;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		dev_err(&pdev->dev, "failed to get io resource: %d\n",
+			ret);
+		goto failed_get_resource;
+	}
+
+	if (!request_mem_region(res->start, resource_size(res), "mxs-saif")) {
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		ret = -EBUSY;
+		goto failed_get_resource;
+	}
+
+	saif->base = ioremap(res->start, resource_size(res));
+	if (!saif->base) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENODEV;
+		goto failed_ioremap;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (!res) {
+		ret = -ENODEV;
+		dev_err(&pdev->dev, "failed to get dma resource: %d\n",
+			ret);
+		goto failed_ioremap;
+	}
+	saif->dma_param.chan_num = res->start;
+
+	saif->irq = platform_get_irq(pdev, 0);
+	if (saif->irq < 0) {
+		ret = saif->irq;
+		dev_err(&pdev->dev, "failed to get irq resource: %d\n",
+			ret);
+		goto failed_get_irq1;
+	}
+
+	saif->dev = &pdev->dev;
+	ret = request_irq(saif->irq, mxs_saif_irq, 0, "mxs-saif", saif);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to request irq\n");
+		goto failed_get_irq1;
+	}
+
+	saif->dma_param.chan_irq = platform_get_irq(pdev, 1);
+	if (saif->dma_param.chan_irq < 0) {
+		ret = saif->dma_param.chan_irq;
+		dev_err(&pdev->dev, "failed to get dma irq resource: %d\n",
+			ret);
+		goto failed_get_irq2;
+	}
+
+	platform_set_drvdata(pdev, saif);
+
+	ret = snd_soc_register_dai(&pdev->dev, &mxs_saif_dai);
+	if (ret) {
+		dev_err(&pdev->dev, "register DAI failed\n");
+		goto failed_register;
+	}
+
+	saif->soc_platform_pdev = platform_device_alloc(
+					"mxs-pcm-audio", pdev->id);
+	if (!saif->soc_platform_pdev) {
+		ret = -ENOMEM;
+		goto failed_pdev_alloc;
+	}
+
+	platform_set_drvdata(saif->soc_platform_pdev, saif);
+	ret = platform_device_add(saif->soc_platform_pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add soc platform device\n");
+		goto failed_pdev_add;
+	}
+
+	return 0;
+
+failed_pdev_add:
+	platform_device_put(saif->soc_platform_pdev);
+failed_pdev_alloc:
+	snd_soc_unregister_dai(&pdev->dev);
+failed_register:
+failed_get_irq2:
+	free_irq(saif->irq, saif);
+failed_get_irq1:
+	iounmap(saif->base);
+failed_ioremap:
+	release_mem_region(res->start, resource_size(res));
+failed_get_resource:
+	clk_put(saif->clk);
+failed_clk:
+	kfree(saif);
+
+	return ret;
+}
+
+static int __devexit mxs_saif_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	struct mxs_saif *saif = platform_get_drvdata(pdev);
+
+	platform_device_unregister(saif->soc_platform_pdev);
+
+	snd_soc_unregister_dai(&pdev->dev);
+
+	iounmap(saif->base);
+	release_mem_region(res->start, resource_size(res));
+	free_irq(saif->irq, saif);
+
+	clk_put(saif->clk);
+	kfree(saif);
+
+	return 0;
+}
+
+static struct platform_driver mxs_saif_driver = {
+	.probe = mxs_saif_probe,
+	.remove = __devexit_p(mxs_saif_remove),
+
+	.driver = {
+		.name = "mxs-saif",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init mxs_saif_init(void)
+{
+	return platform_driver_register(&mxs_saif_driver);
+}
+
+static void __exit mxs_saif_exit(void)
+{
+	platform_driver_unregister(&mxs_saif_driver);
+}
+
+module_init(mxs_saif_init);
+module_exit(mxs_saif_exit);
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXS ASoC SAIF driver");
+MODULE_LICENSE("GPL");
