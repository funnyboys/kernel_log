commit ff5d18cb04f4ecccbcf05b7f83ab6df2a0d95c16
Author: Sowjanya Komatineni <skomatineni@nvidia.com>
Date:   Mon Jan 13 23:24:24 2020 -0800

    ASoC: tegra: Enable audio mclk during tegra_asoc_utils_init()
    
    Tegra PMC clock clk_out_1 is dedicated for audio mclk from Tegra30
    through Tegra210 and currently Tegra clock driver keeps the audio mclk
    enabled.
    
    With the move of PMC clocks from clock driver into pmc driver, audio
    mclk enable from clock driver is removed and this should be taken care
    of by the audio driver.
    
    tegra_asoc_utils_init() calls tegra_asoc_utils_set_rate() and audio mclk
    rate configuration is not needed during init and the rate is actually
    set during the ->hw_params() callback.
    
    So, this patch removes tegra_asoc_utils_set_rate() call and just leaves
    the audio mclk enabled.
    
    Signed-off-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 25903ed850c8..587f62a288d1 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -205,9 +205,16 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 		data->clk_cdev1 = clk_out_1;
 	}
 
-	ret = tegra_asoc_utils_set_rate(data, 44100, 256 * 44100);
-	if (ret)
+	/*
+	 * FIXME: There is some unknown dependency between audio mclk disable
+	 * and suspend-resume functionality on Tegra30, although audio mclk is
+	 * only needed for audio.
+	 */
+	ret = clk_prepare_enable(data->clk_cdev1);
+	if (ret) {
+		dev_err(data->dev, "Can't enable cdev1: %d\n", ret);
 		return ret;
+	}
 
 	return 0;
 }

commit 1e4e0bf136aa4b4aa59c1e6af19844bd6d807794
Author: Sowjanya Komatineni <skomatineni@nvidia.com>
Date:   Mon Jan 13 23:24:23 2020 -0800

    ASoC: tegra: Add audio mclk parent configuration
    
    Tegra PMC clock clk_out_1 is dedicated for audio mclk from Tegra30
    through Tegra210 and currently Tegra clock driver does the initial
    parent configuration for audio mclk and keeps it enabled by default.
    
    With the move of PMC clocks from clock driver into PMC driver, audio
    clocks parent configuration can be specified through the device tree
    using assigned-clock-parents property and audio mclk control should be
    taken care of by the audio driver.
    
    This patch has implementation for parent configuration when default
    parent configuration through assigned-clock-parents property is not
    specified in the device tree.
    
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Reviewed-by: Sameer Pujar <spujar@nvidia.com>
    Signed-off-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 0d2271952555..25903ed850c8 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -60,8 +60,6 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 	data->set_mclk = 0;
 
 	clk_disable_unprepare(data->clk_cdev1);
-	clk_disable_unprepare(data->clk_pll_a_out0);
-	clk_disable_unprepare(data->clk_pll_a);
 
 	err = clk_set_rate(data->clk_pll_a, new_baseclock);
 	if (err) {
@@ -77,18 +75,6 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 
 	/* Don't set cdev1/extern1 rate; it's locked to pll_a_out0 */
 
-	err = clk_prepare_enable(data->clk_pll_a);
-	if (err) {
-		dev_err(data->dev, "Can't enable pll_a: %d\n", err);
-		return err;
-	}
-
-	err = clk_prepare_enable(data->clk_pll_a_out0);
-	if (err) {
-		dev_err(data->dev, "Can't enable pll_a_out0: %d\n", err);
-		return err;
-	}
-
 	err = clk_prepare_enable(data->clk_cdev1);
 	if (err) {
 		dev_err(data->dev, "Can't enable cdev1: %d\n", err);
@@ -109,8 +95,6 @@ int tegra_asoc_utils_set_ac97_rate(struct tegra_asoc_utils_data *data)
 	int err;
 
 	clk_disable_unprepare(data->clk_cdev1);
-	clk_disable_unprepare(data->clk_pll_a_out0);
-	clk_disable_unprepare(data->clk_pll_a);
 
 	/*
 	 * AC97 rate is fixed at 24.576MHz and is used for both the host
@@ -130,18 +114,6 @@ int tegra_asoc_utils_set_ac97_rate(struct tegra_asoc_utils_data *data)
 
 	/* Don't set cdev1/extern1 rate; it's locked to pll_a_out0 */
 
-	err = clk_prepare_enable(data->clk_pll_a);
-	if (err) {
-		dev_err(data->dev, "Can't enable pll_a: %d\n", err);
-		return err;
-	}
-
-	err = clk_prepare_enable(data->clk_pll_a_out0);
-	if (err) {
-		dev_err(data->dev, "Can't enable pll_a_out0: %d\n", err);
-		return err;
-	}
-
 	err = clk_prepare_enable(data->clk_cdev1);
 	if (err) {
 		dev_err(data->dev, "Can't enable cdev1: %d\n", err);
@@ -158,6 +130,7 @@ EXPORT_SYMBOL_GPL(tegra_asoc_utils_set_ac97_rate);
 int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 			  struct device *dev)
 {
+	struct clk *clk_out_1, *clk_extern1;
 	int ret;
 
 	data->dev = dev;
@@ -193,6 +166,45 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 		return PTR_ERR(data->clk_cdev1);
 	}
 
+	/*
+	 * If clock parents are not set in DT, configure here to use clk_out_1
+	 * as mclk and extern1 as parent for Tegra30 and higher.
+	 */
+	if (!of_find_property(dev->of_node, "assigned-clock-parents", NULL) &&
+	    data->soc > TEGRA_ASOC_UTILS_SOC_TEGRA20) {
+		dev_warn(data->dev,
+			 "Configuring clocks for a legacy device-tree\n");
+		dev_warn(data->dev,
+			 "Please update DT to use assigned-clock-parents\n");
+		clk_extern1 = devm_clk_get(dev, "extern1");
+		if (IS_ERR(clk_extern1)) {
+			dev_err(data->dev, "Can't retrieve clk extern1\n");
+			return PTR_ERR(clk_extern1);
+		}
+
+		ret = clk_set_parent(clk_extern1, data->clk_pll_a_out0);
+		if (ret < 0) {
+			dev_err(data->dev,
+				"Set parent failed for clk extern1\n");
+			return ret;
+		}
+
+		clk_out_1 = devm_clk_get(dev, "pmc_clk_out_1");
+		if (IS_ERR(clk_out_1)) {
+			dev_err(data->dev, "Can't retrieve pmc_clk_out_1\n");
+			return PTR_ERR(clk_out_1);
+		}
+
+		ret = clk_set_parent(clk_out_1, clk_extern1);
+		if (ret < 0) {
+			dev_err(data->dev,
+				"Set parent failed for pmc_clk_out_1\n");
+			return ret;
+		}
+
+		data->clk_cdev1 = clk_out_1;
+	}
+
 	ret = tegra_asoc_utils_set_rate(data, 44100, 256 * 44100);
 	if (ret)
 		return ret;

commit 0de6db30ef79b391cedd749801a49c485d2daf4b
Author: Sowjanya Komatineni <skomatineni@nvidia.com>
Date:   Mon Jan 13 23:24:17 2020 -0800

    ASoC: tegra: Use device managed resource APIs to get the clock
    
    tegra_asoc_utils uses clk_get() to get the clock and clk_put() to free
    them explicitly.
    
    This patch updates it to use device managed resource API devm_clk_get()
    so the clock will be automatically released and freed when the device is
    unbound and removes tegra_asoc_utils_fini() as its no longer needed.
    
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Reviewed-by: Sameer Pujar <spujar@nvidia.com>
    Signed-off-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 536a578e9512..0d2271952555 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -175,52 +175,32 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 		return -EINVAL;
 	}
 
-	data->clk_pll_a = clk_get(dev, "pll_a");
+	data->clk_pll_a = devm_clk_get(dev, "pll_a");
 	if (IS_ERR(data->clk_pll_a)) {
 		dev_err(data->dev, "Can't retrieve clk pll_a\n");
-		ret = PTR_ERR(data->clk_pll_a);
-		goto err;
+		return PTR_ERR(data->clk_pll_a);
 	}
 
-	data->clk_pll_a_out0 = clk_get(dev, "pll_a_out0");
+	data->clk_pll_a_out0 = devm_clk_get(dev, "pll_a_out0");
 	if (IS_ERR(data->clk_pll_a_out0)) {
 		dev_err(data->dev, "Can't retrieve clk pll_a_out0\n");
-		ret = PTR_ERR(data->clk_pll_a_out0);
-		goto err_put_pll_a;
+		return PTR_ERR(data->clk_pll_a_out0);
 	}
 
-	data->clk_cdev1 = clk_get(dev, "mclk");
+	data->clk_cdev1 = devm_clk_get(dev, "mclk");
 	if (IS_ERR(data->clk_cdev1)) {
 		dev_err(data->dev, "Can't retrieve clk cdev1\n");
-		ret = PTR_ERR(data->clk_cdev1);
-		goto err_put_pll_a_out0;
+		return PTR_ERR(data->clk_cdev1);
 	}
 
 	ret = tegra_asoc_utils_set_rate(data, 44100, 256 * 44100);
 	if (ret)
-		goto err_put_cdev1;
+		return ret;
 
 	return 0;
-
-err_put_cdev1:
-	clk_put(data->clk_cdev1);
-err_put_pll_a_out0:
-	clk_put(data->clk_pll_a_out0);
-err_put_pll_a:
-	clk_put(data->clk_pll_a);
-err:
-	return ret;
 }
 EXPORT_SYMBOL_GPL(tegra_asoc_utils_init);
 
-void tegra_asoc_utils_fini(struct tegra_asoc_utils_data *data)
-{
-	clk_put(data->clk_cdev1);
-	clk_put(data->clk_pll_a_out0);
-	clk_put(data->clk_pll_a);
-}
-EXPORT_SYMBOL_GPL(tegra_asoc_utils_fini);
-
 MODULE_AUTHOR("Stephen Warren <swarren@nvidia.com>");
 MODULE_DESCRIPTION("Tegra ASoC utility code");
 MODULE_LICENSE("GPL");

commit 2b27bdcc20958d644d04f9f12d683e52b37a5427
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:50 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 336
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin st fifth floor boston ma 02110
      1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 246 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.674189849@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 1be311c51a18..536a578e9512 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -1,23 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * tegra_asoc_utils.c - Harmony machine ASoC driver
  *
  * Author: Stephen Warren <swarren@nvidia.com>
  * Copyright (C) 2010,2012 - NVIDIA, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
  */
 
 #include <linux/clk.h>

commit 5e049fce368dfe07702c3664add9ae7b45df1a9a
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Oct 11 15:43:17 2013 -0600

    ASoC: tegra: support new register layouts in Tegra124
    
    Tegra124 introduces some small changes to the layout of some registers.
    Modify the affected drivers to program those registers appropriately
    based on which SoC they're running on.
    
    Tegra124 also introduced some new modules on the AHUB configlink register
    bus. These will require new entries in configlink_clocks[] in the AHUB
    driver. However, supporting that change likely relies on switching Tegra
    to the common reset framework, so I'll defer that change for now.
    
    Based-on-work-by: Arun Shamanna Lakshmi <aruns@nvidia.com>
    Based-on-work-by: Songhee Baek <sbaek@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index d173880f290d..1be311c51a18 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -182,6 +182,8 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA30;
 	else if (of_machine_is_compatible("nvidia,tegra114"))
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA114;
+	else if (of_machine_is_compatible("nvidia,tegra124"))
+		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA124;
 	else {
 		dev_err(data->dev, "SoC unknown to Tegra ASoC utils\n");
 		return -EINVAL;

commit 110147c8c5136e1768a382da8896cf7f8b518982
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon May 13 13:26:12 2013 -0600

    ASoC: tegra: always use clk_get() in utility code
    
    Now that all of the Tegra device trees have been updated to represent
    the required audio clocks, remove the compatibility code from the Tegra
    ASoC utility code, and always use clk_get() rather than clk_get_sys().
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 24fb001be7f4..d173880f290d 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -173,7 +173,6 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 			  struct device *dev)
 {
 	int ret;
-	bool new_clocks = false;
 
 	data->dev = dev;
 
@@ -181,40 +180,28 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA20;
 	else if (of_machine_is_compatible("nvidia,tegra30"))
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA30;
-	else if (of_machine_is_compatible("nvidia,tegra114")) {
+	else if (of_machine_is_compatible("nvidia,tegra114"))
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA114;
-		new_clocks = true;
-	} else {
+	else {
 		dev_err(data->dev, "SoC unknown to Tegra ASoC utils\n");
 		return -EINVAL;
 	}
 
-	if (new_clocks)
-		data->clk_pll_a = clk_get(dev, "pll_a");
-	else
-		data->clk_pll_a = clk_get_sys(NULL, "pll_a");
+	data->clk_pll_a = clk_get(dev, "pll_a");
 	if (IS_ERR(data->clk_pll_a)) {
 		dev_err(data->dev, "Can't retrieve clk pll_a\n");
 		ret = PTR_ERR(data->clk_pll_a);
 		goto err;
 	}
 
-	if (new_clocks)
-		data->clk_pll_a_out0 = clk_get(dev, "pll_a_out0");
-	else
-		data->clk_pll_a_out0 = clk_get_sys(NULL, "pll_a_out0");
+	data->clk_pll_a_out0 = clk_get(dev, "pll_a_out0");
 	if (IS_ERR(data->clk_pll_a_out0)) {
 		dev_err(data->dev, "Can't retrieve clk pll_a_out0\n");
 		ret = PTR_ERR(data->clk_pll_a_out0);
 		goto err_put_pll_a;
 	}
 
-	if (new_clocks)
-		data->clk_cdev1 = clk_get(dev, "mclk");
-	else if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA20)
-		data->clk_cdev1 = clk_get_sys(NULL, "cdev1");
-	else
-		data->clk_cdev1 = clk_get_sys("extern1", NULL);
+	data->clk_cdev1 = clk_get(dev, "mclk");
 	if (IS_ERR(data->clk_cdev1)) {
 		dev_err(data->dev, "Can't retrieve clk cdev1\n");
 		ret = PTR_ERR(data->clk_cdev1);

commit a7fc5d256be9fda27bb69e872e6a212542a84230
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Mar 21 13:56:42 2013 -0600

    ASoC: tegra: add Tegra114 support to tegra_asoc_utils.c
    
    Tegra114 requires different PLL rates. Modify the code to know about
    this.
    
    On Tegra114 only for now, use regular clk_get() rather than clk_get_sys()
    to retrieve clocks. This assumes that the clocks will be represented in
    device tree. We can assure that from the start of any Tegra114 audio
    support. For older chips, I'll add the required clocks properties to the
    device trees this kernel cycle, and switch this code to only support the
    "new_clocks" path next cycle.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 49861c6ed874..24fb001be7f4 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -43,8 +43,10 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 	case 88200:
 		if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA20)
 			new_baseclock = 56448000;
-		else
+		else if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA30)
 			new_baseclock = 564480000;
+		else
+			new_baseclock = 282240000;
 		break;
 	case 8000:
 	case 16000:
@@ -54,8 +56,10 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 	case 96000:
 		if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA20)
 			new_baseclock = 73728000;
-		else
+		else if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA30)
 			new_baseclock = 552960000;
+		else
+			new_baseclock = 368640000;
 		break;
 	default:
 		return -EINVAL;
@@ -169,6 +173,7 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 			  struct device *dev)
 {
 	int ret;
+	bool new_clocks = false;
 
 	data->dev = dev;
 
@@ -176,24 +181,37 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA20;
 	else if (of_machine_is_compatible("nvidia,tegra30"))
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA30;
-	else
+	else if (of_machine_is_compatible("nvidia,tegra114")) {
+		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA114;
+		new_clocks = true;
+	} else {
+		dev_err(data->dev, "SoC unknown to Tegra ASoC utils\n");
 		return -EINVAL;
+	}
 
-	data->clk_pll_a = clk_get_sys(NULL, "pll_a");
+	if (new_clocks)
+		data->clk_pll_a = clk_get(dev, "pll_a");
+	else
+		data->clk_pll_a = clk_get_sys(NULL, "pll_a");
 	if (IS_ERR(data->clk_pll_a)) {
 		dev_err(data->dev, "Can't retrieve clk pll_a\n");
 		ret = PTR_ERR(data->clk_pll_a);
 		goto err;
 	}
 
-	data->clk_pll_a_out0 = clk_get_sys(NULL, "pll_a_out0");
+	if (new_clocks)
+		data->clk_pll_a_out0 = clk_get(dev, "pll_a_out0");
+	else
+		data->clk_pll_a_out0 = clk_get_sys(NULL, "pll_a_out0");
 	if (IS_ERR(data->clk_pll_a_out0)) {
 		dev_err(data->dev, "Can't retrieve clk pll_a_out0\n");
 		ret = PTR_ERR(data->clk_pll_a_out0);
 		goto err_put_pll_a;
 	}
 
-	if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA20)
+	if (new_clocks)
+		data->clk_cdev1 = clk_get(dev, "mclk");
+	else if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA20)
 		data->clk_cdev1 = clk_get_sys(NULL, "cdev1");
 	else
 		data->clk_cdev1 = clk_get_sys("extern1", NULL);

commit 69de6be70e611c8165b9b5c16d69574d13f2a3b0
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Feb 15 17:07:30 2013 -0700

    ASoC: tegra: assume CONFIG_OF in tegra_asoc_utils_init
    
    Tegra only supports, and always enables, device tree. Remove all runtime
    checks for DT support from the driver.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index ba419f86384d..49861c6ed874 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -176,11 +176,7 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA20;
 	else if (of_machine_is_compatible("nvidia,tegra30"))
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA30;
-	else if (!dev->of_node)
-		/* non-DT is always Tegra20 */
-		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA20;
 	else
-		/* DT boot, but unknown SoC */
 		return -EINVAL;
 
 	data->clk_pll_a = clk_get_sys(NULL, "pll_a");

commit 919ad49c214adcc80578c7a02efd3fe8460e0797
Author: Lucas Stach <dev@lynxeye.de>
Date:   Thu Dec 20 00:17:33 2012 +0100

    ASoC: tegra: add function to set ac97 rate
    
    AC97 uses a fixed rate, unrelated to the sample rate. Add a function to
    make the setup more trivial.
    
    Signed-off-by: Lucas Stach <dev@lynxeye.de>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 6872c77a1196..ba419f86384d 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -112,6 +112,59 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 }
 EXPORT_SYMBOL_GPL(tegra_asoc_utils_set_rate);
 
+int tegra_asoc_utils_set_ac97_rate(struct tegra_asoc_utils_data *data)
+{
+	const int pll_rate = 73728000;
+	const int ac97_rate = 24576000;
+	int err;
+
+	clk_disable_unprepare(data->clk_cdev1);
+	clk_disable_unprepare(data->clk_pll_a_out0);
+	clk_disable_unprepare(data->clk_pll_a);
+
+	/*
+	 * AC97 rate is fixed at 24.576MHz and is used for both the host
+	 * controller and the external codec
+	 */
+	err = clk_set_rate(data->clk_pll_a, pll_rate);
+	if (err) {
+		dev_err(data->dev, "Can't set pll_a rate: %d\n", err);
+		return err;
+	}
+
+	err = clk_set_rate(data->clk_pll_a_out0, ac97_rate);
+	if (err) {
+		dev_err(data->dev, "Can't set pll_a_out0 rate: %d\n", err);
+		return err;
+	}
+
+	/* Don't set cdev1/extern1 rate; it's locked to pll_a_out0 */
+
+	err = clk_prepare_enable(data->clk_pll_a);
+	if (err) {
+		dev_err(data->dev, "Can't enable pll_a: %d\n", err);
+		return err;
+	}
+
+	err = clk_prepare_enable(data->clk_pll_a_out0);
+	if (err) {
+		dev_err(data->dev, "Can't enable pll_a_out0: %d\n", err);
+		return err;
+	}
+
+	err = clk_prepare_enable(data->clk_cdev1);
+	if (err) {
+		dev_err(data->dev, "Can't enable cdev1: %d\n", err);
+		return err;
+	}
+
+	data->set_baseclock = pll_rate;
+	data->set_mclk = ac97_rate;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tegra_asoc_utils_set_ac97_rate);
+
 int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 			  struct device *dev)
 {

commit 65d2bdd343bd07c8de7df7352186bfe57994b5e7
Author: Prashant Gaikwad <pgaikwad@nvidia.com>
Date:   Tue Jun 5 09:59:42 2012 +0530

    ASoC: tegra: add clk_prepare/clk_unprepare
    
    Use clk_prepare/clk_unprepare as required by the generic clk framework.
    
    Signed-off-by: Prashant Gaikwad <pgaikwad@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 9515ce58ea02..6872c77a1196 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -69,9 +69,9 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 	data->set_baseclock = 0;
 	data->set_mclk = 0;
 
-	clk_disable(data->clk_cdev1);
-	clk_disable(data->clk_pll_a_out0);
-	clk_disable(data->clk_pll_a);
+	clk_disable_unprepare(data->clk_cdev1);
+	clk_disable_unprepare(data->clk_pll_a_out0);
+	clk_disable_unprepare(data->clk_pll_a);
 
 	err = clk_set_rate(data->clk_pll_a, new_baseclock);
 	if (err) {
@@ -87,19 +87,19 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 
 	/* Don't set cdev1/extern1 rate; it's locked to pll_a_out0 */
 
-	err = clk_enable(data->clk_pll_a);
+	err = clk_prepare_enable(data->clk_pll_a);
 	if (err) {
 		dev_err(data->dev, "Can't enable pll_a: %d\n", err);
 		return err;
 	}
 
-	err = clk_enable(data->clk_pll_a_out0);
+	err = clk_prepare_enable(data->clk_pll_a_out0);
 	if (err) {
 		dev_err(data->dev, "Can't enable pll_a_out0: %d\n", err);
 		return err;
 	}
 
-	err = clk_enable(data->clk_cdev1);
+	err = clk_prepare_enable(data->clk_cdev1);
 	if (err) {
 		dev_err(data->dev, "Can't enable cdev1: %d\n", err);
 		return err;

commit 8127bf5529f6a42d20e9e3613643d149e4dbb697
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Apr 10 13:11:17 2012 -0600

    ASoC: tegra: utils: Don't use of_have_populated_dt()
    
    Recent list discussions concluded that drivers should not be calling
    of_have_populated_dt(), and hence of_have_populated_dt() should not be
    exported. Use a different mechanism to detect DT vs. non-DT boot.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 266189d4ff13..9515ce58ea02 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -119,13 +119,15 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 
 	data->dev = dev;
 
-	if (!of_have_populated_dt())
-		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA20;
-	else if (of_machine_is_compatible("nvidia,tegra20"))
+	if (of_machine_is_compatible("nvidia,tegra20"))
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA20;
 	else if (of_machine_is_compatible("nvidia,tegra30"))
 		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA30;
+	else if (!dev->of_node)
+		/* non-DT is always Tegra20 */
+		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA20;
 	else
+		/* DT boot, but unknown SoC */
 		return -EINVAL;
 
 	data->clk_pll_a = clk_get_sys(NULL, "pll_a");

commit c2f6702d318e43bf841da9c0ba5b6f1695661bbc
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 6 11:15:55 2012 -0600

    ASoC: tegra: utils: add support for Tegra30 devices
    
    Tegra30 has some additional clocks that need to be manipulated, names
    some clocks differently, runs PLLs at different base rates, etc. The
    utility code needs to handle this.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 30424e157f69..266189d4ff13 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -2,7 +2,7 @@
  * tegra_asoc_utils.c - Harmony machine ASoC driver
  *
  * Author: Stephen Warren <swarren@nvidia.com>
- * Copyright (C) 2010 - NVIDIA, Inc.
+ * Copyright (C) 2010,2012 - NVIDIA, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -25,6 +25,7 @@
 #include <linux/err.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/of.h>
 
 #include "tegra_asoc_utils.h"
 
@@ -40,7 +41,10 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 	case 22050:
 	case 44100:
 	case 88200:
-		new_baseclock = 56448000;
+		if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA20)
+			new_baseclock = 56448000;
+		else
+			new_baseclock = 564480000;
 		break;
 	case 8000:
 	case 16000:
@@ -48,7 +52,10 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 	case 48000:
 	case 64000:
 	case 96000:
-		new_baseclock = 73728000;
+		if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA20)
+			new_baseclock = 73728000;
+		else
+			new_baseclock = 552960000;
 		break;
 	default:
 		return -EINVAL;
@@ -78,7 +85,7 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 		return err;
 	}
 
-	/* Don't set cdev1 rate; its locked to pll_a_out0 */
+	/* Don't set cdev1/extern1 rate; it's locked to pll_a_out0 */
 
 	err = clk_enable(data->clk_pll_a);
 	if (err) {
@@ -112,6 +119,15 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 
 	data->dev = dev;
 
+	if (!of_have_populated_dt())
+		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA20;
+	else if (of_machine_is_compatible("nvidia,tegra20"))
+		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA20;
+	else if (of_machine_is_compatible("nvidia,tegra30"))
+		data->soc = TEGRA_ASOC_UTILS_SOC_TEGRA30;
+	else
+		return -EINVAL;
+
 	data->clk_pll_a = clk_get_sys(NULL, "pll_a");
 	if (IS_ERR(data->clk_pll_a)) {
 		dev_err(data->dev, "Can't retrieve clk pll_a\n");
@@ -126,7 +142,10 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 		goto err_put_pll_a;
 	}
 
-	data->clk_cdev1 = clk_get_sys(NULL, "cdev1");
+	if (data->soc == TEGRA_ASOC_UTILS_SOC_TEGRA20)
+		data->clk_cdev1 = clk_get_sys(NULL, "cdev1");
+	else
+		data->clk_cdev1 = clk_get_sys("extern1", NULL);
 	if (IS_ERR(data->clk_cdev1)) {
 		dev_err(data->dev, "Can't retrieve clk cdev1\n");
 		ret = PTR_ERR(data->clk_cdev1);

commit a9005b67b3a2103b2b7e32bf602d3f023076fe06
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 6 11:18:16 2012 -0600

    ASoC: tegra: set a sensible initial clock rate
    
    Initialize the audio clock tree appropriately for some reasonable rate.
    This makes sure the PLLs etc. are actually programmed to something
    reasonable when the audio driver is loaded.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index f8428e410e05..30424e157f69 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -133,8 +133,14 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 		goto err_put_pll_a_out0;
 	}
 
+	ret = tegra_asoc_utils_set_rate(data, 44100, 256 * 44100);
+	if (ret)
+		goto err_put_cdev1;
+
 	return 0;
 
+err_put_cdev1:
+	clk_put(data->clk_cdev1);
 err_put_pll_a_out0:
 	clk_put(data->clk_pll_a_out0);
 err_put_pll_a:

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index dfa85cbb05c8..f8428e410e05 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -24,6 +24,7 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 
 #include "tegra_asoc_utils.h"
 

commit 075413966a6ea389f78f4cc2e957708c1d6db8c5
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Apr 19 15:25:09 2011 -0600

    ASoC: Tegra: Don't return mclk_changed from utils_set_rate
    
    Only the clock programming code needs to know whether the clocks changed,
    and that is encapsulated within tegra_asoc_utils_set_rate(). The machine
    driver's call to snd_soc_dai_set_sysclk(codec_dai, ...) is safe
    irrespective of whether the clocks changed.
    
    (Applying Mark's TrimSlice review comments to the existing driver)
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 52f0a3f9ce40..dfa85cbb05c8 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -28,9 +28,10 @@
 #include "tegra_asoc_utils.h"
 
 int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
-			      int mclk, int *mclk_change)
+			      int mclk)
 {
 	int new_baseclock;
+	bool clk_change;
 	int err;
 
 	switch (srate) {
@@ -52,10 +53,10 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 		return -EINVAL;
 	}
 
-	*mclk_change = ((new_baseclock != data->set_baseclock) ||
+	clk_change = ((new_baseclock != data->set_baseclock) ||
 			(mclk != data->set_mclk));
-	if (!*mclk_change)
-	    return 0;
+	if (!clk_change)
+		return 0;
 
 	data->set_baseclock = 0;
 	data->set_mclk = 0;

commit a3cd50deef7ba7df506af5347764a00b4621d7a7
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Feb 22 17:23:56 2011 -0700

    ASoC: Tegra: Move utilities to separate module
    
    The utilities will be required by every machine driver. Including the
    utility object directly into every machine driver causes a build failure
    if the modules are actually built into the kernel, since each will define
    the symbols exported by the utility file. Solve this by moving the
    utility object into a separate module.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index cb4fc13c7d22..52f0a3f9ce40 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -101,6 +101,7 @@ int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(tegra_asoc_utils_set_rate);
 
 int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 			  struct device *dev)
@@ -139,6 +140,7 @@ int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
 err:
 	return ret;
 }
+EXPORT_SYMBOL_GPL(tegra_asoc_utils_init);
 
 void tegra_asoc_utils_fini(struct tegra_asoc_utils_data *data)
 {
@@ -146,4 +148,8 @@ void tegra_asoc_utils_fini(struct tegra_asoc_utils_data *data)
 	clk_put(data->clk_pll_a_out0);
 	clk_put(data->clk_pll_a);
 }
+EXPORT_SYMBOL_GPL(tegra_asoc_utils_fini);
 
+MODULE_AUTHOR("Stephen Warren <swarren@nvidia.com>");
+MODULE_DESCRIPTION("Tegra ASoC utility code");
+MODULE_LICENSE("GPL");

commit d64e57cef0436833cfc9620e350ec6f5b041c9a9
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Jan 28 14:26:40 2011 -0700

    ASoC: Tegra: utils: Don't use global variables
    
    Instead, have the machine driver provide storage for the utility data
    somehow.
    
    For Harmony in particular, store this within struct tegra_harmony, itself
    referenced by snd_soc_card's drvdata.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index cfe2ea890dc0..cb4fc13c7d22 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -21,20 +21,14 @@
  */
 
 #include <linux/clk.h>
+#include <linux/device.h>
 #include <linux/err.h>
 #include <linux/kernel.h>
 
 #include "tegra_asoc_utils.h"
 
-#define PREFIX "ASoC Tegra: "
-
-static struct clk *clk_pll_a;
-static struct clk *clk_pll_a_out0;
-static struct clk *clk_cdev1;
-
-static int set_baseclock, set_mclk;
-
-int tegra_asoc_utils_set_rate(int srate, int mclk, int *mclk_change)
+int tegra_asoc_utils_set_rate(struct tegra_asoc_utils_data *data, int srate,
+			      int mclk, int *mclk_change)
 {
 	int new_baseclock;
 	int err;
@@ -58,95 +52,98 @@ int tegra_asoc_utils_set_rate(int srate, int mclk, int *mclk_change)
 		return -EINVAL;
 	}
 
-	*mclk_change = ((new_baseclock != set_baseclock) ||
-			(mclk != set_mclk));
+	*mclk_change = ((new_baseclock != data->set_baseclock) ||
+			(mclk != data->set_mclk));
 	if (!*mclk_change)
 	    return 0;
 
-	set_baseclock = 0;
-	set_mclk = 0;
+	data->set_baseclock = 0;
+	data->set_mclk = 0;
 
-	clk_disable(clk_cdev1);
-	clk_disable(clk_pll_a_out0);
-	clk_disable(clk_pll_a);
+	clk_disable(data->clk_cdev1);
+	clk_disable(data->clk_pll_a_out0);
+	clk_disable(data->clk_pll_a);
 
-	err = clk_set_rate(clk_pll_a, new_baseclock);
+	err = clk_set_rate(data->clk_pll_a, new_baseclock);
 	if (err) {
-		pr_err(PREFIX "Can't set pll_a rate: %d\n", err);
+		dev_err(data->dev, "Can't set pll_a rate: %d\n", err);
 		return err;
 	}
 
-	err = clk_set_rate(clk_pll_a_out0, mclk);
+	err = clk_set_rate(data->clk_pll_a_out0, mclk);
 	if (err) {
-		pr_err(PREFIX "Can't set pll_a_out0 rate: %d\n", err);
+		dev_err(data->dev, "Can't set pll_a_out0 rate: %d\n", err);
 		return err;
 	}
 
 	/* Don't set cdev1 rate; its locked to pll_a_out0 */
 
-	err = clk_enable(clk_pll_a);
+	err = clk_enable(data->clk_pll_a);
 	if (err) {
-		pr_err(PREFIX "Can't enable pll_a: %d\n", err);
+		dev_err(data->dev, "Can't enable pll_a: %d\n", err);
 		return err;
 	}
 
-	err = clk_enable(clk_pll_a_out0);
+	err = clk_enable(data->clk_pll_a_out0);
 	if (err) {
-		pr_err(PREFIX "Can't enable pll_a_out0: %d\n", err);
+		dev_err(data->dev, "Can't enable pll_a_out0: %d\n", err);
 		return err;
 	}
 
-	err = clk_enable(clk_cdev1);
+	err = clk_enable(data->clk_cdev1);
 	if (err) {
-		pr_err(PREFIX "Can't enable cdev1: %d\n", err);
+		dev_err(data->dev, "Can't enable cdev1: %d\n", err);
 		return err;
 	}
 
-	set_baseclock = new_baseclock;
-	set_mclk = mclk;
+	data->set_baseclock = new_baseclock;
+	data->set_mclk = mclk;
 
 	return 0;
 }
 
-int tegra_asoc_utils_init(void)
+int tegra_asoc_utils_init(struct tegra_asoc_utils_data *data,
+			  struct device *dev)
 {
 	int ret;
 
-	clk_pll_a = clk_get_sys(NULL, "pll_a");
-	if (IS_ERR(clk_pll_a)) {
-		pr_err(PREFIX "Can't retrieve clk pll_a\n");
-		ret = PTR_ERR(clk_pll_a);
+	data->dev = dev;
+
+	data->clk_pll_a = clk_get_sys(NULL, "pll_a");
+	if (IS_ERR(data->clk_pll_a)) {
+		dev_err(data->dev, "Can't retrieve clk pll_a\n");
+		ret = PTR_ERR(data->clk_pll_a);
 		goto err;
 	}
 
-	clk_pll_a_out0 = clk_get_sys(NULL, "pll_a_out0");
-	if (IS_ERR(clk_pll_a_out0)) {
-		pr_err(PREFIX "Can't retrieve clk pll_a_out0\n");
-		ret = PTR_ERR(clk_pll_a_out0);
+	data->clk_pll_a_out0 = clk_get_sys(NULL, "pll_a_out0");
+	if (IS_ERR(data->clk_pll_a_out0)) {
+		dev_err(data->dev, "Can't retrieve clk pll_a_out0\n");
+		ret = PTR_ERR(data->clk_pll_a_out0);
 		goto err_put_pll_a;
 	}
 
-	clk_cdev1 = clk_get_sys(NULL, "cdev1");
-	if (IS_ERR(clk_cdev1)) {
-		pr_err(PREFIX "Can't retrieve clk cdev1\n");
-		ret = PTR_ERR(clk_cdev1);
+	data->clk_cdev1 = clk_get_sys(NULL, "cdev1");
+	if (IS_ERR(data->clk_cdev1)) {
+		dev_err(data->dev, "Can't retrieve clk cdev1\n");
+		ret = PTR_ERR(data->clk_cdev1);
 		goto err_put_pll_a_out0;
 	}
 
 	return 0;
 
 err_put_pll_a_out0:
-	clk_put(clk_pll_a_out0);
+	clk_put(data->clk_pll_a_out0);
 err_put_pll_a:
-	clk_put(clk_pll_a);
+	clk_put(data->clk_pll_a);
 err:
 	return ret;
 }
 
-void tegra_asoc_utils_fini(void)
+void tegra_asoc_utils_fini(struct tegra_asoc_utils_data *data)
 {
-	clk_put(clk_cdev1);
-	clk_put(clk_pll_a_out0);
-	clk_put(clk_pll_a);
+	clk_put(data->clk_cdev1);
+	clk_put(data->clk_pll_a_out0);
+	clk_put(data->clk_pll_a);
 }
 

commit 422650e65a41a61b2f92396dfa4faa6a4df89913
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Jan 11 12:48:53 2011 -0700

    ASoC: tegra: s/IS_ERR_OR_NULL/IS_ERR/ for clk_get_sys
    
    A recent discussion on linux-arm-kernel noted that the value returned by
    clk_get_sys is an opaque token, and not strictly a pointer; it is
    meaningful only to the clock API, clients should not dereference the value,
    and the clock API must accept any non-IS_ERR value it returned.
    
    Hence, only IS_ERR is appropriate to interpret the result, not
    IS_ERR_OR_NULL.
    
    I checked that clk_get_sys in both ASoC's for-next and Tegra's for-next
    do behave as described; NULL is not returned in the case of error.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
index 711ab7ff5ced..cfe2ea890dc0 100644
--- a/sound/soc/tegra/tegra_asoc_utils.c
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -113,35 +113,33 @@ int tegra_asoc_utils_init(void)
 	int ret;
 
 	clk_pll_a = clk_get_sys(NULL, "pll_a");
-	if (IS_ERR_OR_NULL(clk_pll_a)) {
+	if (IS_ERR(clk_pll_a)) {
 		pr_err(PREFIX "Can't retrieve clk pll_a\n");
 		ret = PTR_ERR(clk_pll_a);
 		goto err;
 	}
 
 	clk_pll_a_out0 = clk_get_sys(NULL, "pll_a_out0");
-	if (IS_ERR_OR_NULL(clk_pll_a_out0)) {
+	if (IS_ERR(clk_pll_a_out0)) {
 		pr_err(PREFIX "Can't retrieve clk pll_a_out0\n");
 		ret = PTR_ERR(clk_pll_a_out0);
-		goto err;
+		goto err_put_pll_a;
 	}
 
 	clk_cdev1 = clk_get_sys(NULL, "cdev1");
-	if (IS_ERR_OR_NULL(clk_cdev1)) {
+	if (IS_ERR(clk_cdev1)) {
 		pr_err(PREFIX "Can't retrieve clk cdev1\n");
 		ret = PTR_ERR(clk_cdev1);
-		goto err;
+		goto err_put_pll_a_out0;
 	}
 
 	return 0;
 
+err_put_pll_a_out0:
+	clk_put(clk_pll_a_out0);
+err_put_pll_a:
+	clk_put(clk_pll_a);
 err:
-	if (!IS_ERR_OR_NULL(clk_cdev1))
-		clk_put(clk_cdev1);
-	if (!IS_ERR_OR_NULL(clk_pll_a_out0))
-		clk_put(clk_pll_a_out0);
-	if (!IS_ERR_OR_NULL(clk_pll_a))
-		clk_put(clk_pll_a);
 	return ret;
 }
 

commit a50a399b8ba169816d8afae66bfd42fbb65b1973
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Jan 7 22:36:15 2011 -0700

    ASoC: tegra: Machine utility code
    
    Many portions of Tegra ASoC machine drivers will be similar or identical.
    To avoid cut/paste, this file will act as a repository for all that common
    code. For now, it solely includes code to reprogram the audio PLL for
    44.1KHz- vs. 48KHz-based sample rates.
    
    Signed-Off-By: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra_asoc_utils.c b/sound/soc/tegra/tegra_asoc_utils.c
new file mode 100644
index 000000000000..711ab7ff5ced
--- /dev/null
+++ b/sound/soc/tegra/tegra_asoc_utils.c
@@ -0,0 +1,154 @@
+/*
+ * tegra_asoc_utils.c - Harmony machine ASoC driver
+ *
+ * Author: Stephen Warren <swarren@nvidia.com>
+ * Copyright (C) 2010 - NVIDIA, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+
+#include "tegra_asoc_utils.h"
+
+#define PREFIX "ASoC Tegra: "
+
+static struct clk *clk_pll_a;
+static struct clk *clk_pll_a_out0;
+static struct clk *clk_cdev1;
+
+static int set_baseclock, set_mclk;
+
+int tegra_asoc_utils_set_rate(int srate, int mclk, int *mclk_change)
+{
+	int new_baseclock;
+	int err;
+
+	switch (srate) {
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		new_baseclock = 56448000;
+		break;
+	case 8000:
+	case 16000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+		new_baseclock = 73728000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	*mclk_change = ((new_baseclock != set_baseclock) ||
+			(mclk != set_mclk));
+	if (!*mclk_change)
+	    return 0;
+
+	set_baseclock = 0;
+	set_mclk = 0;
+
+	clk_disable(clk_cdev1);
+	clk_disable(clk_pll_a_out0);
+	clk_disable(clk_pll_a);
+
+	err = clk_set_rate(clk_pll_a, new_baseclock);
+	if (err) {
+		pr_err(PREFIX "Can't set pll_a rate: %d\n", err);
+		return err;
+	}
+
+	err = clk_set_rate(clk_pll_a_out0, mclk);
+	if (err) {
+		pr_err(PREFIX "Can't set pll_a_out0 rate: %d\n", err);
+		return err;
+	}
+
+	/* Don't set cdev1 rate; its locked to pll_a_out0 */
+
+	err = clk_enable(clk_pll_a);
+	if (err) {
+		pr_err(PREFIX "Can't enable pll_a: %d\n", err);
+		return err;
+	}
+
+	err = clk_enable(clk_pll_a_out0);
+	if (err) {
+		pr_err(PREFIX "Can't enable pll_a_out0: %d\n", err);
+		return err;
+	}
+
+	err = clk_enable(clk_cdev1);
+	if (err) {
+		pr_err(PREFIX "Can't enable cdev1: %d\n", err);
+		return err;
+	}
+
+	set_baseclock = new_baseclock;
+	set_mclk = mclk;
+
+	return 0;
+}
+
+int tegra_asoc_utils_init(void)
+{
+	int ret;
+
+	clk_pll_a = clk_get_sys(NULL, "pll_a");
+	if (IS_ERR_OR_NULL(clk_pll_a)) {
+		pr_err(PREFIX "Can't retrieve clk pll_a\n");
+		ret = PTR_ERR(clk_pll_a);
+		goto err;
+	}
+
+	clk_pll_a_out0 = clk_get_sys(NULL, "pll_a_out0");
+	if (IS_ERR_OR_NULL(clk_pll_a_out0)) {
+		pr_err(PREFIX "Can't retrieve clk pll_a_out0\n");
+		ret = PTR_ERR(clk_pll_a_out0);
+		goto err;
+	}
+
+	clk_cdev1 = clk_get_sys(NULL, "cdev1");
+	if (IS_ERR_OR_NULL(clk_cdev1)) {
+		pr_err(PREFIX "Can't retrieve clk cdev1\n");
+		ret = PTR_ERR(clk_cdev1);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	if (!IS_ERR_OR_NULL(clk_cdev1))
+		clk_put(clk_cdev1);
+	if (!IS_ERR_OR_NULL(clk_pll_a_out0))
+		clk_put(clk_pll_a_out0);
+	if (!IS_ERR_OR_NULL(clk_pll_a))
+		clk_put(clk_pll_a);
+	return ret;
+}
+
+void tegra_asoc_utils_fini(void)
+{
+	clk_put(clk_cdev1);
+	clk_put(clk_pll_a_out0);
+	clk_put(clk_pll_a);
+}
+
