commit 2b27bdcc20958d644d04f9f12d683e52b37a5427
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:50 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 336
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin st fifth floor boston ma 02110
      1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 246 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.674189849@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 767c0491e11a..5839833e23a0 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -1,23 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * tegra20_spdif.c - Tegra20 SPDIF driver
  *
  * Author: Stephen Warren <swarren@nvidia.com>
  * Copyright (C) 2011-2012 - NVIDIA, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
  */
 
 #include <linux/clk.h>

commit e2c187a689b4a717024ba90c67a6ecd8ff36a23e
Author: Codrut Grosu <codrut.cristian.grosu@gmail.com>
Date:   Sat Feb 25 13:18:08 2017 +0200

    ASoC: tegra: Remove unnecessary 'out of memory' message
    
    This was reported by checkpatch.pl
    
    Signed-off-by: Codrut GROSU <codrut.cristian.grosu@gmail.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index a0c3640572b9..767c0491e11a 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -271,10 +271,9 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 
 	spdif = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_spdif),
 			     GFP_KERNEL);
-	if (!spdif) {
-		dev_err(&pdev->dev, "Can't allocate tegra20_spdif\n");
+	if (!spdif)
 		return -ENOMEM;
-	}
+
 	dev_set_drvdata(&pdev->dev, spdif);
 
 	spdif->clk_spdif_out = devm_clk_get(&pdev->dev, "spdif_out");

commit f57ddcdfa146636dbdcd6ac0a6d22c15d47b08c8
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Aug 23 23:32:14 2015 +0800

    ASoC: tegra: Use devm_ioremap_resource instead of open code
    
    Use devm_ioremap_resource() to simplify the code.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 0809b1ec1171..a0c3640572b9 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -265,7 +265,7 @@ static const struct regmap_config tegra20_spdif_regmap_config = {
 static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 {
 	struct tegra20_spdif *spdif;
-	struct resource *mem, *memregion, *dmareq;
+	struct resource *mem, *dmareq;
 	void __iomem *regs;
 	int ret;
 
@@ -285,10 +285,9 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	}
 
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!mem) {
-		dev_err(&pdev->dev, "No memory resource\n");
-		return -ENODEV;
-	}
+	regs = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
 
 	dmareq = platform_get_resource(pdev, IORESOURCE_DMA, 0);
 	if (!dmareq) {
@@ -296,19 +295,6 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	memregion = devm_request_mem_region(&pdev->dev, mem->start,
-					    resource_size(mem), DRV_NAME);
-	if (!memregion) {
-		dev_err(&pdev->dev, "Memory region already claimed\n");
-		return -EBUSY;
-	}
-
-	regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
-	if (!regs) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-		return -ENOMEM;
-	}
-
 	spdif->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
 					    &tegra20_spdif_regmap_config);
 	if (IS_ERR(spdif->regmap)) {

commit 5e9a3fcfa2ca10e3ff76938fe9a12515ffa41003
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Aug 23 10:07:13 2015 +0800

    ASoC: tegra: Fix unused variable 'spdif' warning
    
    Fix below build warning:
      CC [M]  sound/soc/tegra/tegra20_spdif.o
    sound/soc/tegra/tegra20_spdif.c: In function 'tegra20_spdif_platform_remove':
    sound/soc/tegra/tegra20_spdif.c:361:24: warning: unused variable 'spdif' [-Wunused-variable]
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Reviewed-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 66237bc44033..0809b1ec1171 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -358,8 +358,6 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 
 static int tegra20_spdif_platform_remove(struct platform_device *pdev)
 {
-	struct tegra20_spdif *spdif = dev_get_drvdata(&pdev->dev);
-
 	pm_runtime_disable(&pdev->dev);
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		tegra20_spdif_runtime_suspend(&pdev->dev);

commit 1d15f21dc8030c4511964819b89b50e39d5a7013
Author: Vaishali Thakkar <vthakkar1994@gmail.com>
Date:   Tue Aug 18 17:26:45 2015 +0530

    ASoC: tegra: Revert part of "ASoC: tegra: Convert to managed resources"
    
    Revert the problematic part of commit 470805eb9f31 ("ASoC: tegra:
    Convert to managed resources"). Before this commit, PM cleanup was
    performed after the component was unregistered. But returning
    directly will skip PM cleanup. So, to be on safe side it is better
    to use snd_soc_register_component instead of
    devm_snd_soc_register_component.
    
    Signed-off-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index a814da096824..66237bc44033 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -329,9 +329,8 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 			goto err_pm_disable;
 	}
 
-	ret = devm_snd_soc_register_component(&pdev->dev,
-					      &tegra20_spdif_component,
-					      &tegra20_spdif_dai, 1);
+	ret = snd_soc_register_component(&pdev->dev, &tegra20_spdif_component,
+					 &tegra20_spdif_dai, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
 		ret = -ENOMEM;
@@ -341,11 +340,13 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	ret = tegra_pcm_platform_register(&pdev->dev);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
-		return ret;
+		goto err_unregister_component;
 	}
 
 	return 0;
 
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
 err_suspend:
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		tegra20_spdif_runtime_suspend(&pdev->dev);
@@ -364,6 +365,7 @@ static int tegra20_spdif_platform_remove(struct platform_device *pdev)
 		tegra20_spdif_runtime_suspend(&pdev->dev);
 
 	tegra_pcm_platform_unregister(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
 
 	return 0;
 }

commit 470805eb9f31be7b0b94cb8e0cbeb5910c47ce37
Author: Vaishali Thakkar <vthakkar1994@gmail.com>
Date:   Thu Aug 13 12:59:21 2015 +0530

    ASoC: tegra: Convert to managed resources
    
    Use managed resource functions devm_clk_put and
    devm_snd_soc_register_component to simplify error handling.
    
    To be compatible with the change various gotos are replaced
    with direct returns, and unneeded labels are dropped.
    
    Signed-off-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 9141477a528d..a814da096824 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -273,45 +273,40 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 			     GFP_KERNEL);
 	if (!spdif) {
 		dev_err(&pdev->dev, "Can't allocate tegra20_spdif\n");
-		ret = -ENOMEM;
-		goto err;
+		return -ENOMEM;
 	}
 	dev_set_drvdata(&pdev->dev, spdif);
 
-	spdif->clk_spdif_out = clk_get(&pdev->dev, "spdif_out");
+	spdif->clk_spdif_out = devm_clk_get(&pdev->dev, "spdif_out");
 	if (IS_ERR(spdif->clk_spdif_out)) {
 		pr_err("Can't retrieve spdif clock\n");
 		ret = PTR_ERR(spdif->clk_spdif_out);
-		goto err;
+		return ret;
 	}
 
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!mem) {
 		dev_err(&pdev->dev, "No memory resource\n");
-		ret = -ENODEV;
-		goto err_clk_put;
+		return -ENODEV;
 	}
 
 	dmareq = platform_get_resource(pdev, IORESOURCE_DMA, 0);
 	if (!dmareq) {
 		dev_err(&pdev->dev, "No DMA resource\n");
-		ret = -ENODEV;
-		goto err_clk_put;
+		return -ENODEV;
 	}
 
 	memregion = devm_request_mem_region(&pdev->dev, mem->start,
 					    resource_size(mem), DRV_NAME);
 	if (!memregion) {
 		dev_err(&pdev->dev, "Memory region already claimed\n");
-		ret = -EBUSY;
-		goto err_clk_put;
+		return -EBUSY;
 	}
 
 	regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
 	if (!regs) {
 		dev_err(&pdev->dev, "ioremap failed\n");
-		ret = -ENOMEM;
-		goto err_clk_put;
+		return -ENOMEM;
 	}
 
 	spdif->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
@@ -319,7 +314,7 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	if (IS_ERR(spdif->regmap)) {
 		dev_err(&pdev->dev, "regmap init failed\n");
 		ret = PTR_ERR(spdif->regmap);
-		goto err_clk_put;
+		return ret;
 	}
 
 	spdif->playback_dma_data.addr = mem->start + TEGRA20_SPDIF_DATA_OUT;
@@ -334,8 +329,9 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 			goto err_pm_disable;
 	}
 
-	ret = snd_soc_register_component(&pdev->dev, &tegra20_spdif_component,
-				   &tegra20_spdif_dai, 1);
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &tegra20_spdif_component,
+					      &tegra20_spdif_dai, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
 		ret = -ENOMEM;
@@ -345,21 +341,17 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	ret = tegra_pcm_platform_register(&pdev->dev);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
-		goto err_unregister_component;
+		return ret;
 	}
 
 	return 0;
 
-err_unregister_component:
-	snd_soc_unregister_component(&pdev->dev);
 err_suspend:
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		tegra20_spdif_runtime_suspend(&pdev->dev);
 err_pm_disable:
 	pm_runtime_disable(&pdev->dev);
-err_clk_put:
-	clk_put(spdif->clk_spdif_out);
-err:
+
 	return ret;
 }
 
@@ -372,9 +364,6 @@ static int tegra20_spdif_platform_remove(struct platform_device *pdev)
 		tegra20_spdif_runtime_suspend(&pdev->dev);
 
 	tegra_pcm_platform_unregister(&pdev->dev);
-	snd_soc_unregister_component(&pdev->dev);
-
-	clk_put(spdif->clk_spdif_out);
 
 	return 0;
 }

commit 89032b176b8200257de2f21ee57ddaef8a212e8c
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:22:15 2014 +0200

    ASoC: tegra: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index a0ce92400faf..9141477a528d 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -387,7 +387,6 @@ static const struct dev_pm_ops tegra20_spdif_pm_ops = {
 static struct platform_driver tegra20_spdif_driver = {
 	.driver = {
 		.name = DRV_NAME,
-		.owner = THIS_MODULE,
 		.pm = &tegra20_spdif_pm_ops,
 	},
 	.probe = tegra20_spdif_platform_probe,

commit 591d14f00796a4250d800d316e3db1fea8a57e20
Author: Dylan Reid <dgreid@chromium.org>
Date:   Mon Mar 17 22:08:49 2014 -0700

    ASoC: tegra: Use flat regcache
    
    When using an rbtree cache, there can be allocations the first time a
    register is accessed.  This can cause an attempt to schedule while
    atomic in the case that the regmap is using a spinlock.  This could be
    fixed by either initializing all the registers or using a flat cache.
    The register maps for tegra30_ahub and tegra30_i2s are dense and don't
    save much from using a tree so convert them to flat.
    
    Tegra30 changes tested on Norrin, Tegra20 changes compile.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 8c7c1028e579..a0ce92400faf 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -259,7 +259,7 @@ static const struct regmap_config tegra20_spdif_regmap_config = {
 	.readable_reg = tegra20_spdif_wr_rd_reg,
 	.volatile_reg = tegra20_spdif_volatile_reg,
 	.precious_reg = tegra20_spdif_precious_reg,
-	.cache_type = REGCACHE_RBTREE,
+	.cache_type = REGCACHE_FLAT,
 };
 
 static int tegra20_spdif_platform_probe(struct platform_device *pdev)

commit 241bf43321a10815225f477bba96a42285a2da73
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Dec 6 13:34:50 2013 -0700

    ASoC: tegra: fix uninitialized variables in set_fmt
    
    In tegra*_i2s_set_fmt(), in the (fmt == SND_SOC_DAIFMT_CBM_CFM) case,
    "val" is never assigned to, but left uninitialized. The other case does
    initialized it. Fix this by initializing val at the start of the
    function, and only ever ORing into it.
    
    Update the handling of "mask" so it works the same way for consistency.
    
    Update tegra20_spdif.c to use the same code-style for consistency, even
    though it doesn't happen to suffer from the same problem at present.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Fixes: 0f163546a772 ("ASoC: tegra: use regmap more directly")
    Cc: <stable@vger.kernel.org>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 08bc6931c7c7..8c7c1028e579 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -67,15 +67,15 @@ static int tegra20_spdif_hw_params(struct snd_pcm_substream *substream,
 {
 	struct device *dev = dai->dev;
 	struct tegra20_spdif *spdif = snd_soc_dai_get_drvdata(dai);
-	unsigned int mask, val;
+	unsigned int mask = 0, val = 0;
 	int ret, spdifclock;
 
-	mask = TEGRA20_SPDIF_CTRL_PACK |
-	       TEGRA20_SPDIF_CTRL_BIT_MODE_MASK;
+	mask |= TEGRA20_SPDIF_CTRL_PACK |
+		TEGRA20_SPDIF_CTRL_BIT_MODE_MASK;
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
-		val = TEGRA20_SPDIF_CTRL_PACK |
-		      TEGRA20_SPDIF_CTRL_BIT_MODE_16BIT;
+		val |= TEGRA20_SPDIF_CTRL_PACK |
+		       TEGRA20_SPDIF_CTRL_BIT_MODE_16BIT;
 		break;
 	default:
 		return -EINVAL;

commit 1d198f26c98e6501659d741d530f7b65e4b7aec3
Author: Joe Perches <joe@perches.com>
Date:   Tue Oct 8 15:55:45 2013 -0700

    sound: Remove unnecessary semicolons
    
    These aren't necessary after switch and if blocks.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 551b3c93ce93..08bc6931c7c7 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -213,7 +213,7 @@ static bool tegra20_spdif_wr_rd_reg(struct device *dev, unsigned int reg)
 		return true;
 	default:
 		return false;
-	};
+	}
 }
 
 static bool tegra20_spdif_volatile_reg(struct device *dev, unsigned int reg)
@@ -234,7 +234,7 @@ static bool tegra20_spdif_volatile_reg(struct device *dev, unsigned int reg)
 		return true;
 	default:
 		return false;
-	};
+	}
 }
 
 static bool tegra20_spdif_precious_reg(struct device *dev, unsigned int reg)
@@ -247,7 +247,7 @@ static bool tegra20_spdif_precious_reg(struct device *dev, unsigned int reg)
 		return true;
 	default:
 		return false;
-	};
+	}
 }
 
 static const struct regmap_config tegra20_spdif_regmap_config = {

commit 647ab784c507763bfda79155f125b6edd1244806
Author: Richard Zhao <rizhao@nvidia.com>
Date:   Sun Jul 21 10:34:09 2013 +0800

    ASoC: tegra: correct playback_dma_data setup
    
    The errors were caused by copy/paste mistake in below commit
    since v3.10:
    3489d50 ASoC: tegra: Use common DAI DMA data struct
    
    It also corrects slave_id initialization in tegra20_ac97 driver.
    
    Signed-off-by: Richard Zhao <rizhao@nvidia.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Lucas Stach <dev@lynxeye.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: <stable@vger.kernel.org> # 3.10

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 5eaa12cdc6eb..551b3c93ce93 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -323,8 +323,8 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	}
 
 	spdif->playback_dma_data.addr = mem->start + TEGRA20_SPDIF_DATA_OUT;
-	spdif->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	spdif->capture_dma_data.maxburst = 4;
+	spdif->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	spdif->playback_dma_data.maxburst = 4;
 	spdif->playback_dma_data.slave_id = dmareq->start;
 
 	pm_runtime_enable(&pdev->dev);

commit 38e8c895d33b0642dc341f83cce0adde4cffbc82
Merge: d66e065c5b8b 69b6f19622ce
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Apr 12 13:57:04 2013 +0100

    Merge remote-tracking branch 'asoc/topic/dma' into asoc-next

commit 3489d5067a2cd8c51a2649b2f39bfb5b11852b8d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Apr 3 11:06:03 2013 +0200

    ASoC: tegra: Use common DAI DMA data struct
    
    Use the common DAI DMA data struct for tegra, this allows us to use the common
    helper function to configure the DMA slave config based on the DAI DMA data.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 04771d14d343..b7b4743cc94d 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -32,6 +32,7 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
 
 #include "tegra20_spdif.h"
 
@@ -318,9 +319,9 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	}
 
 	spdif->playback_dma_data.addr = mem->start + TEGRA20_SPDIF_DATA_OUT;
-	spdif->playback_dma_data.wrap = 4;
-	spdif->playback_dma_data.width = 32;
-	spdif->playback_dma_data.req_sel = dmareq->start;
+	spdif->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	spdif->capture_dma_data.maxburst = 4;
+	spdif->playback_dma_data.slave_id = dmareq->start;
 
 	pm_runtime_enable(&pdev->dev);
 	if (!pm_runtime_enabled(&pdev->dev)) {

commit 094e1a3d7d7d456b504058ed40ea19d40e05a7ff
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 21 03:37:33 2013 -0700

    ASoC: switch over to use snd_soc_register_component() on tegra20 spdif
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 04771d14d343..6fce0be5eaa3 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -182,6 +182,10 @@ static struct snd_soc_dai_driver tegra20_spdif_dai = {
 	.ops = &tegra20_spdif_dai_ops,
 };
 
+static const struct snd_soc_component_driver tegra20_spdif_component = {
+	.name		= DRV_NAME,
+};
+
 static bool tegra20_spdif_wr_rd_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
@@ -329,7 +333,8 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 			goto err_pm_disable;
 	}
 
-	ret = snd_soc_register_dai(&pdev->dev, &tegra20_spdif_dai);
+	ret = snd_soc_register_component(&pdev->dev, &tegra20_spdif_component,
+				   &tegra20_spdif_dai, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
 		ret = -ENOMEM;
@@ -339,13 +344,13 @@ static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	ret = tegra_pcm_platform_register(&pdev->dev);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
-		goto err_unregister_dai;
+		goto err_unregister_component;
 	}
 
 	return 0;
 
-err_unregister_dai:
-	snd_soc_unregister_dai(&pdev->dev);
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
 err_suspend:
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		tegra20_spdif_runtime_suspend(&pdev->dev);
@@ -366,7 +371,7 @@ static int tegra20_spdif_platform_remove(struct platform_device *pdev)
 		tegra20_spdif_runtime_suspend(&pdev->dev);
 
 	tegra_pcm_platform_unregister(&pdev->dev);
-	snd_soc_unregister_dai(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
 
 	clk_put(spdif->clk_spdif_out);
 

commit 4652a0d0c48324e1227e2b2500d17045840e2fb3
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Dec 7 09:26:33 2012 -0500

    ASoC: tegra: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index d9641ef7b1ee..04771d14d343 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -257,7 +257,7 @@ static const struct regmap_config tegra20_spdif_regmap_config = {
 	.cache_type = REGCACHE_RBTREE,
 };
 
-static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
+static int tegra20_spdif_platform_probe(struct platform_device *pdev)
 {
 	struct tegra20_spdif *spdif;
 	struct resource *mem, *memregion, *dmareq;
@@ -357,7 +357,7 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit tegra20_spdif_platform_remove(struct platform_device *pdev)
+static int tegra20_spdif_platform_remove(struct platform_device *pdev)
 {
 	struct tegra20_spdif *spdif = dev_get_drvdata(&pdev->dev);
 
@@ -385,7 +385,7 @@ static struct platform_driver tegra20_spdif_driver = {
 		.pm = &tegra20_spdif_pm_ops,
 	},
 	.probe = tegra20_spdif_platform_probe,
-	.remove = __devexit_p(tegra20_spdif_platform_remove),
+	.remove = tegra20_spdif_platform_remove,
 };
 
 module_platform_driver(tegra20_spdif_driver);

commit f6e6574499eeeeee747d9cfc7ba9f4328bb1806d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:25:33 2012 -0500

    ASoC: remove use of __devinitconst
    
    CONFIG_HOTPLUG is going away as an option so __devinitconst is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 3ebc8670ba00..d9641ef7b1ee 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -373,7 +373,7 @@ static int __devexit tegra20_spdif_platform_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct dev_pm_ops tegra20_spdif_pm_ops __devinitconst = {
+static const struct dev_pm_ops tegra20_spdif_pm_ops = {
 	SET_RUNTIME_PM_OPS(tegra20_spdif_runtime_suspend,
 			   tegra20_spdif_runtime_resume, NULL)
 };

commit dbf7b5915b39bfff548e4c6a3a753fc291a60e25
Merge: d14b7a419a66 c1b623d9e411
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 24 13:37:37 2012 -0700

    Merge tag 'sound-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound update from Takashi Iwai:
     "This is a fairly quiet release in all sound area.  Only a little bit
      of changes in the core side while most of changes are seen in the
      drivers.
    
      HD-audio:
       - A few new codec additions for Nvidia, Realtek and VIA
       - Intel Haswell audio support
       - Support for "phantom" jacks for consistent jack reporting
       - Major clean-ups in HDMI/DP driver codes
       - A workaround for inverted digital-mic pins with Realtek codecs
       - Removal of beep_mode=2 option
    
      ASoC:
       - Added the ability to add and remove DAPM paths dynamically, mostly
         for reparenting on clock changes
       - New machine drivers for Marvell Brownstone, ST-Ericsson Ux500
         reference platform and ttc-dkp
       - New CPU drivers for Blackfin BF6xx SPORTs in I2S mode, Marvell MMP,
         Synopsis Designware I2S controllers, and SPEAr DMA and S/PDIF
       - New CODEC drivers for Dialog DA732x, ST STA529, ST-Ericsson AB8500,
         TI Isabelle and Wolfson Microelectronics WM5102 and WM5110
       - DAPM fixes for the recent locking changes
       - Fix for _PRE and _POST widgets (which have been broken for a few
         releases now)
       - A couple of minor driver updates
    
      Misc
       - Conversion to new dev_pm_ops in platform and PCI drivers
       - LTC support and some fixes in PCXHR driver
       - A few fixes and PM support for ISA OPti9xx and WSS cards
       - Some TLV code cleanup
       - Move driver-specific headers from include/sound to local dirs"
    
    * tag 'sound-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (212 commits)
      ASoC: dapm: Fix _PRE and _POST events for DAPM performance improvements
      ALSA: hda - add dock support for Thinkpad X230 Tablet
      ALSA: hda - Turn on PIN_OUT from hdmi playback prepare.
      ASoC imx-audmux: add MX31_AUDMUX_PORT7_SSI_PINS_7 define
      ASoC: littlemill: Add userspace control of the WM1250 I/O
      ASoC: wm8994: Update micdet for irqdomain conversion
      ALSA: hda - make sure alc268 does not OOPS on codec parse
      ALSA: hda - Add support for Realtek ALC282
      ALSA: hda - Fix index number conflicts of phantom jacks
      ALSA: opti9xx: Fix section mismatch by PM support
      ALSA: snd-opti9xx: Implement suspend/resume
      ALSA: hda - Add new GPU codec ID to snd-hda
      ALSA: hda - Fix driver type of Haswell controller to AZX_DRIVER_SCH
      ALSA: hda - add Haswell HDMI codec id
      ALSA: hda - Add DeviceID for Haswell HDA
      ALSA: wss_lib: Fix resume on Yamaha OPL3-SAx
      ALSA: wss_lib: fix suspend/resume
      ALSA: es1938: replace TLV_DB_RANGE_HEAD with DECLARE_TLV_DB_RANGE
      ALSA: tlv: add DECLARE_TLV_DB_RANGE()
      ALSA: tlv: add DECLARE_TLV_CONTAINER()
      ...

commit 65d2bdd343bd07c8de7df7352186bfe57994b5e7
Author: Prashant Gaikwad <pgaikwad@nvidia.com>
Date:   Tue Jun 5 09:59:42 2012 +0530

    ASoC: tegra: add clk_prepare/clk_unprepare
    
    Use clk_prepare/clk_unprepare as required by the generic clk framework.
    
    Signed-off-by: Prashant Gaikwad <pgaikwad@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index f9b57418bd08..2262e4fdec2a 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -54,7 +54,7 @@ static int tegra20_spdif_runtime_suspend(struct device *dev)
 {
 	struct tegra20_spdif *spdif = dev_get_drvdata(dev);
 
-	clk_disable(spdif->clk_spdif_out);
+	clk_disable_unprepare(spdif->clk_spdif_out);
 
 	return 0;
 }
@@ -64,7 +64,7 @@ static int tegra20_spdif_runtime_resume(struct device *dev)
 	struct tegra20_spdif *spdif = dev_get_drvdata(dev);
 	int ret;
 
-	ret = clk_enable(spdif->clk_spdif_out);
+	ret = clk_prepare_enable(spdif->clk_spdif_out);
 	if (ret) {
 		dev_err(dev, "clk_enable failed: %d\n", ret);
 		return ret;

commit 0f163546a772d62250f59bad6a9338a0e3a2605c
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Jun 6 17:15:06 2012 -0600

    ASoC: tegra: use regmap more directly
    
    Stop open-coding the caching of the ctrl registers; instead, use
    regmap_update_bits() to update parts of the register from different
    places. The removal of the open-coded cache will allow controls to be
    created which touch registers, which will be necessary if any of these
    modules are converted to CODECs.
    
    Get rid of tegra*_read/write; just call regmap_read/write directly.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index f774a2d5e585..5c33c618929d 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -37,19 +37,6 @@
 
 #define DRV_NAME "tegra20-spdif"
 
-static inline void tegra20_spdif_write(struct tegra20_spdif *spdif, u32 reg,
-					u32 val)
-{
-	regmap_write(spdif->regmap, reg, val);
-}
-
-static inline u32 tegra20_spdif_read(struct tegra20_spdif *spdif, u32 reg)
-{
-	u32 val;
-	regmap_read(spdif->regmap, reg, &val);
-	return val;
-}
-
 static int tegra20_spdif_runtime_suspend(struct device *dev)
 {
 	struct tegra20_spdif *spdif = dev_get_drvdata(dev);
@@ -79,19 +66,22 @@ static int tegra20_spdif_hw_params(struct snd_pcm_substream *substream,
 {
 	struct device *dev = dai->dev;
 	struct tegra20_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int mask, val;
 	int ret, spdifclock;
 
-	spdif->reg_ctrl &= ~TEGRA20_SPDIF_CTRL_PACK;
-	spdif->reg_ctrl &= ~TEGRA20_SPDIF_CTRL_BIT_MODE_MASK;
+	mask = TEGRA20_SPDIF_CTRL_PACK |
+	       TEGRA20_SPDIF_CTRL_BIT_MODE_MASK;
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
-		spdif->reg_ctrl |= TEGRA20_SPDIF_CTRL_PACK;
-		spdif->reg_ctrl |= TEGRA20_SPDIF_CTRL_BIT_MODE_16BIT;
+		val = TEGRA20_SPDIF_CTRL_PACK |
+		      TEGRA20_SPDIF_CTRL_BIT_MODE_16BIT;
 		break;
 	default:
 		return -EINVAL;
 	}
 
+	regmap_update_bits(spdif->regmap, TEGRA20_SPDIF_CTRL, mask, val);
+
 	switch (params_rate(params)) {
 	case 32000:
 		spdifclock = 4096000;
@@ -129,14 +119,15 @@ static int tegra20_spdif_hw_params(struct snd_pcm_substream *substream,
 
 static void tegra20_spdif_start_playback(struct tegra20_spdif *spdif)
 {
-	spdif->reg_ctrl |= TEGRA20_SPDIF_CTRL_TX_EN;
-	tegra20_spdif_write(spdif, TEGRA20_SPDIF_CTRL, spdif->reg_ctrl);
+	regmap_update_bits(spdif->regmap, TEGRA20_SPDIF_CTRL,
+			   TEGRA20_SPDIF_CTRL_TX_EN,
+			   TEGRA20_SPDIF_CTRL_TX_EN);
 }
 
 static void tegra20_spdif_stop_playback(struct tegra20_spdif *spdif)
 {
-	spdif->reg_ctrl &= ~TEGRA20_SPDIF_CTRL_TX_EN;
-	tegra20_spdif_write(spdif, TEGRA20_SPDIF_CTRL, spdif->reg_ctrl);
+	regmap_update_bits(spdif->regmap, TEGRA20_SPDIF_CTRL,
+			   TEGRA20_SPDIF_CTRL_TX_EN, 0);
 }
 
 static int tegra20_spdif_trigger(struct snd_pcm_substream *substream, int cmd,

commit c92a40e3a163b6708e0dd82ba4612f79df846912
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Jun 6 17:15:05 2012 -0600

    ASoC: tegra: use DAI's not card's dev for dev_err
    
    This is the actual device of the I2S or SPDIF controller reporting the
    problem. If a future change converts these controllers to be CODECs, then
    there may be no pcm associated with the substream, so this change avoids
    a crash.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index ffbd99c4106e..f774a2d5e585 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -77,7 +77,7 @@ static int tegra20_spdif_hw_params(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params,
 				struct snd_soc_dai *dai)
 {
-	struct device *dev = substream->pcm->card->dev;
+	struct device *dev = dai->dev;
 	struct tegra20_spdif *spdif = snd_soc_dai_get_drvdata(dai);
 	int ret, spdifclock;
 

commit 9515c1010c98347ec92d923bd3e23793fa6dc6fe
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Jun 6 17:15:07 2012 -0600

    ASoC: tegra: add .stream_name to CPU DAIs
    
    This is certainly required if the I2S and SPDIF controllers are converted
    to be CODECs, and is probably good practice irrespective.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index f9b57418bd08..ffbd99c4106e 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -181,6 +181,7 @@ static struct snd_soc_dai_driver tegra20_spdif_dai = {
 	.name = DRV_NAME,
 	.probe = tegra20_spdif_probe,
 	.playback = {
+		.stream_name = "Playback",
 		.channels_min = 2,
 		.channels_max = 2,
 		.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |

commit 5939ae74753ceda976732899bef71f99ffea6ea5
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 13 12:14:07 2012 -0600

    ASoC: convert Tegra20 SPDIF driver to regmap
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 9efd71e13a0a..f9b57418bd08 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -21,13 +21,12 @@
  */
 
 #include <linux/clk.h>
-#include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
-#include <linux/seq_file.h>
+#include <linux/regmap.h>
 #include <linux/slab.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -41,12 +40,14 @@
 static inline void tegra20_spdif_write(struct tegra20_spdif *spdif, u32 reg,
 					u32 val)
 {
-	__raw_writel(val, spdif->regs + reg);
+	regmap_write(spdif->regmap, reg, val);
 }
 
 static inline u32 tegra20_spdif_read(struct tegra20_spdif *spdif, u32 reg)
 {
-	return __raw_readl(spdif->regs + reg);
+	u32 val;
+	regmap_read(spdif->regmap, reg, &val);
+	return val;
 }
 
 static int tegra20_spdif_runtime_suspend(struct device *dev)
@@ -72,78 +73,6 @@ static int tegra20_spdif_runtime_resume(struct device *dev)
 	return 0;
 }
 
-#ifdef CONFIG_DEBUG_FS
-static int tegra20_spdif_show(struct seq_file *s, void *unused)
-{
-#define REG(r) { r, #r }
-	static const struct {
-		int offset;
-		const char *name;
-	} regs[] = {
-		REG(TEGRA20_SPDIF_CTRL),
-		REG(TEGRA20_SPDIF_STATUS),
-		REG(TEGRA20_SPDIF_STROBE_CTRL),
-		REG(TEGRA20_SPDIF_DATA_FIFO_CSR),
-		REG(TEGRA20_SPDIF_CH_STA_RX_A),
-		REG(TEGRA20_SPDIF_CH_STA_RX_B),
-		REG(TEGRA20_SPDIF_CH_STA_RX_C),
-		REG(TEGRA20_SPDIF_CH_STA_RX_D),
-		REG(TEGRA20_SPDIF_CH_STA_RX_E),
-		REG(TEGRA20_SPDIF_CH_STA_RX_F),
-		REG(TEGRA20_SPDIF_CH_STA_TX_A),
-		REG(TEGRA20_SPDIF_CH_STA_TX_B),
-		REG(TEGRA20_SPDIF_CH_STA_TX_C),
-		REG(TEGRA20_SPDIF_CH_STA_TX_D),
-		REG(TEGRA20_SPDIF_CH_STA_TX_E),
-		REG(TEGRA20_SPDIF_CH_STA_TX_F),
-	};
-#undef REG
-
-	struct tegra20_spdif *spdif = s->private;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(regs); i++) {
-		u32 val = tegra20_spdif_read(spdif, regs[i].offset);
-		seq_printf(s, "%s = %08x\n", regs[i].name, val);
-	}
-
-	return 0;
-}
-
-static int tegra20_spdif_debug_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, tegra20_spdif_show, inode->i_private);
-}
-
-static const struct file_operations tegra20_spdif_debug_fops = {
-	.open    = tegra20_spdif_debug_open,
-	.read    = seq_read,
-	.llseek  = seq_lseek,
-	.release = single_release,
-};
-
-static void tegra20_spdif_debug_add(struct tegra20_spdif *spdif)
-{
-	spdif->debug = debugfs_create_file(DRV_NAME, S_IRUGO,
-						snd_soc_debugfs_root, spdif,
-						&tegra20_spdif_debug_fops);
-}
-
-static void tegra20_spdif_debug_remove(struct tegra20_spdif *spdif)
-{
-	if (spdif->debug)
-		debugfs_remove(spdif->debug);
-}
-#else
-static inline void tegra20_spdif_debug_add(struct tegra20_spdif *spdif)
-{
-}
-
-static inline void tegra20_spdif_debug_remove(struct tegra20_spdif *spdif)
-{
-}
-#endif
-
 static int tegra20_spdif_hw_params(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params,
 				struct snd_soc_dai *dai)
@@ -261,10 +190,86 @@ static struct snd_soc_dai_driver tegra20_spdif_dai = {
 	.ops = &tegra20_spdif_dai_ops,
 };
 
+static bool tegra20_spdif_wr_rd_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case TEGRA20_SPDIF_CTRL:
+	case TEGRA20_SPDIF_STATUS:
+	case TEGRA20_SPDIF_STROBE_CTRL:
+	case TEGRA20_SPDIF_DATA_FIFO_CSR:
+	case TEGRA20_SPDIF_DATA_OUT:
+	case TEGRA20_SPDIF_DATA_IN:
+	case TEGRA20_SPDIF_CH_STA_RX_A:
+	case TEGRA20_SPDIF_CH_STA_RX_B:
+	case TEGRA20_SPDIF_CH_STA_RX_C:
+	case TEGRA20_SPDIF_CH_STA_RX_D:
+	case TEGRA20_SPDIF_CH_STA_RX_E:
+	case TEGRA20_SPDIF_CH_STA_RX_F:
+	case TEGRA20_SPDIF_CH_STA_TX_A:
+	case TEGRA20_SPDIF_CH_STA_TX_B:
+	case TEGRA20_SPDIF_CH_STA_TX_C:
+	case TEGRA20_SPDIF_CH_STA_TX_D:
+	case TEGRA20_SPDIF_CH_STA_TX_E:
+	case TEGRA20_SPDIF_CH_STA_TX_F:
+	case TEGRA20_SPDIF_USR_STA_RX_A:
+	case TEGRA20_SPDIF_USR_DAT_TX_A:
+		return true;
+	default:
+		return false;
+	};
+}
+
+static bool tegra20_spdif_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case TEGRA20_SPDIF_STATUS:
+	case TEGRA20_SPDIF_DATA_FIFO_CSR:
+	case TEGRA20_SPDIF_DATA_OUT:
+	case TEGRA20_SPDIF_DATA_IN:
+	case TEGRA20_SPDIF_CH_STA_RX_A:
+	case TEGRA20_SPDIF_CH_STA_RX_B:
+	case TEGRA20_SPDIF_CH_STA_RX_C:
+	case TEGRA20_SPDIF_CH_STA_RX_D:
+	case TEGRA20_SPDIF_CH_STA_RX_E:
+	case TEGRA20_SPDIF_CH_STA_RX_F:
+	case TEGRA20_SPDIF_USR_STA_RX_A:
+	case TEGRA20_SPDIF_USR_DAT_TX_A:
+		return true;
+	default:
+		return false;
+	};
+}
+
+static bool tegra20_spdif_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case TEGRA20_SPDIF_DATA_OUT:
+	case TEGRA20_SPDIF_DATA_IN:
+	case TEGRA20_SPDIF_USR_STA_RX_A:
+	case TEGRA20_SPDIF_USR_DAT_TX_A:
+		return true;
+	default:
+		return false;
+	};
+}
+
+static const struct regmap_config tegra20_spdif_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = TEGRA20_SPDIF_USR_DAT_TX_A,
+	.writeable_reg = tegra20_spdif_wr_rd_reg,
+	.readable_reg = tegra20_spdif_wr_rd_reg,
+	.volatile_reg = tegra20_spdif_volatile_reg,
+	.precious_reg = tegra20_spdif_precious_reg,
+	.cache_type = REGCACHE_RBTREE,
+};
+
 static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 {
 	struct tegra20_spdif *spdif;
 	struct resource *mem, *memregion, *dmareq;
+	void __iomem *regs;
 	int ret;
 
 	spdif = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_spdif),
@@ -305,13 +310,21 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 		goto err_clk_put;
 	}
 
-	spdif->regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
-	if (!spdif->regs) {
+	regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
+	if (!regs) {
 		dev_err(&pdev->dev, "ioremap failed\n");
 		ret = -ENOMEM;
 		goto err_clk_put;
 	}
 
+	spdif->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					    &tegra20_spdif_regmap_config);
+	if (IS_ERR(spdif->regmap)) {
+		dev_err(&pdev->dev, "regmap init failed\n");
+		ret = PTR_ERR(spdif->regmap);
+		goto err_clk_put;
+	}
+
 	spdif->playback_dma_data.addr = mem->start + TEGRA20_SPDIF_DATA_OUT;
 	spdif->playback_dma_data.wrap = 4;
 	spdif->playback_dma_data.width = 32;
@@ -337,8 +350,6 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 		goto err_unregister_dai;
 	}
 
-	tegra20_spdif_debug_add(spdif);
-
 	return 0;
 
 err_unregister_dai:
@@ -365,8 +376,6 @@ static int __devexit tegra20_spdif_platform_remove(struct platform_device *pdev)
 	tegra_pcm_platform_unregister(&pdev->dev);
 	snd_soc_unregister_dai(&pdev->dev);
 
-	tegra20_spdif_debug_remove(spdif);
-
 	clk_put(spdif->clk_spdif_out);
 
 	return 0;

commit 82ef0ae46b8614f052cc3ee856c5624eff614063
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Apr 9 09:52:22 2012 -0600

    ASoC: tegra: add runtime PM support
    
    To the Tegra I2S and SPDIF drivers
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index ef5d49ed5658..9efd71e13a0a 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -26,6 +26,7 @@
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
 #include <sound/core.h>
@@ -48,6 +49,29 @@ static inline u32 tegra20_spdif_read(struct tegra20_spdif *spdif, u32 reg)
 	return __raw_readl(spdif->regs + reg);
 }
 
+static int tegra20_spdif_runtime_suspend(struct device *dev)
+{
+	struct tegra20_spdif *spdif = dev_get_drvdata(dev);
+
+	clk_disable(spdif->clk_spdif_out);
+
+	return 0;
+}
+
+static int tegra20_spdif_runtime_resume(struct device *dev)
+{
+	struct tegra20_spdif *spdif = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_enable(spdif->clk_spdif_out);
+	if (ret) {
+		dev_err(dev, "clk_enable failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
 #ifdef CONFIG_DEBUG_FS
 static int tegra20_spdif_show(struct seq_file *s, void *unused)
 {
@@ -195,14 +219,12 @@ static int tegra20_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 	case SNDRV_PCM_TRIGGER_RESUME:
-		clk_enable(spdif->clk_spdif_out);
 		tegra20_spdif_start_playback(spdif);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 		tegra20_spdif_stop_playback(spdif);
-		clk_disable(spdif->clk_spdif_out);
 		break;
 	default:
 		return -EINVAL;
@@ -295,11 +317,18 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	spdif->playback_dma_data.width = 32;
 	spdif->playback_dma_data.req_sel = dmareq->start;
 
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = tegra20_spdif_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
 	ret = snd_soc_register_dai(&pdev->dev, &tegra20_spdif_dai);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
 		ret = -ENOMEM;
-		goto err_clk_put;
+		goto err_suspend;
 	}
 
 	ret = tegra_pcm_platform_register(&pdev->dev);
@@ -314,6 +343,11 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 
 err_unregister_dai:
 	snd_soc_unregister_dai(&pdev->dev);
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		tegra20_spdif_runtime_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
 err_clk_put:
 	clk_put(spdif->clk_spdif_out);
 err:
@@ -324,6 +358,10 @@ static int __devexit tegra20_spdif_platform_remove(struct platform_device *pdev)
 {
 	struct tegra20_spdif *spdif = dev_get_drvdata(&pdev->dev);
 
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		tegra20_spdif_runtime_suspend(&pdev->dev);
+
 	tegra_pcm_platform_unregister(&pdev->dev);
 	snd_soc_unregister_dai(&pdev->dev);
 
@@ -334,10 +372,16 @@ static int __devexit tegra20_spdif_platform_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct dev_pm_ops tegra20_spdif_pm_ops __devinitconst = {
+	SET_RUNTIME_PM_OPS(tegra20_spdif_runtime_suspend,
+			   tegra20_spdif_runtime_resume, NULL)
+};
+
 static struct platform_driver tegra20_spdif_driver = {
 	.driver = {
 		.name = DRV_NAME,
 		.owner = THIS_MODULE,
+		.pm = &tegra20_spdif_pm_ops,
 	},
 	.probe = tegra20_spdif_platform_probe,
 	.remove = __devexit_p(tegra20_spdif_platform_remove),

commit 17933db2e4758b0cefdf23124087b488bce24b82
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 6 11:14:04 2012 -0600

    ASoC: tegra: use devm_ APIs in SPDIF driver
    
    The devm_ APIs remove the need to manually clean up allocations,
    thus removing some code.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 00a2d33352f4..ef5d49ed5658 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -245,11 +245,12 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	struct resource *mem, *memregion, *dmareq;
 	int ret;
 
-	spdif = kzalloc(sizeof(struct tegra20_spdif), GFP_KERNEL);
+	spdif = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_spdif),
+			     GFP_KERNEL);
 	if (!spdif) {
 		dev_err(&pdev->dev, "Can't allocate tegra20_spdif\n");
 		ret = -ENOMEM;
-		goto exit;
+		goto err;
 	}
 	dev_set_drvdata(&pdev->dev, spdif);
 
@@ -257,7 +258,7 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	if (IS_ERR(spdif->clk_spdif_out)) {
 		pr_err("Can't retrieve spdif clock\n");
 		ret = PTR_ERR(spdif->clk_spdif_out);
-		goto err_free;
+		goto err;
 	}
 
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -274,19 +275,19 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 		goto err_clk_put;
 	}
 
-	memregion = request_mem_region(mem->start, resource_size(mem),
-					DRV_NAME);
+	memregion = devm_request_mem_region(&pdev->dev, mem->start,
+					    resource_size(mem), DRV_NAME);
 	if (!memregion) {
 		dev_err(&pdev->dev, "Memory region already claimed\n");
 		ret = -EBUSY;
 		goto err_clk_put;
 	}
 
-	spdif->regs = ioremap(mem->start, resource_size(mem));
+	spdif->regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
 	if (!spdif->regs) {
 		dev_err(&pdev->dev, "ioremap failed\n");
 		ret = -ENOMEM;
-		goto err_release;
+		goto err_clk_put;
 	}
 
 	spdif->playback_dma_data.addr = mem->start + TEGRA20_SPDIF_DATA_OUT;
@@ -298,7 +299,7 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
 		ret = -ENOMEM;
-		goto err_unmap;
+		goto err_clk_put;
 	}
 
 	ret = tegra_pcm_platform_register(&pdev->dev);
@@ -313,37 +314,23 @@ static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 
 err_unregister_dai:
 	snd_soc_unregister_dai(&pdev->dev);
-err_unmap:
-	iounmap(spdif->regs);
-err_release:
-	release_mem_region(mem->start, resource_size(mem));
 err_clk_put:
 	clk_put(spdif->clk_spdif_out);
-err_free:
-	kfree(spdif);
-exit:
+err:
 	return ret;
 }
 
 static int __devexit tegra20_spdif_platform_remove(struct platform_device *pdev)
 {
 	struct tegra20_spdif *spdif = dev_get_drvdata(&pdev->dev);
-	struct resource *res;
 
 	tegra_pcm_platform_unregister(&pdev->dev);
 	snd_soc_unregister_dai(&pdev->dev);
 
 	tegra20_spdif_debug_remove(spdif);
 
-	iounmap(spdif->regs);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, resource_size(res));
-
 	clk_put(spdif->clk_spdif_out);
 
-	kfree(spdif);
-
 	return 0;
 }
 

commit 7613c508dfd7880cb7e17ad5eb64b9dfb0b80292
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 6 11:12:25 2012 -0600

    ASoC: tegra: sort includes, remove mach/iomap.h
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index 052bff816c4d..00a2d33352f4 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -21,14 +21,13 @@
  */
 
 #include <linux/clk.h>
-#include <linux/module.h>
 #include <linux/debugfs.h>
 #include <linux/device.h>
+#include <linux/io.h>
+#include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
-#include <linux/io.h>
-#include <mach/iomap.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>

commit 896637ac1be95a239b68dbe61c12a8a9bc00a9a3
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 6 10:30:52 2012 -0600

    ASoC: tegra: complete Tegra->Tegra20 renaming
    
    Rename Tegra20-specific Kconfig variables, module filenames, all internal
    symbol names, clocks, and platform devices, to reflect the fact the DAS
    and I2S drivers are for a specific HW version.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
index ed1fd502ef8d..052bff816c4d 100644
--- a/sound/soc/tegra/tegra20_spdif.c
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -36,105 +36,105 @@
 
 #include "tegra20_spdif.h"
 
-#define DRV_NAME "tegra-spdif"
+#define DRV_NAME "tegra20-spdif"
 
-static inline void tegra_spdif_write(struct tegra_spdif *spdif, u32 reg,
+static inline void tegra20_spdif_write(struct tegra20_spdif *spdif, u32 reg,
 					u32 val)
 {
 	__raw_writel(val, spdif->regs + reg);
 }
 
-static inline u32 tegra_spdif_read(struct tegra_spdif *spdif, u32 reg)
+static inline u32 tegra20_spdif_read(struct tegra20_spdif *spdif, u32 reg)
 {
 	return __raw_readl(spdif->regs + reg);
 }
 
 #ifdef CONFIG_DEBUG_FS
-static int tegra_spdif_show(struct seq_file *s, void *unused)
+static int tegra20_spdif_show(struct seq_file *s, void *unused)
 {
 #define REG(r) { r, #r }
 	static const struct {
 		int offset;
 		const char *name;
 	} regs[] = {
-		REG(TEGRA_SPDIF_CTRL),
-		REG(TEGRA_SPDIF_STATUS),
-		REG(TEGRA_SPDIF_STROBE_CTRL),
-		REG(TEGRA_SPDIF_DATA_FIFO_CSR),
-		REG(TEGRA_SPDIF_CH_STA_RX_A),
-		REG(TEGRA_SPDIF_CH_STA_RX_B),
-		REG(TEGRA_SPDIF_CH_STA_RX_C),
-		REG(TEGRA_SPDIF_CH_STA_RX_D),
-		REG(TEGRA_SPDIF_CH_STA_RX_E),
-		REG(TEGRA_SPDIF_CH_STA_RX_F),
-		REG(TEGRA_SPDIF_CH_STA_TX_A),
-		REG(TEGRA_SPDIF_CH_STA_TX_B),
-		REG(TEGRA_SPDIF_CH_STA_TX_C),
-		REG(TEGRA_SPDIF_CH_STA_TX_D),
-		REG(TEGRA_SPDIF_CH_STA_TX_E),
-		REG(TEGRA_SPDIF_CH_STA_TX_F),
+		REG(TEGRA20_SPDIF_CTRL),
+		REG(TEGRA20_SPDIF_STATUS),
+		REG(TEGRA20_SPDIF_STROBE_CTRL),
+		REG(TEGRA20_SPDIF_DATA_FIFO_CSR),
+		REG(TEGRA20_SPDIF_CH_STA_RX_A),
+		REG(TEGRA20_SPDIF_CH_STA_RX_B),
+		REG(TEGRA20_SPDIF_CH_STA_RX_C),
+		REG(TEGRA20_SPDIF_CH_STA_RX_D),
+		REG(TEGRA20_SPDIF_CH_STA_RX_E),
+		REG(TEGRA20_SPDIF_CH_STA_RX_F),
+		REG(TEGRA20_SPDIF_CH_STA_TX_A),
+		REG(TEGRA20_SPDIF_CH_STA_TX_B),
+		REG(TEGRA20_SPDIF_CH_STA_TX_C),
+		REG(TEGRA20_SPDIF_CH_STA_TX_D),
+		REG(TEGRA20_SPDIF_CH_STA_TX_E),
+		REG(TEGRA20_SPDIF_CH_STA_TX_F),
 	};
 #undef REG
 
-	struct tegra_spdif *spdif = s->private;
+	struct tegra20_spdif *spdif = s->private;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(regs); i++) {
-		u32 val = tegra_spdif_read(spdif, regs[i].offset);
+		u32 val = tegra20_spdif_read(spdif, regs[i].offset);
 		seq_printf(s, "%s = %08x\n", regs[i].name, val);
 	}
 
 	return 0;
 }
 
-static int tegra_spdif_debug_open(struct inode *inode, struct file *file)
+static int tegra20_spdif_debug_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, tegra_spdif_show, inode->i_private);
+	return single_open(file, tegra20_spdif_show, inode->i_private);
 }
 
-static const struct file_operations tegra_spdif_debug_fops = {
-	.open    = tegra_spdif_debug_open,
+static const struct file_operations tegra20_spdif_debug_fops = {
+	.open    = tegra20_spdif_debug_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
 	.release = single_release,
 };
 
-static void tegra_spdif_debug_add(struct tegra_spdif *spdif)
+static void tegra20_spdif_debug_add(struct tegra20_spdif *spdif)
 {
 	spdif->debug = debugfs_create_file(DRV_NAME, S_IRUGO,
 						snd_soc_debugfs_root, spdif,
-						&tegra_spdif_debug_fops);
+						&tegra20_spdif_debug_fops);
 }
 
-static void tegra_spdif_debug_remove(struct tegra_spdif *spdif)
+static void tegra20_spdif_debug_remove(struct tegra20_spdif *spdif)
 {
 	if (spdif->debug)
 		debugfs_remove(spdif->debug);
 }
 #else
-static inline void tegra_spdif_debug_add(struct tegra_spdif *spdif)
+static inline void tegra20_spdif_debug_add(struct tegra20_spdif *spdif)
 {
 }
 
-static inline void tegra_spdif_debug_remove(struct tegra_spdif *spdif)
+static inline void tegra20_spdif_debug_remove(struct tegra20_spdif *spdif)
 {
 }
 #endif
 
-static int tegra_spdif_hw_params(struct snd_pcm_substream *substream,
+static int tegra20_spdif_hw_params(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params,
 				struct snd_soc_dai *dai)
 {
 	struct device *dev = substream->pcm->card->dev;
-	struct tegra_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+	struct tegra20_spdif *spdif = snd_soc_dai_get_drvdata(dai);
 	int ret, spdifclock;
 
-	spdif->reg_ctrl &= ~TEGRA_SPDIF_CTRL_PACK;
-	spdif->reg_ctrl &= ~TEGRA_SPDIF_CTRL_BIT_MODE_MASK;
+	spdif->reg_ctrl &= ~TEGRA20_SPDIF_CTRL_PACK;
+	spdif->reg_ctrl &= ~TEGRA20_SPDIF_CTRL_BIT_MODE_MASK;
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
-		spdif->reg_ctrl |= TEGRA_SPDIF_CTRL_PACK;
-		spdif->reg_ctrl |= TEGRA_SPDIF_CTRL_BIT_MODE_16BIT;
+		spdif->reg_ctrl |= TEGRA20_SPDIF_CTRL_PACK;
+		spdif->reg_ctrl |= TEGRA20_SPDIF_CTRL_BIT_MODE_16BIT;
 		break;
 	default:
 		return -EINVAL;
@@ -175,34 +175,34 @@ static int tegra_spdif_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static void tegra_spdif_start_playback(struct tegra_spdif *spdif)
+static void tegra20_spdif_start_playback(struct tegra20_spdif *spdif)
 {
-	spdif->reg_ctrl |= TEGRA_SPDIF_CTRL_TX_EN;
-	tegra_spdif_write(spdif, TEGRA_SPDIF_CTRL, spdif->reg_ctrl);
+	spdif->reg_ctrl |= TEGRA20_SPDIF_CTRL_TX_EN;
+	tegra20_spdif_write(spdif, TEGRA20_SPDIF_CTRL, spdif->reg_ctrl);
 }
 
-static void tegra_spdif_stop_playback(struct tegra_spdif *spdif)
+static void tegra20_spdif_stop_playback(struct tegra20_spdif *spdif)
 {
-	spdif->reg_ctrl &= ~TEGRA_SPDIF_CTRL_TX_EN;
-	tegra_spdif_write(spdif, TEGRA_SPDIF_CTRL, spdif->reg_ctrl);
+	spdif->reg_ctrl &= ~TEGRA20_SPDIF_CTRL_TX_EN;
+	tegra20_spdif_write(spdif, TEGRA20_SPDIF_CTRL, spdif->reg_ctrl);
 }
 
-static int tegra_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
+static int tegra20_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 				struct snd_soc_dai *dai)
 {
-	struct tegra_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+	struct tegra20_spdif *spdif = snd_soc_dai_get_drvdata(dai);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 	case SNDRV_PCM_TRIGGER_RESUME:
 		clk_enable(spdif->clk_spdif_out);
-		tegra_spdif_start_playback(spdif);
+		tegra20_spdif_start_playback(spdif);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
-		tegra_spdif_stop_playback(spdif);
+		tegra20_spdif_stop_playback(spdif);
 		clk_disable(spdif->clk_spdif_out);
 		break;
 	default:
@@ -212,9 +212,9 @@ static int tegra_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
-static int tegra_spdif_probe(struct snd_soc_dai *dai)
+static int tegra20_spdif_probe(struct snd_soc_dai *dai)
 {
-	struct tegra_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+	struct tegra20_spdif *spdif = snd_soc_dai_get_drvdata(dai);
 
 	dai->capture_dma_data = NULL;
 	dai->playback_dma_data = &spdif->playback_dma_data;
@@ -222,14 +222,14 @@ static int tegra_spdif_probe(struct snd_soc_dai *dai)
 	return 0;
 }
 
-static const struct snd_soc_dai_ops tegra_spdif_dai_ops = {
-	.hw_params	= tegra_spdif_hw_params,
-	.trigger	= tegra_spdif_trigger,
+static const struct snd_soc_dai_ops tegra20_spdif_dai_ops = {
+	.hw_params	= tegra20_spdif_hw_params,
+	.trigger	= tegra20_spdif_trigger,
 };
 
-static struct snd_soc_dai_driver tegra_spdif_dai = {
+static struct snd_soc_dai_driver tegra20_spdif_dai = {
 	.name = DRV_NAME,
-	.probe = tegra_spdif_probe,
+	.probe = tegra20_spdif_probe,
 	.playback = {
 		.channels_min = 2,
 		.channels_max = 2,
@@ -237,18 +237,18 @@ static struct snd_soc_dai_driver tegra_spdif_dai = {
 				SNDRV_PCM_RATE_48000,
 		.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	},
-	.ops = &tegra_spdif_dai_ops,
+	.ops = &tegra20_spdif_dai_ops,
 };
 
-static __devinit int tegra_spdif_platform_probe(struct platform_device *pdev)
+static __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)
 {
-	struct tegra_spdif *spdif;
+	struct tegra20_spdif *spdif;
 	struct resource *mem, *memregion, *dmareq;
 	int ret;
 
-	spdif = kzalloc(sizeof(struct tegra_spdif), GFP_KERNEL);
+	spdif = kzalloc(sizeof(struct tegra20_spdif), GFP_KERNEL);
 	if (!spdif) {
-		dev_err(&pdev->dev, "Can't allocate tegra_spdif\n");
+		dev_err(&pdev->dev, "Can't allocate tegra20_spdif\n");
 		ret = -ENOMEM;
 		goto exit;
 	}
@@ -290,12 +290,12 @@ static __devinit int tegra_spdif_platform_probe(struct platform_device *pdev)
 		goto err_release;
 	}
 
-	spdif->playback_dma_data.addr = mem->start + TEGRA_SPDIF_DATA_OUT;
+	spdif->playback_dma_data.addr = mem->start + TEGRA20_SPDIF_DATA_OUT;
 	spdif->playback_dma_data.wrap = 4;
 	spdif->playback_dma_data.width = 32;
 	spdif->playback_dma_data.req_sel = dmareq->start;
 
-	ret = snd_soc_register_dai(&pdev->dev, &tegra_spdif_dai);
+	ret = snd_soc_register_dai(&pdev->dev, &tegra20_spdif_dai);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
 		ret = -ENOMEM;
@@ -308,7 +308,7 @@ static __devinit int tegra_spdif_platform_probe(struct platform_device *pdev)
 		goto err_unregister_dai;
 	}
 
-	tegra_spdif_debug_add(spdif);
+	tegra20_spdif_debug_add(spdif);
 
 	return 0;
 
@@ -326,15 +326,15 @@ static __devinit int tegra_spdif_platform_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit tegra_spdif_platform_remove(struct platform_device *pdev)
+static int __devexit tegra20_spdif_platform_remove(struct platform_device *pdev)
 {
-	struct tegra_spdif *spdif = dev_get_drvdata(&pdev->dev);
+	struct tegra20_spdif *spdif = dev_get_drvdata(&pdev->dev);
 	struct resource *res;
 
 	tegra_pcm_platform_unregister(&pdev->dev);
 	snd_soc_unregister_dai(&pdev->dev);
 
-	tegra_spdif_debug_remove(spdif);
+	tegra20_spdif_debug_remove(spdif);
 
 	iounmap(spdif->regs);
 
@@ -348,18 +348,18 @@ static int __devexit tegra_spdif_platform_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static struct platform_driver tegra_spdif_driver = {
+static struct platform_driver tegra20_spdif_driver = {
 	.driver = {
 		.name = DRV_NAME,
 		.owner = THIS_MODULE,
 	},
-	.probe = tegra_spdif_platform_probe,
-	.remove = __devexit_p(tegra_spdif_platform_remove),
+	.probe = tegra20_spdif_platform_probe,
+	.remove = __devexit_p(tegra20_spdif_platform_remove),
 };
 
-module_platform_driver(tegra_spdif_driver);
+module_platform_driver(tegra20_spdif_driver);
 
 MODULE_AUTHOR("Stephen Warren <swarren@nvidia.com>");
-MODULE_DESCRIPTION("Tegra SPDIF ASoC driver");
+MODULE_DESCRIPTION("Tegra20 SPDIF ASoC driver");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:" DRV_NAME);

commit ef280d3907cea21b6093802398bbe4193e221a64
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Apr 5 15:54:53 2012 -0600

    ASoC: tegra: rename Tegra20-specific driver files
    
    Rename these files so they include a specific hardware version in their
    filenames. The contents is only touched minimally so that git's rename
    tracking operates correctly; renaming all symbols in the files results
    in a diff so large that the rename detection fails.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_spdif.c b/sound/soc/tegra/tegra20_spdif.c
new file mode 100644
index 000000000000..ed1fd502ef8d
--- /dev/null
+++ b/sound/soc/tegra/tegra20_spdif.c
@@ -0,0 +1,365 @@
+/*
+ * tegra20_spdif.c - Tegra20 SPDIF driver
+ *
+ * Author: Stephen Warren <swarren@nvidia.com>
+ * Copyright (C) 2011-2012 - NVIDIA, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <mach/iomap.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "tegra20_spdif.h"
+
+#define DRV_NAME "tegra-spdif"
+
+static inline void tegra_spdif_write(struct tegra_spdif *spdif, u32 reg,
+					u32 val)
+{
+	__raw_writel(val, spdif->regs + reg);
+}
+
+static inline u32 tegra_spdif_read(struct tegra_spdif *spdif, u32 reg)
+{
+	return __raw_readl(spdif->regs + reg);
+}
+
+#ifdef CONFIG_DEBUG_FS
+static int tegra_spdif_show(struct seq_file *s, void *unused)
+{
+#define REG(r) { r, #r }
+	static const struct {
+		int offset;
+		const char *name;
+	} regs[] = {
+		REG(TEGRA_SPDIF_CTRL),
+		REG(TEGRA_SPDIF_STATUS),
+		REG(TEGRA_SPDIF_STROBE_CTRL),
+		REG(TEGRA_SPDIF_DATA_FIFO_CSR),
+		REG(TEGRA_SPDIF_CH_STA_RX_A),
+		REG(TEGRA_SPDIF_CH_STA_RX_B),
+		REG(TEGRA_SPDIF_CH_STA_RX_C),
+		REG(TEGRA_SPDIF_CH_STA_RX_D),
+		REG(TEGRA_SPDIF_CH_STA_RX_E),
+		REG(TEGRA_SPDIF_CH_STA_RX_F),
+		REG(TEGRA_SPDIF_CH_STA_TX_A),
+		REG(TEGRA_SPDIF_CH_STA_TX_B),
+		REG(TEGRA_SPDIF_CH_STA_TX_C),
+		REG(TEGRA_SPDIF_CH_STA_TX_D),
+		REG(TEGRA_SPDIF_CH_STA_TX_E),
+		REG(TEGRA_SPDIF_CH_STA_TX_F),
+	};
+#undef REG
+
+	struct tegra_spdif *spdif = s->private;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(regs); i++) {
+		u32 val = tegra_spdif_read(spdif, regs[i].offset);
+		seq_printf(s, "%s = %08x\n", regs[i].name, val);
+	}
+
+	return 0;
+}
+
+static int tegra_spdif_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, tegra_spdif_show, inode->i_private);
+}
+
+static const struct file_operations tegra_spdif_debug_fops = {
+	.open    = tegra_spdif_debug_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+};
+
+static void tegra_spdif_debug_add(struct tegra_spdif *spdif)
+{
+	spdif->debug = debugfs_create_file(DRV_NAME, S_IRUGO,
+						snd_soc_debugfs_root, spdif,
+						&tegra_spdif_debug_fops);
+}
+
+static void tegra_spdif_debug_remove(struct tegra_spdif *spdif)
+{
+	if (spdif->debug)
+		debugfs_remove(spdif->debug);
+}
+#else
+static inline void tegra_spdif_debug_add(struct tegra_spdif *spdif)
+{
+}
+
+static inline void tegra_spdif_debug_remove(struct tegra_spdif *spdif)
+{
+}
+#endif
+
+static int tegra_spdif_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct device *dev = substream->pcm->card->dev;
+	struct tegra_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+	int ret, spdifclock;
+
+	spdif->reg_ctrl &= ~TEGRA_SPDIF_CTRL_PACK;
+	spdif->reg_ctrl &= ~TEGRA_SPDIF_CTRL_BIT_MODE_MASK;
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		spdif->reg_ctrl |= TEGRA_SPDIF_CTRL_PACK;
+		spdif->reg_ctrl |= TEGRA_SPDIF_CTRL_BIT_MODE_16BIT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (params_rate(params)) {
+	case 32000:
+		spdifclock = 4096000;
+		break;
+	case 44100:
+		spdifclock = 5644800;
+		break;
+	case 48000:
+		spdifclock = 6144000;
+		break;
+	case 88200:
+		spdifclock = 11289600;
+		break;
+	case 96000:
+		spdifclock = 12288000;
+		break;
+	case 176400:
+		spdifclock = 22579200;
+		break;
+	case 192000:
+		spdifclock = 24576000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = clk_set_rate(spdif->clk_spdif_out, spdifclock);
+	if (ret) {
+		dev_err(dev, "Can't set SPDIF clock rate: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void tegra_spdif_start_playback(struct tegra_spdif *spdif)
+{
+	spdif->reg_ctrl |= TEGRA_SPDIF_CTRL_TX_EN;
+	tegra_spdif_write(spdif, TEGRA_SPDIF_CTRL, spdif->reg_ctrl);
+}
+
+static void tegra_spdif_stop_playback(struct tegra_spdif *spdif)
+{
+	spdif->reg_ctrl &= ~TEGRA_SPDIF_CTRL_TX_EN;
+	tegra_spdif_write(spdif, TEGRA_SPDIF_CTRL, spdif->reg_ctrl);
+}
+
+static int tegra_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	struct tegra_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		clk_enable(spdif->clk_spdif_out);
+		tegra_spdif_start_playback(spdif);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		tegra_spdif_stop_playback(spdif);
+		clk_disable(spdif->clk_spdif_out);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int tegra_spdif_probe(struct snd_soc_dai *dai)
+{
+	struct tegra_spdif *spdif = snd_soc_dai_get_drvdata(dai);
+
+	dai->capture_dma_data = NULL;
+	dai->playback_dma_data = &spdif->playback_dma_data;
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops tegra_spdif_dai_ops = {
+	.hw_params	= tegra_spdif_hw_params,
+	.trigger	= tegra_spdif_trigger,
+};
+
+static struct snd_soc_dai_driver tegra_spdif_dai = {
+	.name = DRV_NAME,
+	.probe = tegra_spdif_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &tegra_spdif_dai_ops,
+};
+
+static __devinit int tegra_spdif_platform_probe(struct platform_device *pdev)
+{
+	struct tegra_spdif *spdif;
+	struct resource *mem, *memregion, *dmareq;
+	int ret;
+
+	spdif = kzalloc(sizeof(struct tegra_spdif), GFP_KERNEL);
+	if (!spdif) {
+		dev_err(&pdev->dev, "Can't allocate tegra_spdif\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+	dev_set_drvdata(&pdev->dev, spdif);
+
+	spdif->clk_spdif_out = clk_get(&pdev->dev, "spdif_out");
+	if (IS_ERR(spdif->clk_spdif_out)) {
+		pr_err("Can't retrieve spdif clock\n");
+		ret = PTR_ERR(spdif->clk_spdif_out);
+		goto err_free;
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "No memory resource\n");
+		ret = -ENODEV;
+		goto err_clk_put;
+	}
+
+	dmareq = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (!dmareq) {
+		dev_err(&pdev->dev, "No DMA resource\n");
+		ret = -ENODEV;
+		goto err_clk_put;
+	}
+
+	memregion = request_mem_region(mem->start, resource_size(mem),
+					DRV_NAME);
+	if (!memregion) {
+		dev_err(&pdev->dev, "Memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_clk_put;
+	}
+
+	spdif->regs = ioremap(mem->start, resource_size(mem));
+	if (!spdif->regs) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_release;
+	}
+
+	spdif->playback_dma_data.addr = mem->start + TEGRA_SPDIF_DATA_OUT;
+	spdif->playback_dma_data.wrap = 4;
+	spdif->playback_dma_data.width = 32;
+	spdif->playback_dma_data.req_sel = dmareq->start;
+
+	ret = snd_soc_register_dai(&pdev->dev, &tegra_spdif_dai);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_unmap;
+	}
+
+	ret = tegra_pcm_platform_register(&pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		goto err_unregister_dai;
+	}
+
+	tegra_spdif_debug_add(spdif);
+
+	return 0;
+
+err_unregister_dai:
+	snd_soc_unregister_dai(&pdev->dev);
+err_unmap:
+	iounmap(spdif->regs);
+err_release:
+	release_mem_region(mem->start, resource_size(mem));
+err_clk_put:
+	clk_put(spdif->clk_spdif_out);
+err_free:
+	kfree(spdif);
+exit:
+	return ret;
+}
+
+static int __devexit tegra_spdif_platform_remove(struct platform_device *pdev)
+{
+	struct tegra_spdif *spdif = dev_get_drvdata(&pdev->dev);
+	struct resource *res;
+
+	tegra_pcm_platform_unregister(&pdev->dev);
+	snd_soc_unregister_dai(&pdev->dev);
+
+	tegra_spdif_debug_remove(spdif);
+
+	iounmap(spdif->regs);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	clk_put(spdif->clk_spdif_out);
+
+	kfree(spdif);
+
+	return 0;
+}
+
+static struct platform_driver tegra_spdif_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = tegra_spdif_platform_probe,
+	.remove = __devexit_p(tegra_spdif_platform_remove),
+};
+
+module_platform_driver(tegra_spdif_driver);
+
+MODULE_AUTHOR("Stephen Warren <swarren@nvidia.com>");
+MODULE_DESCRIPTION("Tegra SPDIF ASoC driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
