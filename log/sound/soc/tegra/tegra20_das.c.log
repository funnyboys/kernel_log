commit 21cc4ea85879c1b424fb01caa6e481c14286f7f0
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sat Jul 27 23:07:05 2019 +0800

    ASoC: tegra20_das: use devm_platform_ioremap_resource() to simplify code
    
    Use devm_platform_ioremap_resource() to simplify the code a bit.
    This is detected by coccinelle.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lore.kernel.org/r/20190727150738.54764-2-yuehaibing@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index 10f9c3b19c88..1070b2710d5e 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -120,7 +120,6 @@ static const struct regmap_config tegra20_das_regmap_config = {
 
 static int tegra20_das_probe(struct platform_device *pdev)
 {
-	struct resource *res;
 	void __iomem *regs;
 	int ret = 0;
 
@@ -134,8 +133,7 @@ static int tegra20_das_probe(struct platform_device *pdev)
 	}
 	das->dev = &pdev->dev;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	regs = devm_ioremap_resource(&pdev->dev, res);
+	regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(regs)) {
 		ret = PTR_ERR(regs);
 		goto err;

commit 2b27bdcc20958d644d04f9f12d683e52b37a5427
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:50 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 336
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin st fifth floor boston ma 02110
      1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 246 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.674189849@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index 4024e3abbeed..10f9c3b19c88 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -1,23 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * tegra20_das.c - Tegra20 DAS driver
  *
  * Author: Stephen Warren <swarren@nvidia.com>
  * Copyright (C) 2010 - NVIDIA, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
  */
 
 #include <linux/device.h>

commit bf3c6ef7f5b1e43739ad0356a5afee5127c86465
Author: Codrut Grosu <codrut.cristian.grosu@gmail.com>
Date:   Sat Feb 25 20:59:17 2017 +0200

    ASoC: tegra: Add blank line after declarations
    
    This was reported by checkpatch.pl
    
    Signed-off-by: Codrut GROSU <codrut.cristian.grosu@gmail.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index 6d4a2774135e..4024e3abbeed 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -41,6 +41,7 @@ static inline void tegra20_das_write(u32 reg, u32 val)
 static inline u32 tegra20_das_read(u32 reg)
 {
 	u32 val;
+
 	regmap_read(das->regmap, reg, &val);
 	return val;
 }

commit e2c187a689b4a717024ba90c67a6ecd8ff36a23e
Author: Codrut Grosu <codrut.cristian.grosu@gmail.com>
Date:   Sat Feb 25 13:18:08 2017 +0200

    ASoC: tegra: Remove unnecessary 'out of memory' message
    
    This was reported by checkpatch.pl
    
    Signed-off-by: Codrut GROSU <codrut.cristian.grosu@gmail.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index 89add13c31cf..6d4a2774135e 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -142,7 +142,6 @@ static int tegra20_das_probe(struct platform_device *pdev)
 
 	das = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_das), GFP_KERNEL);
 	if (!das) {
-		dev_err(&pdev->dev, "Can't allocate tegra20_das\n");
 		ret = -ENOMEM;
 		goto err;
 	}

commit f57ddcdfa146636dbdcd6ac0a6d22c15d47b08c8
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Aug 23 23:32:14 2015 +0800

    ASoC: tegra: Use devm_ioremap_resource instead of open code
    
    Use devm_ioremap_resource() to simplify the code.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index f52600b4f3fd..89add13c31cf 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -133,7 +133,7 @@ static const struct regmap_config tegra20_das_regmap_config = {
 
 static int tegra20_das_probe(struct platform_device *pdev)
 {
-	struct resource *res, *region;
+	struct resource *res;
 	void __iomem *regs;
 	int ret = 0;
 
@@ -149,24 +149,9 @@ static int tegra20_das_probe(struct platform_device *pdev)
 	das->dev = &pdev->dev;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "No memory resource\n");
-		ret = -ENODEV;
-		goto err;
-	}
-
-	region = devm_request_mem_region(&pdev->dev, res->start,
-					 resource_size(res), pdev->name);
-	if (!region) {
-		dev_err(&pdev->dev, "Memory region already claimed\n");
-		ret = -EBUSY;
-		goto err;
-	}
-
-	regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));
-	if (!regs) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-		ret = -ENOMEM;
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs)) {
+		ret = PTR_ERR(regs);
 		goto err;
 	}
 

commit 89032b176b8200257de2f21ee57ddaef8a212e8c
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:22:15 2014 +0200

    ASoC: tegra: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index a634f13b3ffc..f52600b4f3fd 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -233,7 +233,6 @@ static struct platform_driver tegra20_das_driver = {
 	.remove = tegra20_das_remove,
 	.driver = {
 		.name = DRV_NAME,
-		.owner = THIS_MODULE,
 		.of_match_table = tegra20_das_of_match,
 	},
 };

commit 591d14f00796a4250d800d316e3db1fea8a57e20
Author: Dylan Reid <dgreid@chromium.org>
Date:   Mon Mar 17 22:08:49 2014 -0700

    ASoC: tegra: Use flat regcache
    
    When using an rbtree cache, there can be allocations the first time a
    register is accessed.  This can cause an attempt to schedule while
    atomic in the case that the regmap is using a spinlock.  This could be
    fixed by either initializing all the registers or using a flat cache.
    The register maps for tegra30_ahub and tegra30_i2s are dense and don't
    save much from using a tree so convert them to flat.
    
    Tegra30 changes tested on Norrin, Tegra20 changes compile.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index e72392927bd2..a634f13b3ffc 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -128,7 +128,7 @@ static const struct regmap_config tegra20_das_regmap_config = {
 	.max_register = LAST_REG(DAC_INPUT_DATA_CLK_SEL),
 	.writeable_reg = tegra20_das_wr_rd_reg,
 	.readable_reg = tegra20_das_wr_rd_reg,
-	.cache_type = REGCACHE_RBTREE,
+	.cache_type = REGCACHE_FLAT,
 };
 
 static int tegra20_das_probe(struct platform_device *pdev)

commit 15fab585070ebdd6b31880b3a9a848389d302dd2
Author: Lucas Stach <dev@lynxeye.de>
Date:   Thu Dec 20 00:17:32 2012 +0100

    ASoC: tegra: setup DAP3<->DAC3 connection by default
    
    This connection is used by the AC97 controller.
    
    Signed-off-by: Lucas Stach <dev@lynxeye.de>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index 654318483877..e72392927bd2 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -191,6 +191,19 @@ static int tegra20_das_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	ret = tegra20_das_connect_dap_to_dac(TEGRA20_DAS_DAP_ID_3,
+					     TEGRA20_DAS_DAP_SEL_DAC3);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't set up DAS DAP connection\n");
+		goto err;
+	}
+	ret = tegra20_das_connect_dac_to_dap(TEGRA20_DAS_DAC_ID_3,
+					     TEGRA20_DAS_DAC_SEL_DAP3);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't set up DAS DAC connection\n");
+		goto err;
+	}
+
 	platform_set_drvdata(pdev, das);
 
 	return 0;

commit 4652a0d0c48324e1227e2b2500d17045840e2fb3
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Dec 7 09:26:33 2012 -0500

    ASoC: tegra: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index 49653375970b..654318483877 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -131,7 +131,7 @@ static const struct regmap_config tegra20_das_regmap_config = {
 	.cache_type = REGCACHE_RBTREE,
 };
 
-static int __devinit tegra20_das_probe(struct platform_device *pdev)
+static int tegra20_das_probe(struct platform_device *pdev)
 {
 	struct resource *res, *region;
 	void __iomem *regs;
@@ -200,7 +200,7 @@ static int __devinit tegra20_das_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit tegra20_das_remove(struct platform_device *pdev)
+static int tegra20_das_remove(struct platform_device *pdev)
 {
 	if (!das)
 		return -ENODEV;
@@ -217,7 +217,7 @@ static const struct of_device_id tegra20_das_of_match[] = {
 
 static struct platform_driver tegra20_das_driver = {
 	.probe = tegra20_das_probe,
-	.remove = __devexit_p(tegra20_das_remove),
+	.remove = tegra20_das_remove,
 	.driver = {
 		.name = DRV_NAME,
 		.owner = THIS_MODULE,

commit f6e6574499eeeeee747d9cfc7ba9f4328bb1806d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:25:33 2012 -0500

    ASoC: remove use of __devinitconst
    
    CONFIG_HOTPLUG is going away as an option so __devinitconst is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index bf99296bce95..49653375970b 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -210,7 +210,7 @@ static int __devexit tegra20_das_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id tegra20_das_of_match[] __devinitconst = {
+static const struct of_device_id tegra20_das_of_match[] = {
 	{ .compatible = "nvidia,tegra20-das", },
 	{},
 };

commit 7203a62562dc45dcd69339d4553fb85453d6b587
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 13 12:14:08 2012 -0600

    ASoC: convert Tegra20 DAS driver to regmap
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index 812696d9c863..bf99296bce95 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -20,12 +20,11 @@
  *
  */
 
-#include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
-#include <linux/seq_file.h>
+#include <linux/regmap.h>
 #include <linux/slab.h>
 #include <sound/soc.h>
 #include "tegra20_das.h"
@@ -36,12 +35,14 @@ static struct tegra20_das *das;
 
 static inline void tegra20_das_write(u32 reg, u32 val)
 {
-	__raw_writel(val, das->regs + reg);
+	regmap_write(das->regmap, reg, val);
 }
 
 static inline u32 tegra20_das_read(u32 reg)
 {
-	return __raw_readl(das->regs + reg);
+	u32 val;
+	regmap_read(das->regmap, reg, &val);
+	return val;
 }
 
 int tegra20_das_connect_dap_to_dac(int dap, int dac)
@@ -104,68 +105,36 @@ int tegra20_das_connect_dac_to_dap(int dac, int dap)
 }
 EXPORT_SYMBOL_GPL(tegra20_das_connect_dac_to_dap);
 
-#ifdef CONFIG_DEBUG_FS
-static int tegra20_das_show(struct seq_file *s, void *unused)
-{
-	int i;
-	u32 addr;
-	u32 reg;
-
-	for (i = 0; i < TEGRA20_DAS_DAP_CTRL_SEL_COUNT; i++) {
-		addr = TEGRA20_DAS_DAP_CTRL_SEL +
-			(i * TEGRA20_DAS_DAP_CTRL_SEL_STRIDE);
-		reg = tegra20_das_read(addr);
-		seq_printf(s, "TEGRA20_DAS_DAP_CTRL_SEL[%d] = %08x\n", i, reg);
-	}
-
-	for (i = 0; i < TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_COUNT; i++) {
-		addr = TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL +
-			(i * TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);
-		reg = tegra20_das_read(addr);
-		seq_printf(s, "TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL[%d] = %08x\n",
-			   i, reg);
-	}
+#define LAST_REG(name) \
+	(TEGRA20_DAS_##name + \
+	 (TEGRA20_DAS_##name##_STRIDE * (TEGRA20_DAS_##name##_COUNT - 1)))
 
-	return 0;
-}
-
-static int tegra20_das_debug_open(struct inode *inode, struct file *file)
+static bool tegra20_das_wr_rd_reg(struct device *dev, unsigned int reg)
 {
-	return single_open(file, tegra20_das_show, inode->i_private);
+	if ((reg >= TEGRA20_DAS_DAP_CTRL_SEL) &&
+	    (reg <= LAST_REG(DAP_CTRL_SEL)))
+		return true;
+	if ((reg >= TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL) &&
+	    (reg <= LAST_REG(DAC_INPUT_DATA_CLK_SEL)))
+		return true;
+
+	return false;
 }
 
-static const struct file_operations tegra20_das_debug_fops = {
-	.open    = tegra20_das_debug_open,
-	.read    = seq_read,
-	.llseek  = seq_lseek,
-	.release = single_release,
+static const struct regmap_config tegra20_das_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = LAST_REG(DAC_INPUT_DATA_CLK_SEL),
+	.writeable_reg = tegra20_das_wr_rd_reg,
+	.readable_reg = tegra20_das_wr_rd_reg,
+	.cache_type = REGCACHE_RBTREE,
 };
 
-static void tegra20_das_debug_add(struct tegra20_das *das)
-{
-	das->debug = debugfs_create_file(DRV_NAME, S_IRUGO,
-					 snd_soc_debugfs_root, das,
-					 &tegra20_das_debug_fops);
-}
-
-static void tegra20_das_debug_remove(struct tegra20_das *das)
-{
-	if (das->debug)
-		debugfs_remove(das->debug);
-}
-#else
-static inline void tegra20_das_debug_add(struct tegra20_das *das)
-{
-}
-
-static inline void tegra20_das_debug_remove(struct tegra20_das *das)
-{
-}
-#endif
-
 static int __devinit tegra20_das_probe(struct platform_device *pdev)
 {
 	struct resource *res, *region;
+	void __iomem *regs;
 	int ret = 0;
 
 	if (das)
@@ -194,13 +163,21 @@ static int __devinit tegra20_das_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	das->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));
-	if (!das->regs) {
+	regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+	if (!regs) {
 		dev_err(&pdev->dev, "ioremap failed\n");
 		ret = -ENOMEM;
 		goto err;
 	}
 
+	das->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					    &tegra20_das_regmap_config);
+	if (IS_ERR(das->regmap)) {
+		dev_err(&pdev->dev, "regmap init failed\n");
+		ret = PTR_ERR(das->regmap);
+		goto err;
+	}
+
 	ret = tegra20_das_connect_dap_to_dac(TEGRA20_DAS_DAP_ID_1,
 					     TEGRA20_DAS_DAP_SEL_DAC1);
 	if (ret) {
@@ -214,8 +191,6 @@ static int __devinit tegra20_das_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	tegra20_das_debug_add(das);
-
 	platform_set_drvdata(pdev, das);
 
 	return 0;
@@ -230,8 +205,6 @@ static int __devexit tegra20_das_remove(struct platform_device *pdev)
 	if (!das)
 		return -ENODEV;
 
-	tegra20_das_debug_remove(das);
-
 	das = NULL;
 
 	return 0;

commit 7613c508dfd7880cb7e17ad5eb64b9dfb0b80292
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 6 11:12:25 2012 -0600

    ASoC: tegra: sort includes, remove mach/iomap.h
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index 486d7b245cf4..812696d9c863 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -20,14 +20,13 @@
  *
  */
 
-#include <linux/module.h>
 #include <linux/debugfs.h>
 #include <linux/device.h>
+#include <linux/io.h>
+#include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
-#include <linux/io.h>
-#include <mach/iomap.h>
 #include <sound/soc.h>
 #include "tegra20_das.h"
 

commit 896637ac1be95a239b68dbe61c12a8a9bc00a9a3
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 6 10:30:52 2012 -0600

    ASoC: tegra: complete Tegra->Tegra20 renaming
    
    Rename Tegra20-specific Kconfig variables, module filenames, all internal
    symbol names, clocks, and platform devices, to reflect the fact the DAS
    and I2S drivers are for a specific HW version.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
index b5e369820cb3..486d7b245cf4 100644
--- a/sound/soc/tegra/tegra20_das.c
+++ b/sound/soc/tegra/tegra20_das.c
@@ -31,21 +31,21 @@
 #include <sound/soc.h>
 #include "tegra20_das.h"
 
-#define DRV_NAME "tegra-das"
+#define DRV_NAME "tegra20-das"
 
-static struct tegra_das *das;
+static struct tegra20_das *das;
 
-static inline void tegra_das_write(u32 reg, u32 val)
+static inline void tegra20_das_write(u32 reg, u32 val)
 {
 	__raw_writel(val, das->regs + reg);
 }
 
-static inline u32 tegra_das_read(u32 reg)
+static inline u32 tegra20_das_read(u32 reg)
 {
 	return __raw_readl(das->regs + reg);
 }
 
-int tegra_das_connect_dap_to_dac(int dap, int dac)
+int tegra20_das_connect_dap_to_dac(int dap, int dac)
 {
 	u32 addr;
 	u32 reg;
@@ -53,18 +53,18 @@ int tegra_das_connect_dap_to_dac(int dap, int dac)
 	if (!das)
 		return -ENODEV;
 
-	addr = TEGRA_DAS_DAP_CTRL_SEL +
-		(dap * TEGRA_DAS_DAP_CTRL_SEL_STRIDE);
-	reg = dac << TEGRA_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P;
+	addr = TEGRA20_DAS_DAP_CTRL_SEL +
+		(dap * TEGRA20_DAS_DAP_CTRL_SEL_STRIDE);
+	reg = dac << TEGRA20_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P;
 
-	tegra_das_write(addr, reg);
+	tegra20_das_write(addr, reg);
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(tegra_das_connect_dap_to_dac);
+EXPORT_SYMBOL_GPL(tegra20_das_connect_dap_to_dac);
 
-int tegra_das_connect_dap_to_dap(int dap, int otherdap, int master,
-					int sdata1rx, int sdata2rx)
+int tegra20_das_connect_dap_to_dap(int dap, int otherdap, int master,
+				   int sdata1rx, int sdata2rx)
 {
 	u32 addr;
 	u32 reg;
@@ -72,20 +72,20 @@ int tegra_das_connect_dap_to_dap(int dap, int otherdap, int master,
 	if (!das)
 		return -ENODEV;
 
-	addr = TEGRA_DAS_DAP_CTRL_SEL +
-		(dap * TEGRA_DAS_DAP_CTRL_SEL_STRIDE);
-	reg = otherdap << TEGRA_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P |
-		!!sdata2rx << TEGRA_DAS_DAP_CTRL_SEL_DAP_SDATA2_TX_RX_P |
-		!!sdata1rx << TEGRA_DAS_DAP_CTRL_SEL_DAP_SDATA1_TX_RX_P |
-		!!master << TEGRA_DAS_DAP_CTRL_SEL_DAP_MS_SEL_P;
+	addr = TEGRA20_DAS_DAP_CTRL_SEL +
+		(dap * TEGRA20_DAS_DAP_CTRL_SEL_STRIDE);
+	reg = otherdap << TEGRA20_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P |
+		!!sdata2rx << TEGRA20_DAS_DAP_CTRL_SEL_DAP_SDATA2_TX_RX_P |
+		!!sdata1rx << TEGRA20_DAS_DAP_CTRL_SEL_DAP_SDATA1_TX_RX_P |
+		!!master << TEGRA20_DAS_DAP_CTRL_SEL_DAP_MS_SEL_P;
 
-	tegra_das_write(addr, reg);
+	tegra20_das_write(addr, reg);
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(tegra_das_connect_dap_to_dap);
+EXPORT_SYMBOL_GPL(tegra20_das_connect_dap_to_dap);
 
-int tegra_das_connect_dac_to_dap(int dac, int dap)
+int tegra20_das_connect_dac_to_dap(int dac, int dap)
 {
 	u32 addr;
 	u32 reg;
@@ -93,78 +93,78 @@ int tegra_das_connect_dac_to_dap(int dac, int dap)
 	if (!das)
 		return -ENODEV;
 
-	addr = TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL +
-		(dac * TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);
-	reg = dap << TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_CLK_SEL_P |
-		dap << TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA1_SEL_P |
-		dap << TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA2_SEL_P;
+	addr = TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL +
+		(dac * TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);
+	reg = dap << TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_CLK_SEL_P |
+		dap << TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA1_SEL_P |
+		dap << TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA2_SEL_P;
 
-	tegra_das_write(addr, reg);
+	tegra20_das_write(addr, reg);
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(tegra_das_connect_dac_to_dap);
+EXPORT_SYMBOL_GPL(tegra20_das_connect_dac_to_dap);
 
 #ifdef CONFIG_DEBUG_FS
-static int tegra_das_show(struct seq_file *s, void *unused)
+static int tegra20_das_show(struct seq_file *s, void *unused)
 {
 	int i;
 	u32 addr;
 	u32 reg;
 
-	for (i = 0; i < TEGRA_DAS_DAP_CTRL_SEL_COUNT; i++) {
-		addr = TEGRA_DAS_DAP_CTRL_SEL +
-			(i * TEGRA_DAS_DAP_CTRL_SEL_STRIDE);
-		reg = tegra_das_read(addr);
-		seq_printf(s, "TEGRA_DAS_DAP_CTRL_SEL[%d] = %08x\n", i, reg);
+	for (i = 0; i < TEGRA20_DAS_DAP_CTRL_SEL_COUNT; i++) {
+		addr = TEGRA20_DAS_DAP_CTRL_SEL +
+			(i * TEGRA20_DAS_DAP_CTRL_SEL_STRIDE);
+		reg = tegra20_das_read(addr);
+		seq_printf(s, "TEGRA20_DAS_DAP_CTRL_SEL[%d] = %08x\n", i, reg);
 	}
 
-	for (i = 0; i < TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_COUNT; i++) {
-		addr = TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL +
-			(i * TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);
-		reg = tegra_das_read(addr);
-		seq_printf(s, "TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL[%d] = %08x\n",
-				 i, reg);
+	for (i = 0; i < TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_COUNT; i++) {
+		addr = TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL +
+			(i * TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);
+		reg = tegra20_das_read(addr);
+		seq_printf(s, "TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL[%d] = %08x\n",
+			   i, reg);
 	}
 
 	return 0;
 }
 
-static int tegra_das_debug_open(struct inode *inode, struct file *file)
+static int tegra20_das_debug_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, tegra_das_show, inode->i_private);
+	return single_open(file, tegra20_das_show, inode->i_private);
 }
 
-static const struct file_operations tegra_das_debug_fops = {
-	.open    = tegra_das_debug_open,
+static const struct file_operations tegra20_das_debug_fops = {
+	.open    = tegra20_das_debug_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
 	.release = single_release,
 };
 
-static void tegra_das_debug_add(struct tegra_das *das)
+static void tegra20_das_debug_add(struct tegra20_das *das)
 {
 	das->debug = debugfs_create_file(DRV_NAME, S_IRUGO,
 					 snd_soc_debugfs_root, das,
-					 &tegra_das_debug_fops);
+					 &tegra20_das_debug_fops);
 }
 
-static void tegra_das_debug_remove(struct tegra_das *das)
+static void tegra20_das_debug_remove(struct tegra20_das *das)
 {
 	if (das->debug)
 		debugfs_remove(das->debug);
 }
 #else
-static inline void tegra_das_debug_add(struct tegra_das *das)
+static inline void tegra20_das_debug_add(struct tegra20_das *das)
 {
 }
 
-static inline void tegra_das_debug_remove(struct tegra_das *das)
+static inline void tegra20_das_debug_remove(struct tegra20_das *das)
 {
 }
 #endif
 
-static int __devinit tegra_das_probe(struct platform_device *pdev)
+static int __devinit tegra20_das_probe(struct platform_device *pdev)
 {
 	struct resource *res, *region;
 	int ret = 0;
@@ -172,9 +172,9 @@ static int __devinit tegra_das_probe(struct platform_device *pdev)
 	if (das)
 		return -ENODEV;
 
-	das = devm_kzalloc(&pdev->dev, sizeof(struct tegra_das), GFP_KERNEL);
+	das = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_das), GFP_KERNEL);
 	if (!das) {
-		dev_err(&pdev->dev, "Can't allocate tegra_das\n");
+		dev_err(&pdev->dev, "Can't allocate tegra20_das\n");
 		ret = -ENOMEM;
 		goto err;
 	}
@@ -202,20 +202,20 @@ static int __devinit tegra_das_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	ret = tegra_das_connect_dap_to_dac(TEGRA_DAS_DAP_ID_1,
-					   TEGRA_DAS_DAP_SEL_DAC1);
+	ret = tegra20_das_connect_dap_to_dac(TEGRA20_DAS_DAP_ID_1,
+					     TEGRA20_DAS_DAP_SEL_DAC1);
 	if (ret) {
 		dev_err(&pdev->dev, "Can't set up DAS DAP connection\n");
 		goto err;
 	}
-	ret = tegra_das_connect_dac_to_dap(TEGRA_DAS_DAC_ID_1,
-					   TEGRA_DAS_DAC_SEL_DAP1);
+	ret = tegra20_das_connect_dac_to_dap(TEGRA20_DAS_DAC_ID_1,
+					     TEGRA20_DAS_DAC_SEL_DAP1);
 	if (ret) {
 		dev_err(&pdev->dev, "Can't set up DAS DAC connection\n");
 		goto err;
 	}
 
-	tegra_das_debug_add(das);
+	tegra20_das_debug_add(das);
 
 	platform_set_drvdata(pdev, das);
 
@@ -226,36 +226,36 @@ static int __devinit tegra_das_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit tegra_das_remove(struct platform_device *pdev)
+static int __devexit tegra20_das_remove(struct platform_device *pdev)
 {
 	if (!das)
 		return -ENODEV;
 
-	tegra_das_debug_remove(das);
+	tegra20_das_debug_remove(das);
 
 	das = NULL;
 
 	return 0;
 }
 
-static const struct of_device_id tegra_das_of_match[] __devinitconst = {
+static const struct of_device_id tegra20_das_of_match[] __devinitconst = {
 	{ .compatible = "nvidia,tegra20-das", },
 	{},
 };
 
-static struct platform_driver tegra_das_driver = {
-	.probe = tegra_das_probe,
-	.remove = __devexit_p(tegra_das_remove),
+static struct platform_driver tegra20_das_driver = {
+	.probe = tegra20_das_probe,
+	.remove = __devexit_p(tegra20_das_remove),
 	.driver = {
 		.name = DRV_NAME,
 		.owner = THIS_MODULE,
-		.of_match_table = tegra_das_of_match,
+		.of_match_table = tegra20_das_of_match,
 	},
 };
-module_platform_driver(tegra_das_driver);
+module_platform_driver(tegra20_das_driver);
 
 MODULE_AUTHOR("Stephen Warren <swarren@nvidia.com>");
-MODULE_DESCRIPTION("Tegra DAS driver");
+MODULE_DESCRIPTION("Tegra20 DAS driver");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:" DRV_NAME);
-MODULE_DEVICE_TABLE(of, tegra_das_of_match);
+MODULE_DEVICE_TABLE(of, tegra20_das_of_match);

commit ef280d3907cea21b6093802398bbe4193e221a64
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Apr 5 15:54:53 2012 -0600

    ASoC: tegra: rename Tegra20-specific driver files
    
    Rename these files so they include a specific hardware version in their
    filenames. The contents is only touched minimally so that git's rename
    tracking operates correctly; renaming all symbols in the files results
    in a diff so large that the rename detection fails.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/tegra/tegra20_das.c b/sound/soc/tegra/tegra20_das.c
new file mode 100644
index 000000000000..b5e369820cb3
--- /dev/null
+++ b/sound/soc/tegra/tegra20_das.c
@@ -0,0 +1,261 @@
+/*
+ * tegra20_das.c - Tegra20 DAS driver
+ *
+ * Author: Stephen Warren <swarren@nvidia.com>
+ * Copyright (C) 2010 - NVIDIA, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <mach/iomap.h>
+#include <sound/soc.h>
+#include "tegra20_das.h"
+
+#define DRV_NAME "tegra-das"
+
+static struct tegra_das *das;
+
+static inline void tegra_das_write(u32 reg, u32 val)
+{
+	__raw_writel(val, das->regs + reg);
+}
+
+static inline u32 tegra_das_read(u32 reg)
+{
+	return __raw_readl(das->regs + reg);
+}
+
+int tegra_das_connect_dap_to_dac(int dap, int dac)
+{
+	u32 addr;
+	u32 reg;
+
+	if (!das)
+		return -ENODEV;
+
+	addr = TEGRA_DAS_DAP_CTRL_SEL +
+		(dap * TEGRA_DAS_DAP_CTRL_SEL_STRIDE);
+	reg = dac << TEGRA_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P;
+
+	tegra_das_write(addr, reg);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tegra_das_connect_dap_to_dac);
+
+int tegra_das_connect_dap_to_dap(int dap, int otherdap, int master,
+					int sdata1rx, int sdata2rx)
+{
+	u32 addr;
+	u32 reg;
+
+	if (!das)
+		return -ENODEV;
+
+	addr = TEGRA_DAS_DAP_CTRL_SEL +
+		(dap * TEGRA_DAS_DAP_CTRL_SEL_STRIDE);
+	reg = otherdap << TEGRA_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P |
+		!!sdata2rx << TEGRA_DAS_DAP_CTRL_SEL_DAP_SDATA2_TX_RX_P |
+		!!sdata1rx << TEGRA_DAS_DAP_CTRL_SEL_DAP_SDATA1_TX_RX_P |
+		!!master << TEGRA_DAS_DAP_CTRL_SEL_DAP_MS_SEL_P;
+
+	tegra_das_write(addr, reg);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tegra_das_connect_dap_to_dap);
+
+int tegra_das_connect_dac_to_dap(int dac, int dap)
+{
+	u32 addr;
+	u32 reg;
+
+	if (!das)
+		return -ENODEV;
+
+	addr = TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL +
+		(dac * TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);
+	reg = dap << TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_CLK_SEL_P |
+		dap << TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA1_SEL_P |
+		dap << TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA2_SEL_P;
+
+	tegra_das_write(addr, reg);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tegra_das_connect_dac_to_dap);
+
+#ifdef CONFIG_DEBUG_FS
+static int tegra_das_show(struct seq_file *s, void *unused)
+{
+	int i;
+	u32 addr;
+	u32 reg;
+
+	for (i = 0; i < TEGRA_DAS_DAP_CTRL_SEL_COUNT; i++) {
+		addr = TEGRA_DAS_DAP_CTRL_SEL +
+			(i * TEGRA_DAS_DAP_CTRL_SEL_STRIDE);
+		reg = tegra_das_read(addr);
+		seq_printf(s, "TEGRA_DAS_DAP_CTRL_SEL[%d] = %08x\n", i, reg);
+	}
+
+	for (i = 0; i < TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_COUNT; i++) {
+		addr = TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL +
+			(i * TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);
+		reg = tegra_das_read(addr);
+		seq_printf(s, "TEGRA_DAS_DAC_INPUT_DATA_CLK_SEL[%d] = %08x\n",
+				 i, reg);
+	}
+
+	return 0;
+}
+
+static int tegra_das_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, tegra_das_show, inode->i_private);
+}
+
+static const struct file_operations tegra_das_debug_fops = {
+	.open    = tegra_das_debug_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+};
+
+static void tegra_das_debug_add(struct tegra_das *das)
+{
+	das->debug = debugfs_create_file(DRV_NAME, S_IRUGO,
+					 snd_soc_debugfs_root, das,
+					 &tegra_das_debug_fops);
+}
+
+static void tegra_das_debug_remove(struct tegra_das *das)
+{
+	if (das->debug)
+		debugfs_remove(das->debug);
+}
+#else
+static inline void tegra_das_debug_add(struct tegra_das *das)
+{
+}
+
+static inline void tegra_das_debug_remove(struct tegra_das *das)
+{
+}
+#endif
+
+static int __devinit tegra_das_probe(struct platform_device *pdev)
+{
+	struct resource *res, *region;
+	int ret = 0;
+
+	if (das)
+		return -ENODEV;
+
+	das = devm_kzalloc(&pdev->dev, sizeof(struct tegra_das), GFP_KERNEL);
+	if (!das) {
+		dev_err(&pdev->dev, "Can't allocate tegra_das\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	das->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "No memory resource\n");
+		ret = -ENODEV;
+		goto err;
+	}
+
+	region = devm_request_mem_region(&pdev->dev, res->start,
+					 resource_size(res), pdev->name);
+	if (!region) {
+		dev_err(&pdev->dev, "Memory region already claimed\n");
+		ret = -EBUSY;
+		goto err;
+	}
+
+	das->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+	if (!das->regs) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	ret = tegra_das_connect_dap_to_dac(TEGRA_DAS_DAP_ID_1,
+					   TEGRA_DAS_DAP_SEL_DAC1);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't set up DAS DAP connection\n");
+		goto err;
+	}
+	ret = tegra_das_connect_dac_to_dap(TEGRA_DAS_DAC_ID_1,
+					   TEGRA_DAS_DAC_SEL_DAP1);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't set up DAS DAC connection\n");
+		goto err;
+	}
+
+	tegra_das_debug_add(das);
+
+	platform_set_drvdata(pdev, das);
+
+	return 0;
+
+err:
+	das = NULL;
+	return ret;
+}
+
+static int __devexit tegra_das_remove(struct platform_device *pdev)
+{
+	if (!das)
+		return -ENODEV;
+
+	tegra_das_debug_remove(das);
+
+	das = NULL;
+
+	return 0;
+}
+
+static const struct of_device_id tegra_das_of_match[] __devinitconst = {
+	{ .compatible = "nvidia,tegra20-das", },
+	{},
+};
+
+static struct platform_driver tegra_das_driver = {
+	.probe = tegra_das_probe,
+	.remove = __devexit_p(tegra_das_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = tegra_das_of_match,
+	},
+};
+module_platform_driver(tegra_das_driver);
+
+MODULE_AUTHOR("Stephen Warren <swarren@nvidia.com>");
+MODULE_DESCRIPTION("Tegra DAS driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, tegra_das_of_match);
