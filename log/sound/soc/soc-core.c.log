commit 58f30150ffd6d95efa524ff05bbcee4e95bfa870
Author: Maxime Ripard <maxime@cerno.tech>
Date:   Tue Jul 7 09:42:37 2020 +0200

    ASoC: core: Remove only the registered component in devm functions
    
    The ASoC devm_ functions that register a component
    (devm_snd_soc_register_component and devm_snd_dmaengine_pcm_register) will
    clean their component by running snd_soc_unregister_component.
    
    snd_soc_unregister_component will then remove all the components for the
    device that was used to register the component in the first place.
    
    However, some drivers register several components (such as a DAI and a
    dmaengine PCM) on the same device, and if the dmaengine PCM is registered
    first, then the DAI will be cleaned up first and
    snd_dmaengine_pcm_unregister will be called next.
    
    snd_dmaengine_pcm_unregister will then lookup the dmaengine PCM component
    on the device, and if there's one unregister that component and release its
    dmaengine channels. That doesn't happen in practice though since the first
    call to snd_soc_unregister_component removed all the components, so we
    never get the chance to release the dmaengine channels.
    
    In order to fix this, instead of removing all the components for a given
    device, we can simply remove the component that was registered in the first
    place. We should have the same number of component registration than we
    have components, so it should work just fine.
    
    Signed-off-by: Maxime Ripard <maxime@cerno.tech>
    Link: https://lore.kernel.org/r/20200707074237.287171-1-maxime@cerno.tech
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0f30f5aabaa8..2b8abf88ec60 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2572,6 +2572,33 @@ int snd_soc_register_component(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_component);
 
+/**
+ * snd_soc_unregister_component_by_driver - Unregister component using a given driver
+ * from the ASoC core
+ *
+ * @dev: The device to unregister
+ * @component_driver: The component driver to unregister
+ */
+void snd_soc_unregister_component_by_driver(struct device *dev,
+					    const struct snd_soc_component_driver *component_driver)
+{
+	struct snd_soc_component *component;
+
+	if (!component_driver)
+		return;
+
+	mutex_lock(&client_mutex);
+	component = snd_soc_lookup_component_nolocked(dev, component_driver->name);
+	if (!component)
+		goto out;
+
+	snd_soc_del_component_unlocked(component);
+
+out:
+	mutex_unlock(&client_mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_unregister_component_by_driver);
+
 /**
  * snd_soc_unregister_component - Unregister all related component
  * from the ASoC core

commit 6fbea6b6a838f9aa941fe53a3637fd8d8aab1eba
Author: Shengjiu Wang <shengjiu.wang@nxp.com>
Date:   Fri Jun 12 15:37:48 2020 +0800

    ASoC: soc-card: export snd_soc_lookup_component_nolocked
    
    snd_soc_lookup_component_nolocked can be used for the DPCM case
    that Front-End needs to get the unused platform component but
    added by Back-End cpu dai driver.
    
    If the component is gotten, then we can get the dma chan created
    by Back-End component and reused it in Front-End.
    
    Signed-off-by: Shengjiu Wang <shengjiu.wang@nxp.com>
    Reviewed-by: Nicolin Chen <nicoleotsuka@gmail.com>
    Link: https://lore.kernel.org/r/55f6e0d76f67a517b9a44136d790ff2a06b5caa8.1591947428.git.shengjiu.wang@nxp.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7b387202c5db..0f30f5aabaa8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -310,7 +310,7 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 }
 EXPORT_SYMBOL_GPL(snd_soc_rtdcom_lookup);
 
-static struct snd_soc_component
+struct snd_soc_component
 *snd_soc_lookup_component_nolocked(struct device *dev, const char *driver_name)
 {
 	struct snd_soc_component *component;
@@ -329,6 +329,7 @@ static struct snd_soc_component
 
 	return found_component;
 }
+EXPORT_SYMBOL_GPL(snd_soc_lookup_component_nolocked);
 
 struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
 						   const char *driver_name)

commit 607fa205a7e4dfad28b8a67ab1c985756ddbccb0
Author: Bard Liao <yung-chuan.liao@linux.intel.com>
Date:   Mon Jun 8 14:44:13 2020 -0500

    ASoC: core: only convert non DPCM link to DPCM link
    
    Additional checks for valid DAIs expose a corner case, where existing
    BE dailinks get modified, e.g. HDMI links are tagged with
    dpcm_capture=1 even if the DAIs are for playback.
    
    This patch makes those changes conditional and flags configuration
    issues when a BE dailink is has no_pcm=0 but dpcm_playback or
    dpcm_capture=1 (which makes no sense).
    
    As discussed on the alsa-devel mailing list, there are redundant flags
    for dpcm_playback, dpcm_capture, playback_only, capture_only. This
    will have to be cleaned-up in a future update. For now only correct
    and flag problematic configurations.
    
    Fixes: 218fe9b7ec7f3 ("ASoC: soc-core: Set dpcm_playback / dpcm_capture")
    Suggested-by: Daniel Baluta <daniel.baluta@nxp.com>
    Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@gmail.com>
    Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Link: https://lore.kernel.org/r/20200608194415.4663-3-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b07eca2c6ccc..7b387202c5db 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1648,9 +1648,25 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 			dai_link->platforms->name = component->name;
 
 			/* convert non BE into BE */
-			dai_link->no_pcm = 1;
-			dai_link->dpcm_playback = 1;
-			dai_link->dpcm_capture = 1;
+			if (!dai_link->no_pcm) {
+				dai_link->no_pcm = 1;
+
+				if (dai_link->dpcm_playback)
+					dev_warn(card->dev,
+						 "invalid configuration, dailink %s has flags no_pcm=0 and dpcm_playback=1\n",
+						 dai_link->name);
+				if (dai_link->dpcm_capture)
+					dev_warn(card->dev,
+						 "invalid configuration, dailink %s has flags no_pcm=0 and dpcm_capture=1\n",
+						 dai_link->name);
+
+				/* convert normal link into DPCM one */
+				if (!(dai_link->dpcm_playback ||
+				      dai_link->dpcm_capture)) {
+					dai_link->dpcm_playback = !dai_link->capture_only;
+					dai_link->dpcm_capture = !dai_link->playback_only;
+				}
+			}
 
 			/*
 			 * override any BE fixups

commit fcbbcc325bc2dd90212de19b520c190b6fbeddae
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:50:46 2020 +0900

    ASoC: soc-card: add snd_soc_card_remove_dai_link()
    
    Card related function should be implemented at soc-card now.
    This patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87mu5szv2h.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d238b47252a5..b07eca2c6ccc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -947,8 +947,7 @@ void snd_soc_remove_pcm_runtime(struct snd_soc_card *card,
 	/*
 	 * Notify the machine driver for extra destruction
 	 */
-	if (card->remove_dai_link)
-		card->remove_dai_link(card, rtd->dai_link);
+	snd_soc_card_remove_dai_link(card, rtd->dai_link);
 
 	soc_free_pcm_runtime(rtd);
 }

commit cbc7a6b5a87a129084c643455d16699ea490fd2f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:50:41 2020 +0900

    ASoC: soc-card: add snd_soc_card_add_dai_link()
    
    Card related function should be implemented at soc-card now.
    This patch adds it.
    
    This patch adds missing return when error case.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87o8q8zv2m.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 136ff7237a80..d238b47252a5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -978,8 +978,9 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 	/*
 	 * Notify the machine driver for extra initialization
 	 */
-	if (card->add_dai_link)
-		card->add_dai_link(card, dai_link);
+	ret = snd_soc_card_add_dai_link(card, dai_link);
+	if (ret < 0)
+		return ret;
 
 	if (dai_link->ignore)
 		return 0;

commit b0275d956fab05a5088e20244c8d1eb433b7b90f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:49:26 2020 +0900

    ASoC: soc-card: add snd_soc_card_remove()
    
    Card related function should be implemented at soc-card now.
    This patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87tv00zv4p.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 42e8c11a0b26..136ff7237a80 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1747,9 +1747,7 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 	soc_cleanup_card_debugfs(card);
 
 	/* remove the card */
-	if (card->probed && card->remove)
-		card->remove(card);
-	card->probed = 0;
+	snd_soc_card_remove(card);
 
 	if (card->snd_card) {
 		snd_card_free(card->snd_card);

commit 5c0eac036dfd3e20dd09ab86343c3b2fb2a1ac86
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:49:20 2020 +0900

    ASoC: soc-card: add snd_soc_card_late_probe()
    
    Card related function should be implemented at soc-card now.
    This patch adds it.
    
    card has "card->probe" and "card->late_probe" callbacks,
    and "late_probe" callback is called after "probe".
    This means, we can set "card->probed" flag afer "late_probe"
    for all cases.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87v9kgzv4w.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 13a7d5158534..42e8c11a0b26 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1910,15 +1910,9 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 		}
 	}
 
-	if (card->late_probe) {
-		ret = card->late_probe(card);
-		if (ret < 0) {
-			dev_err(card->dev, "ASoC: %s late_probe() failed: %d\n",
-				card->name, ret);
-			goto probe_end;
-		}
-	}
-	card->probed = 1;
+	ret = snd_soc_card_late_probe(card);
+	if (ret < 0)
+		goto probe_end;
 
 	snd_soc_dapm_new_widgets(card);
 

commit 73de4b026850da432b8bcfb73fc4af94674a8102
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:49:11 2020 +0900

    ASoC: soc-card: add snd_soc_card_probe()
    
    Card related function should be implemented at soc-card now.
    This patch adds it.
    
    One note here is that card has "card->probe" and "card->late_probe"
    callbacks.
    Because it needs to care "late_probe", "card->probed" flag is set
    under if (card->probe) at snd_soc_card_probe().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87wo4wzv54.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7cfb3ee6ff4f..13a7d5158534 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1825,12 +1825,9 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 		goto probe_end;
 
 	/* initialise the sound card only once */
-	if (card->probe) {
-		ret = card->probe(card);
-		if (ret < 0)
-			goto probe_end;
-		card->probed = 1;
-	}
+	ret = snd_soc_card_probe(card);
+	if (ret < 0)
+		goto probe_end;
 
 	/* probe all components used by DAI links on this card */
 	ret = soc_probe_link_components(card);

commit 27f07cacc9f1ddf955b85e5746f967351ab0b40b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:50:21 2020 +0900

    ASoC: soc-card: add probed bit field to snd_soc_card
    
    We already have bit field to control snd_soc_card.
    Let's add "probed" field on it instead of local variable.
    
    One note here is that soc_cleanup_card_resources()
    will be called as (A) formal cleanup or as (B) error handling,
    thus, it needs to distinguish these.
    
    In (A) case, card will have "instantiated" flag if all probe
    callback functions were called without error.
    Thus, snd_soc_unbind_card() is using it to judging card was probed.
    But this this patch removes it, because it is no longer needed.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87r1v4zv36.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 02147acf6547..7cfb3ee6ff4f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1723,8 +1723,7 @@ static void __soc_setup_card_name(char *name, int len,
 	}
 }
 
-static void soc_cleanup_card_resources(struct snd_soc_card *card,
-				       int card_probed)
+static void soc_cleanup_card_resources(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd, *n;
 
@@ -1748,8 +1747,9 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card,
 	soc_cleanup_card_debugfs(card);
 
 	/* remove the card */
-	if (card_probed && card->remove)
+	if (card->probed && card->remove)
 		card->remove(card);
+	card->probed = 0;
 
 	if (card->snd_card) {
 		snd_card_free(card->snd_card);
@@ -1760,12 +1760,10 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card,
 static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 {
 	if (card->instantiated) {
-		int card_probed = 1;
-
 		card->instantiated = false;
 		snd_soc_flush_all_delayed_work(card);
 
-		soc_cleanup_card_resources(card, card_probed);
+		soc_cleanup_card_resources(card);
 		if (!unregister)
 			list_add(&card->list, &unbind_card_list);
 	} else {
@@ -1779,7 +1777,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_component *component;
 	struct snd_soc_dai_link *dai_link;
-	int ret, i, card_probed = 0;
+	int ret, i;
 
 	mutex_lock(&client_mutex);
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
@@ -1831,7 +1829,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 		ret = card->probe(card);
 		if (ret < 0)
 			goto probe_end;
-		card_probed = 1;
+		card->probed = 1;
 	}
 
 	/* probe all components used by DAI links on this card */
@@ -1923,7 +1921,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 			goto probe_end;
 		}
 	}
-	card_probed = 1;
+	card->probed = 1;
 
 	snd_soc_dapm_new_widgets(card);
 
@@ -1945,7 +1943,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 
 probe_end:
 	if (ret < 0)
-		soc_cleanup_card_resources(card, card_probed);
+		soc_cleanup_card_resources(card);
 
 	mutex_unlock(&card->mutex);
 	mutex_unlock(&client_mutex);

commit 739443d1f162ce80eb717c695e58302958b51239
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:49:02 2020 +0900

    ASoC: soc-card: add snd_soc_card_resume_post()
    
    Card related function should be implemented at soc-card now.
    This patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87y2pczv5d.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 540ee055a1e8..02147acf6547 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -692,8 +692,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		}
 	}
 
-	if (card->resume_post)
-		card->resume_post(card);
+	snd_soc_card_resume_post(card);
 
 	dev_dbg(card->dev, "ASoC: resume work completed\n");
 

commit 934c752c38b751663fe3dc18413db13e73b8b2b2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:48:55 2020 +0900

    ASoC: soc-card: add snd_soc_card_resume_pre()
    
    Card related function should be implemented at soc-card now.
    This patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87zh9szv5k.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0327995efc1..540ee055a1e8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -660,8 +660,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	/* Bring us up into D2 so that DAPM starts enabling things */
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D2);
 
-	if (card->resume_pre)
-		card->resume_pre(card);
+	snd_soc_card_resume_pre(card);
 
 	for_each_card_components(card, component) {
 		if (snd_soc_component_is_suspended(component))

commit d17b60b2c46750ebfb6ea39a2b02d988b97484eb
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:48:48 2020 +0900

    ASoC: soc-card: add snd_soc_card_suspend_post()
    
    Card related function should be implemented at soc-card now.
    This patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/871rn425j3.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 52d09fa495c3..c0327995efc1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -631,8 +631,7 @@ int snd_soc_suspend(struct device *dev)
 		}
 	}
 
-	if (card->suspend_post)
-		card->suspend_post(card);
+	snd_soc_card_suspend_post(card);
 
 	return 0;
 }

commit 130dc08c827db76f4a32fe7867075029fe9071d1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:48:39 2020 +0900

    ASoC: soc-card: add snd_soc_card_suspend_pre()
    
    Card related function should be implemented at soc-card now.
    This patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87367k25jc.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b6105b92f589..52d09fa495c3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -561,8 +561,7 @@ int snd_soc_suspend(struct device *dev)
 		snd_pcm_suspend_all(rtd->pcm);
 	}
 
-	if (card->suspend_pre)
-		card->suspend_pre(card);
+	snd_soc_card_suspend_pre(card);
 
 	/* close any waiting streams */
 	snd_soc_flush_all_delayed_work(card);

commit 209c6cdfd28360f030f88ae9adb69f633e6bcd2d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 28 10:47:56 2020 +0900

    ASoC: soc-card: move snd_soc_card_get_kcontrol() to soc-card
    
    Card related function should be implemented at soc-card now.
    This patch moves it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87a71s25kj.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e1b65059c0c4..b6105b92f589 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2096,22 +2096,6 @@ static int snd_soc_add_controls(struct snd_card *card, struct device *dev,
 	return 0;
 }
 
-struct snd_kcontrol *snd_soc_card_get_kcontrol(struct snd_soc_card *soc_card,
-					       const char *name)
-{
-	struct snd_card *card = soc_card->snd_card;
-	struct snd_kcontrol *kctl;
-
-	if (unlikely(!name))
-		return NULL;
-
-	list_for_each_entry(kctl, &card->controls, list)
-		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name)))
-			return kctl;
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_card_get_kcontrol);
-
 /**
  * snd_soc_add_component_controls - Add an array of controls to a component.
  *

commit 0cbbf8a0399518e5b865f9a1320d704c1d621703
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon May 25 09:57:36 2020 +0900

    ASoC: soc-link: add snd_soc_link_be_hw_params_fixup()
    
    dai_link related function should be implemented at soc-link.c.
    This patch adds snd_soc_link_be_hw_params_fixup().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87wo503k73.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 955e175643d7..e1b65059c0c4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1656,7 +1656,11 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 			dai_link->dpcm_playback = 1;
 			dai_link->dpcm_capture = 1;
 
-			/* override any BE fixups */
+			/*
+			 * override any BE fixups
+			 * see
+			 *	snd_soc_link_be_hw_params_fixup()
+			 */
 			dai_link->be_hw_params_fixup =
 				component->driver->be_hw_params_fixup;
 

commit 02e756363fc936917bed7320199c80729b2a825c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon May 25 09:57:14 2020 +0900

    ASoC: add soc-link.c
    
    Current ALSA SoC has many dai_link->xxx() functions.
    But, it is implemented randomly at random place.
    
    This patch creats new soc-link.c and collect dai_link related
    operation into it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/871rn84ys5.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e697258d2ffc..955e175643d7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -38,6 +38,7 @@
 #include <sound/soc.h>
 #include <sound/soc-dpcm.h>
 #include <sound/soc-topology.h>
+#include <sound/soc-link.h>
 #include <sound/initval.h>
 
 #define CREATE_TRACE_POINTS
@@ -1049,14 +1050,9 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 	rtd->pmdown_time = pmdown_time;
 
 	/* do machine specific initialization */
-	if (dai_link->init) {
-		ret = dai_link->init(rtd);
-		if (ret < 0) {
-			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
-				dai_link->name, ret);
-			return ret;
-		}
-	}
+	ret = snd_soc_link_init(rtd);
+	if (ret < 0)
+		return ret;
 
 	if (dai_link->dai_fmt) {
 		ret = snd_soc_runtime_set_dai_fmt(rtd, dai_link->dai_fmt);

commit b3dea624b52e8b18cd49f804ce70fe50374aa5db
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri May 15 09:46:51 2020 +0900

    ASoC: use snd_soc_xxx_active()
    
    We have snd_soc_dai/dai_stream/component_active() macro
    This patch uses it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/8736826n44.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 95d8189e45ab..e697258d2ffc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -372,7 +372,8 @@ void snd_soc_close_delayed_work(struct snd_soc_pcm_runtime *rtd)
 	dev_dbg(rtd->dev,
 		"ASoC: pop wq checking: %s status: %s waiting: %s\n",
 		codec_dai->driver->playback.stream_name,
-		codec_dai->stream_active[playback] ? "active" : "inactive",
+		snd_soc_dai_stream_active(codec_dai, playback) ?
+		"active" : "inactive",
 		rtd->pop_wait ? "yes" : "no");
 
 	/* are we waiting on this codec DAI stream */
@@ -546,7 +547,7 @@ int snd_soc_suspend(struct device *dev)
 			continue;
 
 		for_each_rtd_codec_dais(rtd, i, dai) {
-			if (dai->stream_active[playback])
+			if (snd_soc_dai_stream_active(dai, playback))
 				snd_soc_dai_digital_mute(dai, 1, playback);
 		}
 	}
@@ -688,7 +689,7 @@ static void soc_resume_deferred(struct work_struct *work)
 			continue;
 
 		for_each_rtd_codec_dais(rtd, i, dai) {
-			if (dai->stream_active[playback])
+			if (snd_soc_dai_stream_active(dai, playback))
 				snd_soc_dai_digital_mute(dai, 0, playback);
 		}
 	}
@@ -718,7 +719,7 @@ int snd_soc_resume(struct device *dev)
 
 	/* activate pins from sleep state */
 	for_each_card_components(card, component)
-		if (component->active)
+		if (snd_soc_component_active(component))
 			pinctrl_pm_select_default_state(component->dev);
 
 	dev_dbg(dev, "ASoC: Scheduling resume work\n");
@@ -1943,7 +1944,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 
 	/* deactivate pins to sleep state */
 	for_each_card_components(card, component)
-		if (!component->active)
+		if (!snd_soc_component_active(component))
 			pinctrl_pm_select_sleep_state(component->dev);
 
 probe_end:

commit 7eaa313bdec3f2326c9cdacec88fd484a36c423b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:20 2020 +0900

    ASoC: soc-dai: add snd_soc_pcm_dai_remove()
    
    We have 2 type of component functions
    snd_soc_dai_xxx()     is focusing to dai itself,
    snd_soc_pcm_dai_xxx() is focusing to rtd related dai.
    
    Now we can update snd_soc_dai_remove() to
    snd_soc_pcm_dai_remove(). This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87r1wdssjc.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8cafca4e1405..95d8189e45ab 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1256,35 +1256,15 @@ static int soc_probe_component(struct snd_soc_card *card,
 	return ret;
 }
 
-static void soc_remove_dai(struct snd_soc_dai *dai, int order)
-{
-	int err;
-
-	if (!dai || !dai->probed || !dai->driver ||
-	    dai->driver->remove_order != order)
-		return;
-
-	err = snd_soc_dai_remove(dai);
-	if (err < 0)
-		dev_err(dai->dev,
-			"ASoC: failed to remove %s: %d\n",
-			dai->name, err);
-
-	dai->probed = 0;
-}
-
 static void soc_remove_link_dais(struct snd_soc_card *card)
 {
-	int i;
-	struct snd_soc_dai *dai;
 	struct snd_soc_pcm_runtime *rtd;
 	int order;
 
 	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
-			/* remove DAIs */
-			for_each_rtd_dais(rtd, i, dai)
-				soc_remove_dai(dai, order);
+			/* remove all rtd connected DAIs in good order */
+			snd_soc_pcm_dai_remove(rtd, order);
 		}
 	}
 }

commit 51801aeafdc9c1d55e5e71e58a1bbbd2583328fa
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:15:15 2020 +0900

    ASoC: soc-dai: add snd_soc_pcm_dai_probe()
    
    We have 2 type of component functions
    snd_soc_dai_xxx()     is focusing to dai itself,
    snd_soc_pcm_dai_xxx() is focusing to rtd related dai.
    
    Now we can update snd_soc_dai_probe() to
    snd_soc_pcm_dai_probe(). This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87sggtssjg.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 76167fa264af..8cafca4e1405 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1273,26 +1273,6 @@ static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 	dai->probed = 0;
 }
 
-static int soc_probe_dai(struct snd_soc_dai *dai, int order)
-{
-	int ret;
-
-	if (dai->probed ||
-	    dai->driver->probe_order != order)
-		return 0;
-
-	ret = snd_soc_dai_probe(dai);
-	if (ret < 0) {
-		dev_err(dai->dev, "ASoC: failed to probe DAI %s: %d\n",
-			dai->name, ret);
-		return ret;
-	}
-
-	dai->probed = 1;
-
-	return 0;
-}
-
 static void soc_remove_link_dais(struct snd_soc_card *card)
 {
 	int i;
@@ -1311,9 +1291,8 @@ static void soc_remove_link_dais(struct snd_soc_card *card)
 
 static int soc_probe_link_dais(struct snd_soc_card *card)
 {
-	struct snd_soc_dai *dai;
 	struct snd_soc_pcm_runtime *rtd;
-	int i, order, ret;
+	int order, ret;
 
 	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
@@ -1322,12 +1301,10 @@ static int soc_probe_link_dais(struct snd_soc_card *card)
 				"ASoC: probe %s dai link %d late %d\n",
 				card->name, rtd->num, order);
 
-			/* probe the CPU DAI */
-			for_each_rtd_dais(rtd, i, dai) {
-				ret = soc_probe_dai(dai, order);
-				if (ret)
-					return ret;
-			}
+			/* probe all rtd connected DAIs in good order */
+			ret = snd_soc_pcm_dai_probe(rtd, order);
+			if (ret)
+				return ret;
 		}
 	}
 

commit 0b73ba550cdd95b0fdca5da0040c29ae5d25ae5d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:14:48 2020 +0900

    ASoC: soc-dai: add snd_soc_pcm_dai_new()
    
    We have 2 type of component functions
    snd_soc_dai_xxx()     is focusing to dai itself,
    snd_soc_pcm_dai_xxx() is focusing to rtd related dai.
    
    Now we can update soc_dai_pcm_new() to
    snd_soc_pcm_dai_new(). This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87y2qlssk7.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6778eeffb48f..76167fa264af 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1036,27 +1036,6 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_pcm_runtime);
 
-static int soc_dai_pcm_new(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_dai *dai;
-	int i, ret = 0;
-
-	for_each_rtd_dais(rtd, i, dai) {
-		struct snd_soc_dai_driver *drv = dai->driver;
-
-		if (drv->pcm_new)
-			ret = drv->pcm_new(rtd, dai);
-		if (ret < 0) {
-			dev_err(dai->dev,
-				"ASoC: Failed to bind %s with pcm device\n",
-				dai->name);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
 static int soc_init_pcm_runtime(struct snd_soc_card *card,
 				struct snd_soc_pcm_runtime *rtd)
 {
@@ -1121,7 +1100,7 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 		return ret;
 	}
 
-	return soc_dai_pcm_new(rtd);
+	return snd_soc_pcm_dai_new(rtd);
 }
 
 static void soc_set_name_prefix(struct snd_soc_card *card,

commit 479914ed779d408273fb3cac4c061dbe695f17cb
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 24 08:14:43 2020 +0900

    ASoC: soc-dai: don't overwide dai->driver->ops
    
    Current ASoC overwrites null_dai_ops to dai->driver->ops if it
    was NULL. But, we can remove it if framework always checks
    dai->driver->ops when it uses DAI callbacks.
    This patch do it, and removes null_dai_ops.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87zhb1sskc.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8321e75ff244..6778eeffb48f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -742,9 +742,6 @@ static inline void soc_resume_init(struct snd_soc_card *card)
 }
 #endif
 
-static const struct snd_soc_dai_ops null_dai_ops = {
-};
-
 static struct device_node
 *soc_component_to_node(struct snd_soc_component *component)
 {
@@ -2406,8 +2403,6 @@ struct snd_soc_dai *snd_soc_register_dai(struct snd_soc_component *component,
 	dai->component = component;
 	dai->dev = dev;
 	dai->driver = dai_drv;
-	if (!dai->driver->ops)
-		dai->driver->ops = &null_dai_ops;
 
 	/* see for_each_component_dais */
 	list_add_tail(&dai->list, &component->dai_list);

commit 5c5118dc5d14e1d7864bddade30019660cb467fa
Merge: 3c9432d1efc9 b2acc24c805a
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Apr 14 15:45:38 2020 +0100

    Merge series "ASoC: SOF: adjust dmesg verbosity" from Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>:
    
    Decrease the dmesg verbosity to remove unnecessary logs on SoundWire
    platforms, and conversely add more information to help the community
    and downstream distros with HDaudio/SOF support (DMIC detection and card
    instanciation are the most prevalent issues on GitHub).
    
    Pierre-Louis Bossart (3):
      ASoC: codecs: rt1308-sdw: reduce verbosity
      ASoC: SOF: Intel: hda: reduce verbosity on SoundWire detection
      ASoC: SOF: Intel: hda: log number of microphones detected in NHLT
        tables
    
    Ranjani Sridharan (1):
      ASoC: soc-core: Add dynamic debug logs in soc_dai_link_sanity_check()
    
     sound/soc/codecs/rt1308-sdw.c |  4 ++--
     sound/soc/soc-core.c          | 18 +++++++++++++++---
     sound/soc/sof/intel/hda.c     | 10 ++++++----
     3 files changed, 23 insertions(+), 9 deletions(-)
    
    base-commit: dd8e871d4e560eeb8d22af82dde91457ad835a63
    --
    2.20.1

commit 1729025b04b9f242dca37f50dba8dd3705eb1ea1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 30 10:48:27 2020 +0900

    ASoC: soc-core: remove cpu_dai/codec_dai/cpu_dais/codec_dais
    
    No-one is using cpu_dai/codec_dai/cpu_dais/codec_dais.
    Let's remove these from snd_soc_pcm_runtime
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87eetabok4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4d617c495864..7ea9725e33b3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -487,9 +487,10 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	 * dais = [][][][][][][][][][][][][][][][][][]
 	 *	  ^cpu_dais         ^codec_dais
 	 *	  |--- num_cpus ---|--- num_codecs --|
+	 * see
+	 *	asoc_rtd_to_cpu()
+	 *	asoc_rtd_to_codec()
 	 */
-	rtd->cpu_dais	= &rtd->dais[0];
-	rtd->codec_dais	= &rtd->dais[dai_link->num_cpus];
 	rtd->num_cpus	= dai_link->num_cpus;
 	rtd->num_codecs	= dai_link->num_codecs;
 	rtd->card	= card;
@@ -996,9 +997,6 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 		snd_soc_rtd_add_component(rtd, asoc_rtd_to_cpu(rtd, i)->component);
 	}
 
-	/* Single cpu links expect cpu and cpu_dai in runtime data */
-	rtd->cpu_dai = rtd->cpu_dais[0];
-
 	/* Find CODEC from registered CODECs */
 	for_each_link_codecs(dai_link, i, codec) {
 		asoc_rtd_to_codec(rtd, i) = snd_soc_find_dai(codec);
@@ -1011,9 +1009,6 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 		snd_soc_rtd_add_component(rtd, asoc_rtd_to_codec(rtd, i)->component);
 	}
 
-	/* Single codec links expect codec and codec_dai in runtime data */
-	rtd->codec_dai = rtd->codec_dais[0];
-
 	/* Find PLATFORM from registered PLATFORMs */
 	for_each_link_platforms(dai_link, i, platform) {
 		for_each_component(component) {

commit 01faf501eefa86fa6f334bb9c71a48498de653e6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 30 10:48:14 2020 +0900

    ASoC: soc-core: tidyup soc_new_pcm_runtime() rtd setups
    
    soc_new_pcm_runtime() setups rtd, but code is very random.
    This patch tidyup it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87ftdqbokh.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8cef4fd6df36..4d617c495864 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -492,17 +492,12 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	rtd->codec_dais	= &rtd->dais[dai_link->num_cpus];
 	rtd->num_cpus	= dai_link->num_cpus;
 	rtd->num_codecs	= dai_link->num_codecs;
-
-	/*
-	 * rtd remaining settings
-	 */
-	rtd->card = card;
-	rtd->dai_link = dai_link;
+	rtd->card	= card;
+	rtd->dai_link	= dai_link;
+	rtd->num	= card->num_rtd++;
 
 	/* see for_each_card_rtds */
 	list_add_tail(&rtd->list, &card->rtd_list);
-	rtd->num = card->num_rtd;
-	card->num_rtd++;
 
 	return rtd;
 

commit 49648d02008dd75ddd84b16f9abf29f24c383519
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 30 10:47:54 2020 +0900

    ASoC: soc-core: set rtd->num_cpu/codec at soc_new_pcm_runtime()
    
    rtd->cpu_dais/codec_dais are set at soc_new_pcm_runtime().
    rtd->num_cpus/codecs should be set there.
    This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87h7y6bol1.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4ad64b96d893..8cef4fd6df36 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -490,6 +490,8 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	 */
 	rtd->cpu_dais	= &rtd->dais[0];
 	rtd->codec_dais	= &rtd->dais[dai_link->num_cpus];
+	rtd->num_cpus	= dai_link->num_cpus;
+	rtd->num_codecs	= dai_link->num_codecs;
 
 	/*
 	 * rtd remaining settings
@@ -989,7 +991,6 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 	if (!rtd)
 		return -ENOMEM;
 
-	rtd->num_cpus = dai_link->num_cpus;
 	for_each_link_cpus(dai_link, i, cpu) {
 		asoc_rtd_to_cpu(rtd, i) = snd_soc_find_dai(cpu);
 		if (!asoc_rtd_to_cpu(rtd, i)) {
@@ -1004,7 +1005,6 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 	rtd->cpu_dai = rtd->cpu_dais[0];
 
 	/* Find CODEC from registered CODECs */
-	rtd->num_codecs = dai_link->num_codecs;
 	for_each_link_codecs(dai_link, i, codec) {
 		asoc_rtd_to_codec(rtd, i) = snd_soc_find_dai(codec);
 		if (!asoc_rtd_to_codec(rtd, i)) {

commit c2233a266178f8937cc26a84cd7672334b5424b7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 30 10:47:37 2020 +0900

    ASoC: soc: use asoc_rtd_to_cpu() / asoc_rtd_to_codec() macro for DAI pointer
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87imimboli.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 843b8b1c89d4..4ad64b96d893 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -364,7 +364,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
  */
 void snd_soc_close_delayed_work(struct snd_soc_pcm_runtime *rtd)
 {
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
 	int playback = SNDRV_PCM_STREAM_PLAYBACK;
 
 	mutex_lock_nested(&rtd->card->pcm_mutex, rtd->card->pcm_subclass);
@@ -991,13 +991,13 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 
 	rtd->num_cpus = dai_link->num_cpus;
 	for_each_link_cpus(dai_link, i, cpu) {
-		rtd->cpu_dais[i] = snd_soc_find_dai(cpu);
-		if (!rtd->cpu_dais[i]) {
+		asoc_rtd_to_cpu(rtd, i) = snd_soc_find_dai(cpu);
+		if (!asoc_rtd_to_cpu(rtd, i)) {
 			dev_info(card->dev, "ASoC: CPU DAI %s not registered\n",
 				 cpu->dai_name);
 			goto _err_defer;
 		}
-		snd_soc_rtd_add_component(rtd, rtd->cpu_dais[i]->component);
+		snd_soc_rtd_add_component(rtd, asoc_rtd_to_cpu(rtd, i)->component);
 	}
 
 	/* Single cpu links expect cpu and cpu_dai in runtime data */
@@ -1006,14 +1006,14 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 	/* Find CODEC from registered CODECs */
 	rtd->num_codecs = dai_link->num_codecs;
 	for_each_link_codecs(dai_link, i, codec) {
-		rtd->codec_dais[i] = snd_soc_find_dai(codec);
-		if (!rtd->codec_dais[i]) {
+		asoc_rtd_to_codec(rtd, i) = snd_soc_find_dai(codec);
+		if (!asoc_rtd_to_codec(rtd, i)) {
 			dev_info(card->dev, "ASoC: CODEC DAI %s not registered\n",
 				 codec->dai_name);
 			goto _err_defer;
 		}
 
-		snd_soc_rtd_add_component(rtd, rtd->codec_dais[i]->component);
+		snd_soc_rtd_add_component(rtd, asoc_rtd_to_codec(rtd, i)->component);
 	}
 
 	/* Single codec links expect codec and codec_dai in runtime data */
@@ -1062,7 +1062,7 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 				struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_dai_link *dai_link = rtd->dai_link;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
 	struct snd_soc_component *component;
 	int ret, num, i;
 

commit b2acc24c805a42b6ebfe8b8ae09dbf9c994c5604
Author: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Date:   Thu Apr 9 13:44:16 2020 -0500

    ASoC: soc-core: Add dynamic debug logs in soc_dai_link_sanity_check()
    
    When a platform device is created successfully but the machine driver
    probe fails due to errors with missing components during the card bind
    stage, no error is propagated or logged. To help flag such problems,
    add a dynamic debug log.
    
    Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@gmail.com>
    Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20200409184416.15591-5-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 843b8b1c89d4..8b2f6dd2fc8e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -865,8 +865,12 @@ static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 		 * Defer card registration if codec component is not added to
 		 * component list.
 		 */
-		if (!soc_find_component(codec))
+		if (!soc_find_component(codec)) {
+			dev_dbg(card->dev,
+				"ASoC: codec component %s not found for link %s\n",
+				codec->name, link->name);
 			return -EPROBE_DEFER;
+		}
 	}
 
 	for_each_link_platforms(link, i, platform) {
@@ -886,8 +890,12 @@ static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 		 * Defer card registration if platform component is not added to
 		 * component list.
 		 */
-		if (!soc_find_component(platform))
+		if (!soc_find_component(platform)) {
+			dev_dbg(card->dev,
+				"ASoC: platform component %s not found for link %s\n",
+				platform->name, link->name);
 			return -EPROBE_DEFER;
+		}
 	}
 
 	for_each_link_cpus(link, i, cpu) {
@@ -908,8 +916,12 @@ static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 		 * component list.
 		 */
 		if ((cpu->of_node || cpu->name) &&
-		    !soc_find_component(cpu))
+		    !soc_find_component(cpu)) {
+			dev_dbg(card->dev,
+				"ASoC: cpu component %s not found for link %s\n",
+				cpu->name, link->name);
 			return -EPROBE_DEFER;
+		}
 
 		/*
 		 * At least one of CPU DAI name or CPU device name/node must be

commit d1eb6d116123b2bcebeefce8bcdc828c80b033b8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 16 15:37:20 2020 +0900

    ASoC: soc-core: Merge CPU/Codec for soc_dai_pcm_new()
    
    Now CPU/Codec DAIs are alias for dais.
    Thus, we can directly use for_each_rtd_dais() macro
    for soc_dai_pcm_new().
    This patch merge CPU/Codec for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87r1xsolen.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 246d59966795..843b8b1c89d4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1037,20 +1037,20 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_pcm_runtime);
 
-static int soc_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
-			   struct snd_soc_pcm_runtime *rtd)
+static int soc_dai_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
+	struct snd_soc_dai *dai;
 	int i, ret = 0;
 
-	for (i = 0; i < num_dais; ++i) {
-		struct snd_soc_dai_driver *drv = dais[i]->driver;
+	for_each_rtd_dais(rtd, i, dai) {
+		struct snd_soc_dai_driver *drv = dai->driver;
 
 		if (drv->pcm_new)
-			ret = drv->pcm_new(rtd, dais[i]);
+			ret = drv->pcm_new(rtd, dai);
 		if (ret < 0) {
-			dev_err(dais[i]->dev,
+			dev_err(dai->dev,
 				"ASoC: Failed to bind %s with pcm device\n",
-				dais[i]->name);
+				dai->name);
 			return ret;
 		}
 	}
@@ -1121,13 +1121,8 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 			dai_link->stream_name, ret);
 		return ret;
 	}
-	ret = soc_dai_pcm_new(rtd->cpu_dais,
-			      rtd->num_cpus, rtd);
-	if (ret < 0)
-		return ret;
-	ret = soc_dai_pcm_new(rtd->codec_dais,
-			      rtd->num_codecs, rtd);
-	return ret;
+
+	return soc_dai_pcm_new(rtd);
 }
 
 static void soc_set_name_prefix(struct snd_soc_card *card,

commit 3af6ff5035ad95ee02728aff271a9b543b912f15
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 16 15:37:03 2020 +0900

    ASoC: soc-core: Merge for_each_rtd_cpu/codec_dais()
    
    Now we can use for_each_rtd_dais().
    Let's use it instead of for_each_rtd_cpu/codec_dais().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87v9n4olf4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0fd582c19c03..246d59966795 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1323,26 +1323,22 @@ static int soc_probe_dai(struct snd_soc_dai *dai, int order)
 static void soc_remove_link_dais(struct snd_soc_card *card)
 {
 	int i;
-	struct snd_soc_dai *codec_dai;
-	struct snd_soc_dai *cpu_dai;
+	struct snd_soc_dai *dai;
 	struct snd_soc_pcm_runtime *rtd;
 	int order;
 
 	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
-			/* remove the CODEC DAI */
-			for_each_rtd_codec_dais(rtd, i, codec_dai)
-				soc_remove_dai(codec_dai, order);
-
-			for_each_rtd_cpu_dais(rtd, i, cpu_dai)
-				soc_remove_dai(cpu_dai, order);
+			/* remove DAIs */
+			for_each_rtd_dais(rtd, i, dai)
+				soc_remove_dai(dai, order);
 		}
 	}
 }
 
 static int soc_probe_link_dais(struct snd_soc_card *card)
 {
-	struct snd_soc_dai *codec_dai, *cpu_dai;
+	struct snd_soc_dai *dai;
 	struct snd_soc_pcm_runtime *rtd;
 	int i, order, ret;
 
@@ -1354,15 +1350,8 @@ static int soc_probe_link_dais(struct snd_soc_card *card)
 				card->name, rtd->num, order);
 
 			/* probe the CPU DAI */
-			for_each_rtd_cpu_dais(rtd, i, cpu_dai) {
-				ret = soc_probe_dai(cpu_dai, order);
-				if (ret)
-					return ret;
-			}
-
-			/* probe the CODEC DAI */
-			for_each_rtd_codec_dais(rtd, i, codec_dai) {
-				ret = soc_probe_dai(codec_dai, order);
+			for_each_rtd_dais(rtd, i, dai) {
+				ret = soc_probe_dai(dai, order);
 				if (ret)
 					return ret;
 			}

commit 22a2fc81658b3eebcfcc110de97bcbd32f5ee301
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 16 15:36:58 2020 +0900

    ASoC: soc-core: Merge CPU/Codec DAIs
    
    ALSA SoC is currently categorizing CPU/Codec DAIs,
    and it works well.
    
    But modern devices require more complex connections,
    for example Codec to Codec, etc, and future devices will
    enable to more complex connections.
    Because of these background, CPU/Codec DAIs categorizing is
    no longer good much to modern device.
    
    Currently, rtd has both CPU/Codec DAIs pointer.
    
            rtd->cpu_dais   = [][][][][][][][][]
            rtd->codec_dais = [][][][][][][][][]
    
    This patch merges these into DAIs pointer.
    
            rtd->dais = [][][][][][][][][][][][][][][][][][]
                        ^cpu_dais         ^codec_dais
                        |--- num_cpus ---|--- num_codecs --|
    
    Then, we can merge for_each_rtd_cpu/codec_dais() from this patch.
    
    -       for_each_rtd_cpu_dais() {
    -               ...
    -       }
    -       for_each_rtd_codec_dais() {
    -               ...
    -       }
    +       for_each_rtd_dais() {
    +               ...
    +       }
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87wo7kolfa.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e7e70b47590a..0fd582c19c03 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -475,22 +475,22 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
 
 	/*
-	 * for rtd->codec_dais
+	 * for rtd->dais
 	 */
-	rtd->codec_dais = devm_kcalloc(dev, dai_link->num_codecs,
+	rtd->dais = devm_kcalloc(dev, dai_link->num_cpus + dai_link->num_codecs,
 					sizeof(struct snd_soc_dai *),
 					GFP_KERNEL);
-	if (!rtd->codec_dais)
+	if (!rtd->dais)
 		goto free_rtd;
 
 	/*
-	 * for rtd->cpu_dais
+	 * dais = [][][][][][][][][][][][][][][][][][]
+	 *	  ^cpu_dais         ^codec_dais
+	 *	  |--- num_cpus ---|--- num_codecs --|
 	 */
-	rtd->cpu_dais = devm_kcalloc(dev, dai_link->num_cpus,
-				     sizeof(struct snd_soc_dai *),
-				     GFP_KERNEL);
-	if (!rtd->cpu_dais)
-		goto free_rtd;
+	rtd->cpu_dais	= &rtd->dais[0];
+	rtd->codec_dais	= &rtd->dais[dai_link->num_cpus];
+
 	/*
 	 * rtd remaining settings
 	 */

commit 673f45f7bf7dbb6801a04053e3e2d13dfa42db08
Merge: bd2b34e485f2 1a0f2433d738
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 13 18:52:23 2020 +0000

    Merge branch 'for-5.6' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-5.7

commit a4be4187b2bfc66f4be8a6d35f497eb53a2c8d76
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 9 13:08:04 2020 +0900

    ASoC: soc: use for_each_rtd_codecs/cpus_dai() macro
    
    This patch switch to use plural form macro.
    
            - for_each_rtd_codec_dai()
            + for_each_rtd_codec_dais()
    
            - for_each_rtd_codec_dai_rollback()
            + for_each_rtd_codec_dais_rollback()
    
            - for_each_rtd_cpu_dai()
            + for_each_rtd_cpu_dais()
    
            - for_each_rtd_cpu_dai_rollback()
            + for_each_rtd_cpu_dais_rollback()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87v9negogr.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f2cfbf182f49..4e0f55555e37 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -547,7 +547,7 @@ int snd_soc_suspend(struct device *dev)
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		for_each_rtd_codec_dai(rtd, i, dai) {
+		for_each_rtd_codec_dais(rtd, i, dai) {
 			if (dai->stream_active[playback])
 				snd_soc_dai_digital_mute(dai, 1, playback);
 		}
@@ -689,7 +689,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		for_each_rtd_codec_dai(rtd, i, dai) {
+		for_each_rtd_codec_dais(rtd, i, dai) {
 			if (dai->stream_active[playback])
 				snd_soc_dai_digital_mute(dai, 0, playback);
 		}
@@ -1321,10 +1321,10 @@ static void soc_remove_link_dais(struct snd_soc_card *card)
 	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
 			/* remove the CODEC DAI */
-			for_each_rtd_codec_dai(rtd, i, codec_dai)
+			for_each_rtd_codec_dais(rtd, i, codec_dai)
 				soc_remove_dai(codec_dai, order);
 
-			for_each_rtd_cpu_dai(rtd, i, cpu_dai)
+			for_each_rtd_cpu_dais(rtd, i, cpu_dai)
 				soc_remove_dai(cpu_dai, order);
 		}
 	}
@@ -1344,14 +1344,14 @@ static int soc_probe_link_dais(struct snd_soc_card *card)
 				card->name, rtd->num, order);
 
 			/* probe the CPU DAI */
-			for_each_rtd_cpu_dai(rtd, i, cpu_dai) {
+			for_each_rtd_cpu_dais(rtd, i, cpu_dai) {
 				ret = soc_probe_dai(cpu_dai, order);
 				if (ret)
 					return ret;
 			}
 
 			/* probe the CODEC DAI */
-			for_each_rtd_codec_dai(rtd, i, codec_dai) {
+			for_each_rtd_codec_dais(rtd, i, codec_dai) {
 				ret = soc_probe_dai(codec_dai, order);
 				if (ret)
 					return ret;
@@ -1486,7 +1486,7 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 	unsigned int i;
 	int ret;
 
-	for_each_rtd_codec_dai(rtd, i, codec_dai) {
+	for_each_rtd_codec_dais(rtd, i, codec_dai) {
 		ret = snd_soc_dai_set_fmt(codec_dai, dai_fmt);
 		if (ret != 0 && ret != -ENOTSUPP) {
 			dev_warn(codec_dai->dev,
@@ -1514,7 +1514,7 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 		inv_dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
 		break;
 	}
-	for_each_rtd_cpu_dai(rtd, i, cpu_dai) {
+	for_each_rtd_cpu_dais(rtd, i, cpu_dai) {
 		unsigned int fmt = dai_fmt;
 
 		if (cpu_dai->component->driver->non_legacy_dai_naming)

commit a22ae72b86a4f754e8d25fbf9ea5a8f77365e531
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Mon Mar 9 14:27:43 2020 -0500

    ASoC: soc-core: disable route checks for legacy devices
    
    v5.4 changes in soc-core tightened the checks on soc_dapm_add_routes,
    which results in the ASoC card probe failing.
    
    Introduce a flag to be set in machine drivers to prevent the probe
    from stopping in case of incomplete topologies or missing routes. This
    flag is for backwards compatibility only and shall not be used for
    newer machine drivers.
    
    Example with an HDaudio card with a bad topology:
    
    [ 236.177898] skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: Failed to
    add route iDisp1_out -> direct -> iDisp1 Tx
    
    [ 236.177902] skl_hda_dsp_generic skl_hda_dsp_generic:
    snd_soc_bind_card: snd_soc_dapm_add_routes failed: -19
    
    with the disable_route_checks set:
    
    [ 64.031657] skl_hda_dsp_generic skl_hda_dsp_generic: ASoC: Failed to
    add route iDisp1_out -> direct -> iDisp1 Tx
    
    [ 64.031661] skl_hda_dsp_generic skl_hda_dsp_generic:
    snd_soc_bind_card: disable_route_checks set, ignoring errors on
    add_routes
    
    Fixes: daa480bde6b3a9 ("ASoC: soc-core: tidyup for snd_soc_dapm_add_routes()")
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/20200309192744.18380-2-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 068d809c349a..b17366bac846 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1256,8 +1256,18 @@ static int soc_probe_component(struct snd_soc_card *card,
 	ret = snd_soc_dapm_add_routes(dapm,
 				      component->driver->dapm_routes,
 				      component->driver->num_dapm_routes);
-	if (ret < 0)
-		goto err_probe;
+	if (ret < 0) {
+		if (card->disable_route_checks) {
+			dev_info(card->dev,
+				 "%s: disable_route_checks set, ignoring errors on add_routes\n",
+				 __func__);
+		} else {
+			dev_err(card->dev,
+				"%s: snd_soc_dapm_add_routes failed: %d\n",
+				__func__, ret);
+			goto err_probe;
+		}
+	}
 
 	/* see for_each_card_components */
 	list_add(&component->card_list, &card->component_dev_list);
@@ -1938,8 +1948,18 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 
 	ret = snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 				      card->num_dapm_routes);
-	if (ret < 0)
-		goto probe_end;
+	if (ret < 0) {
+		if (card->disable_route_checks) {
+			dev_info(card->dev,
+				 "%s: disable_route_checks set, ignoring errors on add_routes\n",
+				 __func__);
+		} else {
+			dev_err(card->dev,
+				 "%s: snd_soc_dapm_add_routes failed: %d\n",
+				 __func__, ret);
+			goto probe_end;
+		}
+	}
 
 	ret = snd_soc_dapm_add_routes(&card->dapm, card->of_dapm_routes,
 				      card->num_of_dapm_routes);

commit 76afa64374a79c22b2dab61aebef99a967783bf0
Author: Shreyas NC <shreyas.nc@intel.com>
Date:   Tue Feb 25 21:39:12 2020 +0800

    ASoC: Add initial support for multiple CPU DAIs
    
    ASoC core supports multiple codec DAIs but supports only a CPU DAI.
    To support multiple cpu DAIs, add cpu_dai and num_cpu_dai in
    snd_soc_dai_link and snd_soc_pcm_runtime structures similar to
    support for codec_dai. This is intended as a preparatory patch to
    eventually support the unification of the Codec and CPU DAI.
    
    Inline with multiple codec DAI approach, add support to allocate,
    init, bind and probe multiple cpu_dai on init if driver specifies
    that. Also add support to loop over multiple cpu_dai during
    suspend and resume.
    
    This is intended as a preparatory patch to eventually unify the CPU
    and Codec DAI into DAI components.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Shreyas NC <shreyas.nc@intel.com>
    Link: https://lore.kernel.org/r/20200225133917.21314-2-yung-chuan.liao@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 518b652cf872..f2cfbf182f49 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -483,6 +483,14 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	if (!rtd->codec_dais)
 		goto free_rtd;
 
+	/*
+	 * for rtd->cpu_dais
+	 */
+	rtd->cpu_dais = devm_kcalloc(dev, dai_link->num_cpus,
+				     sizeof(struct snd_soc_dai *),
+				     GFP_KERNEL);
+	if (!rtd->cpu_dais)
+		goto free_rtd;
 	/*
 	 * rtd remaining settings
 	 */
@@ -833,7 +841,7 @@ static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 				     struct snd_soc_dai_link *link)
 {
 	int i;
-	struct snd_soc_dai_link_component *codec, *platform;
+	struct snd_soc_dai_link_component *cpu, *codec, *platform;
 
 	for_each_link_codecs(link, i, codec) {
 		/*
@@ -882,44 +890,38 @@ static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 			return -EPROBE_DEFER;
 	}
 
-	/* FIXME */
-	if (link->num_cpus > 1) {
-		dev_err(card->dev,
-			"ASoC: multi cpu is not yet supported %s\n",
-			link->name);
-		return -EINVAL;
-	}
-
-	/*
-	 * CPU device may be specified by either name or OF node, but
-	 * can be left unspecified, and will be matched based on DAI
-	 * name alone..
-	 */
-	if (link->cpus->name && link->cpus->of_node) {
-		dev_err(card->dev,
-			"ASoC: Neither/both cpu name/of_node are set for %s\n",
-			link->name);
-		return -EINVAL;
-	}
+	for_each_link_cpus(link, i, cpu) {
+		/*
+		 * CPU device may be specified by either name or OF node, but
+		 * can be left unspecified, and will be matched based on DAI
+		 * name alone..
+		 */
+		if (cpu->name && cpu->of_node) {
+			dev_err(card->dev,
+				"ASoC: Neither/both cpu name/of_node are set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
 
-	/*
-	 * Defer card registration if cpu dai component is not added to
-	 * component list.
-	 */
-	if ((link->cpus->of_node || link->cpus->name) &&
-	    !soc_find_component(link->cpus))
-		return -EPROBE_DEFER;
+		/*
+		 * Defer card registration if cpu dai component is not added to
+		 * component list.
+		 */
+		if ((cpu->of_node || cpu->name) &&
+		    !soc_find_component(cpu))
+			return -EPROBE_DEFER;
 
-	/*
-	 * At least one of CPU DAI name or CPU device name/node must be
-	 * specified
-	 */
-	if (!link->cpus->dai_name &&
-	    !(link->cpus->name || link->cpus->of_node)) {
-		dev_err(card->dev,
-			"ASoC: Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
-			link->name);
-		return -EINVAL;
+		/*
+		 * At least one of CPU DAI name or CPU device name/node must be
+		 * specified
+		 */
+		if (!cpu->dai_name &&
+		    !(cpu->name || cpu->of_node)) {
+			dev_err(card->dev,
+				"ASoC: Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
 	}
 
 	return 0;
@@ -962,7 +964,7 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 			    struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_dai_link_component *codec, *platform;
+	struct snd_soc_dai_link_component *codec, *platform, *cpu;
 	struct snd_soc_component *component;
 	int i, ret;
 
@@ -987,14 +989,19 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 	if (!rtd)
 		return -ENOMEM;
 
-	/* FIXME: we need multi CPU support in the future */
-	rtd->cpu_dai = snd_soc_find_dai(dai_link->cpus);
-	if (!rtd->cpu_dai) {
-		dev_info(card->dev, "ASoC: CPU DAI %s not registered\n",
-			 dai_link->cpus->dai_name);
-		goto _err_defer;
+	rtd->num_cpus = dai_link->num_cpus;
+	for_each_link_cpus(dai_link, i, cpu) {
+		rtd->cpu_dais[i] = snd_soc_find_dai(cpu);
+		if (!rtd->cpu_dais[i]) {
+			dev_info(card->dev, "ASoC: CPU DAI %s not registered\n",
+				 cpu->dai_name);
+			goto _err_defer;
+		}
+		snd_soc_rtd_add_component(rtd, rtd->cpu_dais[i]->component);
 	}
-	snd_soc_rtd_add_component(rtd, rtd->cpu_dai->component);
+
+	/* Single cpu links expect cpu and cpu_dai in runtime data */
+	rtd->cpu_dai = rtd->cpu_dais[0];
 
 	/* Find CODEC from registered CODECs */
 	rtd->num_codecs = dai_link->num_codecs;
@@ -1114,7 +1121,8 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 			dai_link->stream_name, ret);
 		return ret;
 	}
-	ret = soc_dai_pcm_new(&cpu_dai, 1, rtd);
+	ret = soc_dai_pcm_new(rtd->cpu_dais,
+			      rtd->num_cpus, rtd);
 	if (ret < 0)
 		return ret;
 	ret = soc_dai_pcm_new(rtd->codec_dais,
@@ -1306,6 +1314,7 @@ static void soc_remove_link_dais(struct snd_soc_card *card)
 {
 	int i;
 	struct snd_soc_dai *codec_dai;
+	struct snd_soc_dai *cpu_dai;
 	struct snd_soc_pcm_runtime *rtd;
 	int order;
 
@@ -1315,14 +1324,15 @@ static void soc_remove_link_dais(struct snd_soc_card *card)
 			for_each_rtd_codec_dai(rtd, i, codec_dai)
 				soc_remove_dai(codec_dai, order);
 
-			soc_remove_dai(rtd->cpu_dai, order);
+			for_each_rtd_cpu_dai(rtd, i, cpu_dai)
+				soc_remove_dai(cpu_dai, order);
 		}
 	}
 }
 
 static int soc_probe_link_dais(struct snd_soc_card *card)
 {
-	struct snd_soc_dai *codec_dai;
+	struct snd_soc_dai *codec_dai, *cpu_dai;
 	struct snd_soc_pcm_runtime *rtd;
 	int i, order, ret;
 
@@ -1333,9 +1343,12 @@ static int soc_probe_link_dais(struct snd_soc_card *card)
 				"ASoC: probe %s dai link %d late %d\n",
 				card->name, rtd->num, order);
 
-			ret = soc_probe_dai(rtd->cpu_dai, order);
-			if (ret)
-				return ret;
+			/* probe the CPU DAI */
+			for_each_rtd_cpu_dai(rtd, i, cpu_dai) {
+				ret = soc_probe_dai(cpu_dai, order);
+				if (ret)
+					return ret;
+			}
 
 			/* probe the CODEC DAI */
 			for_each_rtd_codec_dai(rtd, i, codec_dai) {
@@ -1467,8 +1480,9 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 	unsigned int dai_fmt)
 {
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *cpu_dai;
 	struct snd_soc_dai *codec_dai;
+	unsigned int inv_dai_fmt;
 	unsigned int i;
 	int ret;
 
@@ -1485,33 +1499,33 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 	 * Flip the polarity for the "CPU" end of a CODEC<->CODEC link
 	 * the component which has non_legacy_dai_naming is Codec
 	 */
-	if (cpu_dai->component->driver->non_legacy_dai_naming) {
-		unsigned int inv_dai_fmt;
-
-		inv_dai_fmt = dai_fmt & ~SND_SOC_DAIFMT_MASTER_MASK;
-		switch (dai_fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-		case SND_SOC_DAIFMT_CBM_CFM:
-			inv_dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
-			break;
-		case SND_SOC_DAIFMT_CBM_CFS:
-			inv_dai_fmt |= SND_SOC_DAIFMT_CBS_CFM;
-			break;
-		case SND_SOC_DAIFMT_CBS_CFM:
-			inv_dai_fmt |= SND_SOC_DAIFMT_CBM_CFS;
-			break;
-		case SND_SOC_DAIFMT_CBS_CFS:
-			inv_dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
-			break;
-		}
-
-		dai_fmt = inv_dai_fmt;
+	inv_dai_fmt = dai_fmt & ~SND_SOC_DAIFMT_MASTER_MASK;
+	switch (dai_fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		inv_dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		inv_dai_fmt |= SND_SOC_DAIFMT_CBS_CFM;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		inv_dai_fmt |= SND_SOC_DAIFMT_CBM_CFS;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		inv_dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+		break;
 	}
+	for_each_rtd_cpu_dai(rtd, i, cpu_dai) {
+		unsigned int fmt = dai_fmt;
 
-	ret = snd_soc_dai_set_fmt(cpu_dai, dai_fmt);
-	if (ret != 0 && ret != -ENOTSUPP) {
-		dev_warn(cpu_dai->dev,
-			 "ASoC: Failed to set DAI format: %d\n", ret);
-		return ret;
+		if (cpu_dai->component->driver->non_legacy_dai_naming)
+			fmt = inv_dai_fmt;
+
+		ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+		if (ret != 0 && ret != -ENOTSUPP) {
+			dev_warn(cpu_dai->dev,
+				 "ASoC: Failed to set DAI format: %d\n", ret);
+			return ret;
+		}
 	}
 
 	return 0;

commit 6b62fa95b56bcc77cbbcc76e45f5170b4ec229b1
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Wed Feb 19 11:25:26 2020 +0100

    ASoC: fix card registration regression.
    
    This reverts commit b2354e4009a773c00054b964d937e1b81cb92078.
    
    This change might have been desirable to ensure the uniqueness of
    the component name. It would have helped to better support linux
    devices which register multiple components, something is which more
    common than initially thought.
    
    However, some card driver are directly using dev_name() to fill the
    component names of the dai_link which is a problem if want to change
    the way ASoC generates the component names.
    
    Until we figure out the appropriate way to deal with this, revert the
    change and keep the names as they were. There might be a couple of warning
    related to debugfs (which were already present before the change) but it
    is still better than breaking working audio cards.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200219102526.692126-1-jbrunet@baylibre.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 30c17fde14ca..518b652cf872 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2442,33 +2442,6 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 	return ret;
 }
 
-static char *snd_soc_component_unique_name(struct device *dev,
-					   struct snd_soc_component *component)
-{
-	struct snd_soc_component *pos;
-	int count = 0;
-	char *name, *unique;
-
-	name = fmt_single_name(dev, &component->id);
-	if (!name)
-		return name;
-
-	/* Count the number of components registred by the device */
-	for_each_component(pos) {
-		if (dev == pos->dev)
-			count++;
-	}
-
-	/* Keep naming as it is for the 1st component */
-	if (!count)
-		return name;
-
-	unique = devm_kasprintf(dev, GFP_KERNEL, "%s-%d", name, count);
-	devm_kfree(dev, name);
-
-	return unique;
-}
-
 static int snd_soc_component_initialize(struct snd_soc_component *component,
 	const struct snd_soc_component_driver *driver, struct device *dev)
 {
@@ -2477,7 +2450,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	INIT_LIST_HEAD(&component->card_list);
 	mutex_init(&component->io_mutex);
 
-	component->name = snd_soc_component_unique_name(dev, component);
+	component->name = fmt_single_name(dev, &component->id);
 	if (!component->name) {
 		dev_err(dev, "ASoC: Failed to allocate name\n");
 		return -ENOMEM;

commit d74c2a156b710e9ad81193a60e037430f8894c0c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 17 17:28:25 2020 +0900

    ASoC: soc-core: use for_each_pcm_streams() macro
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/8736b9botk.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f0ae1a7d7e09..30c17fde14ca 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -432,6 +432,7 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	struct snd_soc_component *component;
 	struct device *dev;
 	int ret;
+	int stream;
 
 	/*
 	 * for rtd->dev
@@ -466,10 +467,10 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 
 	rtd->dev = dev;
 	INIT_LIST_HEAD(&rtd->list);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].be_clients);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].fe_clients);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].fe_clients);
+	for_each_pcm_streams(stream) {
+		INIT_LIST_HEAD(&rtd->dpcm[stream].be_clients);
+		INIT_LIST_HEAD(&rtd->dpcm[stream].fe_clients);
+	}
 	dev_set_drvdata(dev, rtd);
 	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
 
@@ -559,17 +560,14 @@ int snd_soc_suspend(struct device *dev)
 	snd_soc_flush_all_delayed_work(card);
 
 	for_each_card_rtds(card, rtd) {
+		int stream;
 
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		snd_soc_dapm_stream_event(rtd,
-					  SNDRV_PCM_STREAM_PLAYBACK,
-					  SND_SOC_DAPM_STREAM_SUSPEND);
-
-		snd_soc_dapm_stream_event(rtd,
-					  SNDRV_PCM_STREAM_CAPTURE,
-					  SND_SOC_DAPM_STREAM_SUSPEND);
+		for_each_pcm_streams(stream)
+			snd_soc_dapm_stream_event(rtd, stream,
+						  SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
 	/* Recheck all endpoints too, their state is affected by suspend */
@@ -665,17 +663,14 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	for_each_card_rtds(card, rtd) {
+		int stream;
 
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		snd_soc_dapm_stream_event(rtd,
-					  SNDRV_PCM_STREAM_PLAYBACK,
-					  SND_SOC_DAPM_STREAM_RESUME);
-
-		snd_soc_dapm_stream_event(rtd,
-					  SNDRV_PCM_STREAM_CAPTURE,
-					  SND_SOC_DAPM_STREAM_RESUME);
+		for_each_pcm_streams(stream)
+			snd_soc_dapm_stream_event(rtd, stream,
+						  SND_SOC_DAPM_STREAM_RESUME);
 	}
 
 	/* unmute any active DACs */

commit 0f6011fd79a2fb92cb80177fd6bdc8aac3a3cd93
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 17 17:28:15 2020 +0900

    ASoC: soc-pcm: merge playback/cature_active into stream_active
    
    DAI has playback_active and capture_active to care usage count.
    OTOH, we have SNDRV_PCM_STREAM_PLAYBACK/CAPTURE.
    But because of this kind of implementation mismatch,
    ALSA SoC has many verbose code.
    
    To solve this issue, this patch merge playback_active/capture_active
    into stream_active[2];
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/875zg5botu.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6a58a8f6e3c4..f0ae1a7d7e09 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -365,19 +365,20 @@ EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
 void snd_soc_close_delayed_work(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int playback = SNDRV_PCM_STREAM_PLAYBACK;
 
 	mutex_lock_nested(&rtd->card->pcm_mutex, rtd->card->pcm_subclass);
 
 	dev_dbg(rtd->dev,
 		"ASoC: pop wq checking: %s status: %s waiting: %s\n",
 		codec_dai->driver->playback.stream_name,
-		codec_dai->playback_active ? "active" : "inactive",
+		codec_dai->stream_active[playback] ? "active" : "inactive",
 		rtd->pop_wait ? "yes" : "no");
 
 	/* are we waiting on this codec DAI stream */
 	if (rtd->pop_wait == 1) {
 		rtd->pop_wait = 0;
-		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
+		snd_soc_dapm_stream_event(rtd, playback,
 					  SND_SOC_DAPM_STREAM_STOP);
 	}
 
@@ -514,6 +515,7 @@ int snd_soc_suspend(struct device *dev)
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	struct snd_soc_component *component;
 	struct snd_soc_pcm_runtime *rtd;
+	int playback = SNDRV_PCM_STREAM_PLAYBACK;
 	int i;
 
 	/* If the card is not initialized yet there is nothing to do */
@@ -537,9 +539,8 @@ int snd_soc_suspend(struct device *dev)
 			continue;
 
 		for_each_rtd_codec_dai(rtd, i, dai) {
-			if (dai->playback_active)
-				snd_soc_dai_digital_mute(dai, 1,
-						SNDRV_PCM_STREAM_PLAYBACK);
+			if (dai->stream_active[playback])
+				snd_soc_dai_digital_mute(dai, 1, playback);
 		}
 	}
 
@@ -680,14 +681,14 @@ static void soc_resume_deferred(struct work_struct *work)
 	/* unmute any active DACs */
 	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *dai;
+		int playback = SNDRV_PCM_STREAM_PLAYBACK;
 
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
 		for_each_rtd_codec_dai(rtd, i, dai) {
-			if (dai->playback_active)
-				snd_soc_dai_digital_mute(dai, 0,
-						SNDRV_PCM_STREAM_PLAYBACK);
+			if (dai->stream_active[playback])
+				snd_soc_dai_digital_mute(dai, 0, playback);
 		}
 	}
 

commit b2354e4009a773c00054b964d937e1b81cb92078
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Feb 14 14:47:04 2020 +0100

    ASoC: core: ensure component names are unique
    
    Make sure each ASoC component is registered with a unique name.
    The component is derived from the device name. If a device registers more
    than one component, the component names will be the same.
    
    This usually brings up a warning about the debugfs directory creation of
    the component since directory already exists.
    
    In such case, start numbering the component of the device so the names
    don't collide anymore.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Link: https://lore.kernel.org/r/20200214134704.342501-1-jbrunet@baylibre.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 03b87427faa7..6a58a8f6e3c4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2446,6 +2446,33 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 	return ret;
 }
 
+static char *snd_soc_component_unique_name(struct device *dev,
+					   struct snd_soc_component *component)
+{
+	struct snd_soc_component *pos;
+	int count = 0;
+	char *name, *unique;
+
+	name = fmt_single_name(dev, &component->id);
+	if (!name)
+		return name;
+
+	/* Count the number of components registred by the device */
+	for_each_component(pos) {
+		if (dev == pos->dev)
+			count++;
+	}
+
+	/* Keep naming as it is for the 1st component */
+	if (!count)
+		return name;
+
+	unique = devm_kasprintf(dev, GFP_KERNEL, "%s-%d", name, count);
+	devm_kfree(dev, name);
+
+	return unique;
+}
+
 static int snd_soc_component_initialize(struct snd_soc_component *component,
 	const struct snd_soc_component_driver *driver, struct device *dev)
 {
@@ -2454,7 +2481,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	INIT_LIST_HEAD(&component->card_list);
 	mutex_init(&component->io_mutex);
 
-	component->name = fmt_single_name(dev, &component->id);
+	component->name = snd_soc_component_unique_name(dev, component);
 	if (!component->name) {
 		dev_err(dev, "ASoC: Failed to allocate name\n");
 		return -ENOMEM;

commit 1dfa5a5ab34560fd9647083f623d19705be2e706
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Thu Feb 13 16:51:51 2020 +0100

    ASoC: core: allow a dt node to provide several components
    
    At the moment, querying the dai_name will stop of the first component
    matching the dt node. This does not allow a device (single dt node) to
    provide several ASoC components which could then be used through DT.
    
    This change let the search go on if the xlate function of the component
    returns an error, giving the possibility to another component to match
    and return the dai_name.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Link: https://lore.kernel.org/r/20200213155159.3235792-2-jbrunet@baylibre.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 068d809c349a..03b87427faa7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3102,6 +3102,14 @@ int snd_soc_get_dai_name(struct of_phandle_args *args,
 			*dai_name = dai->driver->name;
 			if (!*dai_name)
 				*dai_name = pos->name;
+		} else if (ret) {
+			/*
+			 * if another error than ENOTSUPP is returned go on and
+			 * check if another component is provided with the same
+			 * node. This may happen if a device provides several
+			 * components
+			 */
+			continue;
 		}
 
 		break;

commit d8e2e0d2491e78f3f7b451c3a93ba29950efe2cf
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jan 22 09:45:00 2020 +0900

    ASoC: soc-core: remove null_snd_soc_ops
    
    All rtd->dai_link callback functions are controlled by soc_rtd_xxxx(),
    and checking rtd->dai_link->ops.
    We don't need to have null_snd_soc_ops anymore.
    This patch removes it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87zhegl3oz.wl-kuninori.morimoto.gx@renesas.com
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f969a3b8c82b..068d809c349a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -342,8 +342,6 @@ struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
 
-static const struct snd_soc_ops null_snd_soc_ops;
-
 struct snd_soc_pcm_runtime
 *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
 			 struct snd_soc_dai_link *dai_link)
@@ -488,8 +486,6 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	 */
 	rtd->card = card;
 	rtd->dai_link = dai_link;
-	if (!rtd->dai_link->ops)
-		rtd->dai_link->ops = &null_snd_soc_ops;
 
 	/* see for_each_card_rtds */
 	list_add_tail(&rtd->list, &card->rtd_list);

commit 250a15cf575a655097151ad887cea02dd0977136
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 20 10:05:07 2020 +0900

    ASoC: soc-core: remove bus_control
    
    Now, snd_soc_dai_driver::bus_control is used for how to resume.
    But, no driver which has bus_control has DAI driver suspend/resume
    support.
    This patch removes pointless bus_control from ALSA SoC.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87pnffx7i4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b0ec3233125a..f969a3b8c82b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -712,8 +712,6 @@ static void soc_resume_deferred(struct work_struct *work)
 int snd_soc_resume(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
-	bool bus_control = false;
-	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_component *component;
 
 	/* If the card is not initialized yet there is nothing to do */
@@ -725,25 +723,9 @@ int snd_soc_resume(struct device *dev)
 		if (component->active)
 			pinctrl_pm_select_default_state(component->dev);
 
-	/*
-	 * DAIs that also act as the control bus master might have other drivers
-	 * hanging off them so need to resume immediately. Other drivers don't
-	 * have that problem and may take a substantial amount of time to resume
-	 * due to I/O costs and anti-pop so handle them out of line.
-	 */
-	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-
-		bus_control |= cpu_dai->driver->bus_control;
-	}
-	if (bus_control) {
-		dev_dbg(dev, "ASoC: Resuming control bus master immediately\n");
-		soc_resume_deferred(&card->deferred_resume_work);
-	} else {
-		dev_dbg(dev, "ASoC: Scheduling resume work\n");
-		if (!schedule_work(&card->deferred_resume_work))
-			dev_err(dev, "ASoC: resume work item may be lost\n");
-	}
+	dev_dbg(dev, "ASoC: Scheduling resume work\n");
+	if (!schedule_work(&card->deferred_resume_work))
+		dev_err(dev, "ASoC: resume work item may be lost\n");
 
 	return 0;
 }

commit 450312b640f9c6caeeaf4bd8d4130f86ea27f456
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 20 10:05:03 2020 +0900

    ASoC: soc-core: remove DAI suspend/resume
    
    Historically, CPU and Codec were implemented different, but now it is
    merged as Component.
    ALSA SoC is supporting suspend/resume at DAI and Component level.
    The method is like below.
    
            1) Suspend/Resume all CPU DAI if bus-control was 0
            2) Suspend/Resume all Component
            3) Suspend/Resume all CPU DAI if bus-control was 1
    
    Historically 2) was Codec special operation.
    Because CPU and Codec were merged into Component,
    CPU   suspend/resume has 3 chance to suspend(= 1/2/3), but
    Codec suspend/resume has 1 chance (= 2).
    
    Here, DAI side suspend/resume is caring bus-control, but no driver
    which is supporting suspend/resume is setting bus-control.
    This means 3) was never used.
    
    Here, used parameter for suspend/resume component->dev and dai->dev are
    same pointer.
    For that reason, we can merge DAI and Component suspend/resume.
    One note is that we should use 2), because it is caring BIAS level.
    
    This patch removes 1) and 3).
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87r1zvx7i8.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index acf6f141fd2d..b0ec3233125a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -558,16 +558,6 @@ int snd_soc_suspend(struct device *dev)
 	if (card->suspend_pre)
 		card->suspend_pre(card);
 
-	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-
-		if (rtd->dai_link->ignore_suspend)
-			continue;
-
-		if (!cpu_dai->driver->bus_control)
-			snd_soc_dai_suspend(cpu_dai);
-	}
-
 	/* close any waiting streams */
 	snd_soc_flush_all_delayed_work(card);
 
@@ -639,16 +629,6 @@ int snd_soc_suspend(struct device *dev)
 		}
 	}
 
-	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-
-		if (rtd->dai_link->ignore_suspend)
-			continue;
-
-		if (cpu_dai->driver->bus_control)
-			snd_soc_dai_suspend(cpu_dai);
-	}
-
 	if (card->suspend_post)
 		card->suspend_post(card);
 
@@ -682,17 +662,6 @@ static void soc_resume_deferred(struct work_struct *work)
 	if (card->resume_pre)
 		card->resume_pre(card);
 
-	/* resume control bus DAIs */
-	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-
-		if (rtd->dai_link->ignore_suspend)
-			continue;
-
-		if (cpu_dai->driver->bus_control)
-			snd_soc_dai_resume(cpu_dai);
-	}
-
 	for_each_card_components(card, component) {
 		if (snd_soc_component_is_suspended(component))
 			snd_soc_component_resume(component);
@@ -726,16 +695,6 @@ static void soc_resume_deferred(struct work_struct *work)
 		}
 	}
 
-	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-
-		if (rtd->dai_link->ignore_suspend)
-			continue;
-
-		if (!cpu_dai->driver->bus_control)
-			snd_soc_dai_resume(cpu_dai);
-	}
-
 	if (card->resume_post)
 		card->resume_post(card);
 

commit 83f94a2e293d617a98e077680ea00b2830a9ca22
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 10 11:36:17 2020 +0900

    ASoC: soc-core: add snd_soc_close_delayed_work()
    
    We need to setup rtd->close_delayed_work_func.
    It will be set at snd_soc_dai_compress_new() or soc_new_pcm().
    But these setups close_delayed_work() which is same name /
    same implemantaion, but different local code.
    To reduce duplicate code, this patch moves it as
    snd_soc_close_delayed_work() and share same code.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/8736cot4v2.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3c729eaf0bbf..acf6f141fd2d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -359,6 +359,34 @@ struct snd_soc_pcm_runtime
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
 
+/*
+ * Power down the audio subsystem pmdown_time msecs after close is called.
+ * This is to ensure there are no pops or clicks in between any music tracks
+ * due to DAPM power cycling.
+ */
+void snd_soc_close_delayed_work(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+
+	mutex_lock_nested(&rtd->card->pcm_mutex, rtd->card->pcm_subclass);
+
+	dev_dbg(rtd->dev,
+		"ASoC: pop wq checking: %s status: %s waiting: %s\n",
+		codec_dai->driver->playback.stream_name,
+		codec_dai->playback_active ? "active" : "inactive",
+		rtd->pop_wait ? "yes" : "no");
+
+	/* are we waiting on this codec DAI stream */
+	if (rtd->pop_wait == 1) {
+		rtd->pop_wait = 0;
+		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
+					  SND_SOC_DAPM_STREAM_STOP);
+	}
+
+	mutex_unlock(&rtd->card->pcm_mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_close_delayed_work);
+
 static void soc_release_rtd_dev(struct device *dev)
 {
 	/* "dev" means "rtd->dev" */

commit 76c39e867cba338d8982f6372b2c4e3189f6439b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 10 11:36:13 2020 +0900

    ASoC: soc-core: do pinctrl_pm_select_xxx() as component
    
    ALSA SoC need to care pinctrl_pm_select_xxx().
    It is called at soc-core and soc-pcm.
    soc-pcm  is controlling it for activate DAI.
    soc-core is controlling it for whole system
    (= suspend/resume/probe/poweroff).
    
    If we focus to soc-core side, it need to care about BIAS level.
    Then, snd_soc_suspend() only is controlling it by Component base (a).
    Other functions are DAI base (b).
    
    (a)     pinctrl_pm_select_xxx(component->dev, xxx);
    (b)     pinctrl_pm_select_xxx(dai->dev, xxx);
    
    Because of these unbalance, the code is confusable.
    Here, dai->dev and component->dev are same pointer.
    Thus, we can replace it component base.
    
    One note here is that it cared DAI (= CPU/Codec) pin before this patch,
    after this patch, it cares Component (= CPU/Codec/Platform) pin.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/874kx4t4v6.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 191b68732e56..3c729eaf0bbf 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -727,25 +727,16 @@ int snd_soc_resume(struct device *dev)
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	bool bus_control = false;
 	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_dai *codec_dai;
-	int i;
+	struct snd_soc_component *component;
 
 	/* If the card is not initialized yet there is nothing to do */
 	if (!card->instantiated)
 		return 0;
 
 	/* activate pins from sleep state */
-	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-
-		if (cpu_dai->active)
-			pinctrl_pm_select_default_state(cpu_dai->dev);
-
-		for_each_rtd_codec_dai(rtd, i, codec_dai) {
-			if (codec_dai->active)
-				pinctrl_pm_select_default_state(codec_dai->dev);
-		}
-	}
+	for_each_card_components(card, component)
+		if (component->active)
+			pinctrl_pm_select_default_state(component->dev);
 
 	/*
 	 * DAIs that also act as the control bus master might have other drivers
@@ -1885,6 +1876,7 @@ static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 static int snd_soc_bind_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
+	struct snd_soc_component *component;
 	struct snd_soc_dai_link *dai_link;
 	int ret, i, card_probed = 0;
 
@@ -2036,17 +2028,9 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 	snd_soc_dapm_sync(&card->dapm);
 
 	/* deactivate pins to sleep state */
-	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *dai;
-
-		for_each_rtd_codec_dai(rtd, i, dai) {
-			if (!dai->active)
-				pinctrl_pm_select_sleep_state(dai->dev);
-		}
-
-		if (!rtd->cpu_dai->active)
-			pinctrl_pm_select_sleep_state(rtd->cpu_dai->dev);
-	}
+	for_each_card_components(card, component)
+		if (!component->active)
+			pinctrl_pm_select_sleep_state(component->dev);
 
 probe_end:
 	if (ret < 0)
@@ -2092,7 +2076,7 @@ static int soc_remove(struct platform_device *pdev)
 int snd_soc_poweroff(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
-	struct snd_soc_pcm_runtime *rtd;
+	struct snd_soc_component *component;
 
 	if (!card->instantiated)
 		return 0;
@@ -2106,16 +2090,8 @@ int snd_soc_poweroff(struct device *dev)
 	snd_soc_dapm_shutdown(card);
 
 	/* deactivate pins to sleep state */
-	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-		struct snd_soc_dai *codec_dai;
-		int i;
-
-		pinctrl_pm_select_sleep_state(cpu_dai->dev);
-		for_each_rtd_codec_dai(rtd, i, codec_dai) {
-			pinctrl_pm_select_sleep_state(codec_dai->dev);
-		}
-	}
+	for_each_card_components(card, component)
+		pinctrl_pm_select_sleep_state(component->dev);
 
 	return 0;
 }

commit d7a8cb4931652256a01383bb3ea10fab316e72a1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 10 11:36:07 2020 +0900

    ASoC: soc-core: remove duplicate pinctrl operation when suspend
    
    snd_soc_suspend() are doing below for pinctrl_pm_select_sleep_state()
    
            int snd_soc_suspend(struct device *dev)
            {
                    ...
                    for_each_card_components(card, component) {
                            ...
    (1)                     pinctrl_pm_select_sleep_state(component->dev);
                    }
    
                    for_each_card_rtds(card, rtd) {
                            ...
    (2)                     pinctrl_pm_select_sleep_state(cpu_dai->dev);
                    }
            }
    
    (1) is called for all component (CPU/Codec/Platform), and
    (2) is called for CPU DAIs.
    Here, component->dev is same as dai->dev.
    This means, it is called in duplicate on CPU case.
    This patch removes (2).
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/875zhkt4vc.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8a1b4ffa6ca6..191b68732e56 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -619,9 +619,6 @@ int snd_soc_suspend(struct device *dev)
 
 		if (cpu_dai->driver->bus_control)
 			snd_soc_dai_suspend(cpu_dai);
-
-		/* deactivate pins to sleep state */
-		pinctrl_pm_select_sleep_state(cpu_dai->dev);
 	}
 
 	if (card->suspend_post)

commit 1272063a7ee4e60ace4cf7cae621fb6f8cafaaba
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 10 11:36:02 2020 +0900

    ASoC: soc-core: care .ignore_suspend for Component suspend
    
    Card dai_link has .ignore_suspend, and ALSA SoC cares it when suspend.
    For example, like this
    
            for_each_card_rtds(card, rtd) {
                    if (rtd->dai_link->ignore_suspend)
                            continue;
                    ...
            }
    
    But in snd_soc_suspend(), it doesn't care about
    it when suspending Component. This patch cares it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/877e20t4vh.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9a6d905cda43..8a1b4ffa6ca6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -562,15 +562,25 @@ int snd_soc_suspend(struct device *dev)
 	snd_soc_dapm_sync(&card->dapm);
 
 	/* suspend all COMPONENTs */
-	for_each_card_components(card, component) {
-		struct snd_soc_dapm_context *dapm =
+	for_each_card_rtds(card, rtd) {
+
+		if (rtd->dai_link->ignore_suspend)
+			continue;
+
+		for_each_rtd_components(rtd, i, component) {
+			struct snd_soc_dapm_context *dapm =
 				snd_soc_component_get_dapm(component);
 
-		/*
-		 * If there are paths active then the COMPONENT will be held
-		 * with bias _ON and should not be suspended.
-		 */
-		if (!snd_soc_component_is_suspended(component)) {
+			/*
+			 * ignore if component was already suspended
+			 */
+			if (snd_soc_component_is_suspended(component))
+				continue;
+
+			/*
+			 * If there are paths active then the COMPONENT will be
+			 * held with bias _ON and should not be suspended.
+			 */
 			switch (snd_soc_dapm_get_bias_level(dapm)) {
 			case SND_SOC_BIAS_STANDBY:
 				/*

commit 12b052327dc2d9d4ca5146608aad1c42741df4fb
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 10 11:35:54 2020 +0900

    ASoC: soc-core: rename snd_soc_rtdcom_add() to snd_soc_rtd_add_component()
    
    We don't have snd_soc_rtdcom_list anymore.
    Let's rename snd_soc_rtdcom_add() to more understandable
    snd_soc_rtd_add_component()
    
    Reported-by: Sridharan, Ranjani <ranjani.sridharan@intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/878smgt4vp.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c9daa63a339b..9a6d905cda43 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -258,8 +258,8 @@ static inline void snd_soc_debugfs_exit(void)
 
 #endif
 
-static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
-			      struct snd_soc_component *component)
+static int snd_soc_rtd_add_component(struct snd_soc_pcm_runtime *rtd,
+				     struct snd_soc_component *component)
 {
 	struct snd_soc_component *comp;
 	int i;
@@ -1035,7 +1035,7 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 			 dai_link->cpus->dai_name);
 		goto _err_defer;
 	}
-	snd_soc_rtdcom_add(rtd, rtd->cpu_dai->component);
+	snd_soc_rtd_add_component(rtd, rtd->cpu_dai->component);
 
 	/* Find CODEC from registered CODECs */
 	rtd->num_codecs = dai_link->num_codecs;
@@ -1047,7 +1047,7 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 			goto _err_defer;
 		}
 
-		snd_soc_rtdcom_add(rtd, rtd->codec_dais[i]->component);
+		snd_soc_rtd_add_component(rtd, rtd->codec_dais[i]->component);
 	}
 
 	/* Single codec links expect codec and codec_dai in runtime data */
@@ -1059,7 +1059,7 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 			if (!snd_soc_is_matching_component(platform, component))
 				continue;
 
-			snd_soc_rtdcom_add(rtd, component);
+			snd_soc_rtd_add_component(rtd, component);
 		}
 	}
 

commit 613fb50059cf19aa6acbc503a00265d9151c0b09
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 10 11:35:21 2020 +0900

    ASoC: soc-core: remove snd_soc_rtdcom_list
    
    Current ALSA SoC is using struct snd_soc_rtdcom_list to
    connecting component to rtd by using list_head.
    
            struct snd_soc_rtdcom_list {
                    struct snd_soc_component *component;
                    struct list_head list; /* rtd::component_list */
            };
    
            struct snd_soc_pcm_runtime {
                    ...
                    struct list_head component_list; /* list of connected components */
                    ...
            };
    
    The CPU/Codec/Platform component which will be connected to rtd (a)
    is indicated via dai_link at snd_soc_add_pcm_runtime()
    
            int snd_soc_add_pcm_runtime(...)
            {
                    ...
                    /* Find CPU from registered CPUs */
                    rtd->cpu_dai = snd_soc_find_dai(dai_link->cpus);
                    ...
    (a)             snd_soc_rtdcom_add(rtd, rtd->cpu_dai->component);
                    ...
    
                    /* Find CODEC from registered CODECs */
    (b)             for_each_link_codecs(dai_link, i, codec) {
                            rtd->codec_dais[i] = snd_soc_find_dai(codec);
                            ...
    (a)                     snd_soc_rtdcom_add(rtd, rtd->codec_dais[i]->component);
                    }
                    ...
    
                    /* Find PLATFORM from registered PLATFORMs */
    (b)             for_each_link_platforms(dai_link, i, platform) {
                            for_each_component(component) {
                                    ...
    (a)                             snd_soc_rtdcom_add(rtd, component);
                            }
                    }
    
            }
    
    It shows, it is possible to know how many components will be
    connected to rtd by using
    
            dai_link->num_cpus
            dai_link->num_codecs
            dai_link->num_platforms
    
    If so, we can use component pointer array instead of list_head,
    in such case, code can be more simple.
    This patch removes struct snd_soc_rtdcom_list that is only
    of temporary value, and convert to pointer array.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-By: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87a76wt4wm.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 55b98e82a978..c9daa63a339b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -261,34 +261,18 @@ static inline void snd_soc_debugfs_exit(void)
 static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 			      struct snd_soc_component *component)
 {
-	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *comp;
+	int i;
 
-	for_each_rtd_components(rtd, rtdcom, comp) {
+	for_each_rtd_components(rtd, i, comp) {
 		/* already connected */
 		if (comp == component)
 			return 0;
 	}
 
-	/*
-	 * created rtdcom here will be freed when rtd->dev was freed.
-	 * see
-	 *	soc_free_pcm_runtime() :: device_unregister(rtd->dev)
-	 */
-	rtdcom = devm_kzalloc(rtd->dev, sizeof(*rtdcom), GFP_KERNEL);
-	if (!rtdcom)
-		return -ENOMEM;
-
-	rtdcom->component = component;
-	INIT_LIST_HEAD(&rtdcom->list);
-
-	/*
-	 * When rtd was freed, created rtdcom here will be
-	 * also freed.
-	 * And we don't need to call list_del(&rtdcom->list)
-	 * when freed, because rtd is also freed.
-	 */
-	list_add_tail(&rtdcom->list, &rtd->component_list);
+	/* see for_each_rtd_components */
+	rtd->components[rtd->num_components] = component;
+	rtd->num_components++;
 
 	return 0;
 }
@@ -296,8 +280,8 @@ static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 						const char *driver_name)
 {
-	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
+	int i;
 
 	if (!driver_name)
 		return NULL;
@@ -310,7 +294,7 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 	 * But, if many components which have same driver name are connected
 	 * to 1 rtd, this function will return 1st found component.
 	 */
-	for_each_rtd_components(rtd, rtdcom, component) {
+	for_each_rtd_components(rtd, i, component) {
 		const char *component_name = component->driver->name;
 
 		if (!component_name)
@@ -318,7 +302,7 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 
 		if ((component_name == driver_name) ||
 		    strcmp(component_name, driver_name) == 0)
-			return rtdcom->component;
+			return component;
 	}
 
 	return NULL;
@@ -418,6 +402,7 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	struct snd_soc_card *card, struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
+	struct snd_soc_component *component;
 	struct device *dev;
 	int ret;
 
@@ -443,13 +428,17 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	/*
 	 * for rtd
 	 */
-	rtd = devm_kzalloc(dev, sizeof(*rtd), GFP_KERNEL);
+	rtd = devm_kzalloc(dev,
+			   sizeof(*rtd) +
+			   sizeof(*component) * (dai_link->num_cpus +
+						 dai_link->num_codecs +
+						 dai_link->num_platforms),
+			   GFP_KERNEL);
 	if (!rtd)
 		goto free_rtd;
 
 	rtd->dev = dev;
 	INIT_LIST_HEAD(&rtd->list);
-	INIT_LIST_HEAD(&rtd->component_list);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].be_clients);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].fe_clients);
@@ -1108,9 +1097,8 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 {
 	struct snd_soc_dai_link *dai_link = rtd->dai_link;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
-	int ret, num;
+	int ret, num, i;
 
 	/* set default power off timeout */
 	rtd->pmdown_time = pmdown_time;
@@ -1141,7 +1129,7 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 	 * topology based drivers can use the DAI link id field to set PCM
 	 * device number and then use rtd + a base offset of the BEs.
 	 */
-	for_each_rtd_components(rtd, rtdcom, component) {
+	for_each_rtd_components(rtd, i, component) {
 		if (!component->driver->use_dai_pcm_id)
 			continue;
 
@@ -1406,12 +1394,11 @@ static void soc_remove_link_components(struct snd_soc_card *card)
 {
 	struct snd_soc_component *component;
 	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_rtdcom_list *rtdcom;
-	int order;
+	int i, order;
 
 	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
-			for_each_rtd_components(rtd, rtdcom, component) {
+			for_each_rtd_components(rtd, i, component) {
 				if (component->driver->remove_order != order)
 					continue;
 
@@ -1425,12 +1412,11 @@ static int soc_probe_link_components(struct snd_soc_card *card)
 {
 	struct snd_soc_component *component;
 	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_rtdcom_list *rtdcom;
-	int ret, order;
+	int i, ret, order;
 
 	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
-			for_each_rtd_components(rtd, rtdcom, component) {
+			for_each_rtd_components(rtd, i, component) {
 				if (component->driver->probe_order != order)
 					continue;
 

commit a82cf72f94af1135f2edde0a244499af390f333a
Merge: bb9ee1eacb2d dcf08d0f8f09
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Dec 25 17:51:43 2019 +0000

    Merge branch 'for-5.5' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-5.6

commit 07d22a9bb623714dc3199099c5cce3df6aef496c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Dec 4 16:14:54 2019 +0100

    ASoC: core: Fix access to uninitialized list heads
    
    The error path of soc_new_pcm_runtime() invokes soc_free_pcm_runtime()
    that may cause a few problems.  First off, it calls list_del() for
    rtd->list that may not be initialized.  Similarly,
    snd_soc_pcm_component_free() traverses over the component list that
    may not be initialized, either.  Such access to the uninitialized list
    head would lead to either a BUG_ON() or a memory corruption.
    
    This patch fixes the access to uninitialized list heads by
    initializing the list heads properly at the beginning before those
    error paths.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20191204151454.21643-1-tiwai@suse.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6050c4c62fe8..8ef0efeed0a7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -479,6 +479,12 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 		goto free_rtd;
 
 	rtd->dev = dev;
+	INIT_LIST_HEAD(&rtd->list);
+	INIT_LIST_HEAD(&rtd->component_list);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].be_clients);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].fe_clients);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].fe_clients);
 	dev_set_drvdata(dev, rtd);
 	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
 
@@ -494,12 +500,6 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	/*
 	 * rtd remaining settings
 	 */
-	INIT_LIST_HEAD(&rtd->component_list);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].be_clients);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].fe_clients);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].fe_clients);
-
 	rtd->card = card;
 	rtd->dai_link = dai_link;
 	if (!rtd->dai_link->ops)

commit 218fe9b7ec7f32c10a07539365488d80af7b0084
Author: Daniel Baluta <daniel.baluta@nxp.com>
Date:   Wed Dec 4 17:13:33 2019 +0200

    ASoC: soc-core: Set dpcm_playback / dpcm_capture
    
    When converting a normal link to a DPCM link we need
    to set dpcm_playback / dpcm_capture otherwise playback/capture
    streams will not be created resulting in errors like this:
    
    [   36.039111]  sai1-wm8960-hifi: ASoC: no backend playback stream
    
    Fixes: a655de808cbde ("ASoC: core: Allow topology to override machine driver FE DAI link config")
    Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
    Link: https://lore.kernel.org/r/20191204151333.26625-1-daniel.baluta@nxp.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1c84ff1a5bf9..6050c4c62fe8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1871,6 +1871,8 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 
 			/* convert non BE into BE */
 			dai_link->no_pcm = 1;
+			dai_link->dpcm_playback = 1;
+			dai_link->dpcm_capture = 1;
 
 			/* override any BE fixups */
 			dai_link->be_hw_params_fixup =

commit ee8f537fd8b71c555d01a89e0834413bbf5373d4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 13 09:55:55 2019 +0900

    ASoC: soc-core: remove legacy style of codec_conf
    
    Now all driver is using snd_soc_dai_link_component for codec_conf.
    Let's remove legacy style
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/871rt959ic.wl-kuninori.morimoto.gx@renesas.com
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 411b83ba2fc0..0bd2cb2e7a67 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1185,12 +1185,6 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 	for (i = 0; i < card->num_configs; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
 
-		/* fixme */
-		if (map->dev_name)
-			map->dlc.name = map->dev_name;
-		if (map->of_node)
-			map->dlc.of_node = map->of_node;
-
 		if (snd_soc_is_matching_component(&map->dlc, component)) {
 			component->name_prefix = map->name_prefix;
 			return;

commit c13493a2460b7ba8f6e75fe6e1a3b732cc294f8f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 13 09:54:36 2019 +0900

    ASoC: soc-core: support snd_soc_dai_link_component for codec_conf
    
    To find codec_conf component, it is using dev_name, of_node.
    But, we already has this kind of finding component method by
    snd_soc_dai_link_component, and snd_soc_is_matching_component().
    We shouldn't have duplicate implementation to do same things.
    This patch adds snd_soc_dai_link_component support to find
    codec_conf component.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87lfrh59kj.wl-kuninori.morimoto.gx@renesas.com
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ee77db253bcc..411b83ba2fc0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1185,12 +1185,16 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 	for (i = 0; i < card->num_configs; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
 
-		if (map->of_node && of_node != map->of_node)
-			continue;
-		if (map->dev_name && strcmp(component->name, map->dev_name))
-			continue;
-		component->name_prefix = map->name_prefix;
-		return;
+		/* fixme */
+		if (map->dev_name)
+			map->dlc.name = map->dev_name;
+		if (map->of_node)
+			map->dlc.of_node = map->of_node;
+
+		if (snd_soc_is_matching_component(&map->dlc, component)) {
+			component->name_prefix = map->name_prefix;
+			return;
+		}
 	}
 
 	/*
@@ -2915,7 +2919,7 @@ void snd_soc_of_parse_node_prefix(struct device_node *np,
 		return;
 	}
 
-	codec_conf->of_node	= of_node;
+	codec_conf->dlc.of_node	= of_node;
 	codec_conf->name_prefix	= str;
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_node_prefix);

commit 01fec8cce7cc68bb88b1ff55bc03da5f3e6625e3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 15:54:06 2019 +0100

    ASoC: Drop snd_soc_pcm_lib_ioctl()
    
    Now all snd_soc_pcm_lib_ioctl() calls were dropped, and it became
    superfluous.  Let's kill it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20191210145406.21419-24-tiwai@suse.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3eb874c4a340..ee77db253bcc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -258,18 +258,6 @@ static inline void snd_soc_debugfs_exit(void)
 
 #endif
 
-/*
- * This is glue code between snd_pcm_lib_ioctl() and
- * snd_soc_component_driver :: ioctl
- */
-int snd_soc_pcm_lib_ioctl(struct snd_soc_component *component,
-			  struct snd_pcm_substream *substream,
-			  unsigned int cmd, void *arg)
-{
-	return snd_pcm_lib_ioctl(substream, cmd, arg);
-}
-EXPORT_SYMBOL_GPL(snd_soc_pcm_lib_ioctl);
-
 static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 			      struct snd_soc_component *component)
 {

commit a4072cdfa9fe79adcd41320355847e77de22baf0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Dec 11 13:32:20 2019 +0900

    ASoC: soc-core: tidyup for CONFIG_DEBUG_FS
    
    soc-core.c has 2 #ifdef CONFIG_DEBUG_FS, but we can merge these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87d0cvbhyj.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 51a404fb89e2..3eb874c4a340 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -45,11 +45,6 @@
 
 #define NAME_SIZE	32
 
-#ifdef CONFIG_DEBUG_FS
-struct dentry *snd_soc_debugfs_root;
-EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);
-#endif
-
 static DEFINE_MUTEX(client_mutex);
 static LIST_HEAD(component_list);
 static LIST_HEAD(unbind_card_list);
@@ -133,6 +128,9 @@ static const struct attribute_group *soc_dev_attr_groups[] = {
 };
 
 #ifdef CONFIG_DEBUG_FS
+struct dentry *snd_soc_debugfs_root;
+EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);
+
 static void soc_init_component_debugfs(struct snd_soc_component *component)
 {
 	if (!component->card->debugfs_card_root)

commit 8a6a6a38f86885982891197840e7b8eccad5ef50
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Dec 11 13:32:05 2019 +0900

    ASoC: soc-core: tidyup for CONFIG_DMI
    
    soc-core.c has 2 #ifdef CONFIG_DMI, but we can merge these.
    OTOH, soc.h has dmi_longname, but it is needed if CONFIG_DMI was defined.
    In other words, It is not needed if CONFIG_DMI was not defined.
    This patch tidyup these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87eexbbhyy.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f8090bd2cf73..51a404fb89e2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -73,23 +73,6 @@ static int pmdown_time = 5000;
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
-#ifdef CONFIG_DMI
-/*
- * If a DMI filed contain strings in this blacklist (e.g.
- * "Type2 - Board Manufacturer" or "Type1 - TBD by OEM"), it will be taken
- * as invalid and dropped when setting the card long name from DMI info.
- */
-static const char * const dmi_blacklist[] = {
-	"To be filled by OEM",
-	"TBD by OEM",
-	"Default String",
-	"Board Manufacturer",
-	"Board Vendor Name",
-	"Board Product Name",
-	NULL,	/* terminator */
-};
-#endif
-
 static ssize_t pmdown_time_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -1607,6 +1590,21 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 EXPORT_SYMBOL_GPL(snd_soc_runtime_set_dai_fmt);
 
 #ifdef CONFIG_DMI
+/*
+ * If a DMI filed contain strings in this blacklist (e.g.
+ * "Type2 - Board Manufacturer" or "Type1 - TBD by OEM"), it will be taken
+ * as invalid and dropped when setting the card long name from DMI info.
+ */
+static const char * const dmi_blacklist[] = {
+	"To be filled by OEM",
+	"TBD by OEM",
+	"Default String",
+	"Board Manufacturer",
+	"Board Vendor Name",
+	"Board Product Name",
+	NULL,	/* terminator */
+};
+
 /*
  * Trim special characters, and replace '-' with '_' since '-' is used to
  * separate different DMI fields in the card long name. Only number and

commit 29d9fc7acacbb985daa1b4c662c619dc959a11b0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Dec 11 13:31:39 2019 +0900

    ASoC: soc-core: merge soc_set_name_prefix() and soc_set_of_name_prefix()
    
    soc_set_name_prefix() is calling soc_set_of_name_prefix().
    We don't need to separate these operation.
    This patch merges these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87fthrbhzo.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 750469acd5b4..f8090bd2cf73 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1206,22 +1206,12 @@ static int soc_init_pcm_runtime(struct snd_soc_card *card,
 	return ret;
 }
 
-static void soc_set_of_name_prefix(struct snd_soc_component *component)
-{
-	struct device_node *of_node = soc_component_to_node(component);
-	const char *str;
-	int ret;
-
-	ret = of_property_read_string(of_node, "sound-name-prefix", &str);
-	if (!ret)
-		component->name_prefix = str;
-}
-
 static void soc_set_name_prefix(struct snd_soc_card *card,
 				struct snd_soc_component *component)
 {
 	struct device_node *of_node = soc_component_to_node(component);
-	int i;
+	const char *str;
+	int ret, i;
 
 	for (i = 0; i < card->num_configs; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
@@ -1238,7 +1228,11 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 	 * If there is no configuration table or no match in the table,
 	 * check if a prefix is provided in the node
 	 */
-	soc_set_of_name_prefix(component);
+	ret = of_property_read_string(of_node, "sound-name-prefix", &str);
+	if (ret < 0)
+		return;
+
+	component->name_prefix = str;
 }
 
 static void soc_remove_component(struct snd_soc_component *component,

commit 2acf6ce2c25fb71a56ad35fcb9a63c19b20a4f4e
Merge: 2aae447a4c10 4e64ba3fd181
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Dec 10 13:27:14 2019 +0000

    Merge branch 'for-5.5' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-5.6

commit aec3ff99ce4a02d9bbe8b7311136edc69bdb739d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:52 2019 +0900

    ASoC: soc-core: soc_set_name_prefix(): get component device_node at out of loop
    
    Component device_node is not related to codec_conf loop at
    soc_set_name_prefix().
    This patch moves it to out of loop.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87v9qpxbkj.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a483f6fc50a0..f662d677229b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1209,11 +1209,11 @@ static void soc_set_of_name_prefix(struct snd_soc_component *component)
 static void soc_set_name_prefix(struct snd_soc_card *card,
 				struct snd_soc_component *component)
 {
+	struct device_node *of_node = soc_component_to_node(component);
 	int i;
 
 	for (i = 0; i < card->num_configs; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
-		struct device_node *of_node = soc_component_to_node(component);
 
 		if (map->of_node && of_node != map->of_node)
 			continue;

commit 4702f99148dae94b00bcb7bbba6cd9ca01651e69
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:48 2019 +0900

    ASoC: soc-core: soc_set_name_prefix(): tidyup loop condition
    
    Current soc_set_name_prefix() for loop is checking both codec_conf
    pointer and its number
    
            for (...; i < card->num_configs && card->codec_conf; ...)
    
    But, if card->num_configs exists but card->codec_conf was NULL,
    it is just bug.
    This patch cleanups for loop condition.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87wob5xbkn.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d18e30ec5a12..a483f6fc50a0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1211,7 +1211,7 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 {
 	int i;
 
-	for (i = 0; i < card->num_configs && card->codec_conf; i++) {
+	for (i = 0; i < card->num_configs; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
 		struct device_node *of_node = soc_component_to_node(component);
 

commit eaffeefbd042a44ca31f60f299a27d899aa4ec26
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:44 2019 +0900

    ASoC: soc-core: rename soc_link_init() to soc_init_pcm_runtime()
    
    soc-core is using soc_link_init().
    It sounds like dai_link function, but it is for pcm_runtime.
    This patch renames soc_link_init() to soc_init_pcm_runtime().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87y2vlxbkr.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2af3df5d0d72..d18e30ec5a12 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1123,8 +1123,8 @@ static int soc_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 	return 0;
 }
 
-static int soc_link_init(struct snd_soc_card *card,
-			 struct snd_soc_pcm_runtime *rtd)
+static int soc_init_pcm_runtime(struct snd_soc_card *card,
+				struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_dai_link *dai_link = rtd->dai_link;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
@@ -1984,7 +1984,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 	}
 
 	for_each_card_rtds(card, rtd) {
-		ret = soc_link_init(card, rtd);
+		ret = soc_init_pcm_runtime(card, rtd);
 		if (ret < 0)
 			goto probe_end;
 	}

commit 626c2e57a33a7565af03b2eb95989c43be651a03
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:40 2019 +0900

    ASoC: soc-core: add missing return value check for soc_link_init()
    
    soc_link_init() returns error code, but snd_soc_bind_card()
    is not cheking it.
    This patch adds missing return value check for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87zhg1xbkv.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 04cb69072f80..2af3df5d0d72 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1983,8 +1983,11 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 		goto probe_end;
 	}
 
-	for_each_card_rtds(card, rtd)
-		soc_link_init(card, rtd);
+	for_each_card_rtds(card, rtd) {
+		ret = soc_link_init(card, rtd);
+		if (ret < 0)
+			goto probe_end;
+	}
 
 	snd_soc_dapm_link_dai_widgets(card);
 	snd_soc_dapm_connect_dai_link_widgets(card);

commit 46496acbe1c43cd26f5515b51b5d3c46a97d785d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:36 2019 +0900

    ASoC: soc-core: move soc_link_init()
    
    This patch moves soc_link_init() to upper side.
    This is prepare for its cleanup.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/871rtdyq5g.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 81164b54632a..04cb69072f80 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1123,6 +1123,78 @@ static int soc_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 	return 0;
 }
 
+static int soc_link_init(struct snd_soc_card *card,
+			 struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *component;
+	int ret, num;
+
+	/* set default power off timeout */
+	rtd->pmdown_time = pmdown_time;
+
+	/* do machine specific initialization */
+	if (dai_link->init) {
+		ret = dai_link->init(rtd);
+		if (ret < 0) {
+			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
+				dai_link->name, ret);
+			return ret;
+		}
+	}
+
+	if (dai_link->dai_fmt) {
+		ret = snd_soc_runtime_set_dai_fmt(rtd, dai_link->dai_fmt);
+		if (ret)
+			return ret;
+	}
+
+	/* add DPCM sysfs entries */
+	soc_dpcm_debugfs_add(rtd);
+
+	num = rtd->num;
+
+	/*
+	 * most drivers will register their PCMs using DAI link ordering but
+	 * topology based drivers can use the DAI link id field to set PCM
+	 * device number and then use rtd + a base offset of the BEs.
+	 */
+	for_each_rtd_components(rtd, rtdcom, component) {
+		if (!component->driver->use_dai_pcm_id)
+			continue;
+
+		if (rtd->dai_link->no_pcm)
+			num += component->driver->be_pcm_base;
+		else
+			num = rtd->dai_link->id;
+	}
+
+	/* create compress_device if possible */
+	ret = snd_soc_dai_compress_new(cpu_dai, rtd, num);
+	if (ret != -ENOTSUPP) {
+		if (ret < 0)
+			dev_err(card->dev, "ASoC: can't create compress %s\n",
+				dai_link->stream_name);
+		return ret;
+	}
+
+	/* create the pcm */
+	ret = soc_new_pcm(rtd, num);
+	if (ret < 0) {
+		dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
+			dai_link->stream_name, ret);
+		return ret;
+	}
+	ret = soc_dai_pcm_new(&cpu_dai, 1, rtd);
+	if (ret < 0)
+		return ret;
+	ret = soc_dai_pcm_new(rtd->codec_dais,
+			      rtd->num_codecs, rtd);
+	return ret;
+}
+
 static void soc_set_of_name_prefix(struct snd_soc_component *component)
 {
 	struct device_node *of_node = soc_component_to_node(component);
@@ -1400,78 +1472,6 @@ static int soc_probe_link_components(struct snd_soc_card *card)
 	return 0;
 }
 
-static int soc_link_init(struct snd_soc_card *card,
-			 struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_dai_link *dai_link = rtd->dai_link;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_rtdcom_list *rtdcom;
-	struct snd_soc_component *component;
-	int ret, num;
-
-	/* set default power off timeout */
-	rtd->pmdown_time = pmdown_time;
-
-	/* do machine specific initialization */
-	if (dai_link->init) {
-		ret = dai_link->init(rtd);
-		if (ret < 0) {
-			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
-				dai_link->name, ret);
-			return ret;
-		}
-	}
-
-	if (dai_link->dai_fmt) {
-		ret = snd_soc_runtime_set_dai_fmt(rtd, dai_link->dai_fmt);
-		if (ret)
-			return ret;
-	}
-
-	/* add DPCM sysfs entries */
-	soc_dpcm_debugfs_add(rtd);
-
-	num = rtd->num;
-
-	/*
-	 * most drivers will register their PCMs using DAI link ordering but
-	 * topology based drivers can use the DAI link id field to set PCM
-	 * device number and then use rtd + a base offset of the BEs.
-	 */
-	for_each_rtd_components(rtd, rtdcom, component) {
-		if (!component->driver->use_dai_pcm_id)
-			continue;
-
-		if (rtd->dai_link->no_pcm)
-			num += component->driver->be_pcm_base;
-		else
-			num = rtd->dai_link->id;
-	}
-
-	/* create compress_device if possible */
-	ret = snd_soc_dai_compress_new(cpu_dai, rtd, num);
-	if (ret != -ENOTSUPP) {
-		if (ret < 0)
-			dev_err(card->dev, "ASoC: can't create compress %s\n",
-					 dai_link->stream_name);
-		return ret;
-	}
-
-	/* create the pcm */
-	ret = soc_new_pcm(rtd, num);
-	if (ret < 0) {
-		dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
-			dai_link->stream_name, ret);
-		return ret;
-	}
-	ret = soc_dai_pcm_new(&cpu_dai, 1, rtd);
-	if (ret < 0)
-		return ret;
-	ret = soc_dai_pcm_new(rtd->codec_dais,
-			      rtd->num_codecs, rtd);
-	return ret;
-}
-
 static void soc_unbind_aux_dev(struct snd_soc_card *card)
 {
 	struct snd_soc_component *component, *_component;

commit bfa0dd89536026e17b074eb2c42089f3455ea1a3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:32 2019 +0900

    ASoC: soc-core: rename soc_link_dai_pcm_new() to soc_dai_pcm_new()
    
    soc_link_dai_pcm_new() sounds like dai_link function,
    but it is not related to it.
    This patch rename soc_link_dai_pcm_new() to soc_dai_pcm_new().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/8736dtyq5j.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8ace5f5b251c..81164b54632a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1102,8 +1102,8 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_pcm_runtime);
 
-static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
-				struct snd_soc_pcm_runtime *rtd)
+static int soc_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
+			   struct snd_soc_pcm_runtime *rtd)
 {
 	int i, ret = 0;
 
@@ -1464,11 +1464,11 @@ static int soc_link_init(struct snd_soc_card *card,
 			dai_link->stream_name, ret);
 		return ret;
 	}
-	ret = soc_link_dai_pcm_new(&cpu_dai, 1, rtd);
+	ret = soc_dai_pcm_new(&cpu_dai, 1, rtd);
 	if (ret < 0)
 		return ret;
-	ret = soc_link_dai_pcm_new(rtd->codec_dais,
-				   rtd->num_codecs, rtd);
+	ret = soc_dai_pcm_new(rtd->codec_dais,
+			      rtd->num_codecs, rtd);
 	return ret;
 }
 

commit 9e9c70a5dd0194f6a30a04d96dd8c1f6ff44f6c4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:27 2019 +0900

    ASoC: soc-core: move soc_link_dai_pcm_new()
    
    This patch moves soc_link_dai_pcm_new() to upper side.
    This is prepare for its cleanup.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/874ky9yq5o.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f82d521306b7..8ace5f5b251c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1102,6 +1102,27 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_pcm_runtime);
 
+static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
+				struct snd_soc_pcm_runtime *rtd)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < num_dais; ++i) {
+		struct snd_soc_dai_driver *drv = dais[i]->driver;
+
+		if (drv->pcm_new)
+			ret = drv->pcm_new(rtd, dais[i]);
+		if (ret < 0) {
+			dev_err(dais[i]->dev,
+				"ASoC: Failed to bind %s with pcm device\n",
+				dais[i]->name);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static void soc_set_of_name_prefix(struct snd_soc_component *component)
 {
 	struct device_node *of_node = soc_component_to_node(component);
@@ -1379,27 +1400,6 @@ static int soc_probe_link_components(struct snd_soc_card *card)
 	return 0;
 }
 
-static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
-				struct snd_soc_pcm_runtime *rtd)
-{
-	int i, ret = 0;
-
-	for (i = 0; i < num_dais; ++i) {
-		struct snd_soc_dai_driver *drv = dais[i]->driver;
-
-		if (drv->pcm_new)
-			ret = drv->pcm_new(rtd, dais[i]);
-		if (ret < 0) {
-			dev_err(dais[i]->dev,
-				"ASoC: Failed to bind %s with pcm device\n",
-				dais[i]->name);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
 static int soc_link_init(struct snd_soc_card *card,
 			 struct snd_soc_pcm_runtime *rtd)
 {

commit 50cd9b5317d5593d0a33f4227f56ddcc1bf66604
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:23 2019 +0900

    ASoC: soc-core: rename snd_soc_remove_dai_link() to snd_soc_remove_pcm_runtime()
    
    Now soc-core and soc-topology is using snd_soc_remove_dai_link().
    It removes pcm_runtime (= rtd) and disconnect it from card.
    The purpose is removing pcm_runtime, not dai_link.
    This patch renames function name.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/875zipyq5s.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index af9da991d99e..f82d521306b7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -998,33 +998,26 @@ static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 }
 
 /**
- * snd_soc_remove_dai_link - Remove a DAI link from the list
- * @card: The ASoC card that owns the link
- * @dai_link: The DAI link to remove
+ * snd_soc_remove_pcm_runtime - Remove a pcm_runtime from card
+ * @card: The ASoC card to which the pcm_runtime has
+ * @rtd: The pcm_runtime to remove
  *
- * This function removes a DAI link from the ASoC card's link list.
- *
- * For DAI links previously added by topology, topology should
- * remove them by using the dobj embedded in the link.
+ * This function removes a pcm_runtime from the ASoC card.
  */
-void snd_soc_remove_dai_link(struct snd_soc_card *card,
-			     struct snd_soc_dai_link *dai_link)
+void snd_soc_remove_pcm_runtime(struct snd_soc_card *card,
+				struct snd_soc_pcm_runtime *rtd)
 {
-	struct snd_soc_pcm_runtime *rtd;
-
 	lockdep_assert_held(&client_mutex);
 
 	/*
 	 * Notify the machine driver for extra destruction
 	 */
 	if (card->remove_dai_link)
-		card->remove_dai_link(card, dai_link);
+		card->remove_dai_link(card, rtd->dai_link);
 
-	rtd = snd_soc_get_pcm_runtime(card, dai_link);
-	if (rtd)
-		soc_free_pcm_runtime(rtd);
+	soc_free_pcm_runtime(rtd);
 }
-EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
+EXPORT_SYMBOL_GPL(snd_soc_remove_pcm_runtime);
 
 /**
  * snd_soc_add_pcm_runtime - Add a pcm_runtime dynamically via dai_link
@@ -1104,7 +1097,7 @@ int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
 	return 0;
 
 _err_defer:
-	soc_free_pcm_runtime(rtd);
+	snd_soc_remove_pcm_runtime(card, rtd);
 	return -EPROBE_DEFER;
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_pcm_runtime);
@@ -1871,7 +1864,7 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card,
 	soc_remove_link_components(card);
 
 	for_each_card_rtds_safe(card, rtd, n)
-		snd_soc_remove_dai_link(card, rtd->dai_link);
+		snd_soc_remove_pcm_runtime(card, rtd);
 
 	/* remove auxiliary devices */
 	soc_remove_aux_devices(card);

commit 0c04800424c42ec3fbe87422d3e04b5c978fc177
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:19 2019 +0900

    ASoC: soc-core: rename snd_soc_add_dai_link() to snd_soc_add_pcm_runtime()
    
    Now soc-core and soc-topology is using snd_soc_add_dai_link().
    The abstract of this function is "create pcm_runtime from
    dai_link information and connect it to card".
    Thus, "add dai_link" is wrong/confusable naming.
    This patch renames function name.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/877e35yq5w.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bf5bbb1f3cdb..af9da991d99e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1027,18 +1027,18 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
 
 /**
- * snd_soc_add_dai_link - Add a DAI link dynamically
- * @card: The ASoC card to which the DAI link is added
- * @dai_link: The new DAI link to add
+ * snd_soc_add_pcm_runtime - Add a pcm_runtime dynamically via dai_link
+ * @card: The ASoC card to which the pcm_runtime is added
+ * @dai_link: The DAI link to find pcm_runtime
  *
- * This function adds a DAI link to the ASoC card's link list.
+ * This function adds a pcm_runtime ASoC card by using dai_link.
  *
- * Note: Topology can use this API to add DAI links when probing the
+ * Note: Topology can use this API to add pcm_runtime when probing the
  * topology component. And machine drivers can still define static
  * DAI links in dai_link array.
  */
-int snd_soc_add_dai_link(struct snd_soc_card *card,
-			 struct snd_soc_dai_link *dai_link)
+int snd_soc_add_pcm_runtime(struct snd_soc_card *card,
+			    struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link_component *codec, *platform;
@@ -1107,7 +1107,7 @@ int snd_soc_add_dai_link(struct snd_soc_card *card,
 	soc_free_pcm_runtime(rtd);
 	return -EPROBE_DEFER;
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_dai_link);
+EXPORT_SYMBOL_GPL(snd_soc_add_pcm_runtime);
 
 static void soc_set_of_name_prefix(struct snd_soc_component *component)
 {
@@ -1929,7 +1929,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 	/* add predefined DAI links to the list */
 	card->num_rtd = 0;
 	for_each_card_prelinks(card, i, dai_link) {
-		ret = snd_soc_add_dai_link(card, dai_link);
+		ret = snd_soc_add_pcm_runtime(card, dai_link);
 		if (ret < 0)
 			goto probe_end;
 	}

commit d6f31e0e6d09594717ed21c7c9238d9fbdb30ccb
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:14 2019 +0900

    ASoC: soc-core: move snd_soc_find_dai_link()
    
    snd_soc_find_dai_link() is soc-topology specific function.
    We don't need to have it at soc-core.
    This patch moves it to soc-topology.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/878snlyq61.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9ee7d5d118c0..bf5bbb1f3cdb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -901,50 +901,6 @@ struct snd_soc_dai *snd_soc_find_dai(
 }
 EXPORT_SYMBOL_GPL(snd_soc_find_dai);
 
-/**
- * snd_soc_find_dai_link - Find a DAI link
- *
- * @card: soc card
- * @id: DAI link ID to match
- * @name: DAI link name to match, optional
- * @stream_name: DAI link stream name to match, optional
- *
- * This function will search all existing DAI links of the soc card to
- * find the link of the same ID. Since DAI links may not have their
- * unique ID, so name and stream name should also match if being
- * specified.
- *
- * Return: pointer of DAI link, or NULL if not found.
- */
-struct snd_soc_dai_link *snd_soc_find_dai_link(struct snd_soc_card *card,
-					       int id, const char *name,
-					       const char *stream_name)
-{
-	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_dai_link *link;
-
-	lockdep_assert_held(&client_mutex);
-
-	for_each_card_rtds(card, rtd) {
-		link = rtd->dai_link;
-
-		if (link->id != id)
-			continue;
-
-		if (name && (!link->name || strcmp(name, link->name)))
-			continue;
-
-		if (stream_name && (!link->stream_name
-			|| strcmp(stream_name, link->stream_name)))
-			continue;
-
-		return link;
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_find_dai_link);
-
 static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 				     struct snd_soc_dai_link *link)
 {

commit 4468189ff307f294491628a49702a04de22bffb8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:08 2019 +0900

    ASoC: soc-core: find rtd via dai_link pointer at snd_soc_get_pcm_runtime()
    
    Current snd_soc_get_pcm_runtime() is finding rtd by checking dai_link
    name. But, it is strange and waste of CPU power, because its user want
    to get from rtd from dai_link, not from dai_link name.
    This patch find rtd via dai_link pointer instead of its name.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87a781yq67.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f215a37fd3d6..9ee7d5d118c0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -393,15 +393,15 @@ static const struct snd_soc_ops null_snd_soc_ops;
 
 struct snd_soc_pcm_runtime
 *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
-			 const char *dai_link)
+			 struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
 
 	for_each_card_rtds(card, rtd) {
-		if (!strcmp(rtd->dai_link->name, dai_link))
+		if (rtd->dai_link == dai_link)
 			return rtd;
 	}
-	dev_dbg(card->dev, "ASoC: failed to find rtd %s\n", dai_link);
+	dev_dbg(card->dev, "ASoC: failed to find rtd %s\n", dai_link->name);
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
@@ -1064,7 +1064,7 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 	if (card->remove_dai_link)
 		card->remove_dai_link(card, dai_link);
 
-	rtd = snd_soc_get_pcm_runtime(card, dai_link->name);
+	rtd = snd_soc_get_pcm_runtime(card, dai_link);
 	if (rtd)
 		soc_free_pcm_runtime(rtd);
 }

commit 94def8ea66be2ea9f6aac61549b6b5874bca6235
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:34:01 2019 +0900

    ASoC: soc-core: move snd_soc_get_pcm_runtime()
    
    This patch moves snd_soc_get_pcm_runtime() next to
    snd_soc_get_dai_substream().
    This is prepare for snd_soc_get_pcm_runtime() cleanup.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87blshyq6e.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 16265d0e48de..f215a37fd3d6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -391,6 +391,21 @@ EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
 
 static const struct snd_soc_ops null_snd_soc_ops;
 
+struct snd_soc_pcm_runtime
+*snd_soc_get_pcm_runtime(struct snd_soc_card *card,
+			 const char *dai_link)
+{
+	struct snd_soc_pcm_runtime *rtd;
+
+	for_each_card_rtds(card, rtd) {
+		if (!strcmp(rtd->dai_link->name, dai_link))
+			return rtd;
+	}
+	dev_dbg(card->dev, "ASoC: failed to find rtd %s\n", dai_link);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
+
 static void soc_release_rtd_dev(struct device *dev)
 {
 	/* "dev" means "rtd->dev" */
@@ -491,20 +506,6 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	return NULL;
 }
 
-struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
-		const char *dai_link)
-{
-	struct snd_soc_pcm_runtime *rtd;
-
-	for_each_card_rtds(card, rtd) {
-		if (!strcmp(rtd->dai_link->name, dai_link))
-			return rtd;
-	}
-	dev_dbg(card->dev, "ASoC: failed to find rtd %s\n", dai_link);
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
-
 static void snd_soc_flush_all_delayed_work(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;

commit 8babfb7030573f7338b141d038c2094b7bb95034
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:33:55 2019 +0900

    ASoC: soc-core: remove snd_soc_get_dai_substream()
    
    No driver is using snd_soc_get_dai_substream(),
    and snd_soc_get_pcm_runtime() is enough for such purpose.
    We can revival it if it was needed in the future.
    Let's remove unused function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87d0cxyq6k.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0d436a2560e4..16265d0e48de 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -389,21 +389,6 @@ struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
 
-struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
-		const char *dai_link, int stream)
-{
-	struct snd_soc_pcm_runtime *rtd;
-
-	for_each_card_rtds(card, rtd) {
-		if (rtd->dai_link->no_pcm &&
-			!strcmp(rtd->dai_link->name, dai_link))
-			return rtd->pcm->streams[stream].substream;
-	}
-	dev_dbg(card->dev, "ASoC: failed to find dai link %s\n", dai_link);
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_dai_substream);
-
 static const struct snd_soc_ops null_snd_soc_ops;
 
 static void soc_release_rtd_dev(struct device *dev)

commit b553bd238da23041bf39110e58ee80f8efe034e0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:33:50 2019 +0900

    ASoC: soc-core: remove snd_soc_disconnect_sync()
    
    Sound card disconnecting operation was needed when "sound driver" was
    unbinded without unbinding "sound card".
    In such case, sound driver should be stopped even though it was
    playbacking/capturing. Otherwise clock open/close counter mismatch happen.
    
    One headache was that we can't skip unbind in error case because unbind
    operation doesn't check return value from each drivers.
    snd_soc_disconnect_sync() was added for these purpose, and Renesas
    sound card only is used it.
    
    But now, ALSA SoC automatically disconnect sound card when sound driver
    was unbinded. Thus, snd_soc_disconnect_sync() is no longer needed.
    This patch removes it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87eexdyq6p.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9483bfe17260..0d436a2560e4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1444,18 +1444,6 @@ static int soc_probe_link_components(struct snd_soc_card *card)
 	return 0;
 }
 
-void snd_soc_disconnect_sync(struct device *dev)
-{
-	struct snd_soc_component *component =
-			snd_soc_lookup_component(dev, NULL);
-
-	if (!component || !component->card)
-		return;
-
-	snd_card_disconnect_sync(component->card->snd_card);
-}
-EXPORT_SYMBOL_GPL(snd_soc_disconnect_sync);
-
 static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 				struct snd_soc_pcm_runtime *rtd)
 {

commit cc73390008c9a47c49ad73c459b5590fd4c4c890
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 10 09:33:40 2019 +0900

    ASoC: soc-core: remove dai_link_list
    
    ASoC is using many lists.
    Now, used dai_link is listed to card as dai_link_list.
    
            [card]->[dai_link]->[dai_link]->...
    
    BTW, this "dai_link" is used to create "rtd".
    And this rtd is listed to card as rtd_list.
    
            [card]->[rtd]->[rtd]->...
    
    Here, each rtd has dai_link. This means, we can track all dai_link via
    rtd list. This patch removes card dai_link_list, and uses rtd_list
    instead of it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87fthtyq6z.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1a362a799dbb..9483bfe17260 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -934,11 +934,14 @@ struct snd_soc_dai_link *snd_soc_find_dai_link(struct snd_soc_card *card,
 					       int id, const char *name,
 					       const char *stream_name)
 {
+	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link *link;
 
 	lockdep_assert_held(&client_mutex);
 
-	for_each_card_links(card, link) {
+	for_each_card_rtds(card, rtd) {
+		link = rtd->dai_link;
+
 		if (link->id != id)
 			continue;
 
@@ -1075,8 +1078,6 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 	if (card->remove_dai_link)
 		card->remove_dai_link(card, dai_link);
 
-	list_del(&dai_link->list);
-
 	rtd = snd_soc_get_pcm_runtime(card, dai_link->name);
 	if (rtd)
 		soc_free_pcm_runtime(rtd);
@@ -1158,9 +1159,6 @@ int snd_soc_add_dai_link(struct snd_soc_card *card,
 		}
 	}
 
-	/* see for_each_card_links */
-	list_add_tail(&dai_link->list, &card->dai_link_list);
-
 	return 0;
 
 _err_defer:
@@ -1931,7 +1929,7 @@ static void __soc_setup_card_name(char *name, int len,
 static void soc_cleanup_card_resources(struct snd_soc_card *card,
 				       int card_probed)
 {
-	struct snd_soc_dai_link *link, *_link;
+	struct snd_soc_pcm_runtime *rtd, *n;
 
 	if (card->snd_card)
 		snd_card_disconnect_sync(card->snd_card);
@@ -1942,8 +1940,8 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card,
 	soc_remove_link_dais(card);
 	soc_remove_link_components(card);
 
-	for_each_card_links_safe(card, link, _link)
-		snd_soc_remove_dai_link(card, link);
+	for_each_card_rtds_safe(card, rtd, n)
+		snd_soc_remove_dai_link(card, rtd->dai_link);
 
 	/* remove auxiliary devices */
 	soc_remove_aux_devices(card);
@@ -2393,7 +2391,6 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	INIT_LIST_HEAD(&card->aux_comp_list);
 	INIT_LIST_HEAD(&card->component_dev_list);
 	INIT_LIST_HEAD(&card->list);
-	INIT_LIST_HEAD(&card->dai_link_list);
 	INIT_LIST_HEAD(&card->rtd_list);
 	INIT_LIST_HEAD(&card->dapm_dirty);
 	INIT_LIST_HEAD(&card->dobj_list);

commit bc9a665581b3c6c82c9220a47f6573b49ce2df0b
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Dec 8 20:37:04 2019 -0800

    ASoC: fix soc-core.c kernel-doc warning
    
    Fix a kernel-doc warning in soc-core.c by adding notation for
    @legacy_dai_naming.
    
    ../sound/soc/soc-core.c:2509: warning: Function parameter or member 'legacy_dai_naming' not described in 'snd_soc_register_dai'
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: alsa-devel@alsa-project.org
    Link: https://lore.kernel.org/r/2215ee04-e870-5eea-a00c-9a5caf06faae@infradead.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 062653ab03a3..1a362a799dbb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2498,6 +2498,8 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
  *
  * @component: The component the DAIs are registered for
  * @dai_drv: DAI driver to use for the DAI
+ * @legacy_dai_naming: if %true, use legacy single-name format;
+ * 	if %false, use multiple-name format;
  *
  * Topology can use this API to register DAIs when probing a component.
  * These DAIs's widgets will be freed in the card cleanup and the DAIs

commit 9c9b65203492927cc4ae419e9601e837ecbd889e
Author: Curtis Malainey <cujomalainey@chromium.org>
Date:   Wed Nov 27 17:13:58 2019 -0800

    ASoC: core: only flush inited work during free
    
    There are many paths to soc_free_pcm_runtime which can both have and
    have not yet inited the workqueue yet. When we flush the queue when we
    have not yet inited the queue we cause warnings to be printed.
    
    An example is soc_cleanup_card_resources which is called by
    snd_soc_bind_card which has multiple failure points before and after
    soc_link_init -> soc_new_pcm which is where the queue is inited.
    
    Signed-off-by: Curtis Malainey <cujomalainey@chromium.org>
    Link: https://lore.kernel.org/r/20191128011358.39234-1-cujomalainey@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0e2e628302f1..1c84ff1a5bf9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -419,7 +419,8 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 
 	list_del(&rtd->list);
 
-	flush_delayed_work(&rtd->delayed_work);
+	if (delayed_work_pending(&rtd->delayed_work))
+		flush_delayed_work(&rtd->delayed_work);
 	snd_soc_pcm_component_free(rtd);
 
 	/*

commit 4bf2e385aa59c2fae5f880aa25cfd2b470109093
Author: Curtis Malainey <cujomalainey@chromium.org>
Date:   Tue Dec 3 09:30:07 2019 -0800

    ASoC: core: Init pcm runtime work early to avoid warnings
    
    There are cases where we fail before we reach soc_new_pcm which would
    init the workqueue. When we fail we attempt to flush the queue which
    generates warnings from the workqueue subsystem when we have not inited
    the queue. Solution is to use a proxy function to get around this issue.
    
    Signed-off-by: Curtis Malainey <cujomalainey@chromium.org>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20191203173007.46504-1-cujomalainey@chromium.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 062653ab03a3..0e2e628302f1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -435,6 +435,15 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 	device_unregister(rtd->dev);
 }
 
+static void close_delayed_work(struct work_struct *work) {
+	struct snd_soc_pcm_runtime *rtd =
+			container_of(work, struct snd_soc_pcm_runtime,
+				     delayed_work.work);
+
+	if (rtd->close_delayed_work_func)
+		rtd->close_delayed_work_func(rtd);
+}
+
 static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	struct snd_soc_card *card, struct snd_soc_dai_link *dai_link)
 {
@@ -470,6 +479,7 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 
 	rtd->dev = dev;
 	dev_set_drvdata(dev, rtd);
+	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
 
 	/*
 	 * for rtd->codec_dais

commit 39870b0dec68ed7dd814beb697e541670975c7d8
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Nov 20 18:44:35 2019 +0100

    ASoC: DMI long name - avoid to add board name if matches with product name
    
    Current code:
    
      LENOVO-20QE000VMC-ThinkPadX1Carbon7th-20QE000VMC
    
    With the patch:
    
      LENOVO-20QE000VMC-ThinkPadX1Carbon7th
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Link: https://lore.kernel.org/r/20191120174435.30920-2-perex@perex.cz
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a1f4d64a0a18..062653ab03a3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1798,7 +1798,8 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 
 	board = dmi_get_system_info(DMI_BOARD_NAME);
 	if (board && is_dmi_valid(board)) {
-		append_dmi_string(card, board);
+		if (!product || strcasecmp(board, product))
+			append_dmi_string(card, board);
 	} else if (!product) {
 		/* fall back to using legacy name */
 		dev_warn(card->dev, "ASoC: no DMI board/product name!\n");

commit 4e01e5dbba96f731119f3f1a6bf51b54c98c5940
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Nov 20 18:44:34 2019 +0100

    ASoC: improve the DMI long card code in asoc-core
    
    Add append_dmi_string() function and make the code more readable.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20191120174435.30920-1-perex@perex.cz
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cc0ef0fcc005..a1f4d64a0a18 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1718,6 +1718,23 @@ static int is_dmi_valid(const char *field)
 	return 1;
 }
 
+/*
+ * Append a string to card->dmi_longname with character cleanups.
+ */
+static void append_dmi_string(struct snd_soc_card *card, const char *str)
+{
+	char *dst = card->dmi_longname;
+	size_t dst_len = sizeof(card->dmi_longname);
+	size_t len;
+
+	len = strlen(dst);
+	snprintf(dst + len, dst_len - len, "-%s", str);
+
+	len++;	/* skip the separator "-" */
+	if (len < dst_len)
+		cleanup_dmi_name(dst + len);
+}
+
 /**
  * snd_soc_set_dmi_name() - Register DMI names to card
  * @card: The card to register DMI names
@@ -1752,61 +1769,36 @@ static int is_dmi_valid(const char *field)
 int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 {
 	const char *vendor, *product, *product_version, *board;
-	size_t longname_buf_size = sizeof(card->snd_card->longname);
-	size_t len;
 
 	if (card->long_name)
 		return 0; /* long name already set by driver or from DMI */
 
-	/* make up dmi long name as: vendor.product.version.board */
+	/* make up dmi long name as: vendor-product-version-board */
 	vendor = dmi_get_system_info(DMI_BOARD_VENDOR);
 	if (!vendor || !is_dmi_valid(vendor)) {
 		dev_warn(card->dev, "ASoC: no DMI vendor name!\n");
 		return 0;
 	}
 
-	snprintf(card->dmi_longname, sizeof(card->snd_card->longname),
-			 "%s", vendor);
+	snprintf(card->dmi_longname, sizeof(card->dmi_longname), "%s", vendor);
 	cleanup_dmi_name(card->dmi_longname);
 
 	product = dmi_get_system_info(DMI_PRODUCT_NAME);
 	if (product && is_dmi_valid(product)) {
-		len = strlen(card->dmi_longname);
-		snprintf(card->dmi_longname + len,
-			 longname_buf_size - len,
-			 "-%s", product);
-
-		len++;	/* skip the separator "-" */
-		if (len < longname_buf_size)
-			cleanup_dmi_name(card->dmi_longname + len);
+		append_dmi_string(card, product);
 
 		/*
 		 * some vendors like Lenovo may only put a self-explanatory
 		 * name in the product version field
 		 */
 		product_version = dmi_get_system_info(DMI_PRODUCT_VERSION);
-		if (product_version && is_dmi_valid(product_version)) {
-			len = strlen(card->dmi_longname);
-			snprintf(card->dmi_longname + len,
-				 longname_buf_size - len,
-				 "-%s", product_version);
-
-			len++;
-			if (len < longname_buf_size)
-				cleanup_dmi_name(card->dmi_longname + len);
-		}
+		if (product_version && is_dmi_valid(product_version))
+			append_dmi_string(card, product_version);
 	}
 
 	board = dmi_get_system_info(DMI_BOARD_NAME);
 	if (board && is_dmi_valid(board)) {
-		len = strlen(card->dmi_longname);
-		snprintf(card->dmi_longname + len,
-			 longname_buf_size - len,
-			 "-%s", board);
-
-		len++;
-		if (len < longname_buf_size)
-			cleanup_dmi_name(card->dmi_longname + len);
+		append_dmi_string(card, board);
 	} else if (!product) {
 		/* fall back to using legacy name */
 		dev_warn(card->dev, "ASoC: no DMI board/product name!\n");
@@ -1814,16 +1806,8 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 	}
 
 	/* Add flavour to dmi long name */
-	if (flavour) {
-		len = strlen(card->dmi_longname);
-		snprintf(card->dmi_longname + len,
-			 longname_buf_size - len,
-			 "-%s", flavour);
-
-		len++;
-		if (len < longname_buf_size)
-			cleanup_dmi_name(card->dmi_longname + len);
-	}
+	if (flavour)
+		append_dmi_string(card, flavour);
 
 	/* set the card long name */
 	card->long_name = card->dmi_longname;

commit dc73d73aa7145f55412611f3eead1e85ae026785
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Nov 19 18:49:32 2019 +0100

    ASoC: add control components management
    
    This ASCII string can carry additional information about
    soundcard components or configuration. Add the possibility
    to set this string via the ASoC card.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Cc: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20191119174933.25526-1-perex@perex.cz
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e3a53ef1db04..cc0ef0fcc005 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2108,6 +2108,19 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 	soc_setup_card_name(card->snd_card->driver,
 			    card->driver_name, card->name, 1);
 
+	if (card->components) {
+		/* the current implementation of snd_component_add() accepts */
+		/* multiple components in the string separated by space, */
+		/* but the string collision (identical string) check might */
+		/* not work correctly */
+		ret = snd_component_add(card->snd_card, card->components);
+		if (ret < 0) {
+			dev_err(card->dev, "ASoC: %s snd_component_add() failed: %d\n",
+				card->name, ret);
+			goto probe_end;
+		}
+	}
+
 	if (card->late_probe) {
 		ret = card->late_probe(card);
 		if (ret < 0) {

commit 0ced7b050224b18ca73e38e7068f36be8e708c06
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 18 10:51:11 2019 +0900

    ASoC: soc-pcm: remove soc_pcm_private_free()
    
    soc-topology adds extra dai_link by using snd_soc_add_dai_link(),
    and removes it by snd_soc_romove_dai_link().
    
    This snd_soc_add/remove_dai_link() and/or its related
    functions are unbalanced before, and now, these are balance-uped.
    But, it finds the random operation issue, and it is reported by
    Pierre-Louis.
    
    When card was released, topology will call snd_soc_remove_dai_link()
    via (A).
    
            static void soc_cleanup_card_resources(struct snd_soc_card *card)
            {
                    struct snd_soc_dai_link *link, *_link;
    
                    /* This should be called before snd_card_free() */
            (A)     soc_remove_link_components(card);
    
                    /* free the ALSA card at first; this syncs with pending operations */
                    if (card->snd_card) {
            (B)             snd_card_free(card->snd_card);
                            card->snd_card = NULL;
                    }
    
                    /* remove and free each DAI */
            (X)     soc_remove_link_dais(card);
    
                    for_each_card_links_safe(card, link, _link)
            (C)             snd_soc_remove_dai_link(card, link);
    
                    ...
            }
    
    At (A), topology calls snd_soc_remove_dai_link().
    Then topology rtd, and its related all data are freed.
    
    Next, (B) is called, and then, pcm->private_free = soc_pcm_private_free()
    is called.
    
            static void soc_pcm_private_free(struct snd_pcm *pcm)
            {
                    struct snd_soc_pcm_runtime *rtd = pcm->private_data;
    
                    /* need to sync the delayed work before releasing resources */
                    flush_delayed_work(&rtd->delayed_work);
                    snd_soc_pcm_component_free(rtd);
            }
    
    Here, it gets rtd via pcm->private_data.
    But, topology related rtd are already freed at (A).
    Normal sound card has no damage, becase it frees rtd at (C).
    
    These are finalizing rtd related data.
    Thus, these should be called when rtd was freed, not sound card
    was freed. It is very natural and understandable.
    
    In other words, pcm->private_free = soc_pcm_private_free()
    is no longer needed.
    
    Extra issue is that there is zero chance to call
    soc_remove_dai() for topology related dai at (X).
    Because (A) removes rtd connection from card too, and,
    (X) is based on card connected rtd.
    
    This means, (X) need to be called before (C) (= for normal sound)
    and (A) (= for topology).
    
    Now, I want to focus this patch which is the reason why
    snd_card_free() = (B) is located there.
    
            commit 4efda5f2130da033aeedc5b3205569893b910de2
            ("ASoC: Fix use-after-free at card unregistration")
    
    Original snd_card_free() was called last of this function.
    But moved to top to avoid use-after-free issue.
    The issue was happen at soc_pcm_free() which was pcm->private_free,
    today it is updated/renamed to soc_pcm_private_free().
    
    In other words, (B) need to be called before (C) (= for normal sound)
    and (A) (= for topology), because it needs (not yet freed) rtd.
    But, (A) need to be called before (B),
    because it needs card->snd_card pointer.
    
    If we call flush_delayed_work() and snd_soc_pcm_component_free()
    (= same as soc_pcm_private_free()) when rtd was freed (= (C), (A)),
    there is no reason to call snd_card_free() at top of this function.
    It can be called end of this function, again.
    
    But, in such case, it will likely break unbind again, as Takashi-san
    reported. When unbind is performed in a busy state, the code may
    release still-in-use resources.
    At least we need to call snd_card_disconnect_sync() at the first place.
    
    The final code will be...
    
            static void soc_cleanup_card_resources(struct snd_soc_card *card)
            {
                    struct snd_soc_dai_link *link, *_link;
    
                    if (card->snd_card)
            (Z)             snd_card_disconnect_sync(card->snd_card);
    
            (X)     soc_remove_link_dais(card);
            (A)     soc_remove_link_components(card);
    
                    for_each_card_links_safe(card, link, _link)
            (C)             snd_soc_remove_dai_link(card, link);
    
                    ...
                    if (card->snd_card) {
            (B)             snd_card_free(card->snd_card);
                            card->snd_card = NULL;
                    }
            }
    
    To avoid release still-in-use resources,
    call snd_card_disconnect_sync() at (Z).
    
    (X) is needed for both non-topology and topology.
    
        topology removes rtd via (A), and
    non topology removes rtd via (C).
    
    snd_card_free() is no longer related to use-after-free issue.
    Thus, locating (B) is no problem.
    
    Fixes: df95a16d2a9626 ("ASoC: soc-core: fix RIP warning on card removal")
    Fixes: bc7a9091e5b927 ("ASoC: soc-core: add soc_unbind_dai_link()")
    Reported-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/87o8xax88g.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 977a7bfad519..e3a53ef1db04 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -419,6 +419,9 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 
 	list_del(&rtd->list);
 
+	flush_delayed_work(&rtd->delayed_work);
+	snd_soc_pcm_component_free(rtd);
+
 	/*
 	 * we don't need to call kfree() for rtd->dev
 	 * see
@@ -1945,19 +1948,14 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card,
 {
 	struct snd_soc_dai_link *link, *_link;
 
-	/* This should be called before snd_card_free() */
-	soc_remove_link_components(card);
-
-	/* free the ALSA card at first; this syncs with pending operations */
-	if (card->snd_card) {
-		snd_card_free(card->snd_card);
-		card->snd_card = NULL;
-	}
+	if (card->snd_card)
+		snd_card_disconnect_sync(card->snd_card);
 
 	snd_soc_dapm_shutdown(card);
 
 	/* remove and free each DAI */
 	soc_remove_link_dais(card);
+	soc_remove_link_components(card);
 
 	for_each_card_links_safe(card, link, _link)
 		snd_soc_remove_dai_link(card, link);
@@ -1972,6 +1970,11 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card,
 	/* remove the card */
 	if (card_probed && card->remove)
 		card->remove(card);
+
+	if (card->snd_card) {
+		snd_card_free(card->snd_card);
+		card->snd_card = NULL;
+	}
 }
 
 static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)

commit ce21401c9d30e81824e864dc25824ebeb9690801
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 13 10:16:48 2019 +0900

    ASoC: soc-core: care card_probed at soc_cleanup_card_resources()
    
    soc_cleanup_card_resources() will call card->remove(), but it should be
    called if card->probe() or card->late_probe() are called.
    snd_soc_bind_card() might be error before calling
    card->probe() / card->late_probe().
    In that time, card->remove() will be called.
    This patch adds card_probed parameter to judge it.
    
    Fixes: bfce78a559655 ("ASoC: soc-core: tidyup soc_init_dai_link()")
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Link: https://lore.kernel.org/r/87o8xg4ltr.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a149697e705d..977a7bfad519 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1940,7 +1940,8 @@ static void __soc_setup_card_name(char *name, int len,
 	}
 }
 
-static void soc_cleanup_card_resources(struct snd_soc_card *card)
+static void soc_cleanup_card_resources(struct snd_soc_card *card,
+				       int card_probed)
 {
 	struct snd_soc_dai_link *link, *_link;
 
@@ -1969,17 +1970,19 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 	soc_cleanup_card_debugfs(card);
 
 	/* remove the card */
-	if (card->remove)
+	if (card_probed && card->remove)
 		card->remove(card);
 }
 
 static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 {
 	if (card->instantiated) {
+		int card_probed = 1;
+
 		card->instantiated = false;
 		snd_soc_flush_all_delayed_work(card);
 
-		soc_cleanup_card_resources(card);
+		soc_cleanup_card_resources(card, card_probed);
 		if (!unregister)
 			list_add(&card->list, &unbind_card_list);
 	} else {
@@ -1992,7 +1995,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link *dai_link;
-	int ret, i;
+	int ret, i, card_probed = 0;
 
 	mutex_lock(&client_mutex);
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
@@ -2044,6 +2047,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 		ret = card->probe(card);
 		if (ret < 0)
 			goto probe_end;
+		card_probed = 1;
 	}
 
 	/* probe all components used by DAI links on this card */
@@ -2109,6 +2113,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 			goto probe_end;
 		}
 	}
+	card_probed = 1;
 
 	snd_soc_dapm_new_widgets(card);
 
@@ -2138,7 +2143,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 
 probe_end:
 	if (ret < 0)
-		soc_cleanup_card_resources(card);
+		soc_cleanup_card_resources(card, card_probed);
 
 	mutex_unlock(&card->mutex);
 	mutex_unlock(&client_mutex);

commit 2cc1afcfc617b33b72e409360ba5dd7c3fc2492d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 13 10:16:34 2019 +0900

    ASoC: soc-core: move snd_soc_unbind_card() next to snd_soc_bind_card()
    
    To makes code readable, this patch moves snd_soc_unbind_card() next
    to snd_soc_bind_card().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87pnhw4lu5.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 216000ae3e20..a149697e705d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1973,6 +1973,21 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 		card->remove(card);
 }
 
+static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
+{
+	if (card->instantiated) {
+		card->instantiated = false;
+		snd_soc_flush_all_delayed_work(card);
+
+		soc_cleanup_card_resources(card);
+		if (!unregister)
+			list_add(&card->list, &unbind_card_list);
+	} else {
+		if (unregister)
+			list_del(&card->list);
+	}
+}
+
 static int snd_soc_bind_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
@@ -2387,21 +2402,6 @@ int snd_soc_register_card(struct snd_soc_card *card)
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_card);
 
-static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
-{
-	if (card->instantiated) {
-		card->instantiated = false;
-		snd_soc_flush_all_delayed_work(card);
-
-		soc_cleanup_card_resources(card);
-		if (!unregister)
-			list_add(&card->list, &unbind_card_list);
-	} else {
-		if (unregister)
-			list_del(&card->list);
-	}
-}
-
 /**
  * snd_soc_unregister_card - Unregister a card with the ASoC core
  *

commit 2a6f0892bda954dc2688b002060093ee0fe38528
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 13 10:16:29 2019 +0900

    ASoC: soc-core: call snd_soc_dapm_shutdown() at soc_cleanup_card_resources()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    snd_soc_bind_card() is calling snd_soc_dapm_init() for both
    card and component.
    Let's call paired snd_soc_dapm_shutdown() at paired
    soc_cleanup_card_resources().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87r22c4lub.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 92260a9569a2..216000ae3e20 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1953,6 +1953,8 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 		card->snd_card = NULL;
 	}
 
+	snd_soc_dapm_shutdown(card);
+
 	/* remove and free each DAI */
 	soc_remove_link_dais(card);
 
@@ -2389,7 +2391,6 @@ static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 {
 	if (card->instantiated) {
 		card->instantiated = false;
-		snd_soc_dapm_shutdown(card);
 		snd_soc_flush_all_delayed_work(card);
 
 		soc_cleanup_card_resources(card);

commit 74bd3f92d0d173fe4c0a12cf736c505ceb15576a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 6 10:08:06 2019 +0900

    ASoC: soc-core: tidyup soc_probe_aux_devices()
    
    snd_soc_bind_card() is calling many initialize functions
    for each card / link / dai / aux etc, etc, etc...
    When error happen, the message is indicated at snd_soc_bind_card(),
    not at each functions.
    But, only soc_probe_aux_devices() case is indicating error at functions,
    not at snd_soc_bind_card().
    It is not an issue, but unbalanced.
    
    This patch moves error message to snd_soc_bind_card().
    Also avoids deep-nested code.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87lfsthkw9.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f3d33a908fbc..92260a9569a2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1579,21 +1579,18 @@ static int soc_bind_aux_dev(struct snd_soc_card *card)
 
 static int soc_probe_aux_devices(struct snd_soc_card *card)
 {
-	struct snd_soc_component *comp;
+	struct snd_soc_component *component;
 	int order;
 	int ret;
 
 	for_each_comp_order(order) {
-		for_each_card_auxs(card, comp) {
-			if (comp->driver->probe_order == order) {
-				ret = soc_probe_component(card,	comp);
-				if (ret < 0) {
-					dev_err(card->dev,
-						"ASoC: failed to probe aux component %s %d\n",
-						comp->name, ret);
-					return ret;
-				}
-			}
+		for_each_card_auxs(card, component) {
+			if (component->driver->probe_order != order)
+				continue;
+
+			ret = soc_probe_component(card,	component);
+			if (ret < 0)
+				return ret;
 		}
 	}
 
@@ -2042,8 +2039,11 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 
 	/* probe auxiliary components */
 	ret = soc_probe_aux_devices(card);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(card->dev,
+			"ASoC: failed to probe aux component %d\n", ret);
 		goto probe_end;
+	}
 
 	/* probe all DAI links on this card */
 	ret = soc_probe_link_dais(card);

commit ed90c013a773b5f9e06089d0eed6714761152d14
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 6 10:07:56 2019 +0900

    ASoC: soc-core: merge snd_soc_bind_card() and snd_soc_instantiate_card()
    
    having both soc_bind_card() and snd_soc_instantiate_card() is
    very confusable. Let's merge these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87mud9hkwj.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 11cbd7915154..f3d33a908fbc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1974,7 +1974,7 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 		card->remove(card);
 }
 
-static int snd_soc_instantiate_card(struct snd_soc_card *card)
+static int snd_soc_bind_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link *dai_link;
@@ -2106,6 +2106,19 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	dapm_mark_endpoints_dirty(card);
 	snd_soc_dapm_sync(&card->dapm);
 
+	/* deactivate pins to sleep state */
+	for_each_card_rtds(card, rtd) {
+		struct snd_soc_dai *dai;
+
+		for_each_rtd_codec_dai(rtd, i, dai) {
+			if (!dai->active)
+				pinctrl_pm_select_sleep_state(dai->dev);
+		}
+
+		if (!rtd->cpu_dai->active)
+			pinctrl_pm_select_sleep_state(rtd->cpu_dai->dev);
+	}
+
 probe_end:
 	if (ret < 0)
 		soc_cleanup_card_resources(card);
@@ -2338,33 +2351,6 @@ int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
 
-static int snd_soc_bind_card(struct snd_soc_card *card)
-{
-	struct snd_soc_pcm_runtime *rtd;
-	int ret;
-
-	ret = snd_soc_instantiate_card(card);
-	if (ret != 0)
-		return ret;
-
-	/* deactivate pins to sleep state */
-	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-		struct snd_soc_dai *codec_dai;
-		int j;
-
-		for_each_rtd_codec_dai(rtd, j, codec_dai) {
-			if (!codec_dai->active)
-				pinctrl_pm_select_sleep_state(codec_dai->dev);
-		}
-
-		if (!cpu_dai->active)
-			pinctrl_pm_select_sleep_state(cpu_dai->dev);
-	}
-
-	return ret;
-}
-
 /**
  * snd_soc_register_card - Register a card with the ASoC core
  *

commit c6619b729814c855fc7bfa5a6936f5ea94d60dfd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 6 10:07:46 2019 +0900

    ASoC: soc-core: merge soc_remove_component() and soc_cleanup_component()
    
    having both soc_remove_component() and soc_cleanup_component() is
    very confusable. Let's merge these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87o8xphkwt.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d80d485f46d1..11cbd7915154 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1201,8 +1201,16 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 	soc_set_of_name_prefix(component);
 }
 
-static void soc_cleanup_component(struct snd_soc_component *component)
+static void soc_remove_component(struct snd_soc_component *component,
+				 int probed)
 {
+
+	if (!component->card)
+		return;
+
+	if (probed)
+		snd_soc_component_remove(component);
+
 	/* For framework level robustness */
 	snd_soc_component_set_jack(component, NULL, NULL);
 
@@ -1213,22 +1221,13 @@ static void soc_cleanup_component(struct snd_soc_component *component)
 	snd_soc_component_module_put_when_remove(component);
 }
 
-static void soc_remove_component(struct snd_soc_component *component)
-{
-	if (!component->card)
-		return;
-
-	snd_soc_component_remove(component);
-
-	soc_cleanup_component(component);
-}
-
 static int soc_probe_component(struct snd_soc_card *card,
 			       struct snd_soc_component *component)
 {
 	struct snd_soc_dapm_context *dapm =
 		snd_soc_component_get_dapm(component);
 	struct snd_soc_dai *dai;
+	int probed = 0;
 	int ret;
 
 	if (!strcmp(component->name, "snd-soc-dummy"))
@@ -1284,6 +1283,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 	     dapm->bias_level != SND_SOC_BIAS_OFF,
 	     "codec %s can not start from non-off bias with idle_bias_off==1\n",
 	     component->name);
+	probed = 1;
 
 	/* machine specific init */
 	if (component->init) {
@@ -1312,7 +1312,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 
 err_probe:
 	if (ret < 0)
-		soc_cleanup_component(component);
+		soc_remove_component(component, probed);
 
 	return ret;
 }
@@ -1414,7 +1414,7 @@ static void soc_remove_link_components(struct snd_soc_card *card)
 				if (component->driver->remove_order != order)
 					continue;
 
-				soc_remove_component(component);
+				soc_remove_component(component, 1);
 			}
 		}
 	}
@@ -1608,7 +1608,7 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 	for_each_comp_order(order) {
 		for_each_card_auxs_safe(card, comp, _comp) {
 			if (comp->driver->remove_order == order)
-				soc_remove_component(comp);
+				soc_remove_component(comp, 1);
 		}
 	}
 }

commit da704f26ba376bd93ac5234fa4605c4a8e4a5648
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 6 10:07:38 2019 +0900

    ASoC: soc-core: merge snd_soc_remove_dai_link() and soc_unbind_dai_link()
    
    We don't need to separete snd_soc_remove_dai_link() and
    soc_unbind_dai_link() anymore. Let's merge these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87pni5hkx1.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8add98431881..d80d485f46d1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1049,15 +1049,36 @@ static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 	return 0;
 }
 
-static void soc_unbind_dai_link(struct snd_soc_card *card,
-				struct snd_soc_dai_link *dai_link)
+/**
+ * snd_soc_remove_dai_link - Remove a DAI link from the list
+ * @card: The ASoC card that owns the link
+ * @dai_link: The DAI link to remove
+ *
+ * This function removes a DAI link from the ASoC card's link list.
+ *
+ * For DAI links previously added by topology, topology should
+ * remove them by using the dobj embedded in the link.
+ */
+void snd_soc_remove_dai_link(struct snd_soc_card *card,
+			     struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
 
+	lockdep_assert_held(&client_mutex);
+
+	/*
+	 * Notify the machine driver for extra destruction
+	 */
+	if (card->remove_dai_link)
+		card->remove_dai_link(card, dai_link);
+
+	list_del(&dai_link->list);
+
 	rtd = snd_soc_get_pcm_runtime(card, dai_link->name);
 	if (rtd)
 		soc_free_pcm_runtime(rtd);
 }
+EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
 
 /**
  * snd_soc_add_dai_link - Add a DAI link dynamically
@@ -1434,33 +1455,6 @@ void snd_soc_disconnect_sync(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_disconnect_sync);
 
-/**
- * snd_soc_remove_dai_link - Remove a DAI link from the list
- * @card: The ASoC card that owns the link
- * @dai_link: The DAI link to remove
- *
- * This function removes a DAI link from the ASoC card's link list.
- *
- * For DAI links previously added by topology, topology should
- * remove them by using the dobj embedded in the link.
- */
-void snd_soc_remove_dai_link(struct snd_soc_card *card,
-			     struct snd_soc_dai_link *dai_link)
-{
-	lockdep_assert_held(&client_mutex);
-
-	/*
-	 * Notify the machine driver for extra destruction
-	 */
-	if (card->remove_dai_link)
-		card->remove_dai_link(card, dai_link);
-
-	list_del(&dai_link->list);
-
-	soc_unbind_dai_link(card, dai_link);
-}
-EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
-
 static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 				struct snd_soc_pcm_runtime *rtd)
 {

commit 63dc47da1f396fecd2373e41928e275f9ca3d924
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 6 10:07:31 2019 +0900

    ASoC: soc-core: merge snd_soc_add_dai_link() and soc_bind_dai_link()
    
    We don't need to separete snd_soc_add_dai_link() and
    soc_bind_dai_link() anymore. Let's merge these.
    
    One note is that before this patch, it adds list (A)
    eventhough if it had dai_link->ignore (1), or already bounded dai_link (2).
    But I guess it is wrong. This patch also solve this issue.
    
    /* BEFORE */
            int soc_bind_dai_link(...)
            {
                    ...
    (1)             if (dai_link->ignore)
                            return 0;
    
    (2)             if (soc_is_dai_link_bound(...))
                            return 0;
                    ...
            }
    
            int snd_soc_add_dai_link(...)
            {
                    ...
    =>              ret = soc_bind_dai_link(...);
    =>              if (ret < 0)
    =>                      return ret;
    
    (A)             list_add_tail(&dai_link->list, &card->dai_link_list);
                    ...
            }
    
    /* AFTER */
    
            int snd_soc_add_dai_link(...)
            {
                    ...
    (1)             if (dai_link->ignore)
                            return 0;
    
    (2)             if (soc_is_dai_link_bound(...))
                            return 0;
                    ...
    (A)             list_add_tail(&dai_link->list, &card->dai_link_list);
                    return 0;
            }
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87r22lhkx8.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 01a8fb28b48f..8add98431881 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1059,14 +1059,33 @@ static void soc_unbind_dai_link(struct snd_soc_card *card,
 		soc_free_pcm_runtime(rtd);
 }
 
-static int soc_bind_dai_link(struct snd_soc_card *card,
-	struct snd_soc_dai_link *dai_link)
+/**
+ * snd_soc_add_dai_link - Add a DAI link dynamically
+ * @card: The ASoC card to which the DAI link is added
+ * @dai_link: The new DAI link to add
+ *
+ * This function adds a DAI link to the ASoC card's link list.
+ *
+ * Note: Topology can use this API to add DAI links when probing the
+ * topology component. And machine drivers can still define static
+ * DAI links in dai_link array.
+ */
+int snd_soc_add_dai_link(struct snd_soc_card *card,
+			 struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link_component *codec, *platform;
 	struct snd_soc_component *component;
 	int i, ret;
 
+	lockdep_assert_held(&client_mutex);
+
+	/*
+	 * Notify the machine driver for extra initialization
+	 */
+	if (card->add_dai_link)
+		card->add_dai_link(card, dai_link);
+
 	if (dai_link->ignore)
 		return 0;
 
@@ -1115,12 +1134,16 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 		}
 	}
 
+	/* see for_each_card_links */
+	list_add_tail(&dai_link->list, &card->dai_link_list);
+
 	return 0;
 
 _err_defer:
 	soc_free_pcm_runtime(rtd);
 	return -EPROBE_DEFER;
 }
+EXPORT_SYMBOL_GPL(snd_soc_add_dai_link);
 
 static void soc_set_of_name_prefix(struct snd_soc_component *component)
 {
@@ -1411,41 +1434,6 @@ void snd_soc_disconnect_sync(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_disconnect_sync);
 
-/**
- * snd_soc_add_dai_link - Add a DAI link dynamically
- * @card: The ASoC card to which the DAI link is added
- * @dai_link: The new DAI link to add
- *
- * This function adds a DAI link to the ASoC card's link list.
- *
- * Note: Topology can use this API to add DAI links when probing the
- * topology component. And machine drivers can still define static
- * DAI links in dai_link array.
- */
-int snd_soc_add_dai_link(struct snd_soc_card *card,
-		struct snd_soc_dai_link *dai_link)
-{
-	int ret;
-
-	lockdep_assert_held(&client_mutex);
-
-	/*
-	 * Notify the machine driver for extra initialization
-	 */
-	if (card->add_dai_link)
-		card->add_dai_link(card, dai_link);
-
-	ret = soc_bind_dai_link(card, dai_link);
-	if (ret < 0)
-		return ret;
-
-	/* see for_each_card_links */
-	list_add_tail(&dai_link->list, &card->dai_link_list);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_add_dai_link);
-
 /**
  * snd_soc_remove_dai_link - Remove a DAI link from the list
  * @card: The ASoC card that owns the link

commit ffdbca0be6c78ea32b9243eea976270441210f2f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 6 10:07:23 2019 +0900

    ASoC: soc-core: merge snd_soc_unregister_dai() and soc_del_dai()
    
    We don't need to separete snd_soc_unregister_dai() and
    soc_del_dai() anymore. Let's merge these
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87sgn1hkxg.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b2544c7ff0f4..01a8fb28b48f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2511,11 +2511,12 @@ static inline char *fmt_multiple_name(struct device *dev,
 	return devm_kstrdup(dev, dai_drv->name, GFP_KERNEL);
 }
 
-static void soc_del_dai(struct snd_soc_dai *dai)
+void snd_soc_unregister_dai(struct snd_soc_dai *dai)
 {
 	dev_dbg(dai->dev, "ASoC: Unregistered DAI '%s'\n", dai->name);
 	list_del(&dai->list);
 }
+EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
 
 /**
  * snd_soc_register_dai - Register a DAI dynamically & create its widgets
@@ -2576,13 +2577,6 @@ struct snd_soc_dai *snd_soc_register_dai(struct snd_soc_component *component,
 	dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
 	return dai;
 }
-EXPORT_SYMBOL_GPL(snd_soc_register_dai);
-
-void snd_soc_unregister_dai(struct snd_soc_dai *dai)
-{
-	soc_del_dai(dai);
-}
-EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
 
 /**
  * snd_soc_unregister_dai - Unregister DAIs from the ASoC core

commit 7ca24386a7c2fb3828303b7c694cb0b4af1eac5c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 6 10:07:17 2019 +0900

    ASoC: soc-core: merge snd_soc_register_dai() and soc_add_dai()
    
    We don't need to separete snd_soc_register_dai() and
    soc_add_dai() anymore. Let's merge these
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87tv7hhkxm.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c6885adbdc8b..b2544c7ff0f4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2517,16 +2517,27 @@ static void soc_del_dai(struct snd_soc_dai *dai)
 	list_del(&dai->list);
 }
 
-/* Create a DAI and add it to the component's DAI list */
-static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
-	struct snd_soc_dai_driver *dai_drv,
-	bool legacy_dai_naming)
+/**
+ * snd_soc_register_dai - Register a DAI dynamically & create its widgets
+ *
+ * @component: The component the DAIs are registered for
+ * @dai_drv: DAI driver to use for the DAI
+ *
+ * Topology can use this API to register DAIs when probing a component.
+ * These DAIs's widgets will be freed in the card cleanup and the DAIs
+ * will be freed in the component cleanup.
+ */
+struct snd_soc_dai *snd_soc_register_dai(struct snd_soc_component *component,
+					 struct snd_soc_dai_driver *dai_drv,
+					 bool legacy_dai_naming)
 {
 	struct device *dev = component->dev;
 	struct snd_soc_dai *dai;
 
 	dev_dbg(dev, "ASoC: dynamically register DAI %s\n", dev_name(dev));
 
+	lockdep_assert_held(&client_mutex);
+
 	dai = devm_kzalloc(dev, sizeof(*dai), GFP_KERNEL);
 	if (dai == NULL)
 		return NULL;
@@ -2565,6 +2576,7 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 	dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
 	return dai;
 }
+EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 
 void snd_soc_unregister_dai(struct snd_soc_dai *dai)
 {
@@ -2572,29 +2584,6 @@ void snd_soc_unregister_dai(struct snd_soc_dai *dai)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
 
-/**
- * snd_soc_register_dai - Register a DAI dynamically & create its widgets
- *
- * @component: The component the DAIs are registered for
- * @dai_drv: DAI driver to use for the DAI
- *
- * Topology can use this API to register DAIs when probing a component.
- * These DAIs's widgets will be freed in the card cleanup and the DAIs
- * will be freed in the component cleanup.
- */
-struct snd_soc_dai *snd_soc_register_dai(struct snd_soc_component *component,
-					 struct snd_soc_dai_driver *dai_drv,
-					 bool legacy_dai_naming)
-{
-	struct device *dev = component->dev;
-
-	dev_dbg(dev, "ASoC: dai register %s\n", dai_drv->name);
-
-	lockdep_assert_held(&client_mutex);
-	return soc_add_dai(component, dai_drv, legacy_dai_naming);
-}
-EXPORT_SYMBOL_GPL(snd_soc_register_dai);
-
 /**
  * snd_soc_unregister_dai - Unregister DAIs from the ASoC core
  *

commit 0d18a7caa654ea1a0c02b3a253adfd5c10723871
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 6 10:07:07 2019 +0900

    ASoC: soc-core: remove soc_is_dai_link_bound()
    
    Because complex separeted "card pre-listed component" and
    "topology added component" duplicated operation is now
    becoming simple, we don't need to check already bound dai_link
    which is not exist anymore.
    This patch removes soc_is_dai_link_bound().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87v9rxhkxw.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 55014e7ae0d8..c6885adbdc8b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -953,19 +953,6 @@ struct snd_soc_dai_link *snd_soc_find_dai_link(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_find_dai_link);
 
-static bool soc_is_dai_link_bound(struct snd_soc_card *card,
-		struct snd_soc_dai_link *dai_link)
-{
-	struct snd_soc_pcm_runtime *rtd;
-
-	for_each_card_rtds(card, rtd) {
-		if (rtd->dai_link == dai_link)
-			return true;
-	}
-
-	return false;
-}
-
 static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 				     struct snd_soc_dai_link *link)
 {
@@ -1085,12 +1072,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 	dev_dbg(card->dev, "ASoC: binding %s\n", dai_link->name);
 
-	if (soc_is_dai_link_bound(card, dai_link)) {
-		dev_dbg(card->dev, "ASoC: dai link %s already bound\n",
-			dai_link->name);
-		return 0;
-	}
-
 	ret = soc_dai_link_sanity_check(card, dai_link);
 	if (ret < 0)
 		return ret;

commit 18dd66ea84464a4bc86089276d5f75cadeb94a09
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 6 16:05:05 2019 +0900

    ASoC: soc-core: fixup dead-lock at snd_soc_unregister_component()
    
    snd_soc_unregister_component() is calling snd_soc_lookup_component()
    under mutex_lock(). But, snd_soc_lookup_component() itself is using
    mutex_lock(), thus it will be dead-lock.
    This patch adds _nolocked version of it, and avoid dead-lock issue.
    
    Fixes: ac6a4dd3e9f0("ASoC: soc-core: use snd_soc_lookup_component() at snd_soc_unregister_component()")
    Reported-by: "kernelci.org bot" <bot@kernelci.org>"
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87bltph4da.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a7ad81ec59db..55014e7ae0d8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -356,14 +356,13 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 }
 EXPORT_SYMBOL_GPL(snd_soc_rtdcom_lookup);
 
-struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
-						   const char *driver_name)
+static struct snd_soc_component
+*snd_soc_lookup_component_nolocked(struct device *dev, const char *driver_name)
 {
 	struct snd_soc_component *component;
 	struct snd_soc_component *found_component;
 
 	found_component = NULL;
-	mutex_lock(&client_mutex);
 	for_each_component(component) {
 		if ((dev == component->dev) &&
 		    (!driver_name ||
@@ -373,10 +372,21 @@ struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
 			break;
 		}
 	}
-	mutex_unlock(&client_mutex);
 
 	return found_component;
 }
+
+struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
+						   const char *driver_name)
+{
+	struct snd_soc_component *component;
+
+	mutex_lock(&client_mutex);
+	component = snd_soc_lookup_component_nolocked(dev, driver_name);
+	mutex_unlock(&client_mutex);
+
+	return component;
+}
 EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
 
 struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
@@ -2855,7 +2865,7 @@ void snd_soc_unregister_component(struct device *dev)
 
 	mutex_lock(&client_mutex);
 	while (1) {
-		component = snd_soc_lookup_component(dev, NULL);
+		component = snd_soc_lookup_component_nolocked(dev, NULL);
 		if (!component)
 			break;
 

commit df95a16d2a9626dcfc3f2b3671c9b91fa076c997
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Wed Nov 6 08:58:01 2019 -0600

    ASoC: soc-core: fix RIP warning on card removal
    
    SOF module load/unload tests show nasty recurring warnings:
    
    WARNING: CPU: 5 PID: 1339 at sound/core/control.c:466
    snd_ctl_remove+0xf0/0x100 [snd]
    RIP: 0010:snd_ctl_remove+0xf0/0x100 [snd]
    
    This regression was introduced by the removal of the call to
    soc_remove_link_components() before soc_card_free() is invoked.
    
    Go back to the initial order but only call
    soc_remove_link_components() once.
    
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Fixes: 5a4c9f054ceea ("ASoC: soc-core: snd_soc_unbind_card() cleanup")
    GitHub issue: https://github.com/thesofproject/linux/issues/1424
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20191106145801.9316-1-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cc596871ba7f..a7ad81ec59db 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1974,6 +1974,9 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 {
 	struct snd_soc_dai_link *link, *_link;
 
+	/* This should be called before snd_card_free() */
+	soc_remove_link_components(card);
+
 	/* free the ALSA card at first; this syncs with pending operations */
 	if (card->snd_card) {
 		snd_card_free(card->snd_card);
@@ -1982,7 +1985,6 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 
 	/* remove and free each DAI */
 	soc_remove_link_dais(card);
-	soc_remove_link_components(card);
 
 	for_each_card_links_safe(card, link, _link)
 		snd_soc_remove_dai_link(card, link);

commit 237d19080cd37e1ccf5462e63d8577d713f6da46
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:47:22 2019 +0900

    ASoC: soc-core: remove topology specific operation
    
    soc-core has some API which is used from topology, but it is doing
    topology specific operation at soc-core.
    soc-core should care about core things, and topology should care
    about topology things, otherwise, it is very confusable.
    
    For example topology type is not related to soc-core,
    it is topology side issue.
    
    This patch removes meaningless check from soc-core.
    
    This patch keeps extra initialization/destruction at
    snd_soc_add_dai_link() / snd_soc_remove_dai_link()
    which were for topology.
    From this patch, non-topology card can use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87pni6251h.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 86c45f751598..cc596871ba7f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1436,19 +1436,12 @@ int snd_soc_add_dai_link(struct snd_soc_card *card,
 {
 	int ret;
 
-	if (dai_link->dobj.type
-	    && dai_link->dobj.type != SND_SOC_DOBJ_DAI_LINK) {
-		dev_err(card->dev, "Invalid dai link type %d\n",
-			dai_link->dobj.type);
-		return -EINVAL;
-	}
-
 	lockdep_assert_held(&client_mutex);
+
 	/*
 	 * Notify the machine driver for extra initialization
-	 * on the link created by topology.
 	 */
-	if (dai_link->dobj.type && card->add_dai_link)
+	if (card->add_dai_link)
 		card->add_dai_link(card, dai_link);
 
 	ret = soc_bind_dai_link(card, dai_link);
@@ -1475,19 +1468,12 @@ EXPORT_SYMBOL_GPL(snd_soc_add_dai_link);
 void snd_soc_remove_dai_link(struct snd_soc_card *card,
 			     struct snd_soc_dai_link *dai_link)
 {
-	if (dai_link->dobj.type
-	    && dai_link->dobj.type != SND_SOC_DOBJ_DAI_LINK) {
-		dev_err(card->dev, "Invalid dai link type %d\n",
-			dai_link->dobj.type);
-		return;
-	}
-
 	lockdep_assert_held(&client_mutex);
+
 	/*
 	 * Notify the machine driver for extra destruction
-	 * on the link created by topology.
 	 */
-	if (dai_link->dobj.type && card->remove_dai_link)
+	if (card->remove_dai_link)
 		card->remove_dai_link(card, dai_link);
 
 	list_del(&dai_link->list);
@@ -2609,12 +2595,6 @@ struct snd_soc_dai *snd_soc_register_dai(struct snd_soc_component *component,
 {
 	struct device *dev = component->dev;
 
-	if (dai_drv->dobj.type &&
-	    dai_drv->dobj.type != SND_SOC_DOBJ_PCM) {
-		dev_err(dev, "Invalid dai type %d\n", dai_drv->dobj.type);
-		return NULL;
-	}
-
 	dev_dbg(dev, "ASoC: dai register %s\n", dai_drv->name);
 
 	lockdep_assert_held(&client_mutex);

commit 71cb85f5e9da4aa3ab62020389b513275121083d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:47:18 2019 +0900

    ASoC: soc-core: call snd_soc_register_dai() from snd_soc_register_dais()
    
    ALSA SoC has 2 functions.
    snd_soc_register_dai()  is used from topology
    snd_soc_register_dais() is used from snd_soc_add_component()
    
    In general, people think like _dai() is called from _dais()
    with for loop. But in reality, these are very similar
    but different implementation.
    We shouldn't have duplicated and confusing implementation.
    
    This patch calls snd_soc_register_dai() from snd_soc_register_dais()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87r22m251l.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 55b13c0037d2..86c45f751598 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2607,12 +2607,16 @@ struct snd_soc_dai *snd_soc_register_dai(struct snd_soc_component *component,
 					 struct snd_soc_dai_driver *dai_drv,
 					 bool legacy_dai_naming)
 {
-	if (dai_drv->dobj.type != SND_SOC_DOBJ_PCM) {
-		dev_err(component->dev, "Invalid dai type %d\n",
-			dai_drv->dobj.type);
+	struct device *dev = component->dev;
+
+	if (dai_drv->dobj.type &&
+	    dai_drv->dobj.type != SND_SOC_DOBJ_PCM) {
+		dev_err(dev, "Invalid dai type %d\n", dai_drv->dobj.type);
 		return NULL;
 	}
 
+	dev_dbg(dev, "ASoC: dai register %s\n", dai_drv->name);
+
 	lockdep_assert_held(&client_mutex);
 	return soc_add_dai(component, dai_drv, legacy_dai_naming);
 }
@@ -2642,16 +2646,12 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 				 struct snd_soc_dai_driver *dai_drv,
 				 size_t count)
 {
-	struct device *dev = component->dev;
 	struct snd_soc_dai *dai;
 	unsigned int i;
 	int ret;
 
-	dev_dbg(dev, "ASoC: dai register %s #%zu\n", dev_name(dev), count);
-
 	for (i = 0; i < count; i++) {
-
-		dai = soc_add_dai(component, dai_drv + i, count == 1 &&
+		dai = snd_soc_register_dai(component, dai_drv + i, count == 1 &&
 				  !component->driver->non_legacy_dai_naming);
 		if (dai == NULL) {
 			ret = -ENOMEM;

commit e443c20593de9f8efd9b2935ed40eb0bbacce30b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:47:14 2019 +0900

    ASoC: soc-core: don't call snd_soc_dapm_new_dai_widgets() at snd_soc_register_dai()
    
    ALSA SoC has 2 functions.
    snd_soc_register_dai()  is used from topology
    snd_soc_register_dais() is used from snd_soc_add_component()
    
    In general, people think like _dai() is called from _dais()
    with for loop. But in reality, these are very similar
    but different implementation.
    We shouldn't have duplicated and confusing implementation.
    
    snd_soc_register_dai() is now used from topology.
    But to reduce duplicated code, it should be used from _dais(), too.
    
    Because of topology side specific reason,
    it is calling snd_soc_dapm_new_dai_widgets(),
    but it is not needed _dais() side.
    
    This patch factorizes snd_soc_register_dai() to
    topology / _dais() common part, and topology specific part.
    And do topology specific part at soc-topology.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87sgn2251p.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6f4933f13b08..55b13c0037d2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2603,37 +2603,18 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
  * These DAIs's widgets will be freed in the card cleanup and the DAIs
  * will be freed in the component cleanup.
  */
-int snd_soc_register_dai(struct snd_soc_component *component,
-			 struct snd_soc_dai_driver *dai_drv,
-			 bool legacy_dai_naming)
+struct snd_soc_dai *snd_soc_register_dai(struct snd_soc_component *component,
+					 struct snd_soc_dai_driver *dai_drv,
+					 bool legacy_dai_naming)
 {
-	struct snd_soc_dapm_context *dapm =
-		snd_soc_component_get_dapm(component);
-	struct snd_soc_dai *dai;
-	int ret;
-
 	if (dai_drv->dobj.type != SND_SOC_DOBJ_PCM) {
 		dev_err(component->dev, "Invalid dai type %d\n",
 			dai_drv->dobj.type);
-		return -EINVAL;
+		return NULL;
 	}
 
 	lockdep_assert_held(&client_mutex);
-	dai = soc_add_dai(component, dai_drv, legacy_dai_naming);
-	if (!dai)
-		return -ENOMEM;
-
-	/*
-	 * Create the DAI widgets here. After adding DAIs, topology may
-	 * also add routes that need these widgets as source or sink.
-	 */
-	ret = snd_soc_dapm_new_dai_widgets(dapm, dai);
-	if (ret != 0) {
-		dev_err(component->dev,
-			"Failed to create DAI widgets %d\n", ret);
-	}
-
-	return ret;
+	return soc_add_dai(component, dai_drv, legacy_dai_naming);
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 

commit 5d07519703bc2f0bf19d33652401552a480d68b8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:47:09 2019 +0900

    ASoC: soc-core: have legacy_dai_naming at snd_soc_register_dai()
    
    ALSA SoC has 2 functions.
    snd_soc_register_dai()  is used from topology
    snd_soc_register_dais() is used from snd_soc_add_component()
    
    In general, people think like _dai() is called from _dais()
    with for loop. But in reality, these are very similar
    but different implementation.
    We shouldn't have duplicated and confusing implementation.
    
    snd_soc_register_dai() is now used from topology.
    But to reduce duplicated code, it should be used from _dais(), too.
    To prepare it, this patch adds missing parameter legacy_dai_naming
    to snd_soc_register_dai().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87tv7i251u.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 38199cd7ce97..6f4933f13b08 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2604,7 +2604,8 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
  * will be freed in the component cleanup.
  */
 int snd_soc_register_dai(struct snd_soc_component *component,
-	struct snd_soc_dai_driver *dai_drv)
+			 struct snd_soc_dai_driver *dai_drv,
+			 bool legacy_dai_naming)
 {
 	struct snd_soc_dapm_context *dapm =
 		snd_soc_component_get_dapm(component);
@@ -2618,7 +2619,7 @@ int snd_soc_register_dai(struct snd_soc_component *component,
 	}
 
 	lockdep_assert_held(&client_mutex);
-	dai = soc_add_dai(component, dai_drv, false);
+	dai = soc_add_dai(component, dai_drv, legacy_dai_naming);
 	if (!dai)
 		return -ENOMEM;
 

commit e11381f38f34789b374880c4a149e25e8d7f0cfd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:47:04 2019 +0900

    ASoC: soc-core: add snd_soc_unregister_dai()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and is difficult to debug.
    
    This patch adds missing soc_del_dai() and snd_soc_unregister_dai().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87v9ry251z.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c803447fe639..38199cd7ce97 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2532,6 +2532,12 @@ static inline char *fmt_multiple_name(struct device *dev,
 	return devm_kstrdup(dev, dai_drv->name, GFP_KERNEL);
 }
 
+static void soc_del_dai(struct snd_soc_dai *dai)
+{
+	dev_dbg(dai->dev, "ASoC: Unregistered DAI '%s'\n", dai->name);
+	list_del(&dai->list);
+}
+
 /* Create a DAI and add it to the component's DAI list */
 static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 	struct snd_soc_dai_driver *dai_drv,
@@ -2581,6 +2587,12 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 	return dai;
 }
 
+void snd_soc_unregister_dai(struct snd_soc_dai *dai)
+{
+	soc_del_dai(dai);
+}
+EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
+
 /**
  * snd_soc_register_dai - Register a DAI dynamically & create its widgets
  *
@@ -2633,11 +2645,8 @@ static void snd_soc_unregister_dais(struct snd_soc_component *component)
 {
 	struct snd_soc_dai *dai, *_dai;
 
-	for_each_component_dais_safe(component, dai, _dai) {
-		dev_dbg(component->dev, "ASoC: Unregistered DAI '%s'\n",
-			dai->name);
-		list_del(&dai->list);
-	}
+	for_each_component_dais_safe(component, dai, _dai)
+		snd_soc_unregister_dai(dai);
 }
 
 /**

commit 3f6674ae13a1e498f249b0255659bfc4f692a7e0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:47:00 2019 +0900

    ASoC: soc-core: move snd_soc_unregister_dais()
    
    This patch moves snd_soc_unregister_dais() next to
    snd_soc_register_dais().
    This is prepare for snd_soc_register_dais() cleanup
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87woce2524.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fb5f01497498..c803447fe639 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2532,22 +2532,6 @@ static inline char *fmt_multiple_name(struct device *dev,
 	return devm_kstrdup(dev, dai_drv->name, GFP_KERNEL);
 }
 
-/**
- * snd_soc_unregister_dai - Unregister DAIs from the ASoC core
- *
- * @component: The component for which the DAIs should be unregistered
- */
-static void snd_soc_unregister_dais(struct snd_soc_component *component)
-{
-	struct snd_soc_dai *dai, *_dai;
-
-	for_each_component_dais_safe(component, dai, _dai) {
-		dev_dbg(component->dev, "ASoC: Unregistered DAI '%s'\n",
-			dai->name);
-		list_del(&dai->list);
-	}
-}
-
 /* Create a DAI and add it to the component's DAI list */
 static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 	struct snd_soc_dai_driver *dai_drv,
@@ -2640,6 +2624,22 @@ int snd_soc_register_dai(struct snd_soc_component *component,
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 
+/**
+ * snd_soc_unregister_dai - Unregister DAIs from the ASoC core
+ *
+ * @component: The component for which the DAIs should be unregistered
+ */
+static void snd_soc_unregister_dais(struct snd_soc_component *component)
+{
+	struct snd_soc_dai *dai, *_dai;
+
+	for_each_component_dais_safe(component, dai, _dai) {
+		dev_dbg(component->dev, "ASoC: Unregistered DAI '%s'\n",
+			dai->name);
+		list_del(&dai->list);
+	}
+}
+
 /**
  * snd_soc_register_dais - Register a DAI with the ASoC core
  *

commit daf7737335bf555abf14031530fe8e47b46b373a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:55 2019 +0900

    ASoC: soc-core: move snd_soc_register_dai()
    
    This patch moves snd_soc_register_dai() next to
    snd_soc_register_dais().
    This is prepare for snd_soc_register_dais() cleanup.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87y2wu2528.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0ce333669138..fb5f01497498 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2597,42 +2597,6 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 	return dai;
 }
 
-/**
- * snd_soc_register_dais - Register a DAI with the ASoC core
- *
- * @component: The component the DAIs are registered for
- * @dai_drv: DAI driver to use for the DAIs
- * @count: Number of DAIs
- */
-static int snd_soc_register_dais(struct snd_soc_component *component,
-				 struct snd_soc_dai_driver *dai_drv,
-				 size_t count)
-{
-	struct device *dev = component->dev;
-	struct snd_soc_dai *dai;
-	unsigned int i;
-	int ret;
-
-	dev_dbg(dev, "ASoC: dai register %s #%zu\n", dev_name(dev), count);
-
-	for (i = 0; i < count; i++) {
-
-		dai = soc_add_dai(component, dai_drv + i, count == 1 &&
-				  !component->driver->non_legacy_dai_naming);
-		if (dai == NULL) {
-			ret = -ENOMEM;
-			goto err;
-		}
-	}
-
-	return 0;
-
-err:
-	snd_soc_unregister_dais(component);
-
-	return ret;
-}
-
 /**
  * snd_soc_register_dai - Register a DAI dynamically & create its widgets
  *
@@ -2676,6 +2640,42 @@ int snd_soc_register_dai(struct snd_soc_component *component,
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 
+/**
+ * snd_soc_register_dais - Register a DAI with the ASoC core
+ *
+ * @component: The component the DAIs are registered for
+ * @dai_drv: DAI driver to use for the DAIs
+ * @count: Number of DAIs
+ */
+static int snd_soc_register_dais(struct snd_soc_component *component,
+				 struct snd_soc_dai_driver *dai_drv,
+				 size_t count)
+{
+	struct device *dev = component->dev;
+	struct snd_soc_dai *dai;
+	unsigned int i;
+	int ret;
+
+	dev_dbg(dev, "ASoC: dai register %s #%zu\n", dev_name(dev), count);
+
+	for (i = 0; i < count; i++) {
+
+		dai = soc_add_dai(component, dai_drv + i, count == 1 &&
+				  !component->driver->non_legacy_dai_naming);
+		if (dai == NULL) {
+			ret = -ENOMEM;
+			goto err;
+		}
+	}
+
+	return 0;
+
+err:
+	snd_soc_unregister_dais(component);
+
+	return ret;
+}
+
 static int snd_soc_component_initialize(struct snd_soc_component *component,
 	const struct snd_soc_component_driver *driver, struct device *dev)
 {

commit ac6a4dd3e9f09697ab6a1774d7ab6a34e7ab36fa
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:51 2019 +0900

    ASoC: soc-core: use snd_soc_lookup_component() at snd_soc_unregister_component()
    
    snd_soc_unregister_component() is now finding component manually,
    but we already have snd_soc_lookup_component() to find component;
    Let's use existing function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87zhha252c.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bb0592159414..0ce333669138 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2876,29 +2876,19 @@ EXPORT_SYMBOL_GPL(snd_soc_register_component);
  *
  * @dev: The device to unregister
  */
-static int __snd_soc_unregister_component(struct device *dev)
+void snd_soc_unregister_component(struct device *dev)
 {
 	struct snd_soc_component *component;
-	int found = 0;
 
 	mutex_lock(&client_mutex);
-	for_each_component(component) {
-		if (dev != component->dev)
-			continue;
+	while (1) {
+		component = snd_soc_lookup_component(dev, NULL);
+		if (!component)
+			break;
 
 		snd_soc_del_component_unlocked(component);
-		found = 1;
-		break;
 	}
 	mutex_unlock(&client_mutex);
-
-	return found;
-}
-
-void snd_soc_unregister_component(struct device *dev)
-{
-	while (__snd_soc_unregister_component(dev))
-		;
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 

commit b18768f56162964f70bbb9119dba59a947d7d577
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:45 2019 +0900

    ASoC: soc-core: remove snd_soc_component_add/del()
    
    soc-core has
    snd_soc_add_component(), snd_soc_component_add(),
    snd_soc_del_component(), snd_soc_component_del().
    
    These are very confusing naming.
    snd_soc_component_xxx() are called from snd_soc_xxx_component(),
    and these are very small.
    Let's merge these into snd_soc_xxx_component(), and
    remove snd_soc_component_xxx().
    
    Reported-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/871rum3jmy.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e91325b688f2..bb0592159414 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2746,34 +2746,6 @@ EXPORT_SYMBOL_GPL(snd_soc_component_exit_regmap);
 
 #endif
 
-static void snd_soc_component_add(struct snd_soc_component *component)
-{
-	mutex_lock(&client_mutex);
-
-	if (!component->driver->write && !component->driver->read) {
-		if (!component->regmap)
-			component->regmap = dev_get_regmap(component->dev,
-							   NULL);
-		if (component->regmap)
-			snd_soc_component_setup_regmap(component);
-	}
-
-	/* see for_each_component */
-	list_add(&component->list, &component_list);
-
-	mutex_unlock(&client_mutex);
-}
-
-static void snd_soc_component_del(struct snd_soc_component *component)
-{
-	struct snd_soc_card *card = component->card;
-
-	if (card)
-		snd_soc_unbind_card(card, false);
-
-	list_del(&component->list);
-}
-
 #define ENDIANNESS_MAP(name) \
 	(SNDRV_PCM_FMTBIT_##name##LE | SNDRV_PCM_FMTBIT_##name##BE)
 static u64 endianness_format_map[] = {
@@ -2820,8 +2792,14 @@ static void snd_soc_try_rebind_card(void)
 
 static void snd_soc_del_component_unlocked(struct snd_soc_component *component)
 {
+	struct snd_soc_card *card = component->card;
+
 	snd_soc_unregister_dais(component);
-	snd_soc_component_del(component);
+
+	if (card)
+		snd_soc_unbind_card(card, false);
+
+	list_del(&component->list);
 }
 
 int snd_soc_add_component(struct device *dev,
@@ -2833,6 +2811,8 @@ int snd_soc_add_component(struct device *dev,
 	int ret;
 	int i;
 
+	mutex_lock(&client_mutex);
+
 	ret = snd_soc_component_initialize(component, component_driver, dev);
 	if (ret)
 		goto err_free;
@@ -2850,14 +2830,26 @@ int snd_soc_add_component(struct device *dev,
 		goto err_cleanup;
 	}
 
-	snd_soc_component_add(component);
-	snd_soc_try_rebind_card();
+	if (!component->driver->write && !component->driver->read) {
+		if (!component->regmap)
+			component->regmap = dev_get_regmap(component->dev,
+							   NULL);
+		if (component->regmap)
+			snd_soc_component_setup_regmap(component);
+	}
 
-	return 0;
+	/* see for_each_component */
+	list_add(&component->list, &component_list);
 
 err_cleanup:
-	snd_soc_del_component_unlocked(component);
+	if (ret < 0)
+		snd_soc_del_component_unlocked(component);
 err_free:
+	mutex_unlock(&client_mutex);
+
+	if (ret == 0)
+		snd_soc_try_rebind_card();
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_component);

commit 486c7978ff665eb763f70cc9477e0de6326e1c41
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:39 2019 +0900

    ASoC: soc-core: add snd_soc_del_component_unlocked()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and is difficult to debug.
    
    Now ALSA SoC has snd_soc_add_component(), but there is no paired
    snd_soc_del_component(). Thus, snd_soc_unregister_component() is
    calling cleanup function randomly. it is difficult to read.
    This patch adds missing snd_soc_del_component_unlocked() and
    balance up code.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/8736f23jn4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index acbaed4e4e9d..e91325b688f2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2764,12 +2764,7 @@ static void snd_soc_component_add(struct snd_soc_component *component)
 	mutex_unlock(&client_mutex);
 }
 
-static void snd_soc_component_cleanup(struct snd_soc_component *component)
-{
-	snd_soc_unregister_dais(component);
-}
-
-static void snd_soc_component_del_unlocked(struct snd_soc_component *component)
+static void snd_soc_component_del(struct snd_soc_component *component)
 {
 	struct snd_soc_card *card = component->card;
 
@@ -2823,6 +2818,12 @@ static void snd_soc_try_rebind_card(void)
 			list_del(&card->list);
 }
 
+static void snd_soc_del_component_unlocked(struct snd_soc_component *component)
+{
+	snd_soc_unregister_dais(component);
+	snd_soc_component_del(component);
+}
+
 int snd_soc_add_component(struct device *dev,
 			struct snd_soc_component *component,
 			const struct snd_soc_component_driver *component_driver,
@@ -2855,7 +2856,7 @@ int snd_soc_add_component(struct device *dev,
 	return 0;
 
 err_cleanup:
-	snd_soc_component_cleanup(component);
+	snd_soc_del_component_unlocked(component);
 err_free:
 	return ret;
 }
@@ -2893,15 +2894,12 @@ static int __snd_soc_unregister_component(struct device *dev)
 		if (dev != component->dev)
 			continue;
 
-		snd_soc_component_del_unlocked(component);
+		snd_soc_del_component_unlocked(component);
 		found = 1;
 		break;
 	}
 	mutex_unlock(&client_mutex);
 
-	if (found)
-		snd_soc_component_cleanup(component);
-
 	return found;
 }
 

commit 5bd7e08b3c5f3924259643e1f413e10ca6c97634
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:35 2019 +0900

    ASoC: soc-core: tidyup snd_soc_lookup_component()
    
    snd_soc_lookup_component() is using mix of continue and break
    in the same loop. It is odd.
    This patch cleanup it.
    
    Reported-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/874kzi3jn8.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b71bddb30db1..acbaed4e4e9d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -360,25 +360,22 @@ struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
 						   const char *driver_name)
 {
 	struct snd_soc_component *component;
-	struct snd_soc_component *ret;
+	struct snd_soc_component *found_component;
 
-	ret = NULL;
+	found_component = NULL;
 	mutex_lock(&client_mutex);
 	for_each_component(component) {
-		if (dev != component->dev)
-			continue;
-
-		if (driver_name &&
-		    (driver_name != component->driver->name) &&
-		    (strcmp(component->driver->name, driver_name) != 0))
-			continue;
-
-		ret = component;
-		break;
+		if ((dev == component->dev) &&
+		    (!driver_name ||
+		     (driver_name == component->driver->name) ||
+		     (strcmp(component->driver->name, driver_name) == 0))) {
+			found_component = component;
+			break;
+		}
 	}
 	mutex_unlock(&client_mutex);
 
-	return ret;
+	return found_component;
 }
 EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
 

commit b8132657990b5a09ad8e1c9e2c8efc20b5f9372a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:30 2019 +0900

    ASoC: soc-core: move snd_soc_lookup_component()
    
    This patch moves snd_soc_lookup_component() to upper side.
    This is prepare for snd_soc_unregister_component()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/875zjy3jnd.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1e8dd19cba24..b71bddb30db1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -356,6 +356,32 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 }
 EXPORT_SYMBOL_GPL(snd_soc_rtdcom_lookup);
 
+struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
+						   const char *driver_name)
+{
+	struct snd_soc_component *component;
+	struct snd_soc_component *ret;
+
+	ret = NULL;
+	mutex_lock(&client_mutex);
+	for_each_component(component) {
+		if (dev != component->dev)
+			continue;
+
+		if (driver_name &&
+		    (driver_name != component->driver->name) &&
+		    (strcmp(component->driver->name, driver_name) != 0))
+			continue;
+
+		ret = component;
+		break;
+	}
+	mutex_unlock(&client_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
+
 struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
 		const char *dai_link, int stream)
 {
@@ -2889,32 +2915,6 @@ void snd_soc_unregister_component(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
-struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
-						   const char *driver_name)
-{
-	struct snd_soc_component *component;
-	struct snd_soc_component *ret;
-
-	ret = NULL;
-	mutex_lock(&client_mutex);
-	for_each_component(component) {
-		if (dev != component->dev)
-			continue;
-
-		if (driver_name &&
-		    (driver_name != component->driver->name) &&
-		    (strcmp(component->driver->name, driver_name) != 0))
-			continue;
-
-		ret = component;
-		break;
-	}
-	mutex_unlock(&client_mutex);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
-
 /* Retrieve a card's name from device tree */
 int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 			       const char *propname)

commit bc7a9091e5b927ecc20dbb3bc07a5a09783fc27b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:25 2019 +0900

    ASoC: soc-core: add soc_unbind_dai_link()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    ALSA SoC has soc_bind_dai_link(), but its paired soc_unbind_dai_link()
    is not implemented.
    More confusable is that soc_remove_pcm_runtimes() which should be
    soc_unbind_dai_link() is implemented without synchronised
    to soc_bind_dai_link().
    
    This patch cleanup this unbalance.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/877e4e3jni.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e8ff6f2f58ba..1e8dd19cba24 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -470,14 +470,6 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	return NULL;
 }
 
-static void soc_remove_pcm_runtimes(struct snd_soc_card *card)
-{
-	struct snd_soc_pcm_runtime *rtd, *_rtd;
-
-	for_each_card_rtds_safe(card, rtd, _rtd)
-		soc_free_pcm_runtime(rtd);
-}
-
 struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
 		const char *dai_link)
 {
@@ -1037,6 +1029,16 @@ static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 	return 0;
 }
 
+static void soc_unbind_dai_link(struct snd_soc_card *card,
+				struct snd_soc_dai_link *dai_link)
+{
+	struct snd_soc_pcm_runtime *rtd;
+
+	rtd = snd_soc_get_pcm_runtime(card, dai_link->name);
+	if (rtd)
+		soc_free_pcm_runtime(rtd);
+}
+
 static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link)
 {
@@ -1466,6 +1468,8 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 		card->remove_dai_link(card, dai_link);
 
 	list_del(&dai_link->list);
+
+	soc_unbind_dai_link(card, dai_link);
 }
 EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
 
@@ -1974,8 +1978,6 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 	for_each_card_links_safe(card, link, _link)
 		snd_soc_remove_dai_link(card, link);
 
-	soc_remove_pcm_runtimes(card);
-
 	/* remove auxiliary devices */
 	soc_remove_aux_devices(card);
 	soc_unbind_aux_dev(card);

commit 6b1dff0266a30df16846a20d1109ab25b985f0d7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:20 2019 +0900

    ASoC: soc-core: call soc_bind_dai_link() under snd_soc_add_dai_link()
    
    If we focus to soc_bind_dai_link() at snd_soc_instantiate_card(),
    we will notice very complex operation.
    
    static int snd_soc_instantiate_card(...)
    {
            ...
            /*
             * (1) Bind dai_link via card pre-linked dai_link
             *
             * Bind dai_link via card pre-linked.
             * 1 dai_link will be 1 rtd, and connected to card.
             * for_each_card_prelinks() is for card pre-linked dai_link.
             *
             * Image
             *
             * card
             * - rtd(A)
             * - rtd(A)
             */
            for_each_card_prelinks(card, i, dai_link) {
                    ret = soc_bind_dai_link(card, dai_link);
                    ...
            }
            ...
            /*
             * (2) Connect card pre-linked dai_link to card list
             *
             * Connect all card pre-linked dai_link to *card list*.
             * Here, (A) means from card pre-linked.
             *
             * Image
             *
             * card         card list
             *  - rtd(A)     - dai_link(A)
             *  - rtd(A)     - dai_link(A)
             *  - ...        - ...
             */
            for_each_card_prelinks(card, i, dai_link) {
                    ret = snd_soc_add_dai_link(card, dai_link);
                    ...
            }
            ...
            /*
             * (3) Probe binded component
             *
             * Each rtd has many components.
             * Here probes each rtd connected components.
             * rtd(A) in Image is the probe target.
             *
             * During this component probe, topology may add new dai_link to
             * *card list* by using snd_soc_add_dai_link() which is
             * used at (2).
             * Here, (B) means from topology
             *
             * Image
             *
             * card         card list
             *  - rtd(A)     - dai_link(A)
             *  - rtd(A)     - dai_link(A)
             *  - ...        - ...
             *               - dai_link(B)
             *               - dai_link(B)
             */
            ret = soc_probe_link_components(card);
            ...
    
            /*
             * (4) Bind dai_link again
             *
             * Bind dai_link again for topology.
             * Note, (1) used for_each_card_prelinks(),
             * here is using  for_each_card_links()
             *
             * This means from card list.
             * As Image indicating, it has dai_link(A) (from card pre-link)
             * and dai_link(B) (from topology).
             * main target here is dai_link(B).
             * soc_bind_dai_link() ignores already used
             * dai_link (= dai_link(A))
             *
             * Image
             *
             * card         card list
             *  - rtd(A)     - dai_link(A)
             *  - rtd(A)     - dai_link(A)
             *  - ...        - ...
             *  - rtd(B)     - dai_link(B)
             *  - rtd(B)     - dai_link(B)
             */
            for_each_card_links(card, dai_link) {
                    ret = soc_bind_dai_link(card, dai_link);
                    ...
            }
            ...
    }
    
    As you see above, it is doing very complex method.
    The problem is binding dai_link via "card pre-linked" (= (1)) and
    "topology added dai_link" (= (3)) are separated.
    The code can be simple if we can bind dai_link when dai_link
    is connected to *card list*.
    This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/878sou3jnn.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3cc36c2d99da..e8ff6f2f58ba 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1409,6 +1409,8 @@ EXPORT_SYMBOL_GPL(snd_soc_disconnect_sync);
 int snd_soc_add_dai_link(struct snd_soc_card *card,
 		struct snd_soc_dai_link *dai_link)
 {
+	int ret;
+
 	if (dai_link->dobj.type
 	    && dai_link->dobj.type != SND_SOC_DOBJ_DAI_LINK) {
 		dev_err(card->dev, "Invalid dai link type %d\n",
@@ -1424,6 +1426,10 @@ int snd_soc_add_dai_link(struct snd_soc_card *card,
 	if (dai_link->dobj.type && card->add_dai_link)
 		card->add_dai_link(card, dai_link);
 
+	ret = soc_bind_dai_link(card, dai_link);
+	if (ret < 0)
+		return ret;
+
 	/* see for_each_card_links */
 	list_add_tail(&dai_link->list, &card->dai_link_list);
 
@@ -1996,13 +2002,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	/* check whether any platform is ignore machine FE and using topology */
 	soc_check_tplg_fes(card);
 
-	/* bind DAIs */
-	for_each_card_prelinks(card, i, dai_link) {
-		ret = soc_bind_dai_link(card, dai_link);
-		if (ret != 0)
-			goto probe_end;
-	}
-
 	/* bind aux_devs too */
 	ret = soc_bind_aux_dev(card);
 	if (ret < 0)
@@ -2060,16 +2059,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	if (ret < 0)
 		goto probe_end;
 
-	/*
-	 * Find new DAI links added during probing components and bind them.
-	 * Components with topology may bring new DAIs and DAI links.
-	 */
-	for_each_card_links(card, dai_link) {
-		ret = soc_bind_dai_link(card, dai_link);
-		if (ret)
-			goto probe_end;
-	}
-
 	/* probe all DAI links on this card */
 	ret = soc_probe_link_dais(card);
 	if (ret < 0) {

commit 95b562e57f0b3a21a3945297862cb51bc2072c7b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:15 2019 +0900

    ASoC: soc-core: remove duplicated soc_is_dai_link_bound()
    
    soc_is_dai_link_bound() check will be called both
    *before* soc_bind_dai_link() (A), and
    *under*  soc_bind_dai_link() (B).
    These are very verbose code. Let's remove one of them.
    
    *       static int soc_bind_dai_link(...)
            {
                    ...
    (B)             if (soc_is_dai_link_bound(...)) {
                            ...
                            return 0;
                    }
                    ...
            }
    
            static int snd_soc_instantiate_card(...)
            {
                    ...
                    for_each_card_links(...) {
    (A)                     if (soc_is_dai_link_bound(...))
                                    continue;
    
    *                       ret = soc_bind_dai_link(...);
                            if (ret)
                                    goto probe_end;
                    }
                    ...
            }
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87a79a3jns.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e1b0d861807c..3cc36c2d99da 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2065,9 +2065,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	 * Components with topology may bring new DAIs and DAI links.
 	 */
 	for_each_card_links(card, dai_link) {
-		if (soc_is_dai_link_bound(card, dai_link))
-			continue;
-
 		ret = soc_bind_dai_link(card, dai_link);
 		if (ret)
 			goto probe_end;

commit cd3c5ad7b2503f4fb4dfcc095b3fccc2b3603c36
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:46:00 2019 +0900

    ASoC: soc-core: typo fix at soc_dai_link_sanity_check()
    
    Reported-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87bltq3jo7.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 827625bd35cd..e1b0d861807c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1015,7 +1015,7 @@ static int soc_dai_link_sanity_check(struct snd_soc_card *card,
 	}
 
 	/*
-	 * Defer card registartion if cpu dai component is not added to
+	 * Defer card registration if cpu dai component is not added to
 	 * component list.
 	 */
 	if ((link->cpus->of_node || link->cpus->name) &&

commit bfce78a559655c5c4512a898a7e5d3a796fbb473
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:45:50 2019 +0900

    ASoC: soc-core: tidyup soc_init_dai_link()
    
    soc_init_dai_link() is needed to be called before soc_bind_dai_link().
    
            int snd_soc_instantiate_card()
            {
                    for_each_card_prelinks(...) {
    (1)                     ret = soc_init_dai_link(...);
                            ...
                    }
                    ...
                    for_each_card_prelinks(...) {
    (2)                     ret = soc_bind_dai_link(...);
                            ...
                    }
                    ...
                    for_each_card_links(...) {
                            ...
    (A)                     ret = soc_init_dai_link(...);
                            ...
    (B)                     ret = soc_bind_dai_link(...);
                    }
                    ...
    
    (1) is for (2), and (A) is for (B)
    (1) and (2) are for card prelink   dai_link.
    (A) and (B) are for topology added dai_link.
    
    soc_init_dai_link() is sanity check for dai_link, not initializing today.
    Therefore, it is confusable naming. We can rename it as sanity_check.
    
    And this check is for soc_bind_dai_link().
    It can be more simple code if we can call it from soc_bind_dai_link().
    
    This patch renames it to soc_dai_link_sanity_check(), and
    call it from soc_bind_dai_link().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87d0e63joh.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a141828f8638..827625bd35cd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -941,8 +941,8 @@ static bool soc_is_dai_link_bound(struct snd_soc_card *card,
 	return false;
 }
 
-static int soc_init_dai_link(struct snd_soc_card *card,
-			     struct snd_soc_dai_link *link)
+static int soc_dai_link_sanity_check(struct snd_soc_card *card,
+				     struct snd_soc_dai_link *link)
 {
 	int i;
 	struct snd_soc_dai_link_component *codec, *platform;
@@ -1043,7 +1043,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link_component *codec, *platform;
 	struct snd_soc_component *component;
-	int i;
+	int i, ret;
 
 	if (dai_link->ignore)
 		return 0;
@@ -1056,6 +1056,10 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 		return 0;
 	}
 
+	ret = soc_dai_link_sanity_check(card, dai_link);
+	if (ret < 0)
+		return ret;
+
 	rtd = soc_new_pcm_runtime(card, dai_link);
 	if (!rtd)
 		return -ENOMEM;
@@ -1985,15 +1989,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	int ret, i;
 
 	mutex_lock(&client_mutex);
-	for_each_card_prelinks(card, i, dai_link) {
-		ret = soc_init_dai_link(card, dai_link);
-		if (ret) {
-			dev_err(card->dev, "ASoC: failed to init link %s: %d\n",
-				dai_link->name, ret);
-			mutex_unlock(&client_mutex);
-			return ret;
-		}
-	}
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
 	snd_soc_dapm_init(&card->dapm, card, NULL);
@@ -2073,9 +2068,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		if (soc_is_dai_link_bound(card, dai_link))
 			continue;
 
-		ret = soc_init_dai_link(card, dai_link);
-		if (ret)
-			goto probe_end;
 		ret = soc_bind_dai_link(card, dai_link);
 		if (ret)
 			goto probe_end;

commit 36794902de1fe6f46f8aa5e0d6a8d9884eecae1d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 5 15:45:41 2019 +0900

    ASoC: soc-core: move soc_init_dai_link()
    
    This patch moves soc_init_dai_link() next to soc_bind_dai_link().
    This is prepare for soc_bind_dai_link() cleanup.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87eeym3joq.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b07ecfac39d7..a141828f8638 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -941,6 +941,102 @@ static bool soc_is_dai_link_bound(struct snd_soc_card *card,
 	return false;
 }
 
+static int soc_init_dai_link(struct snd_soc_card *card,
+			     struct snd_soc_dai_link *link)
+{
+	int i;
+	struct snd_soc_dai_link_component *codec, *platform;
+
+	for_each_link_codecs(link, i, codec) {
+		/*
+		 * Codec must be specified by 1 of name or OF node,
+		 * not both or neither.
+		 */
+		if (!!codec->name == !!codec->of_node) {
+			dev_err(card->dev, "ASoC: Neither/both codec name/of_node are set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
+
+		/* Codec DAI name must be specified */
+		if (!codec->dai_name) {
+			dev_err(card->dev, "ASoC: codec_dai_name not set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
+
+		/*
+		 * Defer card registration if codec component is not added to
+		 * component list.
+		 */
+		if (!soc_find_component(codec))
+			return -EPROBE_DEFER;
+	}
+
+	for_each_link_platforms(link, i, platform) {
+		/*
+		 * Platform may be specified by either name or OF node, but it
+		 * can be left unspecified, then no components will be inserted
+		 * in the rtdcom list
+		 */
+		if (!!platform->name == !!platform->of_node) {
+			dev_err(card->dev,
+				"ASoC: Neither/both platform name/of_node are set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
+
+		/*
+		 * Defer card registration if platform component is not added to
+		 * component list.
+		 */
+		if (!soc_find_component(platform))
+			return -EPROBE_DEFER;
+	}
+
+	/* FIXME */
+	if (link->num_cpus > 1) {
+		dev_err(card->dev,
+			"ASoC: multi cpu is not yet supported %s\n",
+			link->name);
+		return -EINVAL;
+	}
+
+	/*
+	 * CPU device may be specified by either name or OF node, but
+	 * can be left unspecified, and will be matched based on DAI
+	 * name alone..
+	 */
+	if (link->cpus->name && link->cpus->of_node) {
+		dev_err(card->dev,
+			"ASoC: Neither/both cpu name/of_node are set for %s\n",
+			link->name);
+		return -EINVAL;
+	}
+
+	/*
+	 * Defer card registartion if cpu dai component is not added to
+	 * component list.
+	 */
+	if ((link->cpus->of_node || link->cpus->name) &&
+	    !soc_find_component(link->cpus))
+		return -EPROBE_DEFER;
+
+	/*
+	 * At least one of CPU DAI name or CPU device name/node must be
+	 * specified
+	 */
+	if (!link->cpus->dai_name &&
+	    !(link->cpus->name || link->cpus->of_node)) {
+		dev_err(card->dev,
+			"ASoC: Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
+			link->name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link)
 {
@@ -1283,102 +1379,6 @@ static int soc_probe_link_components(struct snd_soc_card *card)
 	return 0;
 }
 
-static int soc_init_dai_link(struct snd_soc_card *card,
-			     struct snd_soc_dai_link *link)
-{
-	int i;
-	struct snd_soc_dai_link_component *codec, *platform;
-
-	for_each_link_codecs(link, i, codec) {
-		/*
-		 * Codec must be specified by 1 of name or OF node,
-		 * not both or neither.
-		 */
-		if (!!codec->name == !!codec->of_node) {
-			dev_err(card->dev, "ASoC: Neither/both codec name/of_node are set for %s\n",
-				link->name);
-			return -EINVAL;
-		}
-
-		/* Codec DAI name must be specified */
-		if (!codec->dai_name) {
-			dev_err(card->dev, "ASoC: codec_dai_name not set for %s\n",
-				link->name);
-			return -EINVAL;
-		}
-
-		/*
-		 * Defer card registration if codec component is not added to
-		 * component list.
-		 */
-		if (!soc_find_component(codec))
-			return -EPROBE_DEFER;
-	}
-
-	for_each_link_platforms(link, i, platform) {
-		/*
-		 * Platform may be specified by either name or OF node, but it
-		 * can be left unspecified, then no components will be inserted
-		 * in the rtdcom list
-		 */
-		if (!!platform->name == !!platform->of_node) {
-			dev_err(card->dev,
-				"ASoC: Neither/both platform name/of_node are set for %s\n",
-				link->name);
-			return -EINVAL;
-		}
-
-		/*
-		 * Defer card registration if platform component is not added to
-		 * component list.
-		 */
-		if (!soc_find_component(platform))
-			return -EPROBE_DEFER;
-	}
-
-	/* FIXME */
-	if (link->num_cpus > 1) {
-		dev_err(card->dev,
-			"ASoC: multi cpu is not yet supported %s\n",
-			link->name);
-		return -EINVAL;
-	}
-
-	/*
-	 * CPU device may be specified by either name or OF node, but
-	 * can be left unspecified, and will be matched based on DAI
-	 * name alone..
-	 */
-	if (link->cpus->name && link->cpus->of_node) {
-		dev_err(card->dev,
-			"ASoC: Neither/both cpu name/of_node are set for %s\n",
-			link->name);
-		return -EINVAL;
-	}
-
-	/*
-	 * Defer card registartion if cpu dai component is not added to
-	 * component list.
-	 */
-	if ((link->cpus->of_node || link->cpus->name) &&
-	    !soc_find_component(link->cpus))
-		return -EPROBE_DEFER;
-
-	/*
-	 * At least one of CPU DAI name or CPU device name/node must be
-	 * specified
-	 */
-	if (!link->cpus->dai_name &&
-	    !(link->cpus->name || link->cpus->of_node)) {
-		dev_err(card->dev,
-			"ASoC: Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
-			link->name);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
 void snd_soc_disconnect_sync(struct device *dev)
 {
 	struct snd_soc_component *component =

commit e9904ed5e73af4fd00cf4fcf705420a385af45da
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 30 10:26:10 2019 +0900

    ASoC: soc-core: remove unneeded snd_soc_tplg_component_remove()
    
    snd_soc_tplg_component_remove() is pair of snd_soc_tplg_component_load(),
    and it is topology related cleanup function.
    
    The driver which called _load() needs to call _remove() by its responsibility.
    Today, skl-pcm and topology are the user, and these are calling both
    _load() and _remove().
    
    soc-core doesn't need to call it.
    This patch remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/8736fbdnwt.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f1b41b0391ed..b07ecfac39d7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2890,8 +2890,6 @@ static int __snd_soc_unregister_component(struct device *dev)
 		if (dev != component->dev)
 			continue;
 
-		snd_soc_tplg_component_remove(component,
-					      SND_SOC_TPLG_INDEX_ALL);
 		snd_soc_component_del_unlocked(component);
 		found = 1;
 		break;

commit 2b544dd7b43b19fb55ea4fbb3e30b60eb20b7828
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 15 12:59:31 2019 +0900

    ASoC: soc-core: add for_each_rtd_components() and replace
    
    ALSA SoC has for_each_rtdcom() which is link list for
    rtd-component which is called as rtdcom. The relationship image is like below
    
                                   rtdcom      rtdcom      rtdcom
                                   component   component   component
            rtd->component_list -> list     -> list     -> list ...
    
    Here, the pointer get via normal link list is rtdcom,
    Thus, current for_each loop is like below, and need to get
    component via rtdcom->component
    
            for_each_rtdcom(rtd, rtdcom) {
                    component = rtdcom->component;
                    ...
            }
    
    but usually, user want to get pointer from for_each_xxx is component
    directly, like below.
    
            for_each_rtd_component(rtd, rtdcom, component) {
                    ...
            }
    
    This patch expands list_for_each_entry manually, and enable to get
    component directly from for_each macro.
    Because of it, the macro becoming difficult to read,
    but macro itself becoming useful.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/878spm64m4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f028a6938ee8..f1b41b0391ed 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -293,10 +293,11 @@ static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 			      struct snd_soc_component *component)
 {
 	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *comp;
 
-	for_each_rtdcom(rtd, rtdcom) {
+	for_each_rtd_components(rtd, rtdcom, comp) {
 		/* already connected */
-		if (rtdcom->component == component)
+		if (comp == component)
 			return 0;
 	}
 
@@ -327,6 +328,7 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 						const char *driver_name)
 {
 	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *component;
 
 	if (!driver_name)
 		return NULL;
@@ -339,8 +341,8 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 	 * But, if many components which have same driver name are connected
 	 * to 1 rtd, this function will return 1st found component.
 	 */
-	for_each_rtdcom(rtd, rtdcom) {
-		const char *component_name = rtdcom->component->driver->name;
+	for_each_rtd_components(rtd, rtdcom, component) {
+		const char *component_name = component->driver->name;
 
 		if (!component_name)
 			continue;
@@ -1248,9 +1250,7 @@ static void soc_remove_link_components(struct snd_soc_card *card)
 
 	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
-			for_each_rtdcom(rtd, rtdcom) {
-				component = rtdcom->component;
-
+			for_each_rtd_components(rtd, rtdcom, component) {
 				if (component->driver->remove_order != order)
 					continue;
 
@@ -1269,9 +1269,7 @@ static int soc_probe_link_components(struct snd_soc_card *card)
 
 	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
-			for_each_rtdcom(rtd, rtdcom) {
-				component = rtdcom->component;
-
+			for_each_rtd_components(rtd, rtdcom, component) {
 				if (component->driver->probe_order != order)
 					continue;
 
@@ -1520,9 +1518,7 @@ static int soc_link_init(struct snd_soc_card *card,
 	 * topology based drivers can use the DAI link id field to set PCM
 	 * device number and then use rtd + a base offset of the BEs.
 	 */
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
-
+	for_each_rtd_components(rtd, rtdcom, component) {
 		if (!component->driver->use_dai_pcm_id)
 			continue;
 

commit 5a4c9f054ceeaa90caef033f5a52eca2d7975364
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 15 12:59:51 2019 +0900

    ASoC: soc-core: snd_soc_unbind_card() cleanup
    
    soc_remove_link_components() will be called from
    soc_cleanup_card_resources(). This patch removes duplicate call.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/877e5664lz.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bd2ac1912466..f028a6938ee8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2446,9 +2446,6 @@ static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 		snd_soc_dapm_shutdown(card);
 		snd_soc_flush_all_delayed_work(card);
 
-		/* remove all components used by DAI links on this card */
-		soc_remove_link_components(card);
-
 		soc_cleanup_card_resources(card);
 		if (!unregister)
 			list_add(&card->list, &unbind_card_list);

commit 8ec241c495dde3d19a0459304298c2468c60182b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:31:06 2019 +0900

    ASoC: soc-core: add snd_soc_pcm_lib_ioctl()
    
    add snd_soc_pcm_lib_ioctl() to bypass to snd_pcm_lib_ioctl()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87r23vaf39.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d39d908f3204..bd2ac1912466 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -277,6 +277,18 @@ static inline void snd_soc_debugfs_exit(void)
 
 #endif
 
+/*
+ * This is glue code between snd_pcm_lib_ioctl() and
+ * snd_soc_component_driver :: ioctl
+ */
+int snd_soc_pcm_lib_ioctl(struct snd_soc_component *component,
+			  struct snd_pcm_substream *substream,
+			  unsigned int cmd, void *arg)
+{
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+EXPORT_SYMBOL_GPL(snd_soc_pcm_lib_ioctl);
+
 static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 			      struct snd_soc_component *component)
 {

commit d8145989ff8c2a938be372b728f90e23de8557a2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:23:07 2019 +0900

    ASoC: soc-core: setup card->rtd_num at snd_soc_instantiate_card()
    
    card->rtd_num is used to count rtd. Initialize it at
    snd_soc_instantiate_card() is very natural and less confusion.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87zhijafgk.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2c2803e6544b..d39d908f3204 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -462,8 +462,6 @@ static void soc_remove_pcm_runtimes(struct snd_soc_card *card)
 
 	for_each_card_rtds_safe(card, rtd, _rtd)
 		soc_free_pcm_runtime(rtd);
-
-	card->num_rtd = 0;
 }
 
 struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
@@ -2008,6 +2006,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		goto probe_end;
 
 	/* add predefined DAI links to the list */
+	card->num_rtd = 0;
 	for_each_card_prelinks(card, i, dai_link) {
 		ret = snd_soc_add_dai_link(card, dai_link);
 		if (ret < 0)
@@ -2418,7 +2417,6 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	INIT_LIST_HEAD(&card->dapm_dirty);
 	INIT_LIST_HEAD(&card->dobj_list);
 
-	card->num_rtd = 0;
 	card->instantiated = 0;
 	mutex_init(&card->mutex);
 	mutex_init(&card->dapm_mutex);

commit 50014499e6a45edd7ba1facf2133c03bbc7d8266
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:22:57 2019 +0900

    ASoC: soc-core: use devm_xxx for component related resource
    
    dai / component related resources are created when component is
    registered, and it will be freed when component was unregistered.
    These resources are not re-used after that.
    This means, we can use devm_xxx for dai / component, without
    thinking about kfree().
    This patch uses devm_xxx for these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/8736gbbu1a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f79ffc4b5b57..2c2803e6544b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2506,7 +2506,7 @@ static char *fmt_single_name(struct device *dev, int *id)
 			*id = 0;
 	}
 
-	return kstrdup(name, GFP_KERNEL);
+	return devm_kstrdup(dev, name, GFP_KERNEL);
 }
 
 /*
@@ -2523,7 +2523,7 @@ static inline char *fmt_multiple_name(struct device *dev,
 		return NULL;
 	}
 
-	return kstrdup(dai_drv->name, GFP_KERNEL);
+	return devm_kstrdup(dev, dai_drv->name, GFP_KERNEL);
 }
 
 /**
@@ -2539,8 +2539,6 @@ static void snd_soc_unregister_dais(struct snd_soc_component *component)
 		dev_dbg(component->dev, "ASoC: Unregistered DAI '%s'\n",
 			dai->name);
 		list_del(&dai->list);
-		kfree(dai->name);
-		kfree(dai);
 	}
 }
 
@@ -2554,7 +2552,7 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 
 	dev_dbg(dev, "ASoC: dynamically register DAI %s\n", dev_name(dev));
 
-	dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
+	dai = devm_kzalloc(dev, sizeof(*dai), GFP_KERNEL);
 	if (dai == NULL)
 		return NULL;
 
@@ -2576,10 +2574,8 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 		else
 			dai->id = component->num_dai;
 	}
-	if (dai->name == NULL) {
-		kfree(dai);
+	if (!dai->name)
 		return NULL;
-	}
 
 	dai->component = component;
 	dai->dev = dev;
@@ -2765,7 +2761,6 @@ static void snd_soc_component_add(struct snd_soc_component *component)
 static void snd_soc_component_cleanup(struct snd_soc_component *component)
 {
 	snd_soc_unregister_dais(component);
-	kfree(component->name);
 }
 
 static void snd_soc_component_del_unlocked(struct snd_soc_component *component)

commit 0f23f718ecbc135866ac40db3424dd75f01c76ea
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:22:49 2019 +0900

    ASoC: soc-core: add soc_setup_card_name()
    
    ALSA needs to setup shortname, longname, and driver.
    These methods are very similar.
    This patch adds new soc_setup_card_name() and setup these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/874l0rbu1i.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a34000d08856..f79ffc4b5b57 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1905,6 +1905,42 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 	}
 }
 
+#define soc_setup_card_name(name, name1, name2, norm)		\
+	__soc_setup_card_name(name, sizeof(name), name1, name2, norm)
+static void __soc_setup_card_name(char *name, int len,
+				  const char *name1, const char *name2,
+				  int normalization)
+{
+	int i;
+
+	snprintf(name, len, "%s", name1 ? name1 : name2);
+
+	if (!normalization)
+		return;
+
+	/*
+	 * Name normalization
+	 *
+	 * The driver name is somewhat special, as it's used as a key for
+	 * searches in the user-space.
+	 *
+	 * ex)
+	 *	"abcd??efg" -> "abcd__efg"
+	 */
+	for (i = 0; i < len; i++) {
+		switch (name[i]) {
+		case '_':
+		case '-':
+		case '\0':
+			break;
+		default:
+			if (!isalnum(name[i]))
+				name[i] = '_';
+			break;
+		}
+	}
+}
+
 static void soc_cleanup_card_resources(struct snd_soc_card *card)
 {
 	struct snd_soc_dai_link *link, *_link;
@@ -2070,24 +2106,12 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	/* try to set some sane longname if DMI is available */
 	snd_soc_set_dmi_name(card, NULL);
 
-	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
-		 "%s", card->name);
-	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
-		 "%s", card->long_name ? card->long_name : card->name);
-	snprintf(card->snd_card->driver, sizeof(card->snd_card->driver),
-		 "%s", card->driver_name ? card->driver_name : card->name);
-	for (i = 0; i < ARRAY_SIZE(card->snd_card->driver); i++) {
-		switch (card->snd_card->driver[i]) {
-		case '_':
-		case '-':
-		case '\0':
-			break;
-		default:
-			if (!isalnum(card->snd_card->driver[i]))
-				card->snd_card->driver[i] = '_';
-			break;
-		}
-	}
+	soc_setup_card_name(card->snd_card->shortname,
+			    card->name, NULL, 0);
+	soc_setup_card_name(card->snd_card->longname,
+			    card->long_name, card->name, 0);
+	soc_setup_card_name(card->snd_card->driver,
+			    card->driver_name, card->name, 1);
 
 	if (card->late_probe) {
 		ret = card->late_probe(card);

commit 7ce6088f60624805a8d3127185e2830e299849f1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:22:40 2019 +0900

    ASoC: soc-core: remove soc_remove_dai_links()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    soc_cleanup_card_resources() (a) which is paired function of
    snd_soc_instantiate_card() (A) is calling soc_remove_dai_links() (*)
    to remove card related resources, but it is breaking
    add/remove balance (B)(b)(C)(c)(D)(d), in other words
    these should be called from soc_cleanup_card_resources() (a)
    from balance point of view.
    
    More headacke is that it is using original removing method for
    dai_link even though we already have snd_soc_remove_dai_link()
    which is the function for it (d).
    
    This patch removes snd_soc_remove_dai_links() and balance up code.
    
            static void soc_remove_dai_links(...)
            {
                    ...
    (b)             soc_remove_link_dais(card);
    (c)             soc_remove_link_components(card);
    
                    for_each_card_links_safe(card, link, _link) {
                            ...
                            /* it should use snd_soc_remove_dai_link() here */
    (d)                     list_del(&link->list);
                    }
            }
    
    (a)     static int soc_cleanup_card_resources(...)
            {
                    ...
    
                    /* remove and free each DAI */
    (*)             soc_remove_dai_links(card);
                    ...
            }
    
    (A)     static int snd_soc_instantiate_card(struct snd_soc_card *card)
            {
                    ...
                    /* add predefined DAI links to the list */
                    for_each_card_prelinks(card, i, dai_link)
    (B)                     snd_soc_add_dai_link(card, dai_link);
                    ...
                    /* probe all components used by DAI links on this card */
    (C)             ret = soc_probe_link_components(card);
                    ...
                    /* probe all DAI links on this card */
    (D)             ret = soc_probe_link_dais(card);
                    ...
            }
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/875zl7bu1r.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b16a94228091..a34000d08856 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1275,23 +1275,6 @@ static int soc_probe_link_components(struct snd_soc_card *card)
 	return 0;
 }
 
-static void soc_remove_dai_links(struct snd_soc_card *card)
-{
-	struct snd_soc_dai_link *link, *_link;
-
-	soc_remove_link_dais(card);
-
-	soc_remove_link_components(card);
-
-	for_each_card_links_safe(card, link, _link) {
-		if (link->dobj.type == SND_SOC_DOBJ_DAI_LINK)
-			dev_warn(card->dev, "Topology forgot to remove link %s?\n",
-				link->name);
-
-		list_del(&link->list);
-	}
-}
-
 static int soc_init_dai_link(struct snd_soc_card *card,
 			     struct snd_soc_dai_link *link)
 {
@@ -1924,6 +1907,8 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 
 static void soc_cleanup_card_resources(struct snd_soc_card *card)
 {
+	struct snd_soc_dai_link *link, *_link;
+
 	/* free the ALSA card at first; this syncs with pending operations */
 	if (card->snd_card) {
 		snd_card_free(card->snd_card);
@@ -1931,7 +1916,12 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 	}
 
 	/* remove and free each DAI */
-	soc_remove_dai_links(card);
+	soc_remove_link_dais(card);
+	soc_remove_link_components(card);
+
+	for_each_card_links_safe(card, link, _link)
+		snd_soc_remove_dai_link(card, link);
+
 	soc_remove_pcm_runtimes(card);
 
 	/* remove auxiliary devices */

commit 4dc0e7df62839d052476de0f8447f29f857cecda
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 2 14:22:32 2019 +0900

    ASoC: soc-core: use devm_kzalloc() for rtd
    
    Current rtd, rtd->dev, rtd->codec_dais are created by normal kzalloc(),
    but we want to use devm_kzalloc() as much as possible.
    
    Created rtd->dev is registered by device_register() at
    soc_new_pcm_runtime(), and it will be freed at
    soc_free_pcm_runtime() by device_unregister().
    
    This means, if we can use devm_kzalloc(rtd->dev, xxx) for
    rtd / rtd->codec_dais, all these are automatically freed
    via soc_free_pcm_runtime().
    This patch uses devm_kzalloc(rtd->dev, xxx) for rtd / rtd->codec_dais.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/877e5nbu1z.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4a47ba94559f..b16a94228091 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -370,7 +370,6 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 	if (!rtd)
 		return;
 
-	kfree(rtd->codec_dais);
 	list_del(&rtd->list);
 
 	/*
@@ -384,7 +383,6 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 	 *	soc_new_pcm_runtime()
 	 */
 	device_unregister(rtd->dev);
-	kfree(rtd);
 }
 
 static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
@@ -416,7 +414,7 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	/*
 	 * for rtd
 	 */
-	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
+	rtd = devm_kzalloc(dev, sizeof(*rtd), GFP_KERNEL);
 	if (!rtd)
 		goto free_rtd;
 
@@ -426,7 +424,7 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	/*
 	 * for rtd->codec_dais
 	 */
-	rtd->codec_dais = kcalloc(dai_link->num_codecs,
+	rtd->codec_dais = devm_kcalloc(dev, dai_link->num_codecs,
 					sizeof(struct snd_soc_dai *),
 					GFP_KERNEL);
 	if (!rtd->codec_dais)

commit 49f9c4f2e83cf562f1a6e3f62eafa4ede5343e4a
Author: Daniel Baluta <daniel.baluta@nxp.com>
Date:   Wed Sep 25 21:33:58 2019 +0300

    ASoC: core: Clarify usage of ignore_machine
    
    For a sound card ignore_machine means that existing FEs links should be
    ignored and existing BEs links should be overridden with some information
    from the matching component driver.
    
    Current code make some confusions about this so fix it!
    
    Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
    Link: https://lore.kernel.org/r/20190925183358.11955-1-daniel.baluta@nxp.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d2842a383846..4a47ba94559f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1859,7 +1859,7 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 
 	for_each_component(component) {
 
-		/* does this component override FEs ? */
+		/* does this component override BEs ? */
 		if (!component->driver->ignore_machine)
 			continue;
 
@@ -1880,7 +1880,7 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 				continue;
 			}
 
-			dev_info(card->dev, "info: override FE DAI link %s\n",
+			dev_info(card->dev, "info: override BE DAI link %s\n",
 				 card->dai_link[i].name);
 
 			/* override platform component */

commit 353e16bf60458fae5927cf04ff668fc152fff465
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 12 13:42:44 2019 +0900

    ASoC: soc-core: remove snd_soc_rtdcom_del_all()
    
    If we can use devm_kzalloc(rtd->dev, xxx) for rtdcom,
    we don't need to call snd_soc_rtdcom_del_all() for kfree().
    This patch uses devm_kzalloc(rtd->dev, xxx) for rtdcom,
    and remove snd_soc_rtdcom_del_all().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/875zlyf7ln.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b72207412c73..d2842a383846 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -288,28 +288,29 @@ static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 			return 0;
 	}
 
-	rtdcom = kmalloc(sizeof(*rtdcom), GFP_KERNEL);
+	/*
+	 * created rtdcom here will be freed when rtd->dev was freed.
+	 * see
+	 *	soc_free_pcm_runtime() :: device_unregister(rtd->dev)
+	 */
+	rtdcom = devm_kzalloc(rtd->dev, sizeof(*rtdcom), GFP_KERNEL);
 	if (!rtdcom)
 		return -ENOMEM;
 
 	rtdcom->component = component;
 	INIT_LIST_HEAD(&rtdcom->list);
 
+	/*
+	 * When rtd was freed, created rtdcom here will be
+	 * also freed.
+	 * And we don't need to call list_del(&rtdcom->list)
+	 * when freed, because rtd is also freed.
+	 */
 	list_add_tail(&rtdcom->list, &rtd->component_list);
 
 	return 0;
 }
 
-static void snd_soc_rtdcom_del_all(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_rtdcom_list *rtdcom1, *rtdcom2;
-
-	for_each_rtdcom_safe(rtd, rtdcom1, rtdcom2)
-		kfree(rtdcom1);
-
-	INIT_LIST_HEAD(&rtd->component_list);
-}
-
 struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 						const char *driver_name)
 {
@@ -370,7 +371,6 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 		return;
 
 	kfree(rtd->codec_dais);
-	snd_soc_rtdcom_del_all(rtd);
 	list_del(&rtd->list);
 
 	/*

commit d918a37610b1bf71faa86f589bd7604f71c1e05f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 12 13:42:30 2019 +0900

    ASoC: soc-core: tidyup soc_new_pcm_runtime() alloc order
    
    This patch allocs dev first at soc_new_pcm_runtime().
    This is prepare for rtd->dev, rtd->codec_dais alloc cleanup
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/877e6ef7m1.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8a37850291bd..b72207412c73 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -125,6 +125,9 @@ static umode_t soc_dev_attr_is_visible(struct kobject *kobj,
 	struct device *dev = kobj_to_dev(kobj);
 	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
 
+	if (!rtd)
+		return 0;
+
 	if (attr == &dev_attr_pmdown_time.attr)
 		return attr->mode; /* always visible */
 	return rtd->num_codecs ? attr->mode : 0; /* enabled only with codec */
@@ -374,9 +377,13 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 	 * we don't need to call kfree() for rtd->dev
 	 * see
 	 *	soc_release_rtd_dev()
+	 *
+	 * We don't need rtd->dev NULL check, because
+	 * it is alloced *before* rtd.
+	 * see
+	 *	soc_new_pcm_runtime()
 	 */
-	if (rtd->dev)
-		device_unregister(rtd->dev);
+	device_unregister(rtd->dev);
 	kfree(rtd);
 }
 
@@ -384,8 +391,28 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	struct snd_soc_card *card, struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
+	struct device *dev;
 	int ret;
 
+	/*
+	 * for rtd->dev
+	 */
+	dev = kzalloc(sizeof(struct device), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->parent	= card->dev;
+	dev->release	= soc_release_rtd_dev;
+	dev->groups	= soc_dev_attr_groups;
+
+	dev_set_name(dev, "%s", dai_link->name);
+
+	ret = device_register(dev);
+	if (ret < 0) {
+		put_device(dev); /* soc_release_rtd_dev */
+		return NULL;
+	}
+
 	/*
 	 * for rtd
 	 */
@@ -393,6 +420,9 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	if (!rtd)
 		goto free_rtd;
 
+	rtd->dev = dev;
+	dev_set_drvdata(dev, rtd);
+
 	/*
 	 * for rtd->codec_dais
 	 */
@@ -402,27 +432,6 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	if (!rtd->codec_dais)
 		goto free_rtd;
 
-	/*
-	 * for rtd->dev
-	 */
-	rtd->dev = kzalloc(sizeof(struct device), GFP_KERNEL);
-	if (!rtd->dev)
-		goto free_rtd;
-
-	rtd->dev->parent = card->dev;
-	rtd->dev->release = soc_release_rtd_dev;
-	rtd->dev->groups = soc_dev_attr_groups;
-
-	dev_set_name(rtd->dev, "%s", dai_link->name);
-	dev_set_drvdata(rtd->dev, rtd);
-
-	ret = device_register(rtd->dev);
-	if (ret < 0) {
-		put_device(rtd->dev); /* soc_release_rtd_dev */
-		rtd->dev = NULL;
-		goto free_rtd;
-	}
-
 	/*
 	 * rtd remaining settings
 	 */

commit b7c5bc45ee94a03a0dc45a862180e17db8ea8e9d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 12 13:41:01 2019 +0900

    ASoC: soc-core: merge soc_free_pcm_runtime() and soc_rtd_free()
    
    "rtd"      is handled by soc_xxx_pcm_runtime(), and
    "rtd->dev" is handled by soc_rtd_xxx().
    
    There is no reason to separate these, and it makes code complex.
    We can free these in the same time.
    
    Here soc_rtd_free() (A) which frees rtd->dev is called from
    soc_remove_link_dais() many times (1).
    Then, it is using dev_registered flags to avoid multi kfree() (2).
    This is no longer needed if we can merge these functions.
    
            static void soc_remove_link_dais(...)
            {
                    ...
    (1)             for_each_comp_order(order) {
    (1)                     for_each_card_rtds(card, rtd) {
    
    (A)                             soc_rtd_free(rtd);
                                    ...
                            }
                    }
            }
    
    (A)     static void soc_rtd_free(...)
            {
    (2)             if (rtd->dev_registered) {
                            /* we don't need to call kfree() for rtd->dev */
                            device_unregister(rtd->dev);
    (2)                     rtd->dev_registered = 0;
                    }
            }
    
    This patch merges soc_rtd_free() into soc_free_pcm_runtime().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/878squf7oi.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6abc1bc9a236..8a37850291bd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -369,6 +369,14 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 	kfree(rtd->codec_dais);
 	snd_soc_rtdcom_del_all(rtd);
 	list_del(&rtd->list);
+
+	/*
+	 * we don't need to call kfree() for rtd->dev
+	 * see
+	 *	soc_release_rtd_dev()
+	 */
+	if (rtd->dev)
+		device_unregister(rtd->dev);
 	kfree(rtd);
 }
 
@@ -434,8 +442,6 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	rtd->num = card->num_rtd;
 	card->num_rtd++;
 
-	rtd->dev_registered = 1;
-
 	return rtd;
 
 free_rtd:
@@ -1169,7 +1175,6 @@ static int soc_probe_dai(struct snd_soc_dai *dai, int order)
 	return 0;
 }
 
-static void soc_rtd_free(struct snd_soc_pcm_runtime *rtd); /* remove me */
 static void soc_remove_link_dais(struct snd_soc_card *card)
 {
 	int i;
@@ -1179,10 +1184,6 @@ static void soc_remove_link_dais(struct snd_soc_card *card)
 
 	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
-
-			/* finalize rtd device */
-			soc_rtd_free(rtd);
-
 			/* remove the CODEC DAI */
 			for_each_rtd_codec_dai(rtd, i, codec_dai)
 				soc_remove_dai(codec_dai, order);
@@ -1460,15 +1461,6 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
 
-static void soc_rtd_free(struct snd_soc_pcm_runtime *rtd)
-{
-	if (rtd->dev_registered) {
-		/* we don't need to call kfree() for rtd->dev */
-		device_unregister(rtd->dev);
-		rtd->dev_registered = 0;
-	}
-}
-
 static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 				struct snd_soc_pcm_runtime *rtd)
 {

commit 6e864344873f19120f742c19d15a8c53e7247c6a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 12 13:40:08 2019 +0900

    ASoC: soc-core: merge soc_new_pcm_runtime() and soc_rtd_init()
    
    "rtd"      is handled by soc_xxx_pcm_runtime(), and
    "rtd->dev" is handled by soc_rtd_xxx().
    
    There is no reason to separate these, and it makes code complex.
    We can create these in the same time.
    
    This patch merges soc_rtd_init() into soc_new_pcm_runtime().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87a7baf7pz.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bc45b0db05ab..6abc1bc9a236 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -355,8 +355,17 @@ EXPORT_SYMBOL_GPL(snd_soc_get_dai_substream);
 
 static const struct snd_soc_ops null_snd_soc_ops;
 
+static void soc_release_rtd_dev(struct device *dev)
+{
+	/* "dev" means "rtd->dev" */
+	kfree(dev);
+}
+
 static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 {
+	if (!rtd)
+		return;
+
 	kfree(rtd->codec_dais);
 	snd_soc_rtdcom_del_all(rtd);
 	list_del(&rtd->list);
@@ -367,20 +376,54 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	struct snd_soc_card *card, struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
+	int ret;
 
+	/*
+	 * for rtd
+	 */
 	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
 	if (!rtd)
-		return NULL;
+		goto free_rtd;
 
+	/*
+	 * for rtd->codec_dais
+	 */
 	rtd->codec_dais = kcalloc(dai_link->num_codecs,
 					sizeof(struct snd_soc_dai *),
 					GFP_KERNEL);
-	if (!rtd->codec_dais) {
-		kfree(rtd);
-		return NULL;
+	if (!rtd->codec_dais)
+		goto free_rtd;
+
+	/*
+	 * for rtd->dev
+	 */
+	rtd->dev = kzalloc(sizeof(struct device), GFP_KERNEL);
+	if (!rtd->dev)
+		goto free_rtd;
+
+	rtd->dev->parent = card->dev;
+	rtd->dev->release = soc_release_rtd_dev;
+	rtd->dev->groups = soc_dev_attr_groups;
+
+	dev_set_name(rtd->dev, "%s", dai_link->name);
+	dev_set_drvdata(rtd->dev, rtd);
+
+	ret = device_register(rtd->dev);
+	if (ret < 0) {
+		put_device(rtd->dev); /* soc_release_rtd_dev */
+		rtd->dev = NULL;
+		goto free_rtd;
 	}
 
+	/*
+	 * rtd remaining settings
+	 */
 	INIT_LIST_HEAD(&rtd->component_list);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].be_clients);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].fe_clients);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].fe_clients);
+
 	rtd->card = card;
 	rtd->dai_link = dai_link;
 	if (!rtd->dai_link->ops)
@@ -391,7 +434,13 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	rtd->num = card->num_rtd;
 	card->num_rtd++;
 
+	rtd->dev_registered = 1;
+
 	return rtd;
+
+free_rtd:
+	soc_free_pcm_runtime(rtd);
+	return NULL;
 }
 
 static void soc_remove_pcm_runtimes(struct snd_soc_card *card)
@@ -1420,40 +1469,6 @@ static void soc_rtd_free(struct snd_soc_pcm_runtime *rtd)
 	}
 }
 
-static void soc_rtd_release(struct device *dev)
-{
-	kfree(dev);
-}
-
-static int soc_rtd_init(struct snd_soc_pcm_runtime *rtd, const char *name)
-{
-	int ret = 0;
-
-	/* register the rtd device */
-	rtd->dev = kzalloc(sizeof(struct device), GFP_KERNEL);
-	if (!rtd->dev)
-		return -ENOMEM;
-	rtd->dev->parent = rtd->card->dev;
-	rtd->dev->release = soc_rtd_release;
-	rtd->dev->groups = soc_dev_attr_groups;
-	dev_set_name(rtd->dev, "%s", name);
-	dev_set_drvdata(rtd->dev, rtd);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].be_clients);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].fe_clients);
-	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].fe_clients);
-	ret = device_register(rtd->dev);
-	if (ret < 0) {
-		/* calling put_device() here to free the rtd->dev */
-		put_device(rtd->dev);
-		dev_err(rtd->card->dev,
-			"ASoC: failed to register runtime device: %d\n", ret);
-		return ret;
-	}
-	rtd->dev_registered = 1;
-	return 0;
-}
-
 static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 				struct snd_soc_pcm_runtime *rtd)
 {
@@ -1503,10 +1518,6 @@ static int soc_link_init(struct snd_soc_card *card,
 			return ret;
 	}
 
-	ret = soc_rtd_init(rtd, dai_link->name);
-	if (ret)
-		return ret;
-
 	/* add DPCM sysfs entries */
 	soc_dpcm_debugfs_add(rtd);
 

commit 929deb849b9e4319015070ead7ca976a4f16e303
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 12 13:39:32 2019 +0900

    ASoC: soc-core: create rtd->codec_dais first
    
    soc_new_pcm_runtime() allocs rtd and rtd->codec_dais.
    This patch allocs both first, and setup these after that.
    This is prepare for soc_new_pcm_runtime() cleanup.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87blvqf7qz.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7a3f4783adf6..bc45b0db05ab 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -372,12 +372,6 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	if (!rtd)
 		return NULL;
 
-	INIT_LIST_HEAD(&rtd->component_list);
-	rtd->card = card;
-	rtd->dai_link = dai_link;
-	if (!rtd->dai_link->ops)
-		rtd->dai_link->ops = &null_snd_soc_ops;
-
 	rtd->codec_dais = kcalloc(dai_link->num_codecs,
 					sizeof(struct snd_soc_dai *),
 					GFP_KERNEL);
@@ -386,6 +380,12 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 		return NULL;
 	}
 
+	INIT_LIST_HEAD(&rtd->component_list);
+	rtd->card = card;
+	rtd->dai_link = dai_link;
+	if (!rtd->dai_link->ops)
+		rtd->dai_link->ops = &null_snd_soc_ops;
+
 	/* see for_each_card_rtds */
 	list_add_tail(&rtd->list, &card->rtd_list);
 	rtd->num = card->num_rtd;

commit 753ace0a34fbd39ac2ec654c6859823db420f69e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 12 13:38:50 2019 +0900

    ASoC: soc-core: call list_del(&rtd->list) at soc_free_pcm_runtime()
    
    Current ALSA SoC is calling list_del(&rtd->list) at (1)
    
            static void soc_remove_pcm_runtimes(...)
            {
                    ...
                    for_each_card_rtds_safe(card, rtd, _rtd) {
    (1)                     list_del(&rtd->list);
    (2)                     soc_free_pcm_runtime(rtd);
                    }
                    ...
            }
    
    But, we will call soc_free_pcm_runtime() after that (2).
    &rtd->list is         connected at soc_new_pcm_runtime(),
    Thus, it should be disconnected at soc_free_pcm_runtime().
    
    This patch calls list_del(&rtd->list) at soc_free_pcm_runtime().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87d0g6f7s5.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cadf96bc0097..7a3f4783adf6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -359,6 +359,7 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 {
 	kfree(rtd->codec_dais);
 	snd_soc_rtdcom_del_all(rtd);
+	list_del(&rtd->list);
 	kfree(rtd);
 }
 
@@ -397,10 +398,8 @@ static void soc_remove_pcm_runtimes(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd, *_rtd;
 
-	for_each_card_rtds_safe(card, rtd, _rtd) {
-		list_del(&rtd->list);
+	for_each_card_rtds_safe(card, rtd, _rtd)
 		soc_free_pcm_runtime(rtd);
-	}
 
 	card->num_rtd = 0;
 }

commit a848125e320a154dfc17b9a377361b4b0df87363
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 12 13:38:34 2019 +0900

    ASoC: soc-core: merge soc_add_pcm_runtime() into soc_new_pcm_runtime()
    
    We have soc_new_pcm_runtime() which allocs rtd and its related memory,
    and     soc_add_pcm_runtime() which connects rtd to card.
    
    But we don't need to separate these, we can alloc and connect rtd
    in the same time.
    
    Current implementation is just makes code complex.
    This patch merges these into one.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ef0mf7sl.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 96d38db8b578..cadf96bc0097 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -385,16 +385,12 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 		return NULL;
 	}
 
-	return rtd;
-}
-
-static void soc_add_pcm_runtime(struct snd_soc_card *card,
-		struct snd_soc_pcm_runtime *rtd)
-{
 	/* see for_each_card_rtds */
 	list_add_tail(&rtd->list, &card->rtd_list);
 	rtd->num = card->num_rtd;
 	card->num_rtd++;
+
+	return rtd;
 }
 
 static void soc_remove_pcm_runtimes(struct snd_soc_card *card)
@@ -930,7 +926,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 		}
 	}
 
-	soc_add_pcm_runtime(card, rtd);
 	return 0;
 
 _err_defer:

commit 1c93a9e00e40e3a084ebbcaa4a8f412b83f1fa0d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Sep 12 13:38:22 2019 +0900

    ASoC: soc-core: move soc_free_pcm_runtime()
    
    This patch moves soc_free_pcm_runtime() next to soc_new_pcm_runtime().
    This is prepare for soc_xxx_pcm_runtime() cleanup.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ftl2f7sx.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 88978a3036c4..96d38db8b578 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -355,6 +355,13 @@ EXPORT_SYMBOL_GPL(snd_soc_get_dai_substream);
 
 static const struct snd_soc_ops null_snd_soc_ops;
 
+static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
+{
+	kfree(rtd->codec_dais);
+	snd_soc_rtdcom_del_all(rtd);
+	kfree(rtd);
+}
+
 static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	struct snd_soc_card *card, struct snd_soc_dai_link *dai_link)
 {
@@ -381,13 +388,6 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	return rtd;
 }
 
-static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
-{
-	kfree(rtd->codec_dais);
-	snd_soc_rtdcom_del_all(rtd);
-	kfree(rtd);
-}
-
 static void soc_add_pcm_runtime(struct snd_soc_card *card,
 		struct snd_soc_pcm_runtime *rtd)
 {

commit 7a5d9815cc010b055c2a99ccf418c4629365fa43
Author: Bard liao <yung-chuan.liao@linux.intel.com>
Date:   Wed Sep 18 21:31:31 2019 +0800

    ASoC: core: use list_del_init and move it back to soc_cleanup_component
    
    commit a0a4bf57a977 ("ASoC: core: delete component->card_list in soc_remove_component only")
    was trying to fix a kernel oops when list_del was called twice without
    re-init the list. Use list_del_init() can solve it, too. Besides, it
    will be more readable if we cleanup all component related resource at
    soc_cleanup_component().
    
    Suggested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Bard liao <yung-chuan.liao@linux.intel.com>
    Link: https://lore.kernel.org/r/20190918133131.15045-1-yung-chuan.liao@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index aff4b4bf4d07..88978a3036c4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -978,6 +978,7 @@ static void soc_cleanup_component(struct snd_soc_component *component)
 	/* For framework level robustness */
 	snd_soc_component_set_jack(component, NULL, NULL);
 
+	list_del_init(&component->card_list);
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 	soc_cleanup_component_debugfs(component);
 	component->card = NULL;
@@ -990,7 +991,7 @@ static void soc_remove_component(struct snd_soc_component *component)
 		return;
 
 	snd_soc_component_remove(component);
-	list_del(&component->card_list);
+
 	soc_cleanup_component(component);
 }
 

commit a0a4bf57a977ed37bcbdfc8027a44485fe086a3d
Author: Bard Liao <yung-chuan.liao@linux.intel.com>
Date:   Tue Sep 17 05:03:53 2019 +0800

    ASoC: core: delete component->card_list in soc_remove_component only
    
    We add component->card_list in the end of soc_probe_component(). In
    other words, component->card_list will not be added if there is an
    error in the soc_probe_component() function. So we can't delete
    component->card_list in the error handling of soc_probe_component().
    
    Fixes: 22d1423187e5 ("ASoC: soc-core: add soc_cleanup_component()")
    Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20190916210353.6318-1-yung-chuan.liao@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 35f48e9c5ead..aff4b4bf4d07 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -978,7 +978,6 @@ static void soc_cleanup_component(struct snd_soc_component *component)
 	/* For framework level robustness */
 	snd_soc_component_set_jack(component, NULL, NULL);
 
-	list_del(&component->card_list);
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 	soc_cleanup_component_debugfs(component);
 	component->card = NULL;
@@ -991,7 +990,7 @@ static void soc_remove_component(struct snd_soc_component *component)
 		return;
 
 	snd_soc_component_remove(component);
-
+	list_del(&component->card_list);
 	soc_cleanup_component(component);
 }
 

commit e8fbd2505242467044ec51bf57c642a50ed28a14
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:15:40 2019 +0900

    ASoC: soc-core: self contained soc_unbind_aux_dev()
    
    Current soc_unbind_aux_dev() implementation is very half,
    thus it is very unreadable.
    
            for_each_comp_order(order) {
                    for_each_card_auxs_safe(card, comp, _comp) {
    
    (1)                     if (comp->driver->remove_order == order) {
                                    ...
    =>                              soc_unbind_aux_dev(comp);
                            }
            }
    
    soc_unbind_aux_dev() itself is not related to remove_order (1).
    And, it is called from soc_remove_aux_devices(), even though
    its paired function soc_bind_aux_dev() is called from
    snd_soc_instantiate_card().
    It is very unbalance, and very difficult to understand.
    
    This patch do
    1) update soc_bind_aux_dev() to self contained
    2) call it from soc_cleanup_card_resources() to make up balance
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87r24wor0z.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2960070e68bc..35f48e9c5ead 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1559,10 +1559,14 @@ static int soc_link_init(struct snd_soc_card *card,
 	return ret;
 }
 
-static void soc_unbind_aux_dev(struct snd_soc_component *component)
+static void soc_unbind_aux_dev(struct snd_soc_card *card)
 {
-	component->init = NULL;
-	list_del(&component->card_aux_list);
+	struct snd_soc_component *component, *_component;
+
+	for_each_card_auxs_safe(card, component, _component) {
+		component->init = NULL;
+		list_del(&component->card_aux_list);
+	}
 }
 
 static int soc_bind_aux_dev(struct snd_soc_card *card)
@@ -1614,12 +1618,8 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 
 	for_each_comp_order(order) {
 		for_each_card_auxs_safe(card, comp, _comp) {
-
-			if (comp->driver->remove_order == order) {
+			if (comp->driver->remove_order == order)
 				soc_remove_component(comp);
-				/* remove it from the card's aux_comp_list */
-				soc_unbind_aux_dev(comp);
-			}
 		}
 	}
 }
@@ -1932,6 +1932,7 @@ static void soc_cleanup_card_resources(struct snd_soc_card *card)
 
 	/* remove auxiliary devices */
 	soc_remove_aux_devices(card);
+	soc_unbind_aux_dev(card);
 
 	snd_soc_dapm_free(&card->dapm);
 	soc_cleanup_card_debugfs(card);

commit 4893a2eb34a9722501915a0b75844aa11956c10d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:15:35 2019 +0900

    ASoC: soc-core: add soc_unbind_aux_dev()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    soc-core.c has soc_bind_aux_dev(), but, there is no its paired
    soc_unbind_aux_dev().
    This patch adds soc_unbind_aux_dev().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87sgpcor14.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d7761df03e19..2960070e68bc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1559,6 +1559,12 @@ static int soc_link_init(struct snd_soc_card *card,
 	return ret;
 }
 
+static void soc_unbind_aux_dev(struct snd_soc_component *component)
+{
+	component->init = NULL;
+	list_del(&component->card_aux_list);
+}
+
 static int soc_bind_aux_dev(struct snd_soc_card *card)
 {
 	struct snd_soc_component *component;
@@ -1612,7 +1618,7 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 			if (comp->driver->remove_order == order) {
 				soc_remove_component(comp);
 				/* remove it from the card's aux_comp_list */
-				list_del(&comp->card_aux_list);
+				soc_unbind_aux_dev(comp);
 			}
 		}
 	}

commit bee886f1ea9d9e58bef8204c543a409c399f8744
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:15:28 2019 +0900

    ASoC: soc-core: self contained soc_bind_aux_dev()
    
    Current soc_bind_aux_dev() implementation is very half,
    thus it is very unreadable.
    
            for_each_card_pre_auxs(xxx) {
    =>              ret = soc_bind_aux_dev(xxx);
                    ...
            }
    
    This patch does all for_each_xxx() under soc_bind_aux_dev(),
    and makes it to self contained.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87tv9sor1b.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 20381f69a34b..d7761df03e19 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1559,20 +1559,22 @@ static int soc_link_init(struct snd_soc_card *card,
 	return ret;
 }
 
-static int soc_bind_aux_dev(struct snd_soc_card *card,
-			    struct snd_soc_aux_dev *aux_dev)
+static int soc_bind_aux_dev(struct snd_soc_card *card)
 {
 	struct snd_soc_component *component;
+	struct snd_soc_aux_dev *aux;
+	int i;
 
-	/* codecs, usually analog devices */
-	component = soc_find_component(&aux_dev->dlc);
-	if (!component)
-		return -EPROBE_DEFER;
-
-	component->init = aux_dev->init;
-	/* see for_each_card_auxs */
-	list_add(&component->card_aux_list, &card->aux_comp_list);
+	for_each_card_pre_auxs(card, i, aux) {
+		/* codecs, usually analog devices */
+		component = soc_find_component(&aux->dlc);
+		if (!component)
+			return -EPROBE_DEFER;
 
+		component->init = aux->init;
+		/* see for_each_card_auxs */
+		list_add(&component->card_aux_list, &card->aux_comp_list);
+	}
 	return 0;
 }
 
@@ -1937,7 +1939,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link *dai_link;
-	struct snd_soc_aux_dev *aux;
 	int ret, i;
 
 	mutex_lock(&client_mutex);
@@ -1965,11 +1966,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	/* bind aux_devs too */
-	for_each_card_pre_auxs(card, i, aux) {
-		ret = soc_bind_aux_dev(card, aux);
-		if (ret != 0)
-			goto probe_end;
-	}
+	ret = soc_bind_aux_dev(card);
+	if (ret < 0)
+		goto probe_end;
 
 	/* add predefined DAI links to the list */
 	for_each_card_prelinks(card, i, dai_link) {

commit bc7c16c226a919a509e4161c905bfe9981a17f02
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:15:23 2019 +0900

    ASoC: soc-core: move soc_probe_link_dais() next to soc_remove_link_dais()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    This patch moves soc_probe_link_dais() next to soc_remove_link_dais()
    which is paired function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87v9u8or1g.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 36b86e3c193c..20381f69a34b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1149,6 +1149,35 @@ static void soc_remove_link_dais(struct snd_soc_card *card)
 	}
 }
 
+static int soc_probe_link_dais(struct snd_soc_card *card)
+{
+	struct snd_soc_dai *codec_dai;
+	struct snd_soc_pcm_runtime *rtd;
+	int i, order, ret;
+
+	for_each_comp_order(order) {
+		for_each_card_rtds(card, rtd) {
+
+			dev_dbg(card->dev,
+				"ASoC: probe %s dai link %d late %d\n",
+				card->name, rtd->num, order);
+
+			ret = soc_probe_dai(rtd->cpu_dai, order);
+			if (ret)
+				return ret;
+
+			/* probe the CODEC DAI */
+			for_each_rtd_codec_dai(rtd, i, codec_dai) {
+				ret = soc_probe_dai(codec_dai, order);
+				if (ret)
+					return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
 static void soc_remove_link_components(struct snd_soc_card *card)
 {
 	struct snd_soc_component *component;
@@ -1452,35 +1481,6 @@ static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 	return 0;
 }
 
-static int soc_probe_link_dais(struct snd_soc_card *card)
-{
-	struct snd_soc_dai *codec_dai;
-	struct snd_soc_pcm_runtime *rtd;
-	int i, order, ret;
-
-	for_each_comp_order(order) {
-		for_each_card_rtds(card, rtd) {
-
-			dev_dbg(card->dev,
-				"ASoC: probe %s dai link %d late %d\n",
-				card->name, rtd->num, order);
-
-			ret = soc_probe_dai(rtd->cpu_dai, order);
-			if (ret)
-				return ret;
-
-			/* probe the CODEC DAI */
-			for_each_rtd_codec_dai(rtd, i, codec_dai) {
-				ret = soc_probe_dai(codec_dai, order);
-				if (ret)
-					return ret;
-			}
-		}
-	}
-
-	return 0;
-}
-
 static int soc_link_init(struct snd_soc_card *card,
 			 struct snd_soc_pcm_runtime *rtd)
 {

commit c7e73774f2f4213e75670f393a7b253620e04441
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:15:17 2019 +0900

    ASoC: soc-core: self contained soc_probe_link_dais()
    
    Current soc_probe_link_dais() implementation is very half,
    thus it is very difficult to read.
    
            for_each_comp_order(xxx) {
                    for_each_card_rtds(xxx)
    =>                      soc_probe_link_dais(xxx);
            }
    
    This patch does all for_each_xxx() under soc_probe_link_dais(),
    and makes it to self contained.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87woeoor1m.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1e74ab8e6a25..36b86e3c193c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1452,25 +1452,30 @@ static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 	return 0;
 }
 
-static int soc_probe_link_dais(struct snd_soc_card *card,
-		struct snd_soc_pcm_runtime *rtd, int order)
+static int soc_probe_link_dais(struct snd_soc_card *card)
 {
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_dai *codec_dai;
-	int i, ret;
+	struct snd_soc_pcm_runtime *rtd;
+	int i, order, ret;
 
-	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
-			card->name, rtd->num, order);
+	for_each_comp_order(order) {
+		for_each_card_rtds(card, rtd) {
 
-	ret = soc_probe_dai(cpu_dai, order);
-	if (ret)
-		return ret;
+			dev_dbg(card->dev,
+				"ASoC: probe %s dai link %d late %d\n",
+				card->name, rtd->num, order);
 
-	/* probe the CODEC DAI */
-	for_each_rtd_codec_dai(rtd, i, codec_dai) {
-		ret = soc_probe_dai(codec_dai, order);
-		if (ret)
-			return ret;
+			ret = soc_probe_dai(rtd->cpu_dai, order);
+			if (ret)
+				return ret;
+
+			/* probe the CODEC DAI */
+			for_each_rtd_codec_dai(rtd, i, codec_dai) {
+				ret = soc_probe_dai(codec_dai, order);
+				if (ret)
+					return ret;
+			}
+		}
 	}
 
 	return 0;
@@ -1933,7 +1938,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link *dai_link;
 	struct snd_soc_aux_dev *aux;
-	int ret, i, order;
+	int ret, i;
 
 	mutex_lock(&client_mutex);
 	for_each_card_prelinks(card, i, dai_link) {
@@ -2034,16 +2039,11 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	/* probe all DAI links on this card */
-	for_each_comp_order(order) {
-		for_each_card_rtds(card, rtd) {
-			ret = soc_probe_link_dais(card, rtd, order);
-			if (ret < 0) {
-				dev_err(card->dev,
-					"ASoC: failed to instantiate card %d\n",
-					ret);
-				goto probe_end;
-			}
-		}
+	ret = soc_probe_link_dais(card);
+	if (ret < 0) {
+		dev_err(card->dev,
+			"ASoC: failed to instantiate card %d\n", ret);
+		goto probe_end;
 	}
 
 	for_each_card_rtds(card, rtd)

commit c4b4698291a1d1c55665ae906779d1b685d5aa66
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:15:12 2019 +0900

    ASoC: soc-core: add new soc_link_init()
    
    Current soc_probe_link_dais() (1) is called under probe_order (2),
    and it will initialize dai_link related settings at *Last* turn (3)(B).
    It is very complex code.
    
            static int soc_probe_link_dais(..., order)
            {
    (A)             /* probe DAIs here */
                    ...
    
    (3)             if (order != SND_SOC_COMP_ORDER_LAST)
                            return 0;
    
    (B)             /* initialize dai_link related settings */
                    ...
            }
    
            static int snd_soc_instantiate_card(...)
            {
                    ...
    (2)             for_each_comp_order(order) {
                            for_each_card_rtds(...) {
    (1)                             ret = soc_probe_link_dais(..., order);
                            }
                    }
            }
    
    This patch separes soc_probe_link_dais() into "DAI probe" portion (A),
    and dai_link settings portion (B).
    The later is named as soc_link_init() by this patch.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87y2z4or1r.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3ca5a21bfa6a..1e74ab8e6a25 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1455,19 +1455,13 @@ static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 static int soc_probe_link_dais(struct snd_soc_card *card,
 		struct snd_soc_pcm_runtime *rtd, int order)
 {
-	struct snd_soc_dai_link *dai_link = rtd->dai_link;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_rtdcom_list *rtdcom;
-	struct snd_soc_component *component;
 	struct snd_soc_dai *codec_dai;
-	int i, ret, num;
+	int i, ret;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
 			card->name, rtd->num, order);
 
-	/* set default power off timeout */
-	rtd->pmdown_time = pmdown_time;
-
 	ret = soc_probe_dai(cpu_dai, order);
 	if (ret)
 		return ret;
@@ -1479,9 +1473,20 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 			return ret;
 	}
 
-	/* complete DAI probe during last probe */
-	if (order != SND_SOC_COMP_ORDER_LAST)
-		return 0;
+	return 0;
+}
+
+static int soc_link_init(struct snd_soc_card *card,
+			 struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *component;
+	int ret, num;
+
+	/* set default power off timeout */
+	rtd->pmdown_time = pmdown_time;
 
 	/* do machine specific initialization */
 	if (dai_link->init) {
@@ -2041,6 +2046,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
+	for_each_card_rtds(card, rtd)
+		soc_link_init(card, rtd);
+
 	snd_soc_dapm_link_dai_widgets(card);
 	snd_soc_dapm_connect_dai_link_widgets(card);
 

commit a7d44f78063d642406132c2ed1dc6033d0d03cfe
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:15:06 2019 +0900

    ASoC: soc-core: move soc_probe_dai() next to soc_remove_dai()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    This patch moves soc_probe_dai() next to soc_remove_dai() which is
    paired function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87zhjkor1x.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0a13f9461303..3ca5a21bfa6a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1106,6 +1106,26 @@ static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 	dai->probed = 0;
 }
 
+static int soc_probe_dai(struct snd_soc_dai *dai, int order)
+{
+	int ret;
+
+	if (dai->probed ||
+	    dai->driver->probe_order != order)
+		return 0;
+
+	ret = snd_soc_dai_probe(dai);
+	if (ret < 0) {
+		dev_err(dai->dev, "ASoC: failed to probe DAI %s: %d\n",
+			dai->name, ret);
+		return ret;
+	}
+
+	dai->probed = 1;
+
+	return 0;
+}
+
 static void soc_rtd_free(struct snd_soc_pcm_runtime *rtd); /* remove me */
 static void soc_remove_link_dais(struct snd_soc_card *card)
 {
@@ -1411,26 +1431,6 @@ static int soc_rtd_init(struct snd_soc_pcm_runtime *rtd, const char *name)
 	return 0;
 }
 
-static int soc_probe_dai(struct snd_soc_dai *dai, int order)
-{
-	int ret;
-
-	if (dai->probed ||
-	    dai->driver->probe_order != order)
-		return 0;
-
-	ret = snd_soc_dai_probe(dai);
-	if (ret < 0) {
-		dev_err(dai->dev, "ASoC: failed to probe DAI %s: %d\n",
-			dai->name, ret);
-		return ret;
-	}
-
-	dai->probed = 1;
-
-	return 0;
-}
-
 static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 				struct snd_soc_pcm_runtime *rtd)
 {

commit 4ca47d21bf7aa044c703688fa715862183dd6a3c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:14:57 2019 +0900

    ASoC: soc-core: self contained soc_remove_link_dais()
    
    Current soc_remove_link_dais() implementation is very half,
    thus it is very difficult to read.
    
            for_each_comp_order(xxx) {
                    for_each_card_rtds(xxx)
    =>                      soc_remove_link_dais(xxx);
            }
    
    This patch does all for_each_xxx() under soc_remove_link_dais(),
    and makes it to self contained.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/871rwwq5mm.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fbaf4dd597b5..0a13f9461303 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1107,20 +1107,26 @@ static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 }
 
 static void soc_rtd_free(struct snd_soc_pcm_runtime *rtd); /* remove me */
-static void soc_remove_link_dais(struct snd_soc_card *card,
-		struct snd_soc_pcm_runtime *rtd, int order)
+static void soc_remove_link_dais(struct snd_soc_card *card)
 {
 	int i;
 	struct snd_soc_dai *codec_dai;
+	struct snd_soc_pcm_runtime *rtd;
+	int order;
+
+	for_each_comp_order(order) {
+		for_each_card_rtds(card, rtd) {
 
-	/* finalize rtd device */
-	soc_rtd_free(rtd);
+			/* finalize rtd device */
+			soc_rtd_free(rtd);
 
-	/* remove the CODEC DAI */
-	for_each_rtd_codec_dai(rtd, i, codec_dai)
-		soc_remove_dai(codec_dai, order);
+			/* remove the CODEC DAI */
+			for_each_rtd_codec_dai(rtd, i, codec_dai)
+				soc_remove_dai(codec_dai, order);
 
-	soc_remove_dai(rtd->cpu_dai, order);
+			soc_remove_dai(rtd->cpu_dai, order);
+		}
+	}
 }
 
 static void soc_remove_link_components(struct snd_soc_card *card)
@@ -1171,14 +1177,9 @@ static int soc_probe_link_components(struct snd_soc_card *card)
 
 static void soc_remove_dai_links(struct snd_soc_card *card)
 {
-	int order;
-	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link *link, *_link;
 
-	for_each_comp_order(order) {
-		for_each_card_rtds(card, rtd)
-			soc_remove_link_dais(card, rtd, order);
-	}
+	soc_remove_link_dais(card);
 
 	soc_remove_link_components(card);
 

commit b006c0c6ed0dc779e64a8d7a25f5cf316fa3562c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:14:51 2019 +0900

    ASoC: soc-core: self contained soc_remove_link_components()
    
    Current soc_remove_link_components() implementation is very half,
    thus it is very difficult to read.
    
            for_each_comp_order(xxx) {
                    for_each_card_rtds(xxx)
    =>                      soc_remove_link_components(xxx);
            }
    
    This patch does all for_each_xxx() under soc_remove_link_components(),
    and makes it to self contained.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/8736hcq5ms.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 04b98e6c7b2a..fbaf4dd597b5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1123,17 +1123,24 @@ static void soc_remove_link_dais(struct snd_soc_card *card,
 	soc_remove_dai(rtd->cpu_dai, order);
 }
 
-static void soc_remove_link_components(struct snd_soc_card *card,
-	struct snd_soc_pcm_runtime *rtd, int order)
+static void soc_remove_link_components(struct snd_soc_card *card)
 {
 	struct snd_soc_component *component;
+	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_rtdcom_list *rtdcom;
+	int order;
 
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
+	for_each_comp_order(order) {
+		for_each_card_rtds(card, rtd) {
+			for_each_rtdcom(rtd, rtdcom) {
+				component = rtdcom->component;
+
+				if (component->driver->remove_order != order)
+					continue;
 
-		if (component->driver->remove_order == order)
-			soc_remove_component(component);
+				soc_remove_component(component);
+			}
+		}
 	}
 }
 
@@ -1173,10 +1180,7 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 			soc_remove_link_dais(card, rtd, order);
 	}
 
-	for_each_comp_order(order) {
-		for_each_card_rtds(card, rtd)
-			soc_remove_link_components(card, rtd, order);
-	}
+	soc_remove_link_components(card);
 
 	for_each_card_links_safe(card, link, _link) {
 		if (link->dobj.type == SND_SOC_DOBJ_DAI_LINK)
@@ -2394,20 +2398,13 @@ EXPORT_SYMBOL_GPL(snd_soc_register_card);
 
 static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 {
-	struct snd_soc_pcm_runtime *rtd;
-	int order;
-
 	if (card->instantiated) {
 		card->instantiated = false;
 		snd_soc_dapm_shutdown(card);
 		snd_soc_flush_all_delayed_work(card);
 
 		/* remove all components used by DAI links on this card */
-		for_each_comp_order(order) {
-			for_each_card_rtds(card, rtd) {
-				soc_remove_link_components(card, rtd, order);
-			}
-		}
+		soc_remove_link_components(card);
 
 		soc_cleanup_card_resources(card);
 		if (!unregister)

commit 62f07a6b6dbaf0e7196b6911111d4666b5d03518
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:14:46 2019 +0900

    ASoC: soc-core: self contained soc_probe_link_components()
    
    Current soc_probe_link_components() implementation is very half,
    thus it is very difficult to read.
    
            for_each_comp_order(xxx) {
                    for_each_card_rtds(xxx) {
    =>                      ret = soc_probe_link_components(xxx);
                            ...
                    }
            }
    
    This patch does all for_each_xxx() under soc_probe_link_components(),
    and makes it to self contained.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/874l1sq5mx.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 05a2aff843aa..04b98e6c7b2a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1137,20 +1137,25 @@ static void soc_remove_link_components(struct snd_soc_card *card,
 	}
 }
 
-static int soc_probe_link_components(struct snd_soc_card *card,
-				     struct snd_soc_pcm_runtime *rtd, int order)
+static int soc_probe_link_components(struct snd_soc_card *card)
 {
 	struct snd_soc_component *component;
+	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_rtdcom_list *rtdcom;
-	int ret;
+	int ret, order;
 
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
+	for_each_comp_order(order) {
+		for_each_card_rtds(card, rtd) {
+			for_each_rtdcom(rtd, rtdcom) {
+				component = rtdcom->component;
 
-		if (component->driver->probe_order == order) {
-			ret = soc_probe_component(card, component);
-			if (ret < 0)
-				return ret;
+				if (component->driver->probe_order != order)
+					continue;
+
+				ret = soc_probe_component(card, component);
+				if (ret < 0)
+					return ret;
+			}
 		}
 	}
 
@@ -1990,16 +1995,11 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	/* probe all components used by DAI links on this card */
-	for_each_comp_order(order) {
-		for_each_card_rtds(card, rtd) {
-			ret = soc_probe_link_components(card, rtd, order);
-			if (ret < 0) {
-				dev_err(card->dev,
-					"ASoC: failed to instantiate card %d\n",
-					ret);
-				goto probe_end;
-			}
-		}
+	ret = soc_probe_link_components(card);
+	if (ret < 0) {
+		dev_err(card->dev,
+			"ASoC: failed to instantiate card %d\n", ret);
+		goto probe_end;
 	}
 
 	/* probe auxiliary components */

commit 04f770d968344ca95b55cf7b50452888ec5440e7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 09:14:35 2019 +0900

    ASoC: soc-core: add comment to jack at soc_remove_component()
    
    Basically, driver which setups snd_soc_component_set_jack() need
    to release it by themselves. But, as framework level robustness,
    soc_remove_component() also releases it.
    
    To avoid code reader confuse, this patch makes it clarify.
    
    This patch makes it clarify.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/875zm8q5n8.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2a166abaade1..05a2aff843aa 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -975,7 +975,9 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 
 static void soc_cleanup_component(struct snd_soc_component *component)
 {
+	/* For framework level robustness */
 	snd_soc_component_set_jack(component, NULL, NULL);
+
 	list_del(&component->card_list);
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 	soc_cleanup_component_debugfs(component);

commit 6fb035502956ad1f338ca61c057653d5372ffd8c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 23 09:58:58 2019 +0900

    ASoC: soc-core: move soc_probe_link_components() position
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    soc_probe_link_components() has paired soc_remove_link_components(),
    but, these are implemented at different place.
    So it is difficult to confirm code.
    This patch moves soc_probe_link_components() next to
    soc_remove_link_components().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87o90g7lbd.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8e831ae59eb8..2a166abaade1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1135,6 +1135,26 @@ static void soc_remove_link_components(struct snd_soc_card *card,
 	}
 }
 
+static int soc_probe_link_components(struct snd_soc_card *card,
+				     struct snd_soc_pcm_runtime *rtd, int order)
+{
+	struct snd_soc_component *component;
+	struct snd_soc_rtdcom_list *rtdcom;
+	int ret;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
+
+		if (component->driver->probe_order == order) {
+			ret = soc_probe_component(card, component);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
 static void soc_remove_dai_links(struct snd_soc_card *card)
 {
 	int order;
@@ -1379,26 +1399,6 @@ static int soc_rtd_init(struct snd_soc_pcm_runtime *rtd, const char *name)
 	return 0;
 }
 
-static int soc_probe_link_components(struct snd_soc_card *card,
-				     struct snd_soc_pcm_runtime *rtd, int order)
-{
-	struct snd_soc_component *component;
-	struct snd_soc_rtdcom_list *rtdcom;
-	int ret;
-
-	for_each_rtdcom(rtd, rtdcom) {
-		component = rtdcom->component;
-
-		if (component->driver->probe_order == order) {
-			ret = soc_probe_component(card, component);
-			if (ret < 0)
-				return ret;
-		}
-	}
-
-	return 0;
-}
-
 static int soc_probe_dai(struct snd_soc_dai *dai, int order)
 {
 	int ret;

commit 95c267dd20431f0eb54ca204bd73a7d85c532a37
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 23 09:58:52 2019 +0900

    ASoC: soc-core: add snd_soc_dapm_init()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    soc-dapm has snd_soc_dapm_free() which cleanups debugfs, widgets, list.
    But, there is no paired initialize function.
    This patch adds snd_soc_dapm_init() and initilaizing dapm
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87pnkw7lbj.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 21c005a044e8..8e831ae59eb8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1023,14 +1023,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 
 	soc_init_component_debugfs(component);
 
-	INIT_LIST_HEAD(&dapm->list);
-	dapm->card		= card;
-	dapm->dev		= component->dev;
-	dapm->component		= component;
-	dapm->bias_level	= SND_SOC_BIAS_OFF;
-	dapm->idle_bias_off	= !component->driver->idle_bias_on;
-	dapm->suspend_bias_off	= component->driver->suspend_bias_off;
-	list_add(&dapm->list, &card->dapm_list);
+	snd_soc_dapm_init(dapm, card, component);
 
 	ret = snd_soc_dapm_new_controls(dapm,
 					component->driver->dapm_widgets,
@@ -1937,10 +1930,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
-	card->dapm.bias_level = SND_SOC_BIAS_OFF;
-	card->dapm.dev = card->dev;
-	card->dapm.card = card;
-	list_add(&card->dapm.list, &card->dapm_list);
+	snd_soc_dapm_init(&card->dapm, card, NULL);
 
 	/* check whether any platform is ignore machine FE and using topology */
 	soc_check_tplg_fes(card);

commit b614beafa495c7f6fbc15cb6977e3fe48beea1e5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 23 09:58:47 2019 +0900

    ASoC: soc-core: dapm related setup at one place
    
    Current ASoC setups some dapm related member at
    snd_soc_component_initialize() which is called when component was
    registered, and setups remaining member at soc_probe_component()
    which is called when component was probed.
    This kind of setup separation is no meanings, and it is very
    difficult to read and confusable.
    This patch setups all dapm settings at one place.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87r25c7lbo.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8fa1cfcc6f17..21c005a044e8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1019,12 +1019,19 @@ static int soc_probe_component(struct snd_soc_card *card,
 		return ret;
 
 	component->card = card;
-	dapm->card = card;
-	INIT_LIST_HEAD(&dapm->list);
 	soc_set_name_prefix(card, component);
 
 	soc_init_component_debugfs(component);
 
+	INIT_LIST_HEAD(&dapm->list);
+	dapm->card		= card;
+	dapm->dev		= component->dev;
+	dapm->component		= component;
+	dapm->bias_level	= SND_SOC_BIAS_OFF;
+	dapm->idle_bias_off	= !component->driver->idle_bias_on;
+	dapm->suspend_bias_off	= component->driver->suspend_bias_off;
+	list_add(&dapm->list, &card->dapm_list);
+
 	ret = snd_soc_dapm_new_controls(dapm,
 					component->driver->dapm_widgets,
 					component->driver->num_dapm_widgets);
@@ -1077,7 +1084,6 @@ static int soc_probe_component(struct snd_soc_card *card,
 	if (ret < 0)
 		goto err_probe;
 
-	list_add(&dapm->list, &card->dapm_list);
 	/* see for_each_card_components */
 	list_add(&component->card_list, &card->component_dev_list);
 
@@ -2649,8 +2655,6 @@ EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 static int snd_soc_component_initialize(struct snd_soc_component *component,
 	const struct snd_soc_component_driver *driver, struct device *dev)
 {
-	struct snd_soc_dapm_context *dapm;
-
 	INIT_LIST_HEAD(&component->dai_list);
 	INIT_LIST_HEAD(&component->dobj_list);
 	INIT_LIST_HEAD(&component->card_list);
@@ -2665,13 +2669,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->dev = dev;
 	component->driver = driver;
 
-	dapm = snd_soc_component_get_dapm(component);
-	dapm->dev = dev;
-	dapm->component = component;
-	dapm->bias_level = SND_SOC_BIAS_OFF;
-	dapm->idle_bias_off = !driver->idle_bias_on;
-	dapm->suspend_bias_off = driver->suspend_bias_off;
-
 	return 0;
 }
 

commit ffd60fba19d9752f553aac367cd40362011ab6c9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 23 09:58:42 2019 +0900

    ASoC: soc-core: move soc_probe_component() position
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    soc_probe_comonent() has paired soc_remove_comonent(),
    but, these are implemented at different place.
    So it is difficult to confirm code.
    This patch moves soc_probe_component() next to
    soc_remove_component().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87sgps7lbt.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3754a08baf62..8fa1cfcc6f17 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -938,6 +938,41 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	return -EPROBE_DEFER;
 }
 
+static void soc_set_of_name_prefix(struct snd_soc_component *component)
+{
+	struct device_node *of_node = soc_component_to_node(component);
+	const char *str;
+	int ret;
+
+	ret = of_property_read_string(of_node, "sound-name-prefix", &str);
+	if (!ret)
+		component->name_prefix = str;
+}
+
+static void soc_set_name_prefix(struct snd_soc_card *card,
+				struct snd_soc_component *component)
+{
+	int i;
+
+	for (i = 0; i < card->num_configs && card->codec_conf; i++) {
+		struct snd_soc_codec_conf *map = &card->codec_conf[i];
+		struct device_node *of_node = soc_component_to_node(component);
+
+		if (map->of_node && of_node != map->of_node)
+			continue;
+		if (map->dev_name && strcmp(component->name, map->dev_name))
+			continue;
+		component->name_prefix = map->name_prefix;
+		return;
+	}
+
+	/*
+	 * If there is no configuration table or no match in the table,
+	 * check if a prefix is provided in the node
+	 */
+	soc_set_of_name_prefix(component);
+}
+
 static void soc_cleanup_component(struct snd_soc_component *component)
 {
 	snd_soc_component_set_jack(component, NULL, NULL);
@@ -958,6 +993,101 @@ static void soc_remove_component(struct snd_soc_component *component)
 	soc_cleanup_component(component);
 }
 
+static int soc_probe_component(struct snd_soc_card *card,
+			       struct snd_soc_component *component)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	struct snd_soc_dai *dai;
+	int ret;
+
+	if (!strcmp(component->name, "snd-soc-dummy"))
+		return 0;
+
+	if (component->card) {
+		if (component->card != card) {
+			dev_err(component->dev,
+				"Trying to bind component to card \"%s\" but is already bound to card \"%s\"\n",
+				card->name, component->card->name);
+			return -ENODEV;
+		}
+		return 0;
+	}
+
+	ret = snd_soc_component_module_get_when_probe(component);
+	if (ret < 0)
+		return ret;
+
+	component->card = card;
+	dapm->card = card;
+	INIT_LIST_HEAD(&dapm->list);
+	soc_set_name_prefix(card, component);
+
+	soc_init_component_debugfs(component);
+
+	ret = snd_soc_dapm_new_controls(dapm,
+					component->driver->dapm_widgets,
+					component->driver->num_dapm_widgets);
+
+	if (ret != 0) {
+		dev_err(component->dev,
+			"Failed to create new controls %d\n", ret);
+		goto err_probe;
+	}
+
+	for_each_component_dais(component, dai) {
+		ret = snd_soc_dapm_new_dai_widgets(dapm, dai);
+		if (ret != 0) {
+			dev_err(component->dev,
+				"Failed to create DAI widgets %d\n", ret);
+			goto err_probe;
+		}
+	}
+
+	ret = snd_soc_component_probe(component);
+	if (ret < 0) {
+		dev_err(component->dev,
+			"ASoC: failed to probe component %d\n", ret);
+		goto err_probe;
+	}
+	WARN(dapm->idle_bias_off &&
+	     dapm->bias_level != SND_SOC_BIAS_OFF,
+	     "codec %s can not start from non-off bias with idle_bias_off==1\n",
+	     component->name);
+
+	/* machine specific init */
+	if (component->init) {
+		ret = component->init(component);
+		if (ret < 0) {
+			dev_err(component->dev,
+				"Failed to do machine specific init %d\n", ret);
+			goto err_probe;
+		}
+	}
+
+	ret = snd_soc_add_component_controls(component,
+					     component->driver->controls,
+					     component->driver->num_controls);
+	if (ret < 0)
+		goto err_probe;
+
+	ret = snd_soc_dapm_add_routes(dapm,
+				      component->driver->dapm_routes,
+				      component->driver->num_dapm_routes);
+	if (ret < 0)
+		goto err_probe;
+
+	list_add(&dapm->list, &card->dapm_list);
+	/* see for_each_card_components */
+	list_add(&component->card_list, &card->component_dev_list);
+
+err_probe:
+	if (ret < 0)
+		soc_cleanup_component(component);
+
+	return ret;
+}
+
 static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 {
 	int err;
@@ -1207,137 +1337,6 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
 
-static void soc_set_of_name_prefix(struct snd_soc_component *component)
-{
-	struct device_node *component_of_node = soc_component_to_node(component);
-	const char *str;
-	int ret;
-
-	ret = of_property_read_string(component_of_node, "sound-name-prefix",
-				      &str);
-	if (!ret)
-		component->name_prefix = str;
-}
-
-static void soc_set_name_prefix(struct snd_soc_card *card,
-				struct snd_soc_component *component)
-{
-	int i;
-
-	for (i = 0; i < card->num_configs && card->codec_conf; i++) {
-		struct snd_soc_codec_conf *map = &card->codec_conf[i];
-		struct device_node *component_of_node = soc_component_to_node(component);
-
-		if (map->of_node && component_of_node != map->of_node)
-			continue;
-		if (map->dev_name && strcmp(component->name, map->dev_name))
-			continue;
-		component->name_prefix = map->name_prefix;
-		return;
-	}
-
-	/*
-	 * If there is no configuration table or no match in the table,
-	 * check if a prefix is provided in the node
-	 */
-	soc_set_of_name_prefix(component);
-}
-
-static int soc_probe_component(struct snd_soc_card *card,
-	struct snd_soc_component *component)
-{
-	struct snd_soc_dapm_context *dapm =
-			snd_soc_component_get_dapm(component);
-	struct snd_soc_dai *dai;
-	int ret;
-
-	if (!strcmp(component->name, "snd-soc-dummy"))
-		return 0;
-
-	if (component->card) {
-		if (component->card != card) {
-			dev_err(component->dev,
-				"Trying to bind component to card \"%s\" but is already bound to card \"%s\"\n",
-				card->name, component->card->name);
-			return -ENODEV;
-		}
-		return 0;
-	}
-
-	ret = snd_soc_component_module_get_when_probe(component);
-	if (ret < 0)
-		return ret;
-
-	component->card = card;
-	dapm->card = card;
-	INIT_LIST_HEAD(&dapm->list);
-	soc_set_name_prefix(card, component);
-
-	soc_init_component_debugfs(component);
-
-	ret = snd_soc_dapm_new_controls(dapm,
-					component->driver->dapm_widgets,
-					component->driver->num_dapm_widgets);
-
-	if (ret != 0) {
-		dev_err(component->dev,
-			"Failed to create new controls %d\n", ret);
-		goto err_probe;
-	}
-
-	for_each_component_dais(component, dai) {
-		ret = snd_soc_dapm_new_dai_widgets(dapm, dai);
-		if (ret != 0) {
-			dev_err(component->dev,
-				"Failed to create DAI widgets %d\n", ret);
-			goto err_probe;
-		}
-	}
-
-	ret = snd_soc_component_probe(component);
-	if (ret < 0) {
-		dev_err(component->dev,
-			"ASoC: failed to probe component %d\n", ret);
-		goto err_probe;
-	}
-	WARN(dapm->idle_bias_off &&
-	     dapm->bias_level != SND_SOC_BIAS_OFF,
-	     "codec %s can not start from non-off bias with idle_bias_off==1\n",
-	     component->name);
-
-	/* machine specific init */
-	if (component->init) {
-		ret = component->init(component);
-		if (ret < 0) {
-			dev_err(component->dev,
-				"Failed to do machine specific init %d\n", ret);
-			goto err_probe;
-		}
-	}
-
-	ret = snd_soc_add_component_controls(component,
-					     component->driver->controls,
-					     component->driver->num_controls);
-	if (ret < 0)
-		goto err_probe;
-
-	ret = snd_soc_dapm_add_routes(dapm,
-				      component->driver->dapm_routes,
-				      component->driver->num_dapm_routes);
-	if (ret < 0)
-		goto err_probe;
-
-	list_add(&dapm->list, &card->dapm_list);
-	/* see for_each_card_components */
-	list_add(&component->card_list, &card->component_dev_list);
-
-err_probe:
-	if (ret < 0)
-		soc_cleanup_component(component);
-
-	return ret;
-}
-
 static void soc_rtd_free(struct snd_soc_pcm_runtime *rtd)
 {
 	if (rtd->dev_registered) {

commit 9a7c9fe1203eb360b3a01b65a18bcd0de6670c53
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 23 09:58:37 2019 +0900

    ASoC: soc-core: add soc_rtd_free()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    soc_rtd_init() was soc_post_component_init(), but there was no
    its paired soc_post_component_free(), but it is done at
    soc_remove_link_dais().
    This means it is difficult to find related code.
    
    This patch adds soc_rtd_free() which is paired soc_rtd_init().
    soc_rtd_xxx() will be more cleanuped in the future.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87tva87lby.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3c087b478398..3754a08baf62 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -975,17 +975,15 @@ static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 	dai->probed = 0;
 }
 
+static void soc_rtd_free(struct snd_soc_pcm_runtime *rtd); /* remove me */
 static void soc_remove_link_dais(struct snd_soc_card *card,
 		struct snd_soc_pcm_runtime *rtd, int order)
 {
 	int i;
 	struct snd_soc_dai *codec_dai;
 
-	/* unregister the rtd device */
-	if (rtd->dev_registered) {
-		device_unregister(rtd->dev);
-		rtd->dev_registered = 0;
-	}
+	/* finalize rtd device */
+	soc_rtd_free(rtd);
 
 	/* remove the CODEC DAI */
 	for_each_rtd_codec_dai(rtd, i, codec_dai)
@@ -1340,6 +1338,15 @@ static int soc_probe_component(struct snd_soc_card *card,
 	return ret;
 }
 
+static void soc_rtd_free(struct snd_soc_pcm_runtime *rtd)
+{
+	if (rtd->dev_registered) {
+		/* we don't need to call kfree() for rtd->dev */
+		device_unregister(rtd->dev);
+		rtd->dev_registered = 0;
+	}
+}
+
 static void soc_rtd_release(struct device *dev)
 {
 	kfree(dev);

commit 542694df7511977c3baa6ba855126a0cce883977
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 23 09:58:32 2019 +0900

    ASoC: soc-core: rename soc_post_component_init() to soc_rtd_init()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    It is easy to create bug at the such code, and it will be difficult to
    debug.
    
    From function name point of view, "soc_post_component_init()" sounds
    like "component initialize function".
    But in reality it is rtd setup function.
    
    This patch renames soc_post_component_init() to soc_rtd_init()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87v9uo7lc3.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0af83963289f..3c087b478398 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1340,13 +1340,12 @@ static int soc_probe_component(struct snd_soc_card *card,
 	return ret;
 }
 
-static void rtd_release(struct device *dev)
+static void soc_rtd_release(struct device *dev)
 {
 	kfree(dev);
 }
 
-static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
-	const char *name)
+static int soc_rtd_init(struct snd_soc_pcm_runtime *rtd, const char *name)
 {
 	int ret = 0;
 
@@ -1355,7 +1354,7 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 	if (!rtd->dev)
 		return -ENOMEM;
 	rtd->dev->parent = rtd->card->dev;
-	rtd->dev->release = rtd_release;
+	rtd->dev->release = soc_rtd_release;
 	rtd->dev->groups = soc_dev_attr_groups;
 	dev_set_name(rtd->dev, "%s", name);
 	dev_set_drvdata(rtd->dev, rtd);
@@ -1483,7 +1482,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 			return ret;
 	}
 
-	ret = soc_post_component_init(rtd, dai_link->name);
+	ret = soc_rtd_init(rtd, dai_link->name);
 	if (ret)
 		return ret;
 

commit 495efdb01f89a5fc53f9b2e61f5726d804d4a15d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 20 14:05:20 2019 +0900

    ASoC: soc-core: initialize list at one place
    
    Initialize component related list at random place is very difficult
    to read. This patch initialize it at snd_soc_component_initialize().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87y2zozazp.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1a17cb1bc03b..0af83963289f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1272,7 +1272,6 @@ static int soc_probe_component(struct snd_soc_card *card,
 
 	component->card = card;
 	dapm->card = card;
-	INIT_LIST_HEAD(&component->card_list);
 	INIT_LIST_HEAD(&dapm->list);
 	soc_set_name_prefix(card, component);
 
@@ -2648,6 +2647,8 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	struct snd_soc_dapm_context *dapm;
 
 	INIT_LIST_HEAD(&component->dai_list);
+	INIT_LIST_HEAD(&component->dobj_list);
+	INIT_LIST_HEAD(&component->card_list);
 	mutex_init(&component->io_mutex);
 
 	component->name = fmt_single_name(dev, &component->id);
@@ -2733,7 +2734,6 @@ static void snd_soc_component_add(struct snd_soc_component *component)
 
 	/* see for_each_component */
 	list_add(&component->list, &component_list);
-	INIT_LIST_HEAD(&component->dobj_list);
 
 	mutex_unlock(&client_mutex);
 }

commit 8d92bb516831e80fac916701447ee6e9f0a6f0f2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 20 14:05:16 2019 +0900

    ASoC: soc-core: initialize component list
    
    It might return without initializing in error case.
    In such case, uninitialized variable might be used at error handler.
    This patch initializes all necessary variable before return.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/87zhk4zazt.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1be069c2ac8d..1a17cb1bc03b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2647,6 +2647,9 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 {
 	struct snd_soc_dapm_context *dapm;
 
+	INIT_LIST_HEAD(&component->dai_list);
+	mutex_init(&component->io_mutex);
+
 	component->name = fmt_single_name(dev, &component->id);
 	if (!component->name) {
 		dev_err(dev, "ASoC: Failed to allocate name\n");
@@ -2663,9 +2666,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	dapm->idle_bias_off = !driver->idle_bias_on;
 	dapm->suspend_bias_off = driver->suspend_bias_off;
 
-	INIT_LIST_HEAD(&component->dai_list);
-	mutex_init(&component->io_mutex);
-
 	return 0;
 }
 

commit a4de83a385670c22c31e9bbb726595a447b32ba4
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 20 14:05:10 2019 +0900

    ASoC: soc-core: soc_cleanup_card_resources() become void
    
    There is no need to check return value for
    soc_cleanup_card_resources(). Let't makes it as void.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/871rxg1lda.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0ed6576bfef4..1be069c2ac8d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1885,7 +1885,7 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 	}
 }
 
-static int soc_cleanup_card_resources(struct snd_soc_card *card)
+static void soc_cleanup_card_resources(struct snd_soc_card *card)
 {
 	/* free the ALSA card at first; this syncs with pending operations */
 	if (card->snd_card) {
@@ -1906,8 +1906,6 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	/* remove the card */
 	if (card->remove)
 		card->remove(card);
-
-	return 0;
 }
 
 static int snd_soc_instantiate_card(struct snd_soc_card *card)

commit a33c0d166cc5bcb3b9718649b84974216709acb1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 20 14:05:02 2019 +0900

    ASoC: soc-core: add NOTE to snd_soc_rtdcom_lookup()
    
    We can find specified name component via snd_soc_rtdcom_lookup().
    But, it is not enough under multi CPU/Codec/Platform, because many
    components which have same driver name might be connected to same rtd.
    
    Not using this function as much as possible is best solution,
    but some drivers are already deeply depended to it.
    
    We can expand this function, for example having "num" which specifies
    found order at parameter, etc (In such case, it need to have fixed
    probing order).
    Or, use different driver name in such component, etc.
    
    We will have such issue if multi CPU/Codec/Platform were supported.
    To indicate it, this patch adds NOTE to this function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/874l2c1ldi.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3860d8521734..0ed6576bfef4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -315,6 +315,14 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 	if (!driver_name)
 		return NULL;
 
+	/*
+	 * NOTE
+	 *
+	 * snd_soc_rtdcom_lookup() will find component from rtd by using
+	 * specified driver name.
+	 * But, if many components which have same driver name are connected
+	 * to 1 rtd, this function will return 1st found component.
+	 */
 	for_each_rtdcom(rtd, rtdcom) {
 		const char *component_name = rtdcom->component->driver->name;
 

commit 4168ddabb480bef818c93f378428632fb681b500
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 20 14:04:49 2019 +0900

    ASoC: soc-core: use device_register()
    
    It is easy to read code if it is cleanly using paired function/naming,
    like start <-> stop, register <-> unregister, etc, etc.
    But, current ALSA SoC code is very random, unbalance, not paired, etc.
    
    soc-core.c is using device_unregiser(), but there is no its paired
    device_regiser(). We can find its code at soc_post_component_init()
    which is using device_initialize() and device_add().
    Here, device_initialize() + device_add() = device_register().
    
            -- linux/drivers/base/core.c --
            int device_register(struct device *dev)
            {
                    device_initialize(dev);
                    return device_add(dev);
            }
    
    device_initialize() is doing each dev member's initialization only,
    not related to device parent/release/groups.
    Thus, we can postpone it.
    let's use device_register() instead of device_initialize()/device_add().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/878sro1ldw.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6df880be1622..3860d8521734 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1347,7 +1347,6 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 	rtd->dev = kzalloc(sizeof(struct device), GFP_KERNEL);
 	if (!rtd->dev)
 		return -ENOMEM;
-	device_initialize(rtd->dev);
 	rtd->dev->parent = rtd->card->dev;
 	rtd->dev->release = rtd_release;
 	rtd->dev->groups = soc_dev_attr_groups;
@@ -1357,7 +1356,7 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].be_clients);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].fe_clients);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].fe_clients);
-	ret = device_add(rtd->dev);
+	ret = device_register(rtd->dev);
 	if (ret < 0) {
 		/* calling put_device() here to free the rtd->dev */
 		put_device(rtd->dev);

commit c26a8841119826badc8d358a4266880f83359f26
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 20 14:04:58 2019 +0900

    ASoC: soc-core: remove unneeded dai_link check from snd_soc_remove_dai_link()
    
    snd_soc_remove_dai_link() has card connected dai_link check. but
            1) we need to call list_del() anyway,
               because it is "remove" function,
            2) It is doing many thing for this card / dai_link already
               before checking dai_link.
    
    This patch removes poinless dai_link check
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/875zms1ldm.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d428491d51a7..6df880be1622 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1182,8 +1182,6 @@ EXPORT_SYMBOL_GPL(snd_soc_add_dai_link);
 void snd_soc_remove_dai_link(struct snd_soc_card *card,
 			     struct snd_soc_dai_link *dai_link)
 {
-	struct snd_soc_dai_link *link, *_link;
-
 	if (dai_link->dobj.type
 	    && dai_link->dobj.type != SND_SOC_DOBJ_DAI_LINK) {
 		dev_err(card->dev, "Invalid dai link type %d\n",
@@ -1199,12 +1197,7 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 	if (dai_link->dobj.type && card->remove_dai_link)
 		card->remove_dai_link(card, dai_link);
 
-	for_each_card_links_safe(card, link, _link) {
-		if (link == dai_link) {
-			list_del(&link->list);
-			return;
-		}
-	}
+	list_del(&dai_link->list);
 }
 EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
 

commit b03bfaec1d52123d5d941488f71e06964535e471
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 20 14:04:54 2019 +0900

    ASoC: soc-core: merge snd_soc_initialize_card_lists()
    
    snd_soc_initialize_card_lists() is doing card related
    INIT_LIST_HEAD(), but, it is already doing at
    snd_soc_register_card(). We don't need to do it separately.
    This patch merges these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Link: https://lore.kernel.org/r/877e781ldq.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b3f820fb53e6..d428491d51a7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2370,15 +2370,18 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 	dev_set_drvdata(card->dev, card);
 
-	snd_soc_initialize_card_lists(card);
-
+	INIT_LIST_HEAD(&card->widgets);
+	INIT_LIST_HEAD(&card->paths);
+	INIT_LIST_HEAD(&card->dapm_list);
+	INIT_LIST_HEAD(&card->aux_comp_list);
+	INIT_LIST_HEAD(&card->component_dev_list);
+	INIT_LIST_HEAD(&card->list);
 	INIT_LIST_HEAD(&card->dai_link_list);
-
 	INIT_LIST_HEAD(&card->rtd_list);
-	card->num_rtd = 0;
-
 	INIT_LIST_HEAD(&card->dapm_dirty);
 	INIT_LIST_HEAD(&card->dobj_list);
+
+	card->num_rtd = 0;
 	card->instantiated = 0;
 	mutex_init(&card->mutex);
 	mutex_init(&card->dapm_mutex);

commit 72b745e3ad65deac94ea4eb83262c52ba3ffdb5b
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Aug 13 13:45:32 2019 +0300

    ASoC: core: Move pcm_mutex up to card level from snd_soc_pcm_runtime
    
    The pcm_mutex is used to prevent concurrent execution of snd_pcm_ops
    callbacks. This works fine most of the cases but it can not handle setups
    when the same DAI is used by different rtd, for example:
    pcm3168a have two DAIs: one for Playback and one for Capture.
    If the codec is connected to a single CPU DAI we need to have two dai_link
    to support both playback and capture.
    
    In this case the snd_pcm_ops callbacks can be executed in parallel causing
    unexpected races in DAI drivers.
    
    By moving the pcm_mutex up to card level this can be solved
    while - hopefully - not breaking other setups.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20190813104532.16669-1-peter.ujfalusi@ti.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index abe2f47cee6e..b3f820fb53e6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1360,7 +1360,6 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 	rtd->dev->groups = soc_dev_attr_groups;
 	dev_set_name(rtd->dev, "%s", name);
 	dev_set_drvdata(rtd->dev, rtd);
-	mutex_init(&rtd->pcm_mutex);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].be_clients);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].fe_clients);
@@ -2383,6 +2382,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	card->instantiated = 0;
 	mutex_init(&card->mutex);
 	mutex_init(&card->dapm_mutex);
+	mutex_init(&card->pcm_mutex);
 	spin_lock_init(&card->dpcm_lock);
 
 	return snd_soc_bind_card(card);

commit 0faf1237c60a3791d7ff32035d3097d3e022e68f
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Aug 13 22:25:01 2019 +0800

    ASoC: soc-core: Fix -Wunused-const-variable warning
    
    If CONFIG_DMI is not set, gcc warns:
    
    sound/soc/soc-core.c:81:27: warning:
     dmi_blacklist defined but not used [-Wunused-const-variable=]
    
    Add #ifdef guard around it.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lore.kernel.org/r/20190813142501.13080-1-yuehaibing@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e9f44505cc3e..abe2f47cee6e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -73,6 +73,7 @@ static int pmdown_time = 5000;
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
+#ifdef CONFIG_DMI
 /*
  * If a DMI filed contain strings in this blacklist (e.g.
  * "Type2 - Board Manufacturer" or "Type1 - TBD by OEM"), it will be taken
@@ -87,6 +88,7 @@ static const char * const dmi_blacklist[] = {
 	"Board Product Name",
 	NULL,	/* terminator */
 };
+#endif
 
 static ssize_t pmdown_time_show(struct device *dev,
 				struct device_attribute *attr, char *buf)

commit c2b71c71037bea7765aa6ff37824520d19108769
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Aug 8 14:54:44 2019 +0900

    ASoC: soc-core: add for_each_xxx macro for aux_dev
    
    To be more readable code, this patch adds
    new for_each_xxx() macro for aux_dev.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ftmc6w8s.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4af382d52675..e9f44505cc3e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1533,9 +1533,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 	return ret;
 }
 
-static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
+static int soc_bind_aux_dev(struct snd_soc_card *card,
+			    struct snd_soc_aux_dev *aux_dev)
 {
-	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	struct snd_soc_component *component;
 
 	/* codecs, usually analog devices */
@@ -1544,6 +1544,7 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 		return -EPROBE_DEFER;
 
 	component->init = aux_dev->init;
+	/* see for_each_card_auxs */
 	list_add(&component->card_aux_list, &card->aux_comp_list);
 
 	return 0;
@@ -1556,7 +1557,7 @@ static int soc_probe_aux_devices(struct snd_soc_card *card)
 	int ret;
 
 	for_each_comp_order(order) {
-		list_for_each_entry(comp, &card->aux_comp_list, card_aux_list) {
+		for_each_card_auxs(card, comp) {
 			if (comp->driver->probe_order == order) {
 				ret = soc_probe_component(card,	comp);
 				if (ret < 0) {
@@ -1578,8 +1579,7 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 	int order;
 
 	for_each_comp_order(order) {
-		list_for_each_entry_safe(comp, _comp,
-			&card->aux_comp_list, card_aux_list) {
+		for_each_card_auxs_safe(card, comp, _comp) {
 
 			if (comp->driver->remove_order == order) {
 				soc_remove_component(comp);
@@ -1913,6 +1913,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link *dai_link;
+	struct snd_soc_aux_dev *aux;
 	int ret, i, order;
 
 	mutex_lock(&client_mutex);
@@ -1943,8 +1944,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	/* bind aux_devs too */
-	for (i = 0; i < card->num_aux_devs; i++) {
-		ret = soc_bind_aux_dev(card, i);
+	for_each_card_pre_auxs(card, i, aux) {
+		ret = soc_bind_aux_dev(card, aux);
 		if (ret != 0)
 			goto probe_end;
 	}

commit a48b561d873d1d9fda55782d275eff94ec647863
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Aug 8 14:54:39 2019 +0900

    ASoC: soc-core: remove legacy style of aux_dev
    
    Now all drivers are using snd_soc_dai_link_component for aux_dev.
    Let's remove legacy style
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87h86s6w8x.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 56b99e340dda..4af382d52675 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1538,12 +1538,6 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	struct snd_soc_component *component;
 
-	/* remove me */
-	if (aux_dev->codec_name)
-		aux_dev->dlc.name = aux_dev->codec_name;
-	if (aux_dev->codec_of_node)
-		aux_dev->dlc.of_node = aux_dev->codec_of_node;
-
 	/* codecs, usually analog devices */
 	component = soc_find_component(&aux_dev->dlc);
 	if (!component)

commit 3dc29b8b2062075602c7aff1514a120b4ed0187f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Aug 8 14:52:33 2019 +0900

    ASoC: soc-core: support snd_soc_dai_link_component for aux_dev
    
    To find aux_dev, ASoC is using .name, codec_name, codec_of_node.
    Here, .name is used to fallback in case of no codec.
    
    But, we already have this kind of component finding method by
    snd_soc_dai_link_component and soc_find_component().
    We shouldn't have duplicated implementation to do same things.
    This patch adds snd_soc_dai_link_component support to finding aux_dev.
    
    Now, no driver is using only .name.
    All drivers are using codec_name and/or codec_of_node.
    This means no driver is finding component from .name so far.
    (Actually almost all drivers are using .name as just "device name",
     not for finding component...)
    
    This patch
    1) add snd_soc_dai_link_component support for aux_dev. legacy style will
       be removed if all drivers are switched to new style.
    2) try to find component via snd_soc_dai_link_component.
       Then, it doesn't try to find via .name, because no driver is using
       it so far.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87y3046wcf.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bf45e60eb34f..56b99e340dda 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1537,38 +1537,22 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	struct snd_soc_component *component;
-	struct snd_soc_dai_link_component dlc;
 
-	if (aux_dev->codec_of_node || aux_dev->codec_name) {
-		/* codecs, usually analog devices */
-		dlc.name = aux_dev->codec_name;
-		dlc.of_node = aux_dev->codec_of_node;
-		component = soc_find_component(&dlc);
-		if (!component) {
-			if (dlc.of_node)
-				dlc.name = of_node_full_name(dlc.of_node);
-			goto err_defer;
-		}
-	} else if (aux_dev->name) {
-		/* generic components */
-		dlc.name = aux_dev->name;
-		dlc.of_node = NULL;
-		component = soc_find_component(&dlc);
-		if (!component)
-			goto err_defer;
-	} else {
-		dev_err(card->dev, "ASoC: Invalid auxiliary device\n");
-		return -EINVAL;
-	}
+	/* remove me */
+	if (aux_dev->codec_name)
+		aux_dev->dlc.name = aux_dev->codec_name;
+	if (aux_dev->codec_of_node)
+		aux_dev->dlc.of_node = aux_dev->codec_of_node;
+
+	/* codecs, usually analog devices */
+	component = soc_find_component(&aux_dev->dlc);
+	if (!component)
+		return -EPROBE_DEFER;
 
 	component->init = aux_dev->init;
 	list_add(&component->card_aux_list, &card->aux_comp_list);
 
 	return 0;
-
-err_defer:
-	dev_err(card->dev, "ASoC: %s not registered\n", dlc.name);
-	return -EPROBE_DEFER;
 }
 
 static int soc_probe_aux_devices(struct snd_soc_card *card)

commit 0e36f36b04e7677c6b74349c9d4baea1ed5668f2
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Wed Aug 7 21:51:31 2019 -0500

    ASoC: soc-core: fix module_put() warning in soc_cleanup_component
    
    The recent changes introduce warnings in the SOF load/unload module
    tests. The code does not seem balanced with a confusion between
    _close() and _remove() macros. Using _remove() fixes the issue and
    removes the warning.
    
    Suggested-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Fixes: 4a81e8f30d0b4 ('ASoC: soc-component: add snd_soc_component_get/put()')
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/20190808025131.32482-1-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1fbd525763d5..bf45e60eb34f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -935,7 +935,7 @@ static void soc_cleanup_component(struct snd_soc_component *component)
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 	soc_cleanup_component_debugfs(component);
 	component->card = NULL;
-	snd_soc_component_module_put_when_close(component);
+	snd_soc_component_module_put_when_remove(component);
 }
 
 static void soc_remove_component(struct snd_soc_component *component)

commit 596becd3f82a7b7e091b0f5c380bc9a0e6758126
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:31:36 2019 +0900

    ASoC: soc-core: dai_link check under soc_dpcm_debugfs_add()
    
    soc_dpcm_debugfs_add(rtd) is checking rtd->dai_link pointer,
    but, rtd->dai_link->dynamic have been already checked before calling it.
    
            static int soc_probe_link_dais(...) {
                    dai_link = rtd->dai_link;
                    ...
    =>              if (dai_link->dynamic)
    =>                      soc_dpcm_debugfs_add(rtd);
                    ...
            }
    
            void soc_dpcm_debugfs_add(rtd)
            {
    =>              if (!rtd->dai_link)
                            return;
                    ...
            }
    
    These pointer checks are strange/pointless.
    This patch checks dai_link->dynamic under soc_dpcm_debugfs_add().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/874l2tahnq.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2a75fba31aa4..1fbd525763d5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1488,8 +1488,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 		return ret;
 
 	/* add DPCM sysfs entries */
-	if (dai_link->dynamic)
-		soc_dpcm_debugfs_add(rtd);
+	soc_dpcm_debugfs_add(rtd);
 
 	num = rtd->num;
 

commit ee5b3f11416d1ba69e919b2fe86aae0b46f9a83e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:31:31 2019 +0900

    ASoC: soc-core: define soc_dpcm_debugfs_add() for non CONFIG_DEBUG_FS
    
    soc_dpcm_debugfs_add() is implemented at soc-pcm.c under CONFIG_DEBUG_FS.
    Thus, soc-core.c which is only user of it need to use CONFIG_DEBUG_FS, too.
    
    This patch defines soc_dpcm_debugfs_add() for non CONFIG_DEBUG_FS case.
    Then, we can remove #ifdef CONFIG_DEBUG_FS from soc-core.c
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/875zn9ahnv.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 25b26caea4e0..2a75fba31aa4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1487,11 +1487,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 	if (ret)
 		return ret;
 
-#ifdef CONFIG_DEBUG_FS
 	/* add DPCM sysfs entries */
 	if (dai_link->dynamic)
 		soc_dpcm_debugfs_add(rtd);
-#endif
 
 	num = rtd->num;
 

commit b3da42519c3e6ad977af844d61c31d0e5f874f1c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:31:24 2019 +0900

    ASoC: soc-core: tidyup for card->deferred_resume_work
    
    card->deferred_resume_work is used if CONFIG_PM_SLEEP was defined.
    but
            1) It is defined even though CONFIG_PM_SLEEP was not defined
            2) random ifdef code is difficult to read.
    This patch tidyup these issues.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/877e7paho1.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6b0042835233..25b26caea4e0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -701,9 +701,18 @@ int snd_soc_resume(struct device *dev)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_resume);
+
+static void soc_resume_init(struct snd_soc_card *card)
+{
+	/* deferred resume work */
+	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
+}
 #else
 #define snd_soc_suspend NULL
 #define snd_soc_resume NULL
+static inline void soc_resume_init(struct snd_soc_card *card)
+{
+}
 #endif
 
 static const struct snd_soc_dai_ops null_dai_ops = {
@@ -1984,10 +1993,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	soc_init_card_debugfs(card);
 
-#ifdef CONFIG_PM_SLEEP
-	/* deferred resume work */
-	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
-#endif
+	soc_resume_init(card);
 
 	ret = snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
 					card->num_dapm_widgets);

commit b245d273cbcd64eeaa93305f99c4ea8a6baf9c89
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:31:19 2019 +0900

    ASoC: soc-core: remove unneeded list_empty() check for snd_soc_try_rebind_card()
    
    list_for_each_entry_safe() will do nothing if it was empty list.
    This patch removes unneeded list_empty() check for
    list_for_each_entry_safe().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/878ss5aho6.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cf3d967d731e..6b0042835233 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2808,12 +2808,9 @@ static void snd_soc_try_rebind_card(void)
 {
 	struct snd_soc_card *card, *c;
 
-	if (!list_empty(&unbind_card_list)) {
-		list_for_each_entry_safe(card, c, &unbind_card_list, list) {
-			if (!snd_soc_bind_card(card))
-				list_del(&card->list);
-		}
-	}
+	list_for_each_entry_safe(card, c, &unbind_card_list, list)
+		if (!snd_soc_bind_card(card))
+			list_del(&card->list);
 }
 
 int snd_soc_add_component(struct device *dev,

commit d8ca7a0a8583fc491b625450580c4092879af3dd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:31:14 2019 +0900

    ASoC: soc-core: call snd_soc_dapm_debugfs_init() at soc_init_card_debugfs()
    
    We have 2 soc_init_card_debugfs() implementations for with/without DEBUG_FS.
    But, snd_soc_instantiate_card() calls snd_soc_dapm_debugfs_init() under
    ifdef DEBUG_FS after soc_init_card_debugfs(). This is very strange.
    We can call snd_soc_dapm_debugfs_init() under soc_init_card_debugfs().
    
            #ifdef CONFIG_DEBUG_FS
    =>      static void soc_init_card_debugfs(...)
            {
                    ...
            }
            ...
            #else
    =>      static inline void soc_init_card_debugfs(...)
            {
                    ...
            }
            #endif
    
            static int snd_soc_instantiate_card(struct snd_soc_card *card)
            {
                    ...
    =>              soc_init_card_debugfs(card);
    
    *       #ifdef CONFIG_DEBUG_FS
    *               snd_soc_dapm_debugfs_init(&card->dapm, card->debugfs_card_root);
    *       #endif
            }
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87a7clahob.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4b9ae867613c..cf3d967d731e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -216,6 +216,8 @@ static void soc_init_card_debugfs(struct snd_soc_card *card)
 
 	debugfs_create_u32("dapm_pop_time", 0644, card->debugfs_card_root,
 			   &card->pop_time);
+
+	snd_soc_dapm_debugfs_init(&card->dapm, card->debugfs_card_root);
 }
 
 static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
@@ -1982,10 +1984,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	soc_init_card_debugfs(card);
 
-#ifdef CONFIG_DEBUG_FS
-	snd_soc_dapm_debugfs_init(&card->dapm, card->debugfs_card_root);
-#endif
-
 #ifdef CONFIG_PM_SLEEP
 	/* deferred resume work */
 	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);

commit 9b98c7c2a0599084c7ed629b5f88f474d2578307
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:31:08 2019 +0900

    ASoC: soc-core: tidyup for snd_soc_add_card_controls()
    
    snd_soc_add_card_controls() registers controls by using
    for(... i < num; ...). If controls was NULL, num should be zero.
    Thus, we don't need to check about controls pointer.
    This patch also cares missing return value.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87blx1ahoi.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index de95b68ce9ee..4b9ae867613c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2058,9 +2058,10 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	snd_soc_dapm_link_dai_widgets(card);
 	snd_soc_dapm_connect_dai_link_widgets(card);
 
-	if (card->controls)
-		snd_soc_add_card_controls(card, card->controls,
-					  card->num_controls);
+	ret = snd_soc_add_card_controls(card, card->controls,
+					card->num_controls);
+	if (ret < 0)
+		goto probe_end;
 
 	ret = snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 				      card->num_dapm_routes);

commit daa480bde6b3a9b728965e52efffc329ccee3f77
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:31:03 2019 +0900

    ASoC: soc-core: tidyup for snd_soc_dapm_add_routes()
    
    snd_soc_dapm_add_routes() registers routes by using
    for(... i < num; ...). If routes was NULL, num should be zero.
    Thus, we don't need to check about route pointer.
    This patch also cares missing return value.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87d0hhahon.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e481f9999bfb..de95b68ce9ee 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1310,10 +1310,11 @@ static int soc_probe_component(struct snd_soc_card *card,
 	if (ret < 0)
 		goto err_probe;
 
-	if (component->driver->dapm_routes)
-		snd_soc_dapm_add_routes(dapm,
-					component->driver->dapm_routes,
-					component->driver->num_dapm_routes);
+	ret = snd_soc_dapm_add_routes(dapm,
+				      component->driver->dapm_routes,
+				      component->driver->num_dapm_routes);
+	if (ret < 0)
+		goto err_probe;
 
 	list_add(&dapm->list, &card->dapm_list);
 	/* see for_each_card_components */
@@ -2061,13 +2062,15 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_add_card_controls(card, card->controls,
 					  card->num_controls);
 
-	if (card->dapm_routes)
-		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
-					card->num_dapm_routes);
+	ret = snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
+				      card->num_dapm_routes);
+	if (ret < 0)
+		goto probe_end;
 
-	if (card->of_dapm_routes)
-		snd_soc_dapm_add_routes(&card->dapm, card->of_dapm_routes,
-					card->num_of_dapm_routes);
+	ret = snd_soc_dapm_add_routes(&card->dapm, card->of_dapm_routes,
+				      card->num_of_dapm_routes);
+	if (ret < 0)
+		goto probe_end;
 
 	/* try to set some sane longname if DMI is available */
 	snd_soc_set_dmi_name(card, NULL);

commit e6d7020c2946bef2efab7c70339eee6a6b3cb6a6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:30:58 2019 +0900

    ASoC: soc-core: tidyup for snd_soc_add_component_controls()
    
    snd_soc_add_component_controls() registers controls by using
    for(... i < num; ...). If controls was NULL, num should be zero.
    Thus, we don't need to check about controls pointer.
    This patch also cares missing return value.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ef1xahor.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bb1e9e2c4ff4..e481f9999bfb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1304,10 +1304,12 @@ static int soc_probe_component(struct snd_soc_card *card,
 		}
 	}
 
-	if (component->driver->controls)
-		snd_soc_add_component_controls(component,
-					       component->driver->controls,
-					       component->driver->num_controls);
+	ret = snd_soc_add_component_controls(component,
+					     component->driver->controls,
+					     component->driver->num_controls);
+	if (ret < 0)
+		goto err_probe;
+
 	if (component->driver->dapm_routes)
 		snd_soc_dapm_add_routes(dapm,
 					component->driver->dapm_routes,

commit b8ba3b572c70c8559ef76c1e0ca02e7b05126e8c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:30:53 2019 +0900

    ASoC: soc-core: tidyup for snd_soc_dapm_new_controls()
    
    snd_soc_dapm_new_controls() registers controls by using
    for(... i < num; ...). It means if widget was NULL, num should be zero.
    Thus, we don't need to check about widget pointer.
    This patch also cares missing return value.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ftmdahow.wl-kuninori.morimoto.gx@renesas.com
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d12054ab8741..bb1e9e2c4ff4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1264,16 +1264,14 @@ static int soc_probe_component(struct snd_soc_card *card,
 
 	soc_init_component_debugfs(component);
 
-	if (component->driver->dapm_widgets) {
-		ret = snd_soc_dapm_new_controls(dapm,
+	ret = snd_soc_dapm_new_controls(dapm,
 					component->driver->dapm_widgets,
 					component->driver->num_dapm_widgets);
 
-		if (ret != 0) {
-			dev_err(component->dev,
-				"Failed to create new controls %d\n", ret);
-			goto err_probe;
-		}
+	if (ret != 0) {
+		dev_err(component->dev,
+			"Failed to create new controls %d\n", ret);
+		goto err_probe;
 	}
 
 	for_each_component_dais(component, dai) {
@@ -1990,13 +1988,15 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
 #endif
 
-	if (card->dapm_widgets)
-		snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
-					  card->num_dapm_widgets);
+	ret = snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
+					card->num_dapm_widgets);
+	if (ret < 0)
+		goto probe_end;
 
-	if (card->of_dapm_widgets)
-		snd_soc_dapm_new_controls(&card->dapm, card->of_dapm_widgets,
-					  card->num_of_dapm_widgets);
+	ret = snd_soc_dapm_new_controls(&card->dapm, card->of_dapm_widgets,
+					card->num_of_dapm_widgets);
+	if (ret < 0)
+		goto probe_end;
 
 	/* initialise the sound card only once */
 	if (card->probe) {

commit 32d2c172fe88705058310635a732259c0a98e89b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:30:47 2019 +0900

    ASoC: soc-core: reuse rtdcom at snd_soc_rtdcom_add()
    
    snd_soc_rtdcom_add() is using both "rtdcom" and "new_rtdcom" as
    variable name, but these are not used at same time.
    Let's reuse rtdcom.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87h86tahp2.wl-kuninori.morimoto.gx@renesas.com
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e176b972e4e6..d12054ab8741 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -274,7 +274,6 @@ static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 			      struct snd_soc_component *component)
 {
 	struct snd_soc_rtdcom_list *rtdcom;
-	struct snd_soc_rtdcom_list *new_rtdcom;
 
 	for_each_rtdcom(rtd, rtdcom) {
 		/* already connected */
@@ -282,14 +281,14 @@ static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 			return 0;
 	}
 
-	new_rtdcom = kmalloc(sizeof(*new_rtdcom), GFP_KERNEL);
-	if (!new_rtdcom)
+	rtdcom = kmalloc(sizeof(*rtdcom), GFP_KERNEL);
+	if (!rtdcom)
 		return -ENOMEM;
 
-	new_rtdcom->component = component;
-	INIT_LIST_HEAD(&new_rtdcom->list);
+	rtdcom->component = component;
+	INIT_LIST_HEAD(&rtdcom->list);
 
-	list_add_tail(&new_rtdcom->list, &rtd->component_list);
+	list_add_tail(&rtdcom->list, &rtd->component_list);
 
 	return 0;
 }

commit 42849064500b24892e2abfe8679507dfffd585f1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:30:41 2019 +0900

    ASoC: soc-core: don't use for_each_card_links_safe() at snd_soc_find_dai_link()
    
    It doesn't removes list during loop at snd_soc_find_dai_link().
    We don't need to use _safe loop.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87imr9ahp9.wl-kuninori.morimoto.gx@renesas.com
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7345679d4903..e176b972e4e6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -817,11 +817,11 @@ struct snd_soc_dai_link *snd_soc_find_dai_link(struct snd_soc_card *card,
 					       int id, const char *name,
 					       const char *stream_name)
 {
-	struct snd_soc_dai_link *link, *_link;
+	struct snd_soc_dai_link *link;
 
 	lockdep_assert_held(&client_mutex);
 
-	for_each_card_links_safe(card, link, _link) {
+	for_each_card_links(card, link) {
 		if (link->id != id)
 			continue;
 

commit 5b99a0aad08a3428cc3262ecee29a71c88c981c2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:30:36 2019 +0900

    ASoC: soc-core: check return value of snd_soc_add_dai_link()
    
    snd_soc_add_dai_link() might return error, we need to check it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87k1bpahpd.wl-kuninori.morimoto.gx@renesas.com
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5e6a48a0f79e..7345679d4903 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1964,8 +1964,11 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	/* add predefined DAI links to the list */
-	for_each_card_prelinks(card, i, dai_link)
-		snd_soc_add_dai_link(card, dai_link);
+	for_each_card_prelinks(card, i, dai_link) {
+		ret = snd_soc_add_dai_link(card, dai_link);
+		if (ret < 0)
+			goto probe_end;
+	}
 
 	/* card bind complete so register a sound card */
 	ret = snd_card_new(card->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,

commit 6634e3d6ea8cd92fce10d1d2da0c8e42ab84da32
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:30:31 2019 +0900

    ASoC: soc-core: add comment for for_each_xxx
    
    soc-core has many for_each_xxx, but it is a little bit
    difficult to know which list is relead to which for_each_xxx.
    This patch adds missing comment for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87lfw5ahpj.wl-kuninori.morimoto.gx@renesas.com
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2f37c4e0974b..5e6a48a0f79e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -380,6 +380,7 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 static void soc_add_pcm_runtime(struct snd_soc_card *card,
 		struct snd_soc_pcm_runtime *rtd)
 {
+	/* see for_each_card_rtds */
 	list_add_tail(&rtd->list, &card->rtd_list);
 	rtd->num = card->num_rtd;
 	card->num_rtd++;
@@ -1149,6 +1150,7 @@ int snd_soc_add_dai_link(struct snd_soc_card *card,
 	if (dai_link->dobj.type && card->add_dai_link)
 		card->add_dai_link(card, dai_link);
 
+	/* see for_each_card_links */
 	list_add_tail(&dai_link->list, &card->dai_link_list);
 
 	return 0;

commit ad64bfbd09d7b7997a1b1510983350836bcd6ed9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Aug 7 10:30:13 2019 +0900

    ASoC: soc-core: set component->debugfs_root NULL
    
    To be more safety code, let's set NULL to component->debugfs_root
    when it was cleanuped.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87muglahq0.wl-kuninori.morimoto.gx@renesas.com
    Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0f75dac4bb26..2f37c4e0974b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -171,7 +171,10 @@ static void soc_init_component_debugfs(struct snd_soc_component *component)
 
 static void soc_cleanup_component_debugfs(struct snd_soc_component *component)
 {
+	if (!component->debugfs_root)
+		return;
 	debugfs_remove_recursive(component->debugfs_root);
+	component->debugfs_root = NULL;
 }
 
 static int dai_list_show(struct seq_file *m, void *v)

commit 7951b14611851bdae18e9bca18015b1d84731d0d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:43 2019 +0900

    ASoC: soc-component: move snd_soc_component_set_bias_level()
    
    Current soc-dapm / soc-core are using a long way round to call
    .set_bias_level.
    
            if (driver->set_bias_level)
                    dapm->set_bias_level = ...;
            ...
            if (dapm->set_bias_level)
                    ret = dapm->set_bias_level(...);
    
    We can directly call it via driver->set_bias_level.
    One note here is that both Card and Component have dapm,
    but, Card's dapm doesn't have dapm->component.
    We need to check it.
    
    This patch moves snd_soc_component_set_bias_level() to soc-component.c
    and updates parameters.
    dapm->set_bias_level is no longer needed
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87tvb94d0n.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8cfbe5fb5921..0f75dac4bb26 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2646,14 +2646,6 @@ int snd_soc_register_dai(struct snd_soc_component *component,
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 
-static int snd_soc_component_set_bias_level(struct snd_soc_dapm_context *dapm,
-					enum snd_soc_bias_level level)
-{
-	struct snd_soc_component *component = dapm->component;
-
-	return component->driver->set_bias_level(component, level);
-}
-
 static int snd_soc_component_initialize(struct snd_soc_component *component,
 	const struct snd_soc_component_driver *driver, struct device *dev)
 {
@@ -2674,8 +2666,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	dapm->bias_level = SND_SOC_BIAS_OFF;
 	dapm->idle_bias_off = !driver->idle_bias_on;
 	dapm->suspend_bias_off = driver->suspend_bias_off;
-	if (driver->set_bias_level)
-		dapm->set_bias_level = snd_soc_component_set_bias_level;
 
 	INIT_LIST_HEAD(&component->dai_list);
 	mutex_init(&component->io_mutex);

commit 8e2a990d76aced95c6f01c2d67d8835c86f0ca67
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:39 2019 +0900

    ASoC: soc-component: move snd_soc_component_stream_event()
    
    Current soc-dapm / soc-core are using a long way round to call
    .stream_event.
    
            if (driver->stream_event)
                    dapm->stream_event = ...;
            ...
            if (dapm->stream_event)
                    ret = dapm->stream_event(...);
    
    We can directly call it via driver->stream_event.
    One note here is that both Card and Component have dapm,
    but, Card's dapm doesn't have dapm->component.
    We need to check it.
    
    This patch moves snd_soc_component_stream_event() to soc-component.c
    and updates parameters.
    dapm->stream_event is no longer needed
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87v9vp4d0r.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c618fecc3d45..8cfbe5fb5921 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2646,14 +2646,6 @@ int snd_soc_register_dai(struct snd_soc_component *component,
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 
-static int snd_soc_component_stream_event(struct snd_soc_dapm_context *dapm,
-	int event)
-{
-	struct snd_soc_component *component = dapm->component;
-
-	return component->driver->stream_event(component, event);
-}
-
 static int snd_soc_component_set_bias_level(struct snd_soc_dapm_context *dapm,
 					enum snd_soc_bias_level level)
 {
@@ -2682,8 +2674,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	dapm->bias_level = SND_SOC_BIAS_OFF;
 	dapm->idle_bias_off = !driver->idle_bias_on;
 	dapm->suspend_bias_off = driver->suspend_bias_off;
-	if (driver->stream_event)
-		dapm->stream_event = snd_soc_component_stream_event;
 	if (driver->set_bias_level)
 		dapm->set_bias_level = snd_soc_component_set_bias_level;
 

commit 9d415fbf773f162a5c274e671741c6fa94b74287
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:35 2019 +0900

    ASoC: soc-component: move snd_soc_component_seq_notifier()
    
    Current soc-dapm / soc-core are using a long way round to call
    .seq_notifier.
    
            if (driver->seq_notifier)
                    dapm->seq_notifier = ...;
            ...
            if (dapm->seq_notifier)
                    ret = dapm->seq_notifier(...);
    
    We can directly call it via driver->seq_notifier.
    One note here is that both Card and Component have dapm,
    but, Card's dapm doesn't have dapm->component.
    We need to check it.
    
    This patch moves snd_soc_component_seq_notifier() to soc-component.c,
    and updates parameters.
    dapm->seq_notifier is no longer needed
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87wog54d0v.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2f068c239f34..c618fecc3d45 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2646,14 +2646,6 @@ int snd_soc_register_dai(struct snd_soc_component *component,
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 
-static void snd_soc_component_seq_notifier(struct snd_soc_dapm_context *dapm,
-	enum snd_soc_dapm_type type, int subseq)
-{
-	struct snd_soc_component *component = dapm->component;
-
-	component->driver->seq_notifier(component, type, subseq);
-}
-
 static int snd_soc_component_stream_event(struct snd_soc_dapm_context *dapm,
 	int event)
 {
@@ -2690,8 +2682,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	dapm->bias_level = SND_SOC_BIAS_OFF;
 	dapm->idle_bias_off = !driver->idle_bias_on;
 	dapm->suspend_bias_off = driver->suspend_bias_off;
-	if (driver->seq_notifier)
-		dapm->seq_notifier = snd_soc_component_seq_notifier;
 	if (driver->stream_event)
 		dapm->stream_event = snd_soc_component_stream_event;
 	if (driver->set_bias_level)

commit a2a341752558cc67d6fe5c8ada7c16f9c3690f89
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:31 2019 +0900

    ASoC: soc-component: add snd_soc_component_of_xlate_dai_name()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_of_xlate_dai_name() and use it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87y30l4d0z.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f63d09dd55f4..2f068c239f34 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3358,11 +3358,8 @@ int snd_soc_get_dai_name(struct of_phandle_args *args,
 		if (component_of_node != args->np)
 			continue;
 
-		if (pos->driver->of_xlate_dai_name) {
-			ret = pos->driver->of_xlate_dai_name(pos,
-							     args,
-							     dai_name);
-		} else {
+		ret = snd_soc_component_of_xlate_dai_name(pos, args, dai_name);
+		if (ret == -ENOTSUPP) {
 			struct snd_soc_dai *dai;
 			int id = -1;
 

commit 2c7b1704819435d188c7697c6815f788bf9e6200
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:26 2019 +0900

    ASoC: soc-component: add snd_soc_component_of_xlate_dai_id()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_of_xlate_dai_id() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87zhl14d14.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6a6403ddf62d..f63d09dd55f4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3334,9 +3334,8 @@ int snd_soc_get_dai_id(struct device_node *ep)
 	ret = -ENOTSUPP;
 	mutex_lock(&client_mutex);
 	component = soc_find_component(&dlc);
-	if (component &&
-	    component->driver->of_xlate_dai_id)
-		ret = component->driver->of_xlate_dai_id(component, ep);
+	if (component)
+		ret = snd_soc_component_of_xlate_dai_id(component, ep);
 	mutex_unlock(&client_mutex);
 
 	of_node_put(dlc.of_node);

commit 03b34dd7d87ce3493cb1837c9e59c3b3aac4724f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:22 2019 +0900

    ASoC: soc-component: add snd_soc_component_remove()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_remove() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/871ryd5rlo.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6a422ddae130..6a6403ddf62d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -929,8 +929,7 @@ static void soc_remove_component(struct snd_soc_component *component)
 	if (!component->card)
 		return;
 
-	if (component->driver->remove)
-		component->driver->remove(component);
+	snd_soc_component_remove(component);
 
 	soc_cleanup_component(component);
 }

commit 08e837dd9e39bd3e25b1fa1a13f6ba44040e3f0d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:17 2019 +0900

    ASoC: soc-component: add snd_soc_component_probe()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_probe() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/8736it5rlt.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ea93edd328a2..6a422ddae130 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1282,13 +1282,11 @@ static int soc_probe_component(struct snd_soc_card *card,
 		}
 	}
 
-	if (component->driver->probe) {
-		ret = component->driver->probe(component);
-		if (ret < 0) {
-			dev_err(component->dev,
-				"ASoC: failed to probe component %d\n", ret);
-			goto err_probe;
-		}
+	ret = snd_soc_component_probe(component);
+	if (ret < 0) {
+		dev_err(component->dev,
+			"ASoC: failed to probe component %d\n", ret);
+		goto err_probe;
 	}
 	WARN(dapm->idle_bias_off &&
 	     dapm->bias_level != SND_SOC_BIAS_OFF,

commit e40fadbcef583808c11d2e86b8ac1c652731468e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:13 2019 +0900

    ASoC: soc-component: add snd_soc_component_is_suspended()
    
    Current ALSA SoC is directly using component->xxx,
    But, it is not good for encapsulation.
    This patch adds new snd_soc_component_is_suspended() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/874l395rlx.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6cdfe7b2fe06..ea93edd328a2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -503,7 +503,7 @@ int snd_soc_suspend(struct device *dev)
 		 * If there are paths active then the COMPONENT will be held
 		 * with bias _ON and should not be suspended.
 		 */
-		if (!component->suspended) {
+		if (!snd_soc_component_is_suspended(component)) {
 			switch (snd_soc_dapm_get_bias_level(dapm)) {
 			case SND_SOC_BIAS_STANDBY:
 				/*
@@ -592,9 +592,8 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	for_each_card_components(card, component) {
-		if (component->suspended) {
+		if (snd_soc_component_is_suspended(component))
 			snd_soc_component_resume(component);
-		}
 	}
 
 	for_each_card_rtds(card, rtd) {

commit 9a840cbac77a90e8406296aaa132ebf2c84ed9e3
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:51:08 2019 +0900

    ASoC: soc-component: add snd_soc_component_resume()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_resume() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/875znp5rm2.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 855b19abc1d2..6cdfe7b2fe06 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -593,9 +593,7 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	for_each_card_components(card, component) {
 		if (component->suspended) {
-			if (component->driver->resume)
-				component->driver->resume(component);
-			component->suspended = 0;
+			snd_soc_component_resume(component);
 		}
 	}
 

commit 66c51573b89d0a5c1089139a2f0dd029a755c37d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:50:34 2019 +0900

    ASoC: soc-component: add snd_soc_component_suspend()
    
    Current ALSA SoC is directly using component->driver->xxx,
    thus, it is deep nested, and makes code difficult to read,
    and is not good for encapsulation.
    This patch adds new snd_soc_component_suspend() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/877e855rn0.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9ba19efcc56c..855b19abc1d2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -520,9 +520,7 @@ int snd_soc_suspend(struct device *dev)
 				/* fall through */
 
 			case SND_SOC_BIAS_OFF:
-				if (component->driver->suspend)
-					component->driver->suspend(component);
-				component->suspended = 1;
+				snd_soc_component_suspend(component);
 				if (component->regmap)
 					regcache_mark_dirty(component->regmap);
 				/* deactivate pins to sleep state */

commit 4a81e8f30d0b422b7f10562952124d719f73b071
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:49:54 2019 +0900

    ASoC: soc-component: add snd_soc_component_get/put()
    
    ALSA SoC is calling try_module_get()/module_put() based on
    component->driver->module_get_upon_open.
    To keep simple and readable code, we should create its function.
    This patch adds new snd_soc_component_get/put().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87h8795ro4.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index dc3e45547da2..9ba19efcc56c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -926,8 +926,7 @@ static void soc_cleanup_component(struct snd_soc_component *component)
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 	soc_cleanup_component_debugfs(component);
 	component->card = NULL;
-	if (!component->driver->module_get_upon_open)
-		module_put(component->dev->driver->owner);
+	snd_soc_component_module_put_when_close(component);
 }
 
 static void soc_remove_component(struct snd_soc_component *component)
@@ -1255,9 +1254,9 @@ static int soc_probe_component(struct snd_soc_card *card,
 		return 0;
 	}
 
-	if (!component->driver->module_get_upon_open &&
-	    !try_module_get(component->dev->driver->owner))
-		return -ENODEV;
+	ret = snd_soc_component_module_get_when_probe(component);
+	if (ret < 0)
+		return ret;
 
 	component->card = card;
 	dapm->card = card;

commit 4ff1fef10f353b928bcc9d56d31fda53f2c43191
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jul 26 13:49:48 2019 +0900

    ASoC: add soc-component.c
    
    ALSA SoC has many snd_soc_component_xxx(), but these are randomly
    located in many files. Because of it, code is difficult to read.
    This patch creates new soc-component.c, and moves existing
    snd_soc_component_xxx() into it.
    But not yet fully. We need more cleanup it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87imrp5roa.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ed66d2c68d10..dc3e45547da2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2345,50 +2345,6 @@ int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
 
-/**
- * snd_soc_component_set_sysclk - configure COMPONENT system or master clock.
- * @component: COMPONENT
- * @clk_id: DAI specific clock ID
- * @source: Source for the clock
- * @freq: new clock frequency in Hz
- * @dir: new clock direction - input/output.
- *
- * Configures the CODEC master (MCLK) or system (SYSCLK) clocking.
- */
-int snd_soc_component_set_sysclk(struct snd_soc_component *component,
-				 int clk_id, int source, unsigned int freq,
-				 int dir)
-{
-	if (component->driver->set_sysclk)
-		return component->driver->set_sysclk(component, clk_id, source,
-						 freq, dir);
-
-	return -ENOTSUPP;
-}
-EXPORT_SYMBOL_GPL(snd_soc_component_set_sysclk);
-
-/*
- * snd_soc_component_set_pll - configure component PLL.
- * @component: COMPONENT
- * @pll_id: DAI specific PLL ID
- * @source: DAI specific source for the PLL
- * @freq_in: PLL input clock frequency in Hz
- * @freq_out: requested PLL output clock frequency in Hz
- *
- * Configures and enables PLL to generate output clock based on input clock.
- */
-int snd_soc_component_set_pll(struct snd_soc_component *component, int pll_id,
-			      int source, unsigned int freq_in,
-			      unsigned int freq_out)
-{
-	if (component->driver->set_pll)
-		return component->driver->set_pll(component, pll_id, source,
-						  freq_in, freq_out);
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_component_set_pll);
-
 static int snd_soc_bind_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;

commit fee531d6fc49b9a616525e30955c4cf3b403f632
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 31 15:17:15 2019 +0200

    ASoC: core: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Also, there is no need to store the individual debugfs file name, just
    remove the whole directory all at once, saving a local variable.
    
    Note, the soc-pcm "state" file has now moved to a subdirectory, as it is
    only a good idea to save the dentries for debugfs directories, not
    individual files, as the individual file debugfs functions are changing
    to not return a dentry.
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Cc: alsa-devel@alsa-project.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20190731131716.9764-2-gregkh@linuxfoundation.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index da11e44b01aa..ed66d2c68d10 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -165,13 +165,6 @@ static void soc_init_component_debugfs(struct snd_soc_component *component)
 				component->card->debugfs_card_root);
 	}
 
-	if (IS_ERR(component->debugfs_root)) {
-		dev_warn(component->dev,
-			"ASoC: Failed to create component debugfs directory: %ld\n",
-			PTR_ERR(component->debugfs_root));
-		return;
-	}
-
 	snd_soc_dapm_debugfs_init(snd_soc_component_get_dapm(component),
 		component->debugfs_root);
 }
@@ -215,32 +208,15 @@ DEFINE_SHOW_ATTRIBUTE(component_list);
 
 static void soc_init_card_debugfs(struct snd_soc_card *card)
 {
-	if (!snd_soc_debugfs_root)
-		return;
-
 	card->debugfs_card_root = debugfs_create_dir(card->name,
 						     snd_soc_debugfs_root);
-	if (IS_ERR(card->debugfs_card_root)) {
-		dev_warn(card->dev,
-			 "ASoC: Failed to create card debugfs directory: %ld\n",
-			 PTR_ERR(card->debugfs_card_root));
-		card->debugfs_card_root = NULL;
-		return;
-	}
 
-	card->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0644,
-						    card->debugfs_card_root,
-						    &card->pop_time);
-	if (IS_ERR(card->debugfs_pop_time))
-		dev_warn(card->dev,
-			 "ASoC: Failed to create pop time debugfs file: %ld\n",
-			 PTR_ERR(card->debugfs_pop_time));
+	debugfs_create_u32("dapm_pop_time", 0644, card->debugfs_card_root,
+			   &card->pop_time);
 }
 
 static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 {
-	if (!card->debugfs_card_root)
-		return;
 	debugfs_remove_recursive(card->debugfs_card_root);
 	card->debugfs_card_root = NULL;
 }
@@ -248,19 +224,12 @@ static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 static void snd_soc_debugfs_init(void)
 {
 	snd_soc_debugfs_root = debugfs_create_dir("asoc", NULL);
-	if (IS_ERR_OR_NULL(snd_soc_debugfs_root)) {
-		pr_warn("ASoC: Failed to create debugfs directory\n");
-		snd_soc_debugfs_root = NULL;
-		return;
-	}
 
-	if (!debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
-				 &dai_list_fops))
-		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
+	debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
+			    &dai_list_fops);
 
-	if (!debugfs_create_file("components", 0444, snd_soc_debugfs_root, NULL,
-				 &component_list_fops))
-		pr_warn("ASoC: Failed to create component list debugfs file\n");
+	debugfs_create_file("components", 0444, snd_soc_debugfs_root, NULL,
+			    &component_list_fops);
 }
 
 static void snd_soc_debugfs_exit(void)

commit a342031cdd0818cb0fbcb44798211c7a02c7ca27
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Thu Jul 25 18:59:47 2019 +0200

    ASoC: create pcm for codec2codec links as well
    
    At the moment, codec to codec links uses an ephemeral variable for
    the struct snd_pcm_substream. Also the struct snd_soc_pcm_runtime
    does not have real struct snd_pcm.
    
    This might a problem if the functions used by a codec on codec to
    codec link expect these structures to exist, and keep on existing
    during the life of the codec.
    
    For example, it is the case of the hdmi-codec, which uses
    snd_pcm_add_chmap_ctls(). For the controls to works, the pcm and
    substream must to exist.
    
    This change is first step, it create pcm (and substreams) for codec
    to codec links, in the same way as dpcm backend links.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Link: https://lore.kernel.org/r/20190725165949.29699-5-jbrunet@baylibre.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 06697b2d96b1..da11e44b01aa 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -447,16 +447,6 @@ static void snd_soc_flush_all_delayed_work(struct snd_soc_card *card)
 		flush_delayed_work(&rtd->delayed_work);
 }
 
-static void codec2codec_close_delayed_work(struct work_struct *work)
-{
-	/*
-	 * Currently nothing to do for c2c links
-	 * Since c2c links are internal nodes in the DAPM graph and
-	 * don't interface with the outside world or application layer
-	 * we don't have to do any special handling on close.
-	 */
-}
-
 #ifdef CONFIG_PM_SLEEP
 /* powers down audio subsystem for suspend */
 int snd_soc_suspend(struct device *dev)
@@ -1555,27 +1545,19 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 		return ret;
 	}
 
-	if (!dai_link->params) {
-		/* create the pcm */
-		ret = soc_new_pcm(rtd, num);
-		if (ret < 0) {
-			dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
-				dai_link->stream_name, ret);
-			return ret;
-		}
-		ret = soc_link_dai_pcm_new(&cpu_dai, 1, rtd);
-		if (ret < 0)
-			return ret;
-		ret = soc_link_dai_pcm_new(rtd->codec_dais,
-					   rtd->num_codecs, rtd);
-		if (ret < 0)
-			return ret;
-	} else {
-		INIT_DELAYED_WORK(&rtd->delayed_work,
-				  codec2codec_close_delayed_work);
+	/* create the pcm */
+	ret = soc_new_pcm(rtd, num);
+	if (ret < 0) {
+		dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
+			dai_link->stream_name, ret);
+		return ret;
 	}
-
-	return 0;
+	ret = soc_link_dai_pcm_new(&cpu_dai, 1, rtd);
+	if (ret < 0)
+		return ret;
+	ret = soc_link_dai_pcm_new(rtd->codec_dais,
+				   rtd->num_codecs, rtd);
+	return ret;
 }
 
 static int soc_bind_aux_dev(struct snd_soc_card *card, int num)

commit 3b46a67af2eb8214a634a37c485146ca0ef42849
Merge: 3dcfb397dad2 1e112c35e3c9
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jul 26 13:10:09 2019 +0100

    Merge branch 'asoc-5.3' into asoc-5.4

commit 40aa5383e393d72f6aa3943a4e7b1aae25a1e43b
Author: Ricard Wanderlof <ricard.wanderlof@axis.com>
Date:   Wed Jul 24 11:38:44 2019 +0200

    ASoC: Fail card instantiation if DAI format setup fails
    
    If the DAI format setup fails, there is no valid communication format
    between CPU and CODEC, so fail card instantiation, rather than continue
    with a card that will most likely not function properly.
    
    Signed-off-by: Ricard Wanderlof <ricardw@axis.com>
    Link: https://lore.kernel.org/r/alpine.DEB.2.20.1907241132350.6338@lnxricardw1.se.axis.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0a774d0a5ff..1486fb2eb921 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1511,8 +1511,11 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 		}
 	}
 
-	if (dai_link->dai_fmt)
-		snd_soc_runtime_set_dai_fmt(rtd, dai_link->dai_fmt);
+	if (dai_link->dai_fmt) {
+		ret = snd_soc_runtime_set_dai_fmt(rtd, dai_link->dai_fmt);
+		if (ret)
+			return ret;
+	}
 
 	ret = soc_post_component_init(rtd, dai_link->name);
 	if (ret)

commit 88fdffa2eef45fc9f6009ee590741c44a57c49c7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:36:27 2019 +0900

    ASoC: soc-core: use existing snd_soc_dai_digital_mute()
    
    ALSA SoC already has snd_soc_dai_digital_mute() for digital_mute,
    let's use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87ef2ihmzo.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 458b090f026a..7ecfe641ca46 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -487,10 +487,9 @@ int snd_soc_suspend(struct device *dev)
 			continue;
 
 		for_each_rtd_codec_dai(rtd, i, dai) {
-			struct snd_soc_dai_driver *drv = dai->driver;
-
-			if (drv->ops->digital_mute && dai->playback_active)
-				drv->ops->digital_mute(dai, 1);
+			if (dai->playback_active)
+				snd_soc_dai_digital_mute(dai, 1,
+						SNDRV_PCM_STREAM_PLAYBACK);
 		}
 	}
 
@@ -665,10 +664,9 @@ static void soc_resume_deferred(struct work_struct *work)
 			continue;
 
 		for_each_rtd_codec_dai(rtd, i, dai) {
-			struct snd_soc_dai_driver *drv = dai->driver;
-
-			if (drv->ops->digital_mute && dai->playback_active)
-				drv->ops->digital_mute(dai, 0);
+			if (dai->playback_active)
+				snd_soc_dai_digital_mute(dai, 0,
+						SNDRV_PCM_STREAM_PLAYBACK);
 		}
 	}
 

commit b423c4202135f7794e0a9c55a884f5933d8e7156
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:35:29 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_compress_new()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_compress_new() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87h87ehn1a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 727fd342b3fb..458b090f026a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1545,15 +1545,16 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 			num = rtd->dai_link->id;
 	}
 
-	if (cpu_dai->driver->compress_new) {
-		/* create compress_device" */
-		ret = cpu_dai->driver->compress_new(rtd, num);
-		if (ret < 0) {
+	/* create compress_device if possible */
+	ret = snd_soc_dai_compress_new(cpu_dai, rtd, num);
+	if (ret != -ENOTSUPP) {
+		if (ret < 0)
 			dev_err(card->dev, "ASoC: can't create compress %s\n",
 					 dai_link->stream_name);
-			return ret;
-		}
-	} else if (!dai_link->params) {
+		return ret;
+	}
+
+	if (!dai_link->params) {
 		/* create the pcm */
 		ret = soc_new_pcm(rtd, num);
 		if (ret < 0) {

commit dcdab5820edd6123911dbd767ee1e389008b6a83
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:35:05 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_remove()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_remvoe() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87imruhn1x.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3e73468225f9..727fd342b3fb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -992,13 +992,12 @@ static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 	    dai->driver->remove_order != order)
 		return;
 
-	if (dai->driver->remove) {
-		err = dai->driver->remove(dai);
-		if (err < 0)
-			dev_err(dai->dev,
-				"ASoC: failed to remove %s: %d\n",
-				dai->name, err);
-	}
+	err = snd_soc_dai_remove(dai);
+	if (err < 0)
+		dev_err(dai->dev,
+			"ASoC: failed to remove %s: %d\n",
+			dai->name, err);
+
 	dai->probed = 0;
 }
 

commit cfd9b5fbfe1e8763018aea2600aa0d6ff015ebfc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:34:56 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_probe()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_probe() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87k1cahn26.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5c02f90cea69..3e73468225f9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1434,18 +1434,17 @@ static int soc_probe_link_components(struct snd_soc_card *card,
 
 static int soc_probe_dai(struct snd_soc_dai *dai, int order)
 {
+	int ret;
+
 	if (dai->probed ||
 	    dai->driver->probe_order != order)
 		return 0;
 
-	if (dai->driver->probe) {
-		int ret = dai->driver->probe(dai);
-
-		if (ret < 0) {
-			dev_err(dai->dev, "ASoC: failed to probe DAI %s: %d\n",
-				dai->name, ret);
-			return ret;
-		}
+	ret = snd_soc_dai_probe(dai);
+	if (ret < 0) {
+		dev_err(dai->dev, "ASoC: failed to probe DAI %s: %d\n",
+			dai->name, ret);
+		return ret;
 	}
 
 	dai->probed = 1;

commit 24b09d051164680f0a1d1910efe21ce36ad5c1ca
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:34:43 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_resume()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_resume() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87lfwqhn2j.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7493afb2371c..5c02f90cea69 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -631,8 +631,8 @@ static void soc_resume_deferred(struct work_struct *work)
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->resume && cpu_dai->driver->bus_control)
-			cpu_dai->driver->resume(cpu_dai);
+		if (cpu_dai->driver->bus_control)
+			snd_soc_dai_resume(cpu_dai);
 	}
 
 	for_each_card_components(card, component) {
@@ -678,8 +678,8 @@ static void soc_resume_deferred(struct work_struct *work)
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->resume && !cpu_dai->driver->bus_control)
-			cpu_dai->driver->resume(cpu_dai);
+		if (!cpu_dai->driver->bus_control)
+			snd_soc_dai_resume(cpu_dai);
 	}
 
 	if (card->resume_post)

commit e0f2262292d0c8160cfd9a8c40425107fb65ab29
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:34:29 2019 +0900

    ASoC: soc-dai: add snd_soc_dai_suspend()
    
    Current ALSA SoC is directly using dai->driver->xxx,
    thus, it has deep nested bracket, and it makes code unreadable.
    This patch adds new snd_soc_dai_suspend() and use it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/87muh6hn2x.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6e8c5c8eeaec..7493afb2371c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -511,8 +511,8 @@ int snd_soc_suspend(struct device *dev)
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->suspend && !cpu_dai->driver->bus_control)
-			cpu_dai->driver->suspend(cpu_dai);
+		if (!cpu_dai->driver->bus_control)
+			snd_soc_dai_suspend(cpu_dai);
 	}
 
 	/* close any waiting streams */
@@ -584,8 +584,8 @@ int snd_soc_suspend(struct device *dev)
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->suspend && cpu_dai->driver->bus_control)
-			cpu_dai->driver->suspend(cpu_dai);
+		if (cpu_dai->driver->bus_control)
+			snd_soc_dai_suspend(cpu_dai);
 
 		/* deactivate pins to sleep state */
 		pinctrl_pm_select_sleep_state(cpu_dai->dev);

commit 06f6e1d41427f394ad3f67ecf06efcd28a46932c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 22 10:32:12 2019 +0900

    ASoC: add soc-dai.c
    
    Current ALSA SoC has many snd_soc_dai_xxx() function which is
    using dai->driver->ops->xxx.
    But, some of them are implemented as snd_soc_dai_xxx(),
    but others are directly using dai->driver->ops->xxx.
    Because of it, the code is not easy to read.
    
    This patch creats new soc-dai.c and moves snd_soc_dai_xxx()
    functions into it.
    One exception is snd_soc_dai_is_dummy() which is based on
    soc-utils local variable. We need to keep it as-is there.
    
    Others which is directly using dai->driver->ops->xxx will be
    implemented at soc-dai.c by incremental patches.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Link: https://lore.kernel.org/r/871ryij1r6.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fd6eaae6c0ed..6e8c5c8eeaec 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2394,26 +2394,6 @@ int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
 
-/**
- * snd_soc_dai_set_sysclk - configure DAI system or master clock.
- * @dai: DAI
- * @clk_id: DAI specific clock ID
- * @freq: new clock frequency in Hz
- * @dir: new clock direction - input/output.
- *
- * Configures the DAI master (MCLK) or system (SYSCLK) clocking.
- */
-int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
-	unsigned int freq, int dir)
-{
-	if (dai->driver->ops->set_sysclk)
-		return dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
-
-	return snd_soc_component_set_sysclk(dai->component, clk_id, 0,
-					    freq, dir);
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
-
 /**
  * snd_soc_component_set_sysclk - configure COMPONENT system or master clock.
  * @component: COMPONENT
@@ -2436,48 +2416,6 @@ int snd_soc_component_set_sysclk(struct snd_soc_component *component,
 }
 EXPORT_SYMBOL_GPL(snd_soc_component_set_sysclk);
 
-/**
- * snd_soc_dai_set_clkdiv - configure DAI clock dividers.
- * @dai: DAI
- * @div_id: DAI specific clock divider ID
- * @div: new clock divisor.
- *
- * Configures the clock dividers. This is used to derive the best DAI bit and
- * frame clocks from the system or master clock. It's best to set the DAI bit
- * and frame clocks as low as possible to save system power.
- */
-int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
-	int div_id, int div)
-{
-	if (dai->driver->ops->set_clkdiv)
-		return dai->driver->ops->set_clkdiv(dai, div_id, div);
-	else
-		return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
-
-/**
- * snd_soc_dai_set_pll - configure DAI PLL.
- * @dai: DAI
- * @pll_id: DAI specific PLL ID
- * @source: DAI specific source for the PLL
- * @freq_in: PLL input clock frequency in Hz
- * @freq_out: requested PLL output clock frequency in Hz
- *
- * Configures and enables PLL to generate output clock based on input clock.
- */
-int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
-	unsigned int freq_in, unsigned int freq_out)
-{
-	if (dai->driver->ops->set_pll)
-		return dai->driver->ops->set_pll(dai, pll_id, source,
-					 freq_in, freq_out);
-
-	return snd_soc_component_set_pll(dai->component, pll_id, source,
-					 freq_in, freq_out);
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
-
 /*
  * snd_soc_component_set_pll - configure component PLL.
  * @component: COMPONENT
@@ -2500,187 +2438,6 @@ int snd_soc_component_set_pll(struct snd_soc_component *component, int pll_id,
 }
 EXPORT_SYMBOL_GPL(snd_soc_component_set_pll);
 
-/**
- * snd_soc_dai_set_bclk_ratio - configure BCLK to sample rate ratio.
- * @dai: DAI
- * @ratio: Ratio of BCLK to Sample rate.
- *
- * Configures the DAI for a preset BCLK to sample rate ratio.
- */
-int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
-{
-	if (dai->driver->ops->set_bclk_ratio)
-		return dai->driver->ops->set_bclk_ratio(dai, ratio);
-	else
-		return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
-
-/**
- * snd_soc_dai_set_fmt - configure DAI hardware audio format.
- * @dai: DAI
- * @fmt: SND_SOC_DAIFMT_* format value.
- *
- * Configures the DAI hardware format and clocking.
- */
-int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
-{
-	if (dai->driver->ops->set_fmt == NULL)
-		return -ENOTSUPP;
-	return dai->driver->ops->set_fmt(dai, fmt);
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
-
-/**
- * snd_soc_xlate_tdm_slot - generate tx/rx slot mask.
- * @slots: Number of slots in use.
- * @tx_mask: bitmask representing active TX slots.
- * @rx_mask: bitmask representing active RX slots.
- *
- * Generates the TDM tx and rx slot default masks for DAI.
- */
-static int snd_soc_xlate_tdm_slot_mask(unsigned int slots,
-				       unsigned int *tx_mask,
-				       unsigned int *rx_mask)
-{
-	if (*tx_mask || *rx_mask)
-		return 0;
-
-	if (!slots)
-		return -EINVAL;
-
-	*tx_mask = (1 << slots) - 1;
-	*rx_mask = (1 << slots) - 1;
-
-	return 0;
-}
-
-/**
- * snd_soc_dai_set_tdm_slot() - Configures a DAI for TDM operation
- * @dai: The DAI to configure
- * @tx_mask: bitmask representing active TX slots.
- * @rx_mask: bitmask representing active RX slots.
- * @slots: Number of slots in use.
- * @slot_width: Width in bits for each slot.
- *
- * This function configures the specified DAI for TDM operation. @slot contains
- * the total number of slots of the TDM stream and @slot_with the width of each
- * slot in bit clock cycles. @tx_mask and @rx_mask are bitmasks specifying the
- * active slots of the TDM stream for the specified DAI, i.e. which slots the
- * DAI should write to or read from. If a bit is set the corresponding slot is
- * active, if a bit is cleared the corresponding slot is inactive. Bit 0 maps to
- * the first slot, bit 1 to the second slot and so on. The first active slot
- * maps to the first channel of the DAI, the second active slot to the second
- * channel and so on.
- *
- * TDM mode can be disabled by passing 0 for @slots. In this case @tx_mask,
- * @rx_mask and @slot_width will be ignored.
- *
- * Returns 0 on success, a negative error code otherwise.
- */
-int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
-	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
-{
-	if (dai->driver->ops->xlate_tdm_slot_mask)
-		dai->driver->ops->xlate_tdm_slot_mask(slots,
-						&tx_mask, &rx_mask);
-	else
-		snd_soc_xlate_tdm_slot_mask(slots, &tx_mask, &rx_mask);
-
-	dai->tx_mask = tx_mask;
-	dai->rx_mask = rx_mask;
-
-	if (dai->driver->ops->set_tdm_slot)
-		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
-				slots, slot_width);
-	else
-		return -ENOTSUPP;
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
-
-/**
- * snd_soc_dai_set_channel_map - configure DAI audio channel map
- * @dai: DAI
- * @tx_num: how many TX channels
- * @tx_slot: pointer to an array which imply the TX slot number channel
- *           0~num-1 uses
- * @rx_num: how many RX channels
- * @rx_slot: pointer to an array which imply the RX slot number channel
- *           0~num-1 uses
- *
- * configure the relationship between channel number and TDM slot number.
- */
-int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,
-	unsigned int tx_num, unsigned int *tx_slot,
-	unsigned int rx_num, unsigned int *rx_slot)
-{
-	if (dai->driver->ops->set_channel_map)
-		return dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,
-			rx_num, rx_slot);
-	else
-		return -ENOTSUPP;
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);
-
-/**
- * snd_soc_dai_get_channel_map - Get DAI audio channel map
- * @dai: DAI
- * @tx_num: how many TX channels
- * @tx_slot: pointer to an array which imply the TX slot number channel
- *           0~num-1 uses
- * @rx_num: how many RX channels
- * @rx_slot: pointer to an array which imply the RX slot number channel
- *           0~num-1 uses
- */
-int snd_soc_dai_get_channel_map(struct snd_soc_dai *dai,
-	unsigned int *tx_num, unsigned int *tx_slot,
-	unsigned int *rx_num, unsigned int *rx_slot)
-{
-	if (dai->driver->ops->get_channel_map)
-		return dai->driver->ops->get_channel_map(dai, tx_num, tx_slot,
-			rx_num, rx_slot);
-	else
-		return -ENOTSUPP;
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_get_channel_map);
-
-/**
- * snd_soc_dai_set_tristate - configure DAI system or master clock.
- * @dai: DAI
- * @tristate: tristate enable
- *
- * Tristates the DAI so that others can use it.
- */
-int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
-{
-	if (dai->driver->ops->set_tristate)
-		return dai->driver->ops->set_tristate(dai, tristate);
-	else
-		return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
-
-/**
- * snd_soc_dai_digital_mute - configure DAI system or master clock.
- * @dai: DAI
- * @mute: mute enable
- * @direction: stream to mute
- *
- * Mutes the DAI DAC.
- */
-int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
-			     int direction)
-{
-	if (dai->driver->ops->mute_stream)
-		return dai->driver->ops->mute_stream(dai, mute, direction);
-	else if (direction == SNDRV_PCM_STREAM_PLAYBACK &&
-		 dai->driver->ops->digital_mute)
-		return dai->driver->ops->digital_mute(dai, mute);
-	else
-		return -ENOTSUPP;
-}
-EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
-
 static int snd_soc_bind_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;

commit 043b35f281f5f141e7a928d27492133ef33b8119
Merge: 0dceaf7c798d 87a6fe80d56b
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Jul 6 12:25:26 2019 +0100

    Merge branch 'asoc-5.3' into asoc-next

commit 74b35a74f80e02bdd69db9cf96d3f4fe78b67064
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Wed Jul 3 13:30:02 2019 +0100

    ASoC: core: Return -ENOTSUPP from set_channel_map() if no operation provided
    
    It makes it easier for common code to work with snd_soc_dai_set_channel_map()
    by distinguishing between operation not being supported and an error.
    This is done inline with others snd_soc_dai.* apis.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Link: https://lore.kernel.org/r/20190703123002.12427-1-srinivas.kandagatla@linaro.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b9061cd8d787..c0a774d0a5ff 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2614,7 +2614,7 @@ int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,
 		return dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,
 			rx_num, rx_slot);
 	else
-		return -EINVAL;
+		return -ENOTSUPP;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);
 

commit 34614739988ad60c3493da66dd856002ee93edf9
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Thu Jun 27 14:13:50 2019 +0200

    ASoC: soc-core: support dai_link with platforms_num != 1
    
    Add support platforms_num != 1 in dai_link. Initially, the main purpose of
    this change was to make the platform optional in the dai_link, instead of
    inserting the dummy platform driver.
    
    This particular case had just been solved by Kuninori Morimoto with
    commit 1d7689892878 ("ASoC: soc-core: allow no Platform on dai_link").
    
    However, this change may still be useful for those who need multiple
    platform components on a single dai_link (it solves one of the FIXME
    note in soc-core)
    
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b5f3c09311c3..b9061cd8d787 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -896,7 +896,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_dai_link_component *codecs;
+	struct snd_soc_dai_link_component *codec, *platform;
 	struct snd_soc_component *component;
 	int i;
 
@@ -926,13 +926,14 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 	/* Find CODEC from registered CODECs */
 	rtd->num_codecs = dai_link->num_codecs;
-	for_each_link_codecs(dai_link, i, codecs) {
-		rtd->codec_dais[i] = snd_soc_find_dai(codecs);
+	for_each_link_codecs(dai_link, i, codec) {
+		rtd->codec_dais[i] = snd_soc_find_dai(codec);
 		if (!rtd->codec_dais[i]) {
 			dev_info(card->dev, "ASoC: CODEC DAI %s not registered\n",
-				 codecs->dai_name);
+				 codec->dai_name);
 			goto _err_defer;
 		}
+
 		snd_soc_rtdcom_add(rtd, rtd->codec_dais[i]->component);
 	}
 
@@ -940,12 +941,13 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	rtd->codec_dai = rtd->codec_dais[0];
 
 	/* Find PLATFORM from registered PLATFORMs */
-	for_each_component(component) {
-		if (!snd_soc_is_matching_component(dai_link->platforms,
-						   component))
-			continue;
+	for_each_link_platforms(dai_link, i, platform) {
+		for_each_component(component) {
+			if (!snd_soc_is_matching_component(platform, component))
+				continue;
 
-		snd_soc_rtdcom_add(rtd, component);
+			snd_soc_rtdcom_add(rtd, component);
+		}
 	}
 
 	soc_add_pcm_runtime(card, rtd);
@@ -1058,15 +1060,14 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 			     struct snd_soc_dai_link *link)
 {
 	int i;
-	struct snd_soc_dai_link_component *codec;
+	struct snd_soc_dai_link_component *codec, *platform;
 
 	for_each_link_codecs(link, i, codec) {
 		/*
 		 * Codec must be specified by 1 of name or OF node,
 		 * not both or neither.
 		 */
-		if (!!codec->name ==
-		    !!codec->of_node) {
+		if (!!codec->name == !!codec->of_node) {
 			dev_err(card->dev, "ASoC: Neither/both codec name/of_node are set for %s\n",
 				link->name);
 			return -EINVAL;
@@ -1087,36 +1088,24 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 			return -EPROBE_DEFER;
 	}
 
-	/*
-	 * Platform may be specified by either name or OF node,
-	 * or no Platform.
-	 *
-	 * FIXME
-	 *
-	 * We need multi-platform support
-	 */
-	if (link->num_platforms > 0) {
-
-		if (link->num_platforms > 1) {
-			dev_err(card->dev,
-				"ASoC: multi platform is not yet supported %s\n",
-				link->name);
-			return -EINVAL;
-		}
-
-		if (link->platforms->name && link->platforms->of_node) {
+	for_each_link_platforms(link, i, platform) {
+		/*
+		 * Platform may be specified by either name or OF node, but it
+		 * can be left unspecified, then no components will be inserted
+		 * in the rtdcom list
+		 */
+		if (!!platform->name == !!platform->of_node) {
 			dev_err(card->dev,
-				"ASoC: Both platform name/of_node are set for %s\n",
+				"ASoC: Neither/both platform name/of_node are set for %s\n",
 				link->name);
 			return -EINVAL;
 		}
 
 		/*
-		 * Defer card registartion if platform dai component is not
-		 * added to component list.
+		 * Defer card registration if platform component is not added to
+		 * component list.
 		 */
-		if ((link->platforms->of_node || link->platforms->name) &&
-		    !soc_find_component(link->platforms))
+		if (!soc_find_component(platform))
 			return -EPROBE_DEFER;
 	}
 

commit af18b13fedae4637b439d1265038b30929ca5a4c
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Thu Jun 27 14:13:49 2019 +0200

    ASoC: soc-core: defer card registration if codec component is missing
    
    Like cpus and platforms, defer sound card initialization if the codec
    component is missing when initializing the dai_link
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 05cd710273b6..b5f3c09311c3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1071,12 +1071,20 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 				link->name);
 			return -EINVAL;
 		}
+
 		/* Codec DAI name must be specified */
 		if (!codec->dai_name) {
 			dev_err(card->dev, "ASoC: codec_dai_name not set for %s\n",
 				link->name);
 			return -EINVAL;
 		}
+
+		/*
+		 * Defer card registration if codec component is not added to
+		 * component list.
+		 */
+		if (!soc_find_component(codec))
+			return -EPROBE_DEFER;
 	}
 
 	/*

commit 53c8b29abe42e5601cfa0ea5962532f0cfdec8a0
Merge: e3303268f9cf 4b972a01a7da
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Jun 26 12:39:34 2019 +0100

    Merge tag 'v5.2-rc6' into asoc-5.3
    
    Linux 5.2-rc6

commit e3303268f9cfa4eb7c2217df471417d4327109fd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 26 10:40:59 2019 +0900

    ASoC: soc-core: don't use soc_find_component() at snd_soc_find_dai()
    
    commit b9f2e25c599bb ("ASoC: soc-core: use soc_find_component() at
    snd_soc_find_dai()") used soc_find_component() at snd_soc_find_dai(),
    but, some CPU driver has CPU component for DAI and Platform component,
    for example generic DMAEngine component.
    In such case, CPU component and Platform component have same
    of_node / name.
    
    Here soc_find_component() returns *1st* found component.
    Thus, we shouldn't use soc_find_component() at snd_soc_find_dai().
    This patch fixup this it, and add comment to indicate this limitation.
    
    Fixes: commit b9f2e25c599bb ("ASoC: soc-core: use soc_find_component() at snd_soc_find_dai()")
    Reported-by: Dmitry Osipenko <digetx@gmail.com>
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 358f1fbf9a30..8ccaf63e428c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -786,6 +786,14 @@ static struct snd_soc_component *soc_find_component(
 
 	lockdep_assert_held(&client_mutex);
 
+	/*
+	 * NOTE
+	 *
+	 * It returns *1st* found component, but some driver
+	 * has few components by same of_node/name
+	 * ex)
+	 *	CPU component and generic DMAEngine component
+	 */
 	for_each_component(component)
 		if (snd_soc_is_matching_component(dlc, component))
 			return component;
@@ -813,8 +821,9 @@ struct snd_soc_dai *snd_soc_find_dai(
 	lockdep_assert_held(&client_mutex);
 
 	/* Find CPU DAI from registered DAIs */
-	component = soc_find_component(dlc);
-	if (component) {
+	for_each_component(component) {
+		if (!snd_soc_is_matching_component(dlc, component))
+			continue;
 		for_each_component_dais(component, dai) {
 			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name)
 			    && (!dai->driver->name

commit b9f2e25c599bbbf0646957e07ebb72b942c286cc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jun 20 09:49:33 2019 +0900

    ASoC: soc-core: use soc_find_component() at snd_soc_find_dai()
    
    snd_soc_find_dai() finds component first via specified
    snd_soc_dai_link_component, and find DAI from it.
    
    We already have soc_find_component() to find component,
    but soc_find_dai() has original implementation to find component.
    
    We shouldn't have duplicate implementation to do same things.
    This patch uses soc_find_component() at soc_find_dai()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1749f4af91b6..358f1fbf9a30 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -813,9 +813,8 @@ struct snd_soc_dai *snd_soc_find_dai(
 	lockdep_assert_held(&client_mutex);
 
 	/* Find CPU DAI from registered DAIs */
-	for_each_component(component) {
-		if (!snd_soc_is_matching_component(dlc, component))
-			continue;
+	component = soc_find_component(dlc);
+	if (component) {
 		for_each_component_dais(component, dai) {
 			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name)
 			    && (!dai->driver->name

commit c1e230f0f7a3cc640317aa78389258a2fa54bcde
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jun 20 09:49:27 2019 +0900

    ASoC: soc-core: soc_find_component() uses snd_soc_dai_link_component
    
    soc_find_component() is using "of_node" and "name" to finding component,
    but we should use snd_soc_dai_link_component now, because it is created
    to such purpose.
    
    This patch uses snd_soc_dai_link_component for soc_find_component().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e6b95b7e2737..1749f4af91b6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -780,19 +780,15 @@ static int snd_soc_is_matching_component(
 }
 
 static struct snd_soc_component *soc_find_component(
-	struct device_node *of_node, const char *name)
+	const struct snd_soc_dai_link_component *dlc)
 {
 	struct snd_soc_component *component;
-	struct snd_soc_dai_link_component dlc;
 
 	lockdep_assert_held(&client_mutex);
 
-	for_each_component(component) {
-		dlc.name = name;
-		dlc.of_node = of_node;
-		if (snd_soc_is_matching_component(&dlc, component))
+	for_each_component(component)
+		if (snd_soc_is_matching_component(dlc, component))
 			return component;
-	}
 
 	return NULL;
 }
@@ -1106,8 +1102,7 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 		 * added to component list.
 		 */
 		if ((link->platforms->of_node || link->platforms->name) &&
-		    !soc_find_component(link->platforms->of_node,
-					link->platforms->name))
+		    !soc_find_component(link->platforms))
 			return -EPROBE_DEFER;
 	}
 
@@ -1136,7 +1131,7 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	 * component list.
 	 */
 	if ((link->cpus->of_node || link->cpus->name) &&
-	    !soc_find_component(link->cpus->of_node, link->cpus->name))
+	    !soc_find_component(link->cpus))
 		return -EPROBE_DEFER;
 
 	/*
@@ -1580,23 +1575,23 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	struct snd_soc_component *component;
-	const char *name;
-	struct device_node *codec_of_node;
+	struct snd_soc_dai_link_component dlc;
 
 	if (aux_dev->codec_of_node || aux_dev->codec_name) {
 		/* codecs, usually analog devices */
-		name = aux_dev->codec_name;
-		codec_of_node = aux_dev->codec_of_node;
-		component = soc_find_component(codec_of_node, name);
+		dlc.name = aux_dev->codec_name;
+		dlc.of_node = aux_dev->codec_of_node;
+		component = soc_find_component(&dlc);
 		if (!component) {
-			if (codec_of_node)
-				name = of_node_full_name(codec_of_node);
+			if (dlc.of_node)
+				dlc.name = of_node_full_name(dlc.of_node);
 			goto err_defer;
 		}
 	} else if (aux_dev->name) {
 		/* generic components */
-		name = aux_dev->name;
-		component = soc_find_component(NULL, name);
+		dlc.name = aux_dev->name;
+		dlc.of_node = NULL;
+		component = soc_find_component(&dlc);
 		if (!component)
 			goto err_defer;
 	} else {
@@ -1610,7 +1605,7 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 	return 0;
 
 err_defer:
-	dev_err(card->dev, "ASoC: %s not registered\n", name);
+	dev_err(card->dev, "ASoC: %s not registered\n", dlc.name);
 	return -EPROBE_DEFER;
 }
 
@@ -3661,11 +3656,11 @@ EXPORT_SYMBOL_GPL(snd_soc_of_parse_daifmt);
 int snd_soc_get_dai_id(struct device_node *ep)
 {
 	struct snd_soc_component *component;
-	struct device_node *node;
+	struct snd_soc_dai_link_component dlc;
 	int ret;
 
-	node = of_graph_get_port_parent(ep);
-
+	dlc.of_node	= of_graph_get_port_parent(ep);
+	dlc.name	= NULL;
 	/*
 	 * For example HDMI case, HDMI has video/sound port,
 	 * but ALSA SoC needs sound port number only.
@@ -3674,13 +3669,13 @@ int snd_soc_get_dai_id(struct device_node *ep)
 	 */
 	ret = -ENOTSUPP;
 	mutex_lock(&client_mutex);
-	component = soc_find_component(node, NULL);
+	component = soc_find_component(&dlc);
 	if (component &&
 	    component->driver->of_xlate_dai_id)
 		ret = component->driver->of_xlate_dai_id(component, ep);
 	mutex_unlock(&client_mutex);
 
-	of_node_put(node);
+	of_node_put(dlc.of_node);
 
 	return ret;
 }

commit a9ec84966f6d887b9066029596eb361b5d2af214
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jun 20 09:49:23 2019 +0900

    ASoC: soc-core: soc_find_component() uses snd_soc_is_matching_component()
    
    ALSA SoC already has snd_soc_is_matching_component() to confirming
    matching component, but, soc_find_component() has original
    implementation to confirm component.
    
    We shouldn't have duplicate implementation to do same things.
    This patch uses snd_soc_is_matching_component() at soc_find_component()
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1b94119cfb0d..e6b95b7e2737 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -780,22 +780,18 @@ static int snd_soc_is_matching_component(
 }
 
 static struct snd_soc_component *soc_find_component(
-	const struct device_node *of_node, const char *name)
+	struct device_node *of_node, const char *name)
 {
 	struct snd_soc_component *component;
-	struct device_node *component_of_node;
+	struct snd_soc_dai_link_component dlc;
 
 	lockdep_assert_held(&client_mutex);
 
 	for_each_component(component) {
-		if (of_node) {
-			component_of_node = soc_component_to_node(component);
-
-			if (component_of_node == of_node)
-				return component;
-		} else if (name && strcmp(component->name, name) == 0) {
+		dlc.name = name;
+		dlc.of_node = of_node;
+		if (snd_soc_is_matching_component(&dlc, component))
 			return component;
-		}
 	}
 
 	return NULL;

commit 7d7db5d3c3d849c2f877be3b4c9afa7f5b5257c2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jun 20 09:49:17 2019 +0900

    ASoC: soc-core: move soc_find_component()
    
    move soc_find_component() next to snd_soc_is_matching_component().
    This is prepare for soc_find_component() cleanup
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4cd77cd6c864..1b94119cfb0d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -760,6 +760,25 @@ static struct device_node
 	return of_node;
 }
 
+static int snd_soc_is_matching_component(
+	const struct snd_soc_dai_link_component *dlc,
+	struct snd_soc_component *component)
+{
+	struct device_node *component_of_node;
+
+	if (!dlc)
+		return 0;
+
+	component_of_node = soc_component_to_node(component);
+
+	if (dlc->of_node && component_of_node != dlc->of_node)
+		return 0;
+	if (dlc->name && strcmp(component->name, dlc->name))
+		return 0;
+
+	return 1;
+}
+
 static struct snd_soc_component *soc_find_component(
 	const struct device_node *of_node, const char *name)
 {
@@ -782,25 +801,6 @@ static struct snd_soc_component *soc_find_component(
 	return NULL;
 }
 
-static int snd_soc_is_matching_component(
-	const struct snd_soc_dai_link_component *dlc,
-	struct snd_soc_component *component)
-{
-	struct device_node *component_of_node;
-
-	if (!dlc)
-		return 0;
-
-	component_of_node = soc_component_to_node(component);
-
-	if (dlc->of_node && component_of_node != dlc->of_node)
-		return 0;
-	if (dlc->name && strcmp(component->name, dlc->name))
-		return 0;
-
-	return 1;
-}
-
 /**
  * snd_soc_find_dai - Find a registered DAI
  *

commit c2c928c93173f220955030e8440517b87ec7df92
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jun 21 12:33:56 2019 +0100

    ASoC: core: Adapt for debugfs API change
    
    Back in ff9fb72bc07705c (debugfs: return error values, not NULL) the
    debugfs APIs were changed to return error pointers rather than NULL
    pointers on error, breaking the error checking in ASoC. Update the
    code to use IS_ERR() and log the codes that are returned as part of
    the error messages.
    
    Fixes: ff9fb72bc07705c (debugfs: return error values, not NULL)
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9138fcb15cd3..6aeba0d66ec5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -158,9 +158,10 @@ static void soc_init_component_debugfs(struct snd_soc_component *component)
 				component->card->debugfs_card_root);
 	}
 
-	if (!component->debugfs_root) {
+	if (IS_ERR(component->debugfs_root)) {
 		dev_warn(component->dev,
-			"ASoC: Failed to create component debugfs directory\n");
+			"ASoC: Failed to create component debugfs directory: %ld\n",
+			PTR_ERR(component->debugfs_root));
 		return;
 	}
 
@@ -212,18 +213,21 @@ static void soc_init_card_debugfs(struct snd_soc_card *card)
 
 	card->debugfs_card_root = debugfs_create_dir(card->name,
 						     snd_soc_debugfs_root);
-	if (!card->debugfs_card_root) {
+	if (IS_ERR(card->debugfs_card_root)) {
 		dev_warn(card->dev,
-			 "ASoC: Failed to create card debugfs directory\n");
+			 "ASoC: Failed to create card debugfs directory: %ld\n",
+			 PTR_ERR(card->debugfs_card_root));
+		card->debugfs_card_root = NULL;
 		return;
 	}
 
 	card->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0644,
 						    card->debugfs_card_root,
 						    &card->pop_time);
-	if (!card->debugfs_pop_time)
+	if (IS_ERR(card->debugfs_pop_time))
 		dev_warn(card->dev,
-			 "ASoC: Failed to create pop time debugfs file\n");
+			 "ASoC: Failed to create pop time debugfs file: %ld\n",
+			 PTR_ERR(card->debugfs_pop_time));
 }
 
 static void soc_cleanup_card_debugfs(struct snd_soc_card *card)

commit b545542a0b866f7975254e41c595836e9bc0ff2f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 19 10:07:19 2019 +0900

    ASoC: soc-core: call snd_soc_unbind_card() under mutex_lock;
    
    commit 34ac3c3eb8f0c07 ("ASoC: core: lock client_mutex while removing
    link components") added mutex_lock() at soc_remove_link_components().
    
    Is is called from snd_soc_unbind_card()
    
            snd_soc_unbind_card()
    =>              soc_remove_link_components()
                    soc_cleanup_card_resources()
                            soc_remove_dai_links()
    =>                              soc_remove_link_components()
    
    And, there are 2 way to call it.
    
    (1)
            snd_soc_unregister_component()
    **              mutex_lock()
                            snd_soc_component_del_unlocked()
    =>                              snd_soc_unbind_card()
    **              mutex_unlock()
    
    (2)
            snd_soc_unregister_card()
    =>              snd_soc_unbind_card()
    
    (1) case is already using mutex_lock() when it calles
    snd_soc_unbind_card(), thus, we will get lockdep warning.
    
    commit 495f926c68ddb90 ("ASoC: core: Fix deadlock in
    snd_soc_instantiate_card()") tried to fixup it, but still not
    enough. We still have lockdep warning when we try unbind/bind.
    
    We need mutex_lock() under snd_soc_unregister_card()
    instead of snd_remove_link_components()/snd_soc_unbind_card().
    
    Fixes: 34ac3c3eb8f0c07 ("ASoC: core: lock client_mutex while removing link components")
    Fixes: 495f926c68ddb90 ("ASoC: core: Fix deadlock in snd_soc_instantiate_card()")
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 41c0cfaf2db5..9138fcb15cd3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2837,14 +2837,12 @@ static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 		snd_soc_dapm_shutdown(card);
 		snd_soc_flush_all_delayed_work(card);
 
-		mutex_lock(&client_mutex);
 		/* remove all components used by DAI links on this card */
 		for_each_comp_order(order) {
 			for_each_card_rtds(card, rtd) {
 				soc_remove_link_components(card, rtd, order);
 			}
 		}
-		mutex_unlock(&client_mutex);
 
 		soc_cleanup_card_resources(card);
 		if (!unregister)
@@ -2863,7 +2861,9 @@ static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
  */
 int snd_soc_unregister_card(struct snd_soc_card *card)
 {
+	mutex_lock(&client_mutex);
 	snd_soc_unbind_card(card, true);
+	mutex_unlock(&client_mutex);
 	dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 
 	return 0;

commit 1d76898928783d79bfd7c465e891b6cf957c839a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jun 19 10:14:07 2019 +0900

    ASoC: soc-core: allow no Platform on dai_link
    
    dai_link is used to selecting Component (= CPU/Codec/Platform) and
    DAI (= CPU/Codec). And selected CPU/Codec/Platform components are
    *listed* on Card.
    
    Many drivers don't need special Platform component, but was
    mandatory at legacy style ALSA SoC.
    Thus, there is this kind of settings on many drivers.
    
            dai_link->platform_of_node = dai_link->cpu_of_node;
    
    In this case, soc_bind_dai_link() will pick-up "CPU component" as
    "Platform component", and try to add it to snd_soc_pcm_runtime.
    But it will be ignored, because it is already added when CPU bindings.
    
    Historically, this kind of "CPU component" is used/selected as
    "Platform" on many ALSA SoC drivers.
    OTOH, Dummy Platform will be selected automatically by ALSA SoC if
    driver doesn't have Platform settings.
    
    These indicates that there are 2 type of Platforms exist at current
    ALSA SoC if driver doesn't need special Platform.
    
            1) use Dummy Platform as Platform component
            2) use CPU component  as Platform component
    
    ALSA SoC will call Dummy Platform callback function if it is using
    Dummy Platform, but it is completely pointless. Because it is the
    sound card which doesn't need special Platform.
    
    Thus, the behavior we request to ALSA SoC is selecting 2) automatically
    instead of 1) if sound card doesn't need special Platform.
    And, 2) means "do nothing" as above explain.
    
    These were needed at legacy style dai_link, but is no longer needed
    at modern style dai_link anymore.
    
    This patch allows "no Platform" settings on dai_link, and will do
    nothing for it if there was no platform settings. This is same as 2).
    
    By this patch, all drivers which is selecting "CPU component" as
    "Platform" can remove such settings.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f0fa289c90d8..4cd77cd6c864 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -788,6 +788,9 @@ static int snd_soc_is_matching_component(
 {
 	struct device_node *component_of_node;
 
+	if (!dlc)
+		return 0;
+
 	component_of_node = soc_component_to_node(component);
 
 	if (dlc->of_node && component_of_node != dlc->of_node)
@@ -1053,20 +1056,12 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 	}
 }
 
-static struct snd_soc_dai_link_component dummy_link = COMP_DUMMY();
-
 static int soc_init_dai_link(struct snd_soc_card *card,
 			     struct snd_soc_dai_link *link)
 {
 	int i;
 	struct snd_soc_dai_link_component *codec;
 
-	/* default Platform */
-	if (!link->platforms || !link->num_platforms) {
-		link->platforms = &dummy_link;
-		link->num_platforms = 1;
-	}
-
 	for_each_link_codecs(link, i, codec) {
 		/*
 		 * Codec must be specified by 1 of name or OF node,
@@ -1086,32 +1081,39 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 		}
 	}
 
-	/* FIXME */
-	if (link->num_platforms > 1) {
-		dev_err(card->dev,
-			"ASoC: multi platform is not yet supported %s\n",
-			link->name);
-		return -EINVAL;
-	}
-
 	/*
-	 * Platform may be specified by either name or OF node, but
-	 * can be left unspecified, and a dummy platform will be used.
+	 * Platform may be specified by either name or OF node,
+	 * or no Platform.
+	 *
+	 * FIXME
+	 *
+	 * We need multi-platform support
 	 */
-	if (link->platforms->name && link->platforms->of_node) {
-		dev_err(card->dev,
-			"ASoC: Both platform name/of_node are set for %s\n",
-			link->name);
-		return -EINVAL;
-	}
+	if (link->num_platforms > 0) {
 
-	/*
-	 * Defer card registartion if platform dai component is not added to
-	 * component list.
-	 */
-	if ((link->platforms->of_node || link->platforms->name) &&
-	    !soc_find_component(link->platforms->of_node, link->platforms->name))
-		return -EPROBE_DEFER;
+		if (link->num_platforms > 1) {
+			dev_err(card->dev,
+				"ASoC: multi platform is not yet supported %s\n",
+				link->name);
+			return -EINVAL;
+		}
+
+		if (link->platforms->name && link->platforms->of_node) {
+			dev_err(card->dev,
+				"ASoC: Both platform name/of_node are set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
+
+		/*
+		 * Defer card registartion if platform dai component is not
+		 * added to component list.
+		 */
+		if ((link->platforms->of_node || link->platforms->name) &&
+		    !soc_find_component(link->platforms->of_node,
+					link->platforms->name))
+			return -EPROBE_DEFER;
+	}
 
 	/* FIXME */
 	if (link->num_cpus > 1) {

commit 495f926c68ddb905a7a0192963096138c6a934e1
Author: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Date:   Fri Jun 7 22:07:06 2019 -0700

    ASoC: core: Fix deadlock in snd_soc_instantiate_card()
    
    Move the client_mutex lock to snd_soc_unbind_card() before
    removing link components. This prevents the deadlock
    in the error path in snd_soc_instantiate_card().
    
    Fixes: 34ac3c3eb8 (ASoC: core: lock client_mutex while removing
    link components)
    Reported-by: kernelci.org bot <bot@kernelci.org>
    Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3fecd957995e..41c0cfaf2db5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1008,14 +1008,12 @@ static void soc_remove_link_components(struct snd_soc_card *card,
 	struct snd_soc_component *component;
 	struct snd_soc_rtdcom_list *rtdcom;
 
-	mutex_lock(&client_mutex);
 	for_each_rtdcom(rtd, rtdcom) {
 		component = rtdcom->component;
 
 		if (component->driver->remove_order == order)
 			soc_remove_component(component);
 	}
-	mutex_unlock(&client_mutex);
 }
 
 static void soc_remove_dai_links(struct snd_soc_card *card)
@@ -2839,12 +2837,14 @@ static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 		snd_soc_dapm_shutdown(card);
 		snd_soc_flush_all_delayed_work(card);
 
+		mutex_lock(&client_mutex);
 		/* remove all components used by DAI links on this card */
 		for_each_comp_order(order) {
 			for_each_card_rtds(card, rtd) {
 				soc_remove_link_components(card, rtd, order);
 			}
 		}
+		mutex_unlock(&client_mutex);
 
 		soc_cleanup_card_resources(card);
 		if (!unregister)

commit 0779935938b1b6f492f019764bc7dda77bb08ec9
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Fri Jun 7 17:49:26 2019 +0200

    ASoC: Remove erroneous soc_cleanup_card_resources() call
    
    When soc_init_dai_link() call at the beginning of snd_soc_instantiate_card
    function fails soc_cleanup_card_resources() and then snd_soc_dapm_free()
    gets called with an incompletely initialized card->dapm. In particular
    card->dapm.card is NULL and it gets dereferenced in dapm_free_widgets().
    Also dapm->list is invalid and there is an invalid pointer dereference
    from list_del().
    
    The function call stack (deferred probing) on Chromebook Snow where this
    issue has shown up in today's -next is:
    
     snd_soc_dapm_free
     soc_cleanup_card_resources
     snd_soc_instantiate_card
     snd_soc_register_card
     devm_snd_soc_register_card
     snow_probe
    
    In patch 70fc53734e71 "ASoC: core: move DAI pre-links initiation to
    snd_soc_instantiate_card" there is an soc_cleanup_platform() call instead
    of soc_cleanup_card_resources() as in current -next.
    
    soc_cleanup_platform got renamed to soc_cleanup_legacy, then removed
    in commit adb76b5b9c47 "ASoC: soc-core: remove legacy style dai_link".
    
    It seems in merge conflict resolution the soc_cleanup_platform() call got
    renamed to soc_cleanup_card_resources(), instead of being removed.
    
    Correct this by removing an unnecessary soc_cleanup_card_resources() call.
    
    Fixes: a8e992342ce4 ("Merge branch 'asoc-5.2' into asoc-5.3")
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Suggested-by: Tzung-Bi Shih <tzungbi@google.com>
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 94a36ee8eb22..f0fa289c90d8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1986,7 +1986,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	for_each_card_prelinks(card, i, dai_link) {
 		ret = soc_init_dai_link(card, dai_link);
 		if (ret) {
-			soc_cleanup_card_resources(card);
 			dev_err(card->dev, "ASoC: failed to init link %s: %d\n",
 				dai_link->name, ret);
 			mutex_unlock(&client_mutex);

commit a8e992342ce4cd173d437d0aa4eecc9e30489f72
Merge: adb76b5b9c47 04268bf2757a
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jun 6 22:44:24 2019 +0100

    Merge branch 'asoc-5.2' into asoc-5.3

commit adb76b5b9c4740a11f6ad6c68764515961ae8ade
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jun 6 13:22:19 2019 +0900

    ASoC: soc-core: remove legacy style dai_link
    
    All drivers switched to modern style dai_link
    (= struct snd_soc_dai_link_component).
    Let's remove legacy style dai_link.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9bd6b08d79b5..f8426c8120b2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1053,167 +1053,18 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 	}
 }
 
-static int snd_soc_init_cpu(struct snd_soc_card *card,
-			    struct snd_soc_dai_link *dai_link)
-{
-	struct snd_soc_dai_link_component *cpu = dai_link->cpus;
-
-	/*
-	 * REMOVE ME
-	 *
-	 * This is glue code for Legacy vs Modern dai_link.
-	 * This function will be removed if all derivers are switched to
-	 * modern style dai_link.
-	 * Driver shouldn't use both legacy and modern style in the same time.
-	 * see
-	 *	soc.h :: struct snd_soc_dai_link
-	 */
-	/* convert Legacy platform link */
-	if (!cpu) {
-		cpu = devm_kzalloc(card->dev,
-				   sizeof(struct snd_soc_dai_link_component),
-				   GFP_KERNEL);
-		if (!cpu)
-			return -ENOMEM;
-
-		dai_link->cpus		= cpu;
-		dai_link->num_cpus	= 1;
-		dai_link->legacy_cpu	= 1;
-
-		cpu->name	= dai_link->cpu_name;
-		cpu->of_node	= dai_link->cpu_of_node;
-		cpu->dai_name	= dai_link->cpu_dai_name;
-	}
-
-	if (!dai_link->cpus) {
-		dev_err(card->dev, "ASoC: DAI link has no CPUs\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int snd_soc_init_platform(struct snd_soc_card *card,
-				 struct snd_soc_dai_link *dai_link)
-{
-	struct snd_soc_dai_link_component *platform = dai_link->platforms;
-
-	/*
-	 * REMOVE ME
-	 *
-	 * This is glue code for Legacy vs Modern dai_link.
-	 * This function will be removed if all derivers are switched to
-	 * modern style dai_link.
-	 * Driver shouldn't use both legacy and modern style in the same time.
-	 * see
-	 *	soc.h :: struct snd_soc_dai_link
-	 */
-	/* convert Legacy platform link */
-	if (!platform) {
-		platform = devm_kzalloc(card->dev,
-				sizeof(struct snd_soc_dai_link_component),
-				GFP_KERNEL);
-		if (!platform)
-			return -ENOMEM;
-
-		dai_link->platforms	  = platform;
-		dai_link->num_platforms	  = 1;
-		dai_link->legacy_platform = 1;
-		platform->name		  = dai_link->platform_name;
-		platform->of_node	  = dai_link->platform_of_node;
-		platform->dai_name	  = NULL;
-	}
-
-	/* if there's no platform we match on the empty platform */
-	if (!platform->name &&
-	    !platform->of_node)
-		platform->name = "snd-soc-dummy";
-
-	return 0;
-}
-
-static void soc_cleanup_legacy(struct snd_soc_card *card)
-{
-	struct snd_soc_dai_link *link;
-	int i;
-	/*
-	 * FIXME
-	 *
-	 * this function should be removed with snd_soc_init_platform
-	 */
-
-	for_each_card_prelinks(card, i, link) {
-		if (link->legacy_platform) {
-			link->legacy_platform = 0;
-			link->platforms       = NULL;
-		}
-		if (link->legacy_cpu) {
-			link->legacy_cpu = 0;
-			link->cpus = NULL;
-		}
-	}
-}
-
-static int snd_soc_init_multicodec(struct snd_soc_card *card,
-				   struct snd_soc_dai_link *dai_link)
-{
-	/*
-	 * REMOVE ME
-	 *
-	 * This is glue code for Legacy vs Modern dai_link.
-	 * This function will be removed if all derivers are switched to
-	 * modern style dai_link.
-	 * Driver shouldn't use both legacy and modern style in the same time.
-	 * see
-	 *	soc.h :: struct snd_soc_dai_link
-	 */
-
-	/* Legacy codec/codec_dai link is a single entry in multicodec */
-	if (dai_link->codec_name || dai_link->codec_of_node ||
-	    dai_link->codec_dai_name) {
-		dai_link->num_codecs = 1;
-
-		dai_link->codecs = devm_kzalloc(card->dev,
-				sizeof(struct snd_soc_dai_link_component),
-				GFP_KERNEL);
-		if (!dai_link->codecs)
-			return -ENOMEM;
-
-		dai_link->codecs[0].name = dai_link->codec_name;
-		dai_link->codecs[0].of_node = dai_link->codec_of_node;
-		dai_link->codecs[0].dai_name = dai_link->codec_dai_name;
-	}
-
-	if (!dai_link->codecs) {
-		dev_err(card->dev, "ASoC: DAI link has no CODECs\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
+static struct snd_soc_dai_link_component dummy_link = COMP_DUMMY();
 
 static int soc_init_dai_link(struct snd_soc_card *card,
 			     struct snd_soc_dai_link *link)
 {
-	int i, ret;
+	int i;
 	struct snd_soc_dai_link_component *codec;
 
-	ret = snd_soc_init_cpu(card, link);
-	if (ret) {
-		dev_err(card->dev, "ASoC: failed to init cpu\n");
-		return ret;
-	}
-
-	ret = snd_soc_init_platform(card, link);
-	if (ret) {
-		dev_err(card->dev, "ASoC: failed to init multiplatform\n");
-		return ret;
-	}
-
-	ret = snd_soc_init_multicodec(card, link);
-	if (ret) {
-		dev_err(card->dev, "ASoC: failed to init multicodec\n");
-		return ret;
+	/* default Platform */
+	if (!link->platforms || !link->num_platforms) {
+		link->platforms = &dummy_link;
+		link->num_platforms = 1;
 	}
 
 	for_each_link_codecs(link, i, codec) {
@@ -2060,7 +1911,7 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 				 card->dai_link[i].name);
 
 			/* override platform component */
-			if (snd_soc_init_platform(card, dai_link) < 0) {
+			if (!dai_link->platforms) {
 				dev_err(card->dev, "init platform error");
 				continue;
 			}
@@ -2111,7 +1962,6 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	/* remove and free each DAI */
 	soc_remove_dai_links(card);
 	soc_remove_pcm_runtimes(card);
-	soc_cleanup_legacy(card);
 
 	/* remove auxiliary devices */
 	soc_remove_aux_devices(card);
@@ -2868,7 +2718,6 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 		ret = soc_init_dai_link(card, link);
 		if (ret) {
-			soc_cleanup_legacy(card);
 			dev_err(card->dev, "ASoC: failed to init link %s\n",
 				link->name);
 			mutex_unlock(&client_mutex);

commit 587c984427bf7d031a2a4b693dfb24a51cd660b2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jun 6 13:07:42 2019 +0900

    ASoC: soc.h: add sound dai_link connection macro
    
    Modern style dai_link requests CPU/Codec/Platform component
    pointer array and its size, but it will be very verbose code.
    To avoid such scene, this patch adds dai_link connection macro.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f86ee4f48f06..9bd6b08d79b5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -57,6 +57,13 @@ static LIST_HEAD(unbind_card_list);
 #define for_each_component(component)			\
 	list_for_each_entry(component, &component_list, list)
 
+/*
+ * This is used if driver don't need to have CPU/Codec/Platform
+ * dai_link. see soc.h
+ */
+struct snd_soc_dai_link_component null_dailink_component[0];
+EXPORT_SYMBOL_GPL(null_dailink_component);
+
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
  * It can be used to eliminate pops between different playback streams, e.g.

commit 08a5841e3a109f9ea7bfa9c64109aefa95a318c7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jun 6 13:07:22 2019 +0900

    ASoC: soc-core: use snd_soc_dai_link_component for CPU
    
    current ALSA SoC is starting to support modern style dai_linke
    (= struct snd_soc_dai_link_component) which is mainly used for
    multipul DAI/component connection.
    Now Codec has full multi-codec support, Platform is using modern
    style but still for single Platform.
    Only CPU is not yet supporting modern style yet.
    If we could support it for CPU, we can switch to modern style
    dai_link on all CPU/Codec/Platform, and remove legacy style
    from ALSA SoC.
    
    Multi-CPU will be supported in the future.
    This patch is initial support for modern style for CPU
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ace5fb01d9a0..f86ee4f48f06 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -887,7 +887,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 {
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link_component *codecs;
-	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_component *component;
 	int i;
 
@@ -906,13 +905,11 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	if (!rtd)
 		return -ENOMEM;
 
-	cpu_dai_component.name = dai_link->cpu_name;
-	cpu_dai_component.of_node = dai_link->cpu_of_node;
-	cpu_dai_component.dai_name = dai_link->cpu_dai_name;
-	rtd->cpu_dai = snd_soc_find_dai(&cpu_dai_component);
+	/* FIXME: we need multi CPU support in the future */
+	rtd->cpu_dai = snd_soc_find_dai(dai_link->cpus);
 	if (!rtd->cpu_dai) {
 		dev_info(card->dev, "ASoC: CPU DAI %s not registered\n",
-			 dai_link->cpu_dai_name);
+			 dai_link->cpus->dai_name);
 		goto _err_defer;
 	}
 	snd_soc_rtdcom_add(rtd, rtd->cpu_dai->component);
@@ -1049,6 +1046,46 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 	}
 }
 
+static int snd_soc_init_cpu(struct snd_soc_card *card,
+			    struct snd_soc_dai_link *dai_link)
+{
+	struct snd_soc_dai_link_component *cpu = dai_link->cpus;
+
+	/*
+	 * REMOVE ME
+	 *
+	 * This is glue code for Legacy vs Modern dai_link.
+	 * This function will be removed if all derivers are switched to
+	 * modern style dai_link.
+	 * Driver shouldn't use both legacy and modern style in the same time.
+	 * see
+	 *	soc.h :: struct snd_soc_dai_link
+	 */
+	/* convert Legacy platform link */
+	if (!cpu) {
+		cpu = devm_kzalloc(card->dev,
+				   sizeof(struct snd_soc_dai_link_component),
+				   GFP_KERNEL);
+		if (!cpu)
+			return -ENOMEM;
+
+		dai_link->cpus		= cpu;
+		dai_link->num_cpus	= 1;
+		dai_link->legacy_cpu	= 1;
+
+		cpu->name	= dai_link->cpu_name;
+		cpu->of_node	= dai_link->cpu_of_node;
+		cpu->dai_name	= dai_link->cpu_dai_name;
+	}
+
+	if (!dai_link->cpus) {
+		dev_err(card->dev, "ASoC: DAI link has no CPUs\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int snd_soc_init_platform(struct snd_soc_card *card,
 				 struct snd_soc_dai_link *dai_link)
 {
@@ -1088,7 +1125,7 @@ static int snd_soc_init_platform(struct snd_soc_card *card,
 	return 0;
 }
 
-static void soc_cleanup_platform(struct snd_soc_card *card)
+static void soc_cleanup_legacy(struct snd_soc_card *card)
 {
 	struct snd_soc_dai_link *link;
 	int i;
@@ -1103,6 +1140,10 @@ static void soc_cleanup_platform(struct snd_soc_card *card)
 			link->legacy_platform = 0;
 			link->platforms       = NULL;
 		}
+		if (link->legacy_cpu) {
+			link->legacy_cpu = 0;
+			link->cpus = NULL;
+		}
 	}
 }
 
@@ -1150,6 +1191,12 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	int i, ret;
 	struct snd_soc_dai_link_component *codec;
 
+	ret = snd_soc_init_cpu(card, link);
+	if (ret) {
+		dev_err(card->dev, "ASoC: failed to init cpu\n");
+		return ret;
+	}
+
 	ret = snd_soc_init_platform(card, link);
 	if (ret) {
 		dev_err(card->dev, "ASoC: failed to init multiplatform\n");
@@ -1208,12 +1255,20 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	    !soc_find_component(link->platforms->of_node, link->platforms->name))
 		return -EPROBE_DEFER;
 
+	/* FIXME */
+	if (link->num_cpus > 1) {
+		dev_err(card->dev,
+			"ASoC: multi cpu is not yet supported %s\n",
+			link->name);
+		return -EINVAL;
+	}
+
 	/*
 	 * CPU device may be specified by either name or OF node, but
 	 * can be left unspecified, and will be matched based on DAI
 	 * name alone..
 	 */
-	if (link->cpu_name && link->cpu_of_node) {
+	if (link->cpus->name && link->cpus->of_node) {
 		dev_err(card->dev,
 			"ASoC: Neither/both cpu name/of_node are set for %s\n",
 			link->name);
@@ -1224,16 +1279,16 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	 * Defer card registartion if cpu dai component is not added to
 	 * component list.
 	 */
-	if ((link->cpu_of_node || link->cpu_name) &&
-	    !soc_find_component(link->cpu_of_node, link->cpu_name))
+	if ((link->cpus->of_node || link->cpus->name) &&
+	    !soc_find_component(link->cpus->of_node, link->cpus->name))
 		return -EPROBE_DEFER;
 
 	/*
 	 * At least one of CPU DAI name or CPU device name/node must be
 	 * specified
 	 */
-	if (!link->cpu_dai_name &&
-	    !(link->cpu_name || link->cpu_of_node)) {
+	if (!link->cpus->dai_name &&
+	    !(link->cpus->name || link->cpus->of_node)) {
 		dev_err(card->dev,
 			"ASoC: Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
 			link->name);
@@ -2049,7 +2104,7 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	/* remove and free each DAI */
 	soc_remove_dai_links(card);
 	soc_remove_pcm_runtimes(card);
-	soc_cleanup_platform(card);
+	soc_cleanup_legacy(card);
 
 	/* remove auxiliary devices */
 	soc_remove_aux_devices(card);
@@ -2806,7 +2861,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 		ret = soc_init_dai_link(card, link);
 		if (ret) {
-			soc_cleanup_platform(card);
+			soc_cleanup_legacy(card);
 			dev_err(card->dev, "ASoC: failed to init link %s\n",
 				link->name);
 			mutex_unlock(&client_mutex);

commit 3bb936f5b92a0a6b6f4d16d834243e2f62521349
Author: Amadeusz Sławiński <amadeuszx.slawinski@linux.intel.com>
Date:   Wed Jun 5 15:45:53 2019 +0200

    ASoC: core: Tell codec that jack is being removed
    
    When component is being removed we should disable jack, otherwise some
    codecs will try to trigger interrupt using freed structures.
    
    Signed-off-by: Amadeusz Sławiński <amadeuszx.slawinski@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7abb017a83f3..ace5fb01d9a0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -951,6 +951,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 static void soc_cleanup_component(struct snd_soc_component *component)
 {
+	snd_soc_component_set_jack(component, NULL, NULL);
 	list_del(&component->card_list);
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 	soc_cleanup_component_debugfs(component);

commit 70fc53734e71ce51f46dfcfd1a1c319e1cfe080c
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Tue Jun 4 11:31:02 2019 +0800

    ASoC: core: move DAI pre-links initiation to snd_soc_instantiate_card
    
    Kernel crashes when an ASoC component rebinding.
    
    The dai_link->platforms has been reset to NULL by soc_cleanup_platform()
    in soc_cleanup_card_resources() when un-registering component.  However,
    it has no chance to re-allocate the dai_link->platforms when registering
    the component again.
    
    Move the DAI pre-links initiation from snd_soc_register_card() to
    snd_soc_instantiate_card() to make sure all DAI pre-links get initiated
    when component rebinding.
    
    As an example, by using the following commands:
    - echo -n max98357a > /sys/bus/platform/drivers/max98357a/unbind
    - echo -n max98357a > /sys/bus/platform/drivers/max98357a/bind
    
    Got the error message:
    "Unable to handle kernel NULL pointer dereference at virtual address".
    
    The call trace:
    snd_soc_is_matching_component+0x30/0x6c
    soc_bind_dai_link+0x16c/0x240
    snd_soc_bind_card+0x1e4/0xb10
    snd_soc_add_component+0x270/0x300
    snd_soc_register_component+0x54/0x6c
    
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 46042d41b79b..3fecd957995e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2072,6 +2072,16 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	int ret, i, order;
 
 	mutex_lock(&client_mutex);
+	for_each_card_prelinks(card, i, dai_link) {
+		ret = soc_init_dai_link(card, dai_link);
+		if (ret) {
+			soc_cleanup_platform(card);
+			dev_err(card->dev, "ASoC: failed to init link %s: %d\n",
+				dai_link->name, ret);
+			mutex_unlock(&client_mutex);
+			return ret;
+		}
+	}
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
 	card->dapm.bias_level = SND_SOC_BIAS_OFF;
@@ -2796,26 +2806,9 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
  */
 int snd_soc_register_card(struct snd_soc_card *card)
 {
-	int i, ret;
-	struct snd_soc_dai_link *link;
-
 	if (!card->name || !card->dev)
 		return -EINVAL;
 
-	mutex_lock(&client_mutex);
-	for_each_card_prelinks(card, i, link) {
-
-		ret = soc_init_dai_link(card, link);
-		if (ret) {
-			soc_cleanup_platform(card);
-			dev_err(card->dev, "ASoC: failed to init link %s\n",
-				link->name);
-			mutex_unlock(&client_mutex);
-			return ret;
-		}
-	}
-	mutex_unlock(&client_mutex);
-
 	dev_set_drvdata(card->dev, card);
 
 	snd_soc_initialize_card_lists(card);

commit 9d563eb95b81f32b9ffa4255033717484d50d06b
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Fri May 31 12:34:02 2019 +0200

    Revert "ASoC: core: use component driver name as component name"
    
    Using component driver as a name is not unique and it breaks audio in
    certain configurations, e.g. Hardkernel Odroid XU3 board where following
    components are registered:
     - "3830000.i2s" with driver name "snd_dmaengine_pcm"
     - "3830000.i2s-sec" with driver name "snd_dmaengine_pcm"
     - "3830000.i2s" with driver name "samsung-i2s"
    
    This reverts commit b19671d6caf1ac393681864d5d85dda9fa99a448.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2d3520fca613..7abb017a83f3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3113,10 +3113,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 {
 	struct snd_soc_dapm_context *dapm;
 
-	if (driver->name)
-		component->name = kstrdup(driver->name, GFP_KERNEL);
-	else
-		component->name = fmt_single_name(dev, &component->id);
+	component->name = fmt_single_name(dev, &component->id);
 	if (!component->name) {
 		dev_err(dev, "ASoC: Failed to allocate name\n");
 		return -ENOMEM;

commit 79b3b7c4a396b9fa1963ac70e853998633e8151d
Merge: e13ef82a9ab8 1f2675f66558
Author: Mark Brown <broonie@kernel.org>
Date:   Thu May 30 16:47:43 2019 +0100

    Merge branch 'asoc-5.2' into asoc-5.3

commit b19671d6caf1ac393681864d5d85dda9fa99a448
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Wed May 29 14:22:14 2019 +0800

    ASoC: core: use component driver name as component name
    
    fmt_single_name() uses device name to determine component name.  If
    multiple components bind to the same device, the debugfs creation in
    soc_init_component_debugfs() would fail due to duplicated entity
    names.
    
    Name provided by component driver is unique enough to represent each
    component.  Use component driver name as the component name to avoid
    name duplication.
    
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ce8c057bcd5b..5f83e2f19801 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3106,7 +3106,10 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 {
 	struct snd_soc_dapm_context *dapm;
 
-	component->name = fmt_single_name(dev, &component->id);
+	if (driver->name)
+		component->name = kstrdup(driver->name, GFP_KERNEL);
+	else
+		component->name = fmt_single_name(dev, &component->id);
 	if (!component->name) {
 		dev_err(dev, "ASoC: Failed to allocate name\n");
 		return -ENOMEM;

commit 29040d1ac569606fece70966179de272cfc0d4db
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon May 27 16:51:34 2019 +0900

    ASoC: soc-core: fixup references at soc_cleanup_card_resources()
    
    commit 53e947a0e1f7 ("ASoC: soc-core: merge card resources cleanup
    method") merged cleanup method of snd_soc_instantiate_card() and
    soc_cleanup_card_resources().
    
    But, after this commit, if user uses unbind/bind to Component factor
    drivers, Kernel might indicates refcount error at
    soc_cleanup_card_resources().
    
    The 1st reason is card->snd_card is still exist even though
    snd_card_free() was called, but it is already cleaned.
    We need to set NULL to it.
    
    2nd is card->dapm and card create debugfs, but its dentry is still
    exist even though it was removed. We need to set NULL to it.
    
    Fixes: 53e947a0e1f7 ("ASoC: soc-core: merge card resources cleanup method")
    Cc: stable@vger.kernel.org # for v5.1
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7c9415987ac7..46042d41b79b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -228,7 +228,10 @@ static void soc_init_card_debugfs(struct snd_soc_card *card)
 
 static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 {
+	if (!card->debugfs_card_root)
+		return;
 	debugfs_remove_recursive(card->debugfs_card_root);
+	card->debugfs_card_root = NULL;
 }
 
 static void snd_soc_debugfs_init(void)
@@ -2039,8 +2042,10 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 static int soc_cleanup_card_resources(struct snd_soc_card *card)
 {
 	/* free the ALSA card at first; this syncs with pending operations */
-	if (card->snd_card)
+	if (card->snd_card) {
 		snd_card_free(card->snd_card);
+		card->snd_card = NULL;
+	}
 
 	/* remove and free each DAI */
 	soc_remove_dai_links(card);

commit 34ac3c3eb8f0c07252ceddf0a22dd240e5c91ccb
Author: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Date:   Thu May 23 10:12:01 2019 -0700

    ASoC: core: lock client_mutex while removing link components
    
    Removing link components results in topology unloading. So,
    acquire the client_mutex before removing components in
    soc_remove_link_components. This will prevent the lockdep warning
    seen when dai links are removed during topology removal.
    
    Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2403bec2fccf..7c9415987ac7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1005,12 +1005,14 @@ static void soc_remove_link_components(struct snd_soc_card *card,
 	struct snd_soc_component *component;
 	struct snd_soc_rtdcom_list *rtdcom;
 
+	mutex_lock(&client_mutex);
 	for_each_rtdcom(rtd, rtdcom) {
 		component = rtdcom->component;
 
 		if (component->driver->remove_order == order)
 			soc_remove_component(component);
 	}
+	mutex_unlock(&client_mutex);
 }
 
 static void soc_remove_dai_links(struct snd_soc_card *card)

commit 2ffb0f580bded5f16ec4d619f8abb4745425e864
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri May 17 15:06:37 2019 +0900

    ASoC: soc-core: WARN() is not related to component->driver->probe
    
    soc_probe_component() has WARN() under if (component->driver->probe),
    but, this WARN() check is not related to .probe callback.
    So, it should be called at (B) instead of (A).
    This patch moves it out of if().
    
            if (component->driver->probe) {
                    ret = component->driver->probe(component);
                    ...
    (A)             WARN(...)
            }
    (B)     WARN(...)
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e83edbe27041..ce8c057bcd5b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1420,12 +1420,11 @@ static int soc_probe_component(struct snd_soc_card *card,
 				"ASoC: failed to probe component %d\n", ret);
 			goto err_probe;
 		}
-
-		WARN(dapm->idle_bias_off &&
-			dapm->bias_level != SND_SOC_BIAS_OFF,
-			"codec %s can not start from non-off bias with idle_bias_off==1\n",
-			component->name);
 	}
+	WARN(dapm->idle_bias_off &&
+	     dapm->bias_level != SND_SOC_BIAS_OFF,
+	     "codec %s can not start from non-off bias with idle_bias_off==1\n",
+	     component->name);
 
 	/* machine specific init */
 	if (component->init) {

commit 09d4cc03ff77790872b8b9e51b6d7b5863686fc5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon May 13 16:07:20 2019 +0900

    ASoC: soc-core: use soc_find_component() at snd_soc_get_dai_id()
    
    soc-core core already has soc_find_component() which find
    component from device node.
    Let's use existing function to find component.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e55170ce6d3e..e83edbe27041 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3751,7 +3751,7 @@ EXPORT_SYMBOL_GPL(snd_soc_of_parse_daifmt);
 
 int snd_soc_get_dai_id(struct device_node *ep)
 {
-	struct snd_soc_component *pos;
+	struct snd_soc_component *component;
 	struct device_node *node;
 	int ret;
 
@@ -3765,17 +3765,10 @@ int snd_soc_get_dai_id(struct device_node *ep)
 	 */
 	ret = -ENOTSUPP;
 	mutex_lock(&client_mutex);
-	for_each_component(pos) {
-		struct device_node *component_of_node = soc_component_to_node(pos);
-
-		if (component_of_node != node)
-			continue;
-
-		if (pos->driver->of_xlate_dai_id)
-			ret = pos->driver->of_xlate_dai_id(pos, ep);
-
-		break;
-	}
+	component = soc_find_component(node, NULL);
+	if (component &&
+	    component->driver->of_xlate_dai_id)
+		ret = component->driver->of_xlate_dai_id(component, ep);
 	mutex_unlock(&client_mutex);
 
 	of_node_put(node);

commit c083444061ada428af71809cc12fd8f06dd2be19
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon May 13 16:06:59 2019 +0900

    ASoC: soc-core: add soc_component_to_node()
    
    Many function are getting device_node from component
    with caring its parent component.
    This patch adds new soc_component_to_node() and share
    same code.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c80e7df3b20b..e55170ce6d3e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -738,6 +738,18 @@ EXPORT_SYMBOL_GPL(snd_soc_resume);
 static const struct snd_soc_dai_ops null_dai_ops = {
 };
 
+static struct device_node
+*soc_component_to_node(struct snd_soc_component *component)
+{
+	struct device_node *of_node;
+
+	of_node = component->dev->of_node;
+	if (!of_node && component->dev->parent)
+		of_node = component->dev->parent->of_node;
+
+	return of_node;
+}
+
 static struct snd_soc_component *soc_find_component(
 	const struct device_node *of_node, const char *name)
 {
@@ -748,9 +760,7 @@ static struct snd_soc_component *soc_find_component(
 
 	for_each_component(component) {
 		if (of_node) {
-			component_of_node = component->dev->of_node;
-			if (!component_of_node && component->dev->parent)
-				component_of_node = component->dev->parent->of_node;
+			component_of_node = soc_component_to_node(component);
 
 			if (component_of_node == of_node)
 				return component;
@@ -768,9 +778,7 @@ static int snd_soc_is_matching_component(
 {
 	struct device_node *component_of_node;
 
-	component_of_node = component->dev->of_node;
-	if (!component_of_node && component->dev->parent)
-		component_of_node = component->dev->parent->of_node;
+	component_of_node = soc_component_to_node(component);
 
 	if (dlc->of_node && component_of_node != dlc->of_node)
 		return 0;
@@ -1317,13 +1325,10 @@ EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
 
 static void soc_set_of_name_prefix(struct snd_soc_component *component)
 {
-	struct device_node *component_of_node = component->dev->of_node;
+	struct device_node *component_of_node = soc_component_to_node(component);
 	const char *str;
 	int ret;
 
-	if (!component_of_node && component->dev->parent)
-		component_of_node = component->dev->parent->of_node;
-
 	ret = of_property_read_string(component_of_node, "sound-name-prefix",
 				      &str);
 	if (!ret)
@@ -1337,10 +1342,7 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 
 	for (i = 0; i < card->num_configs && card->codec_conf; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
-		struct device_node *component_of_node = component->dev->of_node;
-
-		if (!component_of_node && component->dev->parent)
-			component_of_node = component->dev->parent->of_node;
+		struct device_node *component_of_node = soc_component_to_node(component);
 
 		if (map->of_node && component_of_node != map->of_node)
 			continue;
@@ -3764,10 +3766,7 @@ int snd_soc_get_dai_id(struct device_node *ep)
 	ret = -ENOTSUPP;
 	mutex_lock(&client_mutex);
 	for_each_component(pos) {
-		struct device_node *component_of_node = pos->dev->of_node;
-
-		if (!component_of_node && pos->dev->parent)
-			component_of_node = pos->dev->parent->of_node;
+		struct device_node *component_of_node = soc_component_to_node(pos);
 
 		if (component_of_node != node)
 			continue;
@@ -3794,9 +3793,7 @@ int snd_soc_get_dai_name(struct of_phandle_args *args,
 
 	mutex_lock(&client_mutex);
 	for_each_component(pos) {
-		component_of_node = pos->dev->of_node;
-		if (!component_of_node && pos->dev->parent)
-			component_of_node = pos->dev->parent->of_node;
+		component_of_node = soc_component_to_node(pos);
 
 		if (component_of_node != args->np)
 			continue;

commit e2b30edfb9435879dc68cdb7ce20299492012101
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon May 13 16:06:44 2019 +0900

    ASoC: soc-core: tidyup soc_bind_dai_link() comment balance
    
    Many code at soc_bind_dai_link() was changed, and its comment is
    now a little bit anbalanced.
    This patch tidyup these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2ceca7fdf622..c80e7df3b20b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -906,9 +906,8 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	}
 	snd_soc_rtdcom_add(rtd, rtd->cpu_dai->component);
 
-	rtd->num_codecs = dai_link->num_codecs;
-
 	/* Find CODEC from registered CODECs */
+	rtd->num_codecs = dai_link->num_codecs;
 	for_each_link_codecs(dai_link, i, codecs) {
 		rtd->codec_dais[i] = snd_soc_find_dai(codecs);
 		if (!rtd->codec_dais[i]) {
@@ -922,7 +921,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	/* Single codec links expect codec and codec_dai in runtime data */
 	rtd->codec_dai = rtd->codec_dais[0];
 
-	/* find one from the set of registered platforms */
+	/* Find PLATFORM from registered PLATFORMs */
 	for_each_component(component) {
 		if (!snd_soc_is_matching_component(dai_link->platforms,
 						   component))

commit 0a2cfcd998e3503c20be497cadb0ef23edb984be
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon May 13 16:06:30 2019 +0900

    ASoC: soc-core: don't use codec_dais on soc_bind_dai_link()
    
    Current soc_bind_dai_link() is substituting rtd->codec_dais to
    codec_dais, and sets found DAI into it.
    But, it is a little bit un-readable / un-understandable to
    know detail of rtd, and it will make difficult to understand
    rtd->cpu_dais if Multi CPU was supported.
    This patch cleanup it and prepare for Multi CPU support.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0d9b02075050..2ceca7fdf622 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -878,7 +878,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link_component *codecs;
 	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_component *component;
-	struct snd_soc_dai **codec_dais;
 	int i;
 
 	if (dai_link->ignore)
@@ -910,19 +909,18 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	rtd->num_codecs = dai_link->num_codecs;
 
 	/* Find CODEC from registered CODECs */
-	codec_dais = rtd->codec_dais;
 	for_each_link_codecs(dai_link, i, codecs) {
-		codec_dais[i] = snd_soc_find_dai(codecs);
-		if (!codec_dais[i]) {
+		rtd->codec_dais[i] = snd_soc_find_dai(codecs);
+		if (!rtd->codec_dais[i]) {
 			dev_info(card->dev, "ASoC: CODEC DAI %s not registered\n",
 				 codecs->dai_name);
 			goto _err_defer;
 		}
-		snd_soc_rtdcom_add(rtd, codec_dais[i]->component);
+		snd_soc_rtdcom_add(rtd, rtd->codec_dais[i]->component);
 	}
 
 	/* Single codec links expect codec and codec_dai in runtime data */
-	rtd->codec_dai = codec_dais[0];
+	rtd->codec_dai = rtd->codec_dais[0];
 
 	/* find one from the set of registered platforms */
 	for_each_component(component) {

commit 22d251a5964780452aed378a143816fbf2d4201d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon May 13 16:06:07 2019 +0900

    ASoC: soc-core: use i on snd_soc_resume()
    
    This patch uses "int i" instead of "int j" on snd_soc_resume(),
    and moves struct snd_soc_dai *codec_dai to top of this function.
    This is cleanup and prepare for Multi CPU support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2403bec2fccf..0d9b02075050 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -687,6 +687,8 @@ int snd_soc_resume(struct device *dev)
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	bool bus_control = false;
 	struct snd_soc_pcm_runtime *rtd;
+	struct snd_soc_dai *codec_dai;
+	int i;
 
 	/* If the card is not initialized yet there is nothing to do */
 	if (!card->instantiated)
@@ -694,14 +696,12 @@ int snd_soc_resume(struct device *dev)
 
 	/* activate pins from sleep state */
 	for_each_card_rtds(card, rtd) {
-		struct snd_soc_dai *codec_dai;
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-		int j;
 
 		if (cpu_dai->active)
 			pinctrl_pm_select_default_state(cpu_dai->dev);
 
-		for_each_rtd_codec_dai(rtd, j, codec_dai) {
+		for_each_rtd_codec_dai(rtd, i, codec_dai) {
 			if (codec_dai->active)
 				pinctrl_pm_select_default_state(codec_dai->dev);
 		}

commit 93f38ef6a4b62fd57076d36d1345d69f8a328ad9
Merge: 552f2d7edd38 780f202f2bf4
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 26 11:02:03 2019 +0100

    Merge branch 'asoc-5.1' into asoc-5.2

commit b4ed6b51f356224c6c71540ed94087f7f09b84af
Author: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Date:   Fri Apr 5 09:57:08 2019 -0700

    ASoC: core: conditionally increase module refcount on component open
    
    Recently, for Intel platforms the "ignore_module_refcount" field
    was introduced for the component driver. In order to avoid a
    deadlock preventing the PCI modules from being removed
    even when the card was idle, the refcounts were not incremented
    for the device driver module during component probe.
    
    However, this change introduced a nasty side effect:
    the device driver module can be unloaded while a pcm stream is open.
    
    This patch proposes to change the field to be renamed as
    "module_get_upon_open". When this field is set, the module
    refcount should be incremented on pcm open amd decremented
    upon pcm close. This will enable modules to be removed
    when no PCM playback/capture happens and prevent removal
    when the component is actually in use.
    
    Also, align with the skylake component driver with the new name.
    
    Fixes: b450b878('ASoC: core: don't increase component module refcount
                     unconditionally'
    Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Acked-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d88757659729..46e3ab0fced4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -947,7 +947,7 @@ static void soc_cleanup_component(struct snd_soc_component *component)
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 	soc_cleanup_component_debugfs(component);
 	component->card = NULL;
-	if (!component->driver->ignore_module_refcount)
+	if (!component->driver->module_get_upon_open)
 		module_put(component->dev->driver->owner);
 }
 
@@ -1381,7 +1381,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 		return 0;
 	}
 
-	if (!component->driver->ignore_module_refcount &&
+	if (!component->driver->module_get_upon_open &&
 	    !try_module_get(component->dev->driver->owner))
 		return -ENODEV;
 

commit f96fb7d198ca624fe33c4145a004eb5a3d0eddec
Author: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Date:   Thu Apr 4 17:30:40 2019 -0700

    ASoC: core: remove link components before cleaning up card resources
    
    When the card is registered by the machine driver,
    dai link components are probed after the snd_card is
    created. This is done in snd_soc_bind_card() which calls
    snd_soc_instantiate_card() to first create the snd_card
    and then probes the link components by calling
    soc_probe_link_components(). The snd_card is used by the
    component driver to add the kcontrols associated
    with dapm widgets to the card.
    
    When the machine driver is unregistered, the snd_card
    is freed when the card resources are cleaned up.
    But the snd_card needs to be valid while unloading the
    topology dapm widgets in order to remove the kcontrols
    from the card.
    
    Since, unloading topology is done when the component
    driver is removed, the link components should be removed
    in snd_soc_unbind_card(). This will ensure that the kcontrols
    are removed before the card resources are cleaned up and
    the snd_card itself is freed.
    
    Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6f4842977b8d..75f6a8085a76 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2831,10 +2831,21 @@ EXPORT_SYMBOL_GPL(snd_soc_register_card);
 
 static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 {
+	struct snd_soc_pcm_runtime *rtd;
+	int order;
+
 	if (card->instantiated) {
 		card->instantiated = false;
 		snd_soc_dapm_shutdown(card);
 		snd_soc_flush_all_delayed_work(card);
+
+		/* remove all components used by DAI links on this card */
+		for_each_comp_order(order) {
+			for_each_card_rtds(card, rtd) {
+				soc_remove_link_components(card, rtd, order);
+			}
+		}
+
 		soc_cleanup_card_resources(card);
 		if (!unregister)
 			list_add(&card->list, &unbind_card_list);

commit e194098bf9098083f8ae9687924a6878540f8561
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Mar 1 19:08:51 2019 -0600

    ASoC: core: support driver alias names for FE topology overrides
    
    When the same machine driver is reused between platforms but with a
    different alias, using the driver name is not enough. Add additional
    fallback case to use the card device name.
    
    Tested on GeminiLake with bxt_da7219_max98357a machine driver
    
    Suggested-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d88757659729..6f4842977b8d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1974,10 +1974,13 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 			continue;
 
 		/* for this machine ? */
+		if (!strcmp(component->driver->ignore_machine,
+			    card->dev->driver->name))
+			goto match;
 		if (strcmp(component->driver->ignore_machine,
-			   card->dev->driver->name))
+			   dev_name(card->dev)))
 			continue;
-
+match:
 		/* machine matches, so override the rtd data */
 		for_each_card_prelinks(card, i, dai_link) {
 

commit a9764869779081e8bf24da07ac040e8f3efcf13a
Author: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
Date:   Fri Mar 8 13:05:53 2019 +0800

    ASoC: dpcm: prevent snd_soc_dpcm use after free
    
    The dpcm get from fe_clients/be_clients
    may be free before use
    
    Add a spin lock at snd_soc_card level,
    to protect the dpcm instance.
    The lock may be used in atomic context, so use spin lock.
    
    Use irq spin lock version,
    since the lock may be used in interrupts.
    
    possible race condition between
    void dpcm_be_disconnect(
            ...
            list_del(&dpcm->list_be);
            list_del(&dpcm->list_fe);
            kfree(dpcm);
            ...
    
    and
            for_each_dpcm_fe()
            for_each_dpcm_be*()
    
    race condition example
    Thread 1:
        snd_soc_dapm_mixer_update_power()
            -> soc_dpcm_runtime_update()
                -> dpcm_be_disconnect()
                    -> kfree(dpcm);
    Thread 2:
        dpcm_fe_dai_trigger()
            -> dpcm_be_dai_trigger()
                -> snd_soc_dpcm_can_be_free_stop()
                    -> if (dpcm->fe == fe)
    
    Excpetion Scenario:
            two FE link to same BE
            FE1 -> BE
            FE2 ->
    
            Thread 1: switch of mixer between FE2 -> BE
            Thread 2: pcm_stop FE1
    
    Exception:
    
    Unable to handle kernel paging request at virtual address dead0000000000e0
    
    pc=<> [<ffffff8960e2cd10>] dpcm_be_dai_trigger+0x29c/0x47c
            sound/soc/soc-pcm.c:3226
                    if (dpcm->fe == fe)
    lr=<> [<ffffff8960e2f694>] dpcm_fe_dai_do_trigger+0x94/0x26c
    
    Backtrace:
    [<ffffff89602dba80>] notify_die+0x68/0xb8
    [<ffffff896028c7dc>] die+0x118/0x2a8
    [<ffffff89602a2f84>] __do_kernel_fault+0x13c/0x14c
    [<ffffff89602a27f4>] do_translation_fault+0x64/0xa0
    [<ffffff8960280cf8>] do_mem_abort+0x4c/0xd0
    [<ffffff8960282ad0>] el1_da+0x24/0x40
    [<ffffff8960e2cd10>] dpcm_be_dai_trigger+0x29c/0x47c
    [<ffffff8960e2f694>] dpcm_fe_dai_do_trigger+0x94/0x26c
    [<ffffff8960e2edec>] dpcm_fe_dai_trigger+0x3c/0x44
    [<ffffff8960de5588>] snd_pcm_do_stop+0x50/0x5c
    [<ffffff8960dded24>] snd_pcm_action+0xb4/0x13c
    [<ffffff8960ddfdb4>] snd_pcm_drop+0xa0/0x128
    [<ffffff8960de69bc>] snd_pcm_common_ioctl+0x9d8/0x30f0
    [<ffffff8960de1cac>] snd_pcm_ioctl_compat+0x29c/0x2f14
    [<ffffff89604c9d60>] compat_SyS_ioctl+0x128/0x244
    [<ffffff8960283740>] el0_svc_naked+0x34/0x38
    [<ffffffffffffffff>] 0xffffffffffffffff
    
    Signed-off-by: KaiChieh Chuang <kaichieh.chuang@mediatek.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5a5764dba147..d88757659729 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2820,6 +2820,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	card->instantiated = 0;
 	mutex_init(&card->mutex);
 	mutex_init(&card->dapm_mutex);
+	spin_lock_init(&card->dpcm_lock);
 
 	return snd_soc_bind_card(card);
 }

commit c342febcde452f817cbd3896dc40953ab17c309d
Author: Jonathan Hunter <jonathanh@nvidia.com>
Date:   Mon Mar 4 13:31:14 2019 +0000

    ASoC: soc-core: Fix probe deferral following prelink failure
    
    Commit 78a24e10cd94 ("ASoC: soc-core: clear platform pointers on error")
    re-worked the clean-up of any platform pointers that may have been
    initialised by the function snd_soc_init_platform(). This commit missed
    one error path where if any of the prelinks for a soundcard failed to
    initialise, then these platform pointers would not be cleaned-up. This
    then prevents the soundcard from being initialised following a probe
    deferral when any of the soundcard prelinks cannot be found.
    
    Fix this by ensuring that soc_cleanup_platform() is called when
    initialising the soundcard prelinks fails.
    
    Fixes: 78a24e10cd94 ("ASoC: soc-core: clear platform pointers on error")
    
    Signed-off-by: Jonathan Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 93d316d5bf8e..5a5764dba147 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2797,6 +2797,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 		ret = soc_init_dai_link(card, link);
 		if (ret) {
+			soc_cleanup_platform(card);
 			dev_err(card->dev, "ASoC: failed to init link %s\n",
 				link->name);
 			mutex_unlock(&client_mutex);

commit b450b87847b157d69dbf9af7aefb4cec29e89cc9
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Feb 1 11:22:23 2019 -0600

    ASoC: core: don't increase component module refcount unconditionally
    
    The ASoC core has for the longest time increased the module reference
    counts, even before the transition to the component model. This is
    probably fine on most platforms, but it introduces a deadlock case on
    Intel devices with the Skylake and SOF drivers which cannot be removed
    due to their reference counts being modified by the core.
    
    In these 2 cases, the PCI or ACPI driver .probe creates a platform
    device to let the machine driver .probe register the audio
    card. Conversely the PCI or ACPI driver .remove will unregister the
    platform device which results in the card being removed by the machine
    driver .remove.
    
    With ascii art, this can be represented as
    
    modprobe
    snd_soc_skl/
    soc-pci-dev/sof-acpci-dev  ----------> pci/acpi probe
           ^                                    |
           |                     ---------------|
           |                    |               |
           |                    V               V
        increase            register        register machine
        refcount            component       platform_device
           ^                                    |
           |                                    |
           |                                    V
        component <----   register card  <---- probe
        probe
    
    The issue is that by playing with the component's module reference
    counts during the card registration, it's no longer possible to remove
    the module which controls the component. This can be shown, e.g. with
    the following error:
    
    root@plb-XPS-13-9350:~# lsmod | grep snd_soc_skl
    snd_soc_skl           110592  1
    
    root@plb-XPS-13-9350:~# rmmod snd_soc_skl
    rmmod: ERROR: Module snd_soc_skl is in use
    
    Increasing the reference count during the component probe is not
    useful. If the PCI/ACPI module is removed, the card will be removed
    anyway.
    
    To avoid breaking existing platforms and allowing Intel platforms to
    safely deal with module load/unload cases, this patch introduces a
    flag which needs to be set during the component initialization. This
    is a strictly opt-in capability that should only be used when the
    handling of the component module does not require a reference count
    increase to prevent removal during use.
    
    Note that this solution is not directly applicable to the legacy
    Atom/SST driver, which uses a different device hierarchy. There are
    however additional refcount issues which prevent the ACPI driver from
    being removed. This is a different issue which would need a different
    patch.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 994d21d7ba0f..93d316d5bf8e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -947,7 +947,8 @@ static void soc_cleanup_component(struct snd_soc_component *component)
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 	soc_cleanup_component_debugfs(component);
 	component->card = NULL;
-	module_put(component->dev->driver->owner);
+	if (!component->driver->ignore_module_refcount)
+		module_put(component->dev->driver->owner);
 }
 
 static void soc_remove_component(struct snd_soc_component *component)
@@ -1380,7 +1381,8 @@ static int soc_probe_component(struct snd_soc_card *card,
 		return 0;
 	}
 
-	if (!try_module_get(component->dev->driver->owner))
+	if (!component->driver->ignore_module_refcount &&
+	    !try_module_get(component->dev->driver->owner))
 		return -ENODEV;
 
 	component->card = card;

commit e29fe437ea5d926ea23d806b2468bf60ee8dc08a
Merge: 47306401835a c16e12010060
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Feb 6 17:31:39 2019 +0000

    Merge branch 'asoc-5.0' into asoc-5.1 for dapm table

commit 78a24e10cd94420f1b4e2dc5923ae7109e2aaba1
Author: Curtis Malainey <cujomalainey@chromium.org>
Date:   Tue Jan 29 13:47:09 2019 -0800

    ASoC: soc-core: clear platform pointers on error
    
    Originally snd_soc_init_platform was not cleaning up its pointers, this
    was fixed to always reallocate dynamic memory but created a memory leak
    when snd_soc_init_platform was called multiple times during the same
    probe attempt and also threw away any changes made to the struct between
    calls. In order to avoid reallocating memory that is still valid, the
    behaviour will be changed to clear the dynamically set pointers on a
    probe error and a unregister event and snd_soc_init_platform will go
    back to its original behaviour of only allocating null pointers so it will
    stop throwing away valid changes.
    
    Signed-off-by: Curtis Malainey <cujomalainey@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 93efab486736..8c63d32ab2fe 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1048,7 +1048,7 @@ static int snd_soc_init_platform(struct snd_soc_card *card,
 	 *	soc.h :: struct snd_soc_dai_link
 	 */
 	/* convert Legacy platform link */
-	if (!platform || dai_link->legacy_platform) {
+	if (!platform) {
 		platform = devm_kzalloc(card->dev,
 				sizeof(struct snd_soc_dai_link_component),
 				GFP_KERNEL);
@@ -1071,6 +1071,24 @@ static int snd_soc_init_platform(struct snd_soc_card *card,
 	return 0;
 }
 
+static void soc_cleanup_platform(struct snd_soc_card *card)
+{
+	struct snd_soc_dai_link *link;
+	int i;
+	/*
+	 * FIXME
+	 *
+	 * this function should be removed with snd_soc_init_platform
+	 */
+
+	for_each_card_prelinks(card, i, link) {
+		if (link->legacy_platform) {
+			link->legacy_platform = 0;
+			link->platforms       = NULL;
+		}
+	}
+}
+
 static int snd_soc_init_multicodec(struct snd_soc_card *card,
 				   struct snd_soc_dai_link *dai_link)
 {
@@ -2015,6 +2033,7 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	/* remove and free each DAI */
 	soc_remove_dai_links(card);
 	soc_remove_pcm_runtimes(card);
+	soc_cleanup_platform(card);
 
 	/* remove auxiliary devices */
 	soc_remove_aux_devices(card);

commit 52abe6cc1866ac3d54612f5d80563e6608c0ddfc
Author: Guennadi Liakhovetski <guennadi.liakhovetski@intel.com>
Date:   Fri Feb 1 11:05:13 2019 -0600

    ASoC: topology: fix oops/use-after-free case with dai driver
    
    rmmod/modprobe tests expose a kernel oops when accessing the dai
    driver pointer. This comes from the topology design which operates in
    multiple passes. Each object removal happens at a specific iteration,
    and the code checks for the iteration (order) number after the memory
    containing the order was freed.
    
    Fix this be clearing a reference to the dai driver and check its
    validity to avoid dereferences.
    
    Signed-off-by: Guennadi Liakhovetski <guennadi.liakhovetski@intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ea16c2b199ce..50617db05c46 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -956,7 +956,7 @@ static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 {
 	int err;
 
-	if (!dai || !dai->probed ||
+	if (!dai || !dai->probed || !dai->driver ||
 	    dai->driver->remove_order != order)
 		return;
 

commit 720734a0b66f9ca42ec6663a48702b16e49552ee
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 28 10:40:24 2019 +0900

    ASoC: soc-core: use for_each_link_codecs() for dai_link codecs V2
    
    We can use for_each_link_codecs() without waiting
    for_each_rtd_codec_dai() on soc_bind_dai_link().
    Let's use for_each macro.
    
    Fixes: 50acc7e49 ("ASoC: core: Fix multi-CODEC setups")
    Fixes: 10dff9b0d ("ASoC: soc-core: use for_each_link_codecs() for dai_link codecs")
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8a58fa86675a..93efab486736 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -870,7 +870,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
+	struct snd_soc_dai_link_component *codecs;
 	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_component *component;
 	struct snd_soc_dai **codec_dais;
@@ -905,13 +905,12 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	rtd->num_codecs = dai_link->num_codecs;
 
 	/* Find CODEC from registered CODECs */
-	/* we can use for_each_rtd_codec_dai() after this */
 	codec_dais = rtd->codec_dais;
-	for (i = 0; i < rtd->num_codecs; i++) {
-		codec_dais[i] = snd_soc_find_dai(&codecs[i]);
+	for_each_link_codecs(dai_link, i, codecs) {
+		codec_dais[i] = snd_soc_find_dai(codecs);
 		if (!codec_dais[i]) {
 			dev_info(card->dev, "ASoC: CODEC DAI %s not registered\n",
-				 codecs[i].dai_name);
+				 codecs->dai_name);
 			goto _err_defer;
 		}
 		snd_soc_rtdcom_add(rtd, codec_dais[i]->component);

commit d0b95e6cd298a785c126e75a085af6dd7b7b1f60
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Fri Jan 25 16:04:06 2019 +0000

    ASoC: core: Allow soc_find_component lookups to match parent of_node
    
    For devices implemented as a MFD it is common to only have a single node
    in devicetree representing the whole device. As such when looking up
    components in soc_find_components we should match against both the devices
    of_node and the devices parent's of_node, as is already done in the rest
    of the ASoC core.
    
    This causes regressions for some DAI links at the moment as
    soc_find_component was recently added as a check in soc_init_dai_link.
    
    Fixes: 8780cf1142a5 ("ASoC: soc-core: defer card probe until all component is added to list")
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index aae450ba4f08..ea16c2b199ce 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -735,12 +735,17 @@ static struct snd_soc_component *soc_find_component(
 	const struct device_node *of_node, const char *name)
 {
 	struct snd_soc_component *component;
+	struct device_node *component_of_node;
 
 	lockdep_assert_held(&client_mutex);
 
 	for_each_component(component) {
 		if (of_node) {
-			if (component->dev->of_node == of_node)
+			component_of_node = component->dev->of_node;
+			if (!component_of_node && component->dev->parent)
+				component_of_node = component->dev->parent->of_node;
+
+			if (component_of_node == of_node)
 				return component;
 		} else if (name && strcmp(component->name, name) == 0) {
 			return component;

commit 3f6a125230d8bfcbfe0c06ff0b8eaccbc727acd7
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jan 22 17:36:11 2019 +0000

    ASoC: core: Fix multi-CODEC setups
    
    Revert 10dff9b0d (ASoC: soc-core: use for_each_link_codecs() for
    dai_link codecs) for now as Sylwester Nawrocki reports that it causes
    oopses on at least Odroid boards.
    
    Reported-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1c92b4aff57b..8a58fa86675a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -870,7 +870,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_dai_link_component *codecs;
+	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
 	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_component *component;
 	struct snd_soc_dai **codec_dais;
@@ -905,8 +905,9 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	rtd->num_codecs = dai_link->num_codecs;
 
 	/* Find CODEC from registered CODECs */
+	/* we can use for_each_rtd_codec_dai() after this */
 	codec_dais = rtd->codec_dais;
-	for_each_link_codecs(dai_link, i, codecs) {
+	for (i = 0; i < rtd->num_codecs; i++) {
 		codec_dais[i] = snd_soc_find_dai(&codecs[i]);
 		if (!codec_dais[i]) {
 			dev_info(card->dev, "ASoC: CODEC DAI %s not registered\n",

commit 10dff9b0ddf70bebe9523fc311ec77a872ce0a9c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 21 09:32:59 2019 +0900

    ASoC: soc-core: use for_each_link_codecs() for dai_link codecs
    
    We can use for_each_link_codecs() without waiting
    for_each_rtd_codec_dai() on soc_bind_dai_link().
    Let's use for_each macro
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8a58fa86675a..1c92b4aff57b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -870,7 +870,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
+	struct snd_soc_dai_link_component *codecs;
 	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_component *component;
 	struct snd_soc_dai **codec_dais;
@@ -905,9 +905,8 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	rtd->num_codecs = dai_link->num_codecs;
 
 	/* Find CODEC from registered CODECs */
-	/* we can use for_each_rtd_codec_dai() after this */
 	codec_dais = rtd->codec_dais;
-	for (i = 0; i < rtd->num_codecs; i++) {
+	for_each_link_codecs(dai_link, i, codecs) {
 		codec_dais[i] = snd_soc_find_dai(&codecs[i]);
 		if (!codec_dais[i]) {
 			dev_info(card->dev, "ASoC: CODEC DAI %s not registered\n",

commit 22d1423187e5b4d9d5a9851f24466fc0f585a36f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 21 09:32:55 2019 +0900

    ASoC: soc-core: add soc_cleanup_component()
    
    We need to cleanup component when soc_probe_component() was
    failed, or when soc_remove_component() was called.
    But they are cleanuping component on each way.
    (And soc_probe_component() doesn't call snd_soc_dapm_free(),
    but it should).
    Same code in many places makes code un-understandable.
    
    This patch adds new soc_cleanup_component() and call it from
    snd_probe_component() and snd_remove_component().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7fc10a41e0e9..8a58fa86675a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -937,21 +937,24 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	return -EPROBE_DEFER;
 }
 
+static void soc_cleanup_component(struct snd_soc_component *component)
+{
+	list_del(&component->card_list);
+	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
+	soc_cleanup_component_debugfs(component);
+	component->card = NULL;
+	module_put(component->dev->driver->owner);
+}
+
 static void soc_remove_component(struct snd_soc_component *component)
 {
 	if (!component->card)
 		return;
 
-	list_del(&component->card_list);
-
 	if (component->driver->remove)
 		component->driver->remove(component);
 
-	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
-
-	soc_cleanup_component_debugfs(component);
-	component->card = NULL;
-	module_put(component->dev->driver->owner);
+	soc_cleanup_component(component);
 }
 
 static void soc_remove_dai(struct snd_soc_dai *dai, int order)
@@ -1360,6 +1363,8 @@ static int soc_probe_component(struct snd_soc_card *card,
 
 	component->card = card;
 	dapm->card = card;
+	INIT_LIST_HEAD(&component->card_list);
+	INIT_LIST_HEAD(&dapm->list);
 	soc_set_name_prefix(card, component);
 
 	soc_init_component_debugfs(component);
@@ -1422,12 +1427,9 @@ static int soc_probe_component(struct snd_soc_card *card,
 	/* see for_each_card_components */
 	list_add(&component->card_list, &card->component_dev_list);
 
-	return 0;
-
 err_probe:
-	soc_cleanup_component_debugfs(component);
-	component->card = NULL;
-	module_put(component->dev->driver->owner);
+	if (ret < 0)
+		soc_cleanup_component(component);
 
 	return ret;
 }

commit 52293596f5afff10d14e033aa3edfc801a31b3a1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 21 09:32:50 2019 +0900

    ASoC: soc-core: reduce if/else nest on soc_probe_link_dais
    
    Deep nested codec is not readable.
    Let's reduce if/else nest.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d59b5ea9fa25..7fc10a41e0e9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1612,27 +1612,24 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 					 dai_link->stream_name);
 			return ret;
 		}
-	} else {
-
-		if (!dai_link->params) {
-			/* create the pcm */
-			ret = soc_new_pcm(rtd, num);
-			if (ret < 0) {
-				dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
-					dai_link->stream_name, ret);
-				return ret;
-			}
-			ret = soc_link_dai_pcm_new(&cpu_dai, 1, rtd);
-			if (ret < 0)
-				return ret;
-			ret = soc_link_dai_pcm_new(rtd->codec_dais,
-						   rtd->num_codecs, rtd);
-			if (ret < 0)
-				return ret;
-		} else {
-			INIT_DELAYED_WORK(&rtd->delayed_work,
-						codec2codec_close_delayed_work);
+	} else if (!dai_link->params) {
+		/* create the pcm */
+		ret = soc_new_pcm(rtd, num);
+		if (ret < 0) {
+			dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
+				dai_link->stream_name, ret);
+			return ret;
 		}
+		ret = soc_link_dai_pcm_new(&cpu_dai, 1, rtd);
+		if (ret < 0)
+			return ret;
+		ret = soc_link_dai_pcm_new(rtd->codec_dais,
+					   rtd->num_codecs, rtd);
+		if (ret < 0)
+			return ret;
+	} else {
+		INIT_DELAYED_WORK(&rtd->delayed_work,
+				  codec2codec_close_delayed_work);
 	}
 
 	return 0;

commit 53e947a0e1f770b9707febb7054b856878945d50
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 21 09:32:42 2019 +0900

    ASoC: soc-core: merge card resources cleanup method
    
    We need to cleanup card resources when snd_soc_instantiate_card() was
    failed, or when snd_soc_unbind_card() was called.
    But they are cleanuping card resources on each way.
    Same code in many places makes code un-understandable.
    
    This patch reuses soc_cleanup_card_resources() for cleanuping code
    resource. Then, it makes avoiding cleanup order.
    It will be called from snd_soc_instantiate_card() and
    snd_soc_unbind_card().
    
    Then, original soc_cleanup_card_resources() included
    snd_soc_flush_all_delayed_work(), but it is now separated.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index eeb794d8a262..d59b5ea9fa25 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2008,6 +2008,29 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 	}
 }
 
+static int soc_cleanup_card_resources(struct snd_soc_card *card)
+{
+	/* free the ALSA card at first; this syncs with pending operations */
+	if (card->snd_card)
+		snd_card_free(card->snd_card);
+
+	/* remove and free each DAI */
+	soc_remove_dai_links(card);
+	soc_remove_pcm_runtimes(card);
+
+	/* remove auxiliary devices */
+	soc_remove_aux_devices(card);
+
+	snd_soc_dapm_free(&card->dapm);
+	soc_cleanup_card_debugfs(card);
+
+	/* remove the card */
+	if (card->remove)
+		card->remove(card);
+
+	return 0;
+}
+
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
@@ -2017,6 +2040,11 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	mutex_lock(&client_mutex);
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
+	card->dapm.bias_level = SND_SOC_BIAS_OFF;
+	card->dapm.dev = card->dev;
+	card->dapm.card = card;
+	list_add(&card->dapm.list, &card->dapm_list);
+
 	/* check whether any platform is ignore machine FE and using topology */
 	soc_check_tplg_fes(card);
 
@@ -2024,14 +2052,14 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	for_each_card_prelinks(card, i, dai_link) {
 		ret = soc_bind_dai_link(card, dai_link);
 		if (ret != 0)
-			goto base_error;
+			goto probe_end;
 	}
 
 	/* bind aux_devs too */
 	for (i = 0; i < card->num_aux_devs; i++) {
 		ret = soc_bind_aux_dev(card, i);
 		if (ret != 0)
-			goto base_error;
+			goto probe_end;
 	}
 
 	/* add predefined DAI links to the list */
@@ -2045,16 +2073,11 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		dev_err(card->dev,
 			"ASoC: can't create sound card for card %s: %d\n",
 			card->name, ret);
-		goto base_error;
+		goto probe_end;
 	}
 
 	soc_init_card_debugfs(card);
 
-	card->dapm.bias_level = SND_SOC_BIAS_OFF;
-	card->dapm.dev = card->dev;
-	card->dapm.card = card;
-	list_add(&card->dapm.list, &card->dapm_list);
-
 #ifdef CONFIG_DEBUG_FS
 	snd_soc_dapm_debugfs_init(&card->dapm, card->debugfs_card_root);
 #endif
@@ -2076,7 +2099,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	if (card->probe) {
 		ret = card->probe(card);
 		if (ret < 0)
-			goto card_probe_error;
+			goto probe_end;
 	}
 
 	/* probe all components used by DAI links on this card */
@@ -2087,7 +2110,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 				dev_err(card->dev,
 					"ASoC: failed to instantiate card %d\n",
 					ret);
-				goto probe_dai_err;
+				goto probe_end;
 			}
 		}
 	}
@@ -2095,7 +2118,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	/* probe auxiliary components */
 	ret = soc_probe_aux_devices(card);
 	if (ret < 0)
-		goto probe_dai_err;
+		goto probe_end;
 
 	/*
 	 * Find new DAI links added during probing components and bind them.
@@ -2107,10 +2130,10 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 		ret = soc_init_dai_link(card, dai_link);
 		if (ret)
-			goto probe_dai_err;
+			goto probe_end;
 		ret = soc_bind_dai_link(card, dai_link);
 		if (ret)
-			goto probe_dai_err;
+			goto probe_end;
 	}
 
 	/* probe all DAI links on this card */
@@ -2121,7 +2144,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 				dev_err(card->dev,
 					"ASoC: failed to instantiate card %d\n",
 					ret);
-				goto probe_dai_err;
+				goto probe_end;
 			}
 		}
 	}
@@ -2168,7 +2191,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: %s late_probe() failed: %d\n",
 				card->name, ret);
-			goto probe_aux_dev_err;
+			goto probe_end;
 		}
 	}
 
@@ -2178,33 +2201,17 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	if (ret < 0) {
 		dev_err(card->dev, "ASoC: failed to register soundcard %d\n",
 				ret);
-		goto probe_aux_dev_err;
+		goto probe_end;
 	}
 
 	card->instantiated = 1;
 	dapm_mark_endpoints_dirty(card);
 	snd_soc_dapm_sync(&card->dapm);
-	mutex_unlock(&card->mutex);
-	mutex_unlock(&client_mutex);
-
-	return 0;
 
-probe_aux_dev_err:
-	soc_remove_aux_devices(card);
-
-probe_dai_err:
-	soc_remove_dai_links(card);
-
-card_probe_error:
-	if (card->remove)
-		card->remove(card);
-
-	snd_soc_dapm_free(&card->dapm);
-	soc_cleanup_card_debugfs(card);
-	snd_card_free(card->snd_card);
+probe_end:
+	if (ret < 0)
+		soc_cleanup_card_resources(card);
 
-base_error:
-	soc_remove_pcm_runtimes(card);
 	mutex_unlock(&card->mutex);
 	mutex_unlock(&client_mutex);
 
@@ -2233,31 +2240,6 @@ static int soc_probe(struct platform_device *pdev)
 	return snd_soc_register_card(card);
 }
 
-static int soc_cleanup_card_resources(struct snd_soc_card *card)
-{
-	/* make sure any delayed work runs */
-	snd_soc_flush_all_delayed_work(card);
-
-	/* free the ALSA card at first; this syncs with pending operations */
-	snd_card_free(card->snd_card);
-
-	/* remove and free each DAI */
-	soc_remove_dai_links(card);
-	soc_remove_pcm_runtimes(card);
-
-	/* remove auxiliary devices */
-	soc_remove_aux_devices(card);
-
-	snd_soc_dapm_free(&card->dapm);
-	soc_cleanup_card_debugfs(card);
-
-	/* remove the card */
-	if (card->remove)
-		card->remove(card);
-
-	return 0;
-}
-
 /* removes a socdev */
 static int soc_remove(struct platform_device *pdev)
 {
@@ -2823,6 +2805,7 @@ static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
 	if (card->instantiated) {
 		card->instantiated = false;
 		snd_soc_dapm_shutdown(card);
+		snd_soc_flush_all_delayed_work(card);
 		soc_cleanup_card_resources(card);
 		if (!unregister)
 			list_add(&card->list, &unbind_card_list);

commit 65462e445f78cb2f9378443be7ba8b7e07300694
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 21 09:32:37 2019 +0900

    ASoC: soc-core: add new snd_soc_flush_all_delayed_work()
    
    soc-core is calling flush_delayed_work() many times for same purpose.
    Same code in many places makes code un-understandable.
    This patch adds new snd_soc_flush_all_delayed_work() for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2c63921675d5..eeb794d8a262 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -425,6 +425,14 @@ struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
 
+static void snd_soc_flush_all_delayed_work(struct snd_soc_card *card)
+{
+	struct snd_soc_pcm_runtime *rtd;
+
+	for_each_card_rtds(card, rtd)
+		flush_delayed_work(&rtd->delayed_work);
+}
+
 static void codec2codec_close_delayed_work(struct work_struct *work)
 {
 	/*
@@ -494,8 +502,7 @@ int snd_soc_suspend(struct device *dev)
 	}
 
 	/* close any waiting streams */
-	for_each_card_rtds(card, rtd)
-		flush_delayed_work(&rtd->delayed_work);
+	snd_soc_flush_all_delayed_work(card);
 
 	for_each_card_rtds(card, rtd) {
 
@@ -2228,11 +2235,8 @@ static int soc_probe(struct platform_device *pdev)
 
 static int soc_cleanup_card_resources(struct snd_soc_card *card)
 {
-	struct snd_soc_pcm_runtime *rtd;
-
 	/* make sure any delayed work runs */
-	for_each_card_rtds(card, rtd)
-		flush_delayed_work(&rtd->delayed_work);
+	snd_soc_flush_all_delayed_work(card);
 
 	/* free the ALSA card at first; this syncs with pending operations */
 	snd_card_free(card->snd_card);
@@ -2275,8 +2279,7 @@ int snd_soc_poweroff(struct device *dev)
 	 * Flush out pmdown_time work - we actually do want to run it
 	 * now, we're shutting down so no imminent restart.
 	 */
-	for_each_card_rtds(card, rtd)
-		flush_delayed_work(&rtd->delayed_work);
+	snd_soc_flush_all_delayed_work(card);
 
 	snd_soc_dapm_shutdown(card);
 

commit 910fdcabedd2354d161b1beab6ad7dc7e859651d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 21 09:32:32 2019 +0900

    ASoC: soc-core: add .num_platform for dai_link
    
    Current snd_soc_dai_link is starting to use snd_soc_dai_link_component
    (= modern) style for Platform, but it is still assuming single Platform
    so far. We will need to have multi Platform support in the not far
    future.
    
    Currently only simple card is using it as sound card driver,
    and other drivers are converted to it from legacy style by
    snd_soc_init_platform().
    To avoid future problem of multi Platform support, let's add
    num_platforms before it is too late.
    
    In the same time, to make it same naming mothed, "platform" should
    be "platforms". This patch fixup it too.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index de2851f1b3df..2c63921675d5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -915,7 +915,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 	/* find one from the set of registered platforms */
 	for_each_component(component) {
-		if (!snd_soc_is_matching_component(dai_link->platform,
+		if (!snd_soc_is_matching_component(dai_link->platforms,
 						   component))
 			continue;
 
@@ -1026,7 +1026,7 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 static int snd_soc_init_platform(struct snd_soc_card *card,
 				 struct snd_soc_dai_link *dai_link)
 {
-	struct snd_soc_dai_link_component *platform = dai_link->platform;
+	struct snd_soc_dai_link_component *platform = dai_link->platforms;
 
 	/*
 	 * REMOVE ME
@@ -1046,7 +1046,8 @@ static int snd_soc_init_platform(struct snd_soc_card *card,
 		if (!platform)
 			return -ENOMEM;
 
-		dai_link->platform	  = platform;
+		dai_link->platforms	  = platform;
+		dai_link->num_platforms	  = 1;
 		dai_link->legacy_platform = 1;
 		platform->name		  = dai_link->platform_name;
 		platform->of_node	  = dai_link->platform_of_node;
@@ -1136,11 +1137,19 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 		}
 	}
 
+	/* FIXME */
+	if (link->num_platforms > 1) {
+		dev_err(card->dev,
+			"ASoC: multi platform is not yet supported %s\n",
+			link->name);
+		return -EINVAL;
+	}
+
 	/*
 	 * Platform may be specified by either name or OF node, but
 	 * can be left unspecified, and a dummy platform will be used.
 	 */
-	if (link->platform->name && link->platform->of_node) {
+	if (link->platforms->name && link->platforms->of_node) {
 		dev_err(card->dev,
 			"ASoC: Both platform name/of_node are set for %s\n",
 			link->name);
@@ -1151,8 +1160,8 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	 * Defer card registartion if platform dai component is not added to
 	 * component list.
 	 */
-	if ((link->platform->of_node || link->platform->name) &&
-	    !soc_find_component(link->platform->of_node, link->platform->name))
+	if ((link->platforms->of_node || link->platforms->name) &&
+	    !soc_find_component(link->platforms->of_node, link->platforms->name))
 		return -EPROBE_DEFER;
 
 	/*
@@ -1956,7 +1965,7 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 				dev_err(card->dev, "init platform error");
 				continue;
 			}
-			dai_link->platform->name = component->name;
+			dai_link->platforms->name = component->name;
 
 			/* convert non BE into BE */
 			dai_link->no_pcm = 1;

commit 62bc79d35ebb55451112979babea864975cfd16d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 18 11:20:41 2019 +0900

    ASoC: soc.h: add explanation of legacy/modern style of dai_link
    
    Current ALSA SoC is assuming 1 CPU 1 Platform (= DMA) style system.
    Because of this background, it is directly using
    xxx_name / xxx_of_node / xxx_dai_name on dai_link.
    Let's call it as legacy style here.
    
    More complex style system like multi CPU multi Platform (= DMA) will
    coming. To supporting it, we can use snd_soc_dai_link_component on
    dai_link. Let's call it as modern style here.
    But current ALSA SoC can't support it so far. Thus, we need to have
    multi CPU / multi Codec / multi Platform style in the future on ALSA SoC.
    
    Currently we already have multi Codec support. Platform is starting to
    use modern style on dai_link, but still style only. Multi Platform is
    not yet implemented. And we still don't have multi CPU support on ALSA
    SoC, and not have modern style either.
    
    Currently, if driver is using legacy style Codec/Platform, it will be
    converted to modern style on soc-core. This means, we are using glue code
    for legacy vs modern style so far on ALSA SoC.
    We can fully switch to modern style on all drivers if ALSA SoC supported
    modern style for CPU, and then, legacy style code will be removed from
    ALSA SoC.
    Untile then, we need to keep both legacy/modern style and its glue code.
    This patch adds such future plan and background on soc.h
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 890d6c9c2752..de2851f1b3df 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1029,9 +1029,14 @@ static int snd_soc_init_platform(struct snd_soc_card *card,
 	struct snd_soc_dai_link_component *platform = dai_link->platform;
 
 	/*
-	 * FIXME
+	 * REMOVE ME
 	 *
-	 * this function should be removed in the future
+	 * This is glue code for Legacy vs Modern dai_link.
+	 * This function will be removed if all derivers are switched to
+	 * modern style dai_link.
+	 * Driver shouldn't use both legacy and modern style in the same time.
+	 * see
+	 *	soc.h :: struct snd_soc_dai_link
 	 */
 	/* convert Legacy platform link */
 	if (!platform || dai_link->legacy_platform) {
@@ -1059,6 +1064,17 @@ static int snd_soc_init_platform(struct snd_soc_card *card,
 static int snd_soc_init_multicodec(struct snd_soc_card *card,
 				   struct snd_soc_dai_link *dai_link)
 {
+	/*
+	 * REMOVE ME
+	 *
+	 * This is glue code for Legacy vs Modern dai_link.
+	 * This function will be removed if all derivers are switched to
+	 * modern style dai_link.
+	 * Driver shouldn't use both legacy and modern style in the same time.
+	 * see
+	 *	soc.h :: struct snd_soc_dai_link
+	 */
+
 	/* Legacy codec/codec_dai link is a single entry in multicodec */
 	if (dai_link->codec_name || dai_link->codec_of_node ||
 	    dai_link->codec_dai_name) {

commit f557d39a3cb8ea892dada232c51479ae3628cdee
Merge: e412fcb0db5c 4cb79ef9c6c4
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 18 19:14:36 2019 +0000

    Merge tag 'asoc-fix-v5.0-rc2' into asoc-5.1
    
    ASoC: Fixes for v5.0
    
    Quite a big batch of fixes here.  There's a couple of things going on,
    the main one is that we found some issues with not deferring probe when
    we should, causing us to skip some driver initialization.  The fixes for
    this then in turn exposed some issues with how we were searching for
    components which had previously gone unnoticed due to the original
    issue.
    
    There's also been the normal driver specific stuff and there's been what
    looks like several batches of automated scanning for issues which have
    generated quite a large set of smaller fixes for potential crashes and
    missed error handling.

commit 7c7e2d6a9ca3c74ba7ed4da2a75916b2f9ae38f0
Author: Stefan Agner <stefan@agner.ch>
Date:   Fri Jan 18 10:55:04 2019 +0100

    ASoC: soc-core: remove error due to probe deferral
    
    Deferred probes shouldn't cause error messages in the boot log, so
    change the dev_err() to the more harmless dev_info().
    
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0462b3ec977a..98bb05f6ed56 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -903,8 +903,8 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	for (i = 0; i < rtd->num_codecs; i++) {
 		codec_dais[i] = snd_soc_find_dai(&codecs[i]);
 		if (!codec_dais[i]) {
-			dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
-				codecs[i].dai_name);
+			dev_info(card->dev, "ASoC: CODEC DAI %s not registered\n",
+				 codecs[i].dai_name);
 			goto _err_defer;
 		}
 		snd_soc_rtdcom_add(rtd, codec_dais[i]->component);

commit 2833548ecbb385a289124077ab4d812258a867d5
Author: Matthias Reichl <hias@horus.com>
Date:   Tue Jan 15 17:51:07 2019 +0100

    ASoC: core: Don't defer probe on optional, NULL components
    
    cpu and platform are optional components in DAI links. For example
    codec-codec links usually have no platform set.
    
    Call snd_soc_find_component only if the name or of_node of
    a cpu or platform is set. Otherwise it will return NULL and
    soc_init_dai_link bails out immediately with -EPROBE_DEFER,
    meaning registering a card with NULL cpu or platform in DAI links
    can never succeed.
    
    Fixes: 8780cf1142a5 ("ASoC: soc-core: defer card probe until all component is added to list")
    
    Signed-off-by: Matthias Reichl <hias@horus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b680c673c553..aae450ba4f08 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1135,7 +1135,8 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	 * Defer card registartion if platform dai component is not added to
 	 * component list.
 	 */
-	if (!soc_find_component(link->platform->of_node, link->platform->name))
+	if ((link->platform->of_node || link->platform->name) &&
+	    !soc_find_component(link->platform->of_node, link->platform->name))
 		return -EPROBE_DEFER;
 
 	/*
@@ -1154,7 +1155,8 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	 * Defer card registartion if cpu dai component is not added to
 	 * component list.
 	 */
-	if (!soc_find_component(link->cpu_of_node, link->cpu_name))
+	if ((link->cpu_of_node || link->cpu_name) &&
+	    !soc_find_component(link->cpu_of_node, link->cpu_name))
 		return -EPROBE_DEFER;
 
 	/*

commit 5a7b2aabc1aa0393f067d9325ada96fdf67f8cb7
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jan 14 23:29:36 2019 +0000

    ASoC: core: Make snd_soc_find_component() more robust
    
    There are some use cases where you're checking for a lot of things on a
    card and it makes sense that you might end up trying to call
    snd_soc_find_component() without either a name or an of_node.  Currently
    in that case we try to dereference the name and crash but it's more
    useful to allow the caller to just treat that as a case where we don't
    find anything, that error handling will already exist.
    
    Inspired by a patch from Ajit Pandey fixing some callers.
    
    Fixes: 8780cf1142a5 ("ASoC: soc-core: defer card probe until all component is added to list")
    Reported-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cdcc417c94ca..b680c673c553 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -742,7 +742,7 @@ static struct snd_soc_component *soc_find_component(
 		if (of_node) {
 			if (component->dev->of_node == of_node)
 				return component;
-		} else if (strcmp(component->name, name) == 0) {
+		} else if (name && strcmp(component->name, name) == 0) {
 			return component;
 		}
 	}

commit 09ac6a817bd687e7f5dac00470262efdd72f9319
Author: Curtis Malainey <cujomalainey@chromium.org>
Date:   Thu Jan 10 16:21:04 2019 -0800

    ASoC: soc-core: fix init platform memory handling
    
    snd_soc_init_platform initializes pointers to snd_soc_dai_link which is
    statically allocated and it does this by devm_kzalloc. In the event of
    an EPROBE_DEFER the memory will be freed and the pointers are left
    dangling. snd_soc_init_platform sees the dangling pointers and assumes
    they are pointing to initialized memory and does not reallocate them on
    the second probe attempt which results in a use after free bug since
    devm has freed the memory from the first probe attempt.
    
    Since the intention for snd_soc_dai_link->platform is that it can be set
    statically by the machine driver we need to respect the pointer in the
    event we did not set it but still catch dangling pointers. The solution
    is to add a flag to track whether the pointer was dynamically allocated
    or not.
    
    Signed-off-by: Curtis Malainey <cujomalainey@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0934b36645b3..cdcc417c94ca 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1034,17 +1034,18 @@ static int snd_soc_init_platform(struct snd_soc_card *card,
 	 * this function should be removed in the future
 	 */
 	/* convert Legacy platform link */
-	if (!platform) {
+	if (!platform || dai_link->legacy_platform) {
 		platform = devm_kzalloc(card->dev,
 				sizeof(struct snd_soc_dai_link_component),
 				GFP_KERNEL);
 		if (!platform)
 			return -ENOMEM;
 
-		dai_link->platform	= platform;
-		platform->name		= dai_link->platform_name;
-		platform->of_node	= dai_link->platform_of_node;
-		platform->dai_name	= NULL;
+		dai_link->platform	  = platform;
+		dai_link->legacy_platform = 1;
+		platform->name		  = dai_link->platform_name;
+		platform->of_node	  = dai_link->platform_of_node;
+		platform->dai_name	  = NULL;
 	}
 
 	/* if there's no platform we match on the empty platform */

commit 04eb1efcd614d6f067b76a355b3a3599667959dc
Author: Rohit kumar <rohitkr@codeaurora.org>
Date:   Thu Jan 10 14:32:41 2019 +0530

    ASoC: soc-core: Hold client_mutex around soc_init_dai_link()
    
    soc_init_dai_link() calls soc_find_component() which needs
    to be within client_mutex lock. Add client_mutex lock around
    soc_init_dai_link() in snd_soc_register_card() to avoid
    lockdep warning.
    
    Fixes: 8780cf1142a5 ("ASoC: soc-core: defer card probe until all component is added to list")
    Reported-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Rohit kumar <rohitkr@codeaurora.org>
    Signed-off-by: Ajit Pandey <ajitp@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index eec92f17dd15..0934b36645b3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1027,6 +1027,7 @@ static int snd_soc_init_platform(struct snd_soc_card *card,
 				 struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_dai_link_component *platform = dai_link->platform;
+
 	/*
 	 * FIXME
 	 *
@@ -2754,15 +2755,18 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	if (!card->name || !card->dev)
 		return -EINVAL;
 
+	mutex_lock(&client_mutex);
 	for_each_card_prelinks(card, i, link) {
 
 		ret = soc_init_dai_link(card, link);
 		if (ret) {
 			dev_err(card->dev, "ASoC: failed to init link %s\n",
 				link->name);
+			mutex_unlock(&client_mutex);
 			return ret;
 		}
 	}
+	mutex_unlock(&client_mutex);
 
 	dev_set_drvdata(card->dev, card);
 

commit 8780cf1142a59568a3aa77959cbd76b2edb6fd81
Author: Ajit Pandey <ajitp@codeaurora.org>
Date:   Wed Jan 9 14:17:07 2019 +0530

    ASoC: soc-core: defer card probe until all component is added to list
    
    DAI component probe is not called if it is not present
    in component list during sound card registration.
    Check if component is available in component list for
    platform and cpu dai before soundcard registration.
    
    Signed-off-by: Ajit Pandey <ajitp@codeaurora.org>
    Signed-off-by: Rohit kumar <rohitkr@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0462b3ec977a..eec92f17dd15 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1027,7 +1027,6 @@ static int snd_soc_init_platform(struct snd_soc_card *card,
 				 struct snd_soc_dai_link *dai_link)
 {
 	struct snd_soc_dai_link_component *platform = dai_link->platform;
-
 	/*
 	 * FIXME
 	 *
@@ -1129,6 +1128,14 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 			link->name);
 		return -EINVAL;
 	}
+
+	/*
+	 * Defer card registartion if platform dai component is not added to
+	 * component list.
+	 */
+	if (!soc_find_component(link->platform->of_node, link->platform->name))
+		return -EPROBE_DEFER;
+
 	/*
 	 * CPU device may be specified by either name or OF node, but
 	 * can be left unspecified, and will be matched based on DAI
@@ -1140,6 +1147,14 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 			link->name);
 		return -EINVAL;
 	}
+
+	/*
+	 * Defer card registartion if cpu dai component is not added to
+	 * component list.
+	 */
+	if (!soc_find_component(link->cpu_of_node, link->cpu_name))
+		return -EPROBE_DEFER;
+
 	/*
 	 * At least one of CPU DAI name or CPU device name/node must be
 	 * specified

commit de17f14ea576d8a0f2932404467fa916542da94d
Author: Rohit kumar <rohitkr@codeaurora.org>
Date:   Thu Nov 1 18:08:49 2018 +0530

    ASoC: core: Invoke pcm_new() for all DAI-link
    
    Remove no_pcm check to invoke pcm_new() for backend dai-links
    too. This fixes crash in hdmi codec driver during hdmi_codec_startup()
    while accessing chmap_info struct. chmap_info struct memory is
    allocated in pcm_new() of hdmi codec driver which is not invoked
    in case of DPCM when hdmi codec driver is part of backend dai-link.
    
    Below is the crash stack:
    
    [   61.635493] Unable to handle kernel NULL pointer dereference at virtual address 00000018
    ..
    [   61.666696]   CM = 0, WnR = 1
    [   61.669778] user pgtable: 4k pages, 39-bit VAs, pgd = ffffffc0d6633000
    [   61.676526] [0000000000000018] *pgd=0000000153fc8003, *pud=0000000153fc8003, *pmd=0000000000000000
    [   61.685793] Internal error: Oops: 96000046 [#1] PREEMPT SMP
    [   61.722955] CPU: 7 PID: 2238 Comm: aplay Not tainted 4.14.72 #21
    ..
    [   61.740269] PC is at hdmi_codec_startup+0x124/0x164
    [   61.745308] LR is at hdmi_codec_startup+0xe4/0x164
    
    Signed-off-by: Rohit kumar <rohitkr@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b0db59e6339d..0462b3ec977a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1467,7 +1467,7 @@ static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 	for (i = 0; i < num_dais; ++i) {
 		struct snd_soc_dai_driver *drv = dais[i]->driver;
 
-		if (!rtd->dai_link->no_pcm && drv->pcm_new)
+		if (drv->pcm_new)
 			ret = drv->pcm_new(rtd, dais[i]);
 		if (ret < 0) {
 			dev_err(dais[i]->dev,

commit 8fe8915b6c0b5298fa547be21957b3860c39c46e
Merge: 1b46ed96961d a01b8d1d2445
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Dec 13 14:36:46 2018 +0000

    Merge branch 'for-4.20' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-4.21 intel dep

commit 3b7103562c03cffb1a351f8c235b3bba2acd9e9b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 22 00:55:09 2018 +0000

    ASoC: soc-core: add snd_soc_of_parse_node_prefix()
    
    Current ASoC has snd_soc_of_parse_audio_prefix() to get codec_conf
    settings from DT which is used to avoid DAI naming conflict when
    CPU/Codec matching.
    
    Currently, it is parsing from "top node",
    but, we want to parse from "each sub node" if sound card had multi
    cpus/codecs.
    
    This patch adds new snd_soc_of_parse_node_prefix() to allow parsing
    settings from selected node.
    It is keeping existing snd_soc_of_parse_audio_prefix() by using macro.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6ddcf12bc030..012000de4bf0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3484,12 +3484,11 @@ int snd_soc_of_parse_tdm_slot(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_tdm_slot);
 
-void snd_soc_of_parse_audio_prefix(struct snd_soc_card *card,
-				   struct snd_soc_codec_conf *codec_conf,
-				   struct device_node *of_node,
-				   const char *propname)
+void snd_soc_of_parse_node_prefix(struct device_node *np,
+				  struct snd_soc_codec_conf *codec_conf,
+				  struct device_node *of_node,
+				  const char *propname)
 {
-	struct device_node *np = card->dev->of_node;
 	const char *str;
 	int ret;
 
@@ -3502,7 +3501,7 @@ void snd_soc_of_parse_audio_prefix(struct snd_soc_card *card,
 	codec_conf->of_node	= of_node;
 	codec_conf->name_prefix	= str;
 }
-EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_prefix);
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_node_prefix);
 
 int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname)

commit 882eab6c28d23a970ae73b7eb831b169a672d456
Author: Tzung-Bi Shih <tzungbi@google.com>
Date:   Wed Nov 14 17:06:13 2018 +0800

    ASoC: dapm: Recalculate audio map forcely when card instantiated
    
    Audio map are possible in wrong state before card->instantiated has
    been set to true.  Imaging the following examples:
    
    time 1: at the beginning
    
      in:-1    in:-1    in:-1    in:-1
     out:-1   out:-1   out:-1   out:-1
     SIGGEN        A        B      Spk
    
    time 2: after someone called snd_soc_dapm_new_widgets()
    (e.g. create_fill_widget_route_map() in sound/soc/codecs/hdac_hdmi.c)
    
       in:1     in:0     in:0     in:0
      out:0    out:0    out:0    out:1
     SIGGEN        A        B      Spk
    
    time 3: routes added
    
       in:1     in:0     in:0     in:0
      out:0    out:0    out:0    out:1
     SIGGEN -----> A -----> B ---> Spk
    
    In the end, the path should be powered on but it did not.  At time 3,
    "in" of SIGGEN and "out" of Spk did not propagate to their neighbors
    because snd_soc_dapm_add_path() will not invalidate the paths if
    the card has not instantiated (i.e. card->instantiated is false).
    To correct the state of audio map, recalculate the whole map forcely.
    
    Signed-off-by: Tzung-Bi Shih <tzungbi@google.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6ddcf12bc030..b29d0f65611e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2131,6 +2131,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	card->instantiated = 1;
+	dapm_mark_endpoints_dirty(card);
 	snd_soc_dapm_sync(&card->dapm);
 	mutex_unlock(&card->mutex);
 	mutex_unlock(&client_mutex);

commit 2c7b696a7589ab14854c132dc732973fbd498d5a
Author: Marcel Ziswiler <marcel.ziswiler@toradex.com>
Date:   Thu Oct 18 13:18:28 2018 +0200

    ASoC: soc-core: fix trivial checkpatch issues
    
    Fix a few trivial aka cosmetic only checkpatch issues like long lines,
    wrong indentations, spurious blanks and newlines, missing newlines,
    multi-line comments etc.
    
    Signed-off-by: Marcel Ziswiler <marcel.ziswiler@toradex.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 62e8e36062df..6ddcf12bc030 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -66,8 +66,9 @@ static int pmdown_time = 5000;
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
-/* If a DMI filed contain strings in this blacklist (e.g.
- * "Type2 - Board Manufacturer" or  "Type1 - TBD by OEM"), it will be taken
+/*
+ * If a DMI filed contain strings in this blacklist (e.g.
+ * "Type2 - Board Manufacturer" or "Type1 - TBD by OEM"), it will be taken
  * as invalid and dropped when setting the card long name from DMI info.
  */
 static const char * const dmi_blacklist[] = {
@@ -222,7 +223,7 @@ static void soc_init_card_debugfs(struct snd_soc_card *card)
 						    &card->pop_time);
 	if (!card->debugfs_pop_time)
 		dev_warn(card->dev,
-		       "ASoC: Failed to create pop time debugfs file\n");
+			 "ASoC: Failed to create pop time debugfs file\n");
 }
 
 static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
@@ -426,7 +427,8 @@ EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
 
 static void codec2codec_close_delayed_work(struct work_struct *work)
 {
-	/* Currently nothing to do for c2c links
+	/*
+	 * Currently nothing to do for c2c links
 	 * Since c2c links are internal nodes in the DAPM graph and
 	 * don't interface with the outside world or application layer
 	 * we don't have to do any special handling on close.
@@ -446,8 +448,9 @@ int snd_soc_suspend(struct device *dev)
 	if (!card->instantiated)
 		return 0;
 
-	/* Due to the resume being scheduled into a workqueue we could
-	* suspend before that's finished - wait for it to complete.
+	/*
+	 * Due to the resume being scheduled into a workqueue we could
+	 * suspend before that's finished - wait for it to complete.
 	 */
 	snd_power_wait(card->snd_card, SNDRV_CTL_POWER_D0);
 
@@ -514,10 +517,13 @@ int snd_soc_suspend(struct device *dev)
 
 	/* suspend all COMPONENTs */
 	for_each_card_components(card, component) {
-		struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+		struct snd_soc_dapm_context *dapm =
+				snd_soc_component_get_dapm(component);
 
-		/* If there are paths active then the COMPONENT will be held with
-		 * bias _ON and should not be suspended. */
+		/*
+		 * If there are paths active then the COMPONENT will be held
+		 * with bias _ON and should not be suspended.
+		 */
 		if (!component->suspended) {
 			switch (snd_soc_dapm_get_bias_level(dapm)) {
 			case SND_SOC_BIAS_STANDBY:
@@ -571,18 +577,21 @@ int snd_soc_suspend(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_suspend);
 
-/* deferred resume work, so resume can complete before we finished
+/*
+ * deferred resume work, so resume can complete before we finished
  * setting our codec back up, which can be very slow on I2C
  */
 static void soc_resume_deferred(struct work_struct *work)
 {
 	struct snd_soc_card *card =
-			container_of(work, struct snd_soc_card, deferred_resume_work);
+			container_of(work, struct snd_soc_card,
+				     deferred_resume_work);
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_component *component;
 	int i;
 
-	/* our power state is still SNDRV_CTL_POWER_D3hot from suspend time,
+	/*
+	 * our power state is still SNDRV_CTL_POWER_D3hot from suspend time,
 	 * so userspace apps are blocked from touching us
 	 */
 
@@ -699,6 +708,7 @@ int snd_soc_resume(struct device *dev)
 	 */
 	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
 		bus_control |= cpu_dai->driver->bus_control;
 	}
 	if (bus_control) {
@@ -777,7 +787,7 @@ struct snd_soc_dai *snd_soc_find_dai(
 
 	lockdep_assert_held(&client_mutex);
 
-	/* Find CPU DAI from registered DAIs*/
+	/* Find CPU DAI from registered DAIs */
 	for_each_component(component) {
 		if (!snd_soc_is_matching_component(dlc, component))
 			continue;
@@ -795,7 +805,6 @@ struct snd_soc_dai *snd_soc_find_dai(
 }
 EXPORT_SYMBOL_GPL(snd_soc_find_dai);
 
-
 /**
  * snd_soc_find_dai_link - Find a DAI link
  *
@@ -918,7 +927,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 _err_defer:
 	soc_free_pcm_runtime(rtd);
-	return  -EPROBE_DEFER;
+	return -EPROBE_DEFER;
 }
 
 static void soc_remove_component(struct snd_soc_component *component)
@@ -1074,7 +1083,7 @@ static int snd_soc_init_multicodec(struct snd_soc_card *card,
 }
 
 static int soc_init_dai_link(struct snd_soc_card *card,
-				   struct snd_soc_dai_link *link)
+			     struct snd_soc_dai_link *link)
 {
 	int i, ret;
 	struct snd_soc_dai_link_component *codec;
@@ -1148,7 +1157,8 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 
 void snd_soc_disconnect_sync(struct device *dev)
 {
-	struct snd_soc_component *component = snd_soc_lookup_component(dev, NULL);
+	struct snd_soc_component *component =
+			snd_soc_lookup_component(dev, NULL);
 
 	if (!component || !component->card)
 		return;
@@ -1179,7 +1189,8 @@ int snd_soc_add_dai_link(struct snd_soc_card *card,
 	}
 
 	lockdep_assert_held(&client_mutex);
-	/* Notify the machine driver for extra initialization
+	/*
+	 * Notify the machine driver for extra initialization
 	 * on the link created by topology.
 	 */
 	if (dai_link->dobj.type && card->add_dai_link)
@@ -1214,7 +1225,8 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 	}
 
 	lockdep_assert_held(&client_mutex);
-	/* Notify the machine driver for extra destruction
+	/*
+	 * Notify the machine driver for extra destruction
 	 * on the link created by topology.
 	 */
 	if (dai_link->dobj.type && card->remove_dai_link)
@@ -1274,7 +1286,8 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 static int soc_probe_component(struct snd_soc_card *card,
 	struct snd_soc_component *component)
 {
-	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct snd_soc_dapm_context *dapm =
+			snd_soc_component_get_dapm(component);
 	struct snd_soc_dai *dai;
 	int ret;
 
@@ -1406,8 +1419,7 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 }
 
 static int soc_probe_link_components(struct snd_soc_card *card,
-			struct snd_soc_pcm_runtime *rtd,
-				     int order)
+				     struct snd_soc_pcm_runtime *rtd, int order)
 {
 	struct snd_soc_component *component;
 	struct snd_soc_rtdcom_list *rtdcom;
@@ -1434,6 +1446,7 @@ static int soc_probe_dai(struct snd_soc_dai *dai, int order)
 
 	if (dai->driver->probe) {
 		int ret = dai->driver->probe(dai);
+
 		if (ret < 0) {
 			dev_err(dai->dev, "ASoC: failed to probe DAI %s: %d\n",
 				dai->name, ret);
@@ -1541,7 +1554,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 	}
 
 	if (cpu_dai->driver->compress_new) {
-		/*create compress_device"*/
+		/* create compress_device" */
 		ret = cpu_dai->driver->compress_new(rtd, num);
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: can't create compress %s\n",
@@ -1555,7 +1568,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 			ret = soc_new_pcm(rtd, num);
 			if (ret < 0) {
 				dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
-				       dai_link->stream_name, ret);
+					dai_link->stream_name, ret);
 				return ret;
 			}
 			ret = soc_link_dai_pcm_new(&cpu_dai, 1, rtd);
@@ -1683,8 +1696,10 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 		}
 	}
 
-	/* Flip the polarity for the "CPU" end of a CODEC<->CODEC link */
-	/* the component which has non_legacy_dai_naming is Codec */
+	/*
+	 * Flip the polarity for the "CPU" end of a CODEC<->CODEC link
+	 * the component which has non_legacy_dai_naming is Codec
+	 */
 	if (cpu_dai->component->driver->non_legacy_dai_naming) {
 		unsigned int inv_dai_fmt;
 
@@ -1718,9 +1733,9 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 }
 EXPORT_SYMBOL_GPL(snd_soc_runtime_set_dai_fmt);
 
-
 #ifdef CONFIG_DMI
-/* Trim special characters, and replace '-' with '_' since '-' is used to
+/*
+ * Trim special characters, and replace '-' with '_' since '-' is used to
  * separate different DMI fields in the card long name. Only number and
  * alphabet characters and a few separator characters are kept.
  */
@@ -1739,7 +1754,8 @@ static void cleanup_dmi_name(char *name)
 	name[j] = '\0';
 }
 
-/* Check if a DMI field is valid, i.e. not containing any string
+/*
+ * Check if a DMI field is valid, i.e. not containing any string
  * in the black list.
  */
 static int is_dmi_valid(const char *field)
@@ -1802,7 +1818,6 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 		return 0;
 	}
 
-
 	snprintf(card->dmi_longname, sizeof(card->snd_card->longname),
 			 "%s", vendor);
 	cleanup_dmi_name(card->dmi_longname);
@@ -1818,7 +1833,8 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 		if (len < longname_buf_size)
 			cleanup_dmi_name(card->dmi_longname + len);
 
-		/* some vendors like Lenovo may only put a self-explanatory
+		/*
+		 * some vendors like Lenovo may only put a self-explanatory
 		 * name in the product version field
 		 */
 		product_version = dmi_get_system_info(DMI_PRODUCT_VERSION);
@@ -1914,7 +1930,8 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 			dai_link->be_hw_params_fixup =
 				component->driver->be_hw_params_fixup;
 
-			/* most BE links don't set stream name, so set it to
+			/*
+			 * most BE links don't set stream name, so set it to
 			 * dai link name if it's NULL to help bind widgets.
 			 */
 			if (!dai_link->stream_name)
@@ -1924,7 +1941,7 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 		/* Inform userspace we are using alternate topology */
 		if (component->driver->topology_name_prefix) {
 
-			/* topology shortname created ? */
+			/* topology shortname created? */
 			if (!card->topology_shortname_created) {
 				comp_drv = component->driver;
 
@@ -2029,7 +2046,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	if (ret < 0)
 		goto probe_dai_err;
 
-	/* Find new DAI links added during probing components and bind them.
+	/*
+	 * Find new DAI links added during probing components and bind them.
 	 * Components with topology may bring new DAIs and DAI links.
 	 */
 	for_each_card_links(card, dai_link) {
@@ -2061,7 +2079,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	snd_soc_dapm_connect_dai_link_widgets(card);
 
 	if (card->controls)
-		snd_soc_add_card_controls(card, card->controls, card->num_controls);
+		snd_soc_add_card_controls(card, card->controls,
+					  card->num_controls);
 
 	if (card->dapm_routes)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
@@ -2207,8 +2226,10 @@ int snd_soc_poweroff(struct device *dev)
 	if (!card->instantiated)
 		return 0;
 
-	/* Flush out pmdown_time work - we actually do want to run it
-	 * now, we're shutting down so no imminent restart. */
+	/*
+	 * Flush out pmdown_time work - we actually do want to run it
+	 * now, we're shutting down so no imminent restart.
+	 */
 	for_each_card_rtds(card, rtd)
 		flush_delayed_work(&rtd->delayed_work);
 
@@ -2301,6 +2322,7 @@ static int snd_soc_add_controls(struct snd_card *card, struct device *dev,
 
 	for (i = 0; i < num_controls; i++) {
 		const struct snd_kcontrol_new *control = &controls[i];
+
 		err = snd_ctl_add(card, snd_soc_cnew(control, data,
 						     control->name, prefix));
 		if (err < 0) {
@@ -2418,8 +2440,9 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
  *
  * Configures the CODEC master (MCLK) or system (SYSCLK) clocking.
  */
-int snd_soc_component_set_sysclk(struct snd_soc_component *component, int clk_id,
-			     int source, unsigned int freq, int dir)
+int snd_soc_component_set_sysclk(struct snd_soc_component *component,
+				 int clk_id, int source, unsigned int freq,
+				 int dir)
 {
 	if (component->driver->set_sysclk)
 		return component->driver->set_sysclk(component, clk_id, source,
@@ -2487,7 +2510,7 @@ int snd_soc_component_set_pll(struct snd_soc_component *component, int pll_id,
 {
 	if (component->driver->set_pll)
 		return component->driver->set_pll(component, pll_id, source,
-					      freq_in, freq_out);
+						  freq_in, freq_out);
 
 	return -EINVAL;
 }
@@ -2533,8 +2556,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
  * Generates the TDM tx and rx slot default masks for DAI.
  */
 static int snd_soc_xlate_tdm_slot_mask(unsigned int slots,
-					  unsigned int *tx_mask,
-					  unsigned int *rx_mask)
+				       unsigned int *tx_mask,
+				       unsigned int *rx_mask)
 {
 	if (*tx_mask || *rx_mask)
 		return 0;
@@ -2684,7 +2707,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 		return ret;
 
 	/* deactivate pins to sleep state */
-	for_each_card_rtds(card, rtd)  {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 		struct snd_soc_dai *codec_dai;
 		int j;
@@ -2799,7 +2822,7 @@ static char *fmt_single_name(struct device *dev, int *id)
 		}
 
 	} else {
-		/* I2C component devices are named "bus-addr"  */
+		/* I2C component devices are named "bus-addr" */
 		if (sscanf(name, "%x-%x", &id1, &id2) == 2) {
 			char tmp[NAME_SIZE];
 
@@ -2807,7 +2830,8 @@ static char *fmt_single_name(struct device *dev, int *id)
 			*id = ((id1 & 0xffff) << 16) + id2;
 
 			/* sanitize component name for DAI link creation */
-			snprintf(tmp, NAME_SIZE, "%s.%s", dev->driver->name, name);
+			snprintf(tmp, NAME_SIZE, "%s.%s", dev->driver->name,
+				 name);
 			strlcpy(name, tmp, NAME_SIZE);
 		} else
 			*id = 0;
@@ -2874,7 +2898,7 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 	 * component-less anymore.
 	 */
 	if (legacy_dai_naming &&
-	   (dai_drv->id == 0 || dai_drv->name == NULL)) {
+	    (dai_drv->id == 0 || dai_drv->name == NULL)) {
 		dai->name = fmt_single_name(dev, &dai->id);
 	} else {
 		dai->name = fmt_multiple_name(dev, dai_drv);
@@ -2910,7 +2934,8 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
  * @count: Number of DAIs
  */
 static int snd_soc_register_dais(struct snd_soc_component *component,
-				 struct snd_soc_dai_driver *dai_drv, size_t count)
+				 struct snd_soc_dai_driver *dai_drv,
+				 size_t count)
 {
 	struct device *dev = component->dev;
 	struct snd_soc_dai *dai;
@@ -2921,8 +2946,8 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 
 	for (i = 0; i < count; i++) {
 
-		dai = soc_add_dai(component, dai_drv + i,
-				  count == 1 && !component->driver->non_legacy_dai_naming);
+		dai = soc_add_dai(component, dai_drv + i, count == 1 &&
+				  !component->driver->non_legacy_dai_naming);
 		if (dai == NULL) {
 			ret = -ENOMEM;
 			goto err;
@@ -2966,7 +2991,8 @@ int snd_soc_register_dai(struct snd_soc_component *component,
 	if (!dai)
 		return -ENOMEM;
 
-	/* Create the DAI widgets here. After adding DAIs, topology may
+	/*
+	 * Create the DAI widgets here. After adding DAIs, topology may
 	 * also add routes that need these widgets as source or sink.
 	 */
 	ret = snd_soc_dapm_new_dai_widgets(dapm, dai);
@@ -3048,7 +3074,8 @@ static void snd_soc_component_setup_regmap(struct snd_soc_component *component)
 #ifdef CONFIG_REGMAP
 
 /**
- * snd_soc_component_init_regmap() - Initialize regmap instance for the component
+ * snd_soc_component_init_regmap() - Initialize regmap instance for the
+ *                                   component
  * @component: The component for which to initialize the regmap instance
  * @regmap: The regmap instance that should be used by the component
  *
@@ -3066,7 +3093,8 @@ void snd_soc_component_init_regmap(struct snd_soc_component *component,
 EXPORT_SYMBOL_GPL(snd_soc_component_init_regmap);
 
 /**
- * snd_soc_component_exit_regmap() - De-initialize regmap instance for the component
+ * snd_soc_component_exit_regmap() - De-initialize regmap instance for the
+ *                                   component
  * @component: The component for which to de-initialize the regmap instance
  *
  * Calls regmap_exit() on the regmap instance associated to the component and
@@ -3090,7 +3118,8 @@ static void snd_soc_component_add(struct snd_soc_component *component)
 
 	if (!component->driver->write && !component->driver->read) {
 		if (!component->regmap)
-			component->regmap = dev_get_regmap(component->dev, NULL);
+			component->regmap = dev_get_regmap(component->dev,
+							   NULL);
 		if (component->regmap)
 			snd_soc_component_setup_regmap(component);
 	}
@@ -3235,23 +3264,24 @@ static int __snd_soc_unregister_component(struct device *dev)
 		if (dev != component->dev)
 			continue;
 
-		snd_soc_tplg_component_remove(component, SND_SOC_TPLG_INDEX_ALL);
+		snd_soc_tplg_component_remove(component,
+					      SND_SOC_TPLG_INDEX_ALL);
 		snd_soc_component_del_unlocked(component);
 		found = 1;
 		break;
 	}
 	mutex_unlock(&client_mutex);
 
-	if (found) {
+	if (found)
 		snd_soc_component_cleanup(component);
-	}
 
 	return found;
 }
 
 void snd_soc_unregister_component(struct device *dev)
 {
-	while (__snd_soc_unregister_component(dev));
+	while (__snd_soc_unregister_component(dev))
+		;
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
@@ -3832,7 +3862,7 @@ int snd_soc_of_get_dai_link_codecs(struct device *dev,
 	for_each_link_codecs(dai_link, index, component) {
 		ret = of_parse_phandle_with_args(of_node, name,
 						 "#sound-dai-cells",
-						  index, &args);
+						 index, &args);
 		if (ret)
 			goto err;
 		component->of_node = args.np;

commit 15a0c64572463eddf59e80aa643d3a87809a7d9b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Sep 21 05:23:17 2018 +0000

    ASoC: add for_each_component_dais() macro
    
    To be more readable code, this patch adds
    new for_each_component_dais() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b9b33c8cac2e..62e8e36062df 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -180,7 +180,7 @@ static int dai_list_show(struct seq_file *m, void *v)
 	mutex_lock(&client_mutex);
 
 	for_each_component(component)
-		list_for_each_entry(dai, &component->dai_list, list)
+		for_each_component_dais(component, dai)
 			seq_printf(m, "%s\n", dai->name);
 
 	mutex_unlock(&client_mutex);
@@ -781,7 +781,7 @@ struct snd_soc_dai *snd_soc_find_dai(
 	for_each_component(component) {
 		if (!snd_soc_is_matching_component(dlc, component))
 			continue;
-		list_for_each_entry(dai, &component->dai_list, list) {
+		for_each_component_dais(component, dai) {
 			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name)
 			    && (!dai->driver->name
 				|| strcmp(dai->driver->name, dlc->dai_name)))
@@ -1312,7 +1312,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 		}
 	}
 
-	list_for_each_entry(dai, &component->dai_list, list) {
+	for_each_component_dais(component, dai) {
 		ret = snd_soc_dapm_new_dai_widgets(dapm, dai);
 		if (ret != 0) {
 			dev_err(component->dev,
@@ -2842,7 +2842,7 @@ static void snd_soc_unregister_dais(struct snd_soc_component *component)
 {
 	struct snd_soc_dai *dai, *_dai;
 
-	list_for_each_entry_safe(dai, _dai, &component->dai_list, list) {
+	for_each_component_dais_safe(component, dai, _dai) {
 		dev_dbg(component->dev, "ASoC: Unregistered DAI '%s'\n",
 			dai->name);
 		list_del(&dai->list);
@@ -2894,6 +2894,7 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 	if (!dai->driver->ops)
 		dai->driver->ops = &null_dai_ops;
 
+	/* see for_each_component_dais */
 	list_add_tail(&dai->list, &component->dai_list);
 	component->num_dai++;
 
@@ -3728,7 +3729,7 @@ int snd_soc_get_dai_name(struct of_phandle_args *args,
 			ret = 0;
 
 			/* find target DAI */
-			list_for_each_entry(dai, &pos->dai_list, list) {
+			for_each_component_dais(pos, dai) {
 				if (id == 0)
 					break;
 				id--;

commit 368dee9459472b44f760a35cd07a6f3b90b3e549
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Sep 21 05:23:01 2018 +0000

    ASoC: add for_each_component() macro
    
    To be more readable code, this patch adds
    new for_each_component() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d8625ac2b201..b9b33c8cac2e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -54,6 +54,9 @@ static DEFINE_MUTEX(client_mutex);
 static LIST_HEAD(component_list);
 static LIST_HEAD(unbind_card_list);
 
+#define for_each_component(component)			\
+	list_for_each_entry(component, &component_list, list)
+
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
  * It can be used to eliminate pops between different playback streams, e.g.
@@ -176,7 +179,7 @@ static int dai_list_show(struct seq_file *m, void *v)
 
 	mutex_lock(&client_mutex);
 
-	list_for_each_entry(component, &component_list, list)
+	for_each_component(component)
 		list_for_each_entry(dai, &component->dai_list, list)
 			seq_printf(m, "%s\n", dai->name);
 
@@ -192,7 +195,7 @@ static int component_list_show(struct seq_file *m, void *v)
 
 	mutex_lock(&client_mutex);
 
-	list_for_each_entry(component, &component_list, list)
+	for_each_component(component)
 		seq_printf(m, "%s\n", component->name);
 
 	mutex_unlock(&client_mutex);
@@ -725,7 +728,7 @@ static struct snd_soc_component *soc_find_component(
 
 	lockdep_assert_held(&client_mutex);
 
-	list_for_each_entry(component, &component_list, list) {
+	for_each_component(component) {
 		if (of_node) {
 			if (component->dev->of_node == of_node)
 				return component;
@@ -775,7 +778,7 @@ struct snd_soc_dai *snd_soc_find_dai(
 	lockdep_assert_held(&client_mutex);
 
 	/* Find CPU DAI from registered DAIs*/
-	list_for_each_entry(component, &component_list, list) {
+	for_each_component(component) {
 		if (!snd_soc_is_matching_component(dlc, component))
 			continue;
 		list_for_each_entry(dai, &component->dai_list, list) {
@@ -902,7 +905,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	rtd->codec_dai = codec_dais[0];
 
 	/* find one from the set of registered platforms */
-	list_for_each_entry(component, &component_list, list) {
+	for_each_component(component) {
 		if (!snd_soc_is_matching_component(dai_link->platform,
 						   component))
 			continue;
@@ -1874,7 +1877,7 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 	struct snd_soc_dai_link *dai_link;
 	int i;
 
-	list_for_each_entry(component, &component_list, list) {
+	for_each_component(component) {
 
 		/* does this component override FEs ? */
 		if (!component->driver->ignore_machine)
@@ -3091,6 +3094,7 @@ static void snd_soc_component_add(struct snd_soc_component *component)
 			snd_soc_component_setup_regmap(component);
 	}
 
+	/* see for_each_component */
 	list_add(&component->list, &component_list);
 	INIT_LIST_HEAD(&component->dobj_list);
 
@@ -3226,7 +3230,7 @@ static int __snd_soc_unregister_component(struct device *dev)
 	int found = 0;
 
 	mutex_lock(&client_mutex);
-	list_for_each_entry(component, &component_list, list) {
+	for_each_component(component) {
 		if (dev != component->dev)
 			continue;
 
@@ -3258,7 +3262,7 @@ struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
 
 	ret = NULL;
 	mutex_lock(&client_mutex);
-	list_for_each_entry(component, &component_list, list) {
+	for_each_component(component) {
 		if (dev != component->dev)
 			continue;
 
@@ -3658,7 +3662,7 @@ int snd_soc_get_dai_id(struct device_node *ep)
 	 */
 	ret = -ENOTSUPP;
 	mutex_lock(&client_mutex);
-	list_for_each_entry(pos, &component_list, list) {
+	for_each_component(pos) {
 		struct device_node *component_of_node = pos->dev->of_node;
 
 		if (!component_of_node && pos->dev->parent)
@@ -3688,7 +3692,7 @@ int snd_soc_get_dai_name(struct of_phandle_args *args,
 	int ret = -EPROBE_DEFER;
 
 	mutex_lock(&client_mutex);
-	list_for_each_entry(pos, &component_list, list) {
+	for_each_component(pos) {
 		component_of_node = pos->dev->of_node;
 		if (!component_of_node && pos->dev->parent)
 			component_of_node = pos->dev->parent->of_node;

commit 1a1035a9854fd893d487a84edccc1d5804e1d716
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 18 01:30:41 2018 +0000

    ASoC: add for_each_comp_order() macro
    
    To be more readable code, this patch adds
    new for_each_comp_order() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 673a694ede3e..d8625ac2b201 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -992,14 +992,12 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link *link, *_link;
 
-	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
-			order++) {
+	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd)
 			soc_remove_link_dais(card, rtd, order);
 	}
 
-	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
-			order++) {
+	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd)
 			soc_remove_link_components(card, rtd, order);
 	}
@@ -1617,8 +1615,7 @@ static int soc_probe_aux_devices(struct snd_soc_card *card)
 	int order;
 	int ret;
 
-	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
-		order++) {
+	for_each_comp_order(order) {
 		list_for_each_entry(comp, &card->aux_comp_list, card_aux_list) {
 			if (comp->driver->probe_order == order) {
 				ret = soc_probe_component(card,	comp);
@@ -1640,8 +1637,7 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 	struct snd_soc_component *comp, *_comp;
 	int order;
 
-	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
-		order++) {
+	for_each_comp_order(order) {
 		list_for_each_entry_safe(comp, _comp,
 			&card->aux_comp_list, card_aux_list) {
 
@@ -2013,8 +2009,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	/* probe all components used by DAI links on this card */
-	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
-			order++) {
+	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
 			ret = soc_probe_link_components(card, rtd, order);
 			if (ret < 0) {
@@ -2047,8 +2042,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	/* probe all DAI links on this card */
-	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
-			order++) {
+	for_each_comp_order(order) {
 		for_each_card_rtds(card, rtd) {
 			ret = soc_probe_link_dais(card, rtd, order);
 			if (ret < 0) {

commit f70f18f7d459b7958a4d3944396e2bc4a9f7ed72
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 18 01:29:55 2018 +0000

    ASoC: add for_each_card_components() macro
    
    To be more readable code, this patch adds
    new for_each_card_components() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7efcf3475d6f..673a694ede3e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -510,7 +510,7 @@ int snd_soc_suspend(struct device *dev)
 	snd_soc_dapm_sync(&card->dapm);
 
 	/* suspend all COMPONENTs */
-	list_for_each_entry(component, &card->component_dev_list, card_list) {
+	for_each_card_components(card, component) {
 		struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 
 		/* If there are paths active then the COMPONENT will be held with
@@ -602,7 +602,7 @@ static void soc_resume_deferred(struct work_struct *work)
 			cpu_dai->driver->resume(cpu_dai);
 	}
 
-	list_for_each_entry(component, &card->component_dev_list, card_list) {
+	for_each_card_components(card, component) {
 		if (component->suspended) {
 			if (component->driver->resume)
 				component->driver->resume(component);
@@ -1354,6 +1354,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 					component->driver->num_dapm_routes);
 
 	list_add(&dapm->list, &card->dapm_list);
+	/* see for_each_card_components */
 	list_add(&component->card_list, &card->component_dev_list);
 
 	return 0;

commit bcb1fd1fcd6507ba5a1f8610550135dc367aedb7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 18 01:29:35 2018 +0000

    ASoC: add for_each_card_rtds() macro
    
    To be more readable code, this patch adds
    new for_each_card_rtds() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 495173635642..7efcf3475d6f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -342,7 +342,7 @@ struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
 {
 	struct snd_soc_pcm_runtime *rtd;
 
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		if (rtd->dai_link->no_pcm &&
 			!strcmp(rtd->dai_link->name, dai_link))
 			return rtd->pcm->streams[stream].substream;
@@ -399,7 +399,7 @@ static void soc_remove_pcm_runtimes(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd, *_rtd;
 
-	list_for_each_entry_safe(rtd, _rtd, &card->rtd_list, list) {
+	for_each_card_rtds_safe(card, rtd, _rtd) {
 		list_del(&rtd->list);
 		soc_free_pcm_runtime(rtd);
 	}
@@ -412,7 +412,7 @@ struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
 {
 	struct snd_soc_pcm_runtime *rtd;
 
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		if (!strcmp(rtd->dai_link->name, dai_link))
 			return rtd;
 	}
@@ -452,7 +452,7 @@ int snd_soc_suspend(struct device *dev)
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D3hot);
 
 	/* mute any active DACs */
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *dai;
 
 		if (rtd->dai_link->ignore_suspend)
@@ -467,7 +467,7 @@ int snd_soc_suspend(struct device *dev)
 	}
 
 	/* suspend all pcms */
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
@@ -477,7 +477,7 @@ int snd_soc_suspend(struct device *dev)
 	if (card->suspend_pre)
 		card->suspend_pre(card);
 
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 
 		if (rtd->dai_link->ignore_suspend)
@@ -488,10 +488,10 @@ int snd_soc_suspend(struct device *dev)
 	}
 
 	/* close any waiting streams */
-	list_for_each_entry(rtd, &card->rtd_list, list)
+	for_each_card_rtds(card, rtd)
 		flush_delayed_work(&rtd->delayed_work);
 
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 
 		if (rtd->dai_link->ignore_suspend)
 			continue;
@@ -548,7 +548,7 @@ int snd_soc_suspend(struct device *dev)
 		}
 	}
 
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 
 		if (rtd->dai_link->ignore_suspend)
@@ -592,7 +592,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		card->resume_pre(card);
 
 	/* resume control bus DAIs */
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 
 		if (rtd->dai_link->ignore_suspend)
@@ -610,7 +610,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		}
 	}
 
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 
 		if (rtd->dai_link->ignore_suspend)
 			continue;
@@ -625,7 +625,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	/* unmute any active DACs */
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *dai;
 
 		if (rtd->dai_link->ignore_suspend)
@@ -639,7 +639,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		}
 	}
 
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 
 		if (rtd->dai_link->ignore_suspend)
@@ -674,7 +674,7 @@ int snd_soc_resume(struct device *dev)
 		return 0;
 
 	/* activate pins from sleep state */
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *codec_dai;
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 		int j;
@@ -694,7 +694,7 @@ int snd_soc_resume(struct device *dev)
 	 * have that problem and may take a substantial amount of time to resume
 	 * due to I/O costs and anti-pop so handle them out of line.
 	 */
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 		bus_control |= cpu_dai->driver->bus_control;
 	}
@@ -839,7 +839,7 @@ static bool soc_is_dai_link_bound(struct snd_soc_card *card,
 {
 	struct snd_soc_pcm_runtime *rtd;
 
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		if (rtd->dai_link == dai_link)
 			return true;
 	}
@@ -994,13 +994,13 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
-		list_for_each_entry(rtd, &card->rtd_list, list)
+		for_each_card_rtds(card, rtd)
 			soc_remove_link_dais(card, rtd, order);
 	}
 
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
-		list_for_each_entry(rtd, &card->rtd_list, list)
+		for_each_card_rtds(card, rtd)
 			soc_remove_link_components(card, rtd, order);
 	}
 
@@ -2014,7 +2014,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	/* probe all components used by DAI links on this card */
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
-		list_for_each_entry(rtd, &card->rtd_list, list) {
+		for_each_card_rtds(card, rtd) {
 			ret = soc_probe_link_components(card, rtd, order);
 			if (ret < 0) {
 				dev_err(card->dev,
@@ -2048,7 +2048,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	/* probe all DAI links on this card */
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
-		list_for_each_entry(rtd, &card->rtd_list, list) {
+		for_each_card_rtds(card, rtd) {
 			ret = soc_probe_link_dais(card, rtd, order);
 			if (ret < 0) {
 				dev_err(card->dev,
@@ -2169,7 +2169,7 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	struct snd_soc_pcm_runtime *rtd;
 
 	/* make sure any delayed work runs */
-	list_for_each_entry(rtd, &card->rtd_list, list)
+	for_each_card_rtds(card, rtd)
 		flush_delayed_work(&rtd->delayed_work);
 
 	/* free the ALSA card at first; this syncs with pending operations */
@@ -2211,13 +2211,13 @@ int snd_soc_poweroff(struct device *dev)
 
 	/* Flush out pmdown_time work - we actually do want to run it
 	 * now, we're shutting down so no imminent restart. */
-	list_for_each_entry(rtd, &card->rtd_list, list)
+	for_each_card_rtds(card, rtd)
 		flush_delayed_work(&rtd->delayed_work);
 
 	snd_soc_dapm_shutdown(card);
 
 	/* deactivate pins to sleep state */
-	list_for_each_entry(rtd, &card->rtd_list, list) {
+	for_each_card_rtds(card, rtd) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 		struct snd_soc_dai *codec_dai;
 		int i;
@@ -2686,7 +2686,7 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 		return ret;
 
 	/* deactivate pins to sleep state */
-	list_for_each_entry(rtd, &card->rtd_list, list)  {
+	for_each_card_rtds(card, rtd)  {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 		struct snd_soc_dai *codec_dai;
 		int j;

commit 98061fdbfccc02aa0fd6637c67a0524aab385b8d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 18 01:29:16 2018 +0000

    ASoC: add for_each_card_links() macro
    
    To be more readable code, this patch adds
    new for_each_card_links() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 532d8c59ed1e..495173635642 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -816,7 +816,7 @@ struct snd_soc_dai_link *snd_soc_find_dai_link(struct snd_soc_card *card,
 
 	lockdep_assert_held(&client_mutex);
 
-	list_for_each_entry_safe(link, _link, &card->dai_link_list, list) {
+	for_each_card_links_safe(card, link, _link) {
 		if (link->id != id)
 			continue;
 
@@ -1004,7 +1004,7 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 			soc_remove_link_components(card, rtd, order);
 	}
 
-	list_for_each_entry_safe(link, _link, &card->dai_link_list, list) {
+	for_each_card_links_safe(card, link, _link) {
 		if (link->dobj.type == SND_SOC_DOBJ_DAI_LINK)
 			dev_warn(card->dev, "Topology forgot to remove link %s?\n",
 				link->name);
@@ -1219,7 +1219,7 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 	if (dai_link->dobj.type && card->remove_dai_link)
 		card->remove_dai_link(card, dai_link);
 
-	list_for_each_entry_safe(link, _link, &card->dai_link_list, list) {
+	for_each_card_links_safe(card, link, _link) {
 		if (link == dai_link) {
 			list_del(&link->list);
 			return;
@@ -2033,7 +2033,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	/* Find new DAI links added during probing components and bind them.
 	 * Components with topology may bring new DAIs and DAI links.
 	 */
-	list_for_each_entry(dai_link, &card->dai_link_list, list) {
+	for_each_card_links(card, dai_link) {
 		if (soc_is_dai_link_bound(card, dai_link))
 			continue;
 

commit 7fe072b4df5d0cc832eb758c1eed243c145a2dfc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 18 01:28:49 2018 +0000

    ASoC: add for_each_card_prelinks() macro
    
    To be more readable code, this patch adds
    new for_each_card_prelinks() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index da2b2a758b6d..532d8c59ed1e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1889,9 +1889,7 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 			continue;
 
 		/* machine matches, so override the rtd data */
-		for (i = 0; i < card->num_links; i++) {
-
-			dai_link = &card->dai_link[i];
+		for_each_card_prelinks(card, i, dai_link) {
 
 			/* ignore this FE */
 			if (dai_link->dynamic) {
@@ -1955,8 +1953,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	soc_check_tplg_fes(card);
 
 	/* bind DAIs */
-	for (i = 0; i < card->num_links; i++) {
-		ret = soc_bind_dai_link(card, &card->dai_link[i]);
+	for_each_card_prelinks(card, i, dai_link) {
+		ret = soc_bind_dai_link(card, dai_link);
 		if (ret != 0)
 			goto base_error;
 	}
@@ -1969,8 +1967,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	/* add predefined DAI links to the list */
-	for (i = 0; i < card->num_links; i++)
-		snd_soc_add_dai_link(card, card->dai_link+i);
+	for_each_card_prelinks(card, i, dai_link)
+		snd_soc_add_dai_link(card, dai_link);
 
 	/* card bind complete so register a sound card */
 	ret = snd_card_new(card->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
@@ -2714,12 +2712,12 @@ static int snd_soc_bind_card(struct snd_soc_card *card)
 int snd_soc_register_card(struct snd_soc_card *card)
 {
 	int i, ret;
+	struct snd_soc_dai_link *link;
 
 	if (!card->name || !card->dev)
 		return -EINVAL;
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai_link *link = &card->dai_link[i];
+	for_each_card_prelinks(card, i, link) {
 
 		ret = soc_init_dai_link(card, link);
 		if (ret) {

commit be6ac0a9ced99403c435b2b2fe9ac4bd55749823
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 11 06:51:45 2018 +0000

    ASoC: soc-core: add snd_soc_is_matching_component()
    
    To find (CPU/)Codec/Platform, we need to find component first
    (= on CPU/Codec/Platform), and find DAI from it (= CPU/Codec).
    These are similar operation but difficult to be simple,
    and has many duplicate code to finding component.
    This patch adds new snd_soc_is_matching_component(),
    and reduce duplicate codes.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d856b08f5f99..da2b2a758b6d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -737,6 +737,24 @@ static struct snd_soc_component *soc_find_component(
 	return NULL;
 }
 
+static int snd_soc_is_matching_component(
+	const struct snd_soc_dai_link_component *dlc,
+	struct snd_soc_component *component)
+{
+	struct device_node *component_of_node;
+
+	component_of_node = component->dev->of_node;
+	if (!component_of_node && component->dev->parent)
+		component_of_node = component->dev->parent->of_node;
+
+	if (dlc->of_node && component_of_node != dlc->of_node)
+		return 0;
+	if (dlc->name && strcmp(component->name, dlc->name))
+		return 0;
+
+	return 1;
+}
+
 /**
  * snd_soc_find_dai - Find a registered DAI
  *
@@ -753,19 +771,12 @@ struct snd_soc_dai *snd_soc_find_dai(
 {
 	struct snd_soc_component *component;
 	struct snd_soc_dai *dai;
-	struct device_node *component_of_node;
 
 	lockdep_assert_held(&client_mutex);
 
 	/* Find CPU DAI from registered DAIs*/
 	list_for_each_entry(component, &component_list, list) {
-		component_of_node = component->dev->of_node;
-		if (!component_of_node && component->dev->parent)
-			component_of_node = component->dev->parent->of_node;
-
-		if (dlc->of_node && component_of_node != dlc->of_node)
-			continue;
-		if (dlc->name && strcmp(component->name, dlc->name))
+		if (!snd_soc_is_matching_component(dlc, component))
 			continue;
 		list_for_each_entry(dai, &component->dai_list, list) {
 			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name)
@@ -844,7 +855,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_component *component;
 	struct snd_soc_dai **codec_dais;
-	struct device_node *platform_of_node;
 	int i;
 
 	if (dai_link->ignore)
@@ -893,17 +903,9 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 	/* find one from the set of registered platforms */
 	list_for_each_entry(component, &component_list, list) {
-		platform_of_node = component->dev->of_node;
-		if (!platform_of_node && component->dev->parent->of_node)
-			platform_of_node = component->dev->parent->of_node;
-
-		if (dai_link->platform->of_node) {
-			if (platform_of_node != dai_link->platform->of_node)
-				continue;
-		} else {
-			if (strcmp(component->name, dai_link->platform->name))
-				continue;
-		}
+		if (!snd_soc_is_matching_component(dai_link->platform,
+						   component))
+			continue;
 
 		snd_soc_rtdcom_add(rtd, component);
 	}

commit 4a9ed39477bd1635cf23b49e10f9e364329bbe46
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 11 06:51:14 2018 +0000

    ASoC: soc-core: manage platform name under snd_soc_init_platform()
    
    Now "platform" is controlled by snd_soc_dai_link_component,
    thus its "name" can be initialized in snd_soc_init_platform(),
    instead of soc_bind_dai_link() local.
    This patch do it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 325dc1964850..d856b08f5f99 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -845,7 +845,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_component *component;
 	struct snd_soc_dai **codec_dais;
 	struct device_node *platform_of_node;
-	const char *platform_name;
 	int i;
 
 	if (dai_link->ignore)
@@ -892,11 +891,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	/* Single codec links expect codec and codec_dai in runtime data */
 	rtd->codec_dai = codec_dais[0];
 
-	/* if there's no platform we match on the empty platform */
-	platform_name = dai_link->platform->name;
-	if (!platform_name && !dai_link->platform->of_node)
-		platform_name = "snd-soc-dummy";
-
 	/* find one from the set of registered platforms */
 	list_for_each_entry(component, &component_list, list) {
 		platform_of_node = component->dev->of_node;
@@ -907,7 +901,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 			if (platform_of_node != dai_link->platform->of_node)
 				continue;
 		} else {
-			if (strcmp(component->name, platform_name))
+			if (strcmp(component->name, dai_link->platform->name))
 				continue;
 		}
 
@@ -1020,24 +1014,31 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 static int snd_soc_init_platform(struct snd_soc_card *card,
 				 struct snd_soc_dai_link *dai_link)
 {
+	struct snd_soc_dai_link_component *platform = dai_link->platform;
+
 	/*
 	 * FIXME
 	 *
 	 * this function should be removed in the future
 	 */
 	/* convert Legacy platform link */
-	if (dai_link->platform)
-		return 0;
-
-	dai_link->platform = devm_kzalloc(card->dev,
+	if (!platform) {
+		platform = devm_kzalloc(card->dev,
 				sizeof(struct snd_soc_dai_link_component),
 				GFP_KERNEL);
-	if (!dai_link->platform)
-		return -ENOMEM;
+		if (!platform)
+			return -ENOMEM;
 
-	dai_link->platform->name	= dai_link->platform_name;
-	dai_link->platform->of_node	= dai_link->platform_of_node;
-	dai_link->platform->dai_name	= NULL;
+		dai_link->platform	= platform;
+		platform->name		= dai_link->platform_name;
+		platform->of_node	= dai_link->platform_of_node;
+		platform->dai_name	= NULL;
+	}
+
+	/* if there's no platform we match on the empty platform */
+	if (!platform->name &&
+	    !platform->of_node)
+		platform->name = "snd-soc-dummy";
 
 	return 0;
 }

commit a7c439d6128de2cbc087ae7524b47f613ff8bc6c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 11 15:50:27 2018 +0900

    ASoC: soc-core: remove dai->driver NULL check
    
    It is strange if it has "dai" but doesn't have "dai->driver".
    And more over "dai->driver->xxx" is used everywhere without
    "dai->driver" pointer NULL checking.
    It got Oops already if "dai->driver" was NULL.
    Let's remove un-needed "dai->driver" NULL check.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 807f112fad80..325dc1964850 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2519,8 +2519,6 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
  */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	if (dai->driver == NULL)
-		return -EINVAL;
 	if (dai->driver->ops->set_fmt == NULL)
 		return -ENOTSUPP;
 	return dai->driver->ops->set_fmt(dai, fmt);
@@ -2667,9 +2665,6 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
 int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
 			     int direction)
 {
-	if (!dai->driver)
-		return -ENOTSUPP;
-
 	if (dai->driver->ops->mute_stream)
 		return dai->driver->ops->mute_stream(dai, mute, direction);
 	else if (direction == SNDRV_PCM_STREAM_PLAYBACK &&

commit e894efef9ac7c10b7727798dcc711cccf07569f9
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Wed Sep 12 10:15:00 2018 +0100

    ASoC: core: add support to card rebind
    
    Current behaviour of ASoC core w.r.t to component removal is that it
    unregisters dependent sound card totally. There is no support to
    rebind the card if the component comes back.
    Typical use case is DSP restart or kernel modules itself.
    
    With this patch, core now maintains list of cards that are unbind due to
    any of its depended components are removed and card not unregistered yet.
    This list is cleared when the card is rebind successfully or when the
    card is unregistered from machine driver.
    
    This list of unbind cards are tried to bind once again after every new
    component is successfully added, giving a fair chance for card bind
    to be successful.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7e18937c2214..807f112fad80 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -52,6 +52,7 @@ EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);
 
 static DEFINE_MUTEX(client_mutex);
 static LIST_HEAD(component_list);
+static LIST_HEAD(unbind_card_list);
 
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
@@ -2679,6 +2680,33 @@ int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 
+static int snd_soc_bind_card(struct snd_soc_card *card)
+{
+	struct snd_soc_pcm_runtime *rtd;
+	int ret;
+
+	ret = snd_soc_instantiate_card(card);
+	if (ret != 0)
+		return ret;
+
+	/* deactivate pins to sleep state */
+	list_for_each_entry(rtd, &card->rtd_list, list)  {
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+		struct snd_soc_dai *codec_dai;
+		int j;
+
+		for_each_rtd_codec_dai(rtd, j, codec_dai) {
+			if (!codec_dai->active)
+				pinctrl_pm_select_sleep_state(codec_dai->dev);
+		}
+
+		if (!cpu_dai->active)
+			pinctrl_pm_select_sleep_state(cpu_dai->dev);
+	}
+
+	return ret;
+}
+
 /**
  * snd_soc_register_card - Register a card with the ASoC core
  *
@@ -2688,7 +2716,6 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 int snd_soc_register_card(struct snd_soc_card *card)
 {
 	int i, ret;
-	struct snd_soc_pcm_runtime *rtd;
 
 	if (!card->name || !card->dev)
 		return -EINVAL;
@@ -2719,28 +2746,23 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	mutex_init(&card->mutex);
 	mutex_init(&card->dapm_mutex);
 
-	ret = snd_soc_instantiate_card(card);
-	if (ret != 0)
-		return ret;
-
-	/* deactivate pins to sleep state */
-	list_for_each_entry(rtd, &card->rtd_list, list)  {
-		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-		struct snd_soc_dai *codec_dai;
-		int j;
-
-		for_each_rtd_codec_dai(rtd, j, codec_dai) {
-			if (!codec_dai->active)
-				pinctrl_pm_select_sleep_state(codec_dai->dev);
-		}
+	return snd_soc_bind_card(card);
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_card);
 
-		if (!cpu_dai->active)
-			pinctrl_pm_select_sleep_state(cpu_dai->dev);
+static void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)
+{
+	if (card->instantiated) {
+		card->instantiated = false;
+		snd_soc_dapm_shutdown(card);
+		soc_cleanup_card_resources(card);
+		if (!unregister)
+			list_add(&card->list, &unbind_card_list);
+	} else {
+		if (unregister)
+			list_del(&card->list);
 	}
-
-	return ret;
 }
-EXPORT_SYMBOL_GPL(snd_soc_register_card);
 
 /**
  * snd_soc_unregister_card - Unregister a card with the ASoC core
@@ -2750,12 +2772,8 @@ EXPORT_SYMBOL_GPL(snd_soc_register_card);
  */
 int snd_soc_unregister_card(struct snd_soc_card *card)
 {
-	if (card->instantiated) {
-		card->instantiated = false;
-		snd_soc_dapm_shutdown(card);
-		soc_cleanup_card_resources(card);
-		dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
-	}
+	snd_soc_unbind_card(card, true);
+	dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 
 	return 0;
 }
@@ -3099,7 +3117,7 @@ static void snd_soc_component_del_unlocked(struct snd_soc_component *component)
 	struct snd_soc_card *card = component->card;
 
 	if (card)
-		snd_soc_unregister_card(card);
+		snd_soc_unbind_card(card, false);
 
 	list_del(&component->list);
 }
@@ -3139,6 +3157,18 @@ static void convert_endianness_formats(struct snd_soc_pcm_stream *stream)
 			stream->formats |= endianness_format_map[i];
 }
 
+static void snd_soc_try_rebind_card(void)
+{
+	struct snd_soc_card *card, *c;
+
+	if (!list_empty(&unbind_card_list)) {
+		list_for_each_entry_safe(card, c, &unbind_card_list, list) {
+			if (!snd_soc_bind_card(card))
+				list_del(&card->list);
+		}
+	}
+}
+
 int snd_soc_add_component(struct device *dev,
 			struct snd_soc_component *component,
 			const struct snd_soc_component_driver *component_driver,
@@ -3166,6 +3196,7 @@ int snd_soc_add_component(struct device *dev,
 	}
 
 	snd_soc_component_add(component);
+	snd_soc_try_rebind_card();
 
 	return 0;
 

commit 4f1b327e65a9516a46ea491ce72a5161be176af8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 11 06:59:01 2018 +0000

    ASoC: soc-core: remove unused num_dai_links
    
    ALSA SoC is counting card->dai_link_list user,
    but no-one is using it.
    Let's remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index dde9b70b58b5..7e18937c2214 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1013,7 +1013,6 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 				link->name);
 
 		list_del(&link->list);
-		card->num_dai_links--;
 	}
 }
 
@@ -1182,7 +1181,6 @@ int snd_soc_add_dai_link(struct snd_soc_card *card,
 		card->add_dai_link(card, dai_link);
 
 	list_add_tail(&dai_link->list, &card->dai_link_list);
-	card->num_dai_links++;
 
 	return 0;
 }
@@ -1220,7 +1218,6 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 	list_for_each_entry_safe(link, _link, &card->dai_link_list, list) {
 		if (link == dai_link) {
 			list_del(&link->list);
-			card->num_dai_links--;
 			return;
 		}
 	}
@@ -2712,7 +2709,6 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	snd_soc_initialize_card_lists(card);
 
 	INIT_LIST_HEAD(&card->dai_link_list);
-	card->num_dai_links = 0;
 
 	INIT_LIST_HEAD(&card->rtd_list);
 	card->num_rtd = 0;

commit 2eda3cb108b699a6ff78a87e25143c153bc88e41
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 11 06:54:26 2018 +0000

    ASoC: soc-core: avoid nested code on soc_remove_dai()
    
    Nested code is not readable.
    This patch avoid it on soc_remove_dai().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4e9367aacc0c..dde9b70b58b5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -942,17 +942,18 @@ static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 {
 	int err;
 
-	if (dai && dai->probed &&
-			dai->driver->remove_order == order) {
-		if (dai->driver->remove) {
-			err = dai->driver->remove(dai);
-			if (err < 0)
-				dev_err(dai->dev,
-					"ASoC: failed to remove %s: %d\n",
-					dai->name, err);
-		}
-		dai->probed = 0;
+	if (!dai || !dai->probed ||
+	    dai->driver->remove_order != order)
+		return;
+
+	if (dai->driver->remove) {
+		err = dai->driver->remove(dai);
+		if (err < 0)
+			dev_err(dai->dev,
+				"ASoC: failed to remove %s: %d\n",
+				dai->name, err);
 	}
+	dai->probed = 0;
 }
 
 static void soc_remove_link_dais(struct snd_soc_card *card,

commit 778ff5bb8689eb4fd05a72a409e32a3a34e23faf
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Wed Sep 5 15:21:00 2018 +0100

    ASoC: dapm: Move connection of CODEC to CODEC DAIs
    
    Currently, snd_soc_dapm_connect_dai_link_widgets connects up the routes
    representing normal DAIs, however CODEC to CODEC links are hooked up
    through separate infrastructure in soc_link_dai_widgets. Improve the
    consistency of the code by using snd_soc_dapm_connect_dai_link for both
    types of DAIs.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 390da15c4a8b..4e9367aacc0c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1463,48 +1463,6 @@ static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
 	return 0;
 }
 
-static int soc_link_dai_widgets(struct snd_soc_card *card,
-				struct snd_soc_dai_link *dai_link,
-				struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_dapm_widget *sink, *source;
-	int ret;
-
-	if (rtd->num_codecs > 1)
-		dev_warn(card->dev, "ASoC: Multiple codecs not supported yet\n");
-
-	/* link the DAI widgets */
-	sink = codec_dai->playback_widget;
-	source = cpu_dai->capture_widget;
-	if (sink && source) {
-		ret = snd_soc_dapm_new_pcm(card, rtd, dai_link->params,
-					   dai_link->num_params,
-					   source, sink);
-		if (ret != 0) {
-			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
-				sink->name, source->name, ret);
-			return ret;
-		}
-	}
-
-	sink = cpu_dai->playback_widget;
-	source = codec_dai->capture_widget;
-	if (sink && source) {
-		ret = snd_soc_dapm_new_pcm(card, rtd, dai_link->params,
-					   dai_link->num_params,
-					   source, sink);
-		if (ret != 0) {
-			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
-				sink->name, source->name, ret);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
 static int soc_probe_link_dais(struct snd_soc_card *card,
 		struct snd_soc_pcm_runtime *rtd, int order)
 {
@@ -1606,11 +1564,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 		} else {
 			INIT_DELAYED_WORK(&rtd->delayed_work,
 						codec2codec_close_delayed_work);
-
-			/* link the DAI widgets */
-			ret = soc_link_dai_widgets(card, dai_link, rtd);
-			if (ret)
-				return ret;
 		}
 	}
 

commit 0b7990e38971da403ce223d8bdc758a817eb72f8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Sep 3 02:12:56 2018 +0000

    ASoC: add for_each_rtd_codec_dai() macro
    
    ALSA SoC snd_soc_pcm_runtime has snd_soc_dai array for codec_dai.
    To be more readable code, this patch adds
    new for_each_rtd_codec_dai() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index eeab492e954f..390da15c4a8b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -452,12 +452,12 @@ int snd_soc_suspend(struct device *dev)
 
 	/* mute any active DACs */
 	list_for_each_entry(rtd, &card->rtd_list, list) {
+		struct snd_soc_dai *dai;
 
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		for (i = 0; i < rtd->num_codecs; i++) {
-			struct snd_soc_dai *dai = rtd->codec_dais[i];
+		for_each_rtd_codec_dai(rtd, i, dai) {
 			struct snd_soc_dai_driver *drv = dai->driver;
 
 			if (drv->ops->digital_mute && dai->playback_active)
@@ -625,12 +625,12 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	/* unmute any active DACs */
 	list_for_each_entry(rtd, &card->rtd_list, list) {
+		struct snd_soc_dai *dai;
 
 		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		for (i = 0; i < rtd->num_codecs; i++) {
-			struct snd_soc_dai *dai = rtd->codec_dais[i];
+		for_each_rtd_codec_dai(rtd, i, dai) {
 			struct snd_soc_dai_driver *drv = dai->driver;
 
 			if (drv->ops->digital_mute && dai->playback_active)
@@ -674,15 +674,14 @@ int snd_soc_resume(struct device *dev)
 
 	/* activate pins from sleep state */
 	list_for_each_entry(rtd, &card->rtd_list, list) {
-		struct snd_soc_dai **codec_dais = rtd->codec_dais;
+		struct snd_soc_dai *codec_dai;
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 		int j;
 
 		if (cpu_dai->active)
 			pinctrl_pm_select_default_state(cpu_dai->dev);
 
-		for (j = 0; j < rtd->num_codecs; j++) {
-			struct snd_soc_dai *codec_dai = codec_dais[j];
+		for_each_rtd_codec_dai(rtd, j, codec_dai) {
 			if (codec_dai->active)
 				pinctrl_pm_select_default_state(codec_dai->dev);
 		}
@@ -877,6 +876,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	rtd->num_codecs = dai_link->num_codecs;
 
 	/* Find CODEC from registered CODECs */
+	/* we can use for_each_rtd_codec_dai() after this */
 	codec_dais = rtd->codec_dais;
 	for (i = 0; i < rtd->num_codecs; i++) {
 		codec_dais[i] = snd_soc_find_dai(&codecs[i]);
@@ -959,6 +959,7 @@ static void soc_remove_link_dais(struct snd_soc_card *card,
 		struct snd_soc_pcm_runtime *rtd, int order)
 {
 	int i;
+	struct snd_soc_dai *codec_dai;
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
@@ -967,8 +968,8 @@ static void soc_remove_link_dais(struct snd_soc_card *card,
 	}
 
 	/* remove the CODEC DAI */
-	for (i = 0; i < rtd->num_codecs; i++)
-		soc_remove_dai(rtd->codec_dais[i], order);
+	for_each_rtd_codec_dai(rtd, i, codec_dai)
+		soc_remove_dai(codec_dai, order);
 
 	soc_remove_dai(rtd->cpu_dai, order);
 }
@@ -1511,6 +1512,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_component *component;
+	struct snd_soc_dai *codec_dai;
 	int i, ret, num;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
@@ -1524,8 +1526,8 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 		return ret;
 
 	/* probe the CODEC DAI */
-	for (i = 0; i < rtd->num_codecs; i++) {
-		ret = soc_probe_dai(rtd->codec_dais[i], order);
+	for_each_rtd_codec_dai(rtd, i, codec_dai) {
+		ret = soc_probe_dai(codec_dai, order);
 		if (ret)
 			return ret;
 	}
@@ -1712,14 +1714,12 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 	unsigned int dai_fmt)
 {
-	struct snd_soc_dai **codec_dais = rtd->codec_dais;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai;
 	unsigned int i;
 	int ret;
 
-	for (i = 0; i < rtd->num_codecs; i++) {
-		struct snd_soc_dai *codec_dai = codec_dais[i];
-
+	for_each_rtd_codec_dai(rtd, i, codec_dai) {
 		ret = snd_soc_dai_set_fmt(codec_dai, dai_fmt);
 		if (ret != 0 && ret != -ENOTSUPP) {
 			dev_warn(codec_dai->dev,
@@ -2266,11 +2266,11 @@ int snd_soc_poweroff(struct device *dev)
 	/* deactivate pins to sleep state */
 	list_for_each_entry(rtd, &card->rtd_list, list) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+		struct snd_soc_dai *codec_dai;
 		int i;
 
 		pinctrl_pm_select_sleep_state(cpu_dai->dev);
-		for (i = 0; i < rtd->num_codecs; i++) {
-			struct snd_soc_dai *codec_dai = rtd->codec_dais[i];
+		for_each_rtd_codec_dai(rtd, i, codec_dai) {
 			pinctrl_pm_select_sleep_state(codec_dai->dev);
 		}
 	}
@@ -2776,10 +2776,10 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	/* deactivate pins to sleep state */
 	list_for_each_entry(rtd, &card->rtd_list, list)  {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+		struct snd_soc_dai *codec_dai;
 		int j;
 
-		for (j = 0; j < rtd->num_codecs; j++) {
-			struct snd_soc_dai *codec_dai = rtd->codec_dais[j];
+		for_each_rtd_codec_dai(rtd, j, codec_dai) {
 			if (!codec_dai->active)
 				pinctrl_pm_select_sleep_state(codec_dai->dev);
 		}

commit 3db769f17714ae65f2faf44ff2bae9d52f4bd46b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Sep 3 02:12:40 2018 +0000

    ASoC: add for_each_link_codecs() macro
    
    ALSA SoC snd_soc_dai_link has snd_soc_dai_link_component array
    for codecs.
    To be more readable code, this patch adds
    new for_each_link_codecs() macro, and replace existing code to it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e9c2304afaf1..eeab492e954f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1071,6 +1071,7 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 				   struct snd_soc_dai_link *link)
 {
 	int i, ret;
+	struct snd_soc_dai_link_component *codec;
 
 	ret = snd_soc_init_platform(card, link);
 	if (ret) {
@@ -1084,19 +1085,19 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 		return ret;
 	}
 
-	for (i = 0; i < link->num_codecs; i++) {
+	for_each_link_codecs(link, i, codec) {
 		/*
 		 * Codec must be specified by 1 of name or OF node,
 		 * not both or neither.
 		 */
-		if (!!link->codecs[i].name ==
-		    !!link->codecs[i].of_node) {
+		if (!!codec->name ==
+		    !!codec->of_node) {
 			dev_err(card->dev, "ASoC: Neither/both codec name/of_node are set for %s\n",
 				link->name);
 			return -EINVAL;
 		}
 		/* Codec DAI name must be specified */
-		if (!link->codecs[i].dai_name) {
+		if (!codec->dai_name) {
 			dev_err(card->dev, "ASoC: codec_dai_name not set for %s\n",
 				link->name);
 			return -EINVAL;
@@ -3796,10 +3797,10 @@ EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_name);
  */
 void snd_soc_of_put_dai_link_codecs(struct snd_soc_dai_link *dai_link)
 {
-	struct snd_soc_dai_link_component *component = dai_link->codecs;
+	struct snd_soc_dai_link_component *component;
 	int index;
 
-	for (index = 0; index < dai_link->num_codecs; index++, component++) {
+	for_each_link_codecs(dai_link, index, component) {
 		if (!component->of_node)
 			break;
 		of_node_put(component->of_node);
@@ -3851,9 +3852,7 @@ int snd_soc_of_get_dai_link_codecs(struct device *dev,
 	dai_link->num_codecs = num_codecs;
 
 	/* Parse the list */
-	for (index = 0, component = dai_link->codecs;
-	     index < dai_link->num_codecs;
-	     index++, component++) {
+	for_each_link_codecs(dai_link, index, component) {
 		ret = of_parse_phandle_with_args(of_node, name,
 						 "#sound-dai-cells",
 						  index, &args);

commit 63a886f38dd96868e33488eccee8ed427144d397
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Sep 2 19:38:10 2018 -0700

    ASoC: fix soc-core.c kernel-doc warning
    
    Fix kernel-doc warning:
    
    ../sound/soc/soc-core.c:2918: warning: Excess function parameter 'legacy_dai_naming' description in 'snd_soc_register_dais'
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2a73630d0680..e9c2304afaf1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2944,8 +2944,6 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
  * @component: The component the DAIs are registered for
  * @dai_drv: DAI driver to use for the DAIs
  * @count: Number of DAIs
- * @legacy_dai_naming: Use the legacy naming scheme and let the DAI inherit the
- *                     parent's name.
  */
 static int snd_soc_register_dais(struct snd_soc_component *component,
 				 struct snd_soc_dai_driver *dai_drv, size_t count)

commit daecf46ee0e5f0fb2349e20af53c4653e2afc440
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 31 03:10:08 2018 +0000

    ASoC: soc-core: use snd_soc_dai_link_component for platform
    
    Current struct snd_soc_dai_link is supporting multicodec,
    and it is supporting legacy style of
            codec_name
            codec_of_node
            code_dai_name
    This is handled as single entry of multicodec.
    
    We don't have multicpu support yet, but in the future we will.
    In such case, we can use snd_soc_dai_link_component for both
    cpu/codec. Then the code will be more simple and readble.
    
    As next step, we want to use it for platform, too.
    This patch adds snd_soc_dai_link_component style for platform.
    We might have multiplatform support in the future, but we
    don't know yet. To avoid un-known issue / complex code,
    this patch supports just single-platform as 1st step.
    
    If we could use snd_soc_dai_link_component for all CPU/Codec/Platform,
    we will switch to new style, and remove legacy code.
    This is prepare for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 473eefe8658e..2a73630d0680 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -892,8 +892,8 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	rtd->codec_dai = codec_dais[0];
 
 	/* if there's no platform we match on the empty platform */
-	platform_name = dai_link->platform_name;
-	if (!platform_name && !dai_link->platform_of_node)
+	platform_name = dai_link->platform->name;
+	if (!platform_name && !dai_link->platform->of_node)
 		platform_name = "snd-soc-dummy";
 
 	/* find one from the set of registered platforms */
@@ -902,8 +902,8 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 		if (!platform_of_node && component->dev->parent->of_node)
 			platform_of_node = component->dev->parent->of_node;
 
-		if (dai_link->platform_of_node) {
-			if (platform_of_node != dai_link->platform_of_node)
+		if (dai_link->platform->of_node) {
+			if (platform_of_node != dai_link->platform->of_node)
 				continue;
 		} else {
 			if (strcmp(component->name, platform_name))
@@ -1015,6 +1015,31 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 	}
 }
 
+static int snd_soc_init_platform(struct snd_soc_card *card,
+				 struct snd_soc_dai_link *dai_link)
+{
+	/*
+	 * FIXME
+	 *
+	 * this function should be removed in the future
+	 */
+	/* convert Legacy platform link */
+	if (dai_link->platform)
+		return 0;
+
+	dai_link->platform = devm_kzalloc(card->dev,
+				sizeof(struct snd_soc_dai_link_component),
+				GFP_KERNEL);
+	if (!dai_link->platform)
+		return -ENOMEM;
+
+	dai_link->platform->name	= dai_link->platform_name;
+	dai_link->platform->of_node	= dai_link->platform_of_node;
+	dai_link->platform->dai_name	= NULL;
+
+	return 0;
+}
+
 static int snd_soc_init_multicodec(struct snd_soc_card *card,
 				   struct snd_soc_dai_link *dai_link)
 {
@@ -1047,6 +1072,12 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 {
 	int i, ret;
 
+	ret = snd_soc_init_platform(card, link);
+	if (ret) {
+		dev_err(card->dev, "ASoC: failed to init multiplatform\n");
+		return ret;
+	}
+
 	ret = snd_soc_init_multicodec(card, link);
 	if (ret) {
 		dev_err(card->dev, "ASoC: failed to init multicodec\n");
@@ -1076,13 +1107,12 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	 * Platform may be specified by either name or OF node, but
 	 * can be left unspecified, and a dummy platform will be used.
 	 */
-	if (link->platform_name && link->platform_of_node) {
+	if (link->platform->name && link->platform->of_node) {
 		dev_err(card->dev,
 			"ASoC: Both platform name/of_node are set for %s\n",
 			link->name);
 		return -EINVAL;
 	}
-
 	/*
 	 * CPU device may be specified by either name or OF node, but
 	 * can be left unspecified, and will be matched based on DAI
@@ -1917,7 +1947,11 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 				 card->dai_link[i].name);
 
 			/* override platform component */
-			dai_link->platform_name = component->name;
+			if (snd_soc_init_platform(card, dai_link) < 0) {
+				dev_err(card->dev, "init platform error");
+				continue;
+			}
+			dai_link->platform->name = component->name;
 
 			/* convert non BE into BE */
 			dai_link->no_pcm = 1;

commit 249dc49576fc953a7378b916c6a6d47ea81e4da2
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Wed Aug 15 13:11:35 2018 +0100

    ASoC: dapm: Fix NULL pointer deference on CODEC to CODEC DAIs
    
    Commit a655de808cbde ("ASoC: core: Allow topology to override
    machine driver FE DAI link config.") caused soc_dai_hw_params to
    be come dependent on the substream private_data being set with
    a pointer to the snd_soc_pcm_runtime. Currently, CODEC to CODEC
    links don't set this, which causes a NULL pointer dereference:
    
    [<4069de54>] (soc_dai_hw_params) from
    [<40694b68>] (snd_soc_dai_link_event+0x1a0/0x380)
    
    Since the ASoC core in general assumes that the substream
    private_data will be set to a pointer to the snd_soc_pcm_runtime,
    update the CODEC to CODEC links to respect this.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9cfe10d8040c..473eefe8658e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1447,7 +1447,7 @@ static int soc_link_dai_widgets(struct snd_soc_card *card,
 	sink = codec_dai->playback_widget;
 	source = cpu_dai->capture_widget;
 	if (sink && source) {
-		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
+		ret = snd_soc_dapm_new_pcm(card, rtd, dai_link->params,
 					   dai_link->num_params,
 					   source, sink);
 		if (ret != 0) {
@@ -1460,7 +1460,7 @@ static int soc_link_dai_widgets(struct snd_soc_card *card,
 	sink = cpu_dai->playback_widget;
 	source = codec_dai->capture_widget;
 	if (sink && source) {
-		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
+		ret = snd_soc_dapm_new_pcm(card, rtd, dai_link->params,
 					   dai_link->num_params,
 					   source, sink);
 		if (ret != 0) {

commit 1a12d5dc7dd1ffd985503f9770b736fb03db2e3f
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Aug 3 11:34:30 2018 -0500

    ASoC: core: mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 146568 ("Missing break in switch")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 82eb3868be67..9cfe10d8040c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -528,6 +528,7 @@ int snd_soc_suspend(struct device *dev)
 						"ASoC: idle_bias_off CODEC on over suspend\n");
 					break;
 				}
+				/* fall through */
 
 			case SND_SOC_BIAS_OFF:
 				if (component->driver->suspend)

commit 611cbc8799b672f41b6ba7afed758ad9efb959a7
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Thu Aug 2 16:03:38 2018 +0100

    ASoC: core: remove support for card rebind using component framework
    
    DRM based audio components get registered inside the component framework
    bind callback. However component framework has a big mutex lock taken for
    every call to component_add, component_del and bind, unbind callbacks.
    
    This can lead to deadlock situation if we are trying to add new/remove
    component within a bind/unbind callbacks. Which is what was happening
    with bcm2837 rpi 3.
    
    Revert this change till we sort out the mutex issue.
    
    Reported-by: Guillaume Tucker <guillaume.tucker@collabora.com>
    Reported-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 81b27923303d..82eb3868be67 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -279,28 +279,11 @@ static inline void snd_soc_debugfs_exit(void)
 
 #endif
 
-static int snd_soc_card_comp_compare(struct device *dev, void *data)
-{
-	struct snd_soc_component *component;
-
-	lockdep_assert_held(&client_mutex);
-	list_for_each_entry(component, &component_list, list) {
-		if (dev == component->dev) {
-			if (!strcmp(component->name, data))
-				return 1;
-			break;
-		}
-	}
-
-	return 0;
-}
-
 static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 			      struct snd_soc_component *component)
 {
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_rtdcom_list *new_rtdcom;
-	char *cname;
 
 	for_each_rtdcom(rtd, rtdcom) {
 		/* already connected */
@@ -317,13 +300,6 @@ static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 
 	list_add_tail(&new_rtdcom->list, &rtd->component_list);
 
-	if (rtd->card->auto_bind && !rtd->card->components_added) {
-		cname = devm_kasprintf(rtd->card->dev, GFP_KERNEL,
-				       "%s", component->name);
-		component_match_add(rtd->card->dev, &rtd->card->match,
-				    snd_soc_card_comp_compare, cname);
-	}
-
 	return 0;
 }
 
@@ -859,25 +835,6 @@ static bool soc_is_dai_link_bound(struct snd_soc_card *card,
 	return false;
 }
 
-static int snd_soc_card_comp_bind(struct device *dev)
-{
-	struct snd_soc_card *card = dev_get_drvdata(dev);
-
-	if (card->instantiated)
-		return 0;
-
-	return snd_soc_register_card(card);
-}
-
-static void snd_soc_card_comp_unbind(struct device *dev)
-{
-}
-
-static const struct component_master_ops snd_soc_card_comp_ops = {
-	.bind = snd_soc_card_comp_bind,
-	.unbind = snd_soc_card_comp_unbind,
-};
-
 static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link)
 {
@@ -2169,12 +2126,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	card->instantiated = 1;
 	snd_soc_dapm_sync(&card->dapm);
-	if (card->auto_bind && !card->components_added) {
-		component_master_add_with_match(card->dev,
-						&snd_soc_card_comp_ops,
-						card->match);
-		card->components_added = true;
-	}
 	mutex_unlock(&card->mutex);
 	mutex_unlock(&client_mutex);
 
@@ -2820,9 +2771,6 @@ int snd_soc_unregister_card(struct snd_soc_card *card)
 		dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 	}
 
-	if (!card->auto_bind && card->components_added)
-		component_master_del(card->dev, &snd_soc_card_comp_ops);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_card);
@@ -3235,17 +3183,8 @@ int snd_soc_add_component(struct device *dev,
 
 	snd_soc_component_add(component);
 
-	ret = component_add(dev, NULL);
-	if (ret < 0) {
-		dev_err(dev, "ASoC: Failed to add Component: %d\n", ret);
-		goto err_comp;
-	}
-
 	return 0;
 
-err_comp:
-	soc_remove_component(component);
-	snd_soc_unregister_dais(component);
 err_cleanup:
 	snd_soc_component_cleanup(component);
 err_free:
@@ -3293,7 +3232,6 @@ static int __snd_soc_unregister_component(struct device *dev)
 	mutex_unlock(&client_mutex);
 
 	if (found) {
-		component_del(dev, NULL);
 		snd_soc_component_cleanup(component);
 	}
 

commit 467b061f1ac80f323bedb56d20a24f7bc0d2cec5
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Mon Jul 23 16:54:03 2018 +0100

    ASoC: core: add support to snd_soc_dai_get_channel_map()
    
    On Qualcomm platforms, specifically with SLIMbus interfaced codecs,
    the codec slim channel numbers are passed to DSP while configuring
    the slim audio path. Having get_channel_map() would allow dais to
    share such information across multiple dais.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ad5b0ef16d82..81b27923303d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2679,6 +2679,28 @@ int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);
 
+/**
+ * snd_soc_dai_get_channel_map - Get DAI audio channel map
+ * @dai: DAI
+ * @tx_num: how many TX channels
+ * @tx_slot: pointer to an array which imply the TX slot number channel
+ *           0~num-1 uses
+ * @rx_num: how many RX channels
+ * @rx_slot: pointer to an array which imply the RX slot number channel
+ *           0~num-1 uses
+ */
+int snd_soc_dai_get_channel_map(struct snd_soc_dai *dai,
+	unsigned int *tx_num, unsigned int *tx_slot,
+	unsigned int *rx_num, unsigned int *rx_slot)
+{
+	if (dai->driver->ops->get_channel_map)
+		return dai->driver->ops->get_channel_map(dai, tx_num, tx_slot,
+			rx_num, rx_slot);
+	else
+		return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_get_channel_map);
+
 /**
  * snd_soc_dai_set_tristate - configure DAI system or master clock.
  * @dai: DAI

commit cbdfab3b675f4c34258b0ec9e4707de44e1f6989
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Tue Jul 17 17:43:02 2018 +0200

    ASoC: export snd_soc_of_get_slot_mask
    
    Amlogic's axg card driver can't use snd_soc_of_parse_tdm_slot()
    directly because it needs to handle 4 mask for each direction.
    Yet the parsing of each mask is the same, so export
    snd_soc_of_get_slot_mask() to reuse the the existing code.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 08e189485009..ad5b0ef16d82 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3428,9 +3428,9 @@ int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets);
 
-static int snd_soc_of_get_slot_mask(struct device_node *np,
-				    const char *prop_name,
-				    unsigned int *mask)
+int snd_soc_of_get_slot_mask(struct device_node *np,
+			     const char *prop_name,
+			     unsigned int *mask)
 {
 	u32 val;
 	const __be32 *of_slot_mask = of_get_property(np, prop_name, &val);
@@ -3445,6 +3445,7 @@ static int snd_soc_of_get_slot_mask(struct device_node *np,
 
 	return val;
 }
+EXPORT_SYMBOL_GPL(snd_soc_of_get_slot_mask);
 
 int snd_soc_of_parse_tdm_slot(struct device_node *np,
 			      unsigned int *tx_mask,

commit bb4b894addb09a069c072a0a032f644cc470d17f
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Fri Jul 13 16:36:28 2018 +0100

    ASoC: core: add support to card re-bind using component framework
    
    This patch aims at achieving dynamic behaviour of audio card when
    the dependent components disappear and reappear.
    
    With this patch the card is removed if any of the dependent component
    is removed and card is added back if the dependent component comes back.
    All this is done using component framework and matching based on
    component name.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Reviewed-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3be0310d5c81..08e189485009 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -279,11 +279,28 @@ static inline void snd_soc_debugfs_exit(void)
 
 #endif
 
+static int snd_soc_card_comp_compare(struct device *dev, void *data)
+{
+	struct snd_soc_component *component;
+
+	lockdep_assert_held(&client_mutex);
+	list_for_each_entry(component, &component_list, list) {
+		if (dev == component->dev) {
+			if (!strcmp(component->name, data))
+				return 1;
+			break;
+		}
+	}
+
+	return 0;
+}
+
 static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 			      struct snd_soc_component *component)
 {
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_soc_rtdcom_list *new_rtdcom;
+	char *cname;
 
 	for_each_rtdcom(rtd, rtdcom) {
 		/* already connected */
@@ -300,6 +317,13 @@ static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
 
 	list_add_tail(&new_rtdcom->list, &rtd->component_list);
 
+	if (rtd->card->auto_bind && !rtd->card->components_added) {
+		cname = devm_kasprintf(rtd->card->dev, GFP_KERNEL,
+				       "%s", component->name);
+		component_match_add(rtd->card->dev, &rtd->card->match,
+				    snd_soc_card_comp_compare, cname);
+	}
+
 	return 0;
 }
 
@@ -835,6 +859,25 @@ static bool soc_is_dai_link_bound(struct snd_soc_card *card,
 	return false;
 }
 
+static int snd_soc_card_comp_bind(struct device *dev)
+{
+	struct snd_soc_card *card = dev_get_drvdata(dev);
+
+	if (card->instantiated)
+		return 0;
+
+	return snd_soc_register_card(card);
+}
+
+static void snd_soc_card_comp_unbind(struct device *dev)
+{
+}
+
+static const struct component_master_ops snd_soc_card_comp_ops = {
+	.bind = snd_soc_card_comp_bind,
+	.unbind = snd_soc_card_comp_unbind,
+};
+
 static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link)
 {
@@ -2126,6 +2169,12 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	card->instantiated = 1;
 	snd_soc_dapm_sync(&card->dapm);
+	if (card->auto_bind && !card->components_added) {
+		component_master_add_with_match(card->dev,
+						&snd_soc_card_comp_ops,
+						card->match);
+		card->components_added = true;
+	}
 	mutex_unlock(&card->mutex);
 	mutex_unlock(&client_mutex);
 
@@ -2749,6 +2798,9 @@ int snd_soc_unregister_card(struct snd_soc_card *card)
 		dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 	}
 
+	if (!card->auto_bind && card->components_added)
+		component_master_del(card->dev, &snd_soc_card_comp_ops);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_card);
@@ -3161,8 +3213,17 @@ int snd_soc_add_component(struct device *dev,
 
 	snd_soc_component_add(component);
 
+	ret = component_add(dev, NULL);
+	if (ret < 0) {
+		dev_err(dev, "ASoC: Failed to add Component: %d\n", ret);
+		goto err_comp;
+	}
+
 	return 0;
 
+err_comp:
+	soc_remove_component(component);
+	snd_soc_unregister_dais(component);
 err_cleanup:
 	snd_soc_component_cleanup(component);
 err_free:
@@ -3210,6 +3271,7 @@ static int __snd_soc_unregister_component(struct device *dev)
 	mutex_unlock(&client_mutex);
 
 	if (found) {
+		component_del(dev, NULL);
 		snd_soc_component_cleanup(component);
 	}
 

commit aefba45539bc4868c1fae336410aec907ee0882a
Author: Jerome Brunet <jbrunet@baylibre.com>
Date:   Fri Jul 13 14:50:43 2018 +0200

    ASoC: allow soc-core to pick up name prefixes from component nodes
    
    When the component does not match the configuration table provided
    by the card, let soc-core check the component node for a name prefix
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 00bd58d167dd..3be0310d5c81 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1193,15 +1193,27 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
 
+static void soc_set_of_name_prefix(struct snd_soc_component *component)
+{
+	struct device_node *component_of_node = component->dev->of_node;
+	const char *str;
+	int ret;
+
+	if (!component_of_node && component->dev->parent)
+		component_of_node = component->dev->parent->of_node;
+
+	ret = of_property_read_string(component_of_node, "sound-name-prefix",
+				      &str);
+	if (!ret)
+		component->name_prefix = str;
+}
+
 static void soc_set_name_prefix(struct snd_soc_card *card,
 				struct snd_soc_component *component)
 {
 	int i;
 
-	if (card->codec_conf == NULL)
-		return;
-
-	for (i = 0; i < card->num_configs; i++) {
+	for (i = 0; i < card->num_configs && card->codec_conf; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
 		struct device_node *component_of_node = component->dev->of_node;
 
@@ -1213,8 +1225,14 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 		if (map->dev_name && strcmp(component->name, map->dev_name))
 			continue;
 		component->name_prefix = map->name_prefix;
-		break;
+		return;
 	}
+
+	/*
+	 * If there is no configuration table or no match in the table,
+	 * check if a prefix is provided in the node
+	 */
+	soc_set_of_name_prefix(component);
 }
 
 static int soc_probe_component(struct snd_soc_card *card,

commit a655de808cbde6c58b3298e704d786b53f59fb5d
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Mon Jul 2 16:59:54 2018 +0100

    ASoC: core: Allow topology to override machine driver FE DAI link config.
    
    Machine drivers statically define a number of DAI links that currently
    cannot be changed or removed by topology. This means PCMs and platform
    components cannot be changed by topology at runtime AND machine drivers
    are tightly coupled to topology.
    
    This patch allows topology to override the machine driver DAI link config
    in order to reuse machine drivers with different topologies and platform
    components. The patch supports :-
    
    1) create new FE PCMs with a topology defined PCM ID.
    2) destroy existing static FE PCMs
    3) change the platform component driver.
    4) assign any new HW params fixups.
    5) assign a new card name prefix to differentiate this topology to userspace.
    
    The patch requires no changes to the machine drivers, but does add some
    platform component flags that the platform component driver can assign
    before loading topologies.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 68b08781c832..00bd58d167dd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -847,6 +847,9 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	const char *platform_name;
 	int i;
 
+	if (dai_link->ignore)
+		return 0;
+
 	dev_dbg(card->dev, "ASoC: binding %s\n", dai_link->name);
 
 	if (soc_is_dai_link_bound(card, dai_link)) {
@@ -1456,7 +1459,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 {
 	struct snd_soc_dai_link *dai_link = rtd->dai_link;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	int i, ret;
+	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_component *component;
+	int i, ret, num;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
 			card->name, rtd->num, order);
@@ -1502,9 +1507,28 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 		soc_dpcm_debugfs_add(rtd);
 #endif
 
+	num = rtd->num;
+
+	/*
+	 * most drivers will register their PCMs using DAI link ordering but
+	 * topology based drivers can use the DAI link id field to set PCM
+	 * device number and then use rtd + a base offset of the BEs.
+	 */
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
+
+		if (!component->driver->use_dai_pcm_id)
+			continue;
+
+		if (rtd->dai_link->no_pcm)
+			num += component->driver->be_pcm_base;
+		else
+			num = rtd->dai_link->id;
+	}
+
 	if (cpu_dai->driver->compress_new) {
 		/*create compress_device"*/
-		ret = cpu_dai->driver->compress_new(rtd, rtd->num);
+		ret = cpu_dai->driver->compress_new(rtd, num);
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: can't create compress %s\n",
 					 dai_link->stream_name);
@@ -1514,7 +1538,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 
 		if (!dai_link->params) {
 			/* create the pcm */
-			ret = soc_new_pcm(rtd, rtd->num);
+			ret = soc_new_pcm(rtd, num);
 			if (ret < 0) {
 				dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
 				       dai_link->stream_name, ret);
@@ -1841,6 +1865,74 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 EXPORT_SYMBOL_GPL(snd_soc_set_dmi_name);
 #endif /* CONFIG_DMI */
 
+static void soc_check_tplg_fes(struct snd_soc_card *card)
+{
+	struct snd_soc_component *component;
+	const struct snd_soc_component_driver *comp_drv;
+	struct snd_soc_dai_link *dai_link;
+	int i;
+
+	list_for_each_entry(component, &component_list, list) {
+
+		/* does this component override FEs ? */
+		if (!component->driver->ignore_machine)
+			continue;
+
+		/* for this machine ? */
+		if (strcmp(component->driver->ignore_machine,
+			   card->dev->driver->name))
+			continue;
+
+		/* machine matches, so override the rtd data */
+		for (i = 0; i < card->num_links; i++) {
+
+			dai_link = &card->dai_link[i];
+
+			/* ignore this FE */
+			if (dai_link->dynamic) {
+				dai_link->ignore = true;
+				continue;
+			}
+
+			dev_info(card->dev, "info: override FE DAI link %s\n",
+				 card->dai_link[i].name);
+
+			/* override platform component */
+			dai_link->platform_name = component->name;
+
+			/* convert non BE into BE */
+			dai_link->no_pcm = 1;
+
+			/* override any BE fixups */
+			dai_link->be_hw_params_fixup =
+				component->driver->be_hw_params_fixup;
+
+			/* most BE links don't set stream name, so set it to
+			 * dai link name if it's NULL to help bind widgets.
+			 */
+			if (!dai_link->stream_name)
+				dai_link->stream_name = dai_link->name;
+		}
+
+		/* Inform userspace we are using alternate topology */
+		if (component->driver->topology_name_prefix) {
+
+			/* topology shortname created ? */
+			if (!card->topology_shortname_created) {
+				comp_drv = component->driver;
+
+				snprintf(card->topology_shortname, 32, "%s-%s",
+					 comp_drv->topology_name_prefix,
+					 card->name);
+				card->topology_shortname_created = true;
+			}
+
+			/* use topology shortname */
+			card->name = card->topology_shortname;
+		}
+	}
+}
+
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
@@ -1850,6 +1942,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	mutex_lock(&client_mutex);
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
+	/* check whether any platform is ignore machine FE and using topology */
+	soc_check_tplg_fes(card);
+
 	/* bind DAIs */
 	for (i = 0; i < card->num_links; i++) {
 		ret = soc_bind_dai_link(card, &card->dai_link[i]);

commit 873486ed4af3e11bfc20832dff7b124ba652bf77
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 2 06:24:18 2018 +0000

    ASoC: soc-core: convert to SPDX identifiers
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4663de3cf495..68b08781c832 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1,26 +1,21 @@
-/*
- * soc-core.c  --  ALSA SoC Audio Layer
- *
- * Copyright 2005 Wolfson Microelectronics PLC.
- * Copyright 2005 Openedhand Ltd.
- * Copyright (C) 2010 Slimlogic Ltd.
- * Copyright (C) 2010 Texas Instruments Inc.
- *
- * Author: Liam Girdwood <lrg@slimlogic.co.uk>
- *         with code, comments and ideas from :-
- *         Richard Purdie <richard@openedhand.com>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  TODO:
- *   o Add hw rules to enforce rates, etc.
- *   o More testing with other codecs/machines.
- *   o Add more codecs and platforms to ensure good API coverage.
- *   o Support TDM on PCM and I2S
- */
+// SPDX-License-Identifier: GPL-2.0+
+//
+// soc-core.c  --  ALSA SoC Audio Layer
+//
+// Copyright 2005 Wolfson Microelectronics PLC.
+// Copyright 2005 Openedhand Ltd.
+// Copyright (C) 2010 Slimlogic Ltd.
+// Copyright (C) 2010 Texas Instruments Inc.
+//
+// Author: Liam Girdwood <lrg@slimlogic.co.uk>
+//         with code, comments and ideas from :-
+//         Richard Purdie <richard@openedhand.com>
+//
+//  TODO:
+//   o Add hw rules to enforce rates, etc.
+//   o More testing with other codecs/machines.
+//   o Add more codecs and platforms to ensure good API coverage.
+//   o Support TDM on PCM and I2S
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 61542847cb3b..4663de3cf495 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3354,7 +3354,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		return -EINVAL;
 	}
 
-	routes = devm_kzalloc(card->dev, num_routes * sizeof(*routes),
+	routes = devm_kcalloc(card->dev, num_routes, sizeof(*routes),
 			      GFP_KERNEL);
 	if (!routes) {
 		dev_err(card->dev,
@@ -3678,8 +3678,8 @@ int snd_soc_of_get_dai_link_codecs(struct device *dev,
 			dev_err(dev, "Bad phandle in 'sound-dai'\n");
 		return num_codecs;
 	}
-	component = devm_kzalloc(dev,
-				 sizeof *component * num_codecs,
+	component = devm_kcalloc(dev,
+				 num_codecs, sizeof(*component),
 				 GFP_KERNEL);
 	if (!component)
 		return -ENOMEM;

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3d56f1fe5914..61542847cb3b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -373,8 +373,8 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	if (!rtd->dai_link->ops)
 		rtd->dai_link->ops = &null_snd_soc_ops;
 
-	rtd->codec_dais = kzalloc(sizeof(struct snd_soc_dai *) *
-					dai_link->num_codecs,
+	rtd->codec_dais = kcalloc(dai_link->num_codecs,
+					sizeof(struct snd_soc_dai *),
 					GFP_KERNEL);
 	if (!rtd->codec_dais) {
 		kfree(rtd);

commit 0e7b25c673ec916dee8d927fc8de5806d900cba8
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 8 03:23:01 2018 +0000

    ASoC: soc-core: remove legacy_dai_naming from snd_soc_register_dais()
    
    We can get legacy dai name flag from component driver.
    Thus, there is no need to have its parameter on snd_soc_register_dais().
    Let's remove unneeded parameter
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2d3abb3f1231..3d56f1fe5914 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2783,8 +2783,7 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
  *                     parent's name.
  */
 static int snd_soc_register_dais(struct snd_soc_component *component,
-	struct snd_soc_dai_driver *dai_drv, size_t count,
-	bool legacy_dai_naming)
+				 struct snd_soc_dai_driver *dai_drv, size_t count)
 {
 	struct device *dev = component->dev;
 	struct snd_soc_dai *dai;
@@ -2796,7 +2795,7 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 	for (i = 0; i < count; i++) {
 
 		dai = soc_add_dai(component, dai_drv + i,
-				count == 1 && legacy_dai_naming);
+				  count == 1 && !component->driver->non_legacy_dai_naming);
 		if (dai == NULL) {
 			ret = -ENOMEM;
 			goto err;
@@ -3046,8 +3045,7 @@ int snd_soc_add_component(struct device *dev,
 		}
 	}
 
-	ret = snd_soc_register_dais(component, dai_drv, num_dai,
-				    !component_driver->non_legacy_dai_naming);
+	ret = snd_soc_register_dais(component, dai_drv, num_dai);
 	if (ret < 0) {
 		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
 		goto err_cleanup;

commit 359c71eeacbdd93d7870035af9a830140798fc67
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 8 03:22:11 2018 +0000

    ASoC: soc-core: remove snd_soc_component_add_unlocked()
    
    There is no user to call snd_soc_component_add_unlocked() anymore.
    Let's merge snd_soc_component_add_unlocked() and
    snd_soc_component_add().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f22ef347eead..2d3abb3f1231 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2958,8 +2958,10 @@ EXPORT_SYMBOL_GPL(snd_soc_component_exit_regmap);
 
 #endif
 
-static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
+static void snd_soc_component_add(struct snd_soc_component *component)
 {
+	mutex_lock(&client_mutex);
+
 	if (!component->driver->write && !component->driver->read) {
 		if (!component->regmap)
 			component->regmap = dev_get_regmap(component->dev, NULL);
@@ -2969,12 +2971,7 @@ static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
 
 	list_add(&component->list, &component_list);
 	INIT_LIST_HEAD(&component->dobj_list);
-}
 
-static void snd_soc_component_add(struct snd_soc_component *component)
-{
-	mutex_lock(&client_mutex);
-	snd_soc_component_add_unlocked(component);
 	mutex_unlock(&client_mutex);
 }
 

commit db795f9b924eaf9c86ff6ba025d7ae2f3457ef05
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 8 03:21:00 2018 +0000

    ASoC: add component_list_show()
    
    commit ef050bece1b55 ("ASoC: Remove platform code now everything is
    componentised") removed platform code, then platform_list_show() was
    removed, too. But we want to keep it as component_list_show.
    This patch add it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a4cb141b8f38..f22ef347eead 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -190,6 +190,21 @@ static int dai_list_show(struct seq_file *m, void *v)
 }
 DEFINE_SHOW_ATTRIBUTE(dai_list);
 
+static int component_list_show(struct seq_file *m, void *v)
+{
+	struct snd_soc_component *component;
+
+	mutex_lock(&client_mutex);
+
+	list_for_each_entry(component, &component_list, list)
+		seq_printf(m, "%s\n", component->name);
+
+	mutex_unlock(&client_mutex);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(component_list);
+
 static void soc_init_card_debugfs(struct snd_soc_card *card)
 {
 	if (!snd_soc_debugfs_root)
@@ -228,6 +243,10 @@ static void snd_soc_debugfs_init(void)
 	if (!debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
 				 &dai_list_fops))
 		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
+
+	if (!debugfs_create_file("components", 0444, snd_soc_debugfs_root, NULL,
+				 &component_list_fops))
+		pr_warn("ASoC: Failed to create component list debugfs file\n");
 }
 
 static void snd_soc_debugfs_exit(void)

commit 999f7f5af8eb7766f68d925a22bf296011abc84c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 8 03:20:24 2018 +0000

    ASoC: remove Codec related code
    
    Now no one is using Codec related code.
    Let's remove all
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3b78868969d5..a4cb141b8f38 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -56,7 +56,6 @@ EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);
 #endif
 
 static DEFINE_MUTEX(client_mutex);
-static LIST_HEAD(codec_list);
 static LIST_HEAD(component_list);
 
 /*
@@ -174,21 +173,6 @@ static void soc_cleanup_component_debugfs(struct snd_soc_component *component)
 	debugfs_remove_recursive(component->debugfs_root);
 }
 
-static int codec_list_show(struct seq_file *m, void *v)
-{
-	struct snd_soc_codec *codec;
-
-	mutex_lock(&client_mutex);
-
-	list_for_each_entry(codec, &codec_list, list)
-		seq_printf(m, "%s\n", codec->component.name);
-
-	mutex_unlock(&client_mutex);
-
-	return 0;
-}
-DEFINE_SHOW_ATTRIBUTE(codec_list);
-
 static int dai_list_show(struct seq_file *m, void *v)
 {
 	struct snd_soc_component *component;
@@ -241,10 +225,6 @@ static void snd_soc_debugfs_init(void)
 		return;
 	}
 
-	if (!debugfs_create_file("codecs", 0444, snd_soc_debugfs_root, NULL,
-				 &codec_list_fops))
-		pr_warn("ASoC: Failed to create CODEC list debugfs file\n");
-
 	if (!debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
 				 &dai_list_fops))
 		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
@@ -536,8 +516,8 @@ int snd_soc_suspend(struct device *dev)
 				}
 
 			case SND_SOC_BIAS_OFF:
-				if (component->suspend)
-					component->suspend(component);
+				if (component->driver->suspend)
+					component->driver->suspend(component);
 				component->suspended = 1;
 				if (component->regmap)
 					regcache_mark_dirty(component->regmap);
@@ -608,8 +588,8 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	list_for_each_entry(component, &card->component_dev_list, card_list) {
 		if (component->suspended) {
-			if (component->resume)
-				component->resume(component);
+			if (component->driver->resume)
+				component->driver->resume(component);
 			component->suspended = 0;
 		}
 	}
@@ -892,7 +872,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 	/* Single codec links expect codec and codec_dai in runtime data */
 	rtd->codec_dai = codec_dais[0];
-	rtd->codec = rtd->codec_dai->codec;
 
 	/* if there's no platform we match on the empty platform */
 	platform_name = dai_link->platform_name;
@@ -931,8 +910,8 @@ static void soc_remove_component(struct snd_soc_component *component)
 
 	list_del(&component->card_list);
 
-	if (component->remove)
-		component->remove(component);
+	if (component->driver->remove)
+		component->driver->remove(component);
 
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 
@@ -1271,8 +1250,8 @@ static int soc_probe_component(struct snd_soc_card *card,
 		}
 	}
 
-	if (component->probe) {
-		ret = component->probe(component);
+	if (component->driver->probe) {
+		ret = component->driver->probe(component);
 		if (ret < 0) {
 			dev_err(component->dev,
 				"ASoC: failed to probe component %d\n", ret);
@@ -1663,8 +1642,7 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 
 	/* Flip the polarity for the "CPU" end of a CODEC<->CODEC link */
 	/* the component which has non_legacy_dai_naming is Codec */
-	if (cpu_dai->codec ||
-	    cpu_dai->component->driver->non_legacy_dai_naming) {
+	if (cpu_dai->component->driver->non_legacy_dai_naming) {
 		unsigned int inv_dai_fmt;
 
 		inv_dai_fmt = dai_fmt & ~SND_SOC_DAIFMT_MASTER_MASK;
@@ -2256,25 +2234,6 @@ int snd_soc_add_component_controls(struct snd_soc_component *component,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_component_controls);
 
-/**
- * snd_soc_add_codec_controls - add an array of controls to a codec.
- * Convenience function to add a list of controls. Many codecs were
- * duplicating this code.
- *
- * @codec: codec to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
- *
- * Return 0 for success, else error.
- */
-int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
-	const struct snd_kcontrol_new *controls, unsigned int num_controls)
-{
-	return snd_soc_add_component_controls(&codec->component, controls,
-		num_controls);
-}
-EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
-
 /**
  * snd_soc_add_card_controls - add an array of controls to a SoC card.
  * Convenience function to add a list of controls.
@@ -2335,27 +2294,6 @@ int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 
-/**
- * snd_soc_codec_set_sysclk - configure CODEC system or master clock.
- * @codec: CODEC
- * @clk_id: DAI specific clock ID
- * @source: Source for the clock
- * @freq: new clock frequency in Hz
- * @dir: new clock direction - input/output.
- *
- * Configures the CODEC master (MCLK) or system (SYSCLK) clocking.
- */
-int snd_soc_codec_set_sysclk(struct snd_soc_codec *codec, int clk_id,
-			     int source, unsigned int freq, int dir)
-{
-	if (codec->driver->set_sysclk)
-		return codec->driver->set_sysclk(codec, clk_id, source,
-						 freq, dir);
-	else
-		return -ENOTSUPP;
-}
-EXPORT_SYMBOL_GPL(snd_soc_codec_set_sysclk);
-
 /**
  * snd_soc_component_set_sysclk - configure COMPONENT system or master clock.
  * @component: COMPONENT
@@ -2369,11 +2307,6 @@ EXPORT_SYMBOL_GPL(snd_soc_codec_set_sysclk);
 int snd_soc_component_set_sysclk(struct snd_soc_component *component, int clk_id,
 			     int source, unsigned int freq, int dir)
 {
-	/* will be removed */
-	if (component->set_sysclk)
-		return component->set_sysclk(component, clk_id, source,
-					     freq, dir);
-
 	if (component->driver->set_sysclk)
 		return component->driver->set_sysclk(component, clk_id, source,
 						 freq, dir);
@@ -2424,27 +2357,6 @@ int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
 
-/*
- * snd_soc_codec_set_pll - configure codec PLL.
- * @codec: CODEC
- * @pll_id: DAI specific PLL ID
- * @source: DAI specific source for the PLL
- * @freq_in: PLL input clock frequency in Hz
- * @freq_out: requested PLL output clock frequency in Hz
- *
- * Configures and enables PLL to generate output clock based on input clock.
- */
-int snd_soc_codec_set_pll(struct snd_soc_codec *codec, int pll_id, int source,
-			  unsigned int freq_in, unsigned int freq_out)
-{
-	if (codec->driver->set_pll)
-		return codec->driver->set_pll(codec, pll_id, source,
-					      freq_in, freq_out);
-	else
-		return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_codec_set_pll);
-
 /*
  * snd_soc_component_set_pll - configure component PLL.
  * @component: COMPONENT
@@ -2459,11 +2371,6 @@ int snd_soc_component_set_pll(struct snd_soc_component *component, int pll_id,
 			      int source, unsigned int freq_in,
 			      unsigned int freq_out)
 {
-	/* will be removed */
-	if (component->set_pll)
-		return component->set_pll(component, pll_id, source,
-					      freq_in, freq_out);
-
 	if (component->driver->set_pll)
 		return component->driver->set_pll(component, pll_id, source,
 					      freq_in, freq_out);
@@ -2964,13 +2871,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 
 	component->dev = dev;
 	component->driver = driver;
-	component->probe = component->driver->probe;
-	component->remove = component->driver->remove;
-	component->suspend = component->driver->suspend;
-	component->resume = component->driver->resume;
-	component->set_sysclk = component->driver->set_sysclk;
-	component->set_pll = component->driver->set_pll;
-	component->set_jack = component->driver->set_jack;
 
 	dapm = snd_soc_component_get_dapm(component);
 	dapm->dev = dev;
@@ -3041,7 +2941,7 @@ EXPORT_SYMBOL_GPL(snd_soc_component_exit_regmap);
 
 static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
 {
-	if (!component->write && !component->read) {
+	if (!component->driver->write && !component->driver->read) {
 		if (!component->regmap)
 			component->regmap = dev_get_regmap(component->dev, NULL);
 		if (component->regmap)
@@ -3123,9 +3023,6 @@ int snd_soc_add_component(struct device *dev,
 	if (ret)
 		goto err_free;
 
-	component->ignore_pmdown_time = true;
-	component->registered_as_component = true;
-
 	if (component_driver->endianness) {
 		for (i = 0; i < num_dai; i++) {
 			convert_endianness_formats(&dai_drv[i].playback);
@@ -3180,8 +3077,7 @@ static int __snd_soc_unregister_component(struct device *dev)
 
 	mutex_lock(&client_mutex);
 	list_for_each_entry(component, &component_list, list) {
-		if (dev != component->dev ||
-		    !component->registered_as_component)
+		if (dev != component->dev)
 			continue;
 
 		snd_soc_tplg_component_remove(component, SND_SOC_TPLG_INDEX_ALL);
@@ -3230,211 +3126,6 @@ struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
 
-static int snd_soc_codec_drv_probe(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	return codec->driver->probe(codec);
-}
-
-static void snd_soc_codec_drv_remove(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	codec->driver->remove(codec);
-}
-
-static int snd_soc_codec_drv_suspend(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	return codec->driver->suspend(codec);
-}
-
-static int snd_soc_codec_drv_resume(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	return codec->driver->resume(codec);
-}
-
-static int snd_soc_codec_drv_write(struct snd_soc_component *component,
-	unsigned int reg, unsigned int val)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	return codec->driver->write(codec, reg, val);
-}
-
-static int snd_soc_codec_drv_read(struct snd_soc_component *component,
-	unsigned int reg, unsigned int *val)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	*val = codec->driver->read(codec, reg);
-
-	return 0;
-}
-
-static int snd_soc_codec_set_sysclk_(struct snd_soc_component *component,
-			  int clk_id, int source, unsigned int freq, int dir)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	return snd_soc_codec_set_sysclk(codec, clk_id, source, freq, dir);
-}
-
-static int snd_soc_codec_set_pll_(struct snd_soc_component *component,
-				  int pll_id, int source, unsigned int freq_in,
-				  unsigned int freq_out)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	return snd_soc_codec_set_pll(codec, pll_id, source, freq_in, freq_out);
-}
-
-static int snd_soc_codec_set_jack_(struct snd_soc_component *component,
-			       struct snd_soc_jack *jack, void *data)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	return snd_soc_codec_set_jack(codec, jack, data);
-}
-
-static int snd_soc_codec_set_bias_level(struct snd_soc_dapm_context *dapm,
-	enum snd_soc_bias_level level)
-{
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(dapm);
-
-	return codec->driver->set_bias_level(codec, level);
-}
-
-/**
- * snd_soc_register_codec - Register a codec with the ASoC core
- *
- * @dev: The parent device for this codec
- * @codec_drv: Codec driver
- * @dai_drv: The associated DAI driver
- * @num_dai: Number of DAIs
- */
-int snd_soc_register_codec(struct device *dev,
-			   const struct snd_soc_codec_driver *codec_drv,
-			   struct snd_soc_dai_driver *dai_drv,
-			   int num_dai)
-{
-	struct snd_soc_dapm_context *dapm;
-	struct snd_soc_codec *codec;
-	struct snd_soc_dai *dai;
-	int ret, i;
-
-	dev_dbg(dev, "codec register %s\n", dev_name(dev));
-
-	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
-	if (codec == NULL)
-		return -ENOMEM;
-
-	codec->component.codec = codec;
-
-	ret = snd_soc_component_initialize(&codec->component,
-			&codec_drv->component_driver, dev);
-	if (ret)
-		goto err_free;
-
-	if (codec_drv->probe)
-		codec->component.probe = snd_soc_codec_drv_probe;
-	if (codec_drv->remove)
-		codec->component.remove = snd_soc_codec_drv_remove;
-	if (codec_drv->suspend)
-		codec->component.suspend = snd_soc_codec_drv_suspend;
-	if (codec_drv->resume)
-		codec->component.resume = snd_soc_codec_drv_resume;
-	if (codec_drv->write)
-		codec->component.write = snd_soc_codec_drv_write;
-	if (codec_drv->read)
-		codec->component.read = snd_soc_codec_drv_read;
-	if (codec_drv->set_sysclk)
-		codec->component.set_sysclk = snd_soc_codec_set_sysclk_;
-	if (codec_drv->set_pll)
-		codec->component.set_pll = snd_soc_codec_set_pll_;
-	if (codec_drv->set_jack)
-		codec->component.set_jack = snd_soc_codec_set_jack_;
-	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
-
-	dapm = snd_soc_codec_get_dapm(codec);
-	dapm->idle_bias_off = codec_drv->idle_bias_off;
-	dapm->suspend_bias_off = codec_drv->suspend_bias_off;
-	if (codec_drv->seq_notifier)
-		dapm->seq_notifier = codec_drv->seq_notifier;
-	if (codec_drv->set_bias_level)
-		dapm->set_bias_level = snd_soc_codec_set_bias_level;
-	codec->dev = dev;
-	codec->driver = codec_drv;
-
-#ifdef CONFIG_DEBUG_FS
-	codec->component.debugfs_prefix = "codec";
-#endif
-
-	for (i = 0; i < num_dai; i++) {
-		convert_endianness_formats(&dai_drv[i].playback);
-		convert_endianness_formats(&dai_drv[i].capture);
-	}
-
-	ret = snd_soc_register_dais(&codec->component, dai_drv, num_dai, false);
-	if (ret < 0) {
-		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
-		goto err_cleanup;
-	}
-
-	list_for_each_entry(dai, &codec->component.dai_list, list)
-		dai->codec = codec;
-
-	mutex_lock(&client_mutex);
-	snd_soc_component_add_unlocked(&codec->component);
-	list_add(&codec->list, &codec_list);
-	mutex_unlock(&client_mutex);
-
-	dev_dbg(codec->dev, "ASoC: Registered codec '%s'\n",
-		codec->component.name);
-	return 0;
-
-err_cleanup:
-	snd_soc_component_cleanup(&codec->component);
-err_free:
-	kfree(codec);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_register_codec);
-
-/**
- * snd_soc_unregister_codec - Unregister a codec from the ASoC core
- *
- * @dev: codec to unregister
- */
-void snd_soc_unregister_codec(struct device *dev)
-{
-	struct snd_soc_codec *codec;
-
-	mutex_lock(&client_mutex);
-	list_for_each_entry(codec, &codec_list, list) {
-		if (dev == codec->dev)
-			goto found;
-	}
-	mutex_unlock(&client_mutex);
-	return;
-
-found:
-	list_del(&codec->list);
-	snd_soc_component_del_unlocked(&codec->component);
-	mutex_unlock(&client_mutex);
-
-	dev_dbg(codec->dev, "ASoC: Unregistered codec '%s'\n",
-			codec->component.name);
-
-	snd_soc_component_cleanup(&codec->component);
-	kfree(codec);
-}
-EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
-
 /* Retrieve a card's name from device tree */
 int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 			       const char *propname)

commit 11fb14f8c5b8f016ea0dae2237854331071cad42
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 8 03:19:49 2018 +0000

    ASoC: remove unneeded .pcm_new/free
    
    commit ef050bece1b55 ("ASoC: Remove platform code now everything is
    componentised") removed platform code, but it didn't remove
    .pcm_new/free which existed only for platform.
    This patch remove these
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e5af15aa1c28..3b78868969d5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2943,22 +2943,6 @@ static int snd_soc_component_stream_event(struct snd_soc_dapm_context *dapm,
 	return component->driver->stream_event(component, event);
 }
 
-static int snd_soc_component_drv_pcm_new(struct snd_soc_component *component,
-					struct snd_soc_pcm_runtime *rtd)
-{
-	if (component->driver->pcm_new)
-		return component->driver->pcm_new(rtd);
-
-	return 0;
-}
-
-static void snd_soc_component_drv_pcm_free(struct snd_soc_component *component,
-					  struct snd_pcm *pcm)
-{
-	if (component->driver->pcm_free)
-		component->driver->pcm_free(pcm);
-}
-
 static int snd_soc_component_set_bias_level(struct snd_soc_dapm_context *dapm,
 					enum snd_soc_bias_level level)
 {
@@ -2987,8 +2971,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->set_sysclk = component->driver->set_sysclk;
 	component->set_pll = component->driver->set_pll;
 	component->set_jack = component->driver->set_jack;
-	component->pcm_new = snd_soc_component_drv_pcm_new;
-	component->pcm_free = snd_soc_component_drv_pcm_free;
 
 	dapm = snd_soc_component_get_dapm(component);
 	dapm->dev = dev;

commit 2250e76d78e82b1da0f6f571f7211dfa78cbd469
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 8 03:19:16 2018 +0000

    ASoC: remove .get_regmap
    
    To setup regmap, ALSA SoC has snd_soc_component_init_regmap() and
    .get_regmap. But these are duplicated feature.
    Now, no one is using .get_regmap, let's remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 96081160fd24..e5af15aa1c28 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3392,9 +3392,6 @@ int snd_soc_register_codec(struct device *dev,
 	codec->component.debugfs_prefix = "codec";
 #endif
 
-	if (codec_drv->get_regmap)
-		codec->component.regmap = codec_drv->get_regmap(dev);
-
 	for (i = 0; i < num_dai; i++) {
 		convert_endianness_formats(&dai_drv[i].playback);
 		convert_endianness_formats(&dai_drv[i].capture);

commit d1021c88526273644a711d481fd1117a67b6ae20
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue May 8 03:18:38 2018 +0000

    ASoC: remove codec reg_cache
    
    Codec reg_cache is legacy feature, almost all driver are now using
    common regmap, and very few driver had been used this legacy feature.
    Because of this background, it is now implemented on each
    driver internally now.
    So now, no one is using codec reg_cache. Let's remove it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4b068ccf4e13..96081160fd24 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -82,98 +82,6 @@ static const char * const dmi_blacklist[] = {
 	NULL,	/* terminator */
 };
 
-/* returns the minimum number of bytes needed to represent
- * a particular given value */
-static int min_bytes_needed(unsigned long val)
-{
-	int c = 0;
-	int i;
-
-	for (i = (sizeof val * 8) - 1; i >= 0; --i, ++c)
-		if (val & (1UL << i))
-			break;
-	c = (sizeof val * 8) - c;
-	if (!c || (c % 8))
-		c = (c + 8) / 8;
-	else
-		c /= 8;
-	return c;
-}
-
-/* fill buf which is 'len' bytes with a formatted
- * string of the form 'reg: value\n' */
-static int format_register_str(struct snd_soc_codec *codec,
-			       unsigned int reg, char *buf, size_t len)
-{
-	int wordsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
-	int regsize = codec->driver->reg_word_size * 2;
-	int ret;
-
-	/* +2 for ': ' and + 1 for '\n' */
-	if (wordsize + regsize + 2 + 1 != len)
-		return -EINVAL;
-
-	sprintf(buf, "%.*x: ", wordsize, reg);
-	buf += wordsize + 2;
-
-	ret = snd_soc_read(codec, reg);
-	if (ret < 0)
-		memset(buf, 'X', regsize);
-	else
-		sprintf(buf, "%.*x", regsize, ret);
-	buf[regsize] = '\n';
-	/* no NUL-termination needed */
-	return 0;
-}
-
-/* codec register dump */
-static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf,
-				  size_t count, loff_t pos)
-{
-	int i, step = 1;
-	int wordsize, regsize;
-	int len;
-	size_t total = 0;
-	loff_t p = 0;
-
-	wordsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
-	regsize = codec->driver->reg_word_size * 2;
-
-	len = wordsize + regsize + 2 + 1;
-
-	if (!codec->driver->reg_cache_size)
-		return 0;
-
-	if (codec->driver->reg_cache_step)
-		step = codec->driver->reg_cache_step;
-
-	for (i = 0; i < codec->driver->reg_cache_size; i += step) {
-		/* only support larger than PAGE_SIZE bytes debugfs
-		 * entries for the default case */
-		if (p >= pos) {
-			if (total + len >= count - 1)
-				break;
-			format_register_str(codec, i, buf + total, len);
-			total += len;
-		}
-		p += len;
-	}
-
-	total = min(total, count - 1);
-
-	return total;
-}
-
-static ssize_t codec_reg_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
-
-	return soc_codec_reg_show(rtd->codec, buf, PAGE_SIZE, 0);
-}
-
-static DEVICE_ATTR_RO(codec_reg);
-
 static ssize_t pmdown_time_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -199,7 +107,6 @@ static ssize_t pmdown_time_set(struct device *dev,
 static DEVICE_ATTR(pmdown_time, 0644, pmdown_time_show, pmdown_time_set);
 
 static struct attribute *soc_dev_attrs[] = {
-	&dev_attr_codec_reg.attr,
 	&dev_attr_pmdown_time.attr,
 	NULL
 };
@@ -232,71 +139,6 @@ static const struct attribute_group *soc_dev_attr_groups[] = {
 };
 
 #ifdef CONFIG_DEBUG_FS
-static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
-				   size_t count, loff_t *ppos)
-{
-	ssize_t ret;
-	struct snd_soc_codec *codec = file->private_data;
-	char *buf;
-
-	if (*ppos < 0 || !count)
-		return -EINVAL;
-
-	buf = kmalloc(count, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	ret = soc_codec_reg_show(codec, buf, count, *ppos);
-	if (ret >= 0) {
-		if (copy_to_user(user_buf, buf, ret)) {
-			kfree(buf);
-			return -EFAULT;
-		}
-		*ppos += ret;
-	}
-
-	kfree(buf);
-	return ret;
-}
-
-static ssize_t codec_reg_write_file(struct file *file,
-		const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	char buf[32];
-	size_t buf_size;
-	char *start = buf;
-	unsigned long reg, value;
-	struct snd_soc_codec *codec = file->private_data;
-	int ret;
-
-	buf_size = min(count, (sizeof(buf)-1));
-	if (copy_from_user(buf, user_buf, buf_size))
-		return -EFAULT;
-	buf[buf_size] = 0;
-
-	while (*start == ' ')
-		start++;
-	reg = simple_strtoul(start, &start, 16);
-	while (*start == ' ')
-		start++;
-	ret = kstrtoul(start, 16, &value);
-	if (ret)
-		return ret;
-
-	/* Userspace has been fiddling around behind the kernel's back */
-	add_taint(TAINT_USER, LOCKDEP_NOW_UNRELIABLE);
-
-	snd_soc_write(codec, reg, value);
-	return buf_size;
-}
-
-static const struct file_operations codec_reg_fops = {
-	.open = simple_open,
-	.read = codec_reg_read_file,
-	.write = codec_reg_write_file,
-	.llseek = default_llseek,
-};
-
 static void soc_init_component_debugfs(struct snd_soc_component *component)
 {
 	if (!component->card->debugfs_card_root)
@@ -325,9 +167,6 @@ static void soc_init_component_debugfs(struct snd_soc_component *component)
 
 	snd_soc_dapm_debugfs_init(snd_soc_component_get_dapm(component),
 		component->debugfs_root);
-
-	if (component->init_debugfs)
-		component->init_debugfs(component);
 }
 
 static void soc_cleanup_component_debugfs(struct snd_soc_component *component)
@@ -335,19 +174,6 @@ static void soc_cleanup_component_debugfs(struct snd_soc_component *component)
 	debugfs_remove_recursive(component->debugfs_root);
 }
 
-static void soc_init_codec_debugfs(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-	struct dentry *debugfs_reg;
-
-	debugfs_reg = debugfs_create_file("codec_reg", 0644,
-					  codec->component.debugfs_root,
-					  codec, &codec_reg_fops);
-	if (!debugfs_reg)
-		dev_warn(codec->dev,
-			"ASoC: Failed to create codec register debugfs file\n");
-}
-
 static int codec_list_show(struct seq_file *m, void *v)
 {
 	struct snd_soc_codec *codec;
@@ -431,8 +257,6 @@ static void snd_soc_debugfs_exit(void)
 
 #else
 
-#define soc_init_codec_debugfs NULL
-
 static inline void soc_init_component_debugfs(
 	struct snd_soc_component *component)
 {
@@ -1805,24 +1629,6 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 	}
 }
 
-static int snd_soc_init_codec_cache(struct snd_soc_codec *codec)
-{
-	int ret;
-
-	if (codec->cache_init)
-		return 0;
-
-	ret = snd_soc_cache_init(codec);
-	if (ret < 0) {
-		dev_err(codec->dev,
-			"ASoC: Failed to set cache compression type: %d\n",
-			ret);
-		return ret;
-	}
-	codec->cache_init = 1;
-	return 0;
-}
-
 /**
  * snd_soc_runtime_set_dai_fmt() - Change DAI link format for a ASoC runtime
  * @rtd: The runtime for which the DAI link format should be changed
@@ -2045,7 +1851,6 @@ EXPORT_SYMBOL_GPL(snd_soc_set_dmi_name);
 
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
-	struct snd_soc_codec *codec;
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link *dai_link;
 	int ret, i, order;
@@ -2071,15 +1876,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_links; i++)
 		snd_soc_add_dai_link(card, card->dai_link+i);
 
-	/* initialize the register cache for each available codec */
-	list_for_each_entry(codec, &codec_list, list) {
-		if (codec->cache_init)
-			continue;
-		ret = snd_soc_init_codec_cache(codec);
-		if (ret < 0)
-			goto base_error;
-	}
-
 	/* card bind complete so register a sound card */
 	ret = snd_card_new(card->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
 			card->owner, 0, &card->snd_card);
@@ -3591,10 +3387,8 @@ int snd_soc_register_codec(struct device *dev,
 		dapm->set_bias_level = snd_soc_codec_set_bias_level;
 	codec->dev = dev;
 	codec->driver = codec_drv;
-	codec->component.val_bytes = codec_drv->reg_word_size;
 
 #ifdef CONFIG_DEBUG_FS
-	codec->component.init_debugfs = soc_init_codec_debugfs;
 	codec->component.debugfs_prefix = "codec";
 #endif
 
@@ -3658,7 +3452,6 @@ void snd_soc_unregister_codec(struct device *dev)
 			codec->component.name);
 
 	snd_soc_component_cleanup(&codec->component);
-	snd_soc_cache_exit(codec);
 	kfree(codec);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);

commit b24c539b4dc58f7d6283b8d06e240ac87d4966d7
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Fri Apr 27 13:54:36 2018 +0100

    ASoC: core: Allow codec_conf DT lookups to match parent of_node
    
    For devices implemented as a MFD it is common to only have a single node
    in devicetree representing the whole device. As such when looking up
    codec_conf mappings we should match against both the devices of_node and
    the devices parent's of_node, as is already done for DAIs and platform
    components.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 052089f16ea0..4b068ccf4e13 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1383,7 +1383,12 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 
 	for (i = 0; i < card->num_configs; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
-		if (map->of_node && component->dev->of_node != map->of_node)
+		struct device_node *component_of_node = component->dev->of_node;
+
+		if (!component_of_node && component->dev->parent)
+			component_of_node = component->dev->parent->of_node;
+
+		if (map->of_node && component_of_node != map->of_node)
 			continue;
 		if (map->dev_name && strcmp(component->name, map->dev_name))
 			continue;

commit ef050bece1b5564b2c7135ceadc0d5ffdcf152f7
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Tue Apr 24 16:39:02 2018 +0100

    ASoC: Remove platform code now everything is componentised
    
    As all drivers have been moved over to the new generic component
    code remove the now unused platform specific code.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bf7ca32ab31f..052089f16ea0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -56,7 +56,6 @@ EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);
 #endif
 
 static DEFINE_MUTEX(client_mutex);
-static LIST_HEAD(platform_list);
 static LIST_HEAD(codec_list);
 static LIST_HEAD(component_list);
 
@@ -381,21 +380,6 @@ static int dai_list_show(struct seq_file *m, void *v)
 }
 DEFINE_SHOW_ATTRIBUTE(dai_list);
 
-static int platform_list_show(struct seq_file *m, void *v)
-{
-	struct snd_soc_platform *platform;
-
-	mutex_lock(&client_mutex);
-
-	list_for_each_entry(platform, &platform_list, list)
-		seq_printf(m, "%s\n", platform->component.name);
-
-	mutex_unlock(&client_mutex);
-
-	return 0;
-}
-DEFINE_SHOW_ATTRIBUTE(platform_list);
-
 static void soc_init_card_debugfs(struct snd_soc_card *card)
 {
 	if (!snd_soc_debugfs_root)
@@ -438,10 +422,6 @@ static void snd_soc_debugfs_init(void)
 	if (!debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
 				 &dai_list_fops))
 		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
-
-	if (!debugfs_create_file("platforms", 0444, snd_soc_debugfs_root, NULL,
-				 &platform_list_fops))
-		pr_warn("ASoC: Failed to create platform list debugfs file\n");
 }
 
 static void snd_soc_debugfs_exit(void)
@@ -1045,7 +1025,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_component *component;
 	struct snd_soc_dai **codec_dais;
-	struct snd_soc_platform *platform;
 	struct device_node *platform_of_node;
 	const char *platform_name;
 	int i;
@@ -1113,23 +1092,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 		snd_soc_rtdcom_add(rtd, component);
 	}
 
-	/* find one from the set of registered platforms */
-	list_for_each_entry(platform, &platform_list, list) {
-		platform_of_node = platform->dev->of_node;
-		if (!platform_of_node && platform->dev->parent->of_node)
-			platform_of_node = platform->dev->parent->of_node;
-
-		if (dai_link->platform_of_node) {
-			if (platform_of_node != dai_link->platform_of_node)
-				continue;
-		} else {
-			if (strcmp(platform->component.name, platform_name))
-				continue;
-		}
-
-		rtd->platform = platform;
-	}
-
 	soc_add_pcm_runtime(card, rtd);
 	return 0;
 
@@ -2512,24 +2474,6 @@ int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
 
-/**
- * snd_soc_add_platform_controls - add an array of controls to a platform.
- * Convenience function to add a list of controls.
- *
- * @platform: platform to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
- *
- * Return 0 for success, else error.
- */
-int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
-	const struct snd_kcontrol_new *controls, unsigned int num_controls)
-{
-	return snd_soc_add_component_controls(&platform->component, controls,
-		num_controls);
-}
-EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);
-
 /**
  * snd_soc_add_card_controls - add an array of controls to a SoC card.
  * Convenience function to add a list of controls.
@@ -3503,164 +3447,6 @@ struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
 
-static int snd_soc_platform_drv_probe(struct snd_soc_component *component)
-{
-	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
-
-	return platform->driver->probe(platform);
-}
-
-static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
-{
-	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
-
-	platform->driver->remove(platform);
-}
-
-static int snd_soc_platform_drv_pcm_new(struct snd_soc_component *component,
-					struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
-
-	if (platform->driver->pcm_new)
-		return platform->driver->pcm_new(rtd);
-
-	return 0;
-}
-
-static void snd_soc_platform_drv_pcm_free(struct snd_soc_component *component,
-					  struct snd_pcm *pcm)
-{
-	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
-
-	if (platform->driver->pcm_free)
-		platform->driver->pcm_free(pcm);
-}
-
-/**
- * snd_soc_add_platform - Add a platform to the ASoC core
- * @dev: The parent device for the platform
- * @platform: The platform to add
- * @platform_drv: The driver for the platform
- */
-int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
-		const struct snd_soc_platform_driver *platform_drv)
-{
-	int ret;
-
-	ret = snd_soc_component_initialize(&platform->component,
-			&platform_drv->component_driver, dev);
-	if (ret)
-		return ret;
-
-	platform->dev = dev;
-	platform->driver = platform_drv;
-
-	if (platform_drv->probe)
-		platform->component.probe = snd_soc_platform_drv_probe;
-	if (platform_drv->remove)
-		platform->component.remove = snd_soc_platform_drv_remove;
-	if (platform_drv->pcm_new)
-		platform->component.pcm_new = snd_soc_platform_drv_pcm_new;
-	if (platform_drv->pcm_free)
-		platform->component.pcm_free = snd_soc_platform_drv_pcm_free;
-
-#ifdef CONFIG_DEBUG_FS
-	platform->component.debugfs_prefix = "platform";
-#endif
-
-	mutex_lock(&client_mutex);
-	snd_soc_component_add_unlocked(&platform->component);
-	list_add(&platform->list, &platform_list);
-	mutex_unlock(&client_mutex);
-
-	dev_dbg(dev, "ASoC: Registered platform '%s'\n",
-		platform->component.name);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_add_platform);
-
-/**
- * snd_soc_register_platform - Register a platform with the ASoC core
- *
- * @dev: The device for the platform
- * @platform_drv: The driver for the platform
- */
-int snd_soc_register_platform(struct device *dev,
-		const struct snd_soc_platform_driver *platform_drv)
-{
-	struct snd_soc_platform *platform;
-	int ret;
-
-	dev_dbg(dev, "ASoC: platform register %s\n", dev_name(dev));
-
-	platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);
-	if (platform == NULL)
-		return -ENOMEM;
-
-	ret = snd_soc_add_platform(dev, platform, platform_drv);
-	if (ret)
-		kfree(platform);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_register_platform);
-
-/**
- * snd_soc_remove_platform - Remove a platform from the ASoC core
- * @platform: the platform to remove
- */
-void snd_soc_remove_platform(struct snd_soc_platform *platform)
-{
-
-	mutex_lock(&client_mutex);
-	list_del(&platform->list);
-	snd_soc_component_del_unlocked(&platform->component);
-	mutex_unlock(&client_mutex);
-
-	dev_dbg(platform->dev, "ASoC: Unregistered platform '%s'\n",
-		platform->component.name);
-
-	snd_soc_component_cleanup(&platform->component);
-}
-EXPORT_SYMBOL_GPL(snd_soc_remove_platform);
-
-struct snd_soc_platform *snd_soc_lookup_platform(struct device *dev)
-{
-	struct snd_soc_platform *platform;
-
-	mutex_lock(&client_mutex);
-	list_for_each_entry(platform, &platform_list, list) {
-		if (dev == platform->dev) {
-			mutex_unlock(&client_mutex);
-			return platform;
-		}
-	}
-	mutex_unlock(&client_mutex);
-
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_lookup_platform);
-
-/**
- * snd_soc_unregister_platform - Unregister a platform from the ASoC core
- *
- * @dev: platform to unregister
- */
-void snd_soc_unregister_platform(struct device *dev)
-{
-	struct snd_soc_platform *platform;
-
-	platform = snd_soc_lookup_platform(dev);
-	if (!platform)
-		return;
-
-	snd_soc_remove_platform(platform);
-	kfree(platform);
-}
-EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);
-
 static int snd_soc_codec_drv_probe(struct snd_soc_component *component)
 {
 	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);

commit 291bfb928863d496e25c785e132a8fbfb32341a8
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Apr 19 12:14:10 2018 +0100

    ASoC: topology: Revert recent changes while boot errors are investigated
    
    Krzysztof Kozlowski reported a NULL dereference in _instantiate_card()
    on Odroid XU3 and XU boards which he bisected to 45f8cb57da0d7 (ASoC:
    core: Allow topology to override machine driver FE DAI link config).
    Revert that commit for now, along with f11a5c27f928 (ASoC: core: Add
    name prefix for machines with topology rewrites) due to dependency
    issues, in order to keep things booting cleanly in -next.
    
    Reported-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index aa1c33b3cce0..bf7ca32ab31f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1050,9 +1050,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	const char *platform_name;
 	int i;
 
-	if (dai_link->ignore)
-		return 0;
-
 	dev_dbg(card->dev, "ASoC: binding %s\n", dai_link->name);
 
 	if (soc_is_dai_link_bound(card, dai_link)) {
@@ -1675,7 +1672,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 {
 	struct snd_soc_dai_link *dai_link = rtd->dai_link;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	int i, ret, num;
+	int i, ret;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
 			card->name, rtd->num, order);
@@ -1721,23 +1718,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 		soc_dpcm_debugfs_add(rtd);
 #endif
 
-	/*
-	 * most drivers will register their PCMs using DAI link ordering but
-	 * topology based drivers can use the DAI link id field to set PCM
-	 * device number and then use rtd + a base offset of the BEs.
-	 */
-	if (rtd->platform->driver->use_dai_pcm_id) {
-		if (rtd->dai_link->no_pcm)
-			num = rtd->platform->driver->be_pcm_base + rtd->num;
-		else
-			num = rtd->dai_link->id;
-	} else {
-		num = rtd->num;
-	}
-
 	if (cpu_dai->driver->compress_new) {
 		/*create compress_device"*/
-		ret = cpu_dai->driver->compress_new(rtd, num);
+		ret = cpu_dai->driver->compress_new(rtd, rtd->num);
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: can't create compress %s\n",
 					 dai_link->stream_name);
@@ -1747,7 +1730,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 
 		if (!dai_link->params) {
 			/* create the pcm */
-			ret = soc_new_pcm(rtd, num);
+			ret = soc_new_pcm(rtd, rtd->num);
 			if (ret < 0) {
 				dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
 				       dai_link->stream_name, ret);
@@ -2093,67 +2076,6 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 EXPORT_SYMBOL_GPL(snd_soc_set_dmi_name);
 #endif /* CONFIG_DMI */
 
-static void soc_check_tplg_fes(struct snd_soc_card *card)
-{
-	struct snd_soc_platform *platform;
-	struct snd_soc_dai_link *dai_link;
-	int i;
-
-	list_for_each_entry(platform, &platform_list, list) {
-
-		/* does this platform override FEs ? */
-		if (!platform->driver->ignore_machine)
-			continue;
-
-		/* for this machine ? */
-		if (strcmp(platform->driver->ignore_machine,
-			   card->dev->driver->name))
-			continue;
-
-		/* machine matches, so override the rtd data */
-		for (i = 0; i < card->num_links; i++) {
-
-			dai_link = &card->dai_link[i];
-
-			/* ignore this FE */
-			if (dai_link->dynamic) {
-				dai_link->ignore = true;
-				continue;
-			}
-
-			dev_info(card->dev, "info: override FE DAI link %s\n",
-				 card->dai_link[i].name);
-
-			/* override platform */
-			dai_link->platform_name = platform->component.name;
-			dai_link->cpu_dai_name = platform->component.name;
-
-			/* convert non BE into BE */
-			dai_link->no_pcm = 1;
-			dai_link->dpcm_playback = 1;
-			dai_link->dpcm_capture = 1;
-
-			/* override any BE fixups */
-			dai_link->be_hw_params_fixup =
-				platform->driver->be_hw_params_fixup;
-
-			/* most BE links dont set stream name, so set it to
-			 * dai link name if it's NULL to help bind widgets.
-			 */
-			if (!dai_link->stream_name)
-				dai_link->stream_name = dai_link->name;
-		}
-
-		/* Inform userspace we are using alternate topology */
-		if (platform->driver->topology_name_prefix) {
-			snprintf(card->topology_shortname, 32, "%s-%s",
-				 platform->driver->topology_name_prefix,
-				 card->name);
-			card->name = card->topology_shortname;
-		}
-	}
-}
-
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_codec *codec;
@@ -2164,9 +2086,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	mutex_lock(&client_mutex);
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
-	/* check whether any platform is ignore machine FE and using topology */
-	soc_check_tplg_fes(card);
-
 	/* bind DAIs */
 	for (i = 0; i < card->num_links; i++) {
 		ret = soc_bind_dai_link(card, &card->dai_link[i]);

commit f11a5c27f9287cacad74af31cd92d4413eccc05a
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Tue Mar 27 14:30:41 2018 +0100

    ASoC: core: Add name prefix for machines with topology rewrites
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8f01fe8296ff..aa1c33b3cce0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2143,6 +2143,14 @@ static void soc_check_tplg_fes(struct snd_soc_card *card)
 			if (!dai_link->stream_name)
 				dai_link->stream_name = dai_link->name;
 		}
+
+		/* Inform userspace we are using alternate topology */
+		if (platform->driver->topology_name_prefix) {
+			snprintf(card->topology_shortname, 32, "%s-%s",
+				 platform->driver->topology_name_prefix,
+				 card->name);
+			card->name = card->topology_shortname;
+		}
 	}
 }
 

commit 45f8cb57da0d7a9ead4b39d7f5def333a5b0c08b
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Tue Mar 27 14:30:40 2018 +0100

    ASoC: core: Allow topology to override machine driver FE DAI link config.
    
    Machine drivers statically define a number of DAI links that currently
    cannot be changed or removed by topology. This means PCMs and platform
    components cannot be changed by topology at runtime AND machine drivers
    are tightly coupled to topology.
    
    This patch allows topology to override the machine driver DAI link config
    in order to reuse machine drivers with different topologies and platform
    components. The patch supports :-
    
    1) create new FE PCMs with a topology defined PCM ID.
    2) destroy existing static FE PCMs
    3) change the platform component driver.
    4) assign any new HW params fixups.
    
    The patch requires no changes to the machine drivers, but does add some
    platform component flags that the platform component driver can assign
    before loading topologies.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bf7ca32ab31f..8f01fe8296ff 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1050,6 +1050,9 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	const char *platform_name;
 	int i;
 
+	if (dai_link->ignore)
+		return 0;
+
 	dev_dbg(card->dev, "ASoC: binding %s\n", dai_link->name);
 
 	if (soc_is_dai_link_bound(card, dai_link)) {
@@ -1672,7 +1675,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 {
 	struct snd_soc_dai_link *dai_link = rtd->dai_link;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	int i, ret;
+	int i, ret, num;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
 			card->name, rtd->num, order);
@@ -1718,9 +1721,23 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 		soc_dpcm_debugfs_add(rtd);
 #endif
 
+	/*
+	 * most drivers will register their PCMs using DAI link ordering but
+	 * topology based drivers can use the DAI link id field to set PCM
+	 * device number and then use rtd + a base offset of the BEs.
+	 */
+	if (rtd->platform->driver->use_dai_pcm_id) {
+		if (rtd->dai_link->no_pcm)
+			num = rtd->platform->driver->be_pcm_base + rtd->num;
+		else
+			num = rtd->dai_link->id;
+	} else {
+		num = rtd->num;
+	}
+
 	if (cpu_dai->driver->compress_new) {
 		/*create compress_device"*/
-		ret = cpu_dai->driver->compress_new(rtd, rtd->num);
+		ret = cpu_dai->driver->compress_new(rtd, num);
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: can't create compress %s\n",
 					 dai_link->stream_name);
@@ -1730,7 +1747,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 
 		if (!dai_link->params) {
 			/* create the pcm */
-			ret = soc_new_pcm(rtd, rtd->num);
+			ret = soc_new_pcm(rtd, num);
 			if (ret < 0) {
 				dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
 				       dai_link->stream_name, ret);
@@ -2076,6 +2093,59 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 EXPORT_SYMBOL_GPL(snd_soc_set_dmi_name);
 #endif /* CONFIG_DMI */
 
+static void soc_check_tplg_fes(struct snd_soc_card *card)
+{
+	struct snd_soc_platform *platform;
+	struct snd_soc_dai_link *dai_link;
+	int i;
+
+	list_for_each_entry(platform, &platform_list, list) {
+
+		/* does this platform override FEs ? */
+		if (!platform->driver->ignore_machine)
+			continue;
+
+		/* for this machine ? */
+		if (strcmp(platform->driver->ignore_machine,
+			   card->dev->driver->name))
+			continue;
+
+		/* machine matches, so override the rtd data */
+		for (i = 0; i < card->num_links; i++) {
+
+			dai_link = &card->dai_link[i];
+
+			/* ignore this FE */
+			if (dai_link->dynamic) {
+				dai_link->ignore = true;
+				continue;
+			}
+
+			dev_info(card->dev, "info: override FE DAI link %s\n",
+				 card->dai_link[i].name);
+
+			/* override platform */
+			dai_link->platform_name = platform->component.name;
+			dai_link->cpu_dai_name = platform->component.name;
+
+			/* convert non BE into BE */
+			dai_link->no_pcm = 1;
+			dai_link->dpcm_playback = 1;
+			dai_link->dpcm_capture = 1;
+
+			/* override any BE fixups */
+			dai_link->be_hw_params_fixup =
+				platform->driver->be_hw_params_fixup;
+
+			/* most BE links dont set stream name, so set it to
+			 * dai link name if it's NULL to help bind widgets.
+			 */
+			if (!dai_link->stream_name)
+				dai_link->stream_name = dai_link->name;
+		}
+	}
+}
+
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_codec *codec;
@@ -2086,6 +2156,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	mutex_lock(&client_mutex);
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
+	/* check whether any platform is ignore machine FE and using topology */
+	soc_check_tplg_fes(card);
+
 	/* bind DAIs */
 	for (i = 0; i < card->num_links; i++) {
 		ret = soc_bind_dai_link(card, &card->dai_link[i]);

commit 848272e9a38e78bf0c746774a93ed2ab0a5b7f13
Merge: 36e82da9e5fe 4718840e76f7
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Mar 28 10:26:30 2018 +0800

    Merge remote-tracking branch 'asoc/topic/samsung' into asoc-next

commit 9914574db3a582f5ddce76896b48ffd4620072e0
Merge: dd4232c55fdf f7e73b26aea5
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Mar 28 10:26:06 2018 +0800

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 7ecbd6a91b1e9bb90a4f3be641669347aacc5ab5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 19 07:27:17 2018 +0000

    soc-core: don't call kfree() for component
    
    When driver register its component to ALSA SoC, almost all drivers are
    using snd_soc_register_component(), but soc-generic-dmaengine-pcm is
    using snd_soc_add_component().
    
    Existing component function had been assumed that registered component
    was allocated, and it calling kfree() for it.
    But, the user who used snd_soc_add_component() doesn't.
    
    This patch uses devm_kzalloc() instead of kzalloc() for component,
    and doesn't call kree() anymore.
    This patch fixes commit be7ee5f32a9a ("ASoC: soc-generic-dmaengine-pcm:
    replace platform to component").
    Allwinner H3 SoC will crash without this patch.
    Thanks Jernej report.
    
    Reported-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Jernej Skrabec <jernej.skrabec@siol.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9558125b448d..8b1ef90f7b57 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3454,7 +3454,6 @@ int snd_soc_add_component(struct device *dev,
 err_cleanup:
 	snd_soc_component_cleanup(component);
 err_free:
-	kfree(component);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_component);
@@ -3466,7 +3465,7 @@ int snd_soc_register_component(struct device *dev,
 {
 	struct snd_soc_component *component;
 
-	component = kzalloc(sizeof(*component), GFP_KERNEL);
+	component = devm_kzalloc(dev, sizeof(*component), GFP_KERNEL);
 	if (!component)
 		return -ENOMEM;
 
@@ -3501,7 +3500,6 @@ static int __snd_soc_unregister_component(struct device *dev)
 
 	if (found) {
 		snd_soc_component_cleanup(component);
-		kfree(component);
 	}
 
 	return found;

commit 3600cd78d7ac37114c87c7ba42f720dccbc4a5aa
Merge: d9e575127b41 946857636d27
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Mar 12 11:02:30 2018 -0700

    Merge branch 'topic/of' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-samsung

commit 946857636d279486eaa47c930930185631f28fce
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Fri Mar 9 18:48:54 2018 +0100

    ASoC: Add snd_soc_of_put_dai_link_codecs() helper function
    
    The code for dereferencing device nodes in the 'codecs' array is moved
    to a separate function so we can avoid open coding that in drivers.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 96c44f6576c9..a1f86e85bff9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4397,6 +4397,26 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_name);
 
+/*
+ * snd_soc_of_put_dai_link_codecs - Dereference device nodes in the codecs array
+ * @dai_link: DAI link
+ *
+ * Dereference device nodes acquired by snd_soc_of_get_dai_link_codecs().
+ */
+void snd_soc_of_put_dai_link_codecs(struct snd_soc_dai_link *dai_link)
+{
+	struct snd_soc_dai_link_component *component = dai_link->codecs;
+	int index;
+
+	for (index = 0; index < dai_link->num_codecs; index++, component++) {
+		if (!component->of_node)
+			break;
+		of_node_put(component->of_node);
+		component->of_node = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_put_dai_link_codecs);
+
 /*
  * snd_soc_of_get_dai_link_codecs - Parse a list of CODECs in the devicetree
  * @dev: Card device
@@ -4406,7 +4426,8 @@ EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_name);
  * Builds an array of CODEC DAI components from the DAI link property
  * 'sound-dai'.
  * The array is set in the DAI link and the number of DAIs is set accordingly.
- * The device nodes in the array (of_node) must be dereferenced by the caller.
+ * The device nodes in the array (of_node) must be dereferenced by calling
+ * snd_soc_of_put_dai_link_codecs() on @dai_link.
  *
  * Returns 0 for success
  */
@@ -4454,14 +4475,7 @@ int snd_soc_of_get_dai_link_codecs(struct device *dev,
 	}
 	return 0;
 err:
-	for (index = 0, component = dai_link->codecs;
-	     index < dai_link->num_codecs;
-	     index++, component++) {
-		if (!component->of_node)
-			break;
-		of_node_put(component->of_node);
-		component->of_node = NULL;
-	}
+	snd_soc_of_put_dai_link_codecs(dai_link);
 	dai_link->codecs = NULL;
 	dai_link->num_codecs = 0;
 	return ret;

commit f7e73b26aea58003931e2f3925d9c01f6b6c4c4d
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 9 12:46:27 2018 +0000

    ASoC: core: Fix typo roup->group
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e1f047de599e..4cd32f1bceb4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -221,14 +221,14 @@ static const struct attribute_group soc_dapm_dev_group = {
 	.is_visible = soc_dev_attr_is_visible,
 };
 
-static const struct attribute_group soc_dev_roup = {
+static const struct attribute_group soc_dev_group = {
 	.attrs = soc_dev_attrs,
 	.is_visible = soc_dev_attr_is_visible,
 };
 
 static const struct attribute_group *soc_dev_attr_groups[] = {
 	&soc_dapm_dev_group,
-	&soc_dev_roup,
+	&soc_dev_group,
 	NULL
 };
 

commit c15b2a1d185bcdab6556492b81b55ba9e658e201
Author: Peng Donglin <dolinux.peng@gmail.com>
Date:   Wed Feb 14 22:48:07 2018 +0800

    ASoC: use DEFINE_SHOW_ATTRIBUTE() to decrease code duplication
    
    There is some duplicate code in soc-core.c, and the kernel provides
    DEFINE_SHOW_ATTRIBUTE() helper macro to decrease it in seq_file.h.
    
    Signed-off-by: Peng Donglin <dolinux.peng@gmail.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 574048a73b1c..e1f047de599e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -349,7 +349,7 @@ static void soc_init_codec_debugfs(struct snd_soc_component *component)
 			"ASoC: Failed to create codec register debugfs file\n");
 }
 
-static int codec_list_seq_show(struct seq_file *m, void *v)
+static int codec_list_show(struct seq_file *m, void *v)
 {
 	struct snd_soc_codec *codec;
 
@@ -362,20 +362,9 @@ static int codec_list_seq_show(struct seq_file *m, void *v)
 
 	return 0;
 }
+DEFINE_SHOW_ATTRIBUTE(codec_list);
 
-static int codec_list_seq_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, codec_list_seq_show, NULL);
-}
-
-static const struct file_operations codec_list_fops = {
-	.open = codec_list_seq_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static int dai_list_seq_show(struct seq_file *m, void *v)
+static int dai_list_show(struct seq_file *m, void *v)
 {
 	struct snd_soc_component *component;
 	struct snd_soc_dai *dai;
@@ -390,20 +379,9 @@ static int dai_list_seq_show(struct seq_file *m, void *v)
 
 	return 0;
 }
+DEFINE_SHOW_ATTRIBUTE(dai_list);
 
-static int dai_list_seq_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, dai_list_seq_show, NULL);
-}
-
-static const struct file_operations dai_list_fops = {
-	.open = dai_list_seq_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static int platform_list_seq_show(struct seq_file *m, void *v)
+static int platform_list_show(struct seq_file *m, void *v)
 {
 	struct snd_soc_platform *platform;
 
@@ -416,18 +394,7 @@ static int platform_list_seq_show(struct seq_file *m, void *v)
 
 	return 0;
 }
-
-static int platform_list_seq_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, platform_list_seq_show, NULL);
-}
-
-static const struct file_operations platform_list_fops = {
-	.open = platform_list_seq_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(platform_list);
 
 static void soc_init_card_debugfs(struct snd_soc_card *card)
 {

commit 7a2ccad58106696b7909815cc7ab359ae2743bcc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Feb 14 02:58:03 2018 +0000

    ASoC: soc-core: soc_probe_dai() code simplification
    
    Current soc_probe_dai() is using deep nested condition.
    Thus, it is difficult to read/understand.
    This patch simplification it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 60a542f35dbd..574048a73b1c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1624,22 +1624,21 @@ static int soc_probe_link_components(struct snd_soc_card *card,
 
 static int soc_probe_dai(struct snd_soc_dai *dai, int order)
 {
-	int ret;
+	if (dai->probed ||
+	    dai->driver->probe_order != order)
+		return 0;
 
-	if (!dai->probed && dai->driver->probe_order == order) {
-		if (dai->driver->probe) {
-			ret = dai->driver->probe(dai);
-			if (ret < 0) {
-				dev_err(dai->dev,
-					"ASoC: failed to probe DAI %s: %d\n",
-					dai->name, ret);
-				return ret;
-			}
+	if (dai->driver->probe) {
+		int ret = dai->driver->probe(dai);
+		if (ret < 0) {
+			dev_err(dai->dev, "ASoC: failed to probe DAI %s: %d\n",
+				dai->name, ret);
+			return ret;
 		}
-
-		dai->probed = 1;
 	}
 
+	dai->probed = 1;
+
 	return 0;
 }
 

commit 6b49087912e311bc884d36874592595508630b88
Author: Martin Hundebøll <mnhu@prevas.dk>
Date:   Thu Feb 1 11:09:41 2018 +0100

    ASoC: soc-core: remove error due to probe deferral
    
    Deferred probes shouldn't cause error messages in the boot log, so
    change the dev_err() to the more harmless dev_info().
    
    Signed-off-by: Martin Hundebøll <mnhu@prevas.dk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 96c44f6576c9..60a542f35dbd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1100,8 +1100,8 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	cpu_dai_component.dai_name = dai_link->cpu_dai_name;
 	rtd->cpu_dai = snd_soc_find_dai(&cpu_dai_component);
 	if (!rtd->cpu_dai) {
-		dev_err(card->dev, "ASoC: CPU DAI %s not registered\n",
-			dai_link->cpu_dai_name);
+		dev_info(card->dev, "ASoC: CPU DAI %s not registered\n",
+			 dai_link->cpu_dai_name);
 		goto _err_defer;
 	}
 	snd_soc_rtdcom_add(rtd, rtd->cpu_dai->component);

commit bbf4d71aa9e21e8ee05e16cbb2cd2999252ce930
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 29 02:40:28 2018 +0000

    ASoC: remove rtd->platform checck
    
    Now, we are ready to replace rtd->platform to rtdcom list.
    From this patch, rtd->platform check is no longer needed.
    It will be replaced into rtdcom.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 96c44f6576c9..9558125b448d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1162,11 +1162,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 		rtd->platform = platform;
 	}
-	if (!rtd->platform) {
-		dev_err(card->dev, "ASoC: platform %s not registered\n",
-			dai_link->platform_name);
-		goto _err_defer;
-	}
 
 	soc_add_pcm_runtime(card, rtd);
 	return 0;

commit 7590e37bdaeec25ae325f4ba450be13e2aac6c8d
Merge: 7e6127c1240e 3d0a352a552e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 7 12:11:09 2018 -0800

    Merge tag 'asoc-v4.16-5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound
    
    Pull more ASoC updates from Mark Brown:
     "With the merge window having been delayed for another week here's
      another batch of updates that came in during that week.
    
      There's a few important fixes in here, mainly a fix for I/O on a
      number of devices caused by some of the component rework and a fix for
      a potential issue if more than one component in a link provides
      compressed operations. The I/O fixes are particularly important as the
      problem causes a power regression on a number of OMAP platforms"
    
    * tag 'asoc-v4.16-5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound: (22 commits)
      ASoC: stm32: add of dependency for stm32 drivers
      ASoC: mt8173-rt5650: fix child-node lookup
      ASoC: dapm: fix debugfs read using path->connected
      ASoC: compress: Fixup error messages
      ASoC: compress: Remove some extraneous blank lines
      ASoC: compress: Correct handling of copy callback
      ASoC: Intel: kbl: Enable mclk and ssp sclk early
      ASoC: Intel: Skylake: Add extended I2S config blob support in Clock driver
      ASoC: Intel: Skylake: Add ssp clock driver
      ASoC: Fix twl4030 and 6040 regression by adding back read and write
      ASoC: sun8i-codec: Add ADC support for a33
      ASoC: rockchip: Use dummy_dai for rt5514 dsp dailink
      ASoC: soc-pcm: rename .pmdown_time to .use_pmdown_time for Component
      ASoC: ak4613: call dummy write for PW_MGMT1/3 when Playback
      ASoC: soc-pcm: don't call flush_delayed_work() many times in soc_pcm_private_free()
      ASoC: soc-core: snd_soc_rtdcom_lookup() cares component driver name
      ASoC: sam9x5_wm8731: Drop 'ASoC' prefix from error messages
      ASoC: sam9g20_wm8731: use dev_*() logging functions
      ASoC: max98373 Changed SPDX header in C++ comments style
      ASoC: dmic: Fix check of return value from read of 'num-channels'
      ...

commit 535b218a7fc7f2918d54fe00e6d7ac385ced3502
Merge: 008a03c0cfac 03bbf9f5e4eb 971da24c48a9 35b84bf0614a f7f61e08fe58
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Feb 7 11:25:41 2018 +0000

    Merge remote-tracking branches 'asoc/topic/ak4613', 'asoc/topic/core', 'asoc/topic/dmic' and 'asoc/topic/intel' into asoc-next

commit 47fcc0360cfb3fe82e4daddacad3c1cd80b0b75d
Merge: 5d8515bc2321 c505cbd45f6e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 10:00:28 2018 -0800

    Merge tag 'driver-core-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the set of "big" driver core patches for 4.16-rc1.
    
      The majority of the work here is in the firmware subsystem, with
      reworks to try to attempt to make the code easier to handle in the
      long run, but no functional change. There's also some tree-wide sysfs
      attribute fixups with lots of acks from the various subsystem
      maintainers, as well as a handful of other normal fixes and changes.
    
      And finally, some license cleanups for the driver core and sysfs code.
    
      All have been in linux-next for a while with no reported issues"
    
    * tag 'driver-core-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (48 commits)
      device property: Define type of PROPERTY_ENRTY_*() macros
      device property: Reuse property_entry_free_data()
      device property: Move property_entry_free_data() upper
      firmware: Fix up docs referring to FIRMWARE_IN_KERNEL
      firmware: Drop FIRMWARE_IN_KERNEL Kconfig option
      USB: serial: keyspan: Drop firmware Kconfig options
      sysfs: remove DEBUG defines
      sysfs: use SPDX identifiers
      drivers: base: add coredump driver ops
      sysfs: add attribute specification for /sysfs/devices/.../coredump
      test_firmware: fix missing unlock on error in config_num_requests_store()
      test_firmware: make local symbol test_fw_config static
      sysfs: turn WARN() into pr_warn()
      firmware: Fix a typo in fallback-mechanisms.rst
      treewide: Use DEVICE_ATTR_WO
      treewide: Use DEVICE_ATTR_RO
      treewide: Use DEVICE_ATTR_RW
      sysfs.h: Use octal permissions
      component: add debugfs support
      bus: simple-pm-bus: convert bool SIMPLE_PM_BUS to tristate
      ...

commit 971da24c48a9447fb7a3c7805812fd5f443ca008
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jan 23 00:41:24 2018 +0000

    ASoC: soc-core: snd_soc_rtdcom_lookup() cares component driver name
    
    snd_soc_rtdcom_lookup() look up component by uisng driver name.
    Then, it uses component->driver->name.
    Some driver might doesn't have it, thus it should care NULL pointer.
    This patch solve this issue.
    
    Reported-by: Mukunda,Vijendar <vijendar.mukunda@amd.com>
    Reported-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Mukunda,Vijendar <vijendar.mukunda@amd.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9b79c2199781..52b2e04cc5e2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -590,9 +590,17 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 {
 	struct snd_soc_rtdcom_list *rtdcom;
 
+	if (!driver_name)
+		return NULL;
+
 	for_each_rtdcom(rtd, rtdcom) {
-		if ((rtdcom->component->driver->name == driver_name) ||
-		    strcmp(rtdcom->component->driver->name, driver_name) == 0)
+		const char *component_name = rtdcom->component->driver->name;
+
+		if (!component_name)
+			continue;
+
+		if ((component_name == driver_name) ||
+		    strcmp(component_name, driver_name) == 0)
 			return rtdcom->component;
 	}
 

commit 262db3bea59f5277722ae00d3a86c4230cf7af2b
Merge: 6ec2c85f676c d43c17daf277 700c17ca8968 df532185e872 8d6fb0bce202 8f1a1df58e01
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jan 18 11:55:53 2018 +0000

    Merge remote-tracking branches 'asoc/topic/davinci', 'asoc/topic/debugfs', 'asoc/topic/disconnect', 'asoc/topic/ep93xx' and 'asoc/topic/eukrea-tlv320' into asoc-next

commit 6ec2c85f676c2bf687f332c2bbc71f225e79b74f
Merge: b0714c5d98fa ba8dd49f9431 3c89724e994f 8080699a3649 392b79e20b41 4855f6a6283f
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jan 18 11:55:50 2018 +0000

    Merge remote-tracking branches 'asoc/topic/cs47l24', 'asoc/topic/cx20442', 'asoc/topic/da7213', 'asoc/topic/da7218' and 'asoc/topic/dai-drv' into asoc-next

commit 078b3a0205cba12302d40ce04a24c0edaa6842ce
Merge: 5f7a0ea9fe0e 2ca69d73bc05
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jan 18 11:55:37 2018 +0000

    Merge remote-tracking branch 'asoc/topic/rcar' into asoc-next

commit 700c17ca8968f473631594e8a7c2cc880ba2c891
Author: Donglin Peng <dolinux.peng@gmail.com>
Date:   Thu Jan 18 13:31:26 2018 +0800

    ASoC: use seq_file to dump the contents of dai_list,platform_list and codec_list
    
    Now the debugfs files dais/platforms/codecs have a size limit PAGE_SIZE and
    the user can not see the whole contents of dai_list/platform_list/codec_list
    when they are larger than this limit.
    
    This patch uses seq_file instead to make sure dais/platforms/codecs show the
    full contents of dai_list/platform_list/codec_list.
    
    Signed-off-by: Donglin Peng <dolinux.peng@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0edac80df34..7b582112e3fc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -349,120 +349,84 @@ static void soc_init_codec_debugfs(struct snd_soc_component *component)
 			"ASoC: Failed to create codec register debugfs file\n");
 }
 
-static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
-				    size_t count, loff_t *ppos)
+static int codec_list_seq_show(struct seq_file *m, void *v)
 {
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	ssize_t len, ret = 0;
 	struct snd_soc_codec *codec;
 
-	if (!buf)
-		return -ENOMEM;
-
 	mutex_lock(&client_mutex);
 
-	list_for_each_entry(codec, &codec_list, list) {
-		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
-			       codec->component.name);
-		if (len >= 0)
-			ret += len;
-		if (ret > PAGE_SIZE) {
-			ret = PAGE_SIZE;
-			break;
-		}
-	}
+	list_for_each_entry(codec, &codec_list, list)
+		seq_printf(m, "%s\n", codec->component.name);
 
 	mutex_unlock(&client_mutex);
 
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-
-	kfree(buf);
+	return 0;
+}
 
-	return ret;
+static int codec_list_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, codec_list_seq_show, NULL);
 }
 
 static const struct file_operations codec_list_fops = {
-	.read = codec_list_read_file,
-	.llseek = default_llseek,/* read accesses f_pos */
+	.open = codec_list_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
-static ssize_t dai_list_read_file(struct file *file, char __user *user_buf,
-				  size_t count, loff_t *ppos)
+static int dai_list_seq_show(struct seq_file *m, void *v)
 {
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	ssize_t len, ret = 0;
 	struct snd_soc_component *component;
 	struct snd_soc_dai *dai;
 
-	if (!buf)
-		return -ENOMEM;
-
 	mutex_lock(&client_mutex);
 
-	list_for_each_entry(component, &component_list, list) {
-		list_for_each_entry(dai, &component->dai_list, list) {
-			len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
-				dai->name);
-			if (len >= 0)
-				ret += len;
-			if (ret > PAGE_SIZE) {
-				ret = PAGE_SIZE;
-				break;
-			}
-		}
-	}
+	list_for_each_entry(component, &component_list, list)
+		list_for_each_entry(dai, &component->dai_list, list)
+			seq_printf(m, "%s\n", dai->name);
 
 	mutex_unlock(&client_mutex);
 
-	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-
-	kfree(buf);
+	return 0;
+}
 
-	return ret;
+static int dai_list_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dai_list_seq_show, NULL);
 }
 
 static const struct file_operations dai_list_fops = {
-	.read = dai_list_read_file,
-	.llseek = default_llseek,/* read accesses f_pos */
+	.open = dai_list_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
-static ssize_t platform_list_read_file(struct file *file,
-				       char __user *user_buf,
-				       size_t count, loff_t *ppos)
+static int platform_list_seq_show(struct seq_file *m, void *v)
 {
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	ssize_t len, ret = 0;
 	struct snd_soc_platform *platform;
 
-	if (!buf)
-		return -ENOMEM;
-
 	mutex_lock(&client_mutex);
 
-	list_for_each_entry(platform, &platform_list, list) {
-		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
-			       platform->component.name);
-		if (len >= 0)
-			ret += len;
-		if (ret > PAGE_SIZE) {
-			ret = PAGE_SIZE;
-			break;
-		}
-	}
+	list_for_each_entry(platform, &platform_list, list)
+		seq_printf(m, "%s\n", platform->component.name);
 
 	mutex_unlock(&client_mutex);
 
-	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-
-	kfree(buf);
+	return 0;
+}
 
-	return ret;
+static int platform_list_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, platform_list_seq_show, NULL);
 }
 
 static const struct file_operations platform_list_fops = {
-	.read = platform_list_read_file,
-	.llseek = default_llseek,/* read accesses f_pos */
+	.open = platform_list_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 
 static void soc_init_card_debugfs(struct snd_soc_card *card)
@@ -491,7 +455,6 @@ static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 	debugfs_remove_recursive(card->debugfs_card_root);
 }
 
-
 static void snd_soc_debugfs_init(void)
 {
 	snd_soc_debugfs_root = debugfs_create_dir("asoc", NULL);

commit 031734b7d6532633d0cde73475c30646bf37cd6d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 18 01:13:54 2018 +0000

    ASoC: soc-core: add missing EXPORT_SYMBOL_GPL() for snd_soc_rtdcom_lookup
    
    Reported-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b9ca939fd05c..9b79c2199781 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -598,6 +598,7 @@ struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
 
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(snd_soc_rtdcom_lookup);
 
 struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
 		const char *dai_link, int stream)

commit da7b34f80edfd7fe81ca6d13ab5493e559e01e8b
Merge: c966b3cc435c 392b79e20b41 4855f6a6283f d43c17daf277 df532185e872 8d6fb0bce202
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 12 12:29:05 2018 +0000

    Merge remote-tracking branches 'asoc/topic/da7218', 'asoc/topic/dai-drv', 'asoc/topic/davinci', 'asoc/topic/disconnect' and 'asoc/topic/ep93xx' into asoc-next

commit 84d306237bbe1af02ee782a54347752c75b97ca6
Merge: c5a216c3e22a 2ca69d73bc05
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 12 12:28:52 2018 +0000

    Merge remote-tracking branch 'asoc/topic/rcar' into asoc-next

commit c828a8920307185b7194b575731e8387c99a5a67
Author: Joe Perches <joe@perches.com>
Date:   Tue Dec 19 10:15:08 2017 -0800

    treewide: Use DEVICE_ATTR_RO
    
    Convert DEVICE_ATTR uses to DEVICE_ATTR_RO where possible.
    
    Done with perl script:
    
    $ git grep -w --name-only DEVICE_ATTR | \
      xargs perl -i -e 'local $/; while (<>) { s/\bDEVICE_ATTR\s*\(\s*(\w+)\s*,\s*\(?(?:\s*S_IRUGO\s*|\s*0444\s*)\)?\s*,\s*\1_show\s*,\s*NULL\s*\)/DEVICE_ATTR_RO(\1)/g; print;}'
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Sagi Grimberg <sagi@grimberg.me>
    Acked-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Corey Minyard <cminyard@mvista.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0edac80df34..11cfe42fe594 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -173,7 +173,7 @@ static ssize_t codec_reg_show(struct device *dev,
 	return soc_codec_reg_show(rtd->codec, buf, PAGE_SIZE, 0);
 }
 
-static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
+static DEVICE_ATTR_RO(codec_reg);
 
 static ssize_t pmdown_time_show(struct device *dev,
 				struct device_attribute *attr, char *buf)

commit 58bf4179000a37aa9b0ee9ab2796f7573c77fff0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Dec 20 01:48:29 2017 +0000

    ASoC: soc-core: remove dai_drv from snd_soc_component
    
    ALSA SoC has some duplicate parameter.
    snd_soc_component::dai_drv is one of them.
    
    Each DAI is keeping its driver as snd_soc_dai::driver,
    and component has dai_list.
    This means, we can reach to each DAI and its driver by using dai_link.
    Thus, there is no need to keep DAI driver pointer on component.
    Let's remove it
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0edac80df34..6a13fbcba23f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3149,7 +3149,7 @@ static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
 	if (!dai->driver->ops)
 		dai->driver->ops = &null_dai_ops;
 
-	list_add(&dai->list, &component->dai_list);
+	list_add_tail(&dai->list, &component->dai_list);
 	component->num_dai++;
 
 	dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
@@ -3176,8 +3176,6 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 
 	dev_dbg(dev, "ASoC: dai register %s #%zu\n", dev_name(dev), count);
 
-	component->dai_drv = dai_drv;
-
 	for (i = 0; i < count; i++) {
 
 		dai = soc_add_dai(component, dai_drv + i,
@@ -4354,6 +4352,7 @@ int snd_soc_get_dai_name(struct of_phandle_args *args,
 							     args,
 							     dai_name);
 		} else {
+			struct snd_soc_dai *dai;
 			int id = -1;
 
 			switch (args->args_count) {
@@ -4375,7 +4374,14 @@ int snd_soc_get_dai_name(struct of_phandle_args *args,
 
 			ret = 0;
 
-			*dai_name = pos->dai_drv[id].name;
+			/* find target DAI */
+			list_for_each_entry(dai, &pos->dai_list, list) {
+				if (id == 0)
+					break;
+				id--;
+			}
+
+			*dai_name = dai->driver->name;
 			if (!*dai_name)
 				*dai_name = pos->name;
 		}

commit cb2cf0de1174701b7c8c0285a0f398b9f2d30d8e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 15 05:10:47 2017 +0000

    ASoC: soc-core: care Codec <-> Codec case by non_legacy_dai_naming
    
    CPU/Codec categorize will be removed soon.
    Then, it need to know DAI is Codec somehow. This patch uses component
    driver's "non_legacy_dai_naming" which is used by Codec for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 90f1122d91c4..b9ca939fd05c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1945,7 +1945,9 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 	}
 
 	/* Flip the polarity for the "CPU" end of a CODEC<->CODEC link */
-	if (cpu_dai->codec) {
+	/* the component which has non_legacy_dai_naming is Codec */
+	if (cpu_dai->codec ||
+	    cpu_dai->component->driver->non_legacy_dai_naming) {
 		unsigned int inv_dai_fmt;
 
 		inv_dai_fmt = dai_fmt & ~SND_SOC_DAIFMT_MASTER_MASK;

commit 3b6eed8deb37c349bffc7b3b4d722ce4023f8b11
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 5 04:20:42 2017 +0000

    ASoC: don't use rtd->codec on soc_dev_attr_is_visible()
    
    rtd->codec will be removed soon.
    checking rtd->num_codecs is enough
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0edac80df34..90f1122d91c4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -213,7 +213,7 @@ static umode_t soc_dev_attr_is_visible(struct kobject *kobj,
 
 	if (attr == &dev_attr_pmdown_time.attr)
 		return attr->mode; /* always visible */
-	return rtd->codec ? attr->mode : 0; /* enabled only with codec */
+	return rtd->num_codecs ? attr->mode : 0; /* enabled only with codec */
 }
 
 static const struct attribute_group soc_dapm_dev_group = {

commit df532185e8720baff120f55eb46058d270445d56
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 29 02:38:27 2017 +0000

    ASoC: soc-core: add missing EXPORT_SYMBOL_GPL() for snd_soc_disconnect_sync
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9047046c749c..345baa4f10c0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1401,6 +1401,7 @@ void snd_soc_disconnect_sync(struct device *dev)
 
 	snd_card_disconnect_sync(component->card->snd_card);
 }
+EXPORT_SYMBOL_GPL(snd_soc_disconnect_sync);
 
 /**
  * snd_soc_add_dai_link - Add a DAI link dynamically

commit ef2e8175eb19011f756469d4d14f4207bf7f289c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 28 06:27:09 2017 +0000

    ASoC: add snd_soc_disconnect_sync()
    
    Now, we have snd_card_disconnect_sync() on ALSA framework.
    snd_soc_disconnect_sync() is ASoC version of it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0edac80df34..9047046c749c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1392,6 +1392,16 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	return 0;
 }
 
+void snd_soc_disconnect_sync(struct device *dev)
+{
+	struct snd_soc_component *component = snd_soc_lookup_component(dev, NULL);
+
+	if (!component || !component->card)
+		return;
+
+	snd_card_disconnect_sync(component->card->snd_card);
+}
+
 /**
  * snd_soc_add_dai_link - Add a DAI link dynamically
  * @card: The ASoC card to which the DAI link is added

commit 67e85d4e4e2eaf9614cf4db981be704890eb2869
Merge: f2470d529138 4c75968a1bbf e0d746cc0155 0c8b794c4a10 bb19ba2a3454
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Nov 10 21:31:10 2017 +0000

    Merge remote-tracking branches 'asoc/topic/cygnus', 'asoc/topic/da7213', 'asoc/topic/davinci' and 'asoc/topic/doc' into asoc-next

commit bb19ba2a345439b4de3f6d59819da9853500ac4d
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Oct 29 17:10:34 2017 -0700

    ASoC: fix build warning in soc-core.c
    
    Fix kernel-doc build error. A symbol that ends with an underscore
    character ('_') has special meaning in reST (reStructuredText), so add
    a '*' to prevent this error and to indicate that there are several of
    these values to choose from.
    
    ../sound/soc/soc-core.c:2799: ERROR: Unknown target name: "snd_soc_daifmt".
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fee4b0ef5566..3ef6989552c9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2796,7 +2796,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
 /**
  * snd_soc_dai_set_fmt - configure DAI hardware audio format.
  * @dai: DAI
- * @fmt: SND_SOC_DAIFMT_ format value.
+ * @fmt: SND_SOC_DAIFMT_* format value.
  *
  * Configures the DAI hardware format and clocking.
  */

commit 69941bab7c7aeaa7bf7e84397e294c17f0b7c6df
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 11 01:38:51 2017 +0000

    ASoC: snd_soc_component_driver has non_legacy_dai_naming
    
    Codec will be replaced into Component, then Codec side
    doesn't use legacy_dai_naming on snd_soc_register_dais().
    
    This patch adds new non_legacy_dai_naming flag on Component driver
    and use converted its value for snd_soc_register_dais().
    
    When Codec is replaced into Component, Codec driver needs
    to have non_legacy_dai_naming = 1 flags.
    Existing CPU side of course doesn't have this flag, thus CPU calls
    it as true.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 61c3d3649914..533c822ca6e6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3462,7 +3462,8 @@ int snd_soc_add_component(struct device *dev,
 		}
 	}
 
-	ret = snd_soc_register_dais(component, dai_drv, num_dai, true);
+	ret = snd_soc_register_dais(component, dai_drv, num_dai,
+				    !component_driver->non_legacy_dai_naming);
 	if (ret < 0) {
 		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
 		goto err_cleanup;

commit 273d778ef38a8861f880e9df5799029dc82bd55d
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 11 01:38:29 2017 +0000

    ASoC: snd_soc_component_driver has endianness
    
    Codec will be replaced into Component, then Codec side only
    needs to call fixup_codec_formats() at this point.
    
    This patch adds new endianness flag on Component driver
    and call convert_endianness_formats() (= was fixup_codec_format())
    if endianness was true.
    
    When Codec is replaced into Component, Codec driver needs
    to have endianness = 1 flags.
    Existing CPU side of course doesn't have this flag, thus CPU doesn't
    call it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a3dcf14befd8..61c3d3649914 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3404,6 +3404,41 @@ static void snd_soc_component_del_unlocked(struct snd_soc_component *component)
 	list_del(&component->list);
 }
 
+#define ENDIANNESS_MAP(name) \
+	(SNDRV_PCM_FMTBIT_##name##LE | SNDRV_PCM_FMTBIT_##name##BE)
+static u64 endianness_format_map[] = {
+	ENDIANNESS_MAP(S16_),
+	ENDIANNESS_MAP(U16_),
+	ENDIANNESS_MAP(S24_),
+	ENDIANNESS_MAP(U24_),
+	ENDIANNESS_MAP(S32_),
+	ENDIANNESS_MAP(U32_),
+	ENDIANNESS_MAP(S24_3),
+	ENDIANNESS_MAP(U24_3),
+	ENDIANNESS_MAP(S20_3),
+	ENDIANNESS_MAP(U20_3),
+	ENDIANNESS_MAP(S18_3),
+	ENDIANNESS_MAP(U18_3),
+	ENDIANNESS_MAP(FLOAT_),
+	ENDIANNESS_MAP(FLOAT64_),
+	ENDIANNESS_MAP(IEC958_SUBFRAME_),
+};
+
+/*
+ * Fix up the DAI formats for endianness: codecs don't actually see
+ * the endianness of the data but we're using the CPU format
+ * definitions which do need to include endianness so we ensure that
+ * codec DAIs always have both big and little endian variants set.
+ */
+static void convert_endianness_formats(struct snd_soc_pcm_stream *stream)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(endianness_format_map); i++)
+		if (stream->formats & endianness_format_map[i])
+			stream->formats |= endianness_format_map[i];
+}
+
 int snd_soc_add_component(struct device *dev,
 			struct snd_soc_component *component,
 			const struct snd_soc_component_driver *component_driver,
@@ -3411,6 +3446,7 @@ int snd_soc_add_component(struct device *dev,
 			int num_dai)
 {
 	int ret;
+	int i;
 
 	ret = snd_soc_component_initialize(component, component_driver, dev);
 	if (ret)
@@ -3419,6 +3455,13 @@ int snd_soc_add_component(struct device *dev,
 	component->ignore_pmdown_time = true;
 	component->registered_as_component = true;
 
+	if (component_driver->endianness) {
+		for (i = 0; i < num_dai; i++) {
+			convert_endianness_formats(&dai_drv[i].playback);
+			convert_endianness_formats(&dai_drv[i].capture);
+		}
+	}
+
 	ret = snd_soc_register_dais(component, dai_drv, num_dai, true);
 	if (ret < 0) {
 		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
@@ -3675,39 +3718,6 @@ void snd_soc_unregister_platform(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);
 
-static u64 codec_format_map[] = {
-	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE,
-	SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_U16_BE,
-	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE,
-	SNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_U24_BE,
-	SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_BE,
-	SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_U32_BE,
-	SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_U24_3BE,
-	SNDRV_PCM_FMTBIT_U24_3LE | SNDRV_PCM_FMTBIT_U24_3BE,
-	SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE,
-	SNDRV_PCM_FMTBIT_U20_3LE | SNDRV_PCM_FMTBIT_U20_3BE,
-	SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S18_3BE,
-	SNDRV_PCM_FMTBIT_U18_3LE | SNDRV_PCM_FMTBIT_U18_3BE,
-	SNDRV_PCM_FMTBIT_FLOAT_LE | SNDRV_PCM_FMTBIT_FLOAT_BE,
-	SNDRV_PCM_FMTBIT_FLOAT64_LE | SNDRV_PCM_FMTBIT_FLOAT64_BE,
-	SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE
-	| SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE,
-};
-
-/* Fix up the DAI formats for endianness: codecs don't actually see
- * the endianness of the data but we're using the CPU format
- * definitions which do need to include endianness so we ensure that
- * codec DAIs always have both big and little endian variants set.
- */
-static void fixup_codec_formats(struct snd_soc_pcm_stream *stream)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(codec_format_map); i++)
-		if (stream->formats & codec_format_map[i])
-			stream->formats |= codec_format_map[i];
-}
-
 static int snd_soc_codec_drv_probe(struct snd_soc_component *component)
 {
 	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
@@ -3858,8 +3868,8 @@ int snd_soc_register_codec(struct device *dev,
 		codec->component.regmap = codec_drv->get_regmap(dev);
 
 	for (i = 0; i < num_dai; i++) {
-		fixup_codec_formats(&dai_drv[i].playback);
-		fixup_codec_formats(&dai_drv[i].capture);
+		convert_endianness_formats(&dai_drv[i].playback);
+		convert_endianness_formats(&dai_drv[i].capture);
 	}
 
 	ret = snd_soc_register_dais(&codec->component, dai_drv, num_dai, false);

commit 08e61d03b08c99f611227c6e94c70cf0029fdeb6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 2 05:10:33 2017 +0000

    ASoC: soc-core: remove unnecessary message from snd_soc_register_component()
    
    No need to print an error message if kzalloc fails.
    The core will print it.
    
    Reported-by: Daniel Baluta <daniel.baluta@gmail.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 166b6d218fe5..a3dcf14befd8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3445,10 +3445,8 @@ int snd_soc_register_component(struct device *dev,
 	struct snd_soc_component *component;
 
 	component = kzalloc(sizeof(*component), GFP_KERNEL);
-	if (!component) {
-		dev_err(dev, "ASoC: Failed to allocate memory\n");
+	if (!component)
 		return -ENOMEM;
-	}
 
 	return snd_soc_add_component(dev, component, component_driver,
 				     dai_drv, num_dai);

commit d7346278ccb0fd839240d916e45851227e7ef9f4
Merge: 7dd5d0d95461 e0dac41b8c21
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Oct 10 10:23:08 2017 +0100

    Merge branch 'topic/component' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-core

commit e0dac41b8c21d41534b04d520c1927c2b0ac9b5e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 2 05:10:17 2017 +0000

    ASoC: soc-core: add snd_soc_add_component()
    
    ALSA SoC platform/codec will be replaced to component soon.
    But, some function exist in "platform" doesn't exist in "component".
    Current soc-core has snd_soc_register_component(), but
    doesn't have snd_soc_add_component() like snd_soc_add_platform().
    This patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fee4b0ef5566..3a1c3b44de5e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3371,20 +3371,14 @@ static void snd_soc_component_del_unlocked(struct snd_soc_component *component)
 	list_del(&component->list);
 }
 
-int snd_soc_register_component(struct device *dev,
-			       const struct snd_soc_component_driver *component_driver,
-			       struct snd_soc_dai_driver *dai_drv,
-			       int num_dai)
+int snd_soc_add_component(struct device *dev,
+			struct snd_soc_component *component,
+			const struct snd_soc_component_driver *component_driver,
+			struct snd_soc_dai_driver *dai_drv,
+			int num_dai)
 {
-	struct snd_soc_component *component;
 	int ret;
 
-	component = kzalloc(sizeof(*component), GFP_KERNEL);
-	if (!component) {
-		dev_err(dev, "ASoC: Failed to allocate memory\n");
-		return -ENOMEM;
-	}
-
 	ret = snd_soc_component_initialize(component, component_driver, dev);
 	if (ret)
 		goto err_free;
@@ -3408,6 +3402,24 @@ int snd_soc_register_component(struct device *dev,
 	kfree(component);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(snd_soc_add_component);
+
+int snd_soc_register_component(struct device *dev,
+			const struct snd_soc_component_driver *component_driver,
+			struct snd_soc_dai_driver *dai_drv,
+			int num_dai)
+{
+	struct snd_soc_component *component;
+
+	component = kzalloc(sizeof(*component), GFP_KERNEL);
+	if (!component) {
+		dev_err(dev, "ASoC: Failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	return snd_soc_add_component(dev, component, component_driver,
+				     dai_drv, num_dai);
+}
 EXPORT_SYMBOL_GPL(snd_soc_register_component);
 
 /**

commit 7dd5d0d954611c05a38bdf843054c639f45ce08b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Oct 2 05:09:52 2017 +0000

    ASoC: soc-core: add component lookup functions
    
    ALSA SoC platform/codec will be replaced to component soon.
    This means 1 device might have multiple components. But current
    unregister component function only checks "dev" to find it.
    This means, unexpected component might be unregistered by current
    function.
    But, it is no problem if driver registered only 1 component.
    
    To prepare avoid this issue, this patch adds new component
    lookup function. it finds component by "dev" and "driver name".
    
    Here, the reason why it uses "driver name" is that "component name"
    was created by fmt_single_name() and difficult to use it from driver.
    Driver of course knows its "driver name", thus, using it is more easy.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fb3435121172..6ec127346e9c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3481,6 +3481,32 @@ void snd_soc_unregister_component(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
+struct snd_soc_component *snd_soc_lookup_component(struct device *dev,
+						   const char *driver_name)
+{
+	struct snd_soc_component *component;
+	struct snd_soc_component *ret;
+
+	ret = NULL;
+	mutex_lock(&client_mutex);
+	list_for_each_entry(component, &component_list, list) {
+		if (dev != component->dev)
+			continue;
+
+		if (driver_name &&
+		    (driver_name != component->driver->name) &&
+		    (strcmp(component->driver->name, driver_name) != 0))
+			continue;
+
+		ret = component;
+		break;
+	}
+	mutex_unlock(&client_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_lookup_component);
+
 static int snd_soc_platform_drv_probe(struct snd_soc_component *component)
 {
 	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);

commit 7ba236ce58bd7ac8e360de81f834d9c446f7b063
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 26 01:01:10 2017 +0000

    ASoC: add Component level set_bias_level
    
    In current ALSA SoC, Codec only has set_bias_level feature.
    Codec will be merged into Component in next generation ALSA SoC,
    thus current Codec specific feature need to be merged into it.
    This is glue patch for it.
    
    Codec driver has .idle_bias_off for dapm bias. But Component
    driver doesn't have it, and dapm->idle_bias_off is set as "true".
    To keep compatibility, this patch adds "idle_bias_on" instead of
    ".idle_bias_off" on Component driver.
    dapm->idle_bias_off will be set by inverted idle_bias_on.
    
    When we replace Codec to Component, the driver which has
    ".idle_bias_off = true" is just remove it,
    and the driver which doesn't have it will have new
    ".idle_bias_on = true".
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index faed564670cd..fb3435121172 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3270,6 +3270,14 @@ static void snd_soc_component_drv_pcm_free(struct snd_soc_component *component,
 		component->driver->pcm_free(pcm);
 }
 
+static int snd_soc_component_set_bias_level(struct snd_soc_dapm_context *dapm,
+					enum snd_soc_bias_level level)
+{
+	struct snd_soc_component *component = dapm->component;
+
+	return component->driver->set_bias_level(component, level);
+}
+
 static int snd_soc_component_initialize(struct snd_soc_component *component,
 	const struct snd_soc_component_driver *driver, struct device *dev)
 {
@@ -3297,11 +3305,14 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	dapm->dev = dev;
 	dapm->component = component;
 	dapm->bias_level = SND_SOC_BIAS_OFF;
-	dapm->idle_bias_off = true;
+	dapm->idle_bias_off = !driver->idle_bias_on;
+	dapm->suspend_bias_off = driver->suspend_bias_off;
 	if (driver->seq_notifier)
 		dapm->seq_notifier = snd_soc_component_seq_notifier;
 	if (driver->stream_event)
 		dapm->stream_event = snd_soc_component_stream_event;
+	if (driver->set_bias_level)
+		dapm->set_bias_level = snd_soc_component_set_bias_level;
 
 	INIT_LIST_HEAD(&component->dai_list);
 	mutex_init(&component->io_mutex);

commit f523acebbb74f3cf5840d801f2e4856c688bf14a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 26 01:00:53 2017 +0000

    ASoC: add Component level pcm_new/pcm_free v2
    
    In current ALSA SoC, Platform only has pcm_new/pcm_free feature,
    but it should be supported on Component level. This patch adds it.
    
    The v1 was added commit 99b04f4c4051f7 ("ASoC: add Component level
    pcm_new/pcm_free") but it called all "card" connected component's
    pcm_new/free, it was wrong.
    This patch calls "rtd" connected component.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1b5b51952718..faed564670cd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3254,6 +3254,22 @@ static int snd_soc_component_stream_event(struct snd_soc_dapm_context *dapm,
 	return component->driver->stream_event(component, event);
 }
 
+static int snd_soc_component_drv_pcm_new(struct snd_soc_component *component,
+					struct snd_soc_pcm_runtime *rtd)
+{
+	if (component->driver->pcm_new)
+		return component->driver->pcm_new(rtd);
+
+	return 0;
+}
+
+static void snd_soc_component_drv_pcm_free(struct snd_soc_component *component,
+					  struct snd_pcm *pcm)
+{
+	if (component->driver->pcm_free)
+		component->driver->pcm_free(pcm);
+}
+
 static int snd_soc_component_initialize(struct snd_soc_component *component,
 	const struct snd_soc_component_driver *driver, struct device *dev)
 {
@@ -3274,6 +3290,8 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->set_sysclk = component->driver->set_sysclk;
 	component->set_pll = component->driver->set_pll;
 	component->set_jack = component->driver->set_jack;
+	component->pcm_new = snd_soc_component_drv_pcm_new;
+	component->pcm_free = snd_soc_component_drv_pcm_free;
 
 	dapm = snd_soc_component_get_dapm(component);
 	dapm->dev = dev;
@@ -3466,6 +3484,26 @@ static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
 	platform->driver->remove(platform);
 }
 
+static int snd_soc_platform_drv_pcm_new(struct snd_soc_component *component,
+					struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
+
+	if (platform->driver->pcm_new)
+		return platform->driver->pcm_new(rtd);
+
+	return 0;
+}
+
+static void snd_soc_platform_drv_pcm_free(struct snd_soc_component *component,
+					  struct snd_pcm *pcm)
+{
+	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
+
+	if (platform->driver->pcm_free)
+		platform->driver->pcm_free(pcm);
+}
+
 /**
  * snd_soc_add_platform - Add a platform to the ASoC core
  * @dev: The parent device for the platform
@@ -3489,6 +3527,10 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 		platform->component.probe = snd_soc_platform_drv_probe;
 	if (platform_drv->remove)
 		platform->component.remove = snd_soc_platform_drv_remove;
+	if (platform_drv->pcm_new)
+		platform->component.pcm_new = snd_soc_platform_drv_pcm_new;
+	if (platform_drv->pcm_free)
+		platform->component.pcm_free = snd_soc_platform_drv_pcm_free;
 
 #ifdef CONFIG_DEBUG_FS
 	platform->component.debugfs_prefix = "platform";

commit 75ab9eb6f15bad78b3ce274c699c27dc98ab13ce
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 26 00:40:42 2017 +0000

    ASoC: add null_snd_soc_ops and reduce NULL ops check
    
    Double NULL pointer check for ops and ops->func is difficult to read
    and might be forget to check it if new func was add.
    This patch adds new null_snd_soc_ops and use it if rtd->dai_link didn't
    have it to avoid NULL ops, and reduces ops NULL check.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e16220600e51..1b5b51952718 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -614,6 +614,8 @@ struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_dai_substream);
 
+static const struct snd_soc_ops null_snd_soc_ops;
+
 static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	struct snd_soc_card *card, struct snd_soc_dai_link *dai_link)
 {
@@ -626,6 +628,9 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	INIT_LIST_HEAD(&rtd->component_list);
 	rtd->card = card;
 	rtd->dai_link = dai_link;
+	if (!rtd->dai_link->ops)
+		rtd->dai_link->ops = &null_snd_soc_ops;
+
 	rtd->codec_dais = kzalloc(sizeof(struct snd_soc_dai *) *
 					dai_link->num_codecs,
 					GFP_KERNEL);

commit 464719255e095b0cc05a30b124f2cdc67a930d7f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Sep 25 01:38:34 2017 +0000

    ASoC: remove unneeded dai->driver check
    
    On soc_add_dai(), it is checking dai->driver->xxx,
    This means, dai->driver is mandatory, never been NULL.
    dai->driver check is not needed.
    This patch removes it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 091ebe198194..e16220600e51 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2631,7 +2631,7 @@ EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
 int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 	unsigned int freq, int dir)
 {
-	if (dai->driver && dai->driver->ops->set_sysclk)
+	if (dai->driver->ops->set_sysclk)
 		return dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
 
 	return snd_soc_component_set_sysclk(dai->component, clk_id, 0,
@@ -2699,7 +2699,7 @@ EXPORT_SYMBOL_GPL(snd_soc_component_set_sysclk);
 int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
 	int div_id, int div)
 {
-	if (dai->driver && dai->driver->ops->set_clkdiv)
+	if (dai->driver->ops->set_clkdiv)
 		return dai->driver->ops->set_clkdiv(dai, div_id, div);
 	else
 		return -EINVAL;
@@ -2719,7 +2719,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
 	unsigned int freq_in, unsigned int freq_out)
 {
-	if (dai->driver && dai->driver->ops->set_pll)
+	if (dai->driver->ops->set_pll)
 		return dai->driver->ops->set_pll(dai, pll_id, source,
 					 freq_in, freq_out);
 
@@ -2785,7 +2785,7 @@ EXPORT_SYMBOL_GPL(snd_soc_component_set_pll);
  */
 int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
 {
-	if (dai->driver && dai->driver->ops->set_bclk_ratio)
+	if (dai->driver->ops->set_bclk_ratio)
 		return dai->driver->ops->set_bclk_ratio(dai, ratio);
 	else
 		return -EINVAL;
@@ -2859,7 +2859,7 @@ static int snd_soc_xlate_tdm_slot_mask(unsigned int slots,
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
 {
-	if (dai->driver && dai->driver->ops->xlate_tdm_slot_mask)
+	if (dai->driver->ops->xlate_tdm_slot_mask)
 		dai->driver->ops->xlate_tdm_slot_mask(slots,
 						&tx_mask, &rx_mask);
 	else
@@ -2868,7 +2868,7 @@ int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	dai->tx_mask = tx_mask;
 	dai->rx_mask = rx_mask;
 
-	if (dai->driver && dai->driver->ops->set_tdm_slot)
+	if (dai->driver->ops->set_tdm_slot)
 		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
 				slots, slot_width);
 	else
@@ -2892,7 +2892,7 @@ int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,
 	unsigned int tx_num, unsigned int *tx_slot,
 	unsigned int rx_num, unsigned int *rx_slot)
 {
-	if (dai->driver && dai->driver->ops->set_channel_map)
+	if (dai->driver->ops->set_channel_map)
 		return dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,
 			rx_num, rx_slot);
 	else
@@ -2909,7 +2909,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);
  */
 int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
 {
-	if (dai->driver && dai->driver->ops->set_tristate)
+	if (dai->driver->ops->set_tristate)
 		return dai->driver->ops->set_tristate(dai, tristate);
 	else
 		return -EINVAL;

commit db1721f5296704d4f706a31f5d147cf7f16e3add
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Sep 25 01:38:13 2017 +0000

    ASoC: soc-core: remove rtd NULL check on soc_free_pcm_runtime()
    
    static soc_free_pcm_runtime() is never called with rtd == NULL.
    This patch removes unnecessary rtd == NULL check from
    soc_free_pcm_runtime().
    
    Furthermore, NULL check before kfree() is not needed.
    This patch removes such ckeck too.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fee4b0ef5566..091ebe198194 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -639,8 +639,7 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 
 static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 {
-	if (rtd && rtd->codec_dais)
-		kfree(rtd->codec_dais);
+	kfree(rtd->codec_dais);
 	snd_soc_rtdcom_del_all(rtd);
 	kfree(rtd);
 }

commit b06898d119f6b8dba7b318ad73558ce2d39161e8
Merge: b24a5f293058 f5fd4a67bef5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 4 14:50:49 2017 +0200

    Merge tag 'asoc-v4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v4.14
    
    This is quite a large release by volume of patches and diff, a lot of
    that is mechanical cleanup patches but it's great to also see a range of
    vendors actively working on adding new features and fixing issues in
    their drivers.  Intel and Realtek have been especially active here.
    
     - Continued work towards moving everything to the component model from
       Morimoto-san.
     - Use of devres for jack detection GPIOs, eliminating some potential
       resource leaks.
     - Jack detection support for Qualcomm MSM8916.
     - Support for Allwinner H3, Cirrus Logic CS43130, Intel Kabylake
       systems with RT5663, Realtek RT274, TI TLV320AIC32x6 and Wolfson
       WM8523.

commit 39e0a0ae6957a7eafcd3245f45f40bf822e49812
Merge: 0314f6947c51 88c27465dc7e
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Sep 1 12:12:18 2017 +0100

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 44c07365e9e2c87c7e04d63293618c391d1480ec
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Aug 24 00:58:07 2017 +0000

    ASoC: add Component level set_jack
    
    In current ALSA SoC, Codec only has set_jack feature.
    Codec will be merged into Component in next generation ALSA SoC,
    thus current Codec specific feature need to be merged into it.
    This is glue patch for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ee641cd8aa22..3d7287858609 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3225,6 +3225,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->resume = component->driver->resume;
 	component->set_sysclk = component->driver->set_sysclk;
 	component->set_pll = component->driver->set_pll;
+	component->set_jack = component->driver->set_jack;
 
 	dapm = &component->dapm;
 	dapm->dev = dev;
@@ -3625,6 +3626,14 @@ static int snd_soc_codec_set_pll_(struct snd_soc_component *component,
 	return snd_soc_codec_set_pll(codec, pll_id, source, freq_in, freq_out);
 }
 
+static int snd_soc_codec_set_jack_(struct snd_soc_component *component,
+			       struct snd_soc_jack *jack, void *data)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+	return snd_soc_codec_set_jack(codec, jack, data);
+}
+
 static int snd_soc_codec_set_bias_level(struct snd_soc_dapm_context *dapm,
 	enum snd_soc_bias_level level)
 {
@@ -3680,6 +3689,8 @@ int snd_soc_register_codec(struct device *dev,
 		codec->component.set_sysclk = snd_soc_codec_set_sysclk_;
 	if (codec_drv->set_pll)
 		codec->component.set_pll = snd_soc_codec_set_pll_;
+	if (codec_drv->set_jack)
+		codec->component.set_jack = snd_soc_codec_set_jack_;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 
 	dapm = snd_soc_codec_get_dapm(codec);

commit ef641e5d5e6c7a07748239036b786a90ba9b9a95
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Aug 24 00:57:51 2017 +0000

    ASoC: add Component level set_pll
    
    In current ALSA SoC, Codec only has set_pll feature.
    Codec will be merged into Component in next generation ALSA SoC,
    thus current Codec specific feature need to be merged into it.
    This is glue patch for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 654db550039d..ee641cd8aa22 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2679,11 +2679,9 @@ int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
 	if (dai->driver && dai->driver->ops->set_pll)
 		return dai->driver->ops->set_pll(dai, pll_id, source,
 					 freq_in, freq_out);
-	else if (dai->codec && dai->codec->driver->set_pll)
-		return dai->codec->driver->set_pll(dai->codec, pll_id, source,
-						   freq_in, freq_out);
-	else
-		return -EINVAL;
+
+	return snd_soc_component_set_pll(dai->component, pll_id, source,
+					 freq_in, freq_out);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
 
@@ -2708,6 +2706,33 @@ int snd_soc_codec_set_pll(struct snd_soc_codec *codec, int pll_id, int source,
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_pll);
 
+/*
+ * snd_soc_component_set_pll - configure component PLL.
+ * @component: COMPONENT
+ * @pll_id: DAI specific PLL ID
+ * @source: DAI specific source for the PLL
+ * @freq_in: PLL input clock frequency in Hz
+ * @freq_out: requested PLL output clock frequency in Hz
+ *
+ * Configures and enables PLL to generate output clock based on input clock.
+ */
+int snd_soc_component_set_pll(struct snd_soc_component *component, int pll_id,
+			      int source, unsigned int freq_in,
+			      unsigned int freq_out)
+{
+	/* will be removed */
+	if (component->set_pll)
+		return component->set_pll(component, pll_id, source,
+					      freq_in, freq_out);
+
+	if (component->driver->set_pll)
+		return component->driver->set_pll(component, pll_id, source,
+					      freq_in, freq_out);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_set_pll);
+
 /**
  * snd_soc_dai_set_bclk_ratio - configure BCLK to sample rate ratio.
  * @dai: DAI
@@ -3199,6 +3224,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->suspend = component->driver->suspend;
 	component->resume = component->driver->resume;
 	component->set_sysclk = component->driver->set_sysclk;
+	component->set_pll = component->driver->set_pll;
 
 	dapm = &component->dapm;
 	dapm->dev = dev;
@@ -3590,6 +3616,15 @@ static int snd_soc_codec_set_sysclk_(struct snd_soc_component *component,
 	return snd_soc_codec_set_sysclk(codec, clk_id, source, freq, dir);
 }
 
+static int snd_soc_codec_set_pll_(struct snd_soc_component *component,
+				  int pll_id, int source, unsigned int freq_in,
+				  unsigned int freq_out)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+	return snd_soc_codec_set_pll(codec, pll_id, source, freq_in, freq_out);
+}
+
 static int snd_soc_codec_set_bias_level(struct snd_soc_dapm_context *dapm,
 	enum snd_soc_bias_level level)
 {
@@ -3643,6 +3678,8 @@ int snd_soc_register_codec(struct device *dev,
 		codec->component.read = snd_soc_codec_drv_read;
 	if (codec_drv->set_sysclk)
 		codec->component.set_sysclk = snd_soc_codec_set_sysclk_;
+	if (codec_drv->set_pll)
+		codec->component.set_pll = snd_soc_codec_set_pll_;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 
 	dapm = snd_soc_codec_get_dapm(codec);

commit 71ccef0df533cd9c8c6cbf1483a636a092088ab9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Aug 24 00:57:35 2017 +0000

    ASoC: add Component level set_sysclk
    
    In current ALSA SoC, Codec only has set_sysclk feature.
    Codec will be merged into Component in next generation ALSA SoC,
    thus current Codec specific feature need to be merged into it.
    This is glue patch for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 10efd15338fb..654db550039d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2590,11 +2590,9 @@ int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 {
 	if (dai->driver && dai->driver->ops->set_sysclk)
 		return dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
-	else if (dai->codec && dai->codec->driver->set_sysclk)
-		return dai->codec->driver->set_sysclk(dai->codec, clk_id, 0,
-						      freq, dir);
-	else
-		return -ENOTSUPP;
+
+	return snd_soc_component_set_sysclk(dai->component, clk_id, 0,
+					    freq, dir);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 
@@ -2619,6 +2617,32 @@ int snd_soc_codec_set_sysclk(struct snd_soc_codec *codec, int clk_id,
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_sysclk);
 
+/**
+ * snd_soc_component_set_sysclk - configure COMPONENT system or master clock.
+ * @component: COMPONENT
+ * @clk_id: DAI specific clock ID
+ * @source: Source for the clock
+ * @freq: new clock frequency in Hz
+ * @dir: new clock direction - input/output.
+ *
+ * Configures the CODEC master (MCLK) or system (SYSCLK) clocking.
+ */
+int snd_soc_component_set_sysclk(struct snd_soc_component *component, int clk_id,
+			     int source, unsigned int freq, int dir)
+{
+	/* will be removed */
+	if (component->set_sysclk)
+		return component->set_sysclk(component, clk_id, source,
+					     freq, dir);
+
+	if (component->driver->set_sysclk)
+		return component->driver->set_sysclk(component, clk_id, source,
+						 freq, dir);
+
+	return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_set_sysclk);
+
 /**
  * snd_soc_dai_set_clkdiv - configure DAI clock dividers.
  * @dai: DAI
@@ -3174,6 +3198,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->remove = component->driver->remove;
 	component->suspend = component->driver->suspend;
 	component->resume = component->driver->resume;
+	component->set_sysclk = component->driver->set_sysclk;
 
 	dapm = &component->dapm;
 	dapm->dev = dev;
@@ -3557,6 +3582,14 @@ static int snd_soc_codec_drv_read(struct snd_soc_component *component,
 	return 0;
 }
 
+static int snd_soc_codec_set_sysclk_(struct snd_soc_component *component,
+			  int clk_id, int source, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+	return snd_soc_codec_set_sysclk(codec, clk_id, source, freq, dir);
+}
+
 static int snd_soc_codec_set_bias_level(struct snd_soc_dapm_context *dapm,
 	enum snd_soc_bias_level level)
 {
@@ -3608,6 +3641,8 @@ int snd_soc_register_codec(struct device *dev,
 		codec->component.write = snd_soc_codec_drv_write;
 	if (codec_drv->read)
 		codec->component.read = snd_soc_codec_drv_read;
+	if (codec_drv->set_sysclk)
+		codec->component.set_sysclk = snd_soc_codec_set_sysclk_;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 
 	dapm = snd_soc_codec_get_dapm(codec);

commit b388dc1f62a9bdd9c4758a0664e61d0f9a9da519
Merge: 6969b2bae6db cc4a41fe5541
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Aug 30 22:15:31 2017 +0100

    Merge tag 'v4.13-rc7' into asoc-component
    
    Linux 4.13-rc7

commit 7d8e8292013ab72ae1f1500cbc91f198ccb1826d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 30 16:13:25 2017 +0200

    ALSA: Get rid of card power_lock
    
    Currently we're taking power_lock at each card component for assuring
    the power-up sequence, but it doesn't help anything in the
    implementation at the moment: it just serializes unnecessarily the
    callers, but it doesn't protect about the power state change itself.
    It used to have some usefulness in the early days where we managed the
    PM manually.  But now the suspend/resume core procedure is beyond our
    hands, and power_lock lost its meaning.
    
    This patch drops the power_lock from allover the places.
    There shouldn't be any issues by this change, as it's no helper
    regarding the power state change.  Rather we'll get better performance
    by removing the serialization; which is the only slight concern of any
    behavior change, but it can't be a showstopper, after all.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 13c875e2392a..62c11e26ce5c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -653,9 +653,7 @@ int snd_soc_suspend(struct device *dev)
 	/* Due to the resume being scheduled into a workqueue we could
 	* suspend before that's finished - wait for it to complete.
 	 */
-	snd_power_lock(card->snd_card);
 	snd_power_wait(card->snd_card, SNDRV_CTL_POWER_D0);
-	snd_power_unlock(card->snd_card);
 
 	/* we're going to block userspace touching us until resume completes */
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D3hot);

commit 6969b2bae6dbe7f277a7c018b66d2f3ad662129f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 25 00:29:41 2017 +0000

    ASoC: remove duplicate definition of dapm_routes/num_dapm_routes
    
    snd_soc_component and snd_soc_component_driver both have
    dapm_routes/num_dapm_routes, but these are duplicated.
    Let's remove duplicated definition.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3a3236dc996d..b8f96a41b594 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1500,9 +1500,10 @@ static int soc_probe_component(struct snd_soc_card *card,
 		snd_soc_add_component_controls(component,
 					       component->driver->controls,
 					       component->driver->num_controls);
-	if (component->dapm_routes)
-		snd_soc_dapm_add_routes(dapm, component->dapm_routes,
-					component->num_dapm_routes);
+	if (component->driver->dapm_routes)
+		snd_soc_dapm_add_routes(dapm,
+					component->driver->dapm_routes,
+					component->driver->num_dapm_routes);
 
 	list_add(&dapm->list, &card->dapm_list);
 	list_add(&component->card_list, &card->component_dev_list);
@@ -3186,9 +3187,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	if (driver->stream_event)
 		dapm->stream_event = snd_soc_component_stream_event;
 
-	component->dapm_routes = driver->dapm_routes;
-	component->num_dapm_routes = driver->num_dapm_routes;
-
 	INIT_LIST_HEAD(&component->dai_list);
 	mutex_init(&component->io_mutex);
 

commit 688d0ebf49a97aa6959aebec5d177a8b821f27d1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 25 00:29:20 2017 +0000

    ASoC: remove duplicate definition of dapm_widgets/num_dapm_widgets
    
    snd_soc_component and snd_soc_component_driver both have
    dapm_widgets/num_dapm_widgets, but these are duplicated.
    Let's remove duplicated definition.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1317706f8e69..3a3236dc996d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1451,9 +1451,10 @@ static int soc_probe_component(struct snd_soc_card *card,
 
 	soc_init_component_debugfs(component);
 
-	if (component->dapm_widgets) {
-		ret = snd_soc_dapm_new_controls(dapm, component->dapm_widgets,
-			component->num_dapm_widgets);
+	if (component->driver->dapm_widgets) {
+		ret = snd_soc_dapm_new_controls(dapm,
+					component->driver->dapm_widgets,
+					component->driver->num_dapm_widgets);
 
 		if (ret != 0) {
 			dev_err(component->dev,
@@ -3185,8 +3186,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	if (driver->stream_event)
 		dapm->stream_event = snd_soc_component_stream_event;
 
-	component->dapm_widgets = driver->dapm_widgets;
-	component->num_dapm_widgets = driver->num_dapm_widgets;
 	component->dapm_routes = driver->dapm_routes;
 	component->num_dapm_routes = driver->num_dapm_routes;
 

commit b8972bf0521ca7ee3c8d27da0fd101fe648acfc2
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 25 00:29:01 2017 +0000

    ASoC: remove duplicate definition of controls/num_controls
    
    snd_soc_component and snd_soc_component_driver both have
    controls/num_controls, but these are duplicated.
    Let's remove duplicated definition.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3bb8c63564cf..1317706f8e69 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1495,9 +1495,10 @@ static int soc_probe_component(struct snd_soc_card *card,
 		}
 	}
 
-	if (component->controls)
-		snd_soc_add_component_controls(component, component->controls,
-				     component->num_controls);
+	if (component->driver->controls)
+		snd_soc_add_component_controls(component,
+					       component->driver->controls,
+					       component->driver->num_controls);
 	if (component->dapm_routes)
 		snd_soc_dapm_add_routes(dapm, component->dapm_routes,
 					component->num_dapm_routes);
@@ -3184,8 +3185,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	if (driver->stream_event)
 		dapm->stream_event = snd_soc_component_stream_event;
 
-	component->controls = driver->controls;
-	component->num_controls = driver->num_controls;
 	component->dapm_widgets = driver->dapm_widgets;
 	component->num_dapm_widgets = driver->num_dapm_widgets;
 	component->dapm_routes = driver->dapm_routes;

commit 88c27465dc7e3f11c43de295f623c44f593a0912
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 25 01:06:04 2017 +0000

    ASoC: use snd_soc_component_get_dapm()
    
    Now we have snd_soc_component_get_dapm(),
    and as soc.h say below, let's use it.
    
    /* Don't use these, use snd_soc_component_get_dapm() */
    struct snd_soc_dapm_context dapm;
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 74c17068bb11..92e09cb7fda4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3220,7 +3220,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->pcm_new = component->driver->pcm_new;
 	component->pcm_free = component->driver->pcm_free;
 
-	dapm = &component->dapm;
+	dapm = snd_soc_component_get_dapm(component);
 	dapm->dev = dev;
 	dapm->component = component;
 	dapm->bias_level = SND_SOC_BIAS_OFF;

commit 6a6dafda937cfcdbbfe46a3e093de8bb929ba52d
Author: Jeffy Chen <jeffy.chen@rock-chips.com>
Date:   Thu Aug 24 12:40:17 2017 +0800

    ASoC: Add a sanity check before using dai driver name
    
    The dai driver's name is allowed to be NULL. So add a sanity check for
    that.
    
    Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Reported-by: Donglin Peng <dolinux.peng@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6fab0ff213ef..74c17068bb11 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1029,7 +1029,8 @@ struct snd_soc_dai *snd_soc_find_dai(
 			continue;
 		list_for_each_entry(dai, &component->dai_list, list) {
 			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name)
-			    && strcmp(dai->driver->name, dlc->dai_name))
+			    && (!dai->driver->name
+				|| strcmp(dai->driver->name, dlc->dai_name)))
 				continue;
 
 			return dai;

commit 4958471b0d2110a34df0b45803e6f24ed89b857b
Author: Jeffy Chen <jeffy.chen@rock-chips.com>
Date:   Tue Aug 22 15:57:21 2017 +0800

    ASoC: soc-core: Allow searching dai driver name in snd_soc_find_dai
    
    Currently we are searching dai name in snd_soc_find_dai, which could
    either be dai driver name or component device name(for legacy naming).
    
    Allow searching dai driver name in snd_soc_find_dai too, so that we can
    use dai driver name to find legacy naming dais.
    
    Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 50c8dba54649..6fab0ff213ef 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1000,7 +1000,7 @@ static struct snd_soc_component *soc_find_component(
 /**
  * snd_soc_find_dai - Find a registered DAI
  *
- * @dlc: name of the DAI and optional component info to match
+ * @dlc: name of the DAI or the DAI driver and optional component info to match
  *
  * This function will search all registered components and their DAIs to
  * find the DAI of the same name. The component's of_node and name
@@ -1028,7 +1028,8 @@ struct snd_soc_dai *snd_soc_find_dai(
 		if (dlc->name && strcmp(component->name, dlc->name))
 			continue;
 		list_for_each_entry(dai, &component->dai_list, list) {
-			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name))
+			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name)
+			    && strcmp(dai->driver->name, dlc->dai_name))
 				continue;
 
 			return dai;

commit 2eccea8cdeb8fe455fc3a45b4e097f118449c3ef
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Aug 7 02:06:55 2017 +0000

    ASoC: soc-core: snd_soc_unregister_component() unregister all component
    
    Current snd_soc_unregister_component() unregisters first found
    component only which was specified by dev.
    This style can't specify concrete component if system registered some
    component with same dev. And system need to call this function many
    times.
    This patch unregister all related component by 1 call.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b1860b14b075..50c8dba54649 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3365,11 +3365,12 @@ int snd_soc_register_component(struct device *dev,
 EXPORT_SYMBOL_GPL(snd_soc_register_component);
 
 /**
- * snd_soc_unregister_component - Unregister a component from the ASoC core
+ * snd_soc_unregister_component - Unregister all related component
+ * from the ASoC core
  *
  * @dev: The device to unregister
  */
-void snd_soc_unregister_component(struct device *dev)
+static int __snd_soc_unregister_component(struct device *dev)
 {
 	struct snd_soc_component *component;
 	int found = 0;
@@ -3391,6 +3392,13 @@ void snd_soc_unregister_component(struct device *dev)
 		snd_soc_component_cleanup(component);
 		kfree(component);
 	}
+
+	return found;
+}
+
+void snd_soc_unregister_component(struct device *dev)
+{
+	while (__snd_soc_unregister_component(dev));
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 

commit 42d9653e85b386111e729317b9492bfdac1cafbc
Merge: 90be711e23f7 21a035287e28
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Aug 10 16:56:10 2017 +0100

    Merge branch 'topic/component' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-core

commit 90be711e23f7c7ee7b3d6a6e5aa7ee9bab321f2e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 8 06:18:10 2017 +0000

    ASoC: use snd_soc_rtdcom_add() and convert to consistent operation
    
    Basically, current ALSA SoC framework is based on CPU/Codec/Platform,
    but its operation doesn't have consistent.
    Thus, source code was unreadable, and difficult to understand.
    This patch connects each component (= CPU/Codec/Platform) to rtd by
    using snd_soc_rtdcom_add(), and convert uneven operations to consistent
    operation.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Arnaud Pouliquen <arnaud.pouliquen@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c2462e0f0f0d..bbbe003fc0af 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1100,6 +1100,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
 	struct snd_soc_dai_link_component cpu_dai_component;
+	struct snd_soc_component *component;
 	struct snd_soc_dai **codec_dais;
 	struct snd_soc_platform *platform;
 	struct device_node *platform_of_node;
@@ -1127,6 +1128,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 			dai_link->cpu_dai_name);
 		goto _err_defer;
 	}
+	snd_soc_rtdcom_add(rtd, rtd->cpu_dai->component);
 
 	rtd->num_codecs = dai_link->num_codecs;
 
@@ -1139,6 +1141,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 				codecs[i].dai_name);
 			goto _err_defer;
 		}
+		snd_soc_rtdcom_add(rtd, codec_dais[i]->component);
 	}
 
 	/* Single codec links expect codec and codec_dai in runtime data */
@@ -1150,6 +1153,23 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	if (!platform_name && !dai_link->platform_of_node)
 		platform_name = "snd-soc-dummy";
 
+	/* find one from the set of registered platforms */
+	list_for_each_entry(component, &component_list, list) {
+		platform_of_node = component->dev->of_node;
+		if (!platform_of_node && component->dev->parent->of_node)
+			platform_of_node = component->dev->parent->of_node;
+
+		if (dai_link->platform_of_node) {
+			if (platform_of_node != dai_link->platform_of_node)
+				continue;
+		} else {
+			if (strcmp(component->name, platform_name))
+				continue;
+		}
+
+		snd_soc_rtdcom_add(rtd, component);
+	}
+
 	/* find one from the set of registered platforms */
 	list_for_each_entry(platform, &platform_list, list) {
 		platform_of_node = platform->dev->of_node;
@@ -1235,27 +1255,15 @@ static void soc_remove_link_dais(struct snd_soc_card *card,
 static void soc_remove_link_components(struct snd_soc_card *card,
 	struct snd_soc_pcm_runtime *rtd, int order)
 {
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_component *component;
-	int i;
+	struct snd_soc_rtdcom_list *rtdcom;
 
-	/* remove the platform */
-	if (platform && platform->component.driver->remove_order == order)
-		soc_remove_component(&platform->component);
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
 
-	/* remove the CODEC-side CODEC */
-	for (i = 0; i < rtd->num_codecs; i++) {
-		component = rtd->codec_dais[i]->component;
 		if (component->driver->remove_order == order)
 			soc_remove_component(component);
 	}
-
-	/* remove any CPU-side CODEC */
-	if (cpu_dai) {
-		if (cpu_dai->component->driver->remove_order == order)
-			soc_remove_component(cpu_dai->component);
-	}
 }
 
 static void soc_remove_dai_links(struct snd_soc_card *card)
@@ -1607,21 +1615,13 @@ static int soc_probe_link_components(struct snd_soc_card *card,
 			struct snd_soc_pcm_runtime *rtd,
 				     int order)
 {
-	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_component *component;
-	int i, ret;
+	struct snd_soc_rtdcom_list *rtdcom;
+	int ret;
 
-	/* probe the CPU-side component, if it is a CODEC */
-	component = rtd->cpu_dai->component;
-	if (component->driver->probe_order == order) {
-		ret = soc_probe_component(card, component);
-		if (ret < 0)
-			return ret;
-	}
+	for_each_rtdcom(rtd, rtdcom) {
+		component = rtdcom->component;
 
-	/* probe the CODEC-side components */
-	for (i = 0; i < rtd->num_codecs; i++) {
-		component = rtd->codec_dais[i]->component;
 		if (component->driver->probe_order == order) {
 			ret = soc_probe_component(card, component);
 			if (ret < 0)
@@ -1629,13 +1629,6 @@ static int soc_probe_link_components(struct snd_soc_card *card,
 		}
 	}
 
-	/* probe the platform */
-	if (platform->component.driver->probe_order == order) {
-		ret = soc_probe_component(card, &platform->component);
-		if (ret < 0)
-			return ret;
-	}
-
 	return 0;
 }
 

commit a0ac441152238c9b474bafa46940511d9b2e9c7e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 8 06:17:47 2017 +0000

    ASoC: soc-core: add snd_soc_rtdcom_xxx()
    
    Current snd_soc_pcm_runtime has platform / codec pointers, and we could
    use these specific pointer. But these will be replaced to more generic
    "component" soon, and will need more generic method to get each
    connected component pointer from rtd.
    
    This patch adds new snd_soc_rtdcom_xxx() to connect/disconnect
    component to rtd. It means same as previous "platform" / "codec"
    pointer style, but more generic.
    We can find necessary component pointer from rtd by using component
    driver name on snd_soc_rtdcom_lookup().
    
    Here, the reason why it uses "driver name" is that "component name"
    was created by fmt_single_name() and difficult to use it from driver.
    Driver of course knows its "driver name", thus, using it is more easy.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Arnaud Pouliquen <arnaud.pouliquen@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 07d708498500..c2462e0f0f0d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -551,6 +551,54 @@ static inline void snd_soc_debugfs_exit(void)
 
 #endif
 
+static int snd_soc_rtdcom_add(struct snd_soc_pcm_runtime *rtd,
+			      struct snd_soc_component *component)
+{
+	struct snd_soc_rtdcom_list *rtdcom;
+	struct snd_soc_rtdcom_list *new_rtdcom;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		/* already connected */
+		if (rtdcom->component == component)
+			return 0;
+	}
+
+	new_rtdcom = kmalloc(sizeof(*new_rtdcom), GFP_KERNEL);
+	if (!new_rtdcom)
+		return -ENOMEM;
+
+	new_rtdcom->component = component;
+	INIT_LIST_HEAD(&new_rtdcom->list);
+
+	list_add_tail(&new_rtdcom->list, &rtd->component_list);
+
+	return 0;
+}
+
+static void snd_soc_rtdcom_del_all(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_rtdcom_list *rtdcom1, *rtdcom2;
+
+	for_each_rtdcom_safe(rtd, rtdcom1, rtdcom2)
+		kfree(rtdcom1);
+
+	INIT_LIST_HEAD(&rtd->component_list);
+}
+
+struct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,
+						const char *driver_name)
+{
+	struct snd_soc_rtdcom_list *rtdcom;
+
+	for_each_rtdcom(rtd, rtdcom) {
+		if ((rtdcom->component->driver->name == driver_name) ||
+		    strcmp(rtdcom->component->driver->name, driver_name) == 0)
+			return rtdcom->component;
+	}
+
+	return NULL;
+}
+
 struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
 		const char *dai_link, int stream)
 {
@@ -575,6 +623,7 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	if (!rtd)
 		return NULL;
 
+	INIT_LIST_HEAD(&rtd->component_list);
 	rtd->card = card;
 	rtd->dai_link = dai_link;
 	rtd->codec_dais = kzalloc(sizeof(struct snd_soc_dai *) *
@@ -592,6 +641,7 @@ static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
 {
 	if (rtd && rtd->codec_dais)
 		kfree(rtd->codec_dais);
+	snd_soc_rtdcom_del_all(rtd);
 	kfree(rtd);
 }
 

commit 21a035287e28ec225fe7dfd1fffc509efd26a5db
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Aug 7 02:06:40 2017 +0000

    ASoC: soc-core: remove duplicate mutex_unlock from snd_soc_unregister_component()
    
    Current snd_soc_unregister_component() is using multiple mutex_unlock()
    for found/non-found cases. But it is unreadable and confusable code.
    This patch tidyup current code to be readable.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b21488972198..3bb8c63564cf 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3328,21 +3328,25 @@ EXPORT_SYMBOL_GPL(snd_soc_register_component);
 void snd_soc_unregister_component(struct device *dev)
 {
 	struct snd_soc_component *component;
+	int found = 0;
 
 	mutex_lock(&client_mutex);
 	list_for_each_entry(component, &component_list, list) {
-		if (dev == component->dev && component->registered_as_component)
-			goto found;
+		if (dev != component->dev ||
+		    !component->registered_as_component)
+			continue;
+
+		snd_soc_tplg_component_remove(component, SND_SOC_TPLG_INDEX_ALL);
+		snd_soc_component_del_unlocked(component);
+		found = 1;
+		break;
 	}
 	mutex_unlock(&client_mutex);
-	return;
 
-found:
-	snd_soc_tplg_component_remove(component, SND_SOC_TPLG_INDEX_ALL);
-	snd_soc_component_del_unlocked(component);
-	mutex_unlock(&client_mutex);
-	snd_soc_component_cleanup(component);
-	kfree(component);
+	if (found) {
+		snd_soc_component_cleanup(component);
+		kfree(component);
+	}
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 

commit cf9e829eaf0195e722bc3a3929002a3fbe74dafa
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Aug 7 02:06:23 2017 +0000

    ASoC: soc-core: rename "cmpnt" to "component"
    
    To unify notation, to readable.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 921622a01944..b21488972198 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3282,40 +3282,40 @@ static void snd_soc_component_del_unlocked(struct snd_soc_component *component)
 }
 
 int snd_soc_register_component(struct device *dev,
-			       const struct snd_soc_component_driver *cmpnt_drv,
+			       const struct snd_soc_component_driver *component_driver,
 			       struct snd_soc_dai_driver *dai_drv,
 			       int num_dai)
 {
-	struct snd_soc_component *cmpnt;
+	struct snd_soc_component *component;
 	int ret;
 
-	cmpnt = kzalloc(sizeof(*cmpnt), GFP_KERNEL);
-	if (!cmpnt) {
+	component = kzalloc(sizeof(*component), GFP_KERNEL);
+	if (!component) {
 		dev_err(dev, "ASoC: Failed to allocate memory\n");
 		return -ENOMEM;
 	}
 
-	ret = snd_soc_component_initialize(cmpnt, cmpnt_drv, dev);
+	ret = snd_soc_component_initialize(component, component_driver, dev);
 	if (ret)
 		goto err_free;
 
-	cmpnt->ignore_pmdown_time = true;
-	cmpnt->registered_as_component = true;
+	component->ignore_pmdown_time = true;
+	component->registered_as_component = true;
 
-	ret = snd_soc_register_dais(cmpnt, dai_drv, num_dai, true);
+	ret = snd_soc_register_dais(component, dai_drv, num_dai, true);
 	if (ret < 0) {
 		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
 		goto err_cleanup;
 	}
 
-	snd_soc_component_add(cmpnt);
+	snd_soc_component_add(component);
 
 	return 0;
 
 err_cleanup:
-	snd_soc_component_cleanup(cmpnt);
+	snd_soc_component_cleanup(component);
 err_free:
-	kfree(cmpnt);
+	kfree(component);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_component);
@@ -3327,22 +3327,22 @@ EXPORT_SYMBOL_GPL(snd_soc_register_component);
  */
 void snd_soc_unregister_component(struct device *dev)
 {
-	struct snd_soc_component *cmpnt;
+	struct snd_soc_component *component;
 
 	mutex_lock(&client_mutex);
-	list_for_each_entry(cmpnt, &component_list, list) {
-		if (dev == cmpnt->dev && cmpnt->registered_as_component)
+	list_for_each_entry(component, &component_list, list) {
+		if (dev == component->dev && component->registered_as_component)
 			goto found;
 	}
 	mutex_unlock(&client_mutex);
 	return;
 
 found:
-	snd_soc_tplg_component_remove(cmpnt, SND_SOC_TPLG_INDEX_ALL);
-	snd_soc_component_del_unlocked(cmpnt);
+	snd_soc_tplg_component_remove(component, SND_SOC_TPLG_INDEX_ALL);
+	snd_soc_component_del_unlocked(component);
 	mutex_unlock(&client_mutex);
-	snd_soc_component_cleanup(cmpnt);
-	kfree(cmpnt);
+	snd_soc_component_cleanup(component);
+	kfree(component);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 

commit d9a02c552cd69c466998e3afdf420cb4c0b9d9d9
Author: Fabio Estevam <festevam@gmail.com>
Date:   Mon Aug 7 09:08:53 2017 -0300

    ASoC: soc-core: Use IS_ERR_OR_NULL()
    
    The check of IS_ERR or NULL pointer can be replaced by IS_ERR_OR_NULL(),
    which helps readability.
    
    Signed-off-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 558efdfd717d..07d708498500 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -495,7 +495,7 @@ static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 static void snd_soc_debugfs_init(void)
 {
 	snd_soc_debugfs_root = debugfs_create_dir("asoc", NULL);
-	if (IS_ERR(snd_soc_debugfs_root) || !snd_soc_debugfs_root) {
+	if (IS_ERR_OR_NULL(snd_soc_debugfs_root)) {
 		pr_warn("ASoC: Failed to create debugfs directory\n");
 		snd_soc_debugfs_root = NULL;
 		return;

commit 353c64dd19ebc99786c3578ea0444e1b5b1bb172
Author: Fabio Estevam <festevam@gmail.com>
Date:   Mon Aug 7 09:08:52 2017 -0300

    ASoC: soc-core: Remove unneeded dentry member from snd_soc_codec
    
    There is no need to have the *debugfs_reg dentry member as part of
    the snd_soc_codec structure as its only usage is inside
    soc_init_codec_debugfs().
    
    Use a local dentry variable instead.
    
    Signed-off-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 921622a01944..558efdfd717d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -339,11 +339,12 @@ static void soc_cleanup_component_debugfs(struct snd_soc_component *component)
 static void soc_init_codec_debugfs(struct snd_soc_component *component)
 {
 	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+	struct dentry *debugfs_reg;
 
-	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
-						 codec->component.debugfs_root,
-						 codec, &codec_reg_fops);
-	if (!codec->debugfs_reg)
+	debugfs_reg = debugfs_create_file("codec_reg", 0644,
+					  codec->component.debugfs_root,
+					  codec, &codec_reg_fops);
+	if (!debugfs_reg)
 		dev_warn(codec->dev,
 			"ASoC: Failed to create codec register debugfs file\n");
 }

commit 440174aca84d6aec1a75d6d79c276c7c65b14296
Merge: 7e5fed09ddbb b1cd2e34c69a ae1fbdff6dbc deab4563ad6a 651e9268fb9b c0a480d1acf7 ac1ca3ba9faa
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Aug 1 15:17:06 2017 +0100

    Merge remote-tracking branches 'asoc/fix/dpcm', 'asoc/fix/imx', 'asoc/fix/msm8916', 'asoc/fix/multi-pcm', 'asoc/fix/of-graph' and 'asoc/fix/pxa' into asoc-linus

commit c0a480d1acf7dc184f9f3e7cf724483b0d28dc2e
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jul 28 01:23:15 2017 -0700

    device property: Fix usecount for of_graph_get_port_parent()
    
    Fix inconsistent use of of_graph_get_port_parent() where
    asoc_simple_card_parse_graph_dai() does of_node_get() before
    calling it while other callers do not. We can fix this by
    not trashing the node passed to of_graph_get_port_parent().
    
    Let's also make sure the callers have correct refcounts and remove
    related incorrect of_node_put() calls for of_for_each_phandle
    as that's done by of_phandle_iterator_next() except when
    we break out of the loop early.
    
    Let's fix both issues with a single patch to avoid kobject
    refcounts getting messed up more if two patches are merged
    separately.
    
    Otherwise strange issues can happen caused by memory corruption
    caused by too many kobject_del() calls such as:
    
    BUG: sleeping function called from invalid context at
    kernel/locking/mutex.c:747
    ...
    (___might_sleep)
    (__mutex_lock)
    (mutex_lock_nested)
    (kernfs_remove)
    (kobject_del)
    (kobject_put)
    (of_get_next_parent)
    (of_graph_get_port_parent)
    (asoc_simple_card_parse_graph_dai [snd_soc_simple_card_utils])
    (asoc_graph_card_probe [snd_soc_audio_graph_card])
    
    Fixes: 0ef472a973eb ("of_graph: add of_graph_get_port_parent()")
    Fixes: 2692c1c63c29 ("ASoC: add audio-graph-card support")
    Fixes: 1689333f8311 ("ASoC: simple-card-utils: add asoc_simple_card_parse_graph_dai()")
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Tested-by: Antonio Borneo <borneo.antonio@gmail.com>
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 921622a01944..0cf8498fa36c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4113,6 +4113,8 @@ int snd_soc_get_dai_id(struct device_node *ep)
 	}
 	mutex_unlock(&client_mutex);
 
+	of_node_put(node);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_dai_id);

commit c641e5b207ed7dfaa692820aeb5b6dde3de3e9b0
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jul 12 17:55:29 2017 +0200

    ASoC: fix pcm-creation regression
    
    This reverts commit 99b04f4c4051 ("ASoC: add Component level
    pcm_new/pcm_free"), which started calling the pcm_new callback for every
    component in a *card* when creating a new pcm, something which does not
    seem to make any sense.
    
    This specifically led to memory leaks in systems with more than one
    platform component and where DMA memory is allocated in the
    platform-driver callback. For example, when both mcasp devices are being
    used on an am335x board, DMA memory would be allocated twice for every
    DAI link during probe.
    
    When CONFIG_SND_VERBOSE_PROCFS was set this fortunately also led to
    warnings such as:
    
    WARNING: CPU: 0 PID: 565 at ../fs/proc/generic.c:346 proc_register+0x110/0x154
    proc_dir_entry 'sub0/prealloc' already registered
    
    Since there seems to be no users of the new component callbacks, and the
    current implementation introduced a regression, let's revert the
    offending commit for now.
    
    Fixes: 99b04f4c4051 ("ASoC: add Component level pcm_new/pcm_free")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable <stable@vger.kernel.org>     # 4.10

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 921622a01944..c240e13ba057 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3171,8 +3171,6 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->remove = component->driver->remove;
 	component->suspend = component->driver->suspend;
 	component->resume = component->driver->resume;
-	component->pcm_new = component->driver->pcm_new;
-	component->pcm_free = component->driver->pcm_free;
 
 	dapm = &component->dapm;
 	dapm->dev = dev;
@@ -3360,25 +3358,6 @@ static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
 	platform->driver->remove(platform);
 }
 
-static int snd_soc_platform_drv_pcm_new(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_soc_platform *platform = rtd->platform;
-
-	if (platform->driver->pcm_new)
-		return platform->driver->pcm_new(rtd);
-	else
-		return 0;
-}
-
-static void snd_soc_platform_drv_pcm_free(struct snd_pcm *pcm)
-{
-	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
-	struct snd_soc_platform *platform = rtd->platform;
-
-	if (platform->driver->pcm_free)
-		platform->driver->pcm_free(pcm);
-}
-
 /**
  * snd_soc_add_platform - Add a platform to the ASoC core
  * @dev: The parent device for the platform
@@ -3402,10 +3381,6 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 		platform->component.probe = snd_soc_platform_drv_probe;
 	if (platform_drv->remove)
 		platform->component.remove = snd_soc_platform_drv_remove;
-	if (platform_drv->pcm_new)
-		platform->component.pcm_new = snd_soc_platform_drv_pcm_new;
-	if (platform_drv->pcm_free)
-		platform->component.pcm_free = snd_soc_platform_drv_pcm_free;
 
 #ifdef CONFIG_DEBUG_FS
 	platform->component.debugfs_prefix = "platform";

commit 6bf4cd287d6e60755481940386b3d146f7ba3c92
Merge: 2016d5ed4011 8288591368fc
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jul 3 16:51:30 2017 +0100

    Merge remote-tracking branch 'asoc/topic/rcar' into asoc-next

commit 2016d5ed401133539779d8a070abbe42fe9cb3da
Merge: 053251208610 7d3d6e0645dd
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jul 3 16:51:30 2017 +0100

    Merge remote-tracking branch 'asoc/topic/intel' into asoc-next

commit 46b5a4d249ac6798cee28de9f51ef80777d16a3e
Author: Wu Fengguang <fengguang.wu@intel.com>
Date:   Fri Jun 30 00:27:13 2017 +0800

    ASoC: fix semicolon.cocci warnings
    
    sound/soc/soc-core.c:1961:2-3: Unneeded semicolon
    
     Remove unneeded semicolon.
    
    Generated by: scripts/coccinelle/misc/semicolon.cocci
    
    Fixes: 98faf436ee05 ("ASoC: Drop invalid DMI fields when setting card long name from DMI info")
    CC: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e14e04cc0a93..6bd593dc9b54 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1958,7 +1958,7 @@ static int is_dmi_valid(const char *field)
 		if (strstr(field, dmi_blacklist[i]))
 			return 0;
 		i++;
-	};
+	}
 
 	return 1;
 }

commit 98faf436ee05503e258ee934a9de8d8a3472b40f
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Wed Jun 28 15:01:39 2017 +0800

    ASoC: Drop invalid DMI fields when setting card long name from DMI info
    
    Sometimes DMI fields may be invalid and so can't give useful vendor,
    product or board info, such as "Type2 - Board Manufacturer" or
    "Type1 - TBD by OEM". Including such invalid DMI fileds may create silly
    card long name. So this patch creates a black list of invalid strings.
    And if a DMI field contains any string in this list, it will be excluded
    from the card long name.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index aae099c0e502..e14e04cc0a93 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -68,6 +68,20 @@ static int pmdown_time = 5000;
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
+/* If a DMI filed contain strings in this blacklist (e.g.
+ * "Type2 - Board Manufacturer" or  "Type1 - TBD by OEM"), it will be taken
+ * as invalid and dropped when setting the card long name from DMI info.
+ */
+static const char * const dmi_blacklist[] = {
+	"To be filled by OEM",
+	"TBD by OEM",
+	"Default String",
+	"Board Manufacturer",
+	"Board Vendor Name",
+	"Board Product Name",
+	NULL,	/* terminator */
+};
+
 /* returns the minimum number of bytes needed to represent
  * a particular given value */
 static int min_bytes_needed(unsigned long val)
@@ -1933,6 +1947,22 @@ static void cleanup_dmi_name(char *name)
 	name[j] = '\0';
 }
 
+/* Check if a DMI field is valid, i.e. not containing any string
+ * in the black list.
+ */
+static int is_dmi_valid(const char *field)
+{
+	int i = 0;
+
+	while (dmi_blacklist[i]) {
+		if (strstr(field, dmi_blacklist[i]))
+			return 0;
+		i++;
+	};
+
+	return 1;
+}
+
 /**
  * snd_soc_set_dmi_name() - Register DMI names to card
  * @card: The card to register DMI names
@@ -1975,17 +2005,18 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 
 	/* make up dmi long name as: vendor.product.version.board */
 	vendor = dmi_get_system_info(DMI_BOARD_VENDOR);
-	if (!vendor) {
+	if (!vendor || !is_dmi_valid(vendor)) {
 		dev_warn(card->dev, "ASoC: no DMI vendor name!\n");
 		return 0;
 	}
 
+
 	snprintf(card->dmi_longname, sizeof(card->snd_card->longname),
 			 "%s", vendor);
 	cleanup_dmi_name(card->dmi_longname);
 
 	product = dmi_get_system_info(DMI_PRODUCT_NAME);
-	if (product) {
+	if (product && is_dmi_valid(product)) {
 		len = strlen(card->dmi_longname);
 		snprintf(card->dmi_longname + len,
 			 longname_buf_size - len,
@@ -1999,7 +2030,7 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 		 * name in the product version field
 		 */
 		product_version = dmi_get_system_info(DMI_PRODUCT_VERSION);
-		if (product_version) {
+		if (product_version && is_dmi_valid(product_version)) {
 			len = strlen(card->dmi_longname);
 			snprintf(card->dmi_longname + len,
 				 longname_buf_size - len,
@@ -2012,7 +2043,7 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 	}
 
 	board = dmi_get_system_info(DMI_BOARD_NAME);
-	if (board) {
+	if (board && is_dmi_valid(board)) {
 		len = strlen(card->dmi_longname);
 		snprintf(card->dmi_longname + len,
 			 longname_buf_size - len,

commit 7932787f03f33493455360df936d10d0d04fc7c5
Merge: 55cfebfede61 a180e8b98843
Author: Mark Brown <broonie@kernel.org>
Date:   Wed May 24 18:44:06 2017 +0100

    Merge branch 'topic/dai-id' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-of-graph

commit a180e8b988437b3e84a1b501ac4d073467602ca6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu May 18 01:39:25 2017 +0000

    ASoC: add snd_soc_get_dai_id() function
    
    ALSA SoC needs to know connected DAI ID for detecting.
    It is not a big problem if device/driver was only for sound,
    but getting DAI ID will be difficult if device includes both
    Video/Sound, like HDMI.
    To solve this issue, this patch adds new snd_soc_get_dai_id() and
    its related .of_xlate_dai_id callback on component driver.
    In below case, we can handle Sound port (= port@2) as ID = 0
    if .of_xlate_dai_id has its support.
    
            hdmi {
                    port@0 { /* VIDEO */ };
                    port@1 { /* VIDEO */ };
                    port@2 { /* SOUND */ };
            };
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index aae099c0e502..b0fb17082691 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -34,6 +34,7 @@
 #include <linux/ctype.h>
 #include <linux/slab.h>
 #include <linux/of.h>
+#include <linux/of_graph.h>
 #include <linux/dmi.h>
 #include <sound/core.h>
 #include <sound/jack.h>
@@ -4044,6 +4045,42 @@ unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_daifmt);
 
+int snd_soc_get_dai_id(struct device_node *ep)
+{
+	struct snd_soc_component *pos;
+	struct device_node *node;
+	int ret;
+
+	node = of_graph_get_port_parent(ep);
+
+	/*
+	 * For example HDMI case, HDMI has video/sound port,
+	 * but ALSA SoC needs sound port number only.
+	 * Thus counting HDMI DT port/endpoint doesn't work.
+	 * Then, it should have .of_xlate_dai_id
+	 */
+	ret = -ENOTSUPP;
+	mutex_lock(&client_mutex);
+	list_for_each_entry(pos, &component_list, list) {
+		struct device_node *component_of_node = pos->dev->of_node;
+
+		if (!component_of_node && pos->dev->parent)
+			component_of_node = pos->dev->parent->of_node;
+
+		if (component_of_node != node)
+			continue;
+
+		if (pos->driver->of_xlate_dai_id)
+			ret = pos->driver->of_xlate_dai_id(pos, ep);
+
+		break;
+	}
+	mutex_unlock(&client_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_dai_id);
+
 int snd_soc_get_dai_name(struct of_phandle_args *args,
 				const char **dai_name)
 {

commit 4efda5f2130da033aeedc5b3205569893b910de2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 24 10:19:45 2017 +0200

    ASoC: Fix use-after-free at card unregistration
    
    soc_cleanup_card_resources() call snd_card_free() at the last of its
    procedure.  This turned out to lead to a use-after-free.
    PCM runtimes have been already removed via soc_remove_pcm_runtimes(),
    while it's dereferenced later in soc_pcm_free() called via
    snd_card_free().
    
    The fix is simple: just move the snd_card_free() call to the beginning
    of the whole procedure.  This also gives another benefit: it
    guarantees that all operations have been shut down before actually
    releasing the resources, which was racy until now.
    
    Reported-and-tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: <stable@vger.kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index aae099c0e502..754e3ef8d7ae 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2286,6 +2286,9 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	list_for_each_entry(rtd, &card->rtd_list, list)
 		flush_delayed_work(&rtd->delayed_work);
 
+	/* free the ALSA card at first; this syncs with pending operations */
+	snd_card_free(card->snd_card);
+
 	/* remove and free each DAI */
 	soc_remove_dai_links(card);
 	soc_remove_pcm_runtimes(card);
@@ -2300,9 +2303,7 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	if (card->remove)
 		card->remove(card);
 
-	snd_card_free(card->snd_card);
 	return 0;
-
 }
 
 /* removes a socdev */

commit 5711c97920377827da4bbc18233ffb08c6e3bbef
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Apr 20 01:33:24 2017 +0000

    ASoC: soc-core: enable "dai-format" on snd_soc_of_parse_daifmt()
    
    Current snd_soc_of_parse_daifmt() detects [prefix]format, but
    "format" was unclear in some case. This patch checks "dai-format"
    first, and try to check "[prefix]format" if "dai-format" was not
    exist.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index aae099c0e502..ab7a07f86ab8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3960,11 +3960,15 @@ unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 		prefix = "";
 
 	/*
-	 * check "[prefix]format = xxx"
+	 * check "dai-format = xxx"
+	 * or    "[prefix]format = xxx"
 	 * SND_SOC_DAIFMT_FORMAT_MASK area
 	 */
-	snprintf(prop, sizeof(prop), "%sformat", prefix);
-	ret = of_property_read_string(np, prop, &str);
+	ret = of_property_read_string(np, "dai-format", &str);
+	if (ret < 0) {
+		snprintf(prop, sizeof(prop), "%sformat", prefix);
+		ret = of_property_read_string(np, prop, &str);
+	}
 	if (ret == 0) {
 		for (i = 0; i < ARRAY_SIZE(of_fmt_table); i++) {
 			if (strcmp(str, of_fmt_table[i].name) == 0) {

commit ad61dd303a0f2439bb104349e2d2ec91a3010ce0
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon May 8 15:57:50 2017 -0700

    scripts/spelling.txt: add regsiter -> register spelling mistake
    
    This typo is quite common.  Fix it and add it to the spelling file so
    that checkpatch catches it earlier.
    
    Link: http://lkml.kernel.org/r/20170317011131.6881-2-sboyd@codeaurora.org
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 525f2f397b4c..aae099c0e502 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -936,7 +936,7 @@ static struct snd_soc_component *soc_find_component(
  *
  * @dlc: name of the DAI and optional component info to match
  *
- * This function will search all regsitered components and their DAIs to
+ * This function will search all registered components and their DAIs to
  * find the DAI of the same name. The component's of_node and name
  * should also match if being specified.
  *

commit 258ced9d083f364572a4ecfdb6cdd188eff883af
Merge: 7b7b38495779 ea22a26e676e c12c1aad98bb fe3a980cd391 fd9f069d876d b3bbef45e975
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Apr 30 22:16:41 2017 +0900

    Merge remote-tracking branches 'asoc/topic/uda1380', 'asoc/topic/unregister', 'asoc/topic/ux500', 'asoc/topic/wm5100' and 'asoc/topic/wm8903' into asoc-next

commit 0c2964cb38ef9dc44c11db7516bab00c1967e52e
Merge: d872f04606ee 081dc8ab46df
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Apr 30 22:15:41 2017 +0900

    Merge remote-tracking branch 'asoc/topic/intel' into asoc-next

commit d872f04606eec35de3bc4e409e186d01dacdd3d6
Merge: 9dfc53942d04 991454e17070
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Apr 30 22:15:40 2017 +0900

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 861886d338f7dd802be972e770a695bba62f397a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 24 08:54:42 2017 +0200

    ASoC: Call snd_soc_set_dmi_name() unconditionally
    
    Since recently UCM can pick up a configuration specific to the board
    via card longname field, and we introduced a helper function
    snd_soc_set_dmi_name() for that.  So far, it was used only in one
    place (sound/soc/intel/boards/broadwell.c), but it should be more
    widely applied.
    
    This patch puts a big hammer for that: it lets snd_soc_register_card()
    calling snd_soc_set_dmi_name() unconditionally, so that all x86
    devices get the better longname string.  This would have no impact for
    other systems without DMI support, as snd_soc_set_dmi_name() is no-op
    on them.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 52f6d9c28df9..05c4d9564b0b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2192,6 +2192,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_add_routes(&card->dapm, card->of_dapm_routes,
 					card->num_of_dapm_routes);
 
+	/* try to set some sane longname if DMI is available */
+	snd_soc_set_dmi_name(card, NULL);
+
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
 		 "%s", card->name);
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),

commit 1f5a4535db41bd2bb8d1a15f098cb2921d6c1317
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 24 08:54:41 2017 +0200

    ASoC: Provide a dummy wrapper of snd_soc_set_dmi_name()
    
    For systems without DMI, it makes no sense to have the code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6dca408faae3..52f6d9c28df9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1918,6 +1918,7 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 EXPORT_SYMBOL_GPL(snd_soc_runtime_set_dai_fmt);
 
 
+#ifdef CONFIG_DMI
 /* Trim special characters, and replace '-' with '_' since '-' is used to
  * separate different DMI fields in the card long name. Only number and
  * alphabet characters and a few separator characters are kept.
@@ -2049,6 +2050,7 @@ int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_set_dmi_name);
+#endif /* CONFIG_DMI */
 
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {

commit c12c1aad98bb75b435e79c6208b56d2018b42f8b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Apr 3 06:31:22 2017 +0000

    ASoC: soc-core: verify Sound Card normality
    
    Current ALSA SoC Sound Card basically consists of CPU/Codec/Platform
    components. If system uses Kernel modules, we can disable these drivers
    by using rmmod command. In such case, we can't disable
    CPU/Codec/Platform driver without disabling Sound Card driver.
    
    But on the other hand, we can disable these drivers by using unbind
    command. In such case, we can disable these drivers randomly.
    In this case, we can create dirty Sound Card which is missing necessary
    components.
    
    (1) If user disabled Sound Card first, but did nothing to other drivers,
    user can't use Sound because Sound Card is no longer exists.
    (2) If user disabled CPU/Codec/Platform driver randomly, but did nothing
    to Sound Card, user still be able to use Sound Card, because dirty Sound
    Card still exists. In this case, Sound system will be crashed if user
    started sound playback/capture. But we can't block such random unbind
    now.
    
    To avoid Sound Card crash in (2) case, we need to unregister Sound Card
    whenever CPU/Codec/Platform component were unregistered.
    This patch solves this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f1901bb1466e..de6d5609c252 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3076,6 +3076,11 @@ static void snd_soc_component_cleanup(struct snd_soc_component *component)
 
 static void snd_soc_component_del_unlocked(struct snd_soc_component *component)
 {
+	struct snd_soc_card *card = component->card;
+
+	if (card)
+		snd_soc_unregister_card(card);
+
 	list_del(&component->list);
 }
 

commit 991454e17070eaf5286a666d9e896fd6fb332c72
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Mar 24 00:13:00 2017 +0000

    ASoC: core: remove pointless auxiliary from snd_soc_component
    
    commit 1a653aa44725 ("ASoC: core: replace aux_comp_list to ...")
    tried to replace aux_comp_list to component_dev_list,
    but it failed because of binding timing. Thus, Sylwester fixuped it by
    commit d2e3a1358c37 ("ASoC: Fix binding and probing of auxiliary...").
    
    One of main purpose of commit 1a653aa44725 ("ASoC: core: replace...")
    was remove replaceable list (= list_aux) from snd_soc_component by using
    new "auxiliary" flags (but it failed).
    Because of this background, current code has reborned card_aux_list
    (= same as original list_aux), and almost pointless "auxiliary" flags.
    
    Let's remove pointless "auxiliary" flags by this patch
    This means, it is same as revert both
    commit 1a653aa44725 ("ASoC: core: replace aux_comp_list to ...") and
    commit d2e3a1358c37 ("ASoC: Fix binding and probing of auxiliary...").
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d29fbc7195a0..a6f840beacb0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1776,7 +1776,6 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 	}
 
 	component->init = aux_dev->init;
-	component->auxiliary = 1;
 	list_add(&component->card_aux_list, &card->aux_comp_list);
 
 	return 0;
@@ -1788,14 +1787,13 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 
 static int soc_probe_aux_devices(struct snd_soc_card *card)
 {
-	struct snd_soc_component *comp, *tmp;
+	struct snd_soc_component *comp;
 	int order;
 	int ret;
 
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 		order++) {
-		list_for_each_entry_safe(comp, tmp, &card->aux_comp_list,
-					 card_aux_list) {
+		list_for_each_entry(comp, &card->aux_comp_list, card_aux_list) {
 			if (comp->driver->probe_order == order) {
 				ret = soc_probe_component(card,	comp);
 				if (ret < 0) {
@@ -1804,7 +1802,6 @@ static int soc_probe_aux_devices(struct snd_soc_card *card)
 						comp->name, ret);
 					return ret;
 				}
-				list_del(&comp->card_aux_list);
 			}
 		}
 	}
@@ -1820,14 +1817,12 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 		order++) {
 		list_for_each_entry_safe(comp, _comp,
-			&card->component_dev_list, card_list) {
-
-			if (!comp->auxiliary)
-				continue;
+			&card->aux_comp_list, card_aux_list) {
 
 			if (comp->driver->remove_order == order) {
 				soc_remove_component(comp);
-				comp->auxiliary = 0;
+				/* remove it from the card's aux_comp_list */
+				list_del(&comp->card_aux_list);
 			}
 		}
 	}

commit d6c098a1db468b7fd4635e831f276851dfd8852c
Author: Brian Norris <briannorris@chromium.org>
Date:   Wed Mar 8 15:18:54 2017 -0800

    ASoC: don't dereference NULL pcm_{new,free}
    
    Not all platform drivers have pcm_{new,free} callbacks. Seen with a
    "snd-soc-dummy" codec from sound/soc/rockchip/rk3399_gru_sound.c.
    
    Fixes: 99b04f4c4051 ("ASoC: add Component level pcm_new/pcm_free")
    Signed-off-by: Brian Norris <briannorris@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6dca408faae3..2722bb0c5573 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3326,7 +3326,10 @@ static int snd_soc_platform_drv_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_platform *platform = rtd->platform;
 
-	return platform->driver->pcm_new(rtd);
+	if (platform->driver->pcm_new)
+		return platform->driver->pcm_new(rtd);
+	else
+		return 0;
 }
 
 static void snd_soc_platform_drv_pcm_free(struct snd_pcm *pcm)
@@ -3334,7 +3337,8 @@ static void snd_soc_platform_drv_pcm_free(struct snd_pcm *pcm)
 	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
 	struct snd_soc_platform *platform = rtd->platform;
 
-	platform->driver->pcm_free(pcm);
+	if (platform->driver->pcm_free)
+		platform->driver->pcm_free(pcm);
 }
 
 /**

commit ec5a82d6c0b860bf4cba5c7ef8646ae5dad9f5a6
Author: Adrian Dinu <adrian.dinu95@gmail.com>
Date:   Sat Feb 25 13:23:00 2017 +0200

    ASoC: Add space around '='
    
    This was reported by checkpatch.pl
    
    Signed-off-by: Adrian Dinu <adrian.dinu95@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6dca408faae3..d29fbc7195a0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3139,7 +3139,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->suspend = component->driver->suspend;
 	component->resume = component->driver->resume;
 	component->pcm_new = component->driver->pcm_new;
-	component->pcm_free= component->driver->pcm_free;
+	component->pcm_free = component->driver->pcm_free;
 
 	dapm = &component->dapm;
 	dapm->dev = dev;

commit 5b5e0928f742cfa853b2411400a1b19fa379d758
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 27 14:30:02 2017 -0800

    lib/vsprintf.c: remove %Z support
    
    Now that %z is standartised in C99 there is no reason to support %Z.
    Unlike %L it doesn't even make format strings smaller.
    
    Use BUILD_BUG_ON in a couple ATM drivers.
    
    In case anyone didn't notice lib/vsprintf.o is about half of SLUB which
    is in my opinion is quite an achievement.  Hopefully this patch inspires
    someone else to trim vsprintf.c more.
    
    Link: http://lkml.kernel.org/r/20170103230126.GA30170@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a110d3987d4a..6dca408faae3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3041,7 +3041,7 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 	unsigned int i;
 	int ret;
 
-	dev_dbg(dev, "ASoC: dai register %s #%Zu\n", dev_name(dev), count);
+	dev_dbg(dev, "ASoC: dai register %s #%zu\n", dev_name(dev), count);
 
 	component->dai_drv = dai_drv;
 

commit 96f0e8a5b0979255e64ee8431f8287a41dc79140
Merge: 59acd5dfcc1e e21ab17904ff 245c5c7b0863 d61b23daf0c6 4957b556f5e7 b07609cecaac
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:36:23 2017 +0000

    Merge remote-tracking branches 'asoc/topic/dwc', 'asoc/topic/es8328', 'asoc/topic/fsl', 'asoc/topic/fsl-sai' and 'asoc/topic/graph' into asoc-next

commit 59acd5dfcc1e786273beba2edb8645eb3ef01285
Merge: b7707a8be6a7 3f81d9aa80ae d6075c260180 8abab35f9a58
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:36:18 2017 +0000

    Merge remote-tracking branches 'asoc/topic/davinci', 'asoc/topic/debugfs' and 'asoc/topic/doc' into asoc-next

commit b7707a8be6a79b7ea2103c92da5ed5a56e9ba26d
Merge: a2d64282dd11 ca8c7f233fa2 8480ac567959 31489c0b1d8b ac29a8f41740
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:36:13 2017 +0000

    Merge remote-tracking branches 'asoc/topic/atmel', 'asoc/topic/chmap', 'asoc/topic/cq93vc' and 'asoc/topic/da7218' into asoc-next

commit 16b5711485b0eba250451b3a85ab869939f20c7d
Merge: c7bb6d8060ee 7ba8ba3f4f96
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:35:45 2017 +0000

    Merge remote-tracking branch 'asoc/topic/intel' into asoc-next

commit 4ae8be8ea9f7b46f339b8481c265256ffd412567
Merge: 39bc30f25329 96241bae08f6
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:35:41 2017 +0000

    Merge remote-tracking branch 'asoc/topic/component' into asoc-next

commit d6075c2601800a8a45bf6f7c3d87afa8598779b5
Author: Daniel Baluta <daniel.baluta@nxp.com>
Date:   Wed Feb 1 15:37:35 2017 +0200

    ASoC: Drop unnecessary debugfs ifdef
    
    This is a relict of 6553bf06a369 ("ASoC: Don't try to register debugfs
    entries if the parent does not exist").
    
    Signed-off-by: Daniel Baluta <daniel.baluta@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f1901bb1466e..7728cce019f9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4020,8 +4020,6 @@ static void __exit snd_soc_exit(void)
 	snd_soc_util_exit();
 	snd_soc_debugfs_exit();
 
-#ifdef CONFIG_DEBUG_FS
-#endif
 	platform_driver_unregister(&soc_driver);
 }
 module_exit(snd_soc_exit);

commit b07609cecaac6681a2fca3eebc1bae7b00282620
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 27 06:37:51 2017 +0000

    ASoC: soc-core: remove OF adjusting for snd_soc_of_parse_card_name
    
    Because prototype of OF-graph sound card support didn't have Sound Card
    node, commit 8f5ebb1bee15b5720741a98414767bb86f6c2b23
    ("ASoC: soc-core: adjust for graph on snd_soc_of_parse_card_name")
    adjusted to it on each functions.
    
    But final discussion result of ALSA SoC / OF-graph ML, OF-graph sound
    card has node. Thus, this commit became no longer needed.
    
    This reverts commit 8f5ebb1bee15b5720741a98414767bb86f6c2b23.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4ff2448f6023..ebaebc7c9699 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3492,10 +3492,10 @@ void snd_soc_unregister_codec(struct device *dev)
 EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
 
 /* Retrieve a card's name from device tree */
-int snd_soc_of_parse_card_name_from_node(struct snd_soc_card *card,
-					 struct device_node *np,
-					 const char *propname)
+int snd_soc_of_parse_card_name(struct snd_soc_card *card,
+			       const char *propname)
 {
+	struct device_node *np;
 	int ret;
 
 	if (!card->dev) {
@@ -3503,8 +3503,7 @@ int snd_soc_of_parse_card_name_from_node(struct snd_soc_card *card,
 		return -EINVAL;
 	}
 
-	if (!np)
-		np = card->dev->of_node;
+	np = card->dev->of_node;
 
 	ret = of_property_read_string_index(np, propname, 0, &card->name);
 	/*
@@ -3521,7 +3520,7 @@ int snd_soc_of_parse_card_name_from_node(struct snd_soc_card *card,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_of_parse_card_name_from_node);
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_card_name);
 
 static const struct snd_soc_dapm_widget simple_widgets[] = {
 	SND_SOC_DAPM_MIC("Microphone", NULL),

commit 440a3006f154a3aca4badf72841c61ac93a72110
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 27 06:37:16 2017 +0000

    ASoC: soc-core: remove OF adjusting for snd_soc_of_parse_audio_prefix
    
    Because prototype of OF-graph sound card support didn't have Sound Card
    node, commit b6defcca0a604129155ae472b116a2e1688d8995
    ("ASoC: soc-core: adjust for graph on snd_soc_of_parse_audio_prefix")
    adjusted to it on each functions.
    
    But final discussion result of ALSA SoC / OF-graph ML, OF-graph sound
    card has node. Thus, this commit became no longer needed.
    
    This reverts commit b6defcca0a604129155ae472b116a2e1688d8995.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 656a981f6eb1..4ff2448f6023 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3664,18 +3664,15 @@ int snd_soc_of_parse_tdm_slot(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_tdm_slot);
 
-void snd_soc_of_parse_audio_prefix_from_node(struct snd_soc_card *card,
-				   struct device_node *np,
+void snd_soc_of_parse_audio_prefix(struct snd_soc_card *card,
 				   struct snd_soc_codec_conf *codec_conf,
 				   struct device_node *of_node,
 				   const char *propname)
 {
+	struct device_node *np = card->dev->of_node;
 	const char *str;
 	int ret;
 
-	if (!np)
-		np = card->dev->of_node;
-
 	ret = of_property_read_string(np, propname, &str);
 	if (ret < 0) {
 		/* no prefix is not error */
@@ -3685,7 +3682,7 @@ void snd_soc_of_parse_audio_prefix_from_node(struct snd_soc_card *card,
 	codec_conf->of_node	= of_node;
 	codec_conf->name_prefix	= str;
 }
-EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_prefix_from_node);
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_prefix);
 
 int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname)

commit 21efde50ca9cba9230d1b1ea54aadbf6d96c4157
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 27 06:37:34 2017 +0000

    ASoC: soc-core: remove OF adjusting for snd_soc_of_parse_audio_simple_widgets
    
    Because prototype of OF-graph sound card support didn't have Sound Card
    node, commit 1ef5bcd57be5c8b31286b7b47828064be25f266b
    ("ASoC: soc-core: adjust for graph on snd_soc_of_parse_audio_simple_widgets")
    adjusted to it on each functions.
    
    But final discussion result of ALSA SoC / OF-graph ML, OF-graph sound
    card has node. Thus, this commit became no longer needed.
    
    This reverts commit 1ef5bcd57be5c8b31286b7b47828064be25f266b.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e30984fd649b..656a981f6eb1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3530,17 +3530,14 @@ static const struct snd_soc_dapm_widget simple_widgets[] = {
 	SND_SOC_DAPM_SPK("Speaker", NULL),
 };
 
-int snd_soc_of_parse_audio_simple_widgets_from_node(struct snd_soc_card *card,
-					  struct device_node *np,
+int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
 					  const char *propname)
 {
+	struct device_node *np = card->dev->of_node;
 	struct snd_soc_dapm_widget *widgets;
 	const char *template, *wname;
 	int i, j, num_widgets, ret;
 
-	if (!np)
-		np = card->dev->of_node;
-
 	num_widgets = of_property_count_strings(np, propname);
 	if (num_widgets < 0) {
 		dev_err(card->dev,
@@ -3611,7 +3608,7 @@ int snd_soc_of_parse_audio_simple_widgets_from_node(struct snd_soc_card *card,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets_from_node);
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets);
 
 static int snd_soc_of_get_slot_mask(struct device_node *np,
 				    const char *prop_name,

commit 2bc644af610f28d05812f224636a95a57c2631d1
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Jan 27 06:36:50 2017 +0000

    ASoC: soc-core: remove OF adjusting for snd_soc_of_parse_audio_routing
    
    Because prototype of OF-graph sound card support didn't have Sound Card
    node, commit 7364c8dc255232db33bcd1c5b19eb8f34cf6108a
    ("ASoC: soc-core: adjust for graph on snd_soc_of_parse_audio_routing")
    adjusted to it on each functions.
    
    But final discussion result of ALSA SoC / OF-graph ML, OF-graph sound
    card has node. Thus, this commit became no longer needed.
    
    This reverts commit 7364c8dc255232db33bcd1c5b19eb8f34cf6108a.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f1901bb1466e..e30984fd649b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3690,17 +3690,14 @@ void snd_soc_of_parse_audio_prefix_from_node(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_prefix_from_node);
 
-int snd_soc_of_parse_audio_routing_from_node(struct snd_soc_card *card,
-				   struct device_node *np,
+int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname)
 {
+	struct device_node *np = card->dev->of_node;
 	int num_routes;
 	struct snd_soc_dapm_route *routes;
 	int i, ret;
 
-	if (!np)
-		np = card->dev->of_node;
-
 	num_routes = of_property_count_strings(np, propname);
 	if (num_routes < 0 || num_routes & 1) {
 		dev_err(card->dev,
@@ -3747,7 +3744,7 @@ int snd_soc_of_parse_audio_routing_from_node(struct snd_soc_card *card,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_routing_from_node);
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_routing);
 
 unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 				     const char *prefix,

commit 25f7b701c20db3e9ae09e28dd652949bd977e5cd
Author: Arnaud Pouliquen <arnaud.pouliquen@st.com>
Date:   Tue Jan 3 16:52:51 2017 +0100

    ASoC: core: add optional pcm_new callback for DAI driver
    
    During probe, DAIs can need to perform some actions that requests
    the knowledge of the pcm runtime handle.
    The callback is called during DAIs linking, after PCM device creation.
    For instance this can be used to add relationship between a DAI pcm
    control and the pcm device.
    
    Signed-off-by: Arnaud Pouliquen <arnaud.pouliquen@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f1901bb1466e..32b8c42be796 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1593,6 +1593,27 @@ static int soc_probe_dai(struct snd_soc_dai *dai, int order)
 	return 0;
 }
 
+static int soc_link_dai_pcm_new(struct snd_soc_dai **dais, int num_dais,
+				struct snd_soc_pcm_runtime *rtd)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < num_dais; ++i) {
+		struct snd_soc_dai_driver *drv = dais[i]->driver;
+
+		if (!rtd->dai_link->no_pcm && drv->pcm_new)
+			ret = drv->pcm_new(rtd, dais[i]);
+		if (ret < 0) {
+			dev_err(dais[i]->dev,
+				"ASoC: Failed to bind %s with pcm device\n",
+				dais[i]->name);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static int soc_link_dai_widgets(struct snd_soc_card *card,
 				struct snd_soc_dai_link *dai_link,
 				struct snd_soc_pcm_runtime *rtd)
@@ -1704,6 +1725,13 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 				       dai_link->stream_name, ret);
 				return ret;
 			}
+			ret = soc_link_dai_pcm_new(&cpu_dai, 1, rtd);
+			if (ret < 0)
+				return ret;
+			ret = soc_link_dai_pcm_new(rtd->codec_dais,
+						   rtd->num_codecs, rtd);
+			if (ret < 0)
+				return ret;
 		} else {
 			INIT_DELAYED_WORK(&rtd->delayed_work,
 						codec2codec_close_delayed_work);

commit 345233d7c6be80d4124140f2a0993880c7ae2453
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Sat Jan 14 16:13:02 2017 +0800

    ASoC: core: Add API to use DMI name in sound card long name
    
    Intel DSP platform drivers are used by many different devices but are
    difficult for userspace to differentiate. This patch adds an API to allow
    the DMI name to be used in the sound card long name, thereby helping
    userspace load the correct UCM configuration. Usually machine drivers
    uses their own name as the sound card name (short name), and leave the
    long name and driver name blank. This API will use the DMI info like
    vendor, product and board to make up the card long name. If the machine
    driver has already explicitly set the long name, this API will do nothing.
    
    This patch also allows for further differentiation as many devices that
    share the same DMI name i.e. Minnowboards, UP boards may be configured
    with different codecs or firmwares. The API supports flavoring the DMI
    name into the card longname to provide the extra differentiation required
    for these devices.
    
    For Use Case Manager (UCM) in the user space, changing card long name by
    this API is backward compatible, since the card name does not change. For
    a given sound card, even if there is no device-specific UCM configuration
    file that uses the card long name, UCM will fall back to load the default
    configuration file that uses the card name.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f1901bb1466e..530a4dba0709 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -34,6 +34,7 @@
 #include <linux/ctype.h>
 #include <linux/slab.h>
 #include <linux/of.h>
+#include <linux/dmi.h>
 #include <sound/core.h>
 #include <sound/jack.h>
 #include <sound/pcm.h>
@@ -1888,6 +1889,139 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 }
 EXPORT_SYMBOL_GPL(snd_soc_runtime_set_dai_fmt);
 
+
+/* Trim special characters, and replace '-' with '_' since '-' is used to
+ * separate different DMI fields in the card long name. Only number and
+ * alphabet characters and a few separator characters are kept.
+ */
+static void cleanup_dmi_name(char *name)
+{
+	int i, j = 0;
+
+	for (i = 0; name[i]; i++) {
+		if (isalnum(name[i]) || (name[i] == '.')
+		    || (name[i] == '_'))
+			name[j++] = name[i];
+		else if (name[i] == '-')
+			name[j++] = '_';
+	}
+
+	name[j] = '\0';
+}
+
+/**
+ * snd_soc_set_dmi_name() - Register DMI names to card
+ * @card: The card to register DMI names
+ * @flavour: The flavour "differentiator" for the card amongst its peers.
+ *
+ * An Intel machine driver may be used by many different devices but are
+ * difficult for userspace to differentiate, since machine drivers ususally
+ * use their own name as the card short name and leave the card long name
+ * blank. To differentiate such devices and fix bugs due to lack of
+ * device-specific configurations, this function allows DMI info to be used
+ * as the sound card long name, in the format of
+ * "vendor-product-version-board"
+ * (Character '-' is used to separate different DMI fields here).
+ * This will help the user space to load the device-specific Use Case Manager
+ * (UCM) configurations for the card.
+ *
+ * Possible card long names may be:
+ * DellInc.-XPS139343-01-0310JH
+ * ASUSTeKCOMPUTERINC.-T100TA-1.0-T100TA
+ * Circuitco-MinnowboardMaxD0PLATFORM-D0-MinnowBoardMAX
+ *
+ * This function also supports flavoring the card longname to provide
+ * the extra differentiation, like "vendor-product-version-board-flavor".
+ *
+ * We only keep number and alphabet characters and a few separator characters
+ * in the card long name since UCM in the user space uses the card long names
+ * as card configuration directory names and AudoConf cannot support special
+ * charactors like SPACE.
+ *
+ * Returns 0 on success, otherwise a negative error code.
+ */
+int snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)
+{
+	const char *vendor, *product, *product_version, *board;
+	size_t longname_buf_size = sizeof(card->snd_card->longname);
+	size_t len;
+
+	if (card->long_name)
+		return 0; /* long name already set by driver or from DMI */
+
+	/* make up dmi long name as: vendor.product.version.board */
+	vendor = dmi_get_system_info(DMI_BOARD_VENDOR);
+	if (!vendor) {
+		dev_warn(card->dev, "ASoC: no DMI vendor name!\n");
+		return 0;
+	}
+
+	snprintf(card->dmi_longname, sizeof(card->snd_card->longname),
+			 "%s", vendor);
+	cleanup_dmi_name(card->dmi_longname);
+
+	product = dmi_get_system_info(DMI_PRODUCT_NAME);
+	if (product) {
+		len = strlen(card->dmi_longname);
+		snprintf(card->dmi_longname + len,
+			 longname_buf_size - len,
+			 "-%s", product);
+
+		len++;	/* skip the separator "-" */
+		if (len < longname_buf_size)
+			cleanup_dmi_name(card->dmi_longname + len);
+
+		/* some vendors like Lenovo may only put a self-explanatory
+		 * name in the product version field
+		 */
+		product_version = dmi_get_system_info(DMI_PRODUCT_VERSION);
+		if (product_version) {
+			len = strlen(card->dmi_longname);
+			snprintf(card->dmi_longname + len,
+				 longname_buf_size - len,
+				 "-%s", product_version);
+
+			len++;
+			if (len < longname_buf_size)
+				cleanup_dmi_name(card->dmi_longname + len);
+		}
+	}
+
+	board = dmi_get_system_info(DMI_BOARD_NAME);
+	if (board) {
+		len = strlen(card->dmi_longname);
+		snprintf(card->dmi_longname + len,
+			 longname_buf_size - len,
+			 "-%s", board);
+
+		len++;
+		if (len < longname_buf_size)
+			cleanup_dmi_name(card->dmi_longname + len);
+	} else if (!product) {
+		/* fall back to using legacy name */
+		dev_warn(card->dev, "ASoC: no DMI board/product name!\n");
+		return 0;
+	}
+
+	/* Add flavour to dmi long name */
+	if (flavour) {
+		len = strlen(card->dmi_longname);
+		snprintf(card->dmi_longname + len,
+			 longname_buf_size - len,
+			 "-%s", flavour);
+
+		len++;
+		if (len < longname_buf_size)
+			cleanup_dmi_name(card->dmi_longname + len);
+	}
+
+	/* set the card long name */
+	card->long_name = card->dmi_longname;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_dmi_name);
+
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_codec *codec;

commit 8abab35f9a58e15b1f90a1371da69a207e40fc3b
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Jan 12 11:38:15 2017 +0000

    ASoC: Fixup some small kernel-doc typos
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f1901bb1466e..24dc443ec019 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -979,7 +979,7 @@ EXPORT_SYMBOL_GPL(snd_soc_find_dai);
  * @card: soc card
  * @id: DAI link ID to match
  * @name: DAI link name to match, optional
- * @stream name: DAI link stream name to match, optional
+ * @stream_name: DAI link stream name to match, optional
  *
  * This function will search all existing DAI links of the soc card to
  * find the link of the same ID. Since DAI links may not have their

commit d2e3a1358c37cd82eef92b5e908b4f0472194481
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Thu Dec 29 14:11:21 2016 +0100

    ASoC: Fix binding and probing of auxiliary components
    
    Currently binding of auxiliary devices doesn't work as in
    soc_bind_aux_dev() function a bound component is not being added
    to any list and in soc_probe_aux_devices() we are trying to walk
    the component_dev_list list to probe auxiliary components but
    at that time this list doesn't contain any auxiliary components
    since they are being added to the card only in soc_probe_component().
    
    This patch adds a list to the card where are stored bound but not
    probed auxiliary devices, so that all aux devices can be probed.
    
    Fixes: 1a653aa44725 "ASoC: core: replace aux_comp_list to component_dev_list"
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f1901bb1466e..baa1afa41e3d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1748,6 +1748,7 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 
 	component->init = aux_dev->init;
 	component->auxiliary = 1;
+	list_add(&component->card_aux_list, &card->aux_comp_list);
 
 	return 0;
 
@@ -1758,16 +1759,14 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 
 static int soc_probe_aux_devices(struct snd_soc_card *card)
 {
-	struct snd_soc_component *comp;
+	struct snd_soc_component *comp, *tmp;
 	int order;
 	int ret;
 
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 		order++) {
-		list_for_each_entry(comp, &card->component_dev_list, card_list) {
-			if (!comp->auxiliary)
-				continue;
-
+		list_for_each_entry_safe(comp, tmp, &card->aux_comp_list,
+					 card_aux_list) {
 			if (comp->driver->probe_order == order) {
 				ret = soc_probe_component(card,	comp);
 				if (ret < 0) {
@@ -1776,6 +1775,7 @@ static int soc_probe_aux_devices(struct snd_soc_card *card)
 						comp->name, ret);
 					return ret;
 				}
+				list_del(&comp->card_aux_list);
 			}
 		}
 	}

commit 99b04f4c4051f71bc0665a66e11b8fbed17c8958
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Dec 15 08:41:38 2016 +0000

    ASoC: add Component level pcm_new/pcm_free
    
    In current ALSA SoC, Platform only has pcm_new/pcm_free feature,
    but it should be supported on Component level. This patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f1901bb1466e..981443e444d1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2976,6 +2976,8 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->remove = component->driver->remove;
 	component->suspend = component->driver->suspend;
 	component->resume = component->driver->resume;
+	component->pcm_new = component->driver->pcm_new;
+	component->pcm_free= component->driver->pcm_free;
 
 	dapm = &component->dapm;
 	dapm->dev = dev;
@@ -3158,6 +3160,21 @@ static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
 	platform->driver->remove(platform);
 }
 
+static int snd_soc_platform_drv_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_platform *platform = rtd->platform;
+
+	return platform->driver->pcm_new(rtd);
+}
+
+static void snd_soc_platform_drv_pcm_free(struct snd_pcm *pcm)
+{
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+
+	platform->driver->pcm_free(pcm);
+}
+
 /**
  * snd_soc_add_platform - Add a platform to the ASoC core
  * @dev: The parent device for the platform
@@ -3181,6 +3198,10 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 		platform->component.probe = snd_soc_platform_drv_probe;
 	if (platform_drv->remove)
 		platform->component.remove = snd_soc_platform_drv_remove;
+	if (platform_drv->pcm_new)
+		platform->component.pcm_new = snd_soc_platform_drv_pcm_new;
+	if (platform_drv->pcm_free)
+		platform->component.pcm_free = snd_soc_platform_drv_pcm_free;
 
 #ifdef CONFIG_DEBUG_FS
 	platform->component.debugfs_prefix = "platform";

commit dc42c6cb309e09fb81c235350b3a7e7976caf52f
Merge: da644e2edea7 4e2cc814eb27 dd5abb742071 222e728ca29b 4090d63b49d7 f196e9ac07ed
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 12 15:53:25 2016 +0000

    Merge remote-tracking branches 'asoc/topic/tlv320aic31xx', 'asoc/topic/topology', 'asoc/topic/uda1380', 'asoc/topic/wm2200' and 'asoc/topic/wm8523' into asoc-next

commit 2f028b15a232737ba8dd5b883adcca3471a8280e
Merge: b8f04c194326 1ef5bcd57be5 92be58106e5d b4f89a0cce0d bf8e27621eff
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 12 15:53:07 2016 +0000

    Merge remote-tracking branches 'asoc/topic/of-graph', 'asoc/topic/pxa', 'asoc/topic/qcom' and 'asoc/topic/rk808' into asoc-next

commit 3f1b86139e94289289b00f745cc483b1fef5fd46
Merge: 66f89906f07e 06859fca4368
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 12 15:52:43 2016 +0000

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 9178feb4538e055bf22be44c38b90cc31d2baf99
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 30 06:23:13 2016 +0000

    ASoC: add Component level suspend/resume
    
    In current ALSA SoC, Codec only has suspend/resume feature,
    but it should be supported on Component level. This patch adds it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ba8e000faaf1..f35ec5bf3b78 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -702,43 +702,39 @@ int snd_soc_suspend(struct device *dev)
 	dapm_mark_endpoints_dirty(card);
 	snd_soc_dapm_sync(&card->dapm);
 
-	/* suspend all CODECs */
+	/* suspend all COMPONENTs */
 	list_for_each_entry(component, &card->component_dev_list, card_list) {
 		struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
-		struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
 
-		if (!codec)
-			continue;
-
-		/* If there are paths active then the CODEC will be held with
+		/* If there are paths active then the COMPONENT will be held with
 		 * bias _ON and should not be suspended. */
-		if (!codec->suspended) {
+		if (!component->suspended) {
 			switch (snd_soc_dapm_get_bias_level(dapm)) {
 			case SND_SOC_BIAS_STANDBY:
 				/*
-				 * If the CODEC is capable of idle
+				 * If the COMPONENT is capable of idle
 				 * bias off then being in STANDBY
 				 * means it's doing something,
 				 * otherwise fall through.
 				 */
 				if (dapm->idle_bias_off) {
-					dev_dbg(codec->dev,
+					dev_dbg(component->dev,
 						"ASoC: idle_bias_off CODEC on over suspend\n");
 					break;
 				}
 
 			case SND_SOC_BIAS_OFF:
-				if (codec->driver->suspend)
-					codec->driver->suspend(codec);
-				codec->suspended = 1;
-				if (codec->component.regmap)
-					regcache_mark_dirty(codec->component.regmap);
+				if (component->suspend)
+					component->suspend(component);
+				component->suspended = 1;
+				if (component->regmap)
+					regcache_mark_dirty(component->regmap);
 				/* deactivate pins to sleep state */
-				pinctrl_pm_select_sleep_state(codec->dev);
+				pinctrl_pm_select_sleep_state(component->dev);
 				break;
 			default:
-				dev_dbg(codec->dev,
-					"ASoC: CODEC is on over suspend\n");
+				dev_dbg(component->dev,
+					"ASoC: COMPONENT is on over suspend\n");
 				break;
 			}
 		}
@@ -799,15 +795,10 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	list_for_each_entry(component, &card->component_dev_list, card_list) {
-		struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-		if (!codec)
-			continue;
-
-		if (codec->suspended) {
-			if (codec->driver->resume)
-				codec->driver->resume(codec);
-			codec->suspended = 0;
+		if (component->suspended) {
+			if (component->resume)
+				component->resume(component);
+			component->suspended = 0;
 		}
 	}
 
@@ -2937,6 +2928,8 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->driver = driver;
 	component->probe = component->driver->probe;
 	component->remove = component->driver->remove;
+	component->suspend = component->driver->suspend;
+	component->resume = component->driver->resume;
 
 	dapm = &component->dapm;
 	dapm->dev = dev;
@@ -3286,6 +3279,20 @@ static void snd_soc_codec_drv_remove(struct snd_soc_component *component)
 	codec->driver->remove(codec);
 }
 
+static int snd_soc_codec_drv_suspend(struct snd_soc_component *component)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+	return codec->driver->suspend(codec);
+}
+
+static int snd_soc_codec_drv_resume(struct snd_soc_component *component)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+	return codec->driver->resume(codec);
+}
+
 static int snd_soc_codec_drv_write(struct snd_soc_component *component,
 	unsigned int reg, unsigned int val)
 {
@@ -3347,6 +3354,10 @@ int snd_soc_register_codec(struct device *dev,
 		codec->component.probe = snd_soc_codec_drv_probe;
 	if (codec_drv->remove)
 		codec->component.remove = snd_soc_codec_drv_remove;
+	if (codec_drv->suspend)
+		codec->component.suspend = snd_soc_codec_drv_suspend;
+	if (codec_drv->resume)
+		codec->component.resume = snd_soc_codec_drv_resume;
 	if (codec_drv->write)
 		codec->component.write = snd_soc_codec_drv_write;
 	if (codec_drv->read)

commit 1a653aa44725668590b36bbe2d7fe4736a69f055
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 30 06:22:55 2016 +0000

    ASoC: core: replace aux_comp_list to component_dev_list
    
    Now, Card has component_dev_list, we can replace aux_comp_list
    to component_dev_list with new auxiliary flags
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d204bb772f00..ba8e000faaf1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1710,7 +1710,8 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 	}
 
 	component->init = aux_dev->init;
-	list_add(&component->list_aux, &card->aux_comp_list);
+	component->auxiliary = 1;
+
 	return 0;
 
 err_defer:
@@ -1726,7 +1727,10 @@ static int soc_probe_aux_devices(struct snd_soc_card *card)
 
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 		order++) {
-		list_for_each_entry(comp, &card->aux_comp_list, list_aux) {
+		list_for_each_entry(comp, &card->component_dev_list, card_list) {
+			if (!comp->auxiliary)
+				continue;
+
 			if (comp->driver->probe_order == order) {
 				ret = soc_probe_component(card,	comp);
 				if (ret < 0) {
@@ -1750,11 +1754,14 @@ static void soc_remove_aux_devices(struct snd_soc_card *card)
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 		order++) {
 		list_for_each_entry_safe(comp, _comp,
-			&card->aux_comp_list, list_aux) {
+			&card->component_dev_list, card_list) {
+
+			if (!comp->auxiliary)
+				continue;
+
 			if (comp->driver->remove_order == order) {
 				soc_remove_component(comp);
-				/* remove it from the card's aux_comp_list */
-				list_del(&comp->list_aux);
+				comp->auxiliary = 0;
 			}
 		}
 	}

commit d9fc40639dc1b87915426d2ef489a591b0fd650b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Nov 30 06:22:36 2016 +0000

    ASoC: core: replace codec_dev_list to component_dev_list on Card
    
    Current Card has Codec list (= codec_dev_list), but Codec will be
    removed in the future. Because of this reason, this patch adds
    new Component list in Card, and replace Codec list.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0bbcd903261..d204bb772f00 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -626,7 +626,7 @@ static void codec2codec_close_delayed_work(struct work_struct *work)
 int snd_soc_suspend(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
-	struct snd_soc_codec *codec;
+	struct snd_soc_component *component;
 	struct snd_soc_pcm_runtime *rtd;
 	int i;
 
@@ -703,8 +703,12 @@ int snd_soc_suspend(struct device *dev)
 	snd_soc_dapm_sync(&card->dapm);
 
 	/* suspend all CODECs */
-	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
-		struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	list_for_each_entry(component, &card->component_dev_list, card_list) {
+		struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+		struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+		if (!codec)
+			continue;
 
 		/* If there are paths active then the CODEC will be held with
 		 * bias _ON and should not be suspended. */
@@ -768,7 +772,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	struct snd_soc_card *card =
 			container_of(work, struct snd_soc_card, deferred_resume_work);
 	struct snd_soc_pcm_runtime *rtd;
-	struct snd_soc_codec *codec;
+	struct snd_soc_component *component;
 	int i;
 
 	/* our power state is still SNDRV_CTL_POWER_D3hot from suspend time,
@@ -794,7 +798,12 @@ static void soc_resume_deferred(struct work_struct *work)
 			cpu_dai->driver->resume(cpu_dai);
 	}
 
-	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
+	list_for_each_entry(component, &card->component_dev_list, card_list) {
+		struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+		if (!codec)
+			continue;
+
 		if (codec->suspended) {
 			if (codec->driver->resume)
 				codec->driver->resume(codec);
@@ -1072,9 +1081,7 @@ static void soc_remove_component(struct snd_soc_component *component)
 	if (!component->card)
 		return;
 
-	/* This is a HACK and will be removed soon */
-	if (component->codec)
-		list_del(&component->codec->card_list);
+	list_del(&component->card_list);
 
 	if (component->remove)
 		component->remove(component);
@@ -1443,10 +1450,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 					component->num_dapm_routes);
 
 	list_add(&dapm->list, &card->dapm_list);
-
-	/* This is a HACK and will be removed soon */
-	if (component->codec)
-		list_add(&component->codec->card_list, &card->codec_dev_list);
+	list_add(&component->card_list, &card->component_dev_list);
 
 	return 0;
 

commit 1ef5bcd57be5c8b31286b7b47828064be25f266b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Nov 11 01:18:08 2016 +0000

    ASoC: soc-core: adjust for graph on snd_soc_of_parse_audio_simple_widgets
    
    It is assuming that the card related information is located on
    "card" node, but graph case doesn't have it.
    This patch adds node parameter to adjust for graph support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 17132fb57930..6f911f4d413a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3462,14 +3462,17 @@ static const struct snd_soc_dapm_widget simple_widgets[] = {
 	SND_SOC_DAPM_SPK("Speaker", NULL),
 };
 
-int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
+int snd_soc_of_parse_audio_simple_widgets_from_node(struct snd_soc_card *card,
+					  struct device_node *np,
 					  const char *propname)
 {
-	struct device_node *np = card->dev->of_node;
 	struct snd_soc_dapm_widget *widgets;
 	const char *template, *wname;
 	int i, j, num_widgets, ret;
 
+	if (!np)
+		np = card->dev->of_node;
+
 	num_widgets = of_property_count_strings(np, propname);
 	if (num_widgets < 0) {
 		dev_err(card->dev,
@@ -3540,7 +3543,7 @@ int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets);
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets_from_node);
 
 static int snd_soc_of_get_slot_mask(struct device_node *np,
 				    const char *prop_name,

commit 8f5ebb1bee15b5720741a98414767bb86f6c2b23
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Nov 11 01:17:27 2016 +0000

    ASoC: soc-core: adjust for graph on snd_soc_of_parse_card_name
    
    It is assuming that the card related information is located on
    "card" node, but graph case doesn't have it.
    This patch adds node parameter to adjust for graph support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e4c90806fa10..17132fb57930 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3424,10 +3424,10 @@ void snd_soc_unregister_codec(struct device *dev)
 EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
 
 /* Retrieve a card's name from device tree */
-int snd_soc_of_parse_card_name(struct snd_soc_card *card,
-			       const char *propname)
+int snd_soc_of_parse_card_name_from_node(struct snd_soc_card *card,
+					 struct device_node *np,
+					 const char *propname)
 {
-	struct device_node *np;
 	int ret;
 
 	if (!card->dev) {
@@ -3435,7 +3435,8 @@ int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 		return -EINVAL;
 	}
 
-	np = card->dev->of_node;
+	if (!np)
+		np = card->dev->of_node;
 
 	ret = of_property_read_string_index(np, propname, 0, &card->name);
 	/*
@@ -3452,7 +3453,7 @@ int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_of_parse_card_name);
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_card_name_from_node);
 
 static const struct snd_soc_dapm_widget simple_widgets[] = {
 	SND_SOC_DAPM_MIC("Microphone", NULL),

commit b6defcca0a604129155ae472b116a2e1688d8995
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Nov 11 01:19:03 2016 +0000

    ASoC: soc-core: adjust for graph on snd_soc_of_parse_audio_prefix
    
    It is assuming that the card related information is located on
    "card" node, but graph case doesn't have it.
    This patch adds node parameter to adjust for graph support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 81b604151f26..e4c90806fa10 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3595,15 +3595,18 @@ int snd_soc_of_parse_tdm_slot(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_tdm_slot);
 
-void snd_soc_of_parse_audio_prefix(struct snd_soc_card *card,
+void snd_soc_of_parse_audio_prefix_from_node(struct snd_soc_card *card,
+				   struct device_node *np,
 				   struct snd_soc_codec_conf *codec_conf,
 				   struct device_node *of_node,
 				   const char *propname)
 {
-	struct device_node *np = card->dev->of_node;
 	const char *str;
 	int ret;
 
+	if (!np)
+		np = card->dev->of_node;
+
 	ret = of_property_read_string(np, propname, &str);
 	if (ret < 0) {
 		/* no prefix is not error */
@@ -3613,7 +3616,7 @@ void snd_soc_of_parse_audio_prefix(struct snd_soc_card *card,
 	codec_conf->of_node	= of_node;
 	codec_conf->name_prefix	= str;
 }
-EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_prefix);
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_prefix_from_node);
 
 int snd_soc_of_parse_audio_routing_from_node(struct snd_soc_card *card,
 				   struct device_node *np,

commit 1ad8ec535b997ed36c0f32c2616206725258dd30
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Nov 11 01:19:28 2016 +0000

    ASoC: soc-core: snd_soc_get_dai_name() become non static
    
    snd_soc_get_dai_name() is used from snd_soc_of_get_dai_name(),
    and it is assuming that DT is using "sound-dai" / "#sound-dai-cells".
    But graph base DT is using "remote-endpoint". This patch makes
    snd_soc_get_dai_name() non static for graph support.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ec881b8825b6..81b604151f26 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3787,7 +3787,7 @@ unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_daifmt);
 
-static int snd_soc_get_dai_name(struct of_phandle_args *args,
+int snd_soc_get_dai_name(struct of_phandle_args *args,
 				const char **dai_name)
 {
 	struct snd_soc_component *pos;
@@ -3839,6 +3839,7 @@ static int snd_soc_get_dai_name(struct of_phandle_args *args,
 	mutex_unlock(&client_mutex);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(snd_soc_get_dai_name);
 
 int snd_soc_of_get_dai_name(struct device_node *of_node,
 			    const char **dai_name)

commit 7364c8dc255232db33bcd1c5b19eb8f34cf6108a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Nov 11 01:18:35 2016 +0000

    ASoC: soc-core: adjust for graph on snd_soc_of_parse_audio_routing
    
    It is assuming that the card related information is located on
    "card" node, but graph case doesn't have it.
    This patch adds node parameter to adjust for graph support
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0bbcd903261..ec881b8825b6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3615,14 +3615,17 @@ void snd_soc_of_parse_audio_prefix(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_prefix);
 
-int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
+int snd_soc_of_parse_audio_routing_from_node(struct snd_soc_card *card,
+				   struct device_node *np,
 				   const char *propname)
 {
-	struct device_node *np = card->dev->of_node;
 	int num_routes;
 	struct snd_soc_dapm_route *routes;
 	int i, ret;
 
+	if (!np)
+		np = card->dev->of_node;
+
 	num_routes = of_property_count_strings(np, propname);
 	if (num_routes < 0 || num_routes & 1) {
 		dev_err(card->dev,
@@ -3669,7 +3672,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_routing);
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_routing_from_node);
 
 unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 				     const char *prefix,

commit 06859fca4368c407d4acccf3948b8b825db5e569
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Nov 7 13:03:17 2016 +0000

    ASoC: core: If a platform doesn't have an of_node use parent's node
    
    Support was added to allow location of both CPU and CODEC components
    of a DAI link from their parent's of_node if they did not have an
    of_node themselves in this commit:
    
    commit 3e0aa8d83bf8 ("ASoC: core: If component doesn't have of_node
                          use parent's node instead")
    
    However this leaves platforms as something of a special case as the
    major DAI component that doesn't do this. Since this is useful for MFD
    devices which often utilise a single device tree entry for the whole
    device, add support for looking up platforms from the parent's of_node
    as well.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0bbcd903261..26da0466126d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -993,6 +993,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_dai **codec_dais;
 	struct snd_soc_platform *platform;
+	struct device_node *platform_of_node;
 	const char *platform_name;
 	int i;
 
@@ -1042,9 +1043,12 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 	/* find one from the set of registered platforms */
 	list_for_each_entry(platform, &platform_list, list) {
+		platform_of_node = platform->dev->of_node;
+		if (!platform_of_node && platform->dev->parent->of_node)
+			platform_of_node = platform->dev->parent->of_node;
+
 		if (dai_link->platform_of_node) {
-			if (platform->dev->of_node !=
-			    dai_link->platform_of_node)
+			if (platform_of_node != dai_link->platform_of_node)
 				continue;
 		} else {
 			if (strcmp(platform->component.name, platform_name))

commit 17fb175520e5497d71351aa66a125324fcb625a7
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Thu Nov 3 01:04:12 2016 +0800

    ASoC: Define API to find a dai link
    
    Define the API to find an existing DAI link of the soc card by matching
    the ID, name and stream name.
    
    Some cards may use unique ID for each DAI link, so matching ID is enough,
    and name or stream name are not necessary. But user need to specify name
    or stream name as well if not sure whether link ID is unique since most
    cards use 0 as the default link ID.
    
    Topology can use this API to find an existing BE link and configure it.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0bbcd903261..a7a1ca40bcf5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -972,6 +972,48 @@ struct snd_soc_dai *snd_soc_find_dai(
 }
 EXPORT_SYMBOL_GPL(snd_soc_find_dai);
 
+
+/**
+ * snd_soc_find_dai_link - Find a DAI link
+ *
+ * @card: soc card
+ * @id: DAI link ID to match
+ * @name: DAI link name to match, optional
+ * @stream name: DAI link stream name to match, optional
+ *
+ * This function will search all existing DAI links of the soc card to
+ * find the link of the same ID. Since DAI links may not have their
+ * unique ID, so name and stream name should also match if being
+ * specified.
+ *
+ * Return: pointer of DAI link, or NULL if not found.
+ */
+struct snd_soc_dai_link *snd_soc_find_dai_link(struct snd_soc_card *card,
+					       int id, const char *name,
+					       const char *stream_name)
+{
+	struct snd_soc_dai_link *link, *_link;
+
+	lockdep_assert_held(&client_mutex);
+
+	list_for_each_entry_safe(link, _link, &card->dai_link_list, list) {
+		if (link->id != id)
+			continue;
+
+		if (name && (!link->name || strcmp(name, link->name)))
+			continue;
+
+		if (stream_name && (!link->stream_name
+			|| strcmp(stream_name, link->stream_name)))
+			continue;
+
+		return link;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_find_dai_link);
+
 static bool soc_is_dai_link_bound(struct snd_soc_card *card,
 		struct snd_soc_dai_link *dai_link)
 {

commit 971dec826c211c8fef4ed5b6db2cb048873a020b
Merge: 3b495e4bf34b ec103964776b 519302954b72 9be072a6f918 1e8140309540
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Sep 29 12:44:31 2016 -0700

    Merge remote-tracking branches 'asoc/topic/nau8810', 'asoc/topic/of-bool', 'asoc/topic/omap' and 'asoc/topic/platform-drvdata' into asoc-next

commit 7c90fc73bf78aa1f390c65f86a43ffae543a248d
Merge: 81af726167a1 52abe54138d9 c14c59f2e9ca 8c7788f34e11 032ca4a76fc3 8180bd56bdd1
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Sep 29 12:44:07 2016 -0700

    Merge remote-tracking branches 'asoc/topic/ac97', 'asoc/topic/ak4104', 'asoc/topic/arizona', 'asoc/topic/atmel' and 'asoc/topic/codec-component' into asoc-next

commit e8f0f8aa4eb356bd729f15be8827db2558ea1ae6
Merge: d520519518de 3e103a65514c b0f12c61de01 5d764912a0ee d1e814288262
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Aug 24 19:05:22 2016 +0100

    Merge remote-tracking branches 'asoc/fix/atmel', 'asoc/fix/compress', 'asoc/fix/da7213' and 'asoc/fix/debugfs' into asoc-linus

commit d1e81428826221d7ff8e4d83db784d099cd232a7
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Aug 18 19:32:59 2016 +0100

    ASoC: core: Clean up DAPM before the card debugfs
    
    Both the card and DAPM cleanups recursively delete their debugfs
    directories.  Since the DAPM debugfs subdirectory for the card is
    located within the card debugfs this means we end up trying to double
    free the DAPM subdirectory.  Reorder the cleanup to free the card
    debugfs after we've cleaned up DAPM and it has deleted its own
    subdirectory.
    
    Reported-by: Russell King - ARM Linux <linux@armlinux.org.uk>
    Tested-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 16369cad4803..66a33f1e4881 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2083,14 +2083,13 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	/* remove auxiliary devices */
 	soc_remove_aux_devices(card);
 
+	snd_soc_dapm_free(&card->dapm);
 	soc_cleanup_card_debugfs(card);
 
 	/* remove the card */
 	if (card->remove)
 		card->remove(card);
 
-	snd_soc_dapm_free(&card->dapm);
-
 	snd_card_free(card->snd_card);
 	return 0;
 

commit 70fcad495b9903d362bdbf9ffba23259294064c8
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Aug 11 14:39:00 2016 +0100

    ASoC: Fix leak of rtd in soc_bind_dai_link
    
    If we fail to find a platform we simply return EPROBE_DEFER,
    but we have allocated the rtd pointer. All error paths before
    soc_add_pcm_runtime need to call soc_free_pcm_runtime first to
    avoid leaking the rtd pointer. A suitable error path already
    exists and is used else where in the function so simply use that
    here as well.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 16369cad4803..b0e23db83695 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1056,7 +1056,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	if (!rtd->platform) {
 		dev_err(card->dev, "ASoC: platform %s not registered\n",
 			dai_link->platform_name);
-		return -EPROBE_DEFER;
+		goto _err_defer;
 	}
 
 	soc_add_pcm_runtime(card, rtd);

commit 8073aefa60823acf205a1e6a5ea118297179d766
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Aug 8 09:36:49 2016 +0000

    ASoC: remove codec duplicated callback function
    
    codec driver and component driver has duplicated callback functions,
    and codec side functions are just copied to component side when
    register timing. This was quick-hack, but no longer needed.
    This patch removes codec side duplicated callback function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 16369cad4803..edba975d893e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3333,19 +3333,6 @@ int snd_soc_register_codec(struct device *dev,
 	if (ret)
 		goto err_free;
 
-	if (codec_drv->controls) {
-		codec->component.controls = codec_drv->controls;
-		codec->component.num_controls = codec_drv->num_controls;
-	}
-	if (codec_drv->dapm_widgets) {
-		codec->component.dapm_widgets = codec_drv->dapm_widgets;
-		codec->component.num_dapm_widgets = codec_drv->num_dapm_widgets;
-	}
-	if (codec_drv->dapm_routes) {
-		codec->component.dapm_routes = codec_drv->dapm_routes;
-		codec->component.num_dapm_routes = codec_drv->num_dapm_routes;
-	}
-
 	if (codec_drv->probe)
 		codec->component.probe = snd_soc_codec_drv_probe;
 	if (codec_drv->remove)

commit 519302954b726612eea6362047660cd56aa15c2e
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Aug 5 10:56:51 2016 +0200

    ASoC: use of_property_read_bool
    
    Use of_property_read_bool to check for the existence of a property.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression e1,e2;
    statement S2,S1;
    @@
    -       if (of_get_property(e1,e2,NULL))
    +       if (of_property_read_bool(e1,e2))
            S1 else S2
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 16369cad4803..ead49d032e4c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3733,7 +3733,7 @@ unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 	 * SND_SOC_DAIFMT_CLOCK_MASK area
 	 */
 	snprintf(prop, sizeof(prop), "%scontinuous-clock", prefix);
-	if (of_get_property(np, prop, NULL))
+	if (of_property_read_bool(np, prop))
 		format |= SND_SOC_DAIFMT_CONT;
 	else
 		format |= SND_SOC_DAIFMT_GATED;

commit fbb88b5ca1dc84416fc1fec34773948b6780492c
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Fri Apr 22 12:25:33 2016 +0800

    ASoC: Add kerneldoc comments for snd_soc_find_dai
    
    snd_soc_find_dai() has been exported and so add the kerneldoc comments
    for it.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 07663def2db6..16369cad4803 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -930,6 +930,17 @@ static struct snd_soc_component *soc_find_component(
 	return NULL;
 }
 
+/**
+ * snd_soc_find_dai - Find a registered DAI
+ *
+ * @dlc: name of the DAI and optional component info to match
+ *
+ * This function will search all regsitered components and their DAIs to
+ * find the DAI of the same name. The component's of_node and name
+ * should also match if being specified.
+ *
+ * Return: pointer of DAI, or NULL if not found.
+ */
 struct snd_soc_dai *snd_soc_find_dai(
 	const struct snd_soc_dai_link_component *dlc)
 {

commit 305e9020f09d28560373c0112682e6fd11e909f6
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Tue Apr 19 13:12:25 2016 +0800

    ASoC: Export snd_soc_find_dai()
    
    This API can be used by topology to find an existing BE dai by name
    and further configure it.
    
    Topology will also check DAI ID to avoid wrong match.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d2e62b159610..07663def2db6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -930,7 +930,7 @@ static struct snd_soc_component *soc_find_component(
 	return NULL;
 }
 
-static struct snd_soc_dai *snd_soc_find_dai(
+struct snd_soc_dai *snd_soc_find_dai(
 	const struct snd_soc_dai_link_component *dlc)
 {
 	struct snd_soc_component *component;
@@ -959,6 +959,7 @@ static struct snd_soc_dai *snd_soc_find_dai(
 
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(snd_soc_find_dai);
 
 static bool soc_is_dai_link_bound(struct snd_soc_card *card,
 		struct snd_soc_dai_link *dai_link)

commit 513cb31120fb5a5b02d9e42eb1d0a0bf05e227c5
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Feb 22 14:14:31 2016 +0530

    ASoC: fix memory leak
    
    If dai_link is already bound then we just returned and leaked rtd and
    rtd->codec_dais which were allocated by soc_new_pcm_runtime(). We do not
    need this newly allocated rtd to check if dai_link is already binded. Lets
    check first if it is already binded before allocating this memory.
    
    Signed-off-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 790ee2bf1a47..d2e62b159610 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -986,16 +986,16 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 	dev_dbg(card->dev, "ASoC: binding %s\n", dai_link->name);
 
-	rtd = soc_new_pcm_runtime(card, dai_link);
-	if (!rtd)
-		return -ENOMEM;
-
 	if (soc_is_dai_link_bound(card, dai_link)) {
 		dev_dbg(card->dev, "ASoC: dai link %s already bound\n",
 			dai_link->name);
 		return 0;
 	}
 
+	rtd = soc_new_pcm_runtime(card, dai_link);
+	if (!rtd)
+		return -ENOMEM;
+
 	cpu_dai_component.name = dai_link->cpu_name;
 	cpu_dai_component.of_node = dai_link->cpu_of_node;
 	cpu_dai_component.dai_name = dai_link->cpu_dai_name;

commit a1916ff3500db308bff5913996a62b0bf8c4a97e
Merge: 2dd49f8e6f20 f2ed6b07645e
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jan 11 13:54:31 2016 +0000

    Merge remote-tracking branch 'asoc/topic/pcm-list' into asoc-next

commit f2ed6b07645ed29c1e090ead2e41066385cba3ea
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Wed Jan 6 13:29:31 2016 +0800

    ASoC: Make aux_dev more like a generic component
    
    aux_dev is mainly used by the machine driver to specify analog devices,
    which are registered as codecs. Making it more like a generic component
    can help the machine driver to use it to specify any component with
    topology info by name.
    
    Details:
    - Remove the stub 'rtd_aux' array from the soc card.
    - Add a list 'aux_comp_list' to store the components of aux_devs.
      And add a list head 'list_aux' to struct snd_soc_component, for adding
      such components to the above list.
    - Add a 'init' ops to a component for machine specific init.
      soc_bind_aux_dev() will set it to be aux_dev's init. And it will be
      called when probing the component.
    - soc_bind_aux_dev() will also search components by name of an aux_dev,
      since it may not be a codec.
    - Move probing of aux_devs before checking new DAI links brought by
      topology.
    - Move removal of aux_devs later than removal of links. Because topology
      of aux components may register DAIs and the DAI drivers will go with
      removal of the aux components, we want soc_remove_link_dais() to remove
      the DAIs at first.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c572673a5a24..c10bd668659c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1413,6 +1413,16 @@ static int soc_probe_component(struct snd_soc_card *card,
 			component->name);
 	}
 
+	/* machine specific init */
+	if (component->init) {
+		ret = component->init(component);
+		if (ret < 0) {
+			dev_err(component->dev,
+				"Failed to do machine specific init %d\n", ret);
+			goto err_probe;
+		}
+	}
+
 	if (component->controls)
 		snd_soc_add_component_controls(component, component->controls,
 				     component->num_controls);
@@ -1657,65 +1667,81 @@ static int soc_probe_link_dais(struct snd_soc_card *card,
 
 static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 {
-	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
-	const char *name = aux_dev->codec_name;
-
-	rtd->component = soc_find_component(aux_dev->codec_of_node, name);
-	if (!rtd->component) {
-		if (aux_dev->codec_of_node)
-			name = of_node_full_name(aux_dev->codec_of_node);
-
-		dev_err(card->dev, "ASoC: %s not registered\n", name);
-		return -EPROBE_DEFER;
+	struct snd_soc_component *component;
+	const char *name;
+	struct device_node *codec_of_node;
+
+	if (aux_dev->codec_of_node || aux_dev->codec_name) {
+		/* codecs, usually analog devices */
+		name = aux_dev->codec_name;
+		codec_of_node = aux_dev->codec_of_node;
+		component = soc_find_component(codec_of_node, name);
+		if (!component) {
+			if (codec_of_node)
+				name = of_node_full_name(codec_of_node);
+			goto err_defer;
+		}
+	} else if (aux_dev->name) {
+		/* generic components */
+		name = aux_dev->name;
+		component = soc_find_component(NULL, name);
+		if (!component)
+			goto err_defer;
+	} else {
+		dev_err(card->dev, "ASoC: Invalid auxiliary device\n");
+		return -EINVAL;
 	}
 
-	/*
-	 * Some places still reference rtd->codec, so we have to keep that
-	 * initialized if the component is a CODEC. Once all those references
-	 * have been removed, this code can be removed as well.
-	 */
-	 rtd->codec = rtd->component->codec;
-
+	component->init = aux_dev->init;
+	list_add(&component->list_aux, &card->aux_comp_list);
 	return 0;
+
+err_defer:
+	dev_err(card->dev, "ASoC: %s not registered\n", name);
+	return -EPROBE_DEFER;
 }
 
-static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
+static int soc_probe_aux_devices(struct snd_soc_card *card)
 {
-	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
-	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
+	struct snd_soc_component *comp;
+	int order;
 	int ret;
 
-	ret = soc_probe_component(card, rtd->component);
-	if (ret < 0)
-		return ret;
-
-	/* do machine specific initialization */
-	if (aux_dev->init) {
-		ret = aux_dev->init(rtd->component);
-		if (ret < 0) {
-			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
-				aux_dev->name, ret);
-			return ret;
+	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
+		order++) {
+		list_for_each_entry(comp, &card->aux_comp_list, list_aux) {
+			if (comp->driver->probe_order == order) {
+				ret = soc_probe_component(card,	comp);
+				if (ret < 0) {
+					dev_err(card->dev,
+						"ASoC: failed to probe aux component %s %d\n",
+						comp->name, ret);
+					return ret;
+				}
+			}
 		}
 	}
 
-	return soc_post_component_init(rtd, aux_dev->name);
+	return 0;
 }
 
-static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
+static void soc_remove_aux_devices(struct snd_soc_card *card)
 {
-	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
-	struct snd_soc_component *component = rtd->component;
+	struct snd_soc_component *comp, *_comp;
+	int order;
 
-	/* unregister the rtd device */
-	if (rtd->dev_registered) {
-		device_unregister(rtd->dev);
-		rtd->dev_registered = 0;
+	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
+		order++) {
+		list_for_each_entry_safe(comp, _comp,
+			&card->aux_comp_list, list_aux) {
+			if (comp->driver->remove_order == order) {
+				soc_remove_component(comp);
+				/* remove it from the card's aux_comp_list */
+				list_del(&comp->list_aux);
+			}
+		}
 	}
-
-	if (component)
-		soc_remove_component(component);
 }
 
 static int snd_soc_init_codec_cache(struct snd_soc_codec *codec)
@@ -1894,6 +1920,11 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
+	/* probe auxiliary components */
+	ret = soc_probe_aux_devices(card);
+	if (ret < 0)
+		goto probe_dai_err;
+
 	/* Find new DAI links added during probing components and bind them.
 	 * Components with topology may bring new DAIs and DAI links.
 	 */
@@ -1923,16 +1954,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
-	for (i = 0; i < card->num_aux_devs; i++) {
-		ret = soc_probe_aux_dev(card, i);
-		if (ret < 0) {
-			dev_err(card->dev,
-				"ASoC: failed to add auxiliary devices %d\n",
-				ret);
-			goto probe_aux_dev_err;
-		}
-	}
-
 	snd_soc_dapm_link_dai_widgets(card);
 	snd_soc_dapm_connect_dai_link_widgets(card);
 
@@ -1992,8 +2013,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	return 0;
 
 probe_aux_dev_err:
-	for (i = 0; i < card->num_aux_devs; i++)
-		soc_remove_aux_dev(card, i);
+	soc_remove_aux_devices(card);
 
 probe_dai_err:
 	soc_remove_dai_links(card);
@@ -2039,20 +2059,18 @@ static int soc_probe(struct platform_device *pdev)
 static int soc_cleanup_card_resources(struct snd_soc_card *card)
 {
 	struct snd_soc_pcm_runtime *rtd;
-	int i;
 
 	/* make sure any delayed work runs */
 	list_for_each_entry(rtd, &card->rtd_list, list)
 		flush_delayed_work(&rtd->delayed_work);
 
-	/* remove auxiliary devices */
-	for (i = 0; i < card->num_aux_devs; i++)
-		soc_remove_aux_dev(card, i);
-
 	/* remove and free each DAI */
 	soc_remove_dai_links(card);
 	soc_remove_pcm_runtimes(card);
 
+	/* remove auxiliary devices */
+	soc_remove_aux_devices(card);
+
 	soc_cleanup_card_debugfs(card);
 
 	/* remove the card */
@@ -2608,16 +2626,6 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	INIT_LIST_HEAD(&card->rtd_list);
 	card->num_rtd = 0;
 
-	card->rtd_aux = devm_kzalloc(card->dev,
-				 sizeof(struct snd_soc_pcm_runtime) *
-				 card->num_aux_devs,
-				 GFP_KERNEL);
-	if (card->rtd_aux == NULL)
-		return -ENOMEM;
-
-	for (i = 0; i < card->num_aux_devs; i++)
-		card->rtd_aux[i].card = card;
-
 	INIT_LIST_HEAD(&card->dapm_dirty);
 	INIT_LIST_HEAD(&card->dobj_list);
 	card->instantiated = 0;

commit 68003e6cf2bbd239a322bd8a28dacfaf8174fdee
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Thu Dec 31 16:40:43 2015 +0800

    ASoC: Support registering a DAI dynamically
    
    Define API snd_soc_register_dai() to add a DAI dynamically and
    create the DAI widgets. Topology can use this API to register DAIs
    when probing a component with topology info. These DAIs's playback
    & capture widgets will be freed when the sound card is unregistered
    and the DAIs will be freed when cleaning up the component.
    
    And a dobj is embedded into the struct snd_soc_dai_driver. Topology
    can use the dobj to find the DAI drivers created by it and free them
    when the topology component is removed.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1bd0b37b907f..c572673a5a24 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2834,6 +2834,48 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 	return ret;
 }
 
+/**
+ * snd_soc_register_dai - Register a DAI dynamically & create its widgets
+ *
+ * @component: The component the DAIs are registered for
+ * @dai_drv: DAI driver to use for the DAI
+ *
+ * Topology can use this API to register DAIs when probing a component.
+ * These DAIs's widgets will be freed in the card cleanup and the DAIs
+ * will be freed in the component cleanup.
+ */
+int snd_soc_register_dai(struct snd_soc_component *component,
+	struct snd_soc_dai_driver *dai_drv)
+{
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	struct snd_soc_dai *dai;
+	int ret;
+
+	if (dai_drv->dobj.type != SND_SOC_DOBJ_PCM) {
+		dev_err(component->dev, "Invalid dai type %d\n",
+			dai_drv->dobj.type);
+		return -EINVAL;
+	}
+
+	lockdep_assert_held(&client_mutex);
+	dai = soc_add_dai(component, dai_drv, false);
+	if (!dai)
+		return -ENOMEM;
+
+	/* Create the DAI widgets here. After adding DAIs, topology may
+	 * also add routes that need these widgets as source or sink.
+	 */
+	ret = snd_soc_dapm_new_dai_widgets(dapm, dai);
+	if (ret != 0) {
+		dev_err(component->dev,
+			"Failed to create DAI widgets %d\n", ret);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_dai);
+
 static void snd_soc_component_seq_notifier(struct snd_soc_dapm_context *dapm,
 	enum snd_soc_dapm_type type, int subseq)
 {

commit 5e4fb372117f476e0c7f85418ed3e39506fbb75c
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Thu Dec 31 16:40:20 2015 +0800

    ASoC: Define soc_add_dai() to add a DAI to a component
    
    Define soc_add_dai() as a wrapper to add a single DAI to a component.
    It can be reused to register a DAI dynamically by topology.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6b1982dcedf1..1bd0b37b907f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2744,6 +2744,56 @@ static void snd_soc_unregister_dais(struct snd_soc_component *component)
 	}
 }
 
+/* Create a DAI and add it to the component's DAI list */
+static struct snd_soc_dai *soc_add_dai(struct snd_soc_component *component,
+	struct snd_soc_dai_driver *dai_drv,
+	bool legacy_dai_naming)
+{
+	struct device *dev = component->dev;
+	struct snd_soc_dai *dai;
+
+	dev_dbg(dev, "ASoC: dynamically register DAI %s\n", dev_name(dev));
+
+	dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
+	if (dai == NULL)
+		return NULL;
+
+	/*
+	 * Back in the old days when we still had component-less DAIs,
+	 * instead of having a static name, component-less DAIs would
+	 * inherit the name of the parent device so it is possible to
+	 * register multiple instances of the DAI. We still need to keep
+	 * the same naming style even though those DAIs are not
+	 * component-less anymore.
+	 */
+	if (legacy_dai_naming &&
+	   (dai_drv->id == 0 || dai_drv->name == NULL)) {
+		dai->name = fmt_single_name(dev, &dai->id);
+	} else {
+		dai->name = fmt_multiple_name(dev, dai_drv);
+		if (dai_drv->id)
+			dai->id = dai_drv->id;
+		else
+			dai->id = component->num_dai;
+	}
+	if (dai->name == NULL) {
+		kfree(dai);
+		return NULL;
+	}
+
+	dai->component = component;
+	dai->dev = dev;
+	dai->driver = dai_drv;
+	if (!dai->driver->ops)
+		dai->driver->ops = &null_dai_ops;
+
+	list_add(&dai->list, &component->dai_list);
+	component->num_dai++;
+
+	dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
+	return dai;
+}
+
 /**
  * snd_soc_register_dais - Register a DAI with the ASoC core
  *
@@ -2765,49 +2815,15 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 	dev_dbg(dev, "ASoC: dai register %s #%Zu\n", dev_name(dev), count);
 
 	component->dai_drv = dai_drv;
-	component->num_dai = count;
 
 	for (i = 0; i < count; i++) {
 
-		dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
+		dai = soc_add_dai(component, dai_drv + i,
+				count == 1 && legacy_dai_naming);
 		if (dai == NULL) {
 			ret = -ENOMEM;
 			goto err;
 		}
-
-		/*
-		 * Back in the old days when we still had component-less DAIs,
-		 * instead of having a static name, component-less DAIs would
-		 * inherit the name of the parent device so it is possible to
-		 * register multiple instances of the DAI. We still need to keep
-		 * the same naming style even though those DAIs are not
-		 * component-less anymore.
-		 */
-		if (count == 1 && legacy_dai_naming &&
-			(dai_drv[i].id == 0 || dai_drv[i].name == NULL)) {
-			dai->name = fmt_single_name(dev, &dai->id);
-		} else {
-			dai->name = fmt_multiple_name(dev, &dai_drv[i]);
-			if (dai_drv[i].id)
-				dai->id = dai_drv[i].id;
-			else
-				dai->id = i;
-		}
-		if (dai->name == NULL) {
-			kfree(dai);
-			ret = -ENOMEM;
-			goto err;
-		}
-
-		dai->component = component;
-		dai->dev = dev;
-		dai->driver = &dai_drv[i];
-		if (!dai->driver->ops)
-			dai->driver->ops = &null_dai_ops;
-
-		list_add(&dai->list, &component->dai_list);
-
-		dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
 	}
 
 	return 0;

commit 64dc98d374967ca1a17e0dfa1ec040d7f9d09e12
Merge: 38cfbc12c848 501f72e9c520 3de7c420a2b1 800cff79d7ab
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Dec 23 00:23:39 2015 +0000

    Merge remote-tracking branches 'asoc/topic/da7219', 'asoc/topic/dai-link' and 'asoc/topic/doc' into asoc-next

commit a93202fa7b450a2783feecc571dcd0fee55c91c4
Merge: 3b88210da3a6 61b0088b6a5b
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Dec 23 00:23:32 2015 +0000

    Merge remote-tracking branch 'asoc/topic/pcm-list' into asoc-next

commit 61b0088b6a5b98608ce00c18a057b1f5bcb5f8b3
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Wed Dec 2 14:11:48 2015 +0800

    ASoC: Bind new DAI links after probing components
    
    Probing components can bring new DAI or DAI links based on the topology
    info. This patch finds the unbound DAI links and bind them.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 11d073b6ce33..6b1982dcedf1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1806,6 +1806,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_codec *codec;
 	struct snd_soc_pcm_runtime *rtd;
+	struct snd_soc_dai_link *dai_link;
 	int ret, i, order;
 
 	mutex_lock(&client_mutex);
@@ -1893,6 +1894,21 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
+	/* Find new DAI links added during probing components and bind them.
+	 * Components with topology may bring new DAIs and DAI links.
+	 */
+	list_for_each_entry(dai_link, &card->dai_link_list, list) {
+		if (soc_is_dai_link_bound(card, dai_link))
+			continue;
+
+		ret = soc_init_dai_link(card, dai_link);
+		if (ret)
+			goto probe_dai_err;
+		ret = soc_bind_dai_link(card, dai_link);
+		if (ret)
+			goto probe_dai_err;
+	}
+
 	/* probe all DAI links on this card */
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {

commit 49a5ba1cd9da4fb04e7ce1e0d94f6a5a9b7be48e
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Wed Dec 2 14:11:40 2015 +0800

    ASoC: soc_bind_dai_link() directly returns success for a bound DAI link
    
    This function will return success immediately for a bound DAI link.
    No need to look for the cpu/codec DAIs again.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 094856fa8cec..11d073b6ce33 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -960,6 +960,19 @@ static struct snd_soc_dai *snd_soc_find_dai(
 	return NULL;
 }
 
+static bool soc_is_dai_link_bound(struct snd_soc_card *card,
+		struct snd_soc_dai_link *dai_link)
+{
+	struct snd_soc_pcm_runtime *rtd;
+
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		if (rtd->dai_link == dai_link)
+			return true;
+	}
+
+	return false;
+}
+
 static int soc_bind_dai_link(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link)
 {
@@ -977,6 +990,12 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 	if (!rtd)
 		return -ENOMEM;
 
+	if (soc_is_dai_link_bound(card, dai_link)) {
+		dev_dbg(card->dev, "ASoC: dai link %s already bound\n",
+			dai_link->name);
+		return 0;
+	}
+
 	cpu_dai_component.name = dai_link->cpu_name;
 	cpu_dai_component.of_node = dai_link->cpu_of_node;
 	cpu_dai_component.dai_name = dai_link->cpu_dai_name;

commit d6f220ea13edfd3430fb42e09ff92e321ffb5762
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Wed Dec 2 14:11:32 2015 +0800

    ASoC: Define add/remove_dai_link ops for a soc card
    
    A machine driver can register the two ops.
    
    When a DAI link is added or removed by a component's topology, the
    ASoC core can call the ops to notify the machine driver for extra
    intialization or destruction.
    
    E.g. topology can create FE DAI links from a cpu DAI component, and
    the machine driver may define an add_dai_link ops to set machine-specific
    .init ops for the DAI link.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bf4bccfc4b91..094856fa8cec 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1260,6 +1260,12 @@ int snd_soc_add_dai_link(struct snd_soc_card *card,
 	}
 
 	lockdep_assert_held(&client_mutex);
+	/* Notify the machine driver for extra initialization
+	 * on the link created by topology.
+	 */
+	if (dai_link->dobj.type && card->add_dai_link)
+		card->add_dai_link(card, dai_link);
+
 	list_add_tail(&dai_link->list, &card->dai_link_list);
 	card->num_dai_links++;
 
@@ -1290,6 +1296,12 @@ void snd_soc_remove_dai_link(struct snd_soc_card *card,
 	}
 
 	lockdep_assert_held(&client_mutex);
+	/* Notify the machine driver for extra destruction
+	 * on the link created by topology.
+	 */
+	if (dai_link->dobj.type && card->remove_dai_link)
+		card->remove_dai_link(card, dai_link);
+
 	list_for_each_entry_safe(link, _link, &card->dai_link_list, list) {
 		if (link == dai_link) {
 			list_del(&link->list);

commit f8f80361d07d503093940097e967a7edaa134ca2
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Wed Dec 2 14:11:22 2015 +0800

    ASoC: Implement DAI links in a list & define API to add/remove a link
    
    Implement a dai link list for the soc card.
    
    Add APIs to add/remove a DAI links dynamically, e.g. by topology.
    
    And a dobj is embedded into the struct snd_soc_dai_link. Topology can
    use the dobj to find the links created by it and remove them when the
    topology component is unloaded.
    
    The predefined DAI links are reserved to keep backward compatibility.
    And they will also be added to the list.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 878a9fe92686..bf4bccfc4b91 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1120,6 +1120,7 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 {
 	int order;
 	struct snd_soc_pcm_runtime *rtd;
+	struct snd_soc_dai_link *link, *_link;
 
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
@@ -1132,6 +1133,15 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 		list_for_each_entry(rtd, &card->rtd_list, list)
 			soc_remove_link_components(card, rtd, order);
 	}
+
+	list_for_each_entry_safe(link, _link, &card->dai_link_list, list) {
+		if (link->dobj.type == SND_SOC_DOBJ_DAI_LINK)
+			dev_warn(card->dev, "Topology forgot to remove link %s?\n",
+				link->name);
+
+		list_del(&link->list);
+		card->num_dai_links--;
+	}
 }
 
 static int snd_soc_init_multicodec(struct snd_soc_card *card,
@@ -1228,6 +1238,68 @@ static int soc_init_dai_link(struct snd_soc_card *card,
 	return 0;
 }
 
+/**
+ * snd_soc_add_dai_link - Add a DAI link dynamically
+ * @card: The ASoC card to which the DAI link is added
+ * @dai_link: The new DAI link to add
+ *
+ * This function adds a DAI link to the ASoC card's link list.
+ *
+ * Note: Topology can use this API to add DAI links when probing the
+ * topology component. And machine drivers can still define static
+ * DAI links in dai_link array.
+ */
+int snd_soc_add_dai_link(struct snd_soc_card *card,
+		struct snd_soc_dai_link *dai_link)
+{
+	if (dai_link->dobj.type
+	    && dai_link->dobj.type != SND_SOC_DOBJ_DAI_LINK) {
+		dev_err(card->dev, "Invalid dai link type %d\n",
+			dai_link->dobj.type);
+		return -EINVAL;
+	}
+
+	lockdep_assert_held(&client_mutex);
+	list_add_tail(&dai_link->list, &card->dai_link_list);
+	card->num_dai_links++;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_dai_link);
+
+/**
+ * snd_soc_remove_dai_link - Remove a DAI link from the list
+ * @card: The ASoC card that owns the link
+ * @dai_link: The DAI link to remove
+ *
+ * This function removes a DAI link from the ASoC card's link list.
+ *
+ * For DAI links previously added by topology, topology should
+ * remove them by using the dobj embedded in the link.
+ */
+void snd_soc_remove_dai_link(struct snd_soc_card *card,
+			     struct snd_soc_dai_link *dai_link)
+{
+	struct snd_soc_dai_link *link, *_link;
+
+	if (dai_link->dobj.type
+	    && dai_link->dobj.type != SND_SOC_DOBJ_DAI_LINK) {
+		dev_err(card->dev, "Invalid dai link type %d\n",
+			dai_link->dobj.type);
+		return;
+	}
+
+	lockdep_assert_held(&client_mutex);
+	list_for_each_entry_safe(link, _link, &card->dai_link_list, list) {
+		if (link == dai_link) {
+			list_del(&link->list);
+			card->num_dai_links--;
+			return;
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(snd_soc_remove_dai_link);
+
 static void soc_set_name_prefix(struct snd_soc_card *card,
 				struct snd_soc_component *component)
 {
@@ -1722,6 +1794,10 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 			goto base_error;
 	}
 
+	/* add predefined DAI links to the list */
+	for (i = 0; i < card->num_links; i++)
+		snd_soc_add_dai_link(card, card->dai_link+i);
+
 	/* initialize the register cache for each available codec */
 	list_for_each_entry(codec, &codec_list, list) {
 		if (codec->cache_init)
@@ -2479,6 +2555,9 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 	snd_soc_initialize_card_lists(card);
 
+	INIT_LIST_HEAD(&card->dai_link_list);
+	card->num_dai_links = 0;
+
 	INIT_LIST_HEAD(&card->rtd_list);
 	card->num_rtd = 0;
 

commit 6f2f1ff0de83ad69f5a823ae77d1e0f77cc75d45
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Mon Nov 23 11:03:52 2015 -0500

    ASoC: Change 2nd argument of soc_bind_dai_link() to DAI link pointer
    
    Just code refactoring, to reuse it if new DAI Links are added later
    based on topology in component probing phase.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2ecd09475d88..878a9fe92686 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -960,9 +960,9 @@ static struct snd_soc_dai *snd_soc_find_dai(
 	return NULL;
 }
 
-static int soc_bind_dai_link(struct snd_soc_card *card, int num)
+static int soc_bind_dai_link(struct snd_soc_card *card,
+	struct snd_soc_dai_link *dai_link)
 {
-	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
 	struct snd_soc_dai_link_component cpu_dai_component;
@@ -971,7 +971,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	const char *platform_name;
 	int i;
 
-	dev_dbg(card->dev, "ASoC: binding %s at idx %d\n", dai_link->name, num);
+	dev_dbg(card->dev, "ASoC: binding %s\n", dai_link->name);
 
 	rtd = soc_new_pcm_runtime(card, dai_link);
 	if (!rtd)
@@ -1710,7 +1710,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	/* bind DAIs */
 	for (i = 0; i < card->num_links; i++) {
-		ret = soc_bind_dai_link(card, i);
+		ret = soc_bind_dai_link(card, &card->dai_link[i]);
 		if (ret != 0)
 			goto base_error;
 	}

commit 923c5e61ecd9b0ca006a7707583287439f36c2e9
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Mon Nov 23 11:01:49 2015 -0500

    ASoC: Define soc_init_dai_link() to wrap link intialization.
    
    Define soc_init_dai_link() to wrap link initialization, to reuse it later
    by snd_soc_instantiate_card() when adding new DAI links from topology in
    component probing phase.
    
    Move static func snd_soc_init_multicodec(), so that it can be reused by
    soc_init_dai_link(). This saves adding a function declaration for
    snd_soc_init_multicodec().
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2c95de723d8f..2ecd09475d88 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1134,6 +1134,100 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 	}
 }
 
+static int snd_soc_init_multicodec(struct snd_soc_card *card,
+				   struct snd_soc_dai_link *dai_link)
+{
+	/* Legacy codec/codec_dai link is a single entry in multicodec */
+	if (dai_link->codec_name || dai_link->codec_of_node ||
+	    dai_link->codec_dai_name) {
+		dai_link->num_codecs = 1;
+
+		dai_link->codecs = devm_kzalloc(card->dev,
+				sizeof(struct snd_soc_dai_link_component),
+				GFP_KERNEL);
+		if (!dai_link->codecs)
+			return -ENOMEM;
+
+		dai_link->codecs[0].name = dai_link->codec_name;
+		dai_link->codecs[0].of_node = dai_link->codec_of_node;
+		dai_link->codecs[0].dai_name = dai_link->codec_dai_name;
+	}
+
+	if (!dai_link->codecs) {
+		dev_err(card->dev, "ASoC: DAI link has no CODECs\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int soc_init_dai_link(struct snd_soc_card *card,
+				   struct snd_soc_dai_link *link)
+{
+	int i, ret;
+
+	ret = snd_soc_init_multicodec(card, link);
+	if (ret) {
+		dev_err(card->dev, "ASoC: failed to init multicodec\n");
+		return ret;
+	}
+
+	for (i = 0; i < link->num_codecs; i++) {
+		/*
+		 * Codec must be specified by 1 of name or OF node,
+		 * not both or neither.
+		 */
+		if (!!link->codecs[i].name ==
+		    !!link->codecs[i].of_node) {
+			dev_err(card->dev, "ASoC: Neither/both codec name/of_node are set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
+		/* Codec DAI name must be specified */
+		if (!link->codecs[i].dai_name) {
+			dev_err(card->dev, "ASoC: codec_dai_name not set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
+	}
+
+	/*
+	 * Platform may be specified by either name or OF node, but
+	 * can be left unspecified, and a dummy platform will be used.
+	 */
+	if (link->platform_name && link->platform_of_node) {
+		dev_err(card->dev,
+			"ASoC: Both platform name/of_node are set for %s\n",
+			link->name);
+		return -EINVAL;
+	}
+
+	/*
+	 * CPU device may be specified by either name or OF node, but
+	 * can be left unspecified, and will be matched based on DAI
+	 * name alone..
+	 */
+	if (link->cpu_name && link->cpu_of_node) {
+		dev_err(card->dev,
+			"ASoC: Neither/both cpu name/of_node are set for %s\n",
+			link->name);
+		return -EINVAL;
+	}
+	/*
+	 * At least one of CPU DAI name or CPU device name/node must be
+	 * specified
+	 */
+	if (!link->cpu_dai_name &&
+	    !(link->cpu_name || link->cpu_of_node)) {
+		dev_err(card->dev,
+			"ASoC: Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
+			link->name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static void soc_set_name_prefix(struct snd_soc_card *card,
 				struct snd_soc_component *component)
 {
@@ -2356,33 +2450,6 @@ int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 
-static int snd_soc_init_multicodec(struct snd_soc_card *card,
-				   struct snd_soc_dai_link *dai_link)
-{
-	/* Legacy codec/codec_dai link is a single entry in multicodec */
-	if (dai_link->codec_name || dai_link->codec_of_node ||
-	    dai_link->codec_dai_name) {
-		dai_link->num_codecs = 1;
-
-		dai_link->codecs = devm_kzalloc(card->dev,
-				sizeof(struct snd_soc_dai_link_component),
-				GFP_KERNEL);
-		if (!dai_link->codecs)
-			return -ENOMEM;
-
-		dai_link->codecs[0].name = dai_link->codec_name;
-		dai_link->codecs[0].of_node = dai_link->codec_of_node;
-		dai_link->codecs[0].dai_name = dai_link->codec_dai_name;
-	}
-
-	if (!dai_link->codecs) {
-		dev_err(card->dev, "ASoC: DAI link has no CODECs\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
 /**
  * snd_soc_register_card - Register a card with the ASoC core
  *
@@ -2391,7 +2458,7 @@ static int snd_soc_init_multicodec(struct snd_soc_card *card,
  */
 int snd_soc_register_card(struct snd_soc_card *card)
 {
-	int i, j, ret;
+	int i, ret;
 	struct snd_soc_pcm_runtime *rtd;
 
 	if (!card->name || !card->dev)
@@ -2400,63 +2467,11 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai_link *link = &card->dai_link[i];
 
-		ret = snd_soc_init_multicodec(card, link);
+		ret = soc_init_dai_link(card, link);
 		if (ret) {
-			dev_err(card->dev, "ASoC: failed to init multicodec\n");
-			return ret;
-		}
-
-		for (j = 0; j < link->num_codecs; j++) {
-			/*
-			 * Codec must be specified by 1 of name or OF node,
-			 * not both or neither.
-			 */
-			if (!!link->codecs[j].name ==
-			    !!link->codecs[j].of_node) {
-				dev_err(card->dev, "ASoC: Neither/both codec name/of_node are set for %s\n",
-					link->name);
-				return -EINVAL;
-			}
-			/* Codec DAI name must be specified */
-			if (!link->codecs[j].dai_name) {
-				dev_err(card->dev, "ASoC: codec_dai_name not set for %s\n",
-					link->name);
-				return -EINVAL;
-			}
-		}
-
-		/*
-		 * Platform may be specified by either name or OF node, but
-		 * can be left unspecified, and a dummy platform will be used.
-		 */
-		if (link->platform_name && link->platform_of_node) {
-			dev_err(card->dev,
-				"ASoC: Both platform name/of_node are set for %s\n",
+			dev_err(card->dev, "ASoC: failed to init link %s\n",
 				link->name);
-			return -EINVAL;
-		}
-
-		/*
-		 * CPU device may be specified by either name or OF node, but
-		 * can be left unspecified, and will be matched based on DAI
-		 * name alone..
-		 */
-		if (link->cpu_name && link->cpu_of_node) {
-			dev_err(card->dev,
-				"ASoC: Neither/both cpu name/of_node are set for %s\n",
-				link->name);
-			return -EINVAL;
-		}
-		/*
-		 * At least one of CPU DAI name or CPU device name/node must be
-		 * specified
-		 */
-		if (!link->cpu_dai_name &&
-		    !(link->cpu_name || link->cpu_of_node)) {
-			dev_err(card->dev,
-				"ASoC: Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
-				link->name);
-			return -EINVAL;
+			return ret;
 		}
 	}
 

commit 1a7aaa58ec7aaa389cd6b200809908ec472d316b
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Mon Nov 23 21:22:31 2015 +0530

    ASoC: core: Change power state before rechecking endpoint
    
    For DAPM resume, we should first change the power state of the
    card and then recheck the endpoints. This ensures the dapm is
    resumed first and then userspace can resume the streams.
    
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 24b096066a07..a1305f827a98 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -795,12 +795,12 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	dev_dbg(card->dev, "ASoC: resume work completed\n");
 
-	/* userspace can access us now we are back as we were before */
-	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
-
 	/* Recheck all endpoints too, their state is affected by suspend */
 	dapm_mark_endpoints_dirty(card);
 	snd_soc_dapm_sync(&card->dapm);
+
+	/* userspace can access us now we are back as we were before */
+	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
 }
 
 /* powers up audio subsystem after a suspend */

commit 1a497983a5ae62b4970187183fb3b40e68515a24
Author: Mengdong Lin <mengdong.lin@linux.intel.com>
Date:   Wed Nov 18 02:34:11 2015 -0500

    ASoC: Change the PCM runtime array to a list
    
    Currently the number of DAI links is statically defined by the machine
    driver at build time using an array. This makes it difficult to shrink/
    grow the number of DAI links at runtime in order to reflect any changes
    in topology.
    
    We can change the DAI link array in the core to a list so that PCMs and
    FE DAI links can be added and deleted at runtime to reflect changes in
    use case and DSP topology. The machine driver can still register DAI links
    as an array.
    
    As the 1st step, this patch change the PCM runtime array to a list. A new
    PCM runtime is added to the list when a DAI link is bound successfully.
    
    Later patches will further implement the DAI link list.
    
    More:
    - define snd_soc_new/free_pcm_runtime() to create/free a runtime.
    - define soc_add_pcm_runtime() to add a runtime to the rtd list.
    - define soc_remove_pcm_runtimes() to clean up the runtime list.
    
    - traverse the rtd list to probe the link components and dais.
    
    - Add a field "num" to PCM runtime struct, used to specify the device
      number when creating the pcm device, and for a soc card to access
      its dai_props array.
    
    - The following 3rd party machine/platform drivers iterate the rtd list
      to check the runtimes:
      sound/soc/intel/atom/sst-mfld-platform-pcm.c
      sound/soc/intel/boards/cht_bsw_rt5645.c
      sound/soc/intel/boards/cht_bsw_rt5672.c
      sound/soc/intel/boards/cht_bsw_max98090_ti.c
    
    Signed-off-by: Mengdong Lin <mengdong.lin@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 24b096066a07..2c95de723d8f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -537,26 +537,75 @@ static inline void snd_soc_debugfs_exit(void)
 struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
 		const char *dai_link, int stream)
 {
-	int i;
+	struct snd_soc_pcm_runtime *rtd;
 
-	for (i = 0; i < card->num_links; i++) {
-		if (card->rtd[i].dai_link->no_pcm &&
-			!strcmp(card->rtd[i].dai_link->name, dai_link))
-			return card->rtd[i].pcm->streams[stream].substream;
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		if (rtd->dai_link->no_pcm &&
+			!strcmp(rtd->dai_link->name, dai_link))
+			return rtd->pcm->streams[stream].substream;
 	}
 	dev_dbg(card->dev, "ASoC: failed to find dai link %s\n", dai_link);
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_dai_substream);
 
+static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
+	struct snd_soc_card *card, struct snd_soc_dai_link *dai_link)
+{
+	struct snd_soc_pcm_runtime *rtd;
+
+	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
+	if (!rtd)
+		return NULL;
+
+	rtd->card = card;
+	rtd->dai_link = dai_link;
+	rtd->codec_dais = kzalloc(sizeof(struct snd_soc_dai *) *
+					dai_link->num_codecs,
+					GFP_KERNEL);
+	if (!rtd->codec_dais) {
+		kfree(rtd);
+		return NULL;
+	}
+
+	return rtd;
+}
+
+static void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)
+{
+	if (rtd && rtd->codec_dais)
+		kfree(rtd->codec_dais);
+	kfree(rtd);
+}
+
+static void soc_add_pcm_runtime(struct snd_soc_card *card,
+		struct snd_soc_pcm_runtime *rtd)
+{
+	list_add_tail(&rtd->list, &card->rtd_list);
+	rtd->num = card->num_rtd;
+	card->num_rtd++;
+}
+
+static void soc_remove_pcm_runtimes(struct snd_soc_card *card)
+{
+	struct snd_soc_pcm_runtime *rtd, *_rtd;
+
+	list_for_each_entry_safe(rtd, _rtd, &card->rtd_list, list) {
+		list_del(&rtd->list);
+		soc_free_pcm_runtime(rtd);
+	}
+
+	card->num_rtd = 0;
+}
+
 struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
 		const char *dai_link)
 {
-	int i;
+	struct snd_soc_pcm_runtime *rtd;
 
-	for (i = 0; i < card->num_links; i++) {
-		if (!strcmp(card->rtd[i].dai_link->name, dai_link))
-			return &card->rtd[i];
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		if (!strcmp(rtd->dai_link->name, dai_link))
+			return rtd;
 	}
 	dev_dbg(card->dev, "ASoC: failed to find rtd %s\n", dai_link);
 	return NULL;
@@ -578,7 +627,8 @@ int snd_soc_suspend(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	struct snd_soc_codec *codec;
-	int i, j;
+	struct snd_soc_pcm_runtime *rtd;
+	int i;
 
 	/* If the card is not initialized yet there is nothing to do */
 	if (!card->instantiated)
@@ -595,13 +645,13 @@ int snd_soc_suspend(struct device *dev)
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D3hot);
 
 	/* mute any active DACs */
-	for (i = 0; i < card->num_rtd; i++) {
+	list_for_each_entry(rtd, &card->rtd_list, list) {
 
-		if (card->rtd[i].dai_link->ignore_suspend)
+		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		for (j = 0; j < card->rtd[i].num_codecs; j++) {
-			struct snd_soc_dai *dai = card->rtd[i].codec_dais[j];
+		for (i = 0; i < rtd->num_codecs; i++) {
+			struct snd_soc_dai *dai = rtd->codec_dais[i];
 			struct snd_soc_dai_driver *drv = dai->driver;
 
 			if (drv->ops->digital_mute && dai->playback_active)
@@ -610,20 +660,20 @@ int snd_soc_suspend(struct device *dev)
 	}
 
 	/* suspend all pcms */
-	for (i = 0; i < card->num_rtd; i++) {
-		if (card->rtd[i].dai_link->ignore_suspend)
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		snd_pcm_suspend_all(card->rtd[i].pcm);
+		snd_pcm_suspend_all(rtd->pcm);
 	}
 
 	if (card->suspend_pre)
 		card->suspend_pre(card);
 
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 
-		if (card->rtd[i].dai_link->ignore_suspend)
+		if (rtd->dai_link->ignore_suspend)
 			continue;
 
 		if (cpu_dai->driver->suspend && !cpu_dai->driver->bus_control)
@@ -631,19 +681,19 @@ int snd_soc_suspend(struct device *dev)
 	}
 
 	/* close any waiting streams */
-	for (i = 0; i < card->num_rtd; i++)
-		flush_delayed_work(&card->rtd[i].delayed_work);
+	list_for_each_entry(rtd, &card->rtd_list, list)
+		flush_delayed_work(&rtd->delayed_work);
 
-	for (i = 0; i < card->num_rtd; i++) {
+	list_for_each_entry(rtd, &card->rtd_list, list) {
 
-		if (card->rtd[i].dai_link->ignore_suspend)
+		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		snd_soc_dapm_stream_event(&card->rtd[i],
+		snd_soc_dapm_stream_event(rtd,
 					  SNDRV_PCM_STREAM_PLAYBACK,
 					  SND_SOC_DAPM_STREAM_SUSPEND);
 
-		snd_soc_dapm_stream_event(&card->rtd[i],
+		snd_soc_dapm_stream_event(rtd,
 					  SNDRV_PCM_STREAM_CAPTURE,
 					  SND_SOC_DAPM_STREAM_SUSPEND);
 	}
@@ -690,10 +740,10 @@ int snd_soc_suspend(struct device *dev)
 		}
 	}
 
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 
-		if (card->rtd[i].dai_link->ignore_suspend)
+		if (rtd->dai_link->ignore_suspend)
 			continue;
 
 		if (cpu_dai->driver->suspend && cpu_dai->driver->bus_control)
@@ -717,8 +767,9 @@ static void soc_resume_deferred(struct work_struct *work)
 {
 	struct snd_soc_card *card =
 			container_of(work, struct snd_soc_card, deferred_resume_work);
+	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_codec *codec;
-	int i, j;
+	int i;
 
 	/* our power state is still SNDRV_CTL_POWER_D3hot from suspend time,
 	 * so userspace apps are blocked from touching us
@@ -733,10 +784,10 @@ static void soc_resume_deferred(struct work_struct *work)
 		card->resume_pre(card);
 
 	/* resume control bus DAIs */
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 
-		if (card->rtd[i].dai_link->ignore_suspend)
+		if (rtd->dai_link->ignore_suspend)
 			continue;
 
 		if (cpu_dai->driver->resume && cpu_dai->driver->bus_control)
@@ -751,28 +802,28 @@ static void soc_resume_deferred(struct work_struct *work)
 		}
 	}
 
-	for (i = 0; i < card->num_rtd; i++) {
+	list_for_each_entry(rtd, &card->rtd_list, list) {
 
-		if (card->rtd[i].dai_link->ignore_suspend)
+		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		snd_soc_dapm_stream_event(&card->rtd[i],
+		snd_soc_dapm_stream_event(rtd,
 					  SNDRV_PCM_STREAM_PLAYBACK,
 					  SND_SOC_DAPM_STREAM_RESUME);
 
-		snd_soc_dapm_stream_event(&card->rtd[i],
+		snd_soc_dapm_stream_event(rtd,
 					  SNDRV_PCM_STREAM_CAPTURE,
 					  SND_SOC_DAPM_STREAM_RESUME);
 	}
 
 	/* unmute any active DACs */
-	for (i = 0; i < card->num_rtd; i++) {
+	list_for_each_entry(rtd, &card->rtd_list, list) {
 
-		if (card->rtd[i].dai_link->ignore_suspend)
+		if (rtd->dai_link->ignore_suspend)
 			continue;
 
-		for (j = 0; j < card->rtd[i].num_codecs; j++) {
-			struct snd_soc_dai *dai = card->rtd[i].codec_dais[j];
+		for (i = 0; i < rtd->num_codecs; i++) {
+			struct snd_soc_dai *dai = rtd->codec_dais[i];
 			struct snd_soc_dai_driver *drv = dai->driver;
 
 			if (drv->ops->digital_mute && dai->playback_active)
@@ -780,10 +831,10 @@ static void soc_resume_deferred(struct work_struct *work)
 		}
 	}
 
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 
-		if (card->rtd[i].dai_link->ignore_suspend)
+		if (rtd->dai_link->ignore_suspend)
 			continue;
 
 		if (cpu_dai->driver->resume && !cpu_dai->driver->bus_control)
@@ -808,15 +859,14 @@ int snd_soc_resume(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	bool bus_control = false;
-	int i;
+	struct snd_soc_pcm_runtime *rtd;
 
 	/* If the card is not initialized yet there is nothing to do */
 	if (!card->instantiated)
 		return 0;
 
 	/* activate pins from sleep state */
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+	list_for_each_entry(rtd, &card->rtd_list, list) {
 		struct snd_soc_dai **codec_dais = rtd->codec_dais;
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 		int j;
@@ -837,8 +887,8 @@ int snd_soc_resume(struct device *dev)
 	 * have that problem and may take a substantial amount of time to resume
 	 * due to I/O costs and anti-pop so handle them out of line.
 	 */
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+	list_for_each_entry(rtd, &card->rtd_list, list) {
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 		bus_control |= cpu_dai->driver->bus_control;
 	}
 	if (bus_control) {
@@ -913,16 +963,20 @@ static struct snd_soc_dai *snd_soc_find_dai(
 static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
-	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_pcm_runtime *rtd;
 	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
 	struct snd_soc_dai_link_component cpu_dai_component;
-	struct snd_soc_dai **codec_dais = rtd->codec_dais;
+	struct snd_soc_dai **codec_dais;
 	struct snd_soc_platform *platform;
 	const char *platform_name;
 	int i;
 
 	dev_dbg(card->dev, "ASoC: binding %s at idx %d\n", dai_link->name, num);
 
+	rtd = soc_new_pcm_runtime(card, dai_link);
+	if (!rtd)
+		return -ENOMEM;
+
 	cpu_dai_component.name = dai_link->cpu_name;
 	cpu_dai_component.of_node = dai_link->cpu_of_node;
 	cpu_dai_component.dai_name = dai_link->cpu_dai_name;
@@ -930,18 +984,19 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	if (!rtd->cpu_dai) {
 		dev_err(card->dev, "ASoC: CPU DAI %s not registered\n",
 			dai_link->cpu_dai_name);
-		return -EPROBE_DEFER;
+		goto _err_defer;
 	}
 
 	rtd->num_codecs = dai_link->num_codecs;
 
 	/* Find CODEC from registered CODECs */
+	codec_dais = rtd->codec_dais;
 	for (i = 0; i < rtd->num_codecs; i++) {
 		codec_dais[i] = snd_soc_find_dai(&codecs[i]);
 		if (!codec_dais[i]) {
 			dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
 				codecs[i].dai_name);
-			return -EPROBE_DEFER;
+			goto _err_defer;
 		}
 	}
 
@@ -973,9 +1028,12 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		return -EPROBE_DEFER;
 	}
 
-	card->num_rtd++;
-
+	soc_add_pcm_runtime(card, rtd);
 	return 0;
+
+_err_defer:
+	soc_free_pcm_runtime(rtd);
+	return  -EPROBE_DEFER;
 }
 
 static void soc_remove_component(struct snd_soc_component *component)
@@ -1014,9 +1072,9 @@ static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 	}
 }
 
-static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
+static void soc_remove_link_dais(struct snd_soc_card *card,
+		struct snd_soc_pcm_runtime *rtd, int order)
 {
-	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	int i;
 
 	/* unregister the rtd device */
@@ -1032,10 +1090,9 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 	soc_remove_dai(rtd->cpu_dai, order);
 }
 
-static void soc_remove_link_components(struct snd_soc_card *card, int num,
-				       int order)
+static void soc_remove_link_components(struct snd_soc_card *card,
+	struct snd_soc_pcm_runtime *rtd, int order)
 {
-	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_component *component;
@@ -1061,21 +1118,20 @@ static void soc_remove_link_components(struct snd_soc_card *card, int num,
 
 static void soc_remove_dai_links(struct snd_soc_card *card)
 {
-	int dai, order;
+	int order;
+	struct snd_soc_pcm_runtime *rtd;
 
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
-		for (dai = 0; dai < card->num_rtd; dai++)
-			soc_remove_link_dais(card, dai, order);
+		list_for_each_entry(rtd, &card->rtd_list, list)
+			soc_remove_link_dais(card, rtd, order);
 	}
 
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
-		for (dai = 0; dai < card->num_rtd; dai++)
-			soc_remove_link_components(card, dai, order);
+		list_for_each_entry(rtd, &card->rtd_list, list)
+			soc_remove_link_components(card, rtd, order);
 	}
-
-	card->num_rtd = 0;
 }
 
 static void soc_set_name_prefix(struct snd_soc_card *card,
@@ -1220,10 +1276,10 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 	return 0;
 }
 
-static int soc_probe_link_components(struct snd_soc_card *card, int num,
+static int soc_probe_link_components(struct snd_soc_card *card,
+			struct snd_soc_pcm_runtime *rtd,
 				     int order)
 {
-	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_component *component;
 	int i, ret;
@@ -1319,15 +1375,15 @@ static int soc_link_dai_widgets(struct snd_soc_card *card,
 	return 0;
 }
 
-static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
+static int soc_probe_link_dais(struct snd_soc_card *card,
+		struct snd_soc_pcm_runtime *rtd, int order)
 {
-	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
-	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	int i, ret;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
-			card->name, num, order);
+			card->name, rtd->num, order);
 
 	/* set default power off timeout */
 	rtd->pmdown_time = pmdown_time;
@@ -1372,7 +1428,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 
 	if (cpu_dai->driver->compress_new) {
 		/*create compress_device"*/
-		ret = cpu_dai->driver->compress_new(rtd, num);
+		ret = cpu_dai->driver->compress_new(rtd, rtd->num);
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: can't create compress %s\n",
 					 dai_link->stream_name);
@@ -1382,7 +1438,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 
 		if (!dai_link->params) {
 			/* create the pcm */
-			ret = soc_new_pcm(rtd, num);
+			ret = soc_new_pcm(rtd, rtd->num);
 			if (ret < 0) {
 				dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
 				       dai_link->stream_name, ret);
@@ -1552,6 +1608,7 @@ EXPORT_SYMBOL_GPL(snd_soc_runtime_set_dai_fmt);
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_codec *codec;
+	struct snd_soc_pcm_runtime *rtd;
 	int ret, i, order;
 
 	mutex_lock(&client_mutex);
@@ -1624,8 +1681,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	/* probe all components used by DAI links on this card */
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
-		for (i = 0; i < card->num_links; i++) {
-			ret = soc_probe_link_components(card, i, order);
+		list_for_each_entry(rtd, &card->rtd_list, list) {
+			ret = soc_probe_link_components(card, rtd, order);
 			if (ret < 0) {
 				dev_err(card->dev,
 					"ASoC: failed to instantiate card %d\n",
@@ -1638,8 +1695,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	/* probe all DAI links on this card */
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
-		for (i = 0; i < card->num_links; i++) {
-			ret = soc_probe_link_dais(card, i, order);
+		list_for_each_entry(rtd, &card->rtd_list, list) {
+			ret = soc_probe_link_dais(card, rtd, order);
 			if (ret < 0) {
 				dev_err(card->dev,
 					"ASoC: failed to instantiate card %d\n",
@@ -1733,6 +1790,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	snd_card_free(card->snd_card);
 
 base_error:
+	soc_remove_pcm_runtimes(card);
 	mutex_unlock(&card->mutex);
 	mutex_unlock(&client_mutex);
 
@@ -1763,13 +1821,12 @@ static int soc_probe(struct platform_device *pdev)
 
 static int soc_cleanup_card_resources(struct snd_soc_card *card)
 {
+	struct snd_soc_pcm_runtime *rtd;
 	int i;
 
 	/* make sure any delayed work runs */
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+	list_for_each_entry(rtd, &card->rtd_list, list)
 		flush_delayed_work(&rtd->delayed_work);
-	}
 
 	/* remove auxiliary devices */
 	for (i = 0; i < card->num_aux_devs; i++)
@@ -1777,6 +1834,7 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 
 	/* remove and free each DAI */
 	soc_remove_dai_links(card);
+	soc_remove_pcm_runtimes(card);
 
 	soc_cleanup_card_debugfs(card);
 
@@ -1803,29 +1861,26 @@ static int soc_remove(struct platform_device *pdev)
 int snd_soc_poweroff(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
-	int i;
+	struct snd_soc_pcm_runtime *rtd;
 
 	if (!card->instantiated)
 		return 0;
 
 	/* Flush out pmdown_time work - we actually do want to run it
 	 * now, we're shutting down so no imminent restart. */
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+	list_for_each_entry(rtd, &card->rtd_list, list)
 		flush_delayed_work(&rtd->delayed_work);
-	}
 
 	snd_soc_dapm_shutdown(card);
 
 	/* deactivate pins to sleep state */
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+	list_for_each_entry(rtd, &card->rtd_list, list) {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-		int j;
+		int i;
 
 		pinctrl_pm_select_sleep_state(cpu_dai->dev);
-		for (j = 0; j < rtd->num_codecs; j++) {
-			struct snd_soc_dai *codec_dai = rtd->codec_dais[j];
+		for (i = 0; i < rtd->num_codecs; i++) {
+			struct snd_soc_dai *codec_dai = rtd->codec_dais[i];
 			pinctrl_pm_select_sleep_state(codec_dai->dev);
 		}
 	}
@@ -2337,6 +2392,7 @@ static int snd_soc_init_multicodec(struct snd_soc_card *card,
 int snd_soc_register_card(struct snd_soc_card *card)
 {
 	int i, j, ret;
+	struct snd_soc_pcm_runtime *rtd;
 
 	if (!card->name || !card->dev)
 		return -EINVAL;
@@ -2408,25 +2464,15 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 	snd_soc_initialize_card_lists(card);
 
-	card->rtd = devm_kzalloc(card->dev,
+	INIT_LIST_HEAD(&card->rtd_list);
+	card->num_rtd = 0;
+
+	card->rtd_aux = devm_kzalloc(card->dev,
 				 sizeof(struct snd_soc_pcm_runtime) *
-				 (card->num_links + card->num_aux_devs),
+				 card->num_aux_devs,
 				 GFP_KERNEL);
-	if (card->rtd == NULL)
+	if (card->rtd_aux == NULL)
 		return -ENOMEM;
-	card->num_rtd = 0;
-	card->rtd_aux = &card->rtd[card->num_links];
-
-	for (i = 0; i < card->num_links; i++) {
-		card->rtd[i].card = card;
-		card->rtd[i].dai_link = &card->dai_link[i];
-		card->rtd[i].codec_dais = devm_kzalloc(card->dev,
-					sizeof(struct snd_soc_dai *) *
-					(card->rtd[i].dai_link->num_codecs),
-					GFP_KERNEL);
-		if (card->rtd[i].codec_dais == NULL)
-			return -ENOMEM;
-	}
 
 	for (i = 0; i < card->num_aux_devs; i++)
 		card->rtd_aux[i].card = card;
@@ -2442,8 +2488,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		return ret;
 
 	/* deactivate pins to sleep state */
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+	list_for_each_entry(rtd, &card->rtd_list, list)  {
 		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 		int j;
 

commit 3de7c420a2b1737844d893cbfc689a9b2b5528cd
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Mon Nov 9 23:19:58 2015 +0530

    ASoC: core: refactor soc_link_dai_widgets()
    
    In soc_link_dai_widgets() we refer to local widget variables as
    playback/capture_widget, but they are really sink/source widgets,
    so change the names accordingly
    
    Suggested-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 24b096066a07..d5e0bcbafb70 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1283,35 +1283,35 @@ static int soc_link_dai_widgets(struct snd_soc_card *card,
 {
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_dapm_widget *play_w, *capture_w;
+	struct snd_soc_dapm_widget *sink, *source;
 	int ret;
 
 	if (rtd->num_codecs > 1)
 		dev_warn(card->dev, "ASoC: Multiple codecs not supported yet\n");
 
 	/* link the DAI widgets */
-	play_w = codec_dai->playback_widget;
-	capture_w = cpu_dai->capture_widget;
-	if (play_w && capture_w) {
+	sink = codec_dai->playback_widget;
+	source = cpu_dai->capture_widget;
+	if (sink && source) {
 		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
-					   dai_link->num_params, capture_w,
-					   play_w);
+					   dai_link->num_params,
+					   source, sink);
 		if (ret != 0) {
 			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
-				play_w->name, capture_w->name, ret);
+				sink->name, source->name, ret);
 			return ret;
 		}
 	}
 
-	play_w = cpu_dai->playback_widget;
-	capture_w = codec_dai->capture_widget;
-	if (play_w && capture_w) {
+	sink = cpu_dai->playback_widget;
+	source = codec_dai->capture_widget;
+	if (sink && source) {
 		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
-					   dai_link->num_params, capture_w,
-					   play_w);
+					   dai_link->num_params,
+					   source, sink);
 		if (ret != 0) {
 			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
-				play_w->name, capture_w->name, ret);
+				sink->name, source->name, ret);
 			return ret;
 		}
 	}

commit 6439e5c2a784f6b00dd136df54d6f0859bc77af3
Merge: 7c9c29eefa8b 6f0c42269f00
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Oct 26 11:15:55 2015 +0900

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 6f0c42269f000b1e346c84d9a589f17aa94c96d8
Author: Jie Yang <yang.jie@intel.com>
Date:   Tue Oct 13 23:41:00 2015 +0800

    ASoC: compress: add config item for soc-compress to make it compiled only when needed
    
    We don't always need soc-compress in soc, here add a config item
    SND_SOC_COMPRESS, when nobody select it, the soc-compress will
    not be compiled.
    
    Here also change Kconfig to 'select SND_SOC_COMPRESS' for drivers
    that needed soc-compress.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6173d15236c3..6e543e18b4fa 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1370,9 +1370,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 		soc_dpcm_debugfs_add(rtd);
 #endif
 
-	if (cpu_dai->driver->compress_dai) {
+	if (cpu_dai->driver->compress_new) {
 		/*create compress_device"*/
-		ret = soc_new_compress(rtd, num);
+		ret = cpu_dai->driver->compress_new(rtd, num);
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: can't create compress %s\n",
 					 dai_link->stream_name);

commit 6c84e5917f83334f9196a50cfa31e72207b1a7f6
Author: Jyri Sarha <jsarha@ti.com>
Date:   Thu Sep 17 13:13:38 2015 +0300

    ASoC: soc-core: Fix sparse warning in be32_to_cpup() call
    
    Store return value of of_get_property() to a pointer of __be32 type as
    device tree has big endian type. This fixes a sparse warning couple of
    lines later when be32_to_cpup() is used to convert from big endian to
    cpu endian.
    
    The whole conversion is not really necessary, as we are only checking
    if the value is zero or not, but I wanted to add it to remind in the
    future that the data has to be converted before use. Compiler should
    optimize the unnecessary operations away.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c5e21ca0c015..3b471f9c98c6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3296,7 +3296,7 @@ static int snd_soc_of_get_slot_mask(struct device_node *np,
 				    unsigned int *mask)
 {
 	u32 val;
-	const u32 *of_slot_mask = of_get_property(np, prop_name, &val);
+	const __be32 *of_slot_mask = of_get_property(np, prop_name, &val);
 	int i;
 
 	if (!of_slot_mask)

commit 6131084a0bc966107021d8c89489f9cd1663b902
Author: Jyri Sarha <jsarha@ti.com>
Date:   Wed Sep 9 21:27:43 2015 +0300

    ASoC: simple-card: Add tdm slot mask support to simple-card
    
    Adds DT binding for explicitly choosing a tdm mask for DAI and uses it
    in simple-card. The API for snd_soc_of_parse_tdm_slot() has also been
    changed.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6173d15236c3..c5e21ca0c015 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3291,13 +3291,38 @@ int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets);
 
+static int snd_soc_of_get_slot_mask(struct device_node *np,
+				    const char *prop_name,
+				    unsigned int *mask)
+{
+	u32 val;
+	const u32 *of_slot_mask = of_get_property(np, prop_name, &val);
+	int i;
+
+	if (!of_slot_mask)
+		return 0;
+	val /= sizeof(u32);
+	for (i = 0; i < val; i++)
+		if (be32_to_cpup(&of_slot_mask[i]))
+			*mask |= (1 << i);
+
+	return val;
+}
+
 int snd_soc_of_parse_tdm_slot(struct device_node *np,
+			      unsigned int *tx_mask,
+			      unsigned int *rx_mask,
 			      unsigned int *slots,
 			      unsigned int *slot_width)
 {
 	u32 val;
 	int ret;
 
+	if (tx_mask)
+		snd_soc_of_get_slot_mask(np, "dai-tdm-slot-tx-mask", tx_mask);
+	if (rx_mask)
+		snd_soc_of_get_slot_mask(np, "dai-tdm-slot-rx-mask", rx_mask);
+
 	if (of_property_read_bool(np, "dai-tdm-slot-num")) {
 		ret = of_property_read_u32(np, "dai-tdm-slot-num", &val);
 		if (ret)

commit acb47ad5023fbd29a2c9a681c28b33968c9dcc9e
Merge: 1d1ed2c23e6f 775b07de4fa4 0643558f85e7 d5f1117ff60d 5e3cdaa20816 7d40acc38be5
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:55:21 2015 +0100

    Merge remote-tracking branches 'asoc/topic/mediatek', 'asoc/topic/mtk', 'asoc/topic/nuc900', 'asoc/topic/of-name' and 'asoc/topic/omap' into asoc-next

commit 7c0031360bd721254a52c56bd1c2e90b6d9df57b
Merge: 399962239c07 508a43fdd730 553de19a0e2f 628536ea0627 c5b8540dca22
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:53:39 2015 +0100

    Merge remote-tracking branches 'asoc/topic/davinci', 'asoc/topic/davinci-vcif', 'asoc/topic/doc' and 'asoc/topic/dpcm' into asoc-next

commit cb42e0f709a73caf4d631be32189bb1ca513ad25
Merge: ca945cf9fb88 f2988afedf2c
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:52:12 2015 +0100

    Merge remote-tracking branch 'asoc/topic/rt5645' into asoc-next

commit 24ecc23cf62a48ae47ccc40f0f226d45c962512e
Merge: a1780653b906 abd31b32dde4
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 15:51:52 2015 +0100

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 628536ea0627e71da654bd34b1942c85832dbdba
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Tue Aug 25 01:14:48 2015 -0600

    ASoC: Clean up docbook warnings
    
    A number of functions and structures in the sound subsystem had incomplete
    and/or obsolete DocBook comments, leading to warnings when the docs were
    built.  Correct those comments so that we can enjoy our audio in the
    absence of warning noise.
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 90d6335de17a..32242512d828 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2798,6 +2798,7 @@ EXPORT_SYMBOL_GPL(snd_soc_register_component);
 /**
  * snd_soc_unregister_component - Unregister a component from the ASoC core
  *
+ * @dev: The device to unregister
  */
 void snd_soc_unregister_component(struct device *dev)
 {
@@ -2877,7 +2878,8 @@ EXPORT_SYMBOL_GPL(snd_soc_add_platform);
 /**
  * snd_soc_register_platform - Register a platform with the ASoC core
  *
- * @platform: platform to register
+ * @dev: The device for the platform
+ * @platform_drv: The driver for the platform
  */
 int snd_soc_register_platform(struct device *dev,
 		const struct snd_soc_platform_driver *platform_drv)
@@ -2938,7 +2940,7 @@ EXPORT_SYMBOL_GPL(snd_soc_lookup_platform);
 /**
  * snd_soc_unregister_platform - Unregister a platform from the ASoC core
  *
- * @platform: platform to unregister
+ * @dev: platform to unregister
  */
 void snd_soc_unregister_platform(struct device *dev)
 {
@@ -3029,7 +3031,10 @@ static int snd_soc_codec_set_bias_level(struct snd_soc_dapm_context *dapm,
 /**
  * snd_soc_register_codec - Register a codec with the ASoC core
  *
- * @codec: codec to register
+ * @dev: The parent device for this codec
+ * @codec_drv: Codec driver
+ * @dai_drv: The associated DAI driver
+ * @num_dai: Number of DAIs
  */
 int snd_soc_register_codec(struct device *dev,
 			   const struct snd_soc_codec_driver *codec_drv,
@@ -3128,7 +3133,7 @@ EXPORT_SYMBOL_GPL(snd_soc_register_codec);
 /**
  * snd_soc_unregister_codec - Unregister a codec from the ASoC core
  *
- * @codec: codec to unregister
+ * @dev: codec to unregister
  */
 void snd_soc_unregister_codec(struct device *dev)
 {

commit 5e3cdaa20816dd2fe4dc17d06a9f0dae0abc930c
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 15 07:07:42 2015 +0000

    ASoC: core: add snd_soc_of_parse_audio_prefix()
    
    Current ASoC can add name_prefix for DAPM, and it is necessary for
    route settings. This patch adds snd_soc_of_parse_audio_prefix() for
    this purpose. It will be used with snd_soc_of_parse_audio_routing().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Tested-by: Keita Kobayashi <keita.kobayashi.ym@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3a4a5c0e3f97..fd15d5418647 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3303,6 +3303,26 @@ int snd_soc_of_parse_tdm_slot(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_tdm_slot);
 
+void snd_soc_of_parse_audio_prefix(struct snd_soc_card *card,
+				   struct snd_soc_codec_conf *codec_conf,
+				   struct device_node *of_node,
+				   const char *propname)
+{
+	struct device_node *np = card->dev->of_node;
+	const char *str;
+	int ret;
+
+	ret = of_property_read_string(np, propname, &str);
+	if (ret < 0) {
+		/* no prefix is not error */
+		return;
+	}
+
+	codec_conf->of_node	= of_node;
+	codec_conf->name_prefix	= str;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_prefix);
+
 int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname)
 {

commit 7d1442b4c4142d94a83451d4e7a11db8aee132ab
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Jul 15 23:02:39 2015 +0900

    ASoC: Fix warning caused by a typo in comments of snd_soc_add_platform()
    
    This patch fix following warnings.
    Warning(.//sound/soc/soc-core.c:2855): No description found
    for parameter 'platform_drv'
    Warning(.//sound/soc/soc-core.c:2855): Excess function parameter
    'platform_driver' description in 'snd_soc_add_platform'
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 68e54144467e..90d6335de17a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2838,7 +2838,7 @@ static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
  * snd_soc_add_platform - Add a platform to the ASoC core
  * @dev: The parent device for the platform
  * @platform: The platform to add
- * @platform_driver: The driver for the platform
+ * @platform_drv: The driver for the platform
  */
 int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 		const struct snd_soc_platform_driver *platform_drv)

commit 231b86b1d81a75e5212329e2c42faefddcaa9208
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Jul 15 23:02:38 2015 +0900

    ASoC: Fix warning while make xmldocs caused by soc-core.c
    
    This patch fix following warning while make xmldocs.
    Warning(.//sound/soc/soc-core.c:2148): No description found
    for parameter 'ratio'
    
    Add missing ":"
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3a4a5c0e3f97..68e54144467e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2127,7 +2127,7 @@ EXPORT_SYMBOL_GPL(snd_soc_codec_set_pll);
 /**
  * snd_soc_dai_set_bclk_ratio - configure BCLK to sample rate ratio.
  * @dai: DAI
- * @ratio Ratio of BCLK to Sample rate.
+ * @ratio: Ratio of BCLK to Sample rate.
  *
  * Configures the DAI for a preset BCLK to sample rate ratio.
  */

commit 2210438b6aae9668cf89c272fef935b83aedf81d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jul 8 22:14:48 2015 +0200

    ASoC: Free card DAPM context on snd_soc_instantiate_card() error path
    
    Make sure the to free the card DAPM context if snd_soc_instantiate_card()
    fails, otherwise the memory allocated for the DAPM widgets is leaked.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3a4a5c0e3f97..0e1e69c7abd5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1716,6 +1716,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	if (card->remove)
 		card->remove(card);
 
+	snd_soc_dapm_free(&card->dapm);
 	soc_cleanup_card_debugfs(card);
 	snd_card_free(card->snd_card);
 

commit abd31b32dde4683df6fd0439caa314aafd751698
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jul 8 20:47:44 2015 +0200

    ASoC: Use card field to indicate whether a component is bound
    
    Use the card field of a component to indicate whether it is bound or not.
    This makes a certain sense given that the field contains the card the
    component is bound to and a component can only be bound to one card at a
    time. And it also requires to unset the card field when the component is
    unbound from the card.
    
    This makes the probded flag redundant and it can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 96bb71aea529..42575b03411e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -978,7 +978,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 
 static void soc_remove_component(struct snd_soc_component *component)
 {
-	if (!component->probed)
+	if (!component->card)
 		return;
 
 	/* This is a HACK and will be removed soon */
@@ -991,7 +991,7 @@ static void soc_remove_component(struct snd_soc_component *component)
 	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 
 	soc_cleanup_component_debugfs(component);
-	component->probed = 0;
+	component->card = NULL;
 	module_put(component->dev->driver->owner);
 }
 
@@ -1105,7 +1105,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 	if (!strcmp(component->name, "snd-soc-dummy"))
 		return 0;
 
-	if (component->probed) {
+	if (component->card) {
 		if (component->card != card) {
 			dev_err(component->dev,
 				"Trying to bind component to card \"%s\" but is already bound to card \"%s\"\n",
@@ -1115,13 +1115,13 @@ static int soc_probe_component(struct snd_soc_card *card,
 		return 0;
 	}
 
+	if (!try_module_get(component->dev->driver->owner))
+		return -ENODEV;
+
 	component->card = card;
 	dapm->card = card;
 	soc_set_name_prefix(card, component);
 
-	if (!try_module_get(component->dev->driver->owner))
-		return -ENODEV;
-
 	soc_init_component_debugfs(component);
 
 	if (component->dapm_widgets) {
@@ -1165,7 +1165,6 @@ static int soc_probe_component(struct snd_soc_card *card,
 		snd_soc_dapm_add_routes(dapm, component->dapm_routes,
 					component->num_dapm_routes);
 
-	component->probed = 1;
 	list_add(&dapm->list, &card->dapm_list);
 
 	/* This is a HACK and will be removed soon */
@@ -1176,6 +1175,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 
 err_probe:
 	soc_cleanup_component_debugfs(component);
+	component->card = NULL;
 	module_put(component->dev->driver->owner);
 
 	return ret;
@@ -1459,7 +1459,7 @@ static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 		rtd->dev_registered = 0;
 	}
 
-	if (component && component->probed)
+	if (component)
 		soc_remove_component(component);
 }
 

commit 1b7c12316982f74a5b8e7704c24cf5524d0723a3
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jul 8 20:47:43 2015 +0200

    ASoC: Prevent components from being bound to multiple cards
    
    A component can only be bound to a single card at a time. Binding it to
    card while it is already bound to another will result in undefined
    behavior.
    
    As the undefined behavior might only manifest itself later on it is not
    necessarily always straight forward to find the cause. To prevent this add
    a check that refuses to bind a component to multiple cards as well as
    prints a error describing the problem.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6ce621749f8d..96bb71aea529 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1102,9 +1102,19 @@ static int soc_probe_component(struct snd_soc_card *card,
 	struct snd_soc_dai *dai;
 	int ret;
 
-	if (!strcmp(component->name, "snd-soc-dummy") || component->probed)
+	if (!strcmp(component->name, "snd-soc-dummy"))
 		return 0;
 
+	if (component->probed) {
+		if (component->card != card) {
+			dev_err(component->dev,
+				"Trying to bind component to card \"%s\" but is already bound to card \"%s\"\n",
+				card->name, component->card->name);
+			return -ENODEV;
+		}
+		return 0;
+	}
+
 	component->card = card;
 	dapm->card = card;
 	soc_set_name_prefix(card, component);

commit 6e78108bda78adbb2d4ef55ec60a388aba975797
Author: Shengjiu Wang <shengjiu.wang@freescale.com>
Date:   Fri Jul 3 16:30:30 2015 +0800

    ASoC: core: Don't probe the component which is dummy
    
    Dummy dai can be used by multiple sound card. But it only belong to one
    card's dapm list. If another card use it, there will be dapm_assert_locked
    warning.
    
    [   20.015782] WARNING: CPU: 1 PID: 661 at sound/soc/soc-dapm.c:124 dapm_assert_locked.isra.36+0x4c/0x58()
    [   20.025249] Modules linked in:
    [   20.028349] CPU: 1 PID: 661 Comm: aplay Not tainted 4.1.0-rc6-next-20150605-00004-gaee05d8-dirty #92
    [   20.037528] Hardware name: Freescale i.MX6 Quad/DualLite (Device Tree)
    [   20.044110] Backtrace:
    [   20.046614] [<80012e00>] (dump_backtrace) from [<80012fa0>] (show_stack+0x18/0x1c)
    [   20.054229]  r6:809e8060 r5:00000000 r4:00000000 r3:00000000
    [   20.060002] [<80012f88>] (show_stack) from [<807a0f74>] (dump_stack+0x80/0x9c)
    [   20.067293] [<807a0ef4>] (dump_stack) from [<8002b144>] (warn_slowpath_common+0x7c/0xb4)
    [   20.075427]  r5:0000007c r4:00000000
    [   20.079065] [<8002b0c8>] (warn_slowpath_common) from [<8002b1a0>] (warn_slowpath_null+0x24/0x2c)
    [   20.087898]  r8:00000001 r7:88007c28 r6:ed94a680 r5:809e83e4 r4:ed83d6c0
    [   20.094747] [<8002b17c>] (warn_slowpath_null) from [<8058403c>] (dapm_assert_locked.isra.36+0x4c/0x58)
    [   20.104101] [<80583ff0>] (dapm_assert_locked.isra.36) from [<805842ec>] (dapm_mark_dirty+0x64/0xa4)
    [   20.113165] [<80584288>] (dapm_mark_dirty) from [<805853a8>] (soc_dapm_dai_stream_event.isra.42+0x30/0xc8)
    [   20.122863]  r8:ed9b5dbc r7:00000000 r6:00000001 r5:00000001 r4:ed83d6c0
    [   20.129706] [<80585378>] (soc_dapm_dai_stream_event.isra.42) from [<80587e28>] (snd_soc_dapm_stream_event+0x78/0xa0)
    [   20.140264]  r5:ee2ee62c r4:00000001
    [   20.143918] [<80587db0>] (snd_soc_dapm_stream_event) from [<8058957c>] (soc_pcm_prepare+0x138/0x21c)
    [   20.153058]  r8:ed8d9480 r7:00000000 r6:ed9b0e00 r5:00000001 r4:ee2ee62c r3:00000000
    ...
    
    This patch is to not probe the dummy component in soc_probe_component. Then
    there is no widget created for dummy DAI, and also don't need to check the
    dummy dai in dapm_connect_dai_link_widgets().
    
    Signed-off-by: Shengjiu Wang <shengjiu.wang@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3a4a5c0e3f97..6ce621749f8d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1102,7 +1102,7 @@ static int soc_probe_component(struct snd_soc_card *card,
 	struct snd_soc_dai *dai;
 	int ret;
 
-	if (component->probed)
+	if (!strcmp(component->name, "snd-soc-dummy") || component->probed)
 		return 0;
 
 	component->card = card;

commit 4890140f3888b4a4baef90d84e278858afe45248
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jul 6 15:38:11 2015 +0200

    ASoC: Remove snd_soc_codec dapm field
    
    There are no more direct users of the snd_soc_codec DAPM field left. So we
    can finally remove it and switch over to directly using the component DAPM
    context and remove the dapm_ptr indirection.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3a4a5c0e3f97..3747111f8759 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -654,10 +654,12 @@ int snd_soc_suspend(struct device *dev)
 
 	/* suspend all CODECs */
 	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
+		struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+
 		/* If there are paths active then the CODEC will be held with
 		 * bias _ON and should not be suspended. */
 		if (!codec->suspended) {
-			switch (codec->dapm.bias_level) {
+			switch (snd_soc_dapm_get_bias_level(dapm)) {
 			case SND_SOC_BIAS_STANDBY:
 				/*
 				 * If the CODEC is capable of idle
@@ -665,7 +667,7 @@ int snd_soc_suspend(struct device *dev)
 				 * means it's doing something,
 				 * otherwise fall through.
 				 */
-				if (codec->dapm.idle_bias_off) {
+				if (dapm->idle_bias_off) {
 					dev_dbg(codec->dev,
 						"ASoC: idle_bias_off CODEC on over suspend\n");
 					break;
@@ -2651,10 +2653,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->probe = component->driver->probe;
 	component->remove = component->driver->remove;
 
-	if (!component->dapm_ptr)
-		component->dapm_ptr = &component->dapm;
-
-	dapm = component->dapm_ptr;
+	dapm = &component->dapm;
 	dapm->dev = dev;
 	dapm->component = component;
 	dapm->bias_level = SND_SOC_BIAS_OFF;
@@ -3036,6 +3035,7 @@ int snd_soc_register_codec(struct device *dev,
 			   struct snd_soc_dai_driver *dai_drv,
 			   int num_dai)
 {
+	struct snd_soc_dapm_context *dapm;
 	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
 	int ret, i;
@@ -3046,7 +3046,6 @@ int snd_soc_register_codec(struct device *dev,
 	if (codec == NULL)
 		return -ENOMEM;
 
-	codec->component.dapm_ptr = &codec->dapm;
 	codec->component.codec = codec;
 
 	ret = snd_soc_component_initialize(&codec->component,
@@ -3076,12 +3075,14 @@ int snd_soc_register_codec(struct device *dev,
 	if (codec_drv->read)
 		codec->component.read = snd_soc_codec_drv_read;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
-	codec->dapm.idle_bias_off = codec_drv->idle_bias_off;
-	codec->dapm.suspend_bias_off = codec_drv->suspend_bias_off;
+
+	dapm = snd_soc_codec_get_dapm(codec);
+	dapm->idle_bias_off = codec_drv->idle_bias_off;
+	dapm->suspend_bias_off = codec_drv->suspend_bias_off;
 	if (codec_drv->seq_notifier)
-		codec->dapm.seq_notifier = codec_drv->seq_notifier;
+		dapm->seq_notifier = codec_drv->seq_notifier;
 	if (codec_drv->set_bias_level)
-		codec->dapm.set_bias_level = snd_soc_codec_set_bias_level;
+		dapm->set_bias_level = snd_soc_codec_set_bias_level;
 	codec->dev = dev;
 	codec->driver = codec_drv;
 	codec->component.val_bytes = codec_drv->reg_word_size;

commit 28bedc59469e869c1ed9c30384d61798d6c3eb5c
Merge: b5a8342c1d94 932ae8809469 208ba89b402d 3d907cc30d07 2d52d1723982 7a8c78675f3c
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jun 5 18:55:05 2015 +0100

    Merge remote-tracking branches 'asoc/topic/topology', 'asoc/topic/twl6040', 'asoc/topic/wm5100', 'asoc/topic/wm8741' and 'asoc/topic/wm8960' into asoc-next

commit 4b57895522b150966eebcf18f929e1c522d90bb9
Merge: 2914b7004b93 cc76e7def0fa
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jun 5 18:54:45 2015 +0100

    Merge remote-tracking branch 'asoc/topic/dapm' into asoc-next

commit 8a9782346dccd82cf912552735bda619de4efd8c
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri May 29 19:06:14 2015 +0100

    ASoC: topology: Add topology core
    
    The topology core parses the FW topology file for known block types and
    instanciates any common ALSA/ASoC objects that it discovers. The core
    also passes any block that is does not understand to client component
    drivers for enumeration.
    
    The core exports some APIs to client drivers in order to load and unload
    firmware topology data as use case require.
    
    Currently the core deals with the following object types :-
    
     o kcontrols. This includes TLV, enumerated and bytes controls.
     o DAPM widgets. All types with any associated kcontrol.
     o DAPM graph.
     o FE PCM. FE PCM capabilities and configuration can be defined.
     o BE DAI Link. BE DAI link capabilities and configuration can be defined.
     o Codec <-> codec style links capabilities and configuration.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 95b5f034d864..8fafdca5cdf5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -40,6 +40,7 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/soc-dpcm.h>
+#include <sound/soc-topology.h>
 #include <sound/initval.h>
 
 #define CREATE_TRACE_POINTS
@@ -2422,6 +2423,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		card->rtd_aux[i].card = card;
 
 	INIT_LIST_HEAD(&card->dapm_dirty);
+	INIT_LIST_HEAD(&card->dobj_list);
 	card->instantiated = 0;
 	mutex_init(&card->mutex);
 	mutex_init(&card->dapm_mutex);
@@ -2736,6 +2738,7 @@ static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
 	}
 
 	list_add(&component->list, &component_list);
+	INIT_LIST_HEAD(&component->dobj_list);
 }
 
 static void snd_soc_component_add(struct snd_soc_component *component)
@@ -2812,6 +2815,7 @@ void snd_soc_unregister_component(struct device *dev)
 	return;
 
 found:
+	snd_soc_tplg_component_remove(cmpnt, SND_SOC_TPLG_INDEX_ALL);
 	snd_soc_component_del_unlocked(cmpnt);
 	mutex_unlock(&client_mutex);
 	snd_soc_component_cleanup(cmpnt);

commit 3e0aa8d83bf8e6d414e538cf1046a3a7b48017bc
Author: Jyri Sarha <jsarha@ti.com>
Date:   Tue May 26 21:59:05 2015 +0300

    ASoC: core: If component doesn't have of_node use parent's node instead
    
    If an ASoC component device does not have a device tree node, use its
    parent's node instead, when looking for a matching DAI based on a
    device tree reference.
    
    This allows video device drivers to register a separate child device
    for their ASoC side audio functionality.  [And MFDs in general --
    broonie]
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 95414a2cec1b..80b7cf5ef69a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -895,12 +895,17 @@ static struct snd_soc_dai *snd_soc_find_dai(
 {
 	struct snd_soc_component *component;
 	struct snd_soc_dai *dai;
+	struct device_node *component_of_node;
 
 	lockdep_assert_held(&client_mutex);
 
 	/* Find CPU DAI from registered DAIs*/
 	list_for_each_entry(component, &component_list, list) {
-		if (dlc->of_node && component->dev->of_node != dlc->of_node)
+		component_of_node = component->dev->of_node;
+		if (!component_of_node && component->dev->parent)
+			component_of_node = component->dev->parent->of_node;
+
+		if (dlc->of_node && component_of_node != dlc->of_node)
 			continue;
 		if (dlc->name && strcmp(component->name, dlc->name))
 			continue;
@@ -3480,11 +3485,16 @@ static int snd_soc_get_dai_name(struct of_phandle_args *args,
 				const char **dai_name)
 {
 	struct snd_soc_component *pos;
+	struct device_node *component_of_node;
 	int ret = -EPROBE_DEFER;
 
 	mutex_lock(&client_mutex);
 	list_for_each_entry(pos, &component_list, list) {
-		if (pos->dev->of_node != args->np)
+		component_of_node = pos->dev->of_node;
+		if (!component_of_node && pos->dev->parent)
+			component_of_node = pos->dev->parent->of_node;
+
+		if (component_of_node != args->np)
 			continue;
 
 		if (pos->driver->of_xlate_dai_name) {

commit d6b6c2ca6a2fbbb39051ec1d2763a947e3283683
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 26 14:40:14 2015 +0200

    ASoC: Simplify format_register_str() without stack usages
    
    Instead of allocating two string buffers on stack and copying them
    back, manipulate directly the target string buffer.  This simplifies
    the code well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7d028e8a7f1d..95414a2cec1b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -92,30 +92,21 @@ static int format_register_str(struct snd_soc_codec *codec,
 	int wordsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
 	int regsize = codec->driver->reg_word_size * 2;
 	int ret;
-	char tmpbuf[len + 1];
-	char regbuf[regsize + 1];
-
-	/* since tmpbuf is allocated on the stack, warn the callers if they
-	 * try to abuse this function */
-	WARN_ON(len > 63);
 
 	/* +2 for ': ' and + 1 for '\n' */
 	if (wordsize + regsize + 2 + 1 != len)
 		return -EINVAL;
 
-	ret = snd_soc_read(codec, reg);
-	if (ret < 0) {
-		memset(regbuf, 'X', regsize);
-		regbuf[regsize] = '\0';
-	} else {
-		snprintf(regbuf, regsize + 1, "%.*x", regsize, ret);
-	}
-
-	/* prepare the buffer */
-	snprintf(tmpbuf, len + 1, "%.*x: %s\n", wordsize, reg, regbuf);
-	/* copy it back to the caller without the '\0' */
-	memcpy(buf, tmpbuf, len);
+	sprintf(buf, "%.*x: ", wordsize, reg);
+	buf += wordsize + 2;
 
+	ret = snd_soc_read(codec, reg);
+	if (ret < 0)
+		memset(buf, 'X', regsize);
+	else
+		sprintf(buf, "%.*x", regsize, ret);
+	buf[regsize] = '\n';
+	/* no NUL-termination needed */
 	return 0;
 }
 

commit 9e4980896c46ed84d0aa27382e18d1cacb7cb86e
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Fri May 15 10:38:27 2015 +0100

    ASoC: skip legacy dai naming if dai driver has all the information
    
    Original issue is that the id field in the dai is not same as the id
    in dai_driver when dai driver count == 1. This is due to the legacy
    dai naming check, which could possibly cause issues if the audio drivers
    written in assumption that dai->id would be always equal to dai_driver->id.
    This assumption is true only if the dai driver count is greater than 1,
    and false if dai driver count is 1. On Qcom Lpass driver we hit such
    issue while adding support to apq8016.
    
    The code path which falls back to legacy naming for cases where num_dai
    == 1 does not check if there is any valid information in the dai_driver.
    This patch fixes that by checking if the dai_driver has valid id and
    name before falling back to legacy dai naming
    Although the drivers can work around this issue by only using
    dai->driver->id, but this patch attempts to fix the actual issue.
    
    Suggested-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Acked-by: Kenneth Westfield <kwestfie@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 23732523f87c..7d028e8a7f1d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2599,7 +2599,8 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 		 * the same naming style even though those DAIs are not
 		 * component-less anymore.
 		 */
-		if (count == 1 && legacy_dai_naming) {
+		if (count == 1 && legacy_dai_naming &&
+			(dai_drv[i].id == 0 || dai_drv[i].name == NULL)) {
 			dai->name = fmt_single_name(dev, &dai->id);
 		} else {
 			dai->name = fmt_multiple_name(dev, &dai_drv[i]);

commit b8faaba4a655d58b67ba28598c22a48aa844b489
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri May 15 12:41:30 2015 +0200

    ASoC: Drop unnecessary bias level check on resume
    
    The suspended flag will only be set if the CODEC bias level was either
    STANDBY or OFF. This means we don't need to check for that on resume since
    the condition will always be true.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 23732523f87c..95b5f034d864 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -750,23 +750,10 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
-		/* If the CODEC was idle over suspend then it will have been
-		 * left with bias OFF or STANDBY and suspended so we must now
-		 * resume.  Otherwise the suspend was suppressed.
-		 */
 		if (codec->suspended) {
-			switch (codec->dapm.bias_level) {
-			case SND_SOC_BIAS_STANDBY:
-			case SND_SOC_BIAS_OFF:
-				if (codec->driver->resume)
-					codec->driver->resume(codec);
-				codec->suspended = 0;
-				break;
-			default:
-				dev_dbg(codec->dev,
-					"ASoC: CODEC was on over suspend\n");
-				break;
-			}
+			if (codec->driver->resume)
+				codec->driver->resume(codec);
+			codec->suspended = 0;
 		}
 	}
 

commit d0a3997c0c3f9351e24029349dee65dd1d9e8d84
Merge: 6d50ff91d978 d6eb9e3ec78c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 15 15:41:41 2015 -0700

    Merge tag 'sound-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "There have been major modernization with the standard bus: in ALSA
      sequencer core and HD-audio.  Also, HD-audio receives the regmap
      support replacing the in-house cache register cache code.  These
      changes shouldn't impact the existing behavior, but rather
      refactoring.
    
      In addition, HD-audio got the code split to a core library part and
      the "legacy" driver parts.  This is a preliminary work for adapting
      the upcoming ASoC HD-audio driver, and the whole transition is still
      work in progress, likely finished in 4.1.
    
      Along with them, there are many updates in ASoC area as usual, too:
      lots of cleanups, Intel code shuffling, etc.
    
      Here are some highlights:
    
      ALSA core:
       - PCM: the audio timestamp / wallclock enhancement
       - PCM: fixes in DPCM management
       - Fixes / cleanups of user-space control element management
       - Sequencer: modernization using the standard bus
    
      HD-audio:
       - Modernization using the standard bus
       - Regmap support
       - Use standard runtime PM for codec power saving
       - Widget-path based power-saving for IDT, VIA and Realtek codecs
       - Reorganized sysfs entries for each codec object
       - More Dell headset support
    
      ASoC:
       - Move of jack registration to the card level
       - Lots of ASoC cleanups, mainly moving things from the CODEC level to
         the card level
       - Support for DAPM routes specified by both the machine driver and DT
       - Continuing improvements to rcar
       - pcm512x enhacements
       - Intel platforms updates
       - rt5670 updates / fixes
       - New platforms / devices: some non-DSP Qualcomm platforms, Google's
         Storm platform, Maxmim MAX98925 CODECs and the Ingenic JZ4780 SoC
    
      Misc:
       - ice1724: Improved ESI W192M support
       - emu10k1: Emu 1010 fixes/enhancement"
    
    * tag 'sound-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (411 commits)
      ALSA: hda - set GET bit when adding a vendor verb to the codec regmap
      ALSA: hda/realtek - Enable the ALC292 dock fixup on the Thinkpad T450
      ALSA: hda - Fix another race in runtime PM refcounting
      ALSA: hda - Expose codec type sysfs
      ALSA: ctl: fix to handle several elements added by one operation for userspace element
      ASoC: Intel: fix array_size.cocci warnings
      ASoC: n810: Automatically disconnect non-connected pins
      ASoC: n810: Consistently pass the card DAPM context to n810_ext_control()
      ASoC: davinci-evm: Use card DAPM context to access widgets
      ASoC: mop500_ab8500: Use card DAPM context to access widgets
      ASoC: wm1133-ev1: Use card DAPM context to access widgets
      ASoC: atmel: Improve machine driver compile test coverage
      ASoC: atmel: Add dependency to SND_SOC_I2C_AND_SPI where necessary
      ALSA: control: Fix a typo of SNDRV_CTL_ELEM_ACCESS_TLV_* with SNDRV_CTL_TLV_OP_*
      ALSA: usb-audio: Don't attempt to get Microsoft Lifecam Cinema sample rate
      ASoC: rnsd: fix build regression without CONFIG_OF
      ALSA: emu10k1: add toggles for E-mu 1010 optical ports
      ALSA: ctl: fill identical information to return value when adding userspace elements
      ALSA: ctl: fix a bug to return no identical information in info operation for userspace controls
      ALSA: ctl: confirm to return all identical information in 'activate' event
      ...

commit d0bbe0dd353af9521e9d8bc5236308c677b6f62a
Merge: 8de29a35dc84 0e4f93e5017d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 09:50:27 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree from Jiri Kosina:
     "Usual trivial tree updates.  Nothing outstanding -- mostly printk()
      and comment fixes and unused identifier removals"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial:
      goldfish: goldfish_tty_probe() is not using 'i' any more
      powerpc: Fix comment in smu.h
      qla2xxx: Fix printks in ql_log message
      lib: correct link to the original source for div64_u64
      si2168, tda10071, m88ds3103: Fix firmware wording
      usb: storage: Fix printk in isd200_log_config()
      qla2xxx: Fix printk in qla25xx_setup_mode
      init/main: fix reset_device comment
      ipwireless: missing assignment
      goldfish: remove unreachable line of code
      coredump: Fix do_coredump() comment
      stacktrace.h: remove duplicate declaration task_struct
      smpboot.h: Remove unused function prototype
      treewide: Fix typo in printk messages
      treewide: Fix typo in printk messages
      mod_devicetable: fix comment for match_flags

commit e1f059937a2b90a1dbf314959776d3f51b4ab20d
Merge: 626761ad022c 46172b6c2666 c6b424fee751 5116ede10dc9 fa41181fe375
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Apr 12 19:49:06 2015 +0100

    Merge remote-tracking branches 'asoc/topic/link-param', 'asoc/topic/max98090', 'asoc/topic/max98925' and 'asoc/topic/nuc900' into asoc-next

commit a5053a8e200e865ab786384df3f985a3cbb346fe
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 10 09:47:00 2015 +0000

    ASoC: core: call snd_soc_runtime_set_dai_fmt() before soc_new_pcm()
    
    Current snd_soc_runtime_set_dai_fmt() is called after
    soc_probe_link_dais(). this means snd_soc_dai_set_fmt() will be
    called after soc_new_pcm().
    
    Before appling 1efb53a220b78fdfdbb97b726a2156713e75bdab
    (ASoC: simple-card: Remove support for setting differing DAI formats)
    simple-card user had (1) snd_soc_dai_set_fmt() -> soc_new_pcm(),
    but, after that it is (2) soc_new_pcm() -> snd_soc_dai_set_fmt().
    At least rsnd driver is assuming (1) pattern.
    
    This patch move snd_soc_dai_set_fmt() into soc_probe_link_dais()
    after the dai_link->init section to solve this issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 25fcd80cb108..2fb3bf738b5b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1359,6 +1359,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 		}
 	}
 
+	if (dai_link->dai_fmt)
+		snd_soc_runtime_set_dai_fmt(rtd, dai_link->dai_fmt);
+
 	ret = soc_post_component_init(rtd, dai_link->name);
 	if (ret)
 		return ret;
@@ -1672,12 +1675,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_add_routes(&card->dapm, card->of_dapm_routes,
 					card->num_of_dapm_routes);
 
-	for (i = 0; i < card->num_links; i++) {
-		if (card->dai_link[i].dai_fmt)
-			snd_soc_runtime_set_dai_fmt(&card->rtd[i],
-				card->dai_link[i].dai_fmt);
-	}
-
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
 		 "%s", card->name);
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),

commit 1ddca24c532247894eb4430e9315e690306cf860
Merge: 5f97a4bd2c92 3185878a70e7
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 10 16:09:21 2015 +0100

    Merge branch 'topic/dapm-dt' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-core

commit 5f97a4bd2c92aff216581d662a37163881ac3888
Merge: 6553bf06a369 7c0e3facf39a
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 10 16:04:46 2015 +0100

    Merge branch 'topic/delay' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-core

commit 6553bf06a369683408895b87e5172aa99a9266bd
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Apr 9 10:52:38 2015 +0200

    ASoC: Don't try to register debugfs entries if the parent does not exist
    
    If the registration of a debugfs directory fails this is treated as a
    non-fatal error in ASoC and operation continues as normal. This means we
    need to be careful and check if the parent debugfs directory exists if we
    try to register a debugfs file or sub-directory. Otherwise we might end up
    passing NULL for the parent and the file or directory will be registered in
    the top-level debugfs directory.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d29c68ad83c7..9dfa2e241865 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -292,6 +292,9 @@ static const struct file_operations codec_reg_fops = {
 
 static void soc_init_component_debugfs(struct snd_soc_component *component)
 {
+	if (!component->card->debugfs_card_root)
+		return;
+
 	if (component->debugfs_prefix) {
 		char *name;
 
@@ -455,6 +458,9 @@ static const struct file_operations platform_list_fops = {
 
 static void soc_init_card_debugfs(struct snd_soc_card *card)
 {
+	if (!snd_soc_debugfs_root)
+		return;
+
 	card->debugfs_card_root = debugfs_create_dir(card->name,
 						     snd_soc_debugfs_root);
 	if (!card->debugfs_card_root) {
@@ -476,6 +482,34 @@ static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 	debugfs_remove_recursive(card->debugfs_card_root);
 }
 
+
+static void snd_soc_debugfs_init(void)
+{
+	snd_soc_debugfs_root = debugfs_create_dir("asoc", NULL);
+	if (IS_ERR(snd_soc_debugfs_root) || !snd_soc_debugfs_root) {
+		pr_warn("ASoC: Failed to create debugfs directory\n");
+		snd_soc_debugfs_root = NULL;
+		return;
+	}
+
+	if (!debugfs_create_file("codecs", 0444, snd_soc_debugfs_root, NULL,
+				 &codec_list_fops))
+		pr_warn("ASoC: Failed to create CODEC list debugfs file\n");
+
+	if (!debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
+				 &dai_list_fops))
+		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
+
+	if (!debugfs_create_file("platforms", 0444, snd_soc_debugfs_root, NULL,
+				 &platform_list_fops))
+		pr_warn("ASoC: Failed to create platform list debugfs file\n");
+}
+
+static void snd_soc_debugfs_exit(void)
+{
+	debugfs_remove_recursive(snd_soc_debugfs_root);
+}
+
 #else
 
 #define soc_init_codec_debugfs NULL
@@ -497,6 +531,15 @@ static inline void soc_init_card_debugfs(struct snd_soc_card *card)
 static inline void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 {
 }
+
+static inline void snd_soc_debugfs_init(void)
+{
+}
+
+static inline void snd_soc_debugfs_exit(void)
+{
+}
+
 #endif
 
 struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
@@ -3580,26 +3623,7 @@ EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_link_codecs);
 
 static int __init snd_soc_init(void)
 {
-#ifdef CONFIG_DEBUG_FS
-	snd_soc_debugfs_root = debugfs_create_dir("asoc", NULL);
-	if (IS_ERR(snd_soc_debugfs_root) || !snd_soc_debugfs_root) {
-		pr_warn("ASoC: Failed to create debugfs directory\n");
-		snd_soc_debugfs_root = NULL;
-	}
-
-	if (!debugfs_create_file("codecs", 0444, snd_soc_debugfs_root, NULL,
-				 &codec_list_fops))
-		pr_warn("ASoC: Failed to create CODEC list debugfs file\n");
-
-	if (!debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
-				 &dai_list_fops))
-		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
-
-	if (!debugfs_create_file("platforms", 0444, snd_soc_debugfs_root, NULL,
-				 &platform_list_fops))
-		pr_warn("ASoC: Failed to create platform list debugfs file\n");
-#endif
-
+	snd_soc_debugfs_init();
 	snd_soc_util_init();
 
 	return platform_driver_register(&soc_driver);
@@ -3609,9 +3633,9 @@ module_init(snd_soc_init);
 static void __exit snd_soc_exit(void)
 {
 	snd_soc_util_exit();
+	snd_soc_debugfs_exit();
 
 #ifdef CONFIG_DEBUG_FS
-	debugfs_remove_recursive(snd_soc_debugfs_root);
 #endif
 	platform_driver_unregister(&soc_driver);
 }

commit 2e55b90a5e234524f8195c657006ec4f71103dff
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Apr 9 10:52:37 2015 +0200

    ASoC: Make soc_dpcm_debugfs_add() non-fatal
    
    Failing to register the debugfs entries is not fatal and will not affect
    normal operation of the sound card. Don't abort the card registration if
    soc_dpcm_debugfs_add() fails.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3f18fa7f090d..d29c68ad83c7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1328,15 +1328,8 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 
 #ifdef CONFIG_DEBUG_FS
 	/* add DPCM sysfs entries */
-	if (dai_link->dynamic) {
-		ret = soc_dpcm_debugfs_add(rtd);
-		if (ret < 0) {
-			dev_err(rtd->dev,
-				"ASoC: failed to add dpcm sysfs entries: %d\n",
-				ret);
-			return ret;
-		}
-	}
+	if (dai_link->dynamic)
+		soc_dpcm_debugfs_add(rtd);
 #endif
 
 	if (cpu_dai->driver->compress_dai) {

commit 0757d834eb7482e5763fb9ee014abb50789f906a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Apr 9 10:52:36 2015 +0200

    ASoC: Create card debugfs directory earlier
    
    Create the card debugfs directory at the begining of the initilization
    rather then the end as various steps in the initilization sequence will try
    to register files and sub-directories in the card directory.
    
    Fixes: 4e2576bd36a1 ("ASoC: soc-core: initialize debugfs in snd_soc_instantiate_card()")
    Reported-by: Fabio Estevam <festevam@gmail.com>
    Reported-by: Nicolin Chen <nicoleotsuka@gmail.com>
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 71585d0562fa..3f18fa7f090d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1559,6 +1559,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		goto base_error;
 	}
 
+	soc_init_card_debugfs(card);
+
 	card->dapm.bias_level = SND_SOC_BIAS_OFF;
 	card->dapm.dev = card->dev;
 	card->dapm.card = card;
@@ -1680,8 +1682,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	mutex_unlock(&card->mutex);
 	mutex_unlock(&client_mutex);
 
-	soc_init_card_debugfs(card);
-
 	return 0;
 
 probe_aux_dev_err:
@@ -1695,6 +1695,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	if (card->remove)
 		card->remove(card);
 
+	soc_cleanup_card_debugfs(card);
 	snd_card_free(card->snd_card);
 
 base_error:

commit 95a9ca74768089d89c17ba958d6f009aa9c18525
Merge: 4e2576bd36a1 f22e6e847115
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Apr 9 11:23:57 2015 +0100

    Merge tag 'v4.0-rc7' into asoc-core
    
    Linux 4.0-rc7

commit 37660b6daf6d28bb2206c95ec75c8063f2db1606
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Mar 30 21:04:50 2015 +0200

    ASoC: Remove suspend_bias_level from DAPM context struct
    
    The only two users of the suspend_bias_level field were two rather old
    drivers which weren't exactly doing things by the book. Those drivers have
    been updated and field is now unused and can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 30579ca5bacb..72601a86a748 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -583,15 +583,9 @@ int snd_soc_suspend(struct device *dev)
 			cpu_dai->driver->suspend(cpu_dai);
 	}
 
-	/* close any waiting streams and save state */
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai **codec_dais = card->rtd[i].codec_dais;
+	/* close any waiting streams */
+	for (i = 0; i < card->num_rtd; i++)
 		flush_delayed_work(&card->rtd[i].delayed_work);
-		for (j = 0; j < card->rtd[i].num_codecs; j++) {
-			codec_dais[j]->codec->dapm.suspend_bias_level =
-					codec_dais[j]->codec->dapm.bias_level;
-		}
-	}
 
 	for (i = 0; i < card->num_rtd; i++) {
 

commit 4e2576bd36a12e78ac3786d05b99a820dffe687f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Mar 24 09:01:00 2015 +0000

    ASoC: soc-core: initialize debugfs in snd_soc_instantiate_card()
    
    Current soc_init_card_debugfs() is called from snd_soc_register_card()
    but, soc_cleanup_card_debugfs() is called from soc_cleanup_card_resources(),
    not from paired function.
    
    This differences don't matter for now. But if anyone wants to implement
    a proper hotplug/unplug, this difference would become clearer.
    
    Now, we can assume that snd_soc_instantiate_card() and
    soc_cleanup_card_resources() are paired function.
    soc_init_card_debugfs() / soc_cleanup_card_debugfs() paired function
    should be called from these.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index acf99f1250e5..4443581d69f2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1662,6 +1662,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	snd_soc_dapm_sync(&card->dapm);
 	mutex_unlock(&card->mutex);
 
+	soc_init_card_debugfs(card);
+
 	return 0;
 
 probe_aux_dev_err:
@@ -2352,8 +2354,6 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 	snd_soc_initialize_card_lists(card);
 
-	soc_init_card_debugfs(card);
-
 	card->rtd = devm_kzalloc(card->dev,
 				 sizeof(struct snd_soc_pcm_runtime) *
 				 (card->num_links + card->num_aux_devs),
@@ -2384,7 +2384,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 	ret = snd_soc_instantiate_card(card);
 	if (ret != 0)
-		soc_cleanup_card_debugfs(card);
+		return ret;
 
 	/* deactivate pins to sleep state */
 	for (i = 0; i < card->num_rtd; i++) {

commit c66150824b8a809a502fd833fa9b18082cd89a39
Author: Nikesh Oswal <nikesh@opensource.wolfsonmicro.com>
Date:   Mon Feb 2 17:06:44 2015 +0000

    ASoC: dapm: add code to configure dai link parameters
    
    dai-link params for codec-codec links were fixed. The fixed
    link between codec and another chip which may be another codec,
    baseband, bluetooth codec etc may require run time configuaration
    changes. This change provides an optional alsa control to select
    one of the params from a list of params.
    
    Signed-off-by: Nikesh Oswal <nikesh@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 30579ca5bacb..700ac2ffe696 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1245,7 +1245,8 @@ static int soc_link_dai_widgets(struct snd_soc_card *card,
 	capture_w = cpu_dai->capture_widget;
 	if (play_w && capture_w) {
 		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
-					   capture_w, play_w);
+					   dai_link->num_params, capture_w,
+					   play_w);
 		if (ret != 0) {
 			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
 				play_w->name, capture_w->name, ret);
@@ -1257,7 +1258,8 @@ static int soc_link_dai_widgets(struct snd_soc_card *card,
 	capture_w = codec_dai->capture_widget;
 	if (play_w && capture_w) {
 		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
-					   capture_w, play_w);
+					   dai_link->num_params, capture_w,
+					   play_w);
 		if (ret != 0) {
 			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
 				play_w->name, capture_w->name, ret);

commit 778952598e53f09251bebe1655177b355cd9e836
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Mar 7 19:35:08 2015 +0100

    ASoC: Remove unnecessary device_remove_file()
    
    Since commit d29697dc3b92 ("ASoC: Add sysfs entries via static attribute
    groups") the sysfs attributes of the rtd are manged by the device core and
    there is no need to manually call device_remove_file() anymore.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 30579ca5bacb..acf99f1250e5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1410,7 +1410,6 @@ static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
-		device_remove_file(rtd->dev, &dev_attr_codec_reg);
 		device_unregister(rtd->dev);
 		rtd->dev_registered = 0;
 	}

commit 34e81ab4556f3b1371763861e74e3600818924b5
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Mar 7 19:34:03 2015 +0100

    ASoC: Fix component lists locking
    
    Any access to the component_list, codec_list and platform_list needs to be
    properly locked by the client_mutex. Otherwise undefined behavior can occur
    if the list is modified in one thread and concurrently accessed from another
    thread.
    
    This patch adds the missing locking to the debugfs file handlers that
    display the registered components, as well as the various components
    unregister functions.
    
    Furthermore the client_lock is now held for the whole
    snd_soc_instantiate_card() sequence to make sure that component removal does
    not race against the card registration.
    
    Reported-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 30579ca5bacb..e5c990889dcc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -347,6 +347,8 @@ static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
 	if (!buf)
 		return -ENOMEM;
 
+	mutex_lock(&client_mutex);
+
 	list_for_each_entry(codec, &codec_list, list) {
 		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
 			       codec->component.name);
@@ -358,6 +360,8 @@ static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
 		}
 	}
 
+	mutex_unlock(&client_mutex);
+
 	if (ret >= 0)
 		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
@@ -382,6 +386,8 @@ static ssize_t dai_list_read_file(struct file *file, char __user *user_buf,
 	if (!buf)
 		return -ENOMEM;
 
+	mutex_lock(&client_mutex);
+
 	list_for_each_entry(component, &component_list, list) {
 		list_for_each_entry(dai, &component->dai_list, list) {
 			len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
@@ -395,6 +401,8 @@ static ssize_t dai_list_read_file(struct file *file, char __user *user_buf,
 		}
 	}
 
+	mutex_unlock(&client_mutex);
+
 	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
 	kfree(buf);
@@ -418,6 +426,8 @@ static ssize_t platform_list_read_file(struct file *file,
 	if (!buf)
 		return -ENOMEM;
 
+	mutex_lock(&client_mutex);
+
 	list_for_each_entry(platform, &platform_list, list) {
 		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
 			       platform->component.name);
@@ -429,6 +439,8 @@ static ssize_t platform_list_read_file(struct file *file,
 		}
 	}
 
+	mutex_unlock(&client_mutex);
+
 	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
 	kfree(buf);
@@ -836,6 +848,8 @@ static struct snd_soc_component *soc_find_component(
 {
 	struct snd_soc_component *component;
 
+	lockdep_assert_held(&client_mutex);
+
 	list_for_each_entry(component, &component_list, list) {
 		if (of_node) {
 			if (component->dev->of_node == of_node)
@@ -854,6 +868,8 @@ static struct snd_soc_dai *snd_soc_find_dai(
 	struct snd_soc_component *component;
 	struct snd_soc_dai *dai;
 
+	lockdep_assert_held(&client_mutex);
+
 	/* Find CPU DAI from registered DAIs*/
 	list_for_each_entry(component, &component_list, list) {
 		if (dlc->of_node && component->dev->of_node != dlc->of_node)
@@ -1508,6 +1524,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	struct snd_soc_codec *codec;
 	int ret, i, order;
 
+	mutex_lock(&client_mutex);
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
 	/* bind DAIs */
@@ -1662,6 +1679,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	card->instantiated = 1;
 	snd_soc_dapm_sync(&card->dapm);
 	mutex_unlock(&card->mutex);
+	mutex_unlock(&client_mutex);
 
 	return 0;
 
@@ -1680,6 +1698,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 base_error:
 	mutex_unlock(&card->mutex);
+	mutex_unlock(&client_mutex);
 
 	return ret;
 }
@@ -2713,13 +2732,6 @@ static void snd_soc_component_del_unlocked(struct snd_soc_component *component)
 	list_del(&component->list);
 }
 
-static void snd_soc_component_del(struct snd_soc_component *component)
-{
-	mutex_lock(&client_mutex);
-	snd_soc_component_del_unlocked(component);
-	mutex_unlock(&client_mutex);
-}
-
 int snd_soc_register_component(struct device *dev,
 			       const struct snd_soc_component_driver *cmpnt_drv,
 			       struct snd_soc_dai_driver *dai_drv,
@@ -2767,14 +2779,17 @@ void snd_soc_unregister_component(struct device *dev)
 {
 	struct snd_soc_component *cmpnt;
 
+	mutex_lock(&client_mutex);
 	list_for_each_entry(cmpnt, &component_list, list) {
 		if (dev == cmpnt->dev && cmpnt->registered_as_component)
 			goto found;
 	}
+	mutex_unlock(&client_mutex);
 	return;
 
 found:
-	snd_soc_component_del(cmpnt);
+	snd_soc_component_del_unlocked(cmpnt);
+	mutex_unlock(&client_mutex);
 	snd_soc_component_cleanup(cmpnt);
 	kfree(cmpnt);
 }
@@ -2882,10 +2897,14 @@ struct snd_soc_platform *snd_soc_lookup_platform(struct device *dev)
 {
 	struct snd_soc_platform *platform;
 
+	mutex_lock(&client_mutex);
 	list_for_each_entry(platform, &platform_list, list) {
-		if (dev == platform->dev)
+		if (dev == platform->dev) {
+			mutex_unlock(&client_mutex);
 			return platform;
+		}
 	}
+	mutex_unlock(&client_mutex);
 
 	return NULL;
 }
@@ -3090,15 +3109,15 @@ void snd_soc_unregister_codec(struct device *dev)
 {
 	struct snd_soc_codec *codec;
 
+	mutex_lock(&client_mutex);
 	list_for_each_entry(codec, &codec_list, list) {
 		if (dev == codec->dev)
 			goto found;
 	}
+	mutex_unlock(&client_mutex);
 	return;
 
 found:
-
-	mutex_lock(&client_mutex);
 	list_del(&codec->list);
 	snd_soc_component_del_unlocked(&codec->component);
 	mutex_unlock(&client_mutex);

commit f42cf8d6a3ec934551ac0f20f4654dccb11fa30d
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue Feb 24 23:11:26 2015 +0900

    treewide: Fix typo in printk messages
    
    This patch fix spelling typo in printk messages.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..69e655e1ce11 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4064,7 +4064,7 @@ int snd_soc_register_component(struct device *dev,
 
 	ret = snd_soc_register_dais(cmpnt, dai_drv, num_dai, true);
 	if (ret < 0) {
-		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
+		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
 		goto err_cleanup;
 	}
 
@@ -4379,7 +4379,7 @@ int snd_soc_register_codec(struct device *dev,
 
 	ret = snd_soc_register_dais(&codec->component, dai_drv, num_dai, false);
 	if (ret < 0) {
-		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
+		dev_err(dev, "ASoC: Failed to register DAIs: %d\n", ret);
 		goto err_cleanup;
 	}
 

commit f23e860edbb3f2208c0ab3448e756689bb4a3760
Author: Nicolin Chen <nicoleotsuka@gmail.com>
Date:   Sat Feb 14 17:22:49 2015 -0800

    ASoC: core: Add extra dapm properties for Device Tree
    
    The current helper functions, snd_soc_of_parse_audio_simple_widgets()
    and snd_soc_of_parse_audio_routing(), set dapm_widgets and dapm_routes
    without caring if they are already set by using build-in widgets and
    routes in the card driver. So there could be one of them, build-in one
    or Device Tree one, overrided by the other depending on which one was
    assigned later.
    
    This patch adds an extra pair of dapm_widgets and dapm_routes for DT
    use only so as to prevent unexpected overriding.
    
    Signed-off-by: Nicolin Chen <nicoleotsuka@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 30579ca5bacb..5c0658d49609 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1561,6 +1561,10 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
 					  card->num_dapm_widgets);
 
+	if (card->of_dapm_widgets)
+		snd_soc_dapm_new_controls(&card->dapm, card->of_dapm_widgets,
+					  card->num_of_dapm_widgets);
+
 	/* initialise the sound card only once */
 	if (card->probe) {
 		ret = card->probe(card);
@@ -1616,6 +1620,10 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 					card->num_dapm_routes);
 
+	if (card->of_dapm_routes)
+		snd_soc_dapm_add_routes(&card->dapm, card->of_dapm_routes,
+					card->num_of_dapm_routes);
+
 	for (i = 0; i < card->num_links; i++) {
 		if (card->dai_link[i].dai_fmt)
 			snd_soc_runtime_set_dai_fmt(&card->rtd[i],
@@ -3223,8 +3231,8 @@ int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
 		widgets[i].name = wname;
 	}
 
-	card->dapm_widgets = widgets;
-	card->num_dapm_widgets = num_widgets;
+	card->of_dapm_widgets = widgets;
+	card->num_of_dapm_widgets = num_widgets;
 
 	return 0;
 }
@@ -3308,8 +3316,8 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		}
 	}
 
-	card->num_dapm_routes = num_routes;
-	card->dapm_routes = routes;
+	card->num_of_dapm_routes = num_routes;
+	card->of_dapm_routes = routes;
 
 	return 0;
 }

commit 1bf9f29a05ed027dfc3527966321bda33a77ebc3
Merge: ddaaeee0e598 f9911803e82a 3c9390ad0fa6 e46c93669349 a37f1b8fdc91 b8255930e0fb
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Feb 9 15:10:29 2015 +0800

    Merge remote-tracking branches 'asoc/topic/simple', 'asoc/topic/sta32x', 'asoc/topic/tdm-slot', 'asoc/topic/tegra' and 'asoc/topic/tlv320aic3x' into asoc-next

commit 3f1cf65757758ae2a3f777a786fd6c0a73273516
Merge: bd862e12bf67 cd2ee8ad55a1 ddaca25aa4da caa1d794cca9
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Feb 9 15:10:14 2015 +0800

    Merge remote-tracking branches 'asoc/topic/cs42l73', 'asoc/topic/dai' and 'asoc/topic/davinci' into asoc-next

commit afcfe4359e32f4fe1588b1d60414aacce676e27a
Merge: 0cee4db21e85 8f6f9b2982b2
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Feb 9 15:10:00 2015 +0800

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 8f6f9b2982b2c924fe2dde816e2decb3ca1d8f8f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Feb 5 05:34:10 2015 +0000

    ASoC: core: indicate unregister debug message once
    
    Current snd_soc_unregister_card() indicates unregistered debug
    message when it was called. But, it should be called only when
    it was really unregistered.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 54925dc84a96..4bfabc776e21 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2396,8 +2396,8 @@ int snd_soc_unregister_card(struct snd_soc_card *card)
 		card->instantiated = false;
 		snd_soc_dapm_shutdown(card);
 		soc_cleanup_card_resources(card);
+		dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 	}
-	dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 
 	return 0;
 }

commit d29697dc3b92cb12a80632a5ade4fa26fd98225e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 30 20:16:37 2015 +0100

    ASoC: Add sysfs entries via static attribute groups
    
    Instead of calling device_create_file() manually, assign the static
    attribute group entries at the device registration.  This simplifies
    the error handling and avoids the possible races.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 985052b3fbed..54925dc84a96 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -191,6 +191,39 @@ static ssize_t pmdown_time_set(struct device *dev,
 
 static DEVICE_ATTR(pmdown_time, 0644, pmdown_time_show, pmdown_time_set);
 
+static struct attribute *soc_dev_attrs[] = {
+	&dev_attr_codec_reg.attr,
+	&dev_attr_pmdown_time.attr,
+	NULL
+};
+
+static umode_t soc_dev_attr_is_visible(struct kobject *kobj,
+				       struct attribute *attr, int idx)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
+
+	if (attr == &dev_attr_pmdown_time.attr)
+		return attr->mode; /* always visible */
+	return rtd->codec ? attr->mode : 0; /* enabled only with codec */
+}
+
+static const struct attribute_group soc_dapm_dev_group = {
+	.attrs = soc_dapm_dev_attrs,
+	.is_visible = soc_dev_attr_is_visible,
+};
+
+static const struct attribute_group soc_dev_roup = {
+	.attrs = soc_dev_attrs,
+	.is_visible = soc_dev_attr_is_visible,
+};
+
+static const struct attribute_group *soc_dev_attr_groups[] = {
+	&soc_dapm_dev_group,
+	&soc_dev_roup,
+	NULL
+};
+
 #ifdef CONFIG_DEBUG_FS
 static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
 				   size_t count, loff_t *ppos)
@@ -949,8 +982,6 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
-		device_remove_file(rtd->dev, &dev_attr_pmdown_time);
-		device_remove_file(rtd->dev, &dev_attr_codec_reg);
 		device_unregister(rtd->dev);
 		rtd->dev_registered = 0;
 	}
@@ -1120,6 +1151,7 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 	device_initialize(rtd->dev);
 	rtd->dev->parent = rtd->card->dev;
 	rtd->dev->release = rtd_release;
+	rtd->dev->groups = soc_dev_attr_groups;
 	dev_set_name(rtd->dev, "%s", name);
 	dev_set_drvdata(rtd->dev, rtd);
 	mutex_init(&rtd->pcm_mutex);
@@ -1136,23 +1168,6 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 		return ret;
 	}
 	rtd->dev_registered = 1;
-
-	if (rtd->codec) {
-		/* add DAPM sysfs entries for this codec */
-		ret = snd_soc_dapm_sys_add(rtd->dev);
-		if (ret < 0)
-			dev_err(rtd->dev,
-				"ASoC: failed to add codec dapm sysfs entries: %d\n",
-				ret);
-
-		/* add codec sysfs entries */
-		ret = device_create_file(rtd->dev, &dev_attr_codec_reg);
-		if (ret < 0)
-			dev_err(rtd->dev,
-				"ASoC: failed to add codec sysfs files: %d\n",
-				ret);
-	}
-
 	return 0;
 }
 
@@ -1308,11 +1323,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	}
 #endif
 
-	ret = device_create_file(rtd->dev, &dev_attr_pmdown_time);
-	if (ret < 0)
-		dev_warn(rtd->dev, "ASoC: failed to add pmdown_time sysfs: %d\n",
-			ret);
-
 	if (cpu_dai->driver->compress_dai) {
 		/*create compress_device"*/
 		ret = soc_new_compress(rtd, num);

commit e46c93669349072f5caca853f5618cfa01b86008
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jan 12 10:27:20 2015 +0100

    ASoC: Update snd_soc_dai_set_tdm_slot() documentation
    
    There have been some conflicting interpretations of how
    snd_soc_dai_set_tdm_slot() is supposed to work. This patch updates the
    documentation to be more specific on the exact semantics to avoid such
    problems in the future.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 985052b3fbed..64e047dc7cdf 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2119,15 +2119,27 @@ static int snd_soc_xlate_tdm_slot_mask(unsigned int slots,
 }
 
 /**
- * snd_soc_dai_set_tdm_slot - configure DAI TDM.
- * @dai: DAI
+ * snd_soc_dai_set_tdm_slot() - Configures a DAI for TDM operation
+ * @dai: The DAI to configure
  * @tx_mask: bitmask representing active TX slots.
  * @rx_mask: bitmask representing active RX slots.
  * @slots: Number of slots in use.
  * @slot_width: Width in bits for each slot.
  *
- * Configures a DAI for TDM operation. Both mask and slots are codec and DAI
- * specific.
+ * This function configures the specified DAI for TDM operation. @slot contains
+ * the total number of slots of the TDM stream and @slot_with the width of each
+ * slot in bit clock cycles. @tx_mask and @rx_mask are bitmasks specifying the
+ * active slots of the TDM stream for the specified DAI, i.e. which slots the
+ * DAI should write to or read from. If a bit is set the corresponding slot is
+ * active, if a bit is cleared the corresponding slot is inactive. Bit 0 maps to
+ * the first slot, bit 1 to the second slot and so on. The first active slot
+ * maps to the first channel of the DAI, the second active slot to the second
+ * channel and so on.
+ *
+ * TDM mode can be disabled by passing 0 for @slots. In this case @tx_mask,
+ * @rx_mask and @slot_width will be ignored.
+ *
+ * Returns 0 on success, a negative error code otherwise.
  */
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)

commit ddaca25aa4dade234163290f6a9e091e7f57b36a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Jan 8 12:23:05 2015 +0100

    ASoC: Export snd_soc_runtime_set_dai_fmt()
    
    Export snd_soc_runtime_set_dai_fmt() so it can be used in modules.
    
    Fixes: ce64c8b9cf5b ("ASoC: Add helper function for changing the DAI link format")
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 80ea358d3ad7..d342ee2ce28b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1491,6 +1491,7 @@ int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_soc_runtime_set_dai_fmt);
 
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {

commit ce64c8b9cf5be2a93508af4667110dbe90904557
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Jan 6 15:17:20 2015 +0100

    ASoC: Add helper function for changing the DAI link format
    
    For some setups it is necessary to change the DAI link format at runtime.
    This patch factors out the code that does the initial static DAI link format
    configuration into a separate helper function which can be used board
    drivers as well.
    
    This allows board drivers that have to change the DAI link format at runtime
    to reuse it instead of having to manually change the format on all DAIs.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 985052b3fbed..80ea358d3ad7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1427,11 +1427,75 @@ static int snd_soc_init_codec_cache(struct snd_soc_codec *codec)
 	return 0;
 }
 
+/**
+ * snd_soc_runtime_set_dai_fmt() - Change DAI link format for a ASoC runtime
+ * @rtd: The runtime for which the DAI link format should be changed
+ * @dai_fmt: The new DAI link format
+ *
+ * This function updates the DAI link format for all DAIs connected to the DAI
+ * link for the specified runtime.
+ *
+ * Note: For setups with a static format set the dai_fmt field in the
+ * corresponding snd_dai_link struct instead of using this function.
+ *
+ * Returns 0 on success, otherwise a negative error code.
+ */
+int snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,
+	unsigned int dai_fmt)
+{
+	struct snd_soc_dai **codec_dais = rtd->codec_dais;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_dai *codec_dai = codec_dais[i];
+
+		ret = snd_soc_dai_set_fmt(codec_dai, dai_fmt);
+		if (ret != 0 && ret != -ENOTSUPP) {
+			dev_warn(codec_dai->dev,
+				 "ASoC: Failed to set DAI format: %d\n", ret);
+			return ret;
+		}
+	}
+
+	/* Flip the polarity for the "CPU" end of a CODEC<->CODEC link */
+	if (cpu_dai->codec) {
+		unsigned int inv_dai_fmt;
+
+		inv_dai_fmt = dai_fmt & ~SND_SOC_DAIFMT_MASTER_MASK;
+		switch (dai_fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+		case SND_SOC_DAIFMT_CBM_CFM:
+			inv_dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
+			break;
+		case SND_SOC_DAIFMT_CBM_CFS:
+			inv_dai_fmt |= SND_SOC_DAIFMT_CBS_CFM;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFM:
+			inv_dai_fmt |= SND_SOC_DAIFMT_CBM_CFS;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFS:
+			inv_dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+			break;
+		}
+
+		dai_fmt = inv_dai_fmt;
+	}
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_fmt);
+	if (ret != 0 && ret != -ENOTSUPP) {
+		dev_warn(cpu_dai->dev,
+			 "ASoC: Failed to set DAI format: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_codec *codec;
-	struct snd_soc_dai_link *dai_link;
-	int ret, i, order, dai_fmt;
+	int ret, i, order;
 
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
@@ -1542,60 +1606,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 					card->num_dapm_routes);
 
 	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
-		dai_link = &card->dai_link[i];
-		dai_fmt = dai_link->dai_fmt;
-
-		if (dai_fmt) {
-			struct snd_soc_dai **codec_dais = rtd->codec_dais;
-			int j;
-
-			for (j = 0; j < rtd->num_codecs; j++) {
-				struct snd_soc_dai *codec_dai = codec_dais[j];
-
-				ret = snd_soc_dai_set_fmt(codec_dai, dai_fmt);
-				if (ret != 0 && ret != -ENOTSUPP)
-					dev_warn(codec_dai->dev,
-						 "ASoC: Failed to set DAI format: %d\n",
-						 ret);
-			}
-		}
-
-		/* If this is a regular CPU link there will be a platform */
-		if (dai_fmt &&
-		    (dai_link->platform_name || dai_link->platform_of_node)) {
-			ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai,
-						  dai_fmt);
-			if (ret != 0 && ret != -ENOTSUPP)
-				dev_warn(card->rtd[i].cpu_dai->dev,
-					 "ASoC: Failed to set DAI format: %d\n",
-					 ret);
-		} else if (dai_fmt) {
-			/* Flip the polarity for the "CPU" end */
-			dai_fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
-			switch (dai_link->dai_fmt &
-				SND_SOC_DAIFMT_MASTER_MASK) {
-			case SND_SOC_DAIFMT_CBM_CFM:
-				dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
-				break;
-			case SND_SOC_DAIFMT_CBM_CFS:
-				dai_fmt |= SND_SOC_DAIFMT_CBS_CFM;
-				break;
-			case SND_SOC_DAIFMT_CBS_CFM:
-				dai_fmt |= SND_SOC_DAIFMT_CBM_CFS;
-				break;
-			case SND_SOC_DAIFMT_CBS_CFS:
-				dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
-				break;
-			}
-
-			ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai,
-						  dai_fmt);
-			if (ret != 0 && ret != -ENOTSUPP)
-				dev_warn(card->rtd[i].cpu_dai->dev,
-					 "ASoC: Failed to set DAI format: %d\n",
-					 ret);
-		}
+		if (card->dai_link[i].dai_fmt)
+			snd_soc_runtime_set_dai_fmt(&card->rtd[i],
+				card->dai_link[i].dai_fmt);
 	}
 
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),

commit cf82602c41cb3076b0d2efe92d9b080542897861
Merge: f2ec1d3b2577 86d7500326ea
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Dec 24 12:56:40 2014 +0000

    Merge remote-tracking branch 'asoc/topic/dapm' into asoc-next

commit c533b8e60ab27e8f8782a1997f8417561140f7f8
Merge: 97bf6af1f928 e3b1e6a19e09
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Dec 24 12:56:32 2014 +0000

    Merge remote-tracking branch 'asoc/fix/dapm' into asoc-linus

commit 86d7500326ea71ea72aeaf0da78671eef28be2af
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Dec 21 11:05:44 2014 +0100

    ASoC: dapm: Simplify fully route card handling
    
    For legacy reasons the ASoC framework assumes that a CODEC INPUT or OUTPUT
    widget that is not explicitly connected to a external source or sink is
    potentially connected to a source or a sink and hence the framework treats
    the widget itself as source (for INPUT) or sink (for OUTPUT). For this
    reason a INPUT or OUTPUT widget that is really not connected needs to be
    explicitly marked as so.
    
    Setting the card's fully_routed flag will cause the ASoC core, once that all
    widgets and routes have been registered, to go through the list of all
    widgets and mark all INPUT and OUTPUT that are not externally connected as
    non-connected. This essentially negates the default behaviour of treating
    INPUT or OUTPUT widgets without external routes as sources or sinks.
    
    This patch takes a different approach while getting the same result. Instead
    of first marking INPUT and OUTPUT widgets as sinks/sources and then later
    marking them as non-connected, just never mark them as a sink or a source if
    the fully_routed flag is set on a card.
    
    This requires a lot less code and also results in a slightly faster card
    initialization since there is no need to iterate over all widgets and check
    whether the INPUT and OUTPUT widgets are connected or not.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 985052b3fbed..89aa6717f26a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1626,9 +1626,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
-	if (card->fully_routed)
-		snd_soc_dapm_auto_nc_pins(card);
-
 	snd_soc_dapm_new_widgets(card);
 
 	ret = snd_card_register(card->snd_card);

commit e3b1e6a19e09877b91517dfe304a2b3f6b2138fc
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Dec 18 11:46:38 2014 +0000

    ASoC: dapm: Remove snd_soc_of_parse_audio_routing() due to deferred probe
    
    This reverts commit f8781db8aeb18d (ASoC: dapm: Augment existing card
    DAPM routes in snd_soc_of_parse_audio_routing) since it is broken for
    deferred probing as it ends up storing data allocated with devm_ over
    multiple instantiations of the device.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 935721062c21..d7595465cfbc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3231,7 +3231,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname)
 {
 	struct device_node *np = card->dev->of_node;
-	int num_routes, old_routes;
+	int num_routes;
 	struct snd_soc_dapm_route *routes;
 	int i, ret;
 
@@ -3249,9 +3249,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		return -EINVAL;
 	}
 
-	old_routes = card->num_dapm_routes;
-	routes = devm_kzalloc(card->dev,
-			      (old_routes + num_routes) * sizeof(*routes),
+	routes = devm_kzalloc(card->dev, num_routes * sizeof(*routes),
 			      GFP_KERNEL);
 	if (!routes) {
 		dev_err(card->dev,
@@ -3259,11 +3257,9 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		return -EINVAL;
 	}
 
-	memcpy(routes, card->dapm_routes, old_routes * sizeof(*routes));
-
 	for (i = 0; i < num_routes; i++) {
 		ret = of_property_read_string_index(np, propname,
-			2 * i, &routes[old_routes + i].sink);
+			2 * i, &routes[i].sink);
 		if (ret) {
 			dev_err(card->dev,
 				"ASoC: Property '%s' index %d could not be read: %d\n",
@@ -3271,7 +3267,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 			return -EINVAL;
 		}
 		ret = of_property_read_string_index(np, propname,
-			(2 * i) + 1, &routes[old_routes + i].source);
+			(2 * i) + 1, &routes[i].source);
 		if (ret) {
 			dev_err(card->dev,
 				"ASoC: Property '%s' index %d could not be read: %d\n",
@@ -3280,7 +3276,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		}
 	}
 
-	card->num_dapm_routes += num_routes;
+	card->num_dapm_routes = num_routes;
 	card->dapm_routes = routes;
 
 	return 0;

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit c9098c6120f7e4dd2d65ce3c3711d4d20380ef7b
Merge: 41967b775e14 93b0f3eeebdc 8c2727f97b48 d206f66177ab bb66f2dc197d 6d3efa40790a
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 8 13:12:05 2014 +0000

    Merge remote-tracking branches 'asoc/topic/multi-codec', 'asoc/topic/mxs-saif', 'asoc/topic/mxs-sgtl5000', 'asoc/topic/omap' and 'asoc/topic/pxa' into asoc-next

commit cfdf59b4a157b3ffa123073cc9e2a62febdbafbf
Merge: 1f491557d279 47370022d2ca 15f6b09a00a6 6200b75a8bbc
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 8 13:11:52 2014 +0000

    Merge remote-tracking branches 'asoc/topic/codec-mutex', 'asoc/topic/compress' and 'asoc/topic/cq93vc' into asoc-next

commit 0a7e4ca1aad65458edebb718e1b915d1899056e7
Merge: 8f38411a7e24 e874bf5f7647 1b86a3fa4eb3 de172051af78 d69db7f7cd57
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 8 13:11:45 2014 +0000

    Merge remote-tracking branches 'asoc/topic/ac97', 'asoc/topic/ad193x', 'asoc/topic/adau1373' and 'asoc/topic/adau17x1' into asoc-next

commit dbb55ce8afc8832fac7f6cbbe55123b2b05216d5
Merge: 941725f5fade f8781db8aeb1
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 8 13:11:45 2014 +0000

    Merge remote-tracking branch 'asoc/topic/dapm' into asoc-next

commit 941725f5fade7b35394f497c4d684d64a0e05965
Merge: 3ee3f4546325 c362effe5cda
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 8 13:11:44 2014 +0000

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 3ee3f454632547a8299c16156c3fefcc2a05726c
Merge: 063e01a29b7a 427d204c86e0
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 8 13:11:44 2014 +0000

    Merge remote-tracking branch 'asoc/topic/cache' into asoc-next

commit f8781db8aeb18d34edb191bfed9c0a68affaaa74
Author: Peter Rosin <peda@axentia.se>
Date:   Thu Nov 27 22:02:42 2014 +0100

    ASoC: Augment existing card DAPM routes in snd_soc_of_parse_audio_routing
    
    If a snd_soc_card has any DAPM routes when it calls
    snd_soc_of_parse_audio_routing, those are clobbered without this change.
    
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 443be0061129..b6e0e3134861 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4585,7 +4585,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname)
 {
 	struct device_node *np = card->dev->of_node;
-	int num_routes;
+	int num_routes, old_routes;
 	struct snd_soc_dapm_route *routes;
 	int i, ret;
 
@@ -4603,7 +4603,9 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		return -EINVAL;
 	}
 
-	routes = devm_kzalloc(card->dev, num_routes * sizeof(*routes),
+	old_routes = card->num_dapm_routes;
+	routes = devm_kzalloc(card->dev,
+			      (old_routes + num_routes) * sizeof(*routes),
 			      GFP_KERNEL);
 	if (!routes) {
 		dev_err(card->dev,
@@ -4611,9 +4613,11 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		return -EINVAL;
 	}
 
+	memcpy(routes, card->dapm_routes, old_routes * sizeof(*routes));
+
 	for (i = 0; i < num_routes; i++) {
 		ret = of_property_read_string_index(np, propname,
-			2 * i, &routes[i].sink);
+			2 * i, &routes[old_routes + i].sink);
 		if (ret) {
 			dev_err(card->dev,
 				"ASoC: Property '%s' index %d could not be read: %d\n",
@@ -4621,7 +4625,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 			return -EINVAL;
 		}
 		ret = of_property_read_string_index(np, propname,
-			(2 * i) + 1, &routes[i].source);
+			(2 * i) + 1, &routes[old_routes + i].source);
 		if (ret) {
 			dev_err(card->dev,
 				"ASoC: Property '%s' index %d could not be read: %d\n",
@@ -4630,7 +4634,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		}
 	}
 
-	card->num_dapm_routes = num_routes;
+	card->num_dapm_routes += num_routes;
 	card->dapm_routes = routes;
 
 	return 0;

commit e874bf5f7647a9fdf14d72dbb376ec95327e3a81
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 25 21:41:03 2014 +0100

    ASoC: Disable regmap helpers if regmap is disabled
    
    If regmap is disabled there will be no users of the ASoC regmap helpers.
    Furthermore regmap_exit() will no be defined causing the following compile
    error:
            sound/soc/soc-core.c: In function 'snd_soc_component_exit_regmap':
            sound/soc/soc-core.c:2645:2: error: implicit declaration of function
                    'regmap_exit' [-Werror=implicit-function-declaration]
    
    So disable the helpers if regmap is disabled.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Fixes: 20feb881988c ASoC: Add helper functions for deferred regmap setup")
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index db74c061f520..1edc519d6286 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3661,6 +3661,8 @@ static void snd_soc_component_setup_regmap(struct snd_soc_component *component)
 		component->val_bytes = val_bytes;
 }
 
+#ifdef CONFIG_REGMAP
+
 /**
  * snd_soc_component_init_regmap() - Initialize regmap instance for the component
  * @component: The component for which to initialize the regmap instance
@@ -3696,6 +3698,8 @@ void snd_soc_component_exit_regmap(struct snd_soc_component *component)
 }
 EXPORT_SYMBOL_GPL(snd_soc_component_exit_regmap);
 
+#endif
+
 static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
 {
 	if (!component->write && !component->read) {

commit 93b0f3eeebdce6f32417187b5d24ea218a3e7fb4
Author: Jean-Francois Moine <moinejf@free.fr>
Date:   Tue Nov 25 13:16:12 2014 +0100

    ASoC: core: add multi-codec support in DT
    
    This patch exports a core function which handles the DT description
    of multi-codec links (as: "sound-dai = <&hdmi 0>, <&spdif_codec>;")
    and creates a CODEC component array in the DAI link.
    
    Signed-off-by: Jean-Francois Moine <moinejf@free.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..72a3ad047048 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4750,36 +4750,30 @@ unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_daifmt);
 
-int snd_soc_of_get_dai_name(struct device_node *of_node,
-			    const char **dai_name)
+static int snd_soc_get_dai_name(struct of_phandle_args *args,
+				const char **dai_name)
 {
 	struct snd_soc_component *pos;
-	struct of_phandle_args args;
-	int ret;
-
-	ret = of_parse_phandle_with_args(of_node, "sound-dai",
-					 "#sound-dai-cells", 0, &args);
-	if (ret)
-		return ret;
-
-	ret = -EPROBE_DEFER;
+	int ret = -EPROBE_DEFER;
 
 	mutex_lock(&client_mutex);
 	list_for_each_entry(pos, &component_list, list) {
-		if (pos->dev->of_node != args.np)
+		if (pos->dev->of_node != args->np)
 			continue;
 
 		if (pos->driver->of_xlate_dai_name) {
-			ret = pos->driver->of_xlate_dai_name(pos, &args, dai_name);
+			ret = pos->driver->of_xlate_dai_name(pos,
+							     args,
+							     dai_name);
 		} else {
 			int id = -1;
 
-			switch (args.args_count) {
+			switch (args->args_count) {
 			case 0:
 				id = 0; /* same as dai_drv[0] */
 				break;
 			case 1:
-				id = args.args[0];
+				id = args->args[0];
 				break;
 			default:
 				/* not supported */
@@ -4801,6 +4795,21 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 		break;
 	}
 	mutex_unlock(&client_mutex);
+	return ret;
+}
+
+int snd_soc_of_get_dai_name(struct device_node *of_node,
+			    const char **dai_name)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	ret = of_parse_phandle_with_args(of_node, "sound-dai",
+					 "#sound-dai-cells", 0, &args);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_get_dai_name(&args, dai_name);
 
 	of_node_put(args.np);
 
@@ -4808,6 +4817,77 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_name);
 
+/*
+ * snd_soc_of_get_dai_link_codecs - Parse a list of CODECs in the devicetree
+ * @dev: Card device
+ * @of_node: Device node
+ * @dai_link: DAI link
+ *
+ * Builds an array of CODEC DAI components from the DAI link property
+ * 'sound-dai'.
+ * The array is set in the DAI link and the number of DAIs is set accordingly.
+ * The device nodes in the array (of_node) must be dereferenced by the caller.
+ *
+ * Returns 0 for success
+ */
+int snd_soc_of_get_dai_link_codecs(struct device *dev,
+				   struct device_node *of_node,
+				   struct snd_soc_dai_link *dai_link)
+{
+	struct of_phandle_args args;
+	struct snd_soc_dai_link_component *component;
+	char *name;
+	int index, num_codecs, ret;
+
+	/* Count the number of CODECs */
+	name = "sound-dai";
+	num_codecs = of_count_phandle_with_args(of_node, name,
+						"#sound-dai-cells");
+	if (num_codecs <= 0) {
+		if (num_codecs == -ENOENT)
+			dev_err(dev, "No 'sound-dai' property\n");
+		else
+			dev_err(dev, "Bad phandle in 'sound-dai'\n");
+		return num_codecs;
+	}
+	component = devm_kzalloc(dev,
+				 sizeof *component * num_codecs,
+				 GFP_KERNEL);
+	if (!component)
+		return -ENOMEM;
+	dai_link->codecs = component;
+	dai_link->num_codecs = num_codecs;
+
+	/* Parse the list */
+	for (index = 0, component = dai_link->codecs;
+	     index < dai_link->num_codecs;
+	     index++, component++) {
+		ret = of_parse_phandle_with_args(of_node, name,
+						 "#sound-dai-cells",
+						  index, &args);
+		if (ret)
+			goto err;
+		component->of_node = args.np;
+		ret = snd_soc_get_dai_name(&args, &component->dai_name);
+		if (ret < 0)
+			goto err;
+	}
+	return 0;
+err:
+	for (index = 0, component = dai_link->codecs;
+	     index < dai_link->num_codecs;
+	     index++, component++) {
+		if (!component->of_node)
+			break;
+		of_node_put(component->of_node);
+		component->of_node = NULL;
+	}
+	dai_link->codecs = NULL;
+	dai_link->num_codecs = 0;
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_link_codecs);
+
 static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS

commit e975cec295ea71d5ad01fd3b6195670d3e31885e
Merge: c534107fd229 20feb881988c
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 19 10:48:20 2014 +0000

    Merge branch 'topic/regmap' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-ac97

commit 20feb881988cdf5f53304c355ae8ee3bf82e80ec
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 18 19:45:52 2014 +0100

    ASoC: Add helper functions for deferred regmap setup
    
    Some drivers (most notably the AC'97 drivers) do not have access to their
    regmap struct when the component/codec is registered. For those drivers the
    automatic regmap setup will not work and needs to be done manually,
    typically from the component/CODEC drivers probe callback.
    
    This patch adds a set of helper function to handle deferred regmap
    initialization as well as early regmap tear-down.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..5fd5f08ce24e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3996,22 +3996,58 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	return 0;
 }
 
-static void snd_soc_component_init_regmap(struct snd_soc_component *component)
+static void snd_soc_component_setup_regmap(struct snd_soc_component *component)
 {
-	if (!component->regmap)
-		component->regmap = dev_get_regmap(component->dev, NULL);
-	if (component->regmap) {
-		int val_bytes = regmap_get_val_bytes(component->regmap);
-		/* Errors are legitimate for non-integer byte multiples */
-		if (val_bytes > 0)
-			component->val_bytes = val_bytes;
-	}
+	int val_bytes = regmap_get_val_bytes(component->regmap);
+
+	/* Errors are legitimate for non-integer byte multiples */
+	if (val_bytes > 0)
+		component->val_bytes = val_bytes;
+}
+
+/**
+ * snd_soc_component_init_regmap() - Initialize regmap instance for the component
+ * @component: The component for which to initialize the regmap instance
+ * @regmap: The regmap instance that should be used by the component
+ *
+ * This function allows deferred assignment of the regmap instance that is
+ * associated with the component. Only use this if the regmap instance is not
+ * yet ready when the component is registered. The function must also be called
+ * before the first IO attempt of the component.
+ */
+void snd_soc_component_init_regmap(struct snd_soc_component *component,
+	struct regmap *regmap)
+{
+	component->regmap = regmap;
+	snd_soc_component_setup_regmap(component);
 }
+EXPORT_SYMBOL_GPL(snd_soc_component_init_regmap);
+
+/**
+ * snd_soc_component_exit_regmap() - De-initialize regmap instance for the component
+ * @component: The component for which to de-initialize the regmap instance
+ *
+ * Calls regmap_exit() on the regmap instance associated to the component and
+ * removes the regmap instance from the component.
+ *
+ * This function should only be used if snd_soc_component_init_regmap() was used
+ * to initialize the regmap instance.
+ */
+void snd_soc_component_exit_regmap(struct snd_soc_component *component)
+{
+	regmap_exit(component->regmap);
+	component->regmap = NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_exit_regmap);
 
 static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
 {
-	if (!component->write && !component->read)
-		snd_soc_component_init_regmap(component);
+	if (!component->write && !component->read) {
+		if (!component->regmap)
+			component->regmap = dev_get_regmap(component->dev, NULL);
+		if (component->regmap)
+			snd_soc_component_setup_regmap(component);
+	}
 
 	list_add(&component->list, &component_list);
 }

commit bc2632140435cc84f9817f1c362479b23dbdfebc
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:52 2014 +0100

    ASoC: Rename snd_soc_dai_driver struct ac97_control field to bus_control
    
    Setting the ac97_control field on a CPU DAI tells the ASoC core that this
    DAI in addition to audio data also transports control data to the CODEC.
    This causes the core to suspend the DAI after the CODEC and resume it before
    the CODEC so communication to the CODEC is still possible. This is not
    necessarily something that is specific to AC'97 and can be used by other
    buses with the same requirement. This patch renames the flag from
    ac97_control to bus_control to make this explicit.
    
    While we are at it also change the type from int to bool.
    
    The following semantich patch was used for automatic conversion of the
    drivers:
    // <smpl>
    @@
    identifier drv;
    @@
    struct snd_soc_dai_driver drv = {
    -       .ac97_control
    +       .bus_control
            =
    -       1
    +       true
    };
    // </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fba6e28e18d3..f5bebca84b71 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -550,7 +550,7 @@ int snd_soc_suspend(struct device *dev)
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->suspend && !cpu_dai->driver->ac97_control)
+		if (cpu_dai->driver->suspend && !cpu_dai->driver->bus_control)
 			cpu_dai->driver->suspend(cpu_dai);
 		if (platform->driver->suspend && !platform->suspended) {
 			platform->driver->suspend(cpu_dai);
@@ -629,7 +629,7 @@ int snd_soc_suspend(struct device *dev)
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->suspend && cpu_dai->driver->ac97_control)
+		if (cpu_dai->driver->suspend && cpu_dai->driver->bus_control)
 			cpu_dai->driver->suspend(cpu_dai);
 
 		/* deactivate pins to sleep state */
@@ -665,14 +665,14 @@ static void soc_resume_deferred(struct work_struct *work)
 	if (card->resume_pre)
 		card->resume_pre(card);
 
-	/* resume AC97 DAIs */
+	/* resume control bus DAIs */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->resume && cpu_dai->driver->ac97_control)
+		if (cpu_dai->driver->resume && cpu_dai->driver->bus_control)
 			cpu_dai->driver->resume(cpu_dai);
 	}
 
@@ -733,7 +733,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->resume && !cpu_dai->driver->ac97_control)
+		if (cpu_dai->driver->resume && !cpu_dai->driver->bus_control)
 			cpu_dai->driver->resume(cpu_dai);
 		if (platform->driver->resume && platform->suspended) {
 			platform->driver->resume(cpu_dai);
@@ -758,7 +758,8 @@ static void soc_resume_deferred(struct work_struct *work)
 int snd_soc_resume(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
-	int i, ac97_control = 0;
+	bool bus_control = false;
+	int i;
 
 	/* If the card is not initialized yet there is nothing to do */
 	if (!card->instantiated)
@@ -781,17 +782,18 @@ int snd_soc_resume(struct device *dev)
 		}
 	}
 
-	/* AC97 devices might have other drivers hanging off them so
-	 * need to resume immediately.  Other drivers don't have that
-	 * problem and may take a substantial amount of time to resume
+	/*
+	 * DAIs that also act as the control bus master might have other drivers
+	 * hanging off them so need to resume immediately. Other drivers don't
+	 * have that problem and may take a substantial amount of time to resume
 	 * due to I/O costs and anti-pop so handle them out of line.
 	 */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
-		ac97_control |= cpu_dai->driver->ac97_control;
+		bus_control |= cpu_dai->driver->bus_control;
 	}
-	if (ac97_control) {
-		dev_dbg(dev, "ASoC: Resuming AC97 immediately\n");
+	if (bus_control) {
+		dev_dbg(dev, "ASoC: Resuming control bus master immediately\n");
 		soc_resume_deferred(&card->deferred_resume_work);
 	} else {
 		dev_dbg(dev, "ASoC: Scheduling resume work\n");

commit 6794f709b7124ff1e574c4f4c9494418ab56c4b4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:50 2014 +0100

    ASoC: ac97: Drop delayed device registration
    
    We have all the information and dependencies we need to initialize and
    register the device available in snd_soc_new_ac97_codec(). So there is no
    need to delay the device registration until after the card itself as been
    registered.
    
    This makes the code significantly simpler and also makes it possible to use
    the AC'97 device in the CODECs probe function. The later will be required to
    be able to convert the AC'97 CODEC drivers to regmap.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d883b4ad03ac..fba6e28e18d3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1671,10 +1671,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		goto probe_aux_dev_err;
 	}
 
-	ret = snd_soc_ac97_register_dai_links(card);
-	if (ret < 0)
-		goto probe_aux_dev_err;
-
 	card->instantiated = 1;
 	snd_soc_dapm_sync(&card->dapm);
 	mutex_unlock(&card->mutex);

commit ca005f324ee38308b319c693f40523d959027acf
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:49 2014 +0100

    ASoC: ac97: Drop support for setting platform data via the CPU DAI
    
    This has no users since commit f0fba2ad1b6b ("ASoC: multi-component - ASoC
    Multi-Component Support") which was almost 5 years ago. Given that this runs
    after CODEC probe functions have been run it also doesn't seem to be that
    useful.
    
    So drop it altogether to make the code simpler.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 026722f5ebf4..d883b4ad03ac 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1375,8 +1375,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 		}
 	}
 
-	snd_soc_ac97_add_pdata(rtd);
-
 	return 0;
 }
 

commit 336b8423e285174ebecf02a743d69913b83bbc48
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:46 2014 +0100

    ASoC: Move AC'97 support to its own file
    
    Currently the AC'97 support is splattered all throughout soc-core.c. Some
    parts are #ifdef'd some parts are not. This patch moves the AC'97 support to
    its own file, this should make the code a bit more clearer and also makes it
    possible to easily not compile it into the kernel when not needed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7084c6f1285a..026722f5ebf4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -34,9 +34,6 @@
 #include <linux/ctype.h>
 #include <linux/slab.h>
 #include <linux/of.h>
-#include <linux/gpio.h>
-#include <linux/of_gpio.h>
-#include <sound/ac97_codec.h>
 #include <sound/core.h>
 #include <sound/jack.h>
 #include <sound/pcm.h>
@@ -69,16 +66,6 @@ static int pmdown_time = 5000;
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
-struct snd_ac97_reset_cfg {
-	struct pinctrl *pctl;
-	struct pinctrl_state *pstate_reset;
-	struct pinctrl_state *pstate_warm_reset;
-	struct pinctrl_state *pstate_run;
-	int gpio_sdata;
-	int gpio_sync;
-	int gpio_reset;
-};
-
 /* returns the minimum number of bytes needed to represent
  * a particular given value */
 static int min_bytes_needed(unsigned long val)
@@ -499,36 +486,6 @@ struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
 
-#ifdef CONFIG_SND_SOC_AC97_BUS
-/* unregister ac97 codec */
-static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
-{
-	if (codec->ac97->dev.bus)
-		device_del(&codec->ac97->dev);
-	return 0;
-}
-
-/* register ac97 codec to bus */
-static int soc_ac97_dev_register(struct snd_soc_codec *codec)
-{
-	int err;
-
-	codec->ac97->dev.bus = &ac97_bus_type;
-	codec->ac97->dev.parent = codec->component.card->dev;
-
-	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
-		     codec->component.card->snd_card->number, 0,
-		     codec->component.name);
-	err = device_add(&codec->ac97->dev);
-	if (err < 0) {
-		dev_err(codec->dev, "ASoC: Can't register ac97 bus\n");
-		codec->ac97->dev.bus = NULL;
-		return err;
-	}
-	return 0;
-}
-#endif
-
 static void codec2codec_close_delayed_work(struct work_struct *work)
 {
 	/* Currently nothing to do for c2c links
@@ -1418,84 +1375,11 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 		}
 	}
 
-	/* add platform data for AC97 devices */
-	for (i = 0; i < rtd->num_codecs; i++) {
-		if (rtd->codec_dais[i]->driver->ac97_control)
-			snd_ac97_dev_add_pdata(rtd->codec_dais[i]->codec->ac97,
-					       rtd->cpu_dai->ac97_pdata);
-	}
-
-	return 0;
-}
-
-#ifdef CONFIG_SND_SOC_AC97_BUS
-static int soc_register_ac97_codec(struct snd_soc_codec *codec,
-				   struct snd_soc_dai *codec_dai)
-{
-	int ret;
-
-	/* Only instantiate AC97 if not already done by the adaptor
-	 * for the generic AC97 subsystem.
-	 */
-	if (codec_dai->driver->ac97_control && !codec->ac97_registered) {
-		/*
-		 * It is possible that the AC97 device is already registered to
-		 * the device subsystem. This happens when the device is created
-		 * via snd_ac97_mixer(). Currently only SoC codec that does so
-		 * is the generic AC97 glue but others migh emerge.
-		 *
-		 * In those cases we don't try to register the device again.
-		 */
-		if (!codec->ac97_created)
-			return 0;
-
-		ret = soc_ac97_dev_register(codec);
-		if (ret < 0) {
-			dev_err(codec->dev,
-				"ASoC: AC97 device register failed: %d\n", ret);
-			return ret;
-		}
-
-		codec->ac97_registered = 1;
-	}
-	return 0;
-}
-
-static void soc_unregister_ac97_codec(struct snd_soc_codec *codec)
-{
-	if (codec->ac97_registered) {
-		soc_ac97_dev_unregister(codec);
-		codec->ac97_registered = 0;
-	}
-}
-
-static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
-{
-	int i, ret;
-
-	for (i = 0; i < rtd->num_codecs; i++) {
-		struct snd_soc_dai *codec_dai = rtd->codec_dais[i];
-
-		ret = soc_register_ac97_codec(codec_dai->codec, codec_dai);
-		if (ret) {
-			while (--i >= 0)
-				soc_unregister_ac97_codec(codec_dai->codec);
-			return ret;
-		}
-	}
+	snd_soc_ac97_add_pdata(rtd);
 
 	return 0;
 }
 
-static void soc_unregister_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
-{
-	int i;
-
-	for (i = 0; i < rtd->num_codecs; i++)
-		soc_unregister_ac97_codec(rtd->codec_dais[i]->codec);
-}
-#endif
-
 static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
@@ -1789,19 +1673,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		goto probe_aux_dev_err;
 	}
 
-#ifdef CONFIG_SND_SOC_AC97_BUS
-	/* register any AC97 codecs */
-	for (i = 0; i < card->num_rtd; i++) {
-		ret = soc_register_ac97_dai_link(&card->rtd[i]);
-		if (ret < 0) {
-			dev_err(card->dev,
-				"ASoC: failed to register AC97: %d\n", ret);
-			while (--i >= 0)
-				soc_unregister_ac97_dai_link(&card->rtd[i]);
-			goto probe_aux_dev_err;
-		}
-	}
-#endif
+	ret = snd_soc_ac97_register_dai_links(card);
+	if (ret < 0)
+		goto probe_aux_dev_err;
 
 	card->instantiated = 1;
 	snd_soc_dapm_sync(&card->dapm);
@@ -1944,224 +1818,6 @@ static struct platform_driver soc_driver = {
 	.remove		= soc_remove,
 };
 
-static void soc_ac97_device_release(struct device *dev)
-{
-	kfree(to_ac97_t(dev));
-}
-
-/**
- * snd_soc_new_ac97_codec - initailise AC97 device
- * @codec: audio codec
- * @ops: AC97 bus operations
- * @num: AC97 codec number
- *
- * Initialises AC97 codec resources for use by ad-hoc devices only.
- */
-int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
-	struct snd_ac97_bus_ops *ops, int num)
-{
-	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
-	if (codec->ac97 == NULL)
-		return -ENOMEM;
-
-	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
-	if (codec->ac97->bus == NULL) {
-		kfree(codec->ac97);
-		codec->ac97 = NULL;
-		return -ENOMEM;
-	}
-
-	codec->ac97->bus->ops = ops;
-	codec->ac97->num = num;
-	codec->ac97->dev.release = soc_ac97_device_release;
-
-	/*
-	 * Mark the AC97 device to be created by us. This way we ensure that the
-	 * device will be registered with the device subsystem later on.
-	 */
-	codec->ac97_created = 1;
-	device_initialize(&codec->ac97->dev);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
-
-static struct snd_ac97_reset_cfg snd_ac97_rst_cfg;
-
-static void snd_soc_ac97_warm_reset(struct snd_ac97 *ac97)
-{
-	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
-
-	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_warm_reset);
-
-	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 1);
-
-	udelay(10);
-
-	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
-
-	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
-	msleep(2);
-}
-
-static void snd_soc_ac97_reset(struct snd_ac97 *ac97)
-{
-	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
-
-	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_reset);
-
-	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
-	gpio_direction_output(snd_ac97_rst_cfg.gpio_sdata, 0);
-	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 0);
-
-	udelay(10);
-
-	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 1);
-
-	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
-	msleep(2);
-}
-
-static int snd_soc_ac97_parse_pinctl(struct device *dev,
-		struct snd_ac97_reset_cfg *cfg)
-{
-	struct pinctrl *p;
-	struct pinctrl_state *state;
-	int gpio;
-	int ret;
-
-	p = devm_pinctrl_get(dev);
-	if (IS_ERR(p)) {
-		dev_err(dev, "Failed to get pinctrl\n");
-		return PTR_ERR(p);
-	}
-	cfg->pctl = p;
-
-	state = pinctrl_lookup_state(p, "ac97-reset");
-	if (IS_ERR(state)) {
-		dev_err(dev, "Can't find pinctrl state ac97-reset\n");
-		return PTR_ERR(state);
-	}
-	cfg->pstate_reset = state;
-
-	state = pinctrl_lookup_state(p, "ac97-warm-reset");
-	if (IS_ERR(state)) {
-		dev_err(dev, "Can't find pinctrl state ac97-warm-reset\n");
-		return PTR_ERR(state);
-	}
-	cfg->pstate_warm_reset = state;
-
-	state = pinctrl_lookup_state(p, "ac97-running");
-	if (IS_ERR(state)) {
-		dev_err(dev, "Can't find pinctrl state ac97-running\n");
-		return PTR_ERR(state);
-	}
-	cfg->pstate_run = state;
-
-	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 0);
-	if (gpio < 0) {
-		dev_err(dev, "Can't find ac97-sync gpio\n");
-		return gpio;
-	}
-	ret = devm_gpio_request(dev, gpio, "AC97 link sync");
-	if (ret) {
-		dev_err(dev, "Failed requesting ac97-sync gpio\n");
-		return ret;
-	}
-	cfg->gpio_sync = gpio;
-
-	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 1);
-	if (gpio < 0) {
-		dev_err(dev, "Can't find ac97-sdata gpio %d\n", gpio);
-		return gpio;
-	}
-	ret = devm_gpio_request(dev, gpio, "AC97 link sdata");
-	if (ret) {
-		dev_err(dev, "Failed requesting ac97-sdata gpio\n");
-		return ret;
-	}
-	cfg->gpio_sdata = gpio;
-
-	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 2);
-	if (gpio < 0) {
-		dev_err(dev, "Can't find ac97-reset gpio\n");
-		return gpio;
-	}
-	ret = devm_gpio_request(dev, gpio, "AC97 link reset");
-	if (ret) {
-		dev_err(dev, "Failed requesting ac97-reset gpio\n");
-		return ret;
-	}
-	cfg->gpio_reset = gpio;
-
-	return 0;
-}
-
-struct snd_ac97_bus_ops *soc_ac97_ops;
-EXPORT_SYMBOL_GPL(soc_ac97_ops);
-
-int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
-{
-	if (ops == soc_ac97_ops)
-		return 0;
-
-	if (soc_ac97_ops && ops)
-		return -EBUSY;
-
-	soc_ac97_ops = ops;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops);
-
-/**
- * snd_soc_set_ac97_ops_of_reset - Set ac97 ops with generic ac97 reset functions
- *
- * This function sets the reset and warm_reset properties of ops and parses
- * the device node of pdev to get pinctrl states and gpio numbers to use.
- */
-int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
-		struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct snd_ac97_reset_cfg cfg;
-	int ret;
-
-	ret = snd_soc_ac97_parse_pinctl(dev, &cfg);
-	if (ret)
-		return ret;
-
-	ret = snd_soc_set_ac97_ops(ops);
-	if (ret)
-		return ret;
-
-	ops->warm_reset = snd_soc_ac97_warm_reset;
-	ops->reset = snd_soc_ac97_reset;
-
-	snd_ac97_rst_cfg = cfg;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops_of_reset);
-
-/**
- * snd_soc_free_ac97_codec - free AC97 codec device
- * @codec: audio codec
- *
- * Frees AC97 codec device resources.
- */
-void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
-{
-#ifdef CONFIG_SND_SOC_AC97_BUS
-	soc_unregister_ac97_codec(codec);
-#endif
-	kfree(codec->ac97->bus);
-	codec->ac97->bus = NULL;
-	put_device(&codec->ac97->dev);
-	codec->ac97 = NULL;
-	codec->ac97_created = 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
-
 /**
  * snd_soc_cnew - create new control
  * @_template: control template

commit 70f3af3ca15affaef3d026a5aa6e44c4627ea6c7
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 10 22:41:45 2014 +0100

    ASoC: Properly handle AC'97 device lifetime management
    
    The memory that a struct device is contained in must not be freed except
    from within the device's release callback. The ASoC code currently does not
    adhere to this rule for the AC'97 device. This patch fixes it by moving the
    freeing of the AC'97 to the release callback and splitting up the
    registration and unregistration of the device into separate steps for
    getting/putting the reference to the device and adding/removing it to the
    device hierarchy.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..7084c6f1285a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -504,13 +504,10 @@ EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
 static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
 {
 	if (codec->ac97->dev.bus)
-		device_unregister(&codec->ac97->dev);
+		device_del(&codec->ac97->dev);
 	return 0;
 }
 
-/* stop no dev release warning */
-static void soc_ac97_device_release(struct device *dev){}
-
 /* register ac97 codec to bus */
 static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 {
@@ -518,12 +515,11 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 
 	codec->ac97->dev.bus = &ac97_bus_type;
 	codec->ac97->dev.parent = codec->component.card->dev;
-	codec->ac97->dev.release = soc_ac97_device_release;
 
 	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
 		     codec->component.card->snd_card->number, 0,
 		     codec->component.name);
-	err = device_register(&codec->ac97->dev);
+	err = device_add(&codec->ac97->dev);
 	if (err < 0) {
 		dev_err(codec->dev, "ASoC: Can't register ac97 bus\n");
 		codec->ac97->dev.bus = NULL;
@@ -1948,6 +1944,11 @@ static struct platform_driver soc_driver = {
 	.remove		= soc_remove,
 };
 
+static void soc_ac97_device_release(struct device *dev)
+{
+	kfree(to_ac97_t(dev));
+}
+
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec
@@ -1972,12 +1973,14 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 
 	codec->ac97->bus->ops = ops;
 	codec->ac97->num = num;
+	codec->ac97->dev.release = soc_ac97_device_release;
 
 	/*
 	 * Mark the AC97 device to be created by us. This way we ensure that the
 	 * device will be registered with the device subsystem later on.
 	 */
 	codec->ac97_created = 1;
+	device_initialize(&codec->ac97->dev);
 
 	return 0;
 }
@@ -2152,7 +2155,8 @@ void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 	soc_unregister_ac97_codec(codec);
 #endif
 	kfree(codec->ac97->bus);
-	kfree(codec->ac97);
+	codec->ac97->bus = NULL;
+	put_device(&codec->ac97->dev);
 	codec->ac97 = NULL;
 	codec->ac97_created = 0;
 }

commit bd6b87c104bae49816808fde5f55a262093e85ed
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Nov 9 17:01:04 2014 +0100

    ASoC: Remove CODEC mutex
    
    The CODEC mutex is now unused and can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..cc7bb7ad9677 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4362,7 +4362,6 @@ int snd_soc_register_codec(struct device *dev,
 	codec->dev = dev;
 	codec->driver = codec_drv;
 	codec->component.val_bytes = codec_drv->reg_word_size;
-	mutex_init(&codec->mutex);
 
 #ifdef CONFIG_DEBUG_FS
 	codec->component.init_debugfs = soc_init_codec_debugfs;

commit 427d204c86e095bb91eb8af381bd90a48376a860
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Nov 8 16:38:07 2014 +0100

    ASoC: Remove snd_soc_cache_sync() implementation
    
    This function has no more non regmap user, which means we can remove the
    implementation of the function and associated functions and structure
    fields.
    
    For convenience we keep a static inline version of the function that
    forwards calls to regcache_sync() unconditionally.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..4e0e32bb9910 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -309,9 +309,6 @@ static void soc_init_codec_debugfs(struct snd_soc_component *component)
 {
 	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
 
-	debugfs_create_bool("cache_sync", 0444, codec->component.debugfs_root,
-			    &codec->cache_sync);
-
 	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
 						 codec->component.debugfs_root,
 						 codec, &codec_reg_fops);
@@ -656,7 +653,6 @@ int snd_soc_suspend(struct device *dev)
 				if (codec->driver->suspend)
 					codec->driver->suspend(codec);
 				codec->suspended = 1;
-				codec->cache_sync = 1;
 				if (codec->component.regmap)
 					regcache_mark_dirty(codec->component.regmap);
 				/* deactivate pins to sleep state */

commit 8e2be56273666614e24756d7ee551203b8a86809
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 4 11:30:59 2014 +0100

    ASoC: Consolidate CPU and CODEC DAI probe
    
    CPU and CODEC DAI probe are performed in exactly the same way. Which means
    we can reuse the snd_soc_codec_dai_probe() for probing CPU DAIs as well.
    
    While we are at it also drop the unused card parameter form the function.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f3216fc6d9f1..406925c2bbe7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1241,25 +1241,22 @@ static int soc_probe_link_components(struct snd_soc_card *card, int num,
 	return 0;
 }
 
-static int soc_probe_codec_dai(struct snd_soc_card *card,
-			       struct snd_soc_dai *codec_dai,
-			       int order)
+static int soc_probe_dai(struct snd_soc_dai *dai, int order)
 {
 	int ret;
 
-	if (!codec_dai->probed && codec_dai->driver->probe_order == order) {
-		if (codec_dai->driver->probe) {
-			ret = codec_dai->driver->probe(codec_dai);
+	if (!dai->probed && dai->driver->probe_order == order) {
+		if (dai->driver->probe) {
+			ret = dai->driver->probe(dai);
 			if (ret < 0) {
-				dev_err(codec_dai->dev,
-					"ASoC: failed to probe CODEC DAI %s: %d\n",
-					codec_dai->name, ret);
+				dev_err(dai->dev,
+					"ASoC: failed to probe DAI %s: %d\n",
+					dai->name, ret);
 				return ret;
 			}
 		}
 
-		/* mark codec_dai as probed and add to card dai list */
-		codec_dai->probed = 1;
+		dai->probed = 1;
 	}
 
 	return 0;
@@ -1318,24 +1315,13 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	/* set default power off timeout */
 	rtd->pmdown_time = pmdown_time;
 
-	/* probe the cpu_dai */
-	if (!cpu_dai->probed &&
-			cpu_dai->driver->probe_order == order) {
-		if (cpu_dai->driver->probe) {
-			ret = cpu_dai->driver->probe(cpu_dai);
-			if (ret < 0) {
-				dev_err(cpu_dai->dev,
-					"ASoC: failed to probe CPU DAI %s: %d\n",
-					cpu_dai->name, ret);
-				return ret;
-			}
-		}
-		cpu_dai->probed = 1;
-	}
+	ret = soc_probe_dai(cpu_dai, order);
+	if (ret)
+		return ret;
 
 	/* probe the CODEC DAI */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		ret = soc_probe_codec_dai(card, rtd->codec_dais[i], order);
+		ret = soc_probe_dai(rtd->codec_dais[i], order);
 		if (ret)
 			return ret;
 	}

commit 313665b983fe30af9d0eb274f7e03276e05a1bbf
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 4 11:30:58 2014 +0100

    ASoC: Remove card field from snd_soc_dai struct
    
    The card field of the snd_soc_dai field is very rarely used. We can use
    dai->component->card instead and remove the card field from the snd_soc_dai
    struct.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ea1df2083bd5..f3216fc6d9f1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1315,11 +1315,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
 			card->name, num, order);
 
-	/* config components */
-	cpu_dai->card = card;
-	for (i = 0; i < rtd->num_codecs; i++)
-		rtd->codec_dais[i]->card = card;
-
 	/* set default power off timeout */
 	rtd->pmdown_time = pmdown_time;
 
@@ -2314,7 +2309,7 @@ EXPORT_SYMBOL_GPL(snd_soc_add_card_controls);
 int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
 	const struct snd_kcontrol_new *controls, int num_controls)
 {
-	struct snd_card *card = dai->card->snd_card;
+	struct snd_card *card = dai->component->card->snd_card;
 
 	return snd_soc_add_controls(card, dai->dev, controls, num_controls,
 			NULL, dai);

commit ff1b1c3fef511ff051db0d5de332afd15acad363
Merge: 2a374b78f5c2 92a99ea439c4
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Nov 4 11:53:49 2014 +0000

    Merge branch 'topic/dapm' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-core

commit 2a374b78f5c2b5f31d35f8a7cd004989d6936756
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 3 10:31:48 2014 +0100

    ASoC: Remove platform field from snd_soc_dai
    
    Typically a DAI does not need direct access to the platform. Currently the
    only user of this field is in a platform driver where we have a more direct
    way of getting a pointer to the platform. This patch updates the driver to
    use the more direct way and then removes the platform field from the
    snd_soc_dai struct.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0509d726759d..e20bb65a1634 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1309,7 +1309,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	int i, ret;
 
@@ -1317,7 +1316,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 			card->name, num, order);
 
 	/* config components */
-	cpu_dai->platform = platform;
 	cpu_dai->card = card;
 	for (i = 0; i < rtd->num_codecs; i++)
 		rtd->codec_dais[i]->card = card;

commit dd63a9c2952ed142c64fd68c1a74d0d6fcac586f
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 3 10:31:47 2014 +0100

    ASoC: Remove snd_soc_platform_driver suspend/resume callbacks
    
    Those are unused and new drivers should use device driver suspend/resume.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a2b51edf6d83..0509d726759d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -592,17 +592,12 @@ int snd_soc_suspend(struct device *dev)
 
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
-		struct snd_soc_platform *platform = card->rtd[i].platform;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
 		if (cpu_dai->driver->suspend && !cpu_dai->driver->ac97_control)
 			cpu_dai->driver->suspend(cpu_dai);
-		if (platform->driver->suspend && !platform->suspended) {
-			platform->driver->suspend(cpu_dai);
-			platform->suspended = 1;
-		}
 	}
 
 	/* close any waiting streams and save state */
@@ -775,17 +770,12 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
-		struct snd_soc_platform *platform = card->rtd[i].platform;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
 		if (cpu_dai->driver->resume && !cpu_dai->driver->ac97_control)
 			cpu_dai->driver->resume(cpu_dai);
-		if (platform->driver->resume && platform->suspended) {
-			platform->driver->resume(cpu_dai);
-			platform->suspended = 0;
-		}
 	}
 
 	if (card->resume_post)

commit 1ffae3612fe53dd18b92e696ab4f29df319a508d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Oct 29 21:46:30 2014 +0100

    ASoC: Fix snd_soc_find_dai() matching component by name
    
    Commit 14621c7e5e72 ("ASoC: Consolidate CPU and CODEC DAI lookup")
    consolidated the lookup of CPU DAIs and CODEC DAIs into a single function.
    When matching a component by name for CODEC DAIs the code previous to the
    patch compared the name in the DAI link table with component->name. For CPU
    DAIs the code compared to dev_name(component->dev). The newly introduced
    function ended up using the later as well.
    
    For most components dev_name(component->dev) and component->name are the
    same. The main notable exception are I2C devices where the driver name and
    the device name are concatenated to form the component name. By using
    dev_name(component->dev) instead of component->name the patch broke the
    matching of I2C CODECs by name.
    
    This patch restores the original behavior by using component->name instead
    of dev_name(component->dev). This will be safe even for CPU DAIs since for
    CPU DAIs both are the same.
    
    Fixes: 14621c7e5e72 ("ASoC: Consolidate CPU and CODEC DAI lookup")
    Reported-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..b60ff56ebc0f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -884,7 +884,7 @@ static struct snd_soc_dai *snd_soc_find_dai(
 	list_for_each_entry(component, &component_list, list) {
 		if (dlc->of_node && component->dev->of_node != dlc->of_node)
 			continue;
-		if (dlc->name && strcmp(dev_name(component->dev), dlc->name))
+		if (dlc->name && strcmp(component->name, dlc->name))
 			continue;
 		list_for_each_entry(dai, &component->dai_list, list) {
 			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name))

commit 7077148fb50a120d20a50516a332ed6eb9233c16
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Oct 28 22:15:31 2014 +0000

    ASoC: core: Split ops out of soc-core.c
    
    The main ASoC source file is getting quite large and the standard ops don't
    really have anything to do with the rest of the file so split them out into
    a separate file.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 47c378abb9a2..a2b51edf6d83 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2333,925 +2333,6 @@ int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
 
-/**
- * snd_soc_info_enum_double - enumerated double mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a double enumerated
- * mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-
-	return snd_ctl_enum_info(uinfo, e->shift_l == e->shift_r ? 1 : 2,
-				 e->items, e->texts);
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
-
-/**
- * snd_soc_get_enum_double - enumerated double mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a double enumerated mixer.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int val, item;
-	unsigned int reg_val;
-	int ret;
-
-	ret = snd_soc_component_read(component, e->reg, &reg_val);
-	if (ret)
-		return ret;
-	val = (reg_val >> e->shift_l) & e->mask;
-	item = snd_soc_enum_val_to_item(e, val);
-	ucontrol->value.enumerated.item[0] = item;
-	if (e->shift_l != e->shift_r) {
-		val = (reg_val >> e->shift_l) & e->mask;
-		item = snd_soc_enum_val_to_item(e, val);
-		ucontrol->value.enumerated.item[1] = item;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
-
-/**
- * snd_soc_put_enum_double - enumerated double mixer put callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value of a double enumerated mixer.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int *item = ucontrol->value.enumerated.item;
-	unsigned int val;
-	unsigned int mask;
-
-	if (item[0] >= e->items)
-		return -EINVAL;
-	val = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;
-	mask = e->mask << e->shift_l;
-	if (e->shift_l != e->shift_r) {
-		if (item[1] >= e->items)
-			return -EINVAL;
-		val |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_r;
-		mask |= e->mask << e->shift_r;
-	}
-
-	return snd_soc_component_update_bits(component, e->reg, mask, val);
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
-
-/**
- * snd_soc_read_signed - Read a codec register and interprete as signed value
- * @component: component
- * @reg: Register to read
- * @mask: Mask to use after shifting the register value
- * @shift: Right shift of register value
- * @sign_bit: Bit that describes if a number is negative or not.
- * @signed_val: Pointer to where the read value should be stored
- *
- * This functions reads a codec register. The register value is shifted right
- * by 'shift' bits and masked with the given 'mask'. Afterwards it translates
- * the given registervalue into a signed integer if sign_bit is non-zero.
- *
- * Returns 0 on sucess, otherwise an error value
- */
-static int snd_soc_read_signed(struct snd_soc_component *component,
-	unsigned int reg, unsigned int mask, unsigned int shift,
-	unsigned int sign_bit, int *signed_val)
-{
-	int ret;
-	unsigned int val;
-
-	ret = snd_soc_component_read(component, reg, &val);
-	if (ret < 0)
-		return ret;
-
-	val = (val >> shift) & mask;
-
-	if (!sign_bit) {
-		*signed_val = val;
-		return 0;
-	}
-
-	/* non-negative number */
-	if (!(val & BIT(sign_bit))) {
-		*signed_val = val;
-		return 0;
-	}
-
-	ret = val;
-
-	/*
-	 * The register most probably does not contain a full-sized int.
-	 * Instead we have an arbitrary number of bits in a signed
-	 * representation which has to be translated into a full-sized int.
-	 * This is done by filling up all bits above the sign-bit.
-	 */
-	ret |= ~((int)(BIT(sign_bit) - 1));
-
-	*signed_val = ret;
-
-	return 0;
-}
-
-/**
- * snd_soc_info_volsw - single mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a single mixer control, or a double
- * mixer control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int platform_max;
-
-	if (!mc->platform_max)
-		mc->platform_max = mc->max;
-	platform_max = mc->platform_max;
-
-	if (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	else
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-
-	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = platform_max - mc->min;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
-
-/**
- * snd_soc_get_volsw - single mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a single mixer control, or a double mixer
- * control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	int min = mc->min;
-	int sign_bit = mc->sign_bit;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	int val;
-	int ret;
-
-	if (sign_bit)
-		mask = BIT(sign_bit + 1) - 1;
-
-	ret = snd_soc_read_signed(component, reg, mask, shift, sign_bit, &val);
-	if (ret)
-		return ret;
-
-	ucontrol->value.integer.value[0] = val - min;
-	if (invert)
-		ucontrol->value.integer.value[0] =
-			max - ucontrol->value.integer.value[0];
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		if (reg == reg2)
-			ret = snd_soc_read_signed(component, reg, mask, rshift,
-				sign_bit, &val);
-		else
-			ret = snd_soc_read_signed(component, reg2, mask, shift,
-				sign_bit, &val);
-		if (ret)
-			return ret;
-
-		ucontrol->value.integer.value[1] = val - min;
-		if (invert)
-			ucontrol->value.integer.value[1] =
-				max - ucontrol->value.integer.value[1];
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
-
-/**
- * snd_soc_put_volsw - single mixer put callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value of a single mixer control, or a double mixer
- * control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	int min = mc->min;
-	unsigned int sign_bit = mc->sign_bit;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	int err;
-	bool type_2r = false;
-	unsigned int val2 = 0;
-	unsigned int val, val_mask;
-
-	if (sign_bit)
-		mask = BIT(sign_bit + 1) - 1;
-
-	val = ((ucontrol->value.integer.value[0] + min) & mask);
-	if (invert)
-		val = max - val;
-	val_mask = mask << shift;
-	val = val << shift;
-	if (snd_soc_volsw_is_stereo(mc)) {
-		val2 = ((ucontrol->value.integer.value[1] + min) & mask);
-		if (invert)
-			val2 = max - val2;
-		if (reg == reg2) {
-			val_mask |= mask << rshift;
-			val |= val2 << rshift;
-		} else {
-			val2 = val2 << shift;
-			type_2r = true;
-		}
-	}
-	err = snd_soc_component_update_bits(component, reg, val_mask, val);
-	if (err < 0)
-		return err;
-
-	if (type_2r)
-		err = snd_soc_component_update_bits(component, reg2, val_mask,
-			val2);
-
-	return err;
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
-
-/**
- * snd_soc_get_volsw_sx - single mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a single mixer control, or a double mixer
- * control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,
-		      struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-	    (struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	int min = mc->min;
-	int mask = (1 << (fls(min + max) - 1)) - 1;
-	unsigned int val;
-	int ret;
-
-	ret = snd_soc_component_read(component, reg, &val);
-	if (ret < 0)
-		return ret;
-
-	ucontrol->value.integer.value[0] = ((val >> shift) - min) & mask;
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		ret = snd_soc_component_read(component, reg2, &val);
-		if (ret < 0)
-			return ret;
-
-		val = ((val >> rshift) - min) & mask;
-		ucontrol->value.integer.value[1] = val;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_volsw_sx);
-
-/**
- * snd_soc_put_volsw_sx - double mixer set callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to set the value of a double mixer control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
-			 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-	    (struct soc_mixer_control *)kcontrol->private_value;
-
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	int min = mc->min;
-	int mask = (1 << (fls(min + max) - 1)) - 1;
-	int err = 0;
-	unsigned int val, val_mask, val2 = 0;
-
-	val_mask = mask << shift;
-	val = (ucontrol->value.integer.value[0] + min) & mask;
-	val = val << shift;
-
-	err = snd_soc_component_update_bits(component, reg, val_mask, val);
-	if (err < 0)
-		return err;
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		val_mask = mask << rshift;
-		val2 = (ucontrol->value.integer.value[1] + min) & mask;
-		val2 = val2 << rshift;
-
-		err = snd_soc_component_update_bits(component, reg2, val_mask,
-			val2);
-	}
-	return err;
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw_sx);
-
-/**
- * snd_soc_info_volsw_range - single mixer info callback with range.
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information, within a range, about a single
- * mixer control.
- *
- * returns 0 for success.
- */
-int snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int platform_max;
-	int min = mc->min;
-
-	if (!mc->platform_max)
-		mc->platform_max = mc->max;
-	platform_max = mc->platform_max;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = platform_max - min;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_volsw_range);
-
-/**
- * snd_soc_put_volsw_range - single mixer put value callback with range.
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value, within a range, for a single mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	unsigned int rreg = mc->rreg;
-	unsigned int shift = mc->shift;
-	int min = mc->min;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	unsigned int val, val_mask;
-	int ret;
-
-	if (invert)
-		val = (max - ucontrol->value.integer.value[0]) & mask;
-	else
-		val = ((ucontrol->value.integer.value[0] + min) & mask);
-	val_mask = mask << shift;
-	val = val << shift;
-
-	ret = snd_soc_component_update_bits(component, reg, val_mask, val);
-	if (ret < 0)
-		return ret;
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		if (invert)
-			val = (max - ucontrol->value.integer.value[1]) & mask;
-		else
-			val = ((ucontrol->value.integer.value[1] + min) & mask);
-		val_mask = mask << shift;
-		val = val << shift;
-
-		ret = snd_soc_component_update_bits(component, rreg, val_mask,
-			val);
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw_range);
-
-/**
- * snd_soc_get_volsw_range - single mixer get callback with range
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value, within a range, of a single mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int rreg = mc->rreg;
-	unsigned int shift = mc->shift;
-	int min = mc->min;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	unsigned int val;
-	int ret;
-
-	ret = snd_soc_component_read(component, reg, &val);
-	if (ret)
-		return ret;
-
-	ucontrol->value.integer.value[0] = (val >> shift) & mask;
-	if (invert)
-		ucontrol->value.integer.value[0] =
-			max - ucontrol->value.integer.value[0];
-	else
-		ucontrol->value.integer.value[0] =
-			ucontrol->value.integer.value[0] - min;
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		ret = snd_soc_component_read(component, rreg, &val);
-		if (ret)
-			return ret;
-
-		ucontrol->value.integer.value[1] = (val >> shift) & mask;
-		if (invert)
-			ucontrol->value.integer.value[1] =
-				max - ucontrol->value.integer.value[1];
-		else
-			ucontrol->value.integer.value[1] =
-				ucontrol->value.integer.value[1] - min;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_volsw_range);
-
-/**
- * snd_soc_limit_volume - Set new limit to an existing volume control.
- *
- * @codec: where to look for the control
- * @name: Name of the control
- * @max: new maximum limit
- *
- * Return 0 for success, else error.
- */
-int snd_soc_limit_volume(struct snd_soc_codec *codec,
-	const char *name, int max)
-{
-	struct snd_card *card = codec->component.card->snd_card;
-	struct snd_kcontrol *kctl;
-	struct soc_mixer_control *mc;
-	int found = 0;
-	int ret = -EINVAL;
-
-	/* Sanity check for name and max */
-	if (unlikely(!name || max <= 0))
-		return -EINVAL;
-
-	list_for_each_entry(kctl, &card->controls, list) {
-		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name))) {
-			found = 1;
-			break;
-		}
-	}
-	if (found) {
-		mc = (struct soc_mixer_control *)kctl->private_value;
-		if (max <= mc->max) {
-			mc->platform_max = max;
-			ret = 0;
-		}
-	}
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_limit_volume);
-
-int snd_soc_bytes_info(struct snd_kcontrol *kcontrol,
-		       struct snd_ctl_elem_info *uinfo)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_bytes *params = (void *)kcontrol->private_value;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	uinfo->count = params->num_regs * component->val_bytes;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_info);
-
-int snd_soc_bytes_get(struct snd_kcontrol *kcontrol,
-		      struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_bytes *params = (void *)kcontrol->private_value;
-	int ret;
-
-	if (component->regmap)
-		ret = regmap_raw_read(component->regmap, params->base,
-				      ucontrol->value.bytes.data,
-				      params->num_regs * component->val_bytes);
-	else
-		ret = -EINVAL;
-
-	/* Hide any masked bytes to ensure consistent data reporting */
-	if (ret == 0 && params->mask) {
-		switch (component->val_bytes) {
-		case 1:
-			ucontrol->value.bytes.data[0] &= ~params->mask;
-			break;
-		case 2:
-			((u16 *)(&ucontrol->value.bytes.data))[0]
-				&= cpu_to_be16(~params->mask);
-			break;
-		case 4:
-			((u32 *)(&ucontrol->value.bytes.data))[0]
-				&= cpu_to_be32(~params->mask);
-			break;
-		default:
-			return -EINVAL;
-		}
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_get);
-
-int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
-		      struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_bytes *params = (void *)kcontrol->private_value;
-	int ret, len;
-	unsigned int val, mask;
-	void *data;
-
-	if (!component->regmap || !params->num_regs)
-		return -EINVAL;
-
-	len = params->num_regs * component->val_bytes;
-
-	data = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);
-	if (!data)
-		return -ENOMEM;
-
-	/*
-	 * If we've got a mask then we need to preserve the register
-	 * bits.  We shouldn't modify the incoming data so take a
-	 * copy.
-	 */
-	if (params->mask) {
-		ret = regmap_read(component->regmap, params->base, &val);
-		if (ret != 0)
-			goto out;
-
-		val &= params->mask;
-
-		switch (component->val_bytes) {
-		case 1:
-			((u8 *)data)[0] &= ~params->mask;
-			((u8 *)data)[0] |= val;
-			break;
-		case 2:
-			mask = ~params->mask;
-			ret = regmap_parse_val(component->regmap,
-							&mask, &mask);
-			if (ret != 0)
-				goto out;
-
-			((u16 *)data)[0] &= mask;
-
-			ret = regmap_parse_val(component->regmap,
-							&val, &val);
-			if (ret != 0)
-				goto out;
-
-			((u16 *)data)[0] |= val;
-			break;
-		case 4:
-			mask = ~params->mask;
-			ret = regmap_parse_val(component->regmap,
-							&mask, &mask);
-			if (ret != 0)
-				goto out;
-
-			((u32 *)data)[0] &= mask;
-
-			ret = regmap_parse_val(component->regmap,
-							&val, &val);
-			if (ret != 0)
-				goto out;
-
-			((u32 *)data)[0] |= val;
-			break;
-		default:
-			ret = -EINVAL;
-			goto out;
-		}
-	}
-
-	ret = regmap_raw_write(component->regmap, params->base,
-			       data, len);
-
-out:
-	kfree(data);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_put);
-
-int snd_soc_bytes_info_ext(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_info *ucontrol)
-{
-	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
-
-	ucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	ucontrol->count = params->max;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_info_ext);
-
-int snd_soc_bytes_tlv_callback(struct snd_kcontrol *kcontrol, int op_flag,
-				unsigned int size, unsigned int __user *tlv)
-{
-	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
-	unsigned int count = size < params->max ? size : params->max;
-	int ret = -ENXIO;
-
-	switch (op_flag) {
-	case SNDRV_CTL_TLV_OP_READ:
-		if (params->get)
-			ret = params->get(tlv, count);
-		break;
-	case SNDRV_CTL_TLV_OP_WRITE:
-		if (params->put)
-			ret = params->put(tlv, count);
-		break;
-	}
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_tlv_callback);
-
-/**
- * snd_soc_info_xr_sx - signed multi register info callback
- * @kcontrol: mreg control
- * @uinfo: control element information
- *
- * Callback to provide information of a control that can
- * span multiple codec registers which together
- * forms a single signed value in a MSB/LSB manner.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_xr_sx(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_mreg_control *mc =
-		(struct soc_mreg_control *)kcontrol->private_value;
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = mc->min;
-	uinfo->value.integer.max = mc->max;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_xr_sx);
-
-/**
- * snd_soc_get_xr_sx - signed multi register get callback
- * @kcontrol: mreg control
- * @ucontrol: control element information
- *
- * Callback to get the value of a control that can span
- * multiple codec registers which together forms a single
- * signed value in a MSB/LSB manner. The control supports
- * specifying total no of bits used to allow for bitfields
- * across the multiple codec registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mreg_control *mc =
-		(struct soc_mreg_control *)kcontrol->private_value;
-	unsigned int regbase = mc->regbase;
-	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
-	unsigned int regwmask = (1<<regwshift)-1;
-	unsigned int invert = mc->invert;
-	unsigned long mask = (1UL<<mc->nbits)-1;
-	long min = mc->min;
-	long max = mc->max;
-	long val = 0;
-	unsigned int regval;
-	unsigned int i;
-	int ret;
-
-	for (i = 0; i < regcount; i++) {
-		ret = snd_soc_component_read(component, regbase+i, &regval);
-		if (ret)
-			return ret;
-		val |= (regval & regwmask) << (regwshift*(regcount-i-1));
-	}
-	val &= mask;
-	if (min < 0 && val > max)
-		val |= ~mask;
-	if (invert)
-		val = max - val;
-	ucontrol->value.integer.value[0] = val;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_xr_sx);
-
-/**
- * snd_soc_put_xr_sx - signed multi register get callback
- * @kcontrol: mreg control
- * @ucontrol: control element information
- *
- * Callback to set the value of a control that can span
- * multiple codec registers which together forms a single
- * signed value in a MSB/LSB manner. The control supports
- * specifying total no of bits used to allow for bitfields
- * across the multiple codec registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mreg_control *mc =
-		(struct soc_mreg_control *)kcontrol->private_value;
-	unsigned int regbase = mc->regbase;
-	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
-	unsigned int regwmask = (1<<regwshift)-1;
-	unsigned int invert = mc->invert;
-	unsigned long mask = (1UL<<mc->nbits)-1;
-	long max = mc->max;
-	long val = ucontrol->value.integer.value[0];
-	unsigned int i, regval, regmask;
-	int err;
-
-	if (invert)
-		val = max - val;
-	val &= mask;
-	for (i = 0; i < regcount; i++) {
-		regval = (val >> (regwshift*(regcount-i-1))) & regwmask;
-		regmask = (mask >> (regwshift*(regcount-i-1))) & regwmask;
-		err = snd_soc_component_update_bits(component, regbase+i,
-				regmask, regval);
-		if (err < 0)
-			return err;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_xr_sx);
-
-/**
- * snd_soc_get_strobe - strobe get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback get the value of a strobe mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_strobe(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int mask = 1 << shift;
-	unsigned int invert = mc->invert != 0;
-	unsigned int val;
-	int ret;
-
-	ret = snd_soc_component_read(component, reg, &val);
-	if (ret)
-		return ret;
-
-	val &= mask;
-
-	if (shift != 0 && val != 0)
-		val = val >> shift;
-	ucontrol->value.enumerated.item[0] = val ^ invert;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_strobe);
-
-/**
- * snd_soc_put_strobe - strobe put callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback strobe a register bit to high then low (or the inverse)
- * in one pass of a single mixer enum control.
- *
- * Returns 1 for success.
- */
-int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int mask = 1 << shift;
-	unsigned int invert = mc->invert != 0;
-	unsigned int strobe = ucontrol->value.enumerated.item[0] != 0;
-	unsigned int val1 = (strobe ^ invert) ? mask : 0;
-	unsigned int val2 = (strobe ^ invert) ? 0 : mask;
-	int err;
-
-	err = snd_soc_component_update_bits(component, reg, mask, val1);
-	if (err < 0)
-		return err;
-
-	return snd_soc_component_update_bits(component, reg, mask, val2);
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_strobe);
-
 /**
  * snd_soc_dai_set_sysclk - configure DAI system or master clock.
  * @dai: DAI

commit c1b4d1c7774189002bc08766ec10e339dfbc98d6
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Oct 25 20:25:56 2014 +0200

    ASoC: Use generic control handlers for S8 control
    
    Commit f227b88f0fce ("ASoC: core: Add signed register volume control logic")
    added support for signed control to the generic volsw control handler.
    This makes it possible to use them for the S8 control as well, rather than
    having to use a custom control handler implementation.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 96ecdc30eb60..47c378abb9a2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2720,93 +2720,6 @@ int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_sx);
 
-/**
- * snd_soc_info_volsw_s8 - signed mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a signed mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int platform_max;
-	int min = mc->min;
-
-	if (!mc->platform_max)
-		mc->platform_max = mc->max;
-	platform_max = mc->platform_max;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = platform_max - min;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_volsw_s8);
-
-/**
- * snd_soc_get_volsw_s8 - signed mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a signed mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	unsigned int val;
-	int min = mc->min;
-	int ret;
-
-	ret = snd_soc_component_read(component, reg, &val);
-	if (ret)
-		return ret;
-
-	ucontrol->value.integer.value[0] =
-		((signed char)(val & 0xff))-min;
-	ucontrol->value.integer.value[1] =
-		((signed char)((val >> 8) & 0xff))-min;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_volsw_s8);
-
-/**
- * snd_soc_put_volsw_sgn - signed mixer put callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value of a signed mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	int min = mc->min;
-	unsigned int val;
-
-	val = (ucontrol->value.integer.value[0]+min) & 0xff;
-	val |= ((ucontrol->value.integer.value[1]+min) & 0xff) << 8;
-
-	return snd_soc_component_update_bits(component, reg, 0xffff, val);
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
-
 /**
  * snd_soc_info_volsw_range - single mixer info callback with range.
  * @kcontrol: mixer control

commit 8be4da29cf5b8ec65e974c36e7ae4d90b381ac5e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Oct 25 17:42:01 2014 +0200

    ASoC: dapm: Mark endpoints instead of IO widgets dirty during suspend/resume
    
    The state of endpoint widgets is affected by that card's power state.
    Endpoint widgets that do no have the ignore_suspend flag set will be
    considered inactive during suspend. So they have to be re-checked and marked
    dirty after the card's power state changes. Currently the input and output
    widgets are marked dirty instead, this works most of the time since
    typically a path from one endpoint to another will go via a input or output
    widget. But marking the endpoints dirty is technically more correct and will
    also work for odd corner cases.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..443be0061129 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -629,8 +629,8 @@ int snd_soc_suspend(struct device *dev)
 					  SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
-	/* Recheck all analogue paths too */
-	dapm_mark_io_dirty(&card->dapm);
+	/* Recheck all endpoints too, their state is affected by suspend */
+	dapm_mark_endpoints_dirty(card);
 	snd_soc_dapm_sync(&card->dapm);
 
 	/* suspend all CODECs */
@@ -796,8 +796,8 @@ static void soc_resume_deferred(struct work_struct *work)
 	/* userspace can access us now we are back as we were before */
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
 
-	/* Recheck all analogue paths too */
-	dapm_mark_io_dirty(&card->dapm);
+	/* Recheck all endpoints too, their state is affected by suspend */
+	dapm_mark_endpoints_dirty(card);
 	snd_soc_dapm_sync(&card->dapm);
 }
 

commit 78cb4d995b932d9014342ddc81ce0a5cc434ed98
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 21 12:14:56 2014 +0200

    ASoC: core: Use snd_ctl_enum_info()
    
    ... and reduce the open codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..96ecdc30eb60 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2348,16 +2348,8 @@ int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
 {
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
-	uinfo->value.enumerated.items = e->items;
-
-	if (uinfo->value.enumerated.item >= e->items)
-		uinfo->value.enumerated.item = e->items - 1;
-	strlcpy(uinfo->value.enumerated.name,
-		e->texts[uinfo->value.enumerated.item],
-		sizeof(uinfo->value.enumerated.name));
-	return 0;
+	return snd_ctl_enum_info(uinfo, e->shift_l == e->shift_r ? 1 : 2,
+				 e->items, e->texts);
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
 

commit ab31135e6ed873011b40e6f547831757a275d15b
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:22:02 2014 +0200

    ASoC: : drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c8f8a23a0e9..0a476b650708 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1941,7 +1941,6 @@ EXPORT_SYMBOL_GPL(snd_soc_pm_ops);
 static struct platform_driver soc_driver = {
 	.driver		= {
 		.name		= "soc-audio",
-		.owner		= THIS_MODULE,
 		.pm		= &snd_soc_pm_ops,
 	},
 	.probe		= soc_probe,

commit b9fb729949bcd9e592a4c599d2d7875157181db9
Merge: 7b8ab38e8d9c 5e63dfccf34d
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Oct 8 16:44:49 2014 +0100

    Merge remote-tracking branch 'asoc/fix/core' into asoc-linus

commit decc27b01d584c985c231e73d3b493de6ec07af8
Author: Daniel Mack <daniel@zonque.org>
Date:   Tue Oct 7 13:41:23 2014 +0200

    ASoC: core: fix use after free in snd_soc_remove_platform()
    
    Coverity spotted an use-after-free condition in snd_soc_remove_platform().
    Fix this by moving snd_soc_component_cleanup() after the debug print
    statement which uses the component's string.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ae48f1013e80..d877ec57d761 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4315,10 +4315,10 @@ void snd_soc_remove_platform(struct snd_soc_platform *platform)
 	snd_soc_component_del_unlocked(&platform->component);
 	mutex_unlock(&client_mutex);
 
-	snd_soc_component_cleanup(&platform->component);
-
 	dev_dbg(platform->dev, "ASoC: Unregistered platform '%s'\n",
 		platform->component.name);
+
+	snd_soc_component_cleanup(&platform->component);
 }
 EXPORT_SYMBOL_GPL(snd_soc_remove_platform);
 

commit 565fefdf31a58b5c07869fe598c3dcc69ed680d7
Merge: 9919badff1ae f114ce605daa 8a36eaa2ff4a 5d5e63af9980 8d01370f5985 c05a11f7b8b5
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Oct 6 12:48:57 2014 +0100

    Merge remote-tracking branches 'asoc/topic/davinci', 'asoc/topic/dmic', 'asoc/topic/drivers', 'asoc/topic/es8328' and 'asoc/topic/fsl' into asoc-next

commit 97c53e26f0773b9eb9ede21f544a91dd1bcd9ca9
Merge: 5bcaca4b5bf2 e03f73a01f01
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Oct 6 12:48:52 2014 +0100

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 5bcaca4b5bf2b05cc15a2c5bfb3d95fc49607e36
Merge: 832a94143c54 b2d9de549c30
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Oct 6 12:48:51 2014 +0100

    Merge remote-tracking branch 'asoc/topic/component' into asoc-next

commit 0bd2ac3dae74ee25c5ea171cb572731c7a89c248
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Sep 29 11:40:42 2014 +0200

    ASoC: Remove CODEC pointer from snd_soc_dapm_context
    
    The only remaining user of the CODEC pointer in the DAPM struct is to
    initialize the CODEC pointer in the widget struct. The later is scheduled
    for removal, but has still a few users left. For now use
    dapm->component->codec to initialize it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 052f59c1917f..8d45eec141a9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4351,7 +4351,6 @@ int snd_soc_register_codec(struct device *dev,
 	if (codec_drv->read)
 		codec->component.read = snd_soc_codec_drv_read;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
-	codec->dapm.codec = codec;
 	codec->dapm.idle_bias_off = codec_drv->idle_bias_off;
 	if (codec_drv->seq_notifier)
 		codec->dapm.seq_notifier = codec_drv->seq_notifier;

commit 82b925c405444b760e743b55a9ad498cb3551afe
Merge: dfae90ed7fb5 2e4ec1c0b879 6596aa047b62 85151461f114 66d627d554a4
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Sep 28 12:25:12 2014 +0100

    Merge remote-tracking branches 'asoc/fix/atmel', 'asoc/fix/compress', 'asoc/fix/core', 'asoc/fix/fsl-ssi' and 'asoc/fix/rt286' into asoc-linus

commit 6596aa047b624aeec2ea321962cfdecf9953a383
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Sun Sep 28 17:29:37 2014 +0800

    ASoC: core: fix possible ZERO_SIZE_PTR pointer dereferencing error.
    
    Since we cannot make sure the 'params->num_regs' will always be none
    zero here, and then if it equals to zero, the kmemdup() will return
    ZERO_SIZE_PTR, which equals to ((void *)16).
    
    So this patch fix this with just doing the zero check before calling
    kmemdup().
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d4bfd4a9076f..ae48f1013e80 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3203,7 +3203,7 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 	unsigned int val, mask;
 	void *data;
 
-	if (!component->regmap)
+	if (!component->regmap || !params->num_regs)
 		return -EINVAL;
 
 	len = params->num_regs * component->val_bytes;

commit 5c7c343a1159d1cb7604b6137cf547b2c1e2375d
Author: Howard Mitchell <hm@hmbedded.co.uk>
Date:   Fri Sep 19 12:50:31 2014 +0100

    ASoC: core: Fix volsw_range funcs so SOC_DOUBLE_R_RANGE_TLV works.
    
    This fixes a bug when using the SOC_DOUBLE_R_RANGE_TLV macro in
    the invert mode. In the non-invert case, e.g.
    
    SOC_DOUBLE_R_RANGE_TLV("<name>", <reg_l>, <reg_r>,
                                            0, 40, 255, 0, <tlv>)
    
    the range sent to the hardware is 40..255, but in the invert case:
    
    SOC_DOUBLE_R_RANGE_TLV("<name>", <reg_l>, <reg_r>,
                                            0, 40, 255, 1, <tlv>)
    
    the range 215..0 was being sent to the hardware. This commit
    corrects this to 255..40 so it is consistent with the non-invert
    case.
    
    Signed-off-by: Howard Mitchell <hm@hmbedded.co.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3c57f5cf2779..dde4b82ad41d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3019,9 +3019,10 @@ int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
 	unsigned int val, val_mask;
 	int ret;
 
-	val = ((ucontrol->value.integer.value[0] + min) & mask);
 	if (invert)
-		val = max - val;
+		val = (max - ucontrol->value.integer.value[0]) & mask;
+	else
+		val = ((ucontrol->value.integer.value[0] + min) & mask);
 	val_mask = mask << shift;
 	val = val << shift;
 
@@ -3030,9 +3031,10 @@ int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
 		return ret;
 
 	if (snd_soc_volsw_is_stereo(mc)) {
-		val = ((ucontrol->value.integer.value[1] + min) & mask);
 		if (invert)
-			val = max - val;
+			val = (max - ucontrol->value.integer.value[1]) & mask;
+		else
+			val = ((ucontrol->value.integer.value[1] + min) & mask);
 		val_mask = mask << shift;
 		val = val << shift;
 
@@ -3077,8 +3079,9 @@ int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
 	if (invert)
 		ucontrol->value.integer.value[0] =
 			max - ucontrol->value.integer.value[0];
-	ucontrol->value.integer.value[0] =
-		ucontrol->value.integer.value[0] - min;
+	else
+		ucontrol->value.integer.value[0] =
+			ucontrol->value.integer.value[0] - min;
 
 	if (snd_soc_volsw_is_stereo(mc)) {
 		ret = snd_soc_component_read(component, rreg, &val);
@@ -3089,8 +3092,9 @@ int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
 		if (invert)
 			ucontrol->value.integer.value[1] =
 				max - ucontrol->value.integer.value[1];
-		ucontrol->value.integer.value[1] =
-			ucontrol->value.integer.value[1] - min;
+		else
+			ucontrol->value.integer.value[1] =
+				ucontrol->value.integer.value[1] - min;
 	}
 
 	return 0;

commit 8c8f2f6fc1c8eec9e14810f21386fe295a42a40f
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Sep 23 04:15:48 2014 +0200

    ASoC: Fix snd_soc_{new,free}_ac97_codec() locking removal
    
    Commit e3f205a72c45 ("ASoC: Remove locking in
    snd_soc_{new,free}_ac97_codec()") overlooked a unlock on one of the error
    paths.
    
    Fixes: e3f205a72c45 ("ASoC: Remove locking in snd_soc_{new,free}_ac97_codec()")
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a504cf42bf0a..3c57f5cf2779 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2115,7 +2115,6 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 	if (codec->ac97->bus == NULL) {
 		kfree(codec->ac97);
 		codec->ac97 = NULL;
-		mutex_unlock(&codec->mutex);
 		return -ENOMEM;
 	}
 

commit e3f205a72c4554b58f51d5afd98195c4ff54d215
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Sep 23 00:56:28 2014 +0200

    ASoC: Remove locking in snd_soc_{new,free}_ac97_codec()
    
    snd_soc_new_ac97_codec() and snd_soc_free_ac97_codec() are called from
    within a CODEC's probe() and remove() callbacks. Those will not run
    concurrently against each other for the same CODEC instance, hence it is not
    necessary to protect the two functions with a mutex.
    
    This removes the last user in the ASoC core of the snd_soc_codec mutex field
    and will allow us to eventually remove it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d4bfd4a9076f..a504cf42bf0a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2107,13 +2107,9 @@ static struct platform_driver soc_driver = {
 int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 	struct snd_ac97_bus_ops *ops, int num)
 {
-	mutex_lock(&codec->mutex);
-
 	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
-	if (codec->ac97 == NULL) {
-		mutex_unlock(&codec->mutex);
+	if (codec->ac97 == NULL)
 		return -ENOMEM;
-	}
 
 	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
 	if (codec->ac97->bus == NULL) {
@@ -2132,7 +2128,6 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 	 */
 	codec->ac97_created = 1;
 
-	mutex_unlock(&codec->mutex);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
@@ -2302,7 +2297,6 @@ EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops_of_reset);
  */
 void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 {
-	mutex_lock(&codec->mutex);
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	soc_unregister_ac97_codec(codec);
 #endif
@@ -2310,7 +2304,6 @@ void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 	kfree(codec->ac97);
 	codec->ac97 = NULL;
 	codec->ac97_created = 0;
-	mutex_unlock(&codec->mutex);
 }
 EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
 

commit 0634814fe0f29a46c44386a03f259f99c983bf7e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Aug 20 13:08:49 2014 +0200

    ASoC: Remove table based DAPM/control setup support from snd_soc_platform_driver
    
    There are no users left and new users should rather use the component_driver
    struct embedded in the snd_soc_platform_driver struct to do this. E.g.:
    
    static const struct snd_soc_platform_driver foobar_driver = {
            .component_driver = {
                    .dapm_widgets = ...,
                    .num_dapm_widgets = ...,
                    ...,
            },
            ...
    };
    
    instead of
    
    static const struct snd_soc_platform_driver foobar_driver = {
            .dapm_widgets = ...,
            .num_dapm_widgets = ...,
            ...
    };
    
    This also allows us to remove the steal_sibling_dai_widgets hack.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1b422c5c36c8..052f59c1917f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1087,7 +1087,6 @@ static int soc_probe_component(struct snd_soc_card *card,
 	struct snd_soc_component *component)
 {
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
-	struct snd_soc_component *dai_component, *component2;
 	struct snd_soc_dai *dai;
 	int ret;
 
@@ -1114,44 +1113,12 @@ static int soc_probe_component(struct snd_soc_card *card,
 		}
 	}
 
-	/*
-	 * This is rather ugly, but certain platforms expect that the DAPM
-	 * widgets for the DAIs for components with the same parent device are
-	 * created in the platforms DAPM context. Until that is fixed we need to
-	 * keep this.
-	 */
-	if (component->steal_sibling_dai_widgets) {
-		dai_component = NULL;
-		list_for_each_entry(component2, &component_list, list) {
-			if (component == component2)
-				continue;
-
-			if (component2->dev == component->dev &&
-			    !list_empty(&component2->dai_list)) {
-				dai_component = component2;
-				break;
-			}
-		}
-	} else {
-		dai_component = component;
-		list_for_each_entry(component2, &component_list, list) {
-			if (component2->dev == component->dev &&
-			    component2->steal_sibling_dai_widgets) {
-				dai_component = NULL;
-				break;
-			}
-		}
-	}
-
-	if (dai_component) {
-		list_for_each_entry(dai, &dai_component->dai_list, list) {
-			snd_soc_dapm_new_dai_widgets(dapm, dai);
-			if (ret != 0) {
-				dev_err(component->dev,
-					"Failed to create DAI widgets %d\n",
-					ret);
-				goto err_probe;
-			}
+	list_for_each_entry(dai, &component->dai_list, list) {
+		ret = snd_soc_dapm_new_dai_widgets(dapm, dai);
+		if (ret != 0) {
+			dev_err(component->dev,
+				"Failed to create DAI widgets %d\n", ret);
+			goto err_probe;
 		}
 	}
 
@@ -4164,19 +4131,6 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 
 	platform->dev = dev;
 	platform->driver = platform_drv;
-	if (platform_drv->controls) {
-		platform->component.controls = platform_drv->controls;
-		platform->component.num_controls = platform_drv->num_controls;
-	}
-	if (platform_drv->dapm_widgets) {
-		platform->component.dapm_widgets = platform_drv->dapm_widgets;
-		platform->component.num_dapm_widgets = platform_drv->num_dapm_widgets;
-		platform->component.steal_sibling_dai_widgets = true;
-	}
-	if (platform_drv->dapm_routes) {
-		platform->component.dapm_routes = platform_drv->dapm_routes;
-		platform->component.num_dapm_routes = platform_drv->num_dapm_routes;
-	}
 
 	if (platform_drv->probe)
 		platform->component.probe = snd_soc_platform_drv_probe;

commit a80932979a72ef9d4e66a69520c7588cc6de5699
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Sep 4 19:44:07 2014 +0200

    ASoC: Always run default suspend/resume code
    
    We do a bit more than just running the callbacks during suspend and resume
    these days (e.g. call regcache_mark_dirty() during suspend). But this is
    only when suspend and resume callbacks are specified for the driver,
    otherwise nothing is done. This means that drivers which don't want to do
    anything special during suspend and resume, but still want the standard
    operations to run, need to provide empty suspend and resume callback
    functions (rather than no callbacks). This patch updates the suspend and
    resume code to always run standard sequence regardless of whether suspend
    and resume handlers are provided.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2bdf9a4ac2b4..c612900c80ff 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -637,7 +637,7 @@ int snd_soc_suspend(struct device *dev)
 	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
 		/* If there are paths active then the CODEC will be held with
 		 * bias _ON and should not be suspended. */
-		if (!codec->suspended && codec->driver->suspend) {
+		if (!codec->suspended) {
 			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
 				/*
@@ -651,8 +651,10 @@ int snd_soc_suspend(struct device *dev)
 						"ASoC: idle_bias_off CODEC on over suspend\n");
 					break;
 				}
+
 			case SND_SOC_BIAS_OFF:
-				codec->driver->suspend(codec);
+				if (codec->driver->suspend)
+					codec->driver->suspend(codec);
 				codec->suspended = 1;
 				codec->cache_sync = 1;
 				if (codec->component.regmap)
@@ -726,11 +728,12 @@ static void soc_resume_deferred(struct work_struct *work)
 		 * left with bias OFF or STANDBY and suspended so we must now
 		 * resume.  Otherwise the suspend was suppressed.
 		 */
-		if (codec->driver->resume && codec->suspended) {
+		if (codec->suspended) {
 			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
 			case SND_SOC_BIAS_OFF:
-				codec->driver->resume(codec);
+				if (codec->driver->resume)
+					codec->driver->resume(codec);
 				codec->suspended = 0;
 				break;
 			default:

commit 86dbf2ac6fcb2d2932d4610f2dfe0954aa0633f7
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Sep 4 19:44:06 2014 +0200

    ASoC: Add support for automatically going to BIAS_OFF on suspend
    
    There is a substantial amount of drivers that in go to SND_SOC_BIAS_OFF on
    suspend and go back to SND_SOC_BIAS_SUSPEND on resume (Often this is even
    the only thing done in the suspend and resume handlers). This patch
    introduces a new suspend_bias_off flag, which when set by a driver will let
    the ASoC core automatically put the device's DAPM context at the
    SND_SOC_BIAS_OFF level during suspend. Once the device is resumed the DAPM
    context will go back to SND_SOC_BIAS_STANDBY (if the context is idle,
    otherwise to SND_SOC_BIAS_ON).
    
    This will allow us to remove a fair bit of duplicated code from the drivers.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 068785fa1a06..2bdf9a4ac2b4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4402,6 +4402,7 @@ int snd_soc_register_codec(struct device *dev,
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 	codec->dapm.codec = codec;
 	codec->dapm.idle_bias_off = codec_drv->idle_bias_off;
+	codec->dapm.suspend_bias_off = codec_drv->suspend_bias_off;
 	if (codec_drv->seq_notifier)
 		codec->dapm.seq_notifier = codec_drv->seq_notifier;
 	if (codec_drv->set_bias_level)

commit 1c325f771a88579f227fe017e4ee77d852cf5435
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Sep 4 19:44:05 2014 +0200

    ASoC: Shutdown DAPM contexts when removing a card
    
    Currently when a ASoC sound card is unregistered we leave the individual
    components in their current state, just call the remove() callback and leave
    it to the drivers to do the proper shutdown/cleanup.
    
    This patch introduces a call to snd_soc_dapm_shutdown() when removing the
    card.  This will make sure that all DAPM widgets are properly powered down
    and all DAPM contexts are put at the SND_SOC_BIAS_OFF level. This will
    ensure that all components are properly powered down when the card is
    removed.
    
    Since a lot of drivers manually go to SND_SOC_BIAS_OFF in their remove
    callback this will also allow us to remove a bit of duplicated code.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ff9d2892f473..068785fa1a06 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3812,6 +3812,7 @@ int snd_soc_unregister_card(struct snd_soc_card *card)
 {
 	if (card->instantiated) {
 		card->instantiated = false;
+		snd_soc_dapm_shutdown(card);
 		soc_cleanup_card_resources(card);
 	}
 	dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);

commit 01e0df6647e713469466c7bb6d7157c2e3046192
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Sep 4 19:44:04 2014 +0200

    ASoC: Set card->instantiated to false when removing the card
    
    Set card->instantiated to false when the card is removed to make sure that
    operations that expect the card to be fully instantiated do not run anymore
    during card removal.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1b422c5c36c8..ff9d2892f473 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3810,8 +3810,10 @@ EXPORT_SYMBOL_GPL(snd_soc_register_card);
  */
 int snd_soc_unregister_card(struct snd_soc_card *card)
 {
-	if (card->instantiated)
+	if (card->instantiated) {
+		card->instantiated = false;
 		soc_cleanup_card_resources(card);
+	}
 	dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 
 	return 0;

commit b792346fa8660a22a06f118cebe47709f507914f
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Aug 28 14:07:11 2014 +0300

    ASoC: Remove unused cache_only from struct snd_soc_codec
    
    There are no real users for cache_only in "struct snd_soc_codec" so remove
    it and needless debugfs node.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 419682693886..1b422c5c36c8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -311,8 +311,6 @@ static void soc_init_codec_debugfs(struct snd_soc_component *component)
 
 	debugfs_create_bool("cache_sync", 0444, codec->component.debugfs_root,
 			    &codec->cache_sync);
-	debugfs_create_bool("cache_only", 0444, codec->component.debugfs_root,
-			    &codec->cache_only);
 
 	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
 						 codec->component.debugfs_root,

commit 5819c2fa55d4a6eaf7fe025a393dce98fc4b2116
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Aug 24 15:36:55 2014 +0200

    ASoC: Restore idle_bias_off initialization
    
    This was accidentally lost in commit f1d45cc3ae96 ("ASoC: Consolidate
    platform and CODEC probe/remove").
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c36983a133fa..419682693886 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4010,6 +4010,7 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	dapm->dev = dev;
 	dapm->component = component;
 	dapm->bias_level = SND_SOC_BIAS_OFF;
+	dapm->idle_bias_off = true;
 	if (driver->seq_notifier)
 		dapm->seq_notifier = snd_soc_component_seq_notifier;
 	if (driver->stream_event)
@@ -4399,6 +4400,7 @@ int snd_soc_register_codec(struct device *dev,
 		codec->component.read = snd_soc_codec_drv_read;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 	codec->dapm.codec = codec;
+	codec->dapm.idle_bias_off = codec_drv->idle_bias_off;
 	if (codec_drv->seq_notifier)
 		codec->dapm.seq_notifier = codec_drv->seq_notifier;
 	if (codec_drv->set_bias_level)

commit c5599b87a8317738a541d8893cb327df5d04b007
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:30 2014 +0200

    ASoC: Replace list_empty(&card->codec_dev_list) with !card->instantiated
    
    With componentization we no longer necessarily need a snd_soc_codec struct for a
    card. Instead of checking if the card's CODEC list is empty just use
    card->instantiated to check if the card has been instantiated yet.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2d7a9ecbb0e3..c36983a133fa 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -552,10 +552,8 @@ int snd_soc_suspend(struct device *dev)
 	struct snd_soc_codec *codec;
 	int i, j;
 
-	/* If the initialization of this soc device failed, there is no codec
-	 * associated with it. Just bail out in this case.
-	 */
-	if (list_empty(&card->codec_dev_list))
+	/* If the card is not initialized yet there is nothing to do */
+	if (!card->instantiated)
 		return 0;
 
 	/* Due to the resume being scheduled into a workqueue we could
@@ -808,10 +806,8 @@ int snd_soc_resume(struct device *dev)
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	int i, ac97_control = 0;
 
-	/* If the initialization of this soc device failed, there is no codec
-	 * associated with it. Just bail out in this case.
-	 */
-	if (list_empty(&card->codec_dev_list))
+	/* If the card is not initialized yet there is nothing to do */
+	if (!card->instantiated)
 		return 0;
 
 	/* activate pins from sleep state */

commit 75af7c081982d76cef0daf26e96b5d1e8cb9d631
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:29 2014 +0200

    ASoC: Remove support for legacy snd_soc_platform IO
    
    There were never any actual users of this in upstream and by we have with
    regmap a replacement in place, which should be used by new drivers.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 96f286643ca1..2d7a9ecbb0e3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4151,24 +4151,6 @@ static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
 	platform->driver->remove(platform);
 }
 
-static int snd_soc_platform_drv_write(struct snd_soc_component *component,
-	unsigned int reg, unsigned int val)
-{
-	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
-
-	return platform->driver->write(platform, reg, val);
-}
-
-static int snd_soc_platform_drv_read(struct snd_soc_component *component,
-	unsigned int reg, unsigned int *val)
-{
-	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
-
-	*val = platform->driver->read(platform, reg);
-
-	return 0;
-}
-
 /**
  * snd_soc_add_platform - Add a platform to the ASoC core
  * @dev: The parent device for the platform
@@ -4205,10 +4187,6 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 		platform->component.probe = snd_soc_platform_drv_probe;
 	if (platform_drv->remove)
 		platform->component.remove = snd_soc_platform_drv_remove;
-	if (platform_drv->write)
-		platform->component.write = snd_soc_platform_drv_write;
-	if (platform_drv->read)
-		platform->component.read = snd_soc_platform_drv_read;
 
 #ifdef CONFIG_DEBUG_FS
 	platform->component.debugfs_prefix = "platform";

commit 886f5692253de1a9509f5cb708432b2157afb57c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:28 2014 +0200

    ASoC: Automatically initialize regmap for all components
    
    So far regmap is only automatically initialized for CODECs. Now that we have the
    infrastructure in place to let components have DAPM widgets and controls that
    want to use the generic regmap based IO also make sure to automatically
    initialize regmap for all components.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 140f43f91635..96f286643ca1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4032,8 +4032,23 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	return 0;
 }
 
+static void snd_soc_component_init_regmap(struct snd_soc_component *component)
+{
+	if (!component->regmap)
+		component->regmap = dev_get_regmap(component->dev, NULL);
+	if (component->regmap) {
+		int val_bytes = regmap_get_val_bytes(component->regmap);
+		/* Errors are legitimate for non-integer byte multiples */
+		if (val_bytes > 0)
+			component->val_bytes = val_bytes;
+	}
+}
+
 static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
 {
+	if (!component->write && !component->read)
+		snd_soc_component_init_regmap(component);
+
 	list_add(&component->list, &component_list);
 }
 
@@ -4371,7 +4386,6 @@ int snd_soc_register_codec(struct device *dev,
 {
 	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
-	struct regmap *regmap;
 	int ret, i;
 
 	dev_dbg(dev, "codec register %s\n", dev_name(dev));
@@ -4425,23 +4439,8 @@ int snd_soc_register_codec(struct device *dev,
 	codec->component.debugfs_prefix = "codec";
 #endif
 
-	if (!codec->component.write) {
-		if (codec_drv->get_regmap)
-			regmap = codec_drv->get_regmap(dev);
-		else
-			regmap = dev_get_regmap(dev, NULL);
-
-		if (regmap) {
-			ret = snd_soc_component_init_io(&codec->component,
-				regmap);
-			if (ret) {
-				dev_err(codec->dev,
-						"Failed to set cache I/O:%d\n",
-						ret);
-				goto err_cleanup;
-			}
-		}
-	}
+	if (codec_drv->get_regmap)
+		codec->component.regmap = codec_drv->get_regmap(dev);
 
 	for (i = 0; i < num_dai; i++) {
 		fixup_codec_formats(&dai_drv[i].playback);

commit 14621c7e5e72200ec021a7580121130ce7f2ff22
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:27 2014 +0200

    ASoC: Consolidate CPU and CODEC DAI lookup
    
    The lookup of CPU and CODEC DAIs is fairly similar and can easily be
    consolidated into a single helper function.
    
    There are two main differences in the current implementation of the CPU and
    CODEC DAI lookup:
     1) CPU DAIs can be looked up by the DAI name alone and do not necessarily
       require a component name/of_node.
     2) The CODEC DAI search only considers DAIs from CODEC components.
    
    For 1) the new helper function will allow to lookup DAIs without providing a
    component name or of_node, but since snd_soc_register_card() already rejects
    CODEC DAI link components without neither a of_node or a name we'll never get
    into the situation where we try to lookup a CODEC DAI without a name/of_node.
    For 2) the new helper function just always considers all components.
    Componentization is now at a point where it is possible to register a CODEC as a
    snd_soc_component rather than a snd_soc_codec, by considering DAIs from all
    components it is possible to use such a CODEC in a DAI link.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5f6f97874ca2..140f43f91635 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -877,35 +877,23 @@ static struct snd_soc_component *soc_find_component(
 	return NULL;
 }
 
-static struct snd_soc_codec *soc_find_codec(
-					const struct device_node *codec_of_node,
-					const char *codec_name)
+static struct snd_soc_dai *snd_soc_find_dai(
+	const struct snd_soc_dai_link_component *dlc)
 {
-	struct snd_soc_codec *codec;
+	struct snd_soc_component *component;
+	struct snd_soc_dai *dai;
 
-	list_for_each_entry(codec, &codec_list, list) {
-		if (codec_of_node) {
-			if (codec->dev->of_node != codec_of_node)
-				continue;
-		} else {
-			if (strcmp(codec->component.name, codec_name))
+	/* Find CPU DAI from registered DAIs*/
+	list_for_each_entry(component, &component_list, list) {
+		if (dlc->of_node && component->dev->of_node != dlc->of_node)
+			continue;
+		if (dlc->name && strcmp(dev_name(component->dev), dlc->name))
+			continue;
+		list_for_each_entry(dai, &component->dai_list, list) {
+			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name))
 				continue;
-		}
-
-		return codec;
-	}
-
-	return NULL;
-}
-
-static struct snd_soc_dai *soc_find_codec_dai(struct snd_soc_codec *codec,
-					      const char *codec_dai_name)
-{
-	struct snd_soc_dai *codec_dai;
 
-	list_for_each_entry(codec_dai, &codec->component.dai_list, list) {
-		if (!strcmp(codec_dai->name, codec_dai_name)) {
-			return codec_dai;
+			return dai;
 		}
 	}
 
@@ -916,33 +904,19 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	struct snd_soc_component *component;
 	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
+	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_dai **codec_dais = rtd->codec_dais;
 	struct snd_soc_platform *platform;
-	struct snd_soc_dai *cpu_dai;
 	const char *platform_name;
 	int i;
 
 	dev_dbg(card->dev, "ASoC: binding %s at idx %d\n", dai_link->name, num);
 
-	/* Find CPU DAI from registered DAIs*/
-	list_for_each_entry(component, &component_list, list) {
-		if (dai_link->cpu_of_node &&
-			component->dev->of_node != dai_link->cpu_of_node)
-			continue;
-		if (dai_link->cpu_name &&
-			strcmp(dev_name(component->dev), dai_link->cpu_name))
-			continue;
-		list_for_each_entry(cpu_dai, &component->dai_list, list) {
-			if (dai_link->cpu_dai_name &&
-				strcmp(cpu_dai->name, dai_link->cpu_dai_name))
-				continue;
-
-			rtd->cpu_dai = cpu_dai;
-		}
-	}
-
+	cpu_dai_component.name = dai_link->cpu_name;
+	cpu_dai_component.of_node = dai_link->cpu_of_node;
+	cpu_dai_component.dai_name = dai_link->cpu_dai_name;
+	rtd->cpu_dai = snd_soc_find_dai(&cpu_dai_component);
 	if (!rtd->cpu_dai) {
 		dev_err(card->dev, "ASoC: CPU DAI %s not registered\n",
 			dai_link->cpu_dai_name);
@@ -953,15 +927,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 
 	/* Find CODEC from registered CODECs */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		struct snd_soc_codec *codec;
-		codec = soc_find_codec(codecs[i].of_node, codecs[i].name);
-		if (!codec) {
-			dev_err(card->dev, "ASoC: CODEC %s not registered\n",
-				codecs[i].name);
-			return -EPROBE_DEFER;
-		}
-
-		codec_dais[i] = soc_find_codec_dai(codec, codecs[i].dai_name);
+		codec_dais[i] = snd_soc_find_dai(&codecs[i]);
 		if (!codec_dais[i]) {
 			dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
 				codecs[i].dai_name);

commit e60cd14f0bf6c004cd7032a24a036ba32d56e08a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:26 2014 +0200

    ASoC: Consolidate CPU and CODEC DAI removal
    
    CPU and CODEC DAI works exactly the same way. There is already a helper function
    for CODEC DAI removal, use that one as well for CPU DAI removal.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4dc2876c06de..5f6f97874ca2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1021,28 +1021,27 @@ static void soc_remove_component(struct snd_soc_component *component)
 	module_put(component->dev->driver->owner);
 }
 
-static void soc_remove_codec_dai(struct snd_soc_dai *codec_dai, int order)
+static void soc_remove_dai(struct snd_soc_dai *dai, int order)
 {
 	int err;
 
-	if (codec_dai && codec_dai->probed &&
-			codec_dai->driver->remove_order == order) {
-		if (codec_dai->driver->remove) {
-			err = codec_dai->driver->remove(codec_dai);
+	if (dai && dai->probed &&
+			dai->driver->remove_order == order) {
+		if (dai->driver->remove) {
+			err = dai->driver->remove(dai);
 			if (err < 0)
-				dev_err(codec_dai->dev,
+				dev_err(dai->dev,
 					"ASoC: failed to remove %s: %d\n",
-					codec_dai->name, err);
+					dai->name, err);
 		}
-		codec_dai->probed = 0;
+		dai->probed = 0;
 	}
 }
 
 static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	int i, err;
+	int i;
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
@@ -1054,20 +1053,9 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 
 	/* remove the CODEC DAI */
 	for (i = 0; i < rtd->num_codecs; i++)
-		soc_remove_codec_dai(rtd->codec_dais[i], order);
+		soc_remove_dai(rtd->codec_dais[i], order);
 
-	/* remove the cpu_dai */
-	if (cpu_dai && cpu_dai->probed &&
-			cpu_dai->driver->remove_order == order) {
-		if (cpu_dai->driver->remove) {
-			err = cpu_dai->driver->remove(cpu_dai);
-			if (err < 0)
-				dev_err(cpu_dai->dev,
-					"ASoC: failed to remove %s: %d\n",
-					cpu_dai->name, err);
-		}
-		cpu_dai->probed = 0;
-	}
+	soc_remove_dai(rtd->cpu_dai, order);
 }
 
 static void soc_remove_link_components(struct snd_soc_card *card, int num,

commit ffbd7dd72bd3ad9bcae9190788c858e57f1e8e4e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:25 2014 +0200

    ASoC: Cleanup DAI module reference counting
    
    Currently when a DAI has no CODEC associated to it the reference on the module
    containing the DAI driver is increased when the DAI is probed and decrease when
    the DAI is removed. For DAIs with CODECs the module reference count was already
    incremented when the CODEC is probed. Now that all components have their module
    reference count incremented when they are probed and all DAIs do have a
    component it is possible to remove the module reference counting on DAI probe
    and removal.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2fbfbfca48dc..4dc2876c06de 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1067,8 +1067,6 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 					cpu_dai->name, err);
 		}
 		cpu_dai->probed = 0;
-		if (!cpu_dai->codec)
-			module_put(cpu_dai->dev->driver->owner);
 	}
 }
 
@@ -1422,18 +1420,12 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	/* probe the cpu_dai */
 	if (!cpu_dai->probed &&
 			cpu_dai->driver->probe_order == order) {
-		if (!cpu_dai->codec) {
-			if (!try_module_get(cpu_dai->dev->driver->owner))
-				return -ENODEV;
-		}
-
 		if (cpu_dai->driver->probe) {
 			ret = cpu_dai->driver->probe(cpu_dai);
 			if (ret < 0) {
 				dev_err(cpu_dai->dev,
 					"ASoC: failed to probe CPU DAI %s: %d\n",
 					cpu_dai->name, ret);
-				module_put(cpu_dai->dev->driver->owner);
 				return ret;
 			}
 		}

commit 70090bbb8b7d7da7a6f64969b43a61c493c560ff
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:24 2014 +0200

    ASoC: Move component->probed check into soc_{remove,probe}_component()
    
    Having the check in a centralized place makes the code a bit cleaner and
    shorter.
    
    Note: There is a slight semantic change in this patch. soc_probe_aux_dev() will
    no longer return -EBUSY if the AUX dev has already been probed before. This is
    fine though since it will simply do nothing in that case and return success.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4393bc33d3af..2fbfbfca48dc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1004,6 +1004,9 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 
 static void soc_remove_component(struct snd_soc_component *component)
 {
+	if (!component->probed)
+		return;
+
 	/* This is a HACK and will be removed soon */
 	if (component->codec)
 		list_del(&component->codec->card_list);
@@ -1079,22 +1082,19 @@ static void soc_remove_link_components(struct snd_soc_card *card, int num,
 	int i;
 
 	/* remove the platform */
-	if (platform && platform->component.probed &&
-	    platform->component.driver->remove_order == order)
+	if (platform && platform->component.driver->remove_order == order)
 		soc_remove_component(&platform->component);
 
 	/* remove the CODEC-side CODEC */
 	for (i = 0; i < rtd->num_codecs; i++) {
 		component = rtd->codec_dais[i]->component;
-		if (component->probed &&
-		    component->driver->remove_order == order)
+		if (component->driver->remove_order == order)
 			soc_remove_component(component);
 	}
 
 	/* remove any CPU-side CODEC */
 	if (cpu_dai) {
-		if (cpu_dai->component->probed &&
-		    cpu_dai->component->driver->remove_order == order)
+		if (cpu_dai->component->driver->remove_order == order)
 			soc_remove_component(cpu_dai->component);
 	}
 }
@@ -1145,6 +1145,9 @@ static int soc_probe_component(struct snd_soc_card *card,
 	struct snd_soc_dai *dai;
 	int ret;
 
+	if (component->probed)
+		return 0;
+
 	component->card = card;
 	dapm->card = card;
 	soc_set_name_prefix(card, component);
@@ -1306,8 +1309,7 @@ static int soc_probe_link_components(struct snd_soc_card *card, int num,
 
 	/* probe the CPU-side component, if it is a CODEC */
 	component = rtd->cpu_dai->component;
-	if (!component->probed &&
-	    component->driver->probe_order == order) {
+	if (component->driver->probe_order == order) {
 		ret = soc_probe_component(card, component);
 		if (ret < 0)
 			return ret;
@@ -1316,8 +1318,7 @@ static int soc_probe_link_components(struct snd_soc_card *card, int num,
 	/* probe the CODEC-side components */
 	for (i = 0; i < rtd->num_codecs; i++) {
 		component = rtd->codec_dais[i]->component;
-		if (!component->probed &&
-		    component->driver->probe_order == order) {
+		if (component->driver->probe_order == order) {
 			ret = soc_probe_component(card, component);
 			if (ret < 0)
 				return ret;
@@ -1325,8 +1326,7 @@ static int soc_probe_link_components(struct snd_soc_card *card, int num,
 	}
 
 	/* probe the platform */
-	if (!platform->component.probed &&
-	    platform->component.driver->probe_order == order) {
+	if (platform->component.driver->probe_order == order) {
 		ret = soc_probe_component(card, &platform->component);
 		if (ret < 0)
 			return ret;
@@ -1621,11 +1621,6 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	int ret;
 
-	if (rtd->component->probed) {
-		dev_err(rtd->dev, "ASoC: codec already probed\n");
-		return -EBUSY;
-	}
-
 	ret = soc_probe_component(card, rtd->component);
 	if (ret < 0)
 		return ret;

commit 57bf772687700e206c760ba2e4097f78bde97887
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:23 2014 +0200

    ASoC: Pass component instead of DAPM context to AUX dev init callback
    
    Given that the component is the containing structure it makes more sense to pass
    the component rather than the DAPM context to the AUX dev init callback.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 08c04f4c7e62..4393bc33d3af 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1632,7 +1632,7 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 
 	/* do machine specific initialization */
 	if (aux_dev->init) {
-		ret = aux_dev->init(snd_soc_component_get_dapm(rtd->component));
+		ret = aux_dev->init(rtd->component);
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
 				aux_dev->name, ret);

commit 65d9361f0cb50a20641802ee3075145d72e4409c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:22 2014 +0200

    ASoC: Move AUX dev support to the component level
    
    This patch makes it possible to register arbitrary components as a AUX dev
    for a card. This was previously only possible for CODEC components. With
    componentization having made it possible for components to have DAPM contexts
    and controls there is no reason why AUX devs should be artificially limited to
    snd_soc_codec devices.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 08fd85e8c751..08c04f4c7e62 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -860,6 +860,23 @@ EXPORT_SYMBOL_GPL(snd_soc_resume);
 static const struct snd_soc_dai_ops null_dai_ops = {
 };
 
+static struct snd_soc_component *soc_find_component(
+	const struct device_node *of_node, const char *name)
+{
+	struct snd_soc_component *component;
+
+	list_for_each_entry(component, &component_list, list) {
+		if (of_node) {
+			if (component->dev->of_node == of_node)
+				return component;
+		} else if (strcmp(component->name, name) == 0) {
+			return component;
+		}
+	}
+
+	return NULL;
+}
+
 static struct snd_soc_codec *soc_find_codec(
 					const struct device_node *codec_of_node,
 					const char *codec_name)
@@ -1577,17 +1594,24 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
-	const char *codecname = aux_dev->codec_name;
+	const char *name = aux_dev->codec_name;
 
-	rtd->codec = soc_find_codec(aux_dev->codec_of_node, codecname);
-	if (!rtd->codec) {
+	rtd->component = soc_find_component(aux_dev->codec_of_node, name);
+	if (!rtd->component) {
 		if (aux_dev->codec_of_node)
-			codecname = of_node_full_name(aux_dev->codec_of_node);
+			name = of_node_full_name(aux_dev->codec_of_node);
 
-		dev_err(card->dev, "ASoC: %s not registered\n", codecname);
+		dev_err(card->dev, "ASoC: %s not registered\n", name);
 		return -EPROBE_DEFER;
 	}
 
+	/*
+	 * Some places still reference rtd->codec, so we have to keep that
+	 * initialized if the component is a CODEC. Once all those references
+	 * have been removed, this code can be removed as well.
+	 */
+	 rtd->codec = rtd->component->codec;
+
 	return 0;
 }
 
@@ -1597,18 +1621,18 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	int ret;
 
-	if (rtd->codec->component.probed) {
-		dev_err(rtd->codec->dev, "ASoC: codec already probed\n");
+	if (rtd->component->probed) {
+		dev_err(rtd->dev, "ASoC: codec already probed\n");
 		return -EBUSY;
 	}
 
-	ret = soc_probe_component(card, &rtd->codec->component);
+	ret = soc_probe_component(card, rtd->component);
 	if (ret < 0)
 		return ret;
 
 	/* do machine specific initialization */
 	if (aux_dev->init) {
-		ret = aux_dev->init(&rtd->codec->dapm);
+		ret = aux_dev->init(snd_soc_component_get_dapm(rtd->component));
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
 				aux_dev->name, ret);
@@ -1622,7 +1646,7 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
-	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_component *component = rtd->component;
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
@@ -1631,8 +1655,8 @@ static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 		rtd->dev_registered = 0;
 	}
 
-	if (codec && codec->component.probed)
-		soc_remove_component(&codec->component);
+	if (component && component->probed)
+		soc_remove_component(component);
 }
 
 static int snd_soc_init_codec_cache(struct snd_soc_codec *codec)

commit 61aca5646b736a794d40de29a197144db3f0c5ba
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:21 2014 +0200

    ASoC: Add component level probe/remove support
    
    Now that we have a unified probe and remove path make sure to call them for all
    components. soc_{probe,remove}_component are responsible for setting up the DAPM
    context for the component, initialize the component prefix, manage the debugfs
    entries as well as do the registration of table based controls and DAPM
    elements. They also call the component drivers probe and remove callbacks. This
    patch makes these things available for generic snd_soc_component drivers rather
    than only having them for snd_soc_codec and snd_soc_platform drivers.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1c705c28389c..08fd85e8c751 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1058,7 +1058,7 @@ static void soc_remove_link_components(struct snd_soc_card *card, int num,
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_codec *codec;
+	struct snd_soc_component *component;
 	int i;
 
 	/* remove the platform */
@@ -1068,18 +1068,17 @@ static void soc_remove_link_components(struct snd_soc_card *card, int num,
 
 	/* remove the CODEC-side CODEC */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		codec = rtd->codec_dais[i]->codec;
-		if (codec && codec->component.probed &&
-		    codec->component.driver->remove_order == order)
-			soc_remove_component(&codec->component);
+		component = rtd->codec_dais[i]->component;
+		if (component->probed &&
+		    component->driver->remove_order == order)
+			soc_remove_component(component);
 	}
 
 	/* remove any CPU-side CODEC */
 	if (cpu_dai) {
-		codec = cpu_dai->codec;
-		if (codec && codec->component.probed &&
-		    codec->component.driver->remove_order == order)
-			soc_remove_component(&codec->component);
+		if (cpu_dai->component->probed &&
+		    cpu_dai->component->driver->remove_order == order)
+			soc_remove_component(cpu_dai->component);
 	}
 }
 
@@ -1289,19 +1288,17 @@ static int soc_probe_link_components(struct snd_soc_card *card, int num,
 	int i, ret;
 
 	/* probe the CPU-side component, if it is a CODEC */
-	if (rtd->cpu_dai->codec) {
-		component = &rtd->cpu_dai->codec->component;
-		if (!component->probed &&
-		    component->driver->probe_order == order) {
-			ret = soc_probe_component(card, component);
-			if (ret < 0)
-				return ret;
-		}
+	component = rtd->cpu_dai->component;
+	if (!component->probed &&
+	    component->driver->probe_order == order) {
+		ret = soc_probe_component(card, component);
+		if (ret < 0)
+			return ret;
 	}
 
 	/* probe the CODEC-side components */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		component = &rtd->codec_dais[i]->codec->component;
+		component = rtd->codec_dais[i]->component;
 		if (!component->probed &&
 		    component->driver->probe_order == order) {
 			ret = soc_probe_component(card, component);
@@ -4042,6 +4039,8 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 
 	component->dev = dev;
 	component->driver = driver;
+	component->probe = component->driver->probe;
+	component->remove = component->driver->remove;
 
 	if (!component->dapm_ptr)
 		component->dapm_ptr = &component->dapm;
@@ -4055,6 +4054,13 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	if (driver->stream_event)
 		dapm->stream_event = snd_soc_component_stream_event;
 
+	component->controls = driver->controls;
+	component->num_controls = driver->num_controls;
+	component->dapm_widgets = driver->dapm_widgets;
+	component->num_dapm_widgets = driver->num_dapm_widgets;
+	component->dapm_routes = driver->dapm_routes;
+	component->num_dapm_routes = driver->num_dapm_routes;
+
 	INIT_LIST_HEAD(&component->dai_list);
 	mutex_init(&component->io_mutex);
 

commit 93c3ce76ccced3a8718149e8734ccaa931e9a1f1
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:20 2014 +0200

    ASoC: Make rtd->codec optional
    
    There are some place in the ASoC core that expect rtd->codec to be non NULL
    (mainly CODEC specific sysfs files). With componentization going forward
    rtd->codec might be NULL in some cases. This patch prepares the core for this by
    not registering CODEC specific sysfs files if rtd->codec is NULL. sysfs file
    removal does not need to be conditionalized as it handles the removal of
    non-existing files just fine.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b833cc6fd86d..1c705c28389c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1261,17 +1261,21 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 	}
 	rtd->dev_registered = 1;
 
-	/* add DAPM sysfs entries for this codec */
-	ret = snd_soc_dapm_sys_add(rtd->dev);
-	if (ret < 0)
-		dev_err(rtd->dev,
-			"ASoC: failed to add codec dapm sysfs entries: %d\n", ret);
+	if (rtd->codec) {
+		/* add DAPM sysfs entries for this codec */
+		ret = snd_soc_dapm_sys_add(rtd->dev);
+		if (ret < 0)
+			dev_err(rtd->dev,
+				"ASoC: failed to add codec dapm sysfs entries: %d\n",
+				ret);
 
-	/* add codec sysfs entries */
-	ret = device_create_file(rtd->dev, &dev_attr_codec_reg);
-	if (ret < 0)
-		dev_err(rtd->dev,
-			"ASoC: failed to add codec sysfs files: %d\n", ret);
+		/* add codec sysfs entries */
+		ret = device_create_file(rtd->dev, &dev_attr_codec_reg);
+		if (ret < 0)
+			dev_err(rtd->dev,
+				"ASoC: failed to add codec sysfs files: %d\n",
+				ret);
+	}
 
 	return 0;
 }

commit f1d45cc3ae96a6173129b2c164c216272faa5fc0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:19 2014 +0200

    ASoC: Consolidate platform and CODEC probe/remove
    
    The platform and CODEC probe and remove code is now largely identical. This
    patch consolidates it at the component level.
    
    The resulting code is slightly larger due to all the boiler plate code setting
    up the indirection for the table based control and DAPM registration.  Once all
    drivers have been update to no longer use the snd_soc_codec_driver and
    snd_soc_platform_driver specific fields for this the indirection can be removed
    again.
    
    This patch contains two noteworthy hacks that are only meant to be temporary to
    be able to update drivers and the core in separate incremental patches.
    
    The first hack is related to that some DPCM platforms expect that the DAPM
    widgets for the DAIs of a snd_soc_component are created in the DAPM context of
    the snd_soc_platform that has the same parent device. For handling this the
    steal_sibling_dai_widgets attribute is introduced. It gets set for
    snd_soc_platforms that register DAPM elements. When creating the DAI widgets for
    a component this flag is checked and if it is found on one of the siblings the
    component will not create any DAI widgets in its own DAPM context. If the
    attribute is set on a platform it will look for siblings components and create
    DAI widgets for them in its own context. The fix for this will be to update
    the offending drivers to only register a single component rather than two.
    
    The second hack deals with the fact that the ASoC card suspend and resume code
    still needs a list of CODECs that have been registered for the card. To handle
    this the generic probe and remove path have a check to see if the component is
    CODEC and if yes add/remove it to the card's CODEC list. While it is possible to
    clean up the suspend/resume code to not need the CODEC list anymore this is a
    bit of a chicken and egg problem since it will become easier to clean up the
    suspend/resume code once there is a unified component layer.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 79371a77f324..b833cc6fd86d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -985,44 +985,20 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	return 0;
 }
 
-static int soc_remove_platform(struct snd_soc_platform *platform)
+static void soc_remove_component(struct snd_soc_component *component)
 {
-	int ret;
-
-	if (platform->driver->remove) {
-		ret = platform->driver->remove(platform);
-		if (ret < 0)
-			dev_err(platform->dev, "ASoC: failed to remove %d\n",
-				ret);
-	}
-
-	/* Make sure all DAPM widgets are freed */
-	snd_soc_dapm_free(&platform->component.dapm);
-
-	soc_cleanup_component_debugfs(&platform->component);
-	platform->probed = 0;
-	module_put(platform->dev->driver->owner);
-
-	return 0;
-}
-
-static void soc_remove_codec(struct snd_soc_codec *codec)
-{
-	int err;
+	/* This is a HACK and will be removed soon */
+	if (component->codec)
+		list_del(&component->codec->card_list);
 
-	if (codec->driver->remove) {
-		err = codec->driver->remove(codec);
-		if (err < 0)
-			dev_err(codec->dev, "ASoC: failed to remove %d\n", err);
-	}
+	if (component->remove)
+		component->remove(component);
 
-	/* Make sure all DAPM widgets are freed */
-	snd_soc_dapm_free(&codec->dapm);
+	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
 
-	soc_cleanup_component_debugfs(&codec->component);
-	codec->probed = 0;
-	list_del(&codec->card_list);
-	module_put(codec->dev->driver->owner);
+	soc_cleanup_component_debugfs(component);
+	component->probed = 0;
+	module_put(component->dev->driver->owner);
 }
 
 static void soc_remove_codec_dai(struct snd_soc_dai *codec_dai, int order)
@@ -1086,25 +1062,24 @@ static void soc_remove_link_components(struct snd_soc_card *card, int num,
 	int i;
 
 	/* remove the platform */
-	if (platform && platform->probed &&
-	    platform->driver->remove_order == order) {
-		soc_remove_platform(platform);
-	}
+	if (platform && platform->component.probed &&
+	    platform->component.driver->remove_order == order)
+		soc_remove_component(&platform->component);
 
 	/* remove the CODEC-side CODEC */
 	for (i = 0; i < rtd->num_codecs; i++) {
 		codec = rtd->codec_dais[i]->codec;
-		if (codec && codec->probed &&
-		    codec->driver->remove_order == order)
-			soc_remove_codec(codec);
+		if (codec && codec->component.probed &&
+		    codec->component.driver->remove_order == order)
+			soc_remove_component(&codec->component);
 	}
 
 	/* remove any CPU-side CODEC */
 	if (cpu_dai) {
 		codec = cpu_dai->codec;
-		if (codec && codec->probed &&
-		    codec->driver->remove_order == order)
-			soc_remove_codec(codec);
+		if (codec && codec->component.probed &&
+		    codec->component.driver->remove_order == order)
+			soc_remove_component(&codec->component);
 	}
 }
 
@@ -1146,137 +1121,108 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 	}
 }
 
-static int soc_probe_codec(struct snd_soc_card *card,
-			   struct snd_soc_codec *codec)
+static int soc_probe_component(struct snd_soc_card *card,
+	struct snd_soc_component *component)
 {
-	int ret = 0;
-	const struct snd_soc_codec_driver *driver = codec->driver;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct snd_soc_component *dai_component, *component2;
 	struct snd_soc_dai *dai;
+	int ret;
 
-	codec->component.card = card;
-	codec->dapm.card = card;
-	soc_set_name_prefix(card, &codec->component);
+	component->card = card;
+	dapm->card = card;
+	soc_set_name_prefix(card, component);
 
-	if (!try_module_get(codec->dev->driver->owner))
+	if (!try_module_get(component->dev->driver->owner))
 		return -ENODEV;
 
-	soc_init_component_debugfs(&codec->component);
+	soc_init_component_debugfs(component);
 
-	if (driver->dapm_widgets) {
-		ret = snd_soc_dapm_new_controls(&codec->dapm,
-						driver->dapm_widgets,
-					 	driver->num_dapm_widgets);
+	if (component->dapm_widgets) {
+		ret = snd_soc_dapm_new_controls(dapm, component->dapm_widgets,
+			component->num_dapm_widgets);
 
 		if (ret != 0) {
-			dev_err(codec->dev,
+			dev_err(component->dev,
 				"Failed to create new controls %d\n", ret);
 			goto err_probe;
 		}
 	}
 
-	/* Create DAPM widgets for each DAI stream */
-	list_for_each_entry(dai, &codec->component.dai_list, list) {
-		ret = snd_soc_dapm_new_dai_widgets(&codec->dapm, dai);
+	/*
+	 * This is rather ugly, but certain platforms expect that the DAPM
+	 * widgets for the DAIs for components with the same parent device are
+	 * created in the platforms DAPM context. Until that is fixed we need to
+	 * keep this.
+	 */
+	if (component->steal_sibling_dai_widgets) {
+		dai_component = NULL;
+		list_for_each_entry(component2, &component_list, list) {
+			if (component == component2)
+				continue;
 
-		if (ret != 0) {
-			dev_err(codec->dev,
-				"Failed to create DAI widgets %d\n", ret);
-			goto err_probe;
+			if (component2->dev == component->dev &&
+			    !list_empty(&component2->dai_list)) {
+				dai_component = component2;
+				break;
+			}
 		}
-	}
-
-	codec->dapm.idle_bias_off = driver->idle_bias_off;
-
-	if (driver->probe) {
-		ret = driver->probe(codec);
-		if (ret < 0) {
-			dev_err(codec->dev,
-				"ASoC: failed to probe CODEC %d\n", ret);
-			goto err_probe;
+	} else {
+		dai_component = component;
+		list_for_each_entry(component2, &component_list, list) {
+			if (component2->dev == component->dev &&
+			    component2->steal_sibling_dai_widgets) {
+				dai_component = NULL;
+				break;
+			}
 		}
-		WARN(codec->dapm.idle_bias_off &&
-			codec->dapm.bias_level != SND_SOC_BIAS_OFF,
-			"codec %s can not start from non-off bias with idle_bias_off==1\n",
-			codec->component.name);
 	}
 
-	if (driver->controls)
-		snd_soc_add_codec_controls(codec, driver->controls,
-				     driver->num_controls);
-	if (driver->dapm_routes)
-		snd_soc_dapm_add_routes(&codec->dapm, driver->dapm_routes,
-					driver->num_dapm_routes);
-
-	/* mark codec as probed and add to card codec list */
-	codec->probed = 1;
-	list_add(&codec->card_list, &card->codec_dev_list);
-	list_add(&codec->dapm.list, &card->dapm_list);
-
-	return 0;
-
-err_probe:
-	soc_cleanup_component_debugfs(&codec->component);
-	module_put(codec->dev->driver->owner);
-
-	return ret;
-}
-
-static int soc_probe_platform(struct snd_soc_card *card,
-			   struct snd_soc_platform *platform)
-{
-	int ret = 0;
-	const struct snd_soc_platform_driver *driver = platform->driver;
-	struct snd_soc_component *component;
-	struct snd_soc_dai *dai;
-
-	platform->component.card = card;
-	platform->component.dapm.card = card;
-
-	if (!try_module_get(platform->dev->driver->owner))
-		return -ENODEV;
-
-	soc_init_component_debugfs(&platform->component);
-
-	if (driver->dapm_widgets)
-		snd_soc_dapm_new_controls(&platform->component.dapm,
-			driver->dapm_widgets, driver->num_dapm_widgets);
-
-	/* Create DAPM widgets for each DAI stream */
-	list_for_each_entry(component, &component_list, list) {
-		if (component->dev != platform->dev)
-			continue;
-		list_for_each_entry(dai, &component->dai_list, list)
-			snd_soc_dapm_new_dai_widgets(&platform->component.dapm,
-				dai);
+	if (dai_component) {
+		list_for_each_entry(dai, &dai_component->dai_list, list) {
+			snd_soc_dapm_new_dai_widgets(dapm, dai);
+			if (ret != 0) {
+				dev_err(component->dev,
+					"Failed to create DAI widgets %d\n",
+					ret);
+				goto err_probe;
+			}
+		}
 	}
 
-	platform->component.dapm.idle_bias_off = 1;
-
-	if (driver->probe) {
-		ret = driver->probe(platform);
+	if (component->probe) {
+		ret = component->probe(component);
 		if (ret < 0) {
-			dev_err(platform->dev,
-				"ASoC: failed to probe platform %d\n", ret);
+			dev_err(component->dev,
+				"ASoC: failed to probe component %d\n", ret);
 			goto err_probe;
 		}
+
+		WARN(dapm->idle_bias_off &&
+			dapm->bias_level != SND_SOC_BIAS_OFF,
+			"codec %s can not start from non-off bias with idle_bias_off==1\n",
+			component->name);
 	}
 
-	if (driver->controls)
-		snd_soc_add_platform_controls(platform, driver->controls,
-				     driver->num_controls);
-	if (driver->dapm_routes)
-		snd_soc_dapm_add_routes(&platform->component.dapm,
-			driver->dapm_routes, driver->num_dapm_routes);
+	if (component->controls)
+		snd_soc_add_component_controls(component, component->controls,
+				     component->num_controls);
+	if (component->dapm_routes)
+		snd_soc_dapm_add_routes(dapm, component->dapm_routes,
+					component->num_dapm_routes);
 
-	/* mark platform as probed and add to card platform list */
-	platform->probed = 1;
-	list_add(&platform->component.dapm.list, &card->dapm_list);
+	component->probed = 1;
+	list_add(&dapm->list, &card->dapm_list);
+
+	/* This is a HACK and will be removed soon */
+	if (component->codec)
+		list_add(&component->codec->card_list, &card->codec_dev_list);
 
 	return 0;
 
 err_probe:
-	soc_cleanup_component_debugfs(&platform->component);
-	module_put(platform->dev->driver->owner);
+	soc_cleanup_component_debugfs(component);
+	module_put(component->dev->driver->owner);
 
 	return ret;
 }
@@ -1334,33 +1280,36 @@ static int soc_probe_link_components(struct snd_soc_card *card, int num,
 				     int order)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_component *component;
 	int i, ret;
 
 	/* probe the CPU-side component, if it is a CODEC */
-	if (cpu_dai->codec &&
-	    !cpu_dai->codec->probed &&
-	    cpu_dai->codec->driver->probe_order == order) {
-		ret = soc_probe_codec(card, cpu_dai->codec);
-		if (ret < 0)
-			return ret;
+	if (rtd->cpu_dai->codec) {
+		component = &rtd->cpu_dai->codec->component;
+		if (!component->probed &&
+		    component->driver->probe_order == order) {
+			ret = soc_probe_component(card, component);
+			if (ret < 0)
+				return ret;
+		}
 	}
 
 	/* probe the CODEC-side components */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		if (!rtd->codec_dais[i]->codec->probed &&
-		    rtd->codec_dais[i]->codec->driver->probe_order == order) {
-			ret = soc_probe_codec(card, rtd->codec_dais[i]->codec);
+		component = &rtd->codec_dais[i]->codec->component;
+		if (!component->probed &&
+		    component->driver->probe_order == order) {
+			ret = soc_probe_component(card, component);
 			if (ret < 0)
 				return ret;
 		}
 	}
 
 	/* probe the platform */
-	if (!platform->probed &&
-	    platform->driver->probe_order == order) {
-		ret = soc_probe_platform(card, platform);
+	if (!platform->component.probed &&
+	    platform->component.driver->probe_order == order) {
+		ret = soc_probe_component(card, &platform->component);
 		if (ret < 0)
 			return ret;
 	}
@@ -1647,12 +1596,12 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	int ret;
 
-	if (rtd->codec->probed) {
+	if (rtd->codec->component.probed) {
 		dev_err(rtd->codec->dev, "ASoC: codec already probed\n");
 		return -EBUSY;
 	}
 
-	ret = soc_probe_codec(card, rtd->codec);
+	ret = soc_probe_component(card, &rtd->codec->component);
 	if (ret < 0)
 		return ret;
 
@@ -1681,8 +1630,8 @@ static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 		rtd->dev_registered = 0;
 	}
 
-	if (codec && codec->probed)
-		soc_remove_codec(codec);
+	if (codec && codec->component.probed)
+		soc_remove_component(&codec->component);
 }
 
 static int snd_soc_init_codec_cache(struct snd_soc_codec *codec)
@@ -4198,6 +4147,20 @@ void snd_soc_unregister_component(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
+static int snd_soc_platform_drv_probe(struct snd_soc_component *component)
+{
+	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
+
+	return platform->driver->probe(platform);
+}
+
+static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
+{
+	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
+
+	platform->driver->remove(platform);
+}
+
 static int snd_soc_platform_drv_write(struct snd_soc_component *component,
 	unsigned int reg, unsigned int val)
 {
@@ -4234,6 +4197,24 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 
 	platform->dev = dev;
 	platform->driver = platform_drv;
+	if (platform_drv->controls) {
+		platform->component.controls = platform_drv->controls;
+		platform->component.num_controls = platform_drv->num_controls;
+	}
+	if (platform_drv->dapm_widgets) {
+		platform->component.dapm_widgets = platform_drv->dapm_widgets;
+		platform->component.num_dapm_widgets = platform_drv->num_dapm_widgets;
+		platform->component.steal_sibling_dai_widgets = true;
+	}
+	if (platform_drv->dapm_routes) {
+		platform->component.dapm_routes = platform_drv->dapm_routes;
+		platform->component.num_dapm_routes = platform_drv->num_dapm_routes;
+	}
+
+	if (platform_drv->probe)
+		platform->component.probe = snd_soc_platform_drv_probe;
+	if (platform_drv->remove)
+		platform->component.remove = snd_soc_platform_drv_remove;
 	if (platform_drv->write)
 		platform->component.write = snd_soc_platform_drv_write;
 	if (platform_drv->read)
@@ -4363,6 +4344,20 @@ static void fixup_codec_formats(struct snd_soc_pcm_stream *stream)
 			stream->formats |= codec_format_map[i];
 }
 
+static int snd_soc_codec_drv_probe(struct snd_soc_component *component)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+	return codec->driver->probe(codec);
+}
+
+static void snd_soc_codec_drv_remove(struct snd_soc_component *component)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+	codec->driver->remove(codec);
+}
+
 static int snd_soc_codec_drv_write(struct snd_soc_component *component,
 	unsigned int reg, unsigned int val)
 {
@@ -4411,12 +4406,30 @@ int snd_soc_register_codec(struct device *dev,
 		return -ENOMEM;
 
 	codec->component.dapm_ptr = &codec->dapm;
+	codec->component.codec = codec;
 
 	ret = snd_soc_component_initialize(&codec->component,
 			&codec_drv->component_driver, dev);
 	if (ret)
 		goto err_free;
 
+	if (codec_drv->controls) {
+		codec->component.controls = codec_drv->controls;
+		codec->component.num_controls = codec_drv->num_controls;
+	}
+	if (codec_drv->dapm_widgets) {
+		codec->component.dapm_widgets = codec_drv->dapm_widgets;
+		codec->component.num_dapm_widgets = codec_drv->num_dapm_widgets;
+	}
+	if (codec_drv->dapm_routes) {
+		codec->component.dapm_routes = codec_drv->dapm_routes;
+		codec->component.num_dapm_routes = codec_drv->num_dapm_routes;
+	}
+
+	if (codec_drv->probe)
+		codec->component.probe = snd_soc_codec_drv_probe;
+	if (codec_drv->remove)
+		codec->component.remove = snd_soc_codec_drv_remove;
 	if (codec_drv->write)
 		codec->component.write = snd_soc_codec_drv_write;
 	if (codec_drv->read)

commit 81c7cfd1b22a0ee5e40efef72ec2cd17dbf12e6d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 19 15:51:18 2014 +0200

    ASoC: Move debugfs registration to the component level
    
    The debugfs registration is mostly identical between platforms and CODECs. This
    patches consolidates the two implementations at the component level.
    
    Unfortunately there are still a couple of CODEC specific debugfs files that are
    related to legacy ASoC IO that need to be registered. For this a new callback is
    added to the component struct that will be initialized when a CODEC is
    registered and will be used to register the CODEC specific files. Once there are
    no drivers left using legacy IO this can be removed again.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d4bfd4a9076f..79371a77f324 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -270,79 +270,56 @@ static const struct file_operations codec_reg_fops = {
 	.llseek = default_llseek,
 };
 
-static struct dentry *soc_debugfs_create_dir(struct dentry *parent,
-	const char *fmt, ...)
+static void soc_init_component_debugfs(struct snd_soc_component *component)
 {
-	struct dentry *de;
-	va_list ap;
-	char *s;
+	if (component->debugfs_prefix) {
+		char *name;
 
-	va_start(ap, fmt);
-	s = kvasprintf(GFP_KERNEL, fmt, ap);
-	va_end(ap);
+		name = kasprintf(GFP_KERNEL, "%s:%s",
+			component->debugfs_prefix, component->name);
+		if (name) {
+			component->debugfs_root = debugfs_create_dir(name,
+				component->card->debugfs_card_root);
+			kfree(name);
+		}
+	} else {
+		component->debugfs_root = debugfs_create_dir(component->name,
+				component->card->debugfs_card_root);
+	}
 
-	if (!s)
-		return NULL;
+	if (!component->debugfs_root) {
+		dev_warn(component->dev,
+			"ASoC: Failed to create component debugfs directory\n");
+		return;
+	}
 
-	de = debugfs_create_dir(s, parent);
-	kfree(s);
+	snd_soc_dapm_debugfs_init(snd_soc_component_get_dapm(component),
+		component->debugfs_root);
 
-	return de;
+	if (component->init_debugfs)
+		component->init_debugfs(component);
 }
 
-static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
+static void soc_cleanup_component_debugfs(struct snd_soc_component *component)
 {
-	struct dentry *debugfs_card_root = codec->component.card->debugfs_card_root;
+	debugfs_remove_recursive(component->debugfs_root);
+}
 
-	codec->debugfs_codec_root = soc_debugfs_create_dir(debugfs_card_root,
-						"codec:%s",
-						codec->component.name);
-	if (!codec->debugfs_codec_root) {
-		dev_warn(codec->dev,
-			"ASoC: Failed to create codec debugfs directory\n");
-		return;
-	}
+static void soc_init_codec_debugfs(struct snd_soc_component *component)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
 
-	debugfs_create_bool("cache_sync", 0444, codec->debugfs_codec_root,
+	debugfs_create_bool("cache_sync", 0444, codec->component.debugfs_root,
 			    &codec->cache_sync);
-	debugfs_create_bool("cache_only", 0444, codec->debugfs_codec_root,
+	debugfs_create_bool("cache_only", 0444, codec->component.debugfs_root,
 			    &codec->cache_only);
 
 	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
-						 codec->debugfs_codec_root,
+						 codec->component.debugfs_root,
 						 codec, &codec_reg_fops);
 	if (!codec->debugfs_reg)
 		dev_warn(codec->dev,
 			"ASoC: Failed to create codec register debugfs file\n");
-
-	snd_soc_dapm_debugfs_init(&codec->dapm, codec->debugfs_codec_root);
-}
-
-static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
-{
-	debugfs_remove_recursive(codec->debugfs_codec_root);
-}
-
-static void soc_init_platform_debugfs(struct snd_soc_platform *platform)
-{
-	struct dentry *debugfs_card_root = platform->component.card->debugfs_card_root;
-
-	platform->debugfs_platform_root = soc_debugfs_create_dir(debugfs_card_root,
-						"platform:%s",
-						platform->component.name);
-	if (!platform->debugfs_platform_root) {
-		dev_warn(platform->dev,
-			"ASoC: Failed to create platform debugfs directory\n");
-		return;
-	}
-
-	snd_soc_dapm_debugfs_init(&platform->component.dapm,
-		platform->debugfs_platform_root);
-}
-
-static void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform)
-{
-	debugfs_remove_recursive(platform->debugfs_platform_root);
 }
 
 static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
@@ -474,19 +451,15 @@ static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 
 #else
 
-static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
-{
-}
+#define soc_init_codec_debugfs NULL
 
-static inline void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
+static inline void soc_init_component_debugfs(
+	struct snd_soc_component *component)
 {
 }
 
-static inline void soc_init_platform_debugfs(struct snd_soc_platform *platform)
-{
-}
-
-static inline void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform)
+static inline void soc_cleanup_component_debugfs(
+	struct snd_soc_component *component)
 {
 }
 
@@ -1026,7 +999,7 @@ static int soc_remove_platform(struct snd_soc_platform *platform)
 	/* Make sure all DAPM widgets are freed */
 	snd_soc_dapm_free(&platform->component.dapm);
 
-	soc_cleanup_platform_debugfs(platform);
+	soc_cleanup_component_debugfs(&platform->component);
 	platform->probed = 0;
 	module_put(platform->dev->driver->owner);
 
@@ -1046,7 +1019,7 @@ static void soc_remove_codec(struct snd_soc_codec *codec)
 	/* Make sure all DAPM widgets are freed */
 	snd_soc_dapm_free(&codec->dapm);
 
-	soc_cleanup_codec_debugfs(codec);
+	soc_cleanup_component_debugfs(&codec->component);
 	codec->probed = 0;
 	list_del(&codec->card_list);
 	module_put(codec->dev->driver->owner);
@@ -1187,7 +1160,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	if (!try_module_get(codec->dev->driver->owner))
 		return -ENODEV;
 
-	soc_init_codec_debugfs(codec);
+	soc_init_component_debugfs(&codec->component);
 
 	if (driver->dapm_widgets) {
 		ret = snd_soc_dapm_new_controls(&codec->dapm,
@@ -1242,7 +1215,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	return 0;
 
 err_probe:
-	soc_cleanup_codec_debugfs(codec);
+	soc_cleanup_component_debugfs(&codec->component);
 	module_put(codec->dev->driver->owner);
 
 	return ret;
@@ -1262,7 +1235,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	if (!try_module_get(platform->dev->driver->owner))
 		return -ENODEV;
 
-	soc_init_platform_debugfs(platform);
+	soc_init_component_debugfs(&platform->component);
 
 	if (driver->dapm_widgets)
 		snd_soc_dapm_new_controls(&platform->component.dapm,
@@ -1302,7 +1275,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	return 0;
 
 err_probe:
-	soc_cleanup_platform_debugfs(platform);
+	soc_cleanup_component_debugfs(&platform->component);
 	module_put(platform->dev->driver->owner);
 
 	return ret;
@@ -4266,6 +4239,10 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 	if (platform_drv->read)
 		platform->component.read = snd_soc_platform_drv_read;
 
+#ifdef CONFIG_DEBUG_FS
+	platform->component.debugfs_prefix = "platform";
+#endif
+
 	mutex_lock(&client_mutex);
 	snd_soc_component_add_unlocked(&platform->component);
 	list_add(&platform->list, &platform_list);
@@ -4455,6 +4432,11 @@ int snd_soc_register_codec(struct device *dev,
 	codec->component.val_bytes = codec_drv->reg_word_size;
 	mutex_init(&codec->mutex);
 
+#ifdef CONFIG_DEBUG_FS
+	codec->component.init_debugfs = soc_init_codec_debugfs;
+	codec->component.debugfs_prefix = "codec";
+#endif
+
 	if (!codec->component.write) {
 		if (codec_drv->get_regmap)
 			regmap = codec_drv->get_regmap(dev);

commit f294afed03b154fbfaa9a32a0ebe7abdbf98070c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Aug 17 11:28:35 2014 +0200

    ASoC: Use dev_set_name() instead of init_name
    
    init_name is basically a hack and should only be used for statically allocated
    device structs. For dynamically allocated devices dev_set_name() should be used.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d4bfd4a9076f..889f4e3d35dc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1325,7 +1325,7 @@ static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
 	device_initialize(rtd->dev);
 	rtd->dev->parent = rtd->card->dev;
 	rtd->dev->release = rtd_release;
-	rtd->dev->init_name = name;
+	dev_set_name(rtd->dev, "%s", name);
 	dev_set_drvdata(rtd->dev, rtd);
 	mutex_init(&rtd->pcm_mutex);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);

commit c5e64c7636eb53495ee79916ca037fb97700eda0
Merge: 3510a6949546 7523a271682f 08074dc1ae8f 96665e312940 423ca88eb528
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Aug 4 16:32:12 2014 +0100

    Merge remote-tracking branches 'asoc/topic/tlv', 'asoc/topic/tlv320aic23', 'asoc/topic/tlv320aic31xx' and 'asoc/topic/tlv320aic32x4' into asoc-next

commit 7196be58ca832b6b37965921714849276f8996bc
Merge: a1cb98ac8b69 0e400c53812e
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Aug 4 16:31:17 2014 +0100

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 0f2780ad4c2a398528c7bb1572158d6e894e5dd2
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Jul 17 22:01:08 2014 +0200

    ASoC: Add function to register component controls
    
    We have now everything in place to actual let a component register controls. Add
    a function which allows to do so.
    
    Also update snd_soc_add_codec_controls() and snd_soc_platform_controls() to use
    this new function internally. And while we are at it also change the
    num_controls parameter of those two functions from int to unsigned int.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a0ae3d2263d1..28caa63ae526 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2393,6 +2393,25 @@ struct snd_kcontrol *snd_soc_card_get_kcontrol(struct snd_soc_card *soc_card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_card_get_kcontrol);
 
+/**
+ * snd_soc_add_component_controls - Add an array of controls to a component.
+ *
+ * @component: Component to add controls to
+ * @controls: Array of controls to add
+ * @num_controls: Number of elements in the array
+ *
+ * Return: 0 for success, else error.
+ */
+int snd_soc_add_component_controls(struct snd_soc_component *component,
+	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+{
+	struct snd_card *card = component->card->snd_card;
+
+	return snd_soc_add_controls(card, component->dev, controls,
+			num_controls, component->name_prefix, component);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_component_controls);
+
 /**
  * snd_soc_add_codec_controls - add an array of controls to a codec.
  * Convenience function to add a list of controls. Many codecs were
@@ -2405,12 +2424,10 @@ EXPORT_SYMBOL_GPL(snd_soc_card_get_kcontrol);
  * Return 0 for success, else error.
  */
 int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
-	const struct snd_kcontrol_new *controls, int num_controls)
+	const struct snd_kcontrol_new *controls, unsigned int num_controls)
 {
-	struct snd_card *card = codec->component.card->snd_card;
-
-	return snd_soc_add_controls(card, codec->dev, controls, num_controls,
-			codec->component.name_prefix, &codec->component);
+	return snd_soc_add_component_controls(&codec->component, controls,
+		num_controls);
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
 
@@ -2425,12 +2442,10 @@ EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
  * Return 0 for success, else error.
  */
 int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
-	const struct snd_kcontrol_new *controls, int num_controls)
+	const struct snd_kcontrol_new *controls, unsigned int num_controls)
 {
-	struct snd_card *card = platform->component.card->snd_card;
-
-	return snd_soc_add_controls(card, platform->dev, controls, num_controls,
-			NULL, &platform->component);
+	return snd_soc_add_component_controls(&platform->component, controls,
+		num_controls);
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);
 

commit 00200107a296cad3a950049a5ad7134a0d962b8d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Jul 17 22:01:07 2014 +0200

    ASoC: Move card field form platform/codec to component
    
    Both the snd_soc_codec and snd_soc_platform struct do have a pointer to the
    parent card and both handle this pointer in mostly the same way. This patch
    moves the card field to the component level which will allow further code
    consolidation between platforms and CODECS.
    
    Since there are only a handful of users of the snd_soc_codec struct's card field
    (and none of the snd_soc_platform's) these are update in this patch as well,
    which allows it to be removed from the snd_soc_codec struct.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a5edb31ddfff..a0ae3d2263d1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -292,7 +292,7 @@ static struct dentry *soc_debugfs_create_dir(struct dentry *parent,
 
 static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
-	struct dentry *debugfs_card_root = codec->card->debugfs_card_root;
+	struct dentry *debugfs_card_root = codec->component.card->debugfs_card_root;
 
 	codec->debugfs_codec_root = soc_debugfs_create_dir(debugfs_card_root,
 						"codec:%s",
@@ -325,7 +325,7 @@ static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 
 static void soc_init_platform_debugfs(struct snd_soc_platform *platform)
 {
-	struct dentry *debugfs_card_root = platform->card->debugfs_card_root;
+	struct dentry *debugfs_card_root = platform->component.card->debugfs_card_root;
 
 	platform->debugfs_platform_root = soc_debugfs_create_dir(debugfs_card_root,
 						"platform:%s",
@@ -546,11 +546,12 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 	int err;
 
 	codec->ac97->dev.bus = &ac97_bus_type;
-	codec->ac97->dev.parent = codec->card->dev;
+	codec->ac97->dev.parent = codec->component.card->dev;
 	codec->ac97->dev.release = soc_ac97_device_release;
 
 	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
-		     codec->card->snd_card->number, 0, codec->component.name);
+		     codec->component.card->snd_card->number, 0,
+		     codec->component.name);
 	err = device_register(&codec->ac97->dev);
 	if (err < 0) {
 		dev_err(codec->dev, "ASoC: Can't register ac97 bus\n");
@@ -1179,7 +1180,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	const struct snd_soc_codec_driver *driver = codec->driver;
 	struct snd_soc_dai *dai;
 
-	codec->card = card;
+	codec->component.card = card;
 	codec->dapm.card = card;
 	soc_set_name_prefix(card, &codec->component);
 
@@ -1255,7 +1256,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	struct snd_soc_component *component;
 	struct snd_soc_dai *dai;
 
-	platform->card = card;
+	platform->component.card = card;
 	platform->component.dapm.card = card;
 
 	if (!try_module_get(platform->dev->driver->owner))
@@ -2406,7 +2407,7 @@ EXPORT_SYMBOL_GPL(snd_soc_card_get_kcontrol);
 int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
 	const struct snd_kcontrol_new *controls, int num_controls)
 {
-	struct snd_card *card = codec->card->snd_card;
+	struct snd_card *card = codec->component.card->snd_card;
 
 	return snd_soc_add_controls(card, codec->dev, controls, num_controls,
 			codec->component.name_prefix, &codec->component);
@@ -2426,7 +2427,7 @@ EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
 int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
 	const struct snd_kcontrol_new *controls, int num_controls)
 {
-	struct snd_card *card = platform->card->snd_card;
+	struct snd_card *card = platform->component.card->snd_card;
 
 	return snd_soc_add_controls(card, platform->dev, controls, num_controls,
 			NULL, &platform->component);
@@ -3101,7 +3102,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw_range);
 int snd_soc_limit_volume(struct snd_soc_codec *codec,
 	const char *name, int max)
 {
-	struct snd_card *card = codec->card->snd_card;
+	struct snd_card *card = codec->component.card->snd_card;
 	struct snd_kcontrol *kctl;
 	struct soc_mixer_control *mc;
 	int found = 0;

commit 9898e1ccf5af70ad2d03d5b77c591fb243c0f021
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Jul 17 22:01:05 2014 +0200

    ASoC: Remove per card platform list
    
    The platform_dev_list was added in commit f0fba2ad1b ("ASoC: multi-component -
    ASoC Multi-Component Support") and while platforms are added and remove from
    that list it is otherwise unused. This patch removes it again.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6e47610f73a0..a5edb31ddfff 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1027,7 +1027,6 @@ static int soc_remove_platform(struct snd_soc_platform *platform)
 
 	soc_cleanup_platform_debugfs(platform);
 	platform->probed = 0;
-	list_del(&platform->card_list);
 	module_put(platform->dev->driver->owner);
 
 	return 0;
@@ -1297,7 +1296,6 @@ static int soc_probe_platform(struct snd_soc_card *card,
 
 	/* mark platform as probed and add to card platform list */
 	platform->probed = 1;
-	list_add(&platform->card_list, &card->platform_dev_list);
 	list_add(&platform->component.dapm.list, &card->dapm_list);
 
 	return 0;

commit 88bd870f02dff5c9445286e185f21873f25a977f
Author: Benoit Cousson <bcousson@baylibre.com>
Date:   Tue Jul 8 23:19:34 2014 +0200

    ASoC: core: Add initial support for DAI multicodec
    
    DAI link assumes a one to one mapping between CPU DAI and CODEC. In
    some cases, the same CPU DAI can be connected to several codecs.
    This is the case for example, if you connect two mono codecs to the
    same I2S link in order to have a stereo card.
    The current ASoC implementation does not allow such setup.
    
    Add support for DAI links composed of a single CPU DAI and multiple
    CODECs. Sound cards have to pass the CODECs array in the corresponding
    DAI link through a new 'snd_soc_dai_link_component' struct. Each CODEC in
    this array is described in the same manner single CODEC DAIs are
    (either DT/OF node or codec_name).
    
    Multi-codec links are not supported in the case of CODEC to CODEC links.
    Just print a warning if it happens.
    
    Based on an original code done by Misael.
    
    Signed-off-by: Benoit Cousson <bcousson@baylibre.com>
    Signed-off-by: Misael Lopez Cruz <misael.lopez@ti.com>
    Signed-off-by: Fabien Parent <fparent@baylibre.com>
    Tested-by: Lars-Peter Clausen <lars@metafoo.de>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c32d8399e770..6e47610f73a0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -576,7 +576,7 @@ int snd_soc_suspend(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	struct snd_soc_codec *codec;
-	int i;
+	int i, j;
 
 	/* If the initialization of this soc device failed, there is no codec
 	 * associated with it. Just bail out in this case.
@@ -596,14 +596,17 @@ int snd_soc_suspend(struct device *dev)
 
 	/* mute any active DACs */
 	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *dai = card->rtd[i].codec_dai;
-		struct snd_soc_dai_driver *drv = dai->driver;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (drv->ops->digital_mute && dai->playback_active)
-			drv->ops->digital_mute(dai, 1);
+		for (j = 0; j < card->rtd[i].num_codecs; j++) {
+			struct snd_soc_dai *dai = card->rtd[i].codec_dais[j];
+			struct snd_soc_dai_driver *drv = dai->driver;
+
+			if (drv->ops->digital_mute && dai->playback_active)
+				drv->ops->digital_mute(dai, 1);
+		}
 	}
 
 	/* suspend all pcms */
@@ -634,8 +637,12 @@ int snd_soc_suspend(struct device *dev)
 
 	/* close any waiting streams and save state */
 	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai **codec_dais = card->rtd[i].codec_dais;
 		flush_delayed_work(&card->rtd[i].delayed_work);
-		card->rtd[i].codec->dapm.suspend_bias_level = card->rtd[i].codec->dapm.bias_level;
+		for (j = 0; j < card->rtd[i].num_codecs; j++) {
+			codec_dais[j]->codec->dapm.suspend_bias_level =
+					codec_dais[j]->codec->dapm.bias_level;
+		}
 	}
 
 	for (i = 0; i < card->num_rtd; i++) {
@@ -719,7 +726,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	struct snd_soc_card *card =
 			container_of(work, struct snd_soc_card, deferred_resume_work);
 	struct snd_soc_codec *codec;
-	int i;
+	int i, j;
 
 	/* our power state is still SNDRV_CTL_POWER_D3hot from suspend time,
 	 * so userspace apps are blocked from touching us
@@ -780,14 +787,17 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	/* unmute any active DACs */
 	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *dai = card->rtd[i].codec_dai;
-		struct snd_soc_dai_driver *drv = dai->driver;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (drv->ops->digital_mute && dai->playback_active)
-			drv->ops->digital_mute(dai, 0);
+		for (j = 0; j < card->rtd[i].num_codecs; j++) {
+			struct snd_soc_dai *dai = card->rtd[i].codec_dais[j];
+			struct snd_soc_dai_driver *drv = dai->driver;
+
+			if (drv->ops->digital_mute && dai->playback_active)
+				drv->ops->digital_mute(dai, 0);
+		}
 	}
 
 	for (i = 0; i < card->num_rtd; i++) {
@@ -832,12 +842,19 @@ int snd_soc_resume(struct device *dev)
 
 	/* activate pins from sleep state */
 	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
-		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
+		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+		struct snd_soc_dai **codec_dais = rtd->codec_dais;
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+		int j;
+
 		if (cpu_dai->active)
 			pinctrl_pm_select_default_state(cpu_dai->dev);
-		if (codec_dai->active)
-			pinctrl_pm_select_default_state(codec_dai->dev);
+
+		for (j = 0; j < rtd->num_codecs; j++) {
+			struct snd_soc_dai *codec_dai = codec_dais[j];
+			if (codec_dai->active)
+				pinctrl_pm_select_default_state(codec_dai->dev);
+		}
 	}
 
 	/* AC97 devices might have other drivers hanging off them so
@@ -869,8 +886,9 @@ EXPORT_SYMBOL_GPL(snd_soc_resume);
 static const struct snd_soc_dai_ops null_dai_ops = {
 };
 
-static struct snd_soc_codec *soc_find_codec(const struct device_node *codec_of_node,
-					    const char *codec_name)
+static struct snd_soc_codec *soc_find_codec(
+					const struct device_node *codec_of_node,
+					const char *codec_name)
 {
 	struct snd_soc_codec *codec;
 
@@ -908,9 +926,12 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_component *component;
+	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
+	struct snd_soc_dai **codec_dais = rtd->codec_dais;
 	struct snd_soc_platform *platform;
 	struct snd_soc_dai *cpu_dai;
 	const char *platform_name;
+	int i;
 
 	dev_dbg(card->dev, "ASoC: binding %s at idx %d\n", dai_link->name, num);
 
@@ -937,24 +958,30 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		return -EPROBE_DEFER;
 	}
 
-	/* Find CODEC from registered list */
-	rtd->codec = soc_find_codec(dai_link->codec_of_node,
-				    dai_link->codec_name);
-	if (!rtd->codec) {
-		dev_err(card->dev, "ASoC: CODEC %s not registered\n",
-			dai_link->codec_name);
-		return -EPROBE_DEFER;
-	}
+	rtd->num_codecs = dai_link->num_codecs;
 
-	/* Find CODEC DAI from registered list */
-	rtd->codec_dai = soc_find_codec_dai(rtd->codec,
-					    dai_link->codec_dai_name);
-	if (!rtd->codec_dai) {
-		dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
-			dai_link->codec_dai_name);
-		return -EPROBE_DEFER;
+	/* Find CODEC from registered CODECs */
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_codec *codec;
+		codec = soc_find_codec(codecs[i].of_node, codecs[i].name);
+		if (!codec) {
+			dev_err(card->dev, "ASoC: CODEC %s not registered\n",
+				codecs[i].name);
+			return -EPROBE_DEFER;
+		}
+
+		codec_dais[i] = soc_find_codec_dai(codec, codecs[i].dai_name);
+		if (!codec_dais[i]) {
+			dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
+				codecs[i].dai_name);
+			return -EPROBE_DEFER;
+		}
 	}
 
+	/* Single codec links expect codec and codec_dai in runtime data */
+	rtd->codec_dai = codec_dais[0];
+	rtd->codec = rtd->codec_dai->codec;
+
 	/* if there's no platform we match on the empty platform */
 	platform_name = dai_link->platform_name;
 	if (!platform_name && !dai_link->platform_of_node)
@@ -1045,8 +1072,8 @@ static void soc_remove_codec_dai(struct snd_soc_dai *codec_dai, int order)
 static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
-	int err;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int i, err;
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
@@ -1057,7 +1084,8 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 	}
 
 	/* remove the CODEC DAI */
-	soc_remove_codec_dai(codec_dai, order);
+	for (i = 0; i < rtd->num_codecs; i++)
+		soc_remove_codec_dai(rtd->codec_dais[i], order);
 
 	/* remove the cpu_dai */
 	if (cpu_dai && cpu_dai->probed &&
@@ -1080,9 +1108,9 @@ static void soc_remove_link_components(struct snd_soc_card *card, int num,
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_codec *codec;
+	int i;
 
 	/* remove the platform */
 	if (platform && platform->probed &&
@@ -1091,8 +1119,8 @@ static void soc_remove_link_components(struct snd_soc_card *card, int num,
 	}
 
 	/* remove the CODEC-side CODEC */
-	if (codec_dai) {
-		codec = codec_dai->codec;
+	for (i = 0; i < rtd->num_codecs; i++) {
+		codec = rtd->codec_dais[i]->codec;
 		if (codec && codec->probed &&
 		    codec->driver->remove_order == order)
 			soc_remove_codec(codec);
@@ -1335,9 +1363,8 @@ static int soc_probe_link_components(struct snd_soc_card *card, int num,
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct snd_soc_platform *platform = rtd->platform;
-	int ret;
+	int i, ret;
 
 	/* probe the CPU-side component, if it is a CODEC */
 	if (cpu_dai->codec &&
@@ -1348,12 +1375,14 @@ static int soc_probe_link_components(struct snd_soc_card *card, int num,
 			return ret;
 	}
 
-	/* probe the CODEC-side component */
-	if (!codec_dai->codec->probed &&
-	    codec_dai->codec->driver->probe_order == order) {
-		ret = soc_probe_codec(card, codec_dai->codec);
-		if (ret < 0)
-			return ret;
+	/* probe the CODEC-side components */
+	for (i = 0; i < rtd->num_codecs; i++) {
+		if (!rtd->codec_dais[i]->codec->probed &&
+		    rtd->codec_dais[i]->codec->driver->probe_order == order) {
+			ret = soc_probe_codec(card, rtd->codec_dais[i]->codec);
+			if (ret < 0)
+				return ret;
+		}
 	}
 
 	/* probe the platform */
@@ -1400,6 +1429,9 @@ static int soc_link_dai_widgets(struct snd_soc_card *card,
 	struct snd_soc_dapm_widget *play_w, *capture_w;
 	int ret;
 
+	if (rtd->num_codecs > 1)
+		dev_warn(card->dev, "ASoC: Multiple codecs not supported yet\n");
+
 	/* link the DAI widgets */
 	play_w = codec_dai->playback_widget;
 	capture_w = cpu_dai->capture_widget;
@@ -1432,19 +1464,18 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	struct snd_soc_codec *codec = rtd->codec;
 	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	int ret;
+	int i, ret;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
 			card->name, num, order);
 
 	/* config components */
 	cpu_dai->platform = platform;
-	codec_dai->card = card;
 	cpu_dai->card = card;
+	for (i = 0; i < rtd->num_codecs; i++)
+		rtd->codec_dais[i]->card = card;
 
 	/* set default power off timeout */
 	rtd->pmdown_time = pmdown_time;
@@ -1471,9 +1502,11 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	}
 
 	/* probe the CODEC DAI */
-	ret = soc_probe_codec_dai(card, codec_dai, order);
-	if (ret)
-		return ret;
+	for (i = 0; i < rtd->num_codecs; i++) {
+		ret = soc_probe_codec_dai(card, rtd->codec_dais[i], order);
+		if (ret)
+			return ret;
+	}
 
 	/* complete DAI probe during last probe */
 	if (order != SND_SOC_COMP_ORDER_LAST)
@@ -1541,8 +1574,11 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	}
 
 	/* add platform data for AC97 devices */
-	if (rtd->codec_dai->driver->ac97_control)
-		snd_ac97_dev_add_pdata(codec->ac97, rtd->cpu_dai->ac97_pdata);
+	for (i = 0; i < rtd->num_codecs; i++) {
+		if (rtd->codec_dais[i]->driver->ac97_control)
+			snd_ac97_dev_add_pdata(rtd->codec_dais[i]->codec->ac97,
+					       rtd->cpu_dai->ac97_pdata);
+	}
 
 	return 0;
 }
@@ -1580,11 +1616,6 @@ static int soc_register_ac97_codec(struct snd_soc_codec *codec,
 	return 0;
 }
 
-static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
-{
-	return soc_register_ac97_codec(rtd->codec, rtd->codec_dai);
-}
-
 static void soc_unregister_ac97_codec(struct snd_soc_codec *codec)
 {
 	if (codec->ac97_registered) {
@@ -1593,9 +1624,30 @@ static void soc_unregister_ac97_codec(struct snd_soc_codec *codec)
 	}
 }
 
+static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_dai *codec_dai = rtd->codec_dais[i];
+
+		ret = soc_register_ac97_codec(codec_dai->codec, codec_dai);
+		if (ret) {
+			while (--i >= 0)
+				soc_unregister_ac97_codec(codec_dai->codec);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static void soc_unregister_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
 {
-	soc_unregister_ac97_codec(rtd->codec);
+	int i;
+
+	for (i = 0; i < rtd->num_codecs; i++)
+		soc_unregister_ac97_codec(rtd->codec_dais[i]->codec);
 }
 #endif
 
@@ -1794,16 +1846,23 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 					card->num_dapm_routes);
 
 	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
 		dai_link = &card->dai_link[i];
 		dai_fmt = dai_link->dai_fmt;
 
 		if (dai_fmt) {
-			ret = snd_soc_dai_set_fmt(card->rtd[i].codec_dai,
-						  dai_fmt);
-			if (ret != 0 && ret != -ENOTSUPP)
-				dev_warn(card->rtd[i].codec_dai->dev,
-					 "ASoC: Failed to set DAI format: %d\n",
-					 ret);
+			struct snd_soc_dai **codec_dais = rtd->codec_dais;
+			int j;
+
+			for (j = 0; j < rtd->num_codecs; j++) {
+				struct snd_soc_dai *codec_dai = codec_dais[j];
+
+				ret = snd_soc_dai_set_fmt(codec_dai, dai_fmt);
+				if (ret != 0 && ret != -ENOTSUPP)
+					dev_warn(codec_dai->dev,
+						 "ASoC: Failed to set DAI format: %d\n",
+						 ret);
+			}
 		}
 
 		/* If this is a regular CPU link there will be a platform */
@@ -2002,10 +2061,15 @@ int snd_soc_poweroff(struct device *dev)
 
 	/* deactivate pins to sleep state */
 	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
-		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
-		pinctrl_pm_select_sleep_state(codec_dai->dev);
+		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+		int j;
+
 		pinctrl_pm_select_sleep_state(cpu_dai->dev);
+		for (j = 0; j < rtd->num_codecs; j++) {
+			struct snd_soc_dai *codec_dai = rtd->codec_dais[j];
+			pinctrl_pm_select_sleep_state(codec_dai->dev);
+		}
 	}
 
 	return 0;
@@ -3585,6 +3649,9 @@ int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	else
 		snd_soc_xlate_tdm_slot_mask(slots, &tx_mask, &rx_mask);
 
+	dai->tx_mask = tx_mask;
+	dai->rx_mask = rx_mask;
+
 	if (dai->driver && dai->driver->ops->set_tdm_slot)
 		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
 				slots, slot_width);
@@ -3657,6 +3724,33 @@ int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 
+static int snd_soc_init_multicodec(struct snd_soc_card *card,
+				   struct snd_soc_dai_link *dai_link)
+{
+	/* Legacy codec/codec_dai link is a single entry in multicodec */
+	if (dai_link->codec_name || dai_link->codec_of_node ||
+	    dai_link->codec_dai_name) {
+		dai_link->num_codecs = 1;
+
+		dai_link->codecs = devm_kzalloc(card->dev,
+				sizeof(struct snd_soc_dai_link_component),
+				GFP_KERNEL);
+		if (!dai_link->codecs)
+			return -ENOMEM;
+
+		dai_link->codecs[0].name = dai_link->codec_name;
+		dai_link->codecs[0].of_node = dai_link->codec_of_node;
+		dai_link->codecs[0].dai_name = dai_link->codec_dai_name;
+	}
+
+	if (!dai_link->codecs) {
+		dev_err(card->dev, "ASoC: DAI link has no CODECs\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 /**
  * snd_soc_register_card - Register a card with the ASoC core
  *
@@ -3665,7 +3759,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
  */
 int snd_soc_register_card(struct snd_soc_card *card)
 {
-	int i, ret;
+	int i, j, ret;
 
 	if (!card->name || !card->dev)
 		return -EINVAL;
@@ -3673,22 +3767,29 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai_link *link = &card->dai_link[i];
 
-		/*
-		 * Codec must be specified by 1 of name or OF node,
-		 * not both or neither.
-		 */
-		if (!!link->codec_name == !!link->codec_of_node) {
-			dev_err(card->dev,
-				"ASoC: Neither/both codec name/of_node are set for %s\n",
-				link->name);
-			return -EINVAL;
+		ret = snd_soc_init_multicodec(card, link);
+		if (ret) {
+			dev_err(card->dev, "ASoC: failed to init multicodec\n");
+			return ret;
 		}
-		/* Codec DAI name must be specified */
-		if (!link->codec_dai_name) {
-			dev_err(card->dev,
-				"ASoC: codec_dai_name not set for %s\n",
-				link->name);
-			return -EINVAL;
+
+		for (j = 0; j < link->num_codecs; j++) {
+			/*
+			 * Codec must be specified by 1 of name or OF node,
+			 * not both or neither.
+			 */
+			if (!!link->codecs[j].name ==
+			    !!link->codecs[j].of_node) {
+				dev_err(card->dev, "ASoC: Neither/both codec name/of_node are set for %s\n",
+					link->name);
+				return -EINVAL;
+			}
+			/* Codec DAI name must be specified */
+			if (!link->codecs[j].dai_name) {
+				dev_err(card->dev, "ASoC: codec_dai_name not set for %s\n",
+					link->name);
+				return -EINVAL;
+			}
 		}
 
 		/*
@@ -3744,6 +3845,12 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_links; i++) {
 		card->rtd[i].card = card;
 		card->rtd[i].dai_link = &card->dai_link[i];
+		card->rtd[i].codec_dais = devm_kzalloc(card->dev,
+					sizeof(struct snd_soc_dai *) *
+					(card->rtd[i].dai_link->num_codecs),
+					GFP_KERNEL);
+		if (card->rtd[i].codec_dais == NULL)
+			return -ENOMEM;
 	}
 
 	for (i = 0; i < card->num_aux_devs; i++)
@@ -3760,10 +3867,16 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 	/* deactivate pins to sleep state */
 	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
-		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
-		if (!codec_dai->active)
-			pinctrl_pm_select_sleep_state(codec_dai->dev);
+		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+		struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+		int j;
+
+		for (j = 0; j < rtd->num_codecs; j++) {
+			struct snd_soc_dai *codec_dai = rtd->codec_dais[j];
+			if (!codec_dai->active)
+				pinctrl_pm_select_sleep_state(codec_dai->dev);
+		}
+
 		if (!cpu_dai->active)
 			pinctrl_pm_select_sleep_state(cpu_dai->dev);
 	}

commit f7acb3694a999fdf04dc3096e8416a0bfdabd590
Merge: c8dd1fec47d0 5f3484ac8775
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Jul 16 22:58:45 2014 +0100

    Merge remote-tracking branch 'asoc/topic/component' into asoc-multi

commit 7523a271682fc1f35355da344249ce8f8c8b8cb9
Author: Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
Date:   Tue Jul 15 21:34:48 2014 +0530

    ASoC: core: add a helper for extended byte controls using TLV
    
    ALSA supports arbitrary length TLVs for each kcontrol that can be used
    to pass metadata about the control (e.g. volumes, enum information). The
    same transport mechanism is now used for arbitrary length data by
    defining a new helper.
    
    Signed-off-by: Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b87d7d882e6d..a9ce63f634b2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3267,6 +3267,27 @@ int snd_soc_bytes_info_ext(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_bytes_info_ext);
 
+int snd_soc_bytes_tlv_callback(struct snd_kcontrol *kcontrol, int op_flag,
+				unsigned int size, unsigned int __user *tlv)
+{
+	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
+	unsigned int count = size < params->max ? size : params->max;
+	int ret = -ENXIO;
+
+	switch (op_flag) {
+	case SNDRV_CTL_TLV_OP_READ:
+		if (params->get)
+			ret = params->get(tlv, count);
+		break;
+	case SNDRV_CTL_TLV_OP_WRITE:
+		if (params->put)
+			ret = params->put(tlv, count);
+		break;
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_bytes_tlv_callback);
+
 /**
  * snd_soc_info_xr_sx - signed multi register info callback
  * @kcontrol: mreg control

commit 7e07e7c0854b32181b314f5ba43007629594663a
Author: Tushar Behera <tushar.b@samsung.com>
Date:   Fri Jul 4 14:23:00 2014 +0530

    ASoC: core: Fix possible NULL pointer dereference
    
    snd_soc_of_parse_card_name() may be called before card->dev has been
    set, which results in a kernel panic.
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000210
    PC is at snd_soc_of_parse_card_name+0x18/0x54
    LR is at snow_probe+0x5c/0xd4
    
    Add an error check in snd_soc_of_parse_card_name() to take care of this
    case and print out a message in case of error.
    
    Signed-off-by: Tushar Behera <tushar.b@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b87d7d882e6d..63d11071fdba 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4420,9 +4420,16 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
 int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 			       const char *propname)
 {
-	struct device_node *np = card->dev->of_node;
+	struct device_node *np;
 	int ret;
 
+	if (!card->dev) {
+		pr_err("card->dev is not set before calling %s\n", __func__);
+		return -EINVAL;
+	}
+
+	np = card->dev->of_node;
+
 	ret = of_property_read_string_index(np, propname, 0, &card->name);
 	/*
 	 * EINVAL means the property does not exist. This is fine providing

commit 5f3484ac8775a183f855fd213907c4221d2fb11f
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Jul 1 22:13:48 2014 +0200

    ASoC: core: Move non-shared code paths out of snd_soc_post_component_init()
    
    There are two call sites for snd_soc_post_component_init(), one passes 0 and the
    other 1 for the 'dailess' parameter of snd_soc_post_component_init(). Depending
    on whether 'dailess' is 0 or 1 snd_soc_post_component_init() runs different code
    at the beginning and the end of the function. The patch moves this conditional
    code out of snd_soc_post_component_init() and into the call sites. This removes
    the need for snd_soc_post_component_init() to know whether it is called for a
    DAI link or a aux dev.
    
    Also do the initialization of rtd->card when the rtd struct is allocated.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b1600cdcdc14..c4db07f01d10 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1286,74 +1286,17 @@ static void rtd_release(struct device *dev)
 	kfree(dev);
 }
 
-static int soc_aux_dev_init(struct snd_soc_card *card, int num)
+static int soc_post_component_init(struct snd_soc_pcm_runtime *rtd,
+	const char *name)
 {
-	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
-	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
-	int ret;
-
-	rtd->card = card;
-
-	/* do machine specific initialization */
-	if (aux_dev->init) {
-		ret = aux_dev->init(&rtd->codec->dapm);
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int soc_dai_link_init(struct snd_soc_card *card, int num)
-{
-	struct snd_soc_dai_link *dai_link =  &card->dai_link[num];
-	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	int ret;
-
-	rtd->card = card;
-
-	/* do machine specific initialization */
-	if (dai_link->init) {
-		ret = dai_link->init(rtd);
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int soc_post_component_init(struct snd_soc_card *card,
-				   int num, int dailess)
-{
-	struct snd_soc_dai_link *dai_link = NULL;
-	struct snd_soc_aux_dev *aux_dev = NULL;
-	struct snd_soc_pcm_runtime *rtd;
-	const char *name;
 	int ret = 0;
 
-	if (!dailess) {
-		dai_link = &card->dai_link[num];
-		rtd = &card->rtd[num];
-		name = dai_link->name;
-		ret = soc_dai_link_init(card, num);
-	} else {
-		aux_dev = &card->aux_dev[num];
-		rtd = &card->rtd_aux[num];
-		name = aux_dev->name;
-		ret = soc_aux_dev_init(card, num);
-	}
-
-	if (ret < 0) {
-		dev_err(card->dev, "ASoC: failed to init %s: %d\n", name, ret);
-		return ret;
-	}
-
 	/* register the rtd device */
 	rtd->dev = kzalloc(sizeof(struct device), GFP_KERNEL);
 	if (!rtd->dev)
 		return -ENOMEM;
 	device_initialize(rtd->dev);
-	rtd->dev->parent = card->dev;
+	rtd->dev->parent = rtd->card->dev;
 	rtd->dev->release = rtd_release;
 	rtd->dev->init_name = name;
 	dev_set_drvdata(rtd->dev, rtd);
@@ -1366,7 +1309,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	if (ret < 0) {
 		/* calling put_device() here to free the rtd->dev */
 		put_device(rtd->dev);
-		dev_err(card->dev,
+		dev_err(rtd->card->dev,
 			"ASoC: failed to register runtime device: %d\n", ret);
 		return ret;
 	}
@@ -1384,17 +1327,6 @@ static int soc_post_component_init(struct snd_soc_card *card,
 		dev_err(rtd->dev,
 			"ASoC: failed to add codec sysfs files: %d\n", ret);
 
-#ifdef CONFIG_DEBUG_FS
-	/* add DPCM sysfs entries */
-	if (!dailess && !dai_link->dynamic)
-		goto out;
-
-	ret = soc_dpcm_debugfs_add(rtd);
-	if (ret < 0)
-		dev_err(rtd->dev, "ASoC: failed to add dpcm sysfs entries: %d\n", ret);
-
-out:
-#endif
 	return 0;
 }
 
@@ -1546,10 +1478,33 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	if (order != SND_SOC_COMP_ORDER_LAST)
 		return 0;
 
-	ret = soc_post_component_init(card, num, 0);
+	/* do machine specific initialization */
+	if (dai_link->init) {
+		ret = dai_link->init(rtd);
+		if (ret < 0) {
+			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
+				dai_link->name, ret);
+			return ret;
+		}
+	}
+
+	ret = soc_post_component_init(rtd, dai_link->name);
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_DEBUG_FS
+	/* add DPCM sysfs entries */
+	if (dai_link->dynamic) {
+		ret = soc_dpcm_debugfs_add(rtd);
+		if (ret < 0) {
+			dev_err(rtd->dev,
+				"ASoC: failed to add dpcm sysfs entries: %d\n",
+				ret);
+			return ret;
+		}
+	}
+#endif
+
 	ret = device_create_file(rtd->dev, &dev_attr_pmdown_time);
 	if (ret < 0)
 		dev_warn(rtd->dev, "ASoC: failed to add pmdown_time sysfs: %d\n",
@@ -1665,6 +1620,7 @@ static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
+	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	int ret;
 
 	if (rtd->codec->probed) {
@@ -1676,7 +1632,17 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	if (ret < 0)
 		return ret;
 
-	return soc_post_component_init(card, num, 1);
+	/* do machine specific initialization */
+	if (aux_dev->init) {
+		ret = aux_dev->init(&rtd->codec->dapm);
+		if (ret < 0) {
+			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
+				aux_dev->name, ret);
+			return ret;
+		}
+	}
+
+	return soc_post_component_init(rtd, aux_dev->name);
 }
 
 static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
@@ -3775,8 +3741,13 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	card->num_rtd = 0;
 	card->rtd_aux = &card->rtd[card->num_links];
 
-	for (i = 0; i < card->num_links; i++)
+	for (i = 0; i < card->num_links; i++) {
+		card->rtd[i].card = card;
 		card->rtd[i].dai_link = &card->dai_link[i];
+	}
+
+	for (i = 0; i < card->num_aux_devs; i++)
+		card->rtd_aux[i].card = card;
 
 	INIT_LIST_HEAD(&card->dapm_dirty);
 	card->instantiated = 0;

commit 44c69bb13905c3b2281a920c0b44059e88819993
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Jul 1 22:13:47 2014 +0200

    ASoC: core: Bind aux devs early
    
    Currently in snd_soc_instantiate_card() we only check if the aux dev exists, but
    do not yet assign it to its rtd. This means that we need to lookup the aux dev
    again in soc_probe_aux_dev(). This patch changes the behavior to assign the aux
    dev to the rtd in soc_check_aux_dev() (and renames it to soc_bind_aux_dev()).
    This simplifies the implementation a bit and also removes the need for
    soc_post_component_init() to know about the specific CODEC that was assigned to
    the rtd. The later is necessary for componentization as the code should work for
    all types of components not just CODECs. This new behavior is also more in sync
    with how soc_bind_dai_link()/soc_probe_link_dais() works.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c8bdac2db377..b1600cdcdc14 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1286,9 +1286,7 @@ static void rtd_release(struct device *dev)
 	kfree(dev);
 }
 
-static int soc_aux_dev_init(struct snd_soc_card *card,
-			    struct snd_soc_codec *codec,
-			    int num)
+static int soc_aux_dev_init(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
@@ -1298,13 +1296,11 @@ static int soc_aux_dev_init(struct snd_soc_card *card,
 
 	/* do machine specific initialization */
 	if (aux_dev->init) {
-		ret = aux_dev->init(&codec->dapm);
+		ret = aux_dev->init(&rtd->codec->dapm);
 		if (ret < 0)
 			return ret;
 	}
 
-	rtd->codec = codec;
-
 	return 0;
 }
 
@@ -1327,7 +1323,6 @@ static int soc_dai_link_init(struct snd_soc_card *card, int num)
 }
 
 static int soc_post_component_init(struct snd_soc_card *card,
-				   struct snd_soc_codec *codec,
 				   int num, int dailess)
 {
 	struct snd_soc_dai_link *dai_link = NULL;
@@ -1345,7 +1340,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 		aux_dev = &card->aux_dev[num];
 		rtd = &card->rtd_aux[num];
 		name = aux_dev->name;
-		ret = soc_aux_dev_init(card, codec, num);
+		ret = soc_aux_dev_init(card, num);
 	}
 
 	if (ret < 0) {
@@ -1380,13 +1375,13 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	/* add DAPM sysfs entries for this codec */
 	ret = snd_soc_dapm_sys_add(rtd->dev);
 	if (ret < 0)
-		dev_err(codec->dev,
+		dev_err(rtd->dev,
 			"ASoC: failed to add codec dapm sysfs entries: %d\n", ret);
 
 	/* add codec sysfs entries */
 	ret = device_create_file(rtd->dev, &dev_attr_codec_reg);
 	if (ret < 0)
-		dev_err(codec->dev,
+		dev_err(rtd->dev,
 			"ASoC: failed to add codec sysfs files: %d\n", ret);
 
 #ifdef CONFIG_DEBUG_FS
@@ -1551,7 +1546,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	if (order != SND_SOC_COMP_ORDER_LAST)
 		return 0;
 
-	ret = soc_post_component_init(card, codec, num, 0);
+	ret = soc_post_component_init(card, num, 0);
 	if (ret)
 		return ret;
 
@@ -1649,51 +1644,39 @@ static void soc_unregister_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
 }
 #endif
 
-static int soc_check_aux_dev(struct snd_soc_card *card, int num)
-{
-	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
-	const char *codecname = aux_dev->codec_name;
-	struct snd_soc_codec *codec;
-
-	codec = soc_find_codec(aux_dev->codec_of_node, aux_dev->codec_name);
-	if (codec)
-		return 0;
-	if (aux_dev->codec_of_node)
-		codecname = of_node_full_name(aux_dev->codec_of_node);
-
-	dev_err(card->dev, "ASoC: %s not registered\n", codecname);
-	return -EPROBE_DEFER;
-}
-
-static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
+static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 {
+	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	const char *codecname = aux_dev->codec_name;
-	int ret = -ENODEV;
-	struct snd_soc_codec *codec;
 
-	codec = soc_find_codec(aux_dev->codec_of_node, aux_dev->codec_name);
-	if (!codec) {
+	rtd->codec = soc_find_codec(aux_dev->codec_of_node, codecname);
+	if (!rtd->codec) {
 		if (aux_dev->codec_of_node)
 			codecname = of_node_full_name(aux_dev->codec_of_node);
 
-		/* codec not found */
-		dev_err(card->dev, "ASoC: codec %s not found", codecname);
+		dev_err(card->dev, "ASoC: %s not registered\n", codecname);
 		return -EPROBE_DEFER;
 	}
 
-	if (codec->probed) {
-		dev_err(codec->dev, "ASoC: codec already probed");
+	return 0;
+}
+
+static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
+{
+	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
+	int ret;
+
+	if (rtd->codec->probed) {
+		dev_err(rtd->codec->dev, "ASoC: codec already probed\n");
 		return -EBUSY;
 	}
 
-	ret = soc_probe_codec(card, codec);
+	ret = soc_probe_codec(card, rtd->codec);
 	if (ret < 0)
 		return ret;
 
-	ret = soc_post_component_init(card, codec, num, 1);
-
-	return ret;
+	return soc_post_component_init(card, num, 1);
 }
 
 static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
@@ -1745,9 +1728,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 			goto base_error;
 	}
 
-	/* check aux_devs too */
+	/* bind aux_devs too */
 	for (i = 0; i < card->num_aux_devs; i++) {
-		ret = soc_check_aux_dev(card, i);
+		ret = soc_bind_aux_dev(card, i);
 		if (ret != 0)
 			goto base_error;
 	}

commit 48f466d112c9ca735ee765d8f5148d07a8c7bb1d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Jul 1 22:13:46 2014 +0200

    ASoC: core: Replace soc_find_matching_codec() with soc_find_codec()
    
    soc_find_matching_codec() works in the same way as soc_find_codec() except that
    it only works for auxdevs. It can easily be replaced by the generic
    soc_find_codec().
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0cd36b781f4d..c8bdac2db377 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1649,32 +1649,13 @@ static void soc_unregister_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
 }
 #endif
 
-static struct snd_soc_codec *soc_find_matching_codec(struct snd_soc_card *card,
-	int num)
-{
-	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
-	struct snd_soc_codec *codec;
-
-	/* find CODEC from registered CODECs */
-	list_for_each_entry(codec, &codec_list, list) {
-		if (aux_dev->codec_of_node &&
-		   (codec->dev->of_node != aux_dev->codec_of_node))
-			continue;
-		if (aux_dev->codec_name &&
-			strcmp(codec->component.name, aux_dev->codec_name))
-			continue;
-		return codec;
-	}
-
-	return NULL;
-}
-
 static int soc_check_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	const char *codecname = aux_dev->codec_name;
-	struct snd_soc_codec *codec = soc_find_matching_codec(card, num);
+	struct snd_soc_codec *codec;
 
+	codec = soc_find_codec(aux_dev->codec_of_node, aux_dev->codec_name);
 	if (codec)
 		return 0;
 	if (aux_dev->codec_of_node)
@@ -1689,8 +1670,9 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	const char *codecname = aux_dev->codec_name;
 	int ret = -ENODEV;
-	struct snd_soc_codec *codec = soc_find_matching_codec(card, num);
+	struct snd_soc_codec *codec;
 
+	codec = soc_find_codec(aux_dev->codec_of_node, aux_dev->codec_name);
 	if (!codec) {
 		if (aux_dev->codec_of_node)
 			codecname = of_node_full_name(aux_dev->codec_of_node);

commit b8257be5fff447681af8c8b72f1380e8a9c04286
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Jul 1 22:13:45 2014 +0200

    ASoC: core: Remove duplicated rtd->codec initialization
    
    rtd->codec is already initialized in soc_bind_dai_link(), so there is no need to
    do it again in soc_dai_link_init(). Removing the rtd->codec initialization from
    soc_dai_link_init() also removes the need for soc_dai_link_init() to know about
    the CODEC at all.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 72d4a2b009fa..0cd36b781f4d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1308,9 +1308,7 @@ static int soc_aux_dev_init(struct snd_soc_card *card,
 	return 0;
 }
 
-static int soc_dai_link_init(struct snd_soc_card *card,
-			     struct snd_soc_codec *codec,
-			     int num)
+static int soc_dai_link_init(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_dai_link *dai_link =  &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
@@ -1325,8 +1323,6 @@ static int soc_dai_link_init(struct snd_soc_card *card,
 			return ret;
 	}
 
-	rtd->codec = codec;
-
 	return 0;
 }
 
@@ -1344,7 +1340,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 		dai_link = &card->dai_link[num];
 		rtd = &card->rtd[num];
 		name = dai_link->name;
-		ret = soc_dai_link_init(card, codec, num);
+		ret = soc_dai_link_init(card, num);
 	} else {
 		aux_dev = &card->aux_dev[num];
 		rtd = &card->rtd_aux[num];

commit 3f901a028feb916d17d6c01b9010f3f56f675d26
Author: Benoit Cousson <bcousson@baylibre.com>
Date:   Tue Jul 1 09:47:54 2014 +0200

    ASoC: core: Change soc_link_dai_widgets signature for multiple codecs
    
    Since multiple codecs DAI will be usable in the future, remove
    explicit unique codec_dai and cpu_dai parameters.
    Replace them with snd_soc_pcm_runtime pointer that will contain
    every instances.
    
    No functionale change.
    
    Signed-off-by: Benoit Cousson <bcousson@baylibre.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b87d7d882e6d..075e0ae5fade 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1450,9 +1450,10 @@ static int soc_probe_codec_dai(struct snd_soc_card *card,
 
 static int soc_link_dai_widgets(struct snd_soc_card *card,
 				struct snd_soc_dai_link *dai_link,
-				struct snd_soc_dai *cpu_dai,
-				struct snd_soc_dai *codec_dai)
+				struct snd_soc_pcm_runtime *rtd)
 {
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct snd_soc_dapm_widget *play_w, *capture_w;
 	int ret;
 
@@ -1570,8 +1571,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 						codec2codec_close_delayed_work);
 
 			/* link the DAI widgets */
-			ret = soc_link_dai_widgets(card, dai_link,
-					cpu_dai, codec_dai);
+			ret = soc_link_dai_widgets(card, dai_link, rtd);
 			if (ret)
 				return ret;
 		}

commit 211bcc6c3af90f3ee1f1297349d9d692e5f1c7e0
Merge: 88a8fe3df65f e73f3de5c5eb
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Jun 28 13:55:22 2014 +0100

    Merge remote-tracking branch 'asoc/fix/debugfs' into asoc-component
    
    Conflicts:
            sound/soc/soc-core.c

commit e73f3de5c5eb5285a1b1d8eed111eb229702b20f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jun 26 15:22:50 2014 +0100

    ASoC: fix debugfs directory creation bug
    
    Avoid creating duplicate directories by prefixing codecs and platforms
    with their separate identifiers.  This avoids snd-soc-dummy (which can
    appear both as a dummy platform and a dummy codec on the same card)
    from clashing.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b87d7d882e6d..91120b8e283e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -270,12 +270,32 @@ static const struct file_operations codec_reg_fops = {
 	.llseek = default_llseek,
 };
 
+static struct dentry *soc_debugfs_create_dir(struct dentry *parent,
+	const char *fmt, ...)
+{
+	struct dentry *de;
+	va_list ap;
+	char *s;
+
+	va_start(ap, fmt);
+	s = kvasprintf(GFP_KERNEL, fmt, ap);
+	va_end(ap);
+
+	if (!s)
+		return NULL;
+
+	de = debugfs_create_dir(s, parent);
+	kfree(s);
+
+	return de;
+}
+
 static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
 	struct dentry *debugfs_card_root = codec->card->debugfs_card_root;
 
-	codec->debugfs_codec_root = debugfs_create_dir(codec->name,
-						       debugfs_card_root);
+	codec->debugfs_codec_root = soc_debugfs_create_dir(debugfs_card_root,
+						"codec:%s", codec->name);
 	if (!codec->debugfs_codec_root) {
 		dev_warn(codec->dev,
 			"ASoC: Failed to create codec debugfs directory\n");
@@ -306,8 +326,8 @@ static void soc_init_platform_debugfs(struct snd_soc_platform *platform)
 {
 	struct dentry *debugfs_card_root = platform->card->debugfs_card_root;
 
-	platform->debugfs_platform_root = debugfs_create_dir(platform->name,
-						       debugfs_card_root);
+	platform->debugfs_platform_root = soc_debugfs_create_dir(debugfs_card_root,
+						"platform:%s", platform->name);
 	if (!platform->debugfs_platform_root) {
 		dev_warn(platform->dev,
 			"ASoC: Failed to create platform debugfs directory\n");

commit 88a8fe3df65fa0229b04f1c03411062230091cdd
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:11 2014 +0200

    ASoC: dapm: Remove platform field from widget and dapm context struct
    
    The platform field in the snd_soc_dapm_widget and snd_soc_dapm_context structs
    is now unused can be removed. New code that wants to get the platform for a
    widget or dapm context should use snd_soc_dapm_to_platform(w->dapm) or
    snd_soc_dapm_to_platform(dapm).
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 995a4b7f87eb..19c1e9588e05 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4159,7 +4159,6 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 
 	platform->dev = dev;
 	platform->driver = platform_drv;
-	platform->component.dapm.platform = platform;
 	if (platform_drv->write)
 		platform->component.write = snd_soc_platform_drv_write;
 	if (platform_drv->read)

commit 9420d97b3f8672478696ae9c3e33051243e1f4a0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:10 2014 +0200

    ASoC: dapm: Remove DAI DAPM context
    
    The DAI DAPM context was added in commit be09ad90 ("ASoC: core: Add platform DAI
    widget mapping") and the only user was removed again in commit ae10e7e8f ("ASoC:
    core: Only add platform DAI widgets once."). Now that we have a per component
    DAPM context it is unlikely that we'll need the DAI DAPM context again.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5fe732fdfd59..995a4b7f87eb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1048,11 +1048,8 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 					cpu_dai->name, err);
 		}
 		cpu_dai->probed = 0;
-
-		if (!cpu_dai->codec) {
-			snd_soc_dapm_free(&cpu_dai->dapm);
+		if (!cpu_dai->codec)
 			module_put(cpu_dai->dev->driver->owner);
-		}
 	}
 }
 
@@ -1510,11 +1507,8 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	if (!cpu_dai->probed &&
 			cpu_dai->driver->probe_order == order) {
 		if (!cpu_dai->codec) {
-			cpu_dai->dapm.card = card;
 			if (!try_module_get(cpu_dai->dev->driver->owner))
 				return -ENODEV;
-
-			list_add(&cpu_dai->dapm.list, &card->dapm_list);
 		}
 
 		if (cpu_dai->driver->probe) {
@@ -3975,13 +3969,9 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 		dai->component = component;
 		dai->dev = dev;
 		dai->driver = &dai_drv[i];
-		dai->dapm.dev = dev;
 		if (!dai->driver->ops)
 			dai->driver->ops = &null_dai_ops;
 
-		if (!dai->codec)
-			dai->dapm.idle_bias_off = 1;
-
 		list_add(&dai->list, &component->dai_list);
 
 		dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);

commit 14e8bdebfbc1d5c8804b3520233b2d4e516056bc
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:08 2014 +0200

    ASoC: Add component level stream_event() and seq_notifier() support
    
    This patch adds stream_event() and seq_notifier() callbacks similar to those
    found in the snd_soc_codec_driver and snd_soc_platform driver struct to the
    snd_soc_component_driver struct. This is meant to unify the handling of these
    callbacks across different types of components and will eventually allow their
    removal from the CODEC and platfrom driver structs.
    
    The new callbacks are slightly different from the old ones in that they take a
    snd_soc_component as a parameter rather than a snd_soc_dapm_context. This was
    done since otherwise casting from the DAPM context to the component would
    typically be the first thing to do in the callback. And the interface becomes
    slightly cleaner by passing a snd_soc_component to all callbacks in the
    snd_soc_component_driver struct.
    
    The patch also already removes the stream_event() callback from the
    snd_soc_codec_driver and snd_soc_platform_driver structs as it is currently
    unused.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 711e99c43be3..5fe732fdfd59 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3995,6 +3995,22 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 	return ret;
 }
 
+static void snd_soc_component_seq_notifier(struct snd_soc_dapm_context *dapm,
+	enum snd_soc_dapm_type type, int subseq)
+{
+	struct snd_soc_component *component = dapm->component;
+
+	component->driver->seq_notifier(component, type, subseq);
+}
+
+static int snd_soc_component_stream_event(struct snd_soc_dapm_context *dapm,
+	int event)
+{
+	struct snd_soc_component *component = dapm->component;
+
+	return component->driver->stream_event(component, event);
+}
+
 static int snd_soc_component_initialize(struct snd_soc_component *component,
 	const struct snd_soc_component_driver *driver, struct device *dev)
 {
@@ -4016,6 +4032,10 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	dapm->dev = dev;
 	dapm->component = component;
 	dapm->bias_level = SND_SOC_BIAS_OFF;
+	if (driver->seq_notifier)
+		dapm->seq_notifier = snd_soc_component_seq_notifier;
+	if (driver->stream_event)
+		dapm->stream_event = snd_soc_component_stream_event;
 
 	INIT_LIST_HEAD(&component->dai_list);
 	mutex_init(&component->io_mutex);
@@ -4150,7 +4170,6 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 	platform->dev = dev;
 	platform->driver = platform_drv;
 	platform->component.dapm.platform = platform;
-	platform->component.dapm.stream_event = platform_drv->stream_event;
 	if (platform_drv->write)
 		platform->component.write = snd_soc_platform_drv_write;
 	if (platform_drv->read)
@@ -4336,8 +4355,8 @@ int snd_soc_register_codec(struct device *dev,
 		codec->component.read = snd_soc_codec_drv_read;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 	codec->dapm.codec = codec;
-	codec->dapm.seq_notifier = codec_drv->seq_notifier;
-	codec->dapm.stream_event = codec_drv->stream_event;
+	if (codec_drv->seq_notifier)
+		codec->dapm.seq_notifier = codec_drv->seq_notifier;
 	if (codec_drv->set_bias_level)
 		codec->dapm.set_bias_level = snd_soc_codec_set_bias_level;
 	codec->dev = dev;

commit bc9af9fa9b89cb74eed020066d882abf238fad69
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:07 2014 +0200

    ASoC: Use component DAPM context for platforms
    
    The snd_soc_platform dapm field is not accessed outside of the ASoC core. Switch
    it over to using the snd_soc_component DAPM context.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f519a9f7571c..711e99c43be3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -314,7 +314,7 @@ static void soc_init_platform_debugfs(struct snd_soc_platform *platform)
 		return;
 	}
 
-	snd_soc_dapm_debugfs_init(&platform->dapm,
+	snd_soc_dapm_debugfs_init(&platform->component.dapm,
 		platform->debugfs_platform_root);
 }
 
@@ -974,7 +974,7 @@ static int soc_remove_platform(struct snd_soc_platform *platform)
 	}
 
 	/* Make sure all DAPM widgets are freed */
-	snd_soc_dapm_free(&platform->dapm);
+	snd_soc_dapm_free(&platform->component.dapm);
 
 	soc_cleanup_platform_debugfs(platform);
 	platform->probed = 0;
@@ -1210,7 +1210,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	struct snd_soc_dai *dai;
 
 	platform->card = card;
-	platform->dapm.card = card;
+	platform->component.dapm.card = card;
 
 	if (!try_module_get(platform->dev->driver->owner))
 		return -ENODEV;
@@ -1218,7 +1218,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	soc_init_platform_debugfs(platform);
 
 	if (driver->dapm_widgets)
-		snd_soc_dapm_new_controls(&platform->dapm,
+		snd_soc_dapm_new_controls(&platform->component.dapm,
 			driver->dapm_widgets, driver->num_dapm_widgets);
 
 	/* Create DAPM widgets for each DAI stream */
@@ -1226,10 +1226,11 @@ static int soc_probe_platform(struct snd_soc_card *card,
 		if (component->dev != platform->dev)
 			continue;
 		list_for_each_entry(dai, &component->dai_list, list)
-			snd_soc_dapm_new_dai_widgets(&platform->dapm, dai);
+			snd_soc_dapm_new_dai_widgets(&platform->component.dapm,
+				dai);
 	}
 
-	platform->dapm.idle_bias_off = 1;
+	platform->component.dapm.idle_bias_off = 1;
 
 	if (driver->probe) {
 		ret = driver->probe(platform);
@@ -1244,13 +1245,13 @@ static int soc_probe_platform(struct snd_soc_card *card,
 		snd_soc_add_platform_controls(platform, driver->controls,
 				     driver->num_controls);
 	if (driver->dapm_routes)
-		snd_soc_dapm_add_routes(&platform->dapm, driver->dapm_routes,
-					driver->num_dapm_routes);
+		snd_soc_dapm_add_routes(&platform->component.dapm,
+			driver->dapm_routes, driver->num_dapm_routes);
 
 	/* mark platform as probed and add to card platform list */
 	platform->probed = 1;
 	list_add(&platform->card_list, &card->platform_dev_list);
-	list_add(&platform->dapm.list, &card->dapm_list);
+	list_add(&platform->component.dapm.list, &card->dapm_list);
 
 	return 0;
 
@@ -4141,8 +4142,6 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 {
 	int ret;
 
-	platform->component.dapm_ptr = &platform->dapm;
-
 	ret = snd_soc_component_initialize(&platform->component,
 			&platform_drv->component_driver, dev);
 	if (ret)
@@ -4150,8 +4149,8 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 
 	platform->dev = dev;
 	platform->driver = platform_drv;
-	platform->dapm.platform = platform;
-	platform->dapm.stream_event = platform_drv->stream_event;
+	platform->component.dapm.platform = platform;
+	platform->component.dapm.stream_event = platform_drv->stream_event;
 	if (platform_drv->write)
 		platform->component.write = snd_soc_platform_drv_write;
 	if (platform_drv->read)

commit ce0fc93ae56e2ba50ff8c220d69e4e860e889320
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:06 2014 +0200

    ASoC: Add DAPM support at the component level
    
    This patch adds full DAPM support at the component level. Previously there was
    only full DAPM support for CODECs and partial DAPM support (e.g. no Mixers nor
    MUXs) for platforms. Having DAPM support at the component level will allow all
    types of components to use DAPM and also help in consolidating the DAPM support
    between CODECs and platforms.
    
    Since the DAPM context is directly embedded into the snd_soc_codec and
    snd_soc_platform struct and the 'dapm' field is directly referenced in a lot of
    drivers moving the field just right now is not possible without causing code
    churn. The approach this patch takes is to add two new fields to the component
    struct. One field which is the pointer to the actual DAPM context used by the
    component and one DAPM context that will be used as the default if no other
    context was specified. For CODECs and platforms the pointer is initialized to
    point to the CODEC or platform DAPM context. All generic code when referencing
    a component's DAPM struct will go via the pointer. This will make it possible to
    eventually seamlessly move the DAPM context from snd_soc_codec and
    snd_soc_platform struct over once all direct references have been eliminated.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 10e13c43bc54..f519a9f7571c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3997,6 +3997,8 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 static int snd_soc_component_initialize(struct snd_soc_component *component,
 	const struct snd_soc_component_driver *driver, struct device *dev)
 {
+	struct snd_soc_dapm_context *dapm;
+
 	component->name = fmt_single_name(dev, &component->id);
 	if (!component->name) {
 		dev_err(dev, "ASoC: Failed to allocate name\n");
@@ -4006,6 +4008,14 @@ static int snd_soc_component_initialize(struct snd_soc_component *component,
 	component->dev = dev;
 	component->driver = driver;
 
+	if (!component->dapm_ptr)
+		component->dapm_ptr = &component->dapm;
+
+	dapm = component->dapm_ptr;
+	dapm->dev = dev;
+	dapm->component = component;
+	dapm->bias_level = SND_SOC_BIAS_OFF;
+
 	INIT_LIST_HEAD(&component->dai_list);
 	mutex_init(&component->io_mutex);
 
@@ -4131,6 +4141,8 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 {
 	int ret;
 
+	platform->component.dapm_ptr = &platform->dapm;
+
 	ret = snd_soc_component_initialize(&platform->component,
 			&platform_drv->component_driver, dev);
 	if (ret)
@@ -4138,9 +4150,7 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 
 	platform->dev = dev;
 	platform->driver = platform_drv;
-	platform->dapm.dev = dev;
 	platform->dapm.platform = platform;
-	platform->dapm.component = &platform->component;
 	platform->dapm.stream_event = platform_drv->stream_event;
 	if (platform_drv->write)
 		platform->component.write = snd_soc_platform_drv_write;
@@ -4314,6 +4324,8 @@ int snd_soc_register_codec(struct device *dev,
 	if (codec == NULL)
 		return -ENOMEM;
 
+	codec->component.dapm_ptr = &codec->dapm;
+
 	ret = snd_soc_component_initialize(&codec->component,
 			&codec_drv->component_driver, dev);
 	if (ret)
@@ -4324,10 +4336,7 @@ int snd_soc_register_codec(struct device *dev,
 	if (codec_drv->read)
 		codec->component.read = snd_soc_codec_drv_read;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
-	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
-	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;
-	codec->dapm.component = &codec->component;
 	codec->dapm.seq_notifier = codec_drv->seq_notifier;
 	codec->dapm.stream_event = codec_drv->stream_event;
 	if (codec_drv->set_bias_level)

commit 68f831c2724ab72c0088471b2ed1dc99e81948ef
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:05 2014 +0200

    ASoC: Add a set_bias_level() callback to the DAPM context struct
    
    Currently the DAPM code directly looks at the CODEC driver struct to get a
    handle to the set_bias_level() callback. This patch adds a new set_bias_level()
    callback to the DAPM context struct. The DAPM code will use this new callback
    instead of the CODEC callback. For CODECs the new callback is set up to call the
    CODEC specific set_bias_level callback(). Not looking directly at the CODEC
    driver struct will allow non CODEC DAPM contexts to implement a set_bias_level()
    callback.
    
    This is also similar to how the seq_notifier() and stream_event() callbacks are
    currently handled.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bca8a7150a4a..10e13c43bc54 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4285,6 +4285,14 @@ static int snd_soc_codec_drv_read(struct snd_soc_component *component,
 	return 0;
 }
 
+static int snd_soc_codec_set_bias_level(struct snd_soc_dapm_context *dapm,
+	enum snd_soc_bias_level level)
+{
+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(dapm);
+
+	return codec->driver->set_bias_level(codec, level);
+}
+
 /**
  * snd_soc_register_codec - Register a codec with the ASoC core
  *
@@ -4322,6 +4330,8 @@ int snd_soc_register_codec(struct device *dev,
 	codec->dapm.component = &codec->component;
 	codec->dapm.seq_notifier = codec_drv->seq_notifier;
 	codec->dapm.stream_event = codec_drv->stream_event;
+	if (codec_drv->set_bias_level)
+		codec->dapm.set_bias_level = snd_soc_codec_set_bias_level;
 	codec->dev = dev;
 	codec->driver = codec_drv;
 	codec->component.val_bytes = codec_drv->reg_word_size;

commit 7df3788410e674423375b88e2d95c46e4015f5f5
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:04 2014 +0200

    ASoC: Auto disconnect pins from all DAPM contexts
    
    Currently only pins in CODEC DAPM contexts are automatically marked as
    non-connected if the card has the fully_routed flag set. This makes sense since
    widgets which qualify for auto-disconnection are only found in CODEC DAPM
    contexts. But with componentisation this is going to change, so consider all
    widgets for auto-disconnection.
    
    Also it is probably faster to walk the widgets list only once rather than once
    for each CODEC.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0944da66538d..bca8a7150a4a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1928,8 +1928,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	if (card->fully_routed)
-		list_for_each_entry(codec, &card->codec_dev_list, card_list)
-			snd_soc_dapm_auto_nc_codec_pins(codec);
+		snd_soc_dapm_auto_nc_pins(card);
 
 	snd_soc_dapm_new_widgets(card);
 

commit bb13109d85ba5f8009f1a26d840e70198537a4e3
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:03 2014 +0200

    ASoC: Split component registration into two steps
    
    Split snd_soc_component_register() into snd_soc_component_initialize() and
    snd_soc_component_add(). Using a 2-stage registration approach has the advantage
    that it is possible to modify the component after it has been initialized, but
    before it is made visible to the system. This e.g. allows CODECs or platforms to
    overwrite some of the default settings made in snd_soc_component_initialize().
    
    Similar snd_soc_component_unregister() is split into two steps as well,
    snd_soc_component_delete(), which removes the component from the system, and
    snd_soc_component_cleanup(), which frees all the resources allocated by the
    component.
    
    Furthermore this patch makes sure that if a component is visible on two list
    (e.g. the component list and the CODEC list) it is added or removed to both
    lists atomically.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b8cc88a9f947..0944da66538d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3922,16 +3922,14 @@ static void snd_soc_unregister_dais(struct snd_soc_component *component)
  * snd_soc_register_dais - Register a DAI with the ASoC core
  *
  * @component: The component the DAIs are registered for
- * @codec: The CODEC that the DAIs are registered for, NULL if the component is
- *         not a CODEC.
  * @dai_drv: DAI driver to use for the DAIs
  * @count: Number of DAIs
  * @legacy_dai_naming: Use the legacy naming scheme and let the DAI inherit the
  *                     parent's name.
  */
 static int snd_soc_register_dais(struct snd_soc_component *component,
-	struct snd_soc_codec *codec, struct snd_soc_dai_driver *dai_drv,
-	size_t count, bool legacy_dai_naming)
+	struct snd_soc_dai_driver *dai_drv, size_t count,
+	bool legacy_dai_naming)
 {
 	struct device *dev = component->dev;
 	struct snd_soc_dai *dai;
@@ -3940,6 +3938,9 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 
 	dev_dbg(dev, "ASoC: dai register %s #%Zu\n", dev_name(dev), count);
 
+	component->dai_drv = dai_drv;
+	component->num_dai = count;
+
 	for (i = 0; i < count; i++) {
 
 		dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
@@ -3972,7 +3973,6 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 		}
 
 		dai->component = component;
-		dai->codec = codec;
 		dai->dev = dev;
 		dai->driver = &dai_drv[i];
 		dai->dapm.dev = dev;
@@ -3995,60 +3995,52 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 	return ret;
 }
 
-/**
- * snd_soc_register_component - Register a component with the ASoC core
- *
- */
-static int
-__snd_soc_register_component(struct device *dev,
-			     struct snd_soc_component *cmpnt,
-			     const struct snd_soc_component_driver *cmpnt_drv,
-			     struct snd_soc_codec *codec,
-			     struct snd_soc_dai_driver *dai_drv,
-			     int num_dai, bool allow_single_dai)
+static int snd_soc_component_initialize(struct snd_soc_component *component,
+	const struct snd_soc_component_driver *driver, struct device *dev)
 {
-	int ret;
-
-	dev_dbg(dev, "component register %s\n", dev_name(dev));
-
-	if (!cmpnt) {
-		dev_err(dev, "ASoC: Failed to connecting component\n");
+	component->name = fmt_single_name(dev, &component->id);
+	if (!component->name) {
+		dev_err(dev, "ASoC: Failed to allocate name\n");
 		return -ENOMEM;
 	}
 
-	mutex_init(&cmpnt->io_mutex);
+	component->dev = dev;
+	component->driver = driver;
 
-	cmpnt->name = fmt_single_name(dev, &cmpnt->id);
-	if (!cmpnt->name) {
-		dev_err(dev, "ASoC: Failed to simplifying name\n");
-		return -ENOMEM;
-	}
+	INIT_LIST_HEAD(&component->dai_list);
+	mutex_init(&component->io_mutex);
 
-	cmpnt->dev	= dev;
-	cmpnt->driver	= cmpnt_drv;
-	cmpnt->dai_drv	= dai_drv;
-	cmpnt->num_dai	= num_dai;
-	INIT_LIST_HEAD(&cmpnt->dai_list);
+	return 0;
+}
 
-	ret = snd_soc_register_dais(cmpnt, codec, dai_drv, num_dai,
-		allow_single_dai);
-	if (ret < 0) {
-		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
-		goto error_component_name;
-	}
+static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
+{
+	list_add(&component->list, &component_list);
+}
 
+static void snd_soc_component_add(struct snd_soc_component *component)
+{
 	mutex_lock(&client_mutex);
-	list_add(&cmpnt->list, &component_list);
+	snd_soc_component_add_unlocked(component);
 	mutex_unlock(&client_mutex);
+}
 
-	dev_dbg(cmpnt->dev, "ASoC: Registered component '%s'\n", cmpnt->name);
-
-	return ret;
+static void snd_soc_component_cleanup(struct snd_soc_component *component)
+{
+	snd_soc_unregister_dais(component);
+	kfree(component->name);
+}
 
-error_component_name:
-	kfree(cmpnt->name);
+static void snd_soc_component_del_unlocked(struct snd_soc_component *component)
+{
+	list_del(&component->list);
+}
 
-	return ret;
+static void snd_soc_component_del(struct snd_soc_component *component)
+{
+	mutex_lock(&client_mutex);
+	snd_soc_component_del_unlocked(component);
+	mutex_unlock(&client_mutex);
 }
 
 int snd_soc_register_component(struct device *dev,
@@ -4057,32 +4049,38 @@ int snd_soc_register_component(struct device *dev,
 			       int num_dai)
 {
 	struct snd_soc_component *cmpnt;
+	int ret;
 
-	cmpnt = devm_kzalloc(dev, sizeof(*cmpnt), GFP_KERNEL);
+	cmpnt = kzalloc(sizeof(*cmpnt), GFP_KERNEL);
 	if (!cmpnt) {
 		dev_err(dev, "ASoC: Failed to allocate memory\n");
 		return -ENOMEM;
 	}
 
+	ret = snd_soc_component_initialize(cmpnt, cmpnt_drv, dev);
+	if (ret)
+		goto err_free;
+
 	cmpnt->ignore_pmdown_time = true;
 	cmpnt->registered_as_component = true;
 
-	return __snd_soc_register_component(dev, cmpnt, cmpnt_drv, NULL,
-					    dai_drv, num_dai, true);
-}
-EXPORT_SYMBOL_GPL(snd_soc_register_component);
+	ret = snd_soc_register_dais(cmpnt, dai_drv, num_dai, true);
+	if (ret < 0) {
+		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
+		goto err_cleanup;
+	}
 
-static void __snd_soc_unregister_component(struct snd_soc_component *cmpnt)
-{
-	snd_soc_unregister_dais(cmpnt);
+	snd_soc_component_add(cmpnt);
 
-	mutex_lock(&client_mutex);
-	list_del(&cmpnt->list);
-	mutex_unlock(&client_mutex);
+	return 0;
 
-	dev_dbg(cmpnt->dev, "ASoC: Unregistered component '%s'\n", cmpnt->name);
-	kfree(cmpnt->name);
+err_cleanup:
+	snd_soc_component_cleanup(cmpnt);
+err_free:
+	kfree(cmpnt);
+	return ret;
 }
+EXPORT_SYMBOL_GPL(snd_soc_register_component);
 
 /**
  * snd_soc_unregister_component - Unregister a component from the ASoC core
@@ -4099,7 +4097,9 @@ void snd_soc_unregister_component(struct device *dev)
 	return;
 
 found:
-	__snd_soc_unregister_component(cmpnt);
+	snd_soc_component_del(cmpnt);
+	snd_soc_component_cleanup(cmpnt);
+	kfree(cmpnt);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
@@ -4132,6 +4132,11 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 {
 	int ret;
 
+	ret = snd_soc_component_initialize(&platform->component,
+			&platform_drv->component_driver, dev);
+	if (ret)
+		return ret;
+
 	platform->dev = dev;
 	platform->driver = platform_drv;
 	platform->dapm.dev = dev;
@@ -4143,17 +4148,8 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 	if (platform_drv->read)
 		platform->component.read = snd_soc_platform_drv_read;
 
-	/* register component */
-	ret = __snd_soc_register_component(dev, &platform->component,
-					   &platform_drv->component_driver,
-					   NULL, NULL, 0, false);
-	if (ret < 0) {
-		dev_err(platform->component.dev,
-			"ASoC: Failed to register component: %d\n", ret);
-		return ret;
-	}
-
 	mutex_lock(&client_mutex);
+	snd_soc_component_add_unlocked(&platform->component);
 	list_add(&platform->list, &platform_list);
 	mutex_unlock(&client_mutex);
 
@@ -4195,12 +4191,14 @@ EXPORT_SYMBOL_GPL(snd_soc_register_platform);
  */
 void snd_soc_remove_platform(struct snd_soc_platform *platform)
 {
-	__snd_soc_unregister_component(&platform->component);
 
 	mutex_lock(&client_mutex);
 	list_del(&platform->list);
+	snd_soc_component_del_unlocked(&platform->component);
 	mutex_unlock(&client_mutex);
 
+	snd_soc_component_cleanup(&platform->component);
+
 	dev_dbg(platform->dev, "ASoC: Unregistered platform '%s'\n",
 		platform->component.name);
 }
@@ -4299,6 +4297,7 @@ int snd_soc_register_codec(struct device *dev,
 			   int num_dai)
 {
 	struct snd_soc_codec *codec;
+	struct snd_soc_dai *dai;
 	struct regmap *regmap;
 	int ret, i;
 
@@ -4308,6 +4307,11 @@ int snd_soc_register_codec(struct device *dev,
 	if (codec == NULL)
 		return -ENOMEM;
 
+	ret = snd_soc_component_initialize(&codec->component,
+			&codec_drv->component_driver, dev);
+	if (ret)
+		goto err_free;
+
 	if (codec_drv->write)
 		codec->component.write = snd_soc_codec_drv_write;
 	if (codec_drv->read)
@@ -4337,7 +4341,7 @@ int snd_soc_register_codec(struct device *dev,
 				dev_err(codec->dev,
 						"Failed to set cache I/O:%d\n",
 						ret);
-				return ret;
+				goto err_cleanup;
 			}
 		}
 	}
@@ -4347,27 +4351,27 @@ int snd_soc_register_codec(struct device *dev,
 		fixup_codec_formats(&dai_drv[i].capture);
 	}
 
+	ret = snd_soc_register_dais(&codec->component, dai_drv, num_dai, false);
+	if (ret < 0) {
+		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
+		goto err_cleanup;
+	}
+
+	list_for_each_entry(dai, &codec->component.dai_list, list)
+		dai->codec = codec;
+
 	mutex_lock(&client_mutex);
+	snd_soc_component_add_unlocked(&codec->component);
 	list_add(&codec->list, &codec_list);
 	mutex_unlock(&client_mutex);
 
-	/* register component */
-	ret = __snd_soc_register_component(dev, &codec->component,
-					   &codec_drv->component_driver,
-					   codec, dai_drv, num_dai, false);
-	if (ret < 0) {
-		dev_err(codec->dev, "ASoC: Failed to regster component: %d\n", ret);
-		goto fail_codec;
-	}
-
 	dev_dbg(codec->dev, "ASoC: Registered codec '%s'\n",
 		codec->component.name);
 	return 0;
 
-fail_codec:
-	mutex_lock(&client_mutex);
-	list_del(&codec->list);
-	mutex_unlock(&client_mutex);
+err_cleanup:
+	snd_soc_component_cleanup(&codec->component);
+err_free:
 	kfree(codec);
 	return ret;
 }
@@ -4389,15 +4393,16 @@ void snd_soc_unregister_codec(struct device *dev)
 	return;
 
 found:
-	__snd_soc_unregister_component(&codec->component);
 
 	mutex_lock(&client_mutex);
 	list_del(&codec->list);
+	snd_soc_component_del_unlocked(&codec->component);
 	mutex_unlock(&client_mutex);
 
 	dev_dbg(codec->dev, "ASoC: Unregistered codec '%s'\n",
 			codec->component.name);
 
+	snd_soc_component_cleanup(&codec->component);
 	snd_soc_cache_exit(codec);
 	kfree(codec);
 }

commit f4333203ec933f9272c90c7add01774ec2cf94d3
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:02 2014 +0200

    ASoC: Move name and id from CODEC/platform to component
    
    The component struct already has a name and id field which are initialized to
    the same values as the same fields in the CODEC and platform structs. So remove
    them from the CODEC and platform structs and used the ones from the component
    struct instead.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ba822e927187..b8cc88a9f947 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -274,7 +274,7 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
 	struct dentry *debugfs_card_root = codec->card->debugfs_card_root;
 
-	codec->debugfs_codec_root = debugfs_create_dir(codec->name,
+	codec->debugfs_codec_root = debugfs_create_dir(codec->component.name,
 						       debugfs_card_root);
 	if (!codec->debugfs_codec_root) {
 		dev_warn(codec->dev,
@@ -306,8 +306,8 @@ static void soc_init_platform_debugfs(struct snd_soc_platform *platform)
 {
 	struct dentry *debugfs_card_root = platform->card->debugfs_card_root;
 
-	platform->debugfs_platform_root = debugfs_create_dir(platform->name,
-						       debugfs_card_root);
+	platform->debugfs_platform_root = debugfs_create_dir(
+		platform->component.name, debugfs_card_root);
 	if (!platform->debugfs_platform_root) {
 		dev_warn(platform->dev,
 			"ASoC: Failed to create platform debugfs directory\n");
@@ -335,7 +335,7 @@ static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
 
 	list_for_each_entry(codec, &codec_list, list) {
 		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
-			       codec->name);
+			       codec->component.name);
 		if (len >= 0)
 			ret += len;
 		if (ret > PAGE_SIZE) {
@@ -406,7 +406,7 @@ static ssize_t platform_list_read_file(struct file *file,
 
 	list_for_each_entry(platform, &platform_list, list) {
 		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
-			       platform->name);
+			       platform->component.name);
 		if (len >= 0)
 			ret += len;
 		if (ret > PAGE_SIZE) {
@@ -528,7 +528,7 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 	codec->ac97->dev.release = soc_ac97_device_release;
 
 	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
-		     codec->card->snd_card->number, 0, codec->name);
+		     codec->card->snd_card->number, 0, codec->component.name);
 	err = device_register(&codec->ac97->dev);
 	if (err < 0) {
 		dev_err(codec->dev, "ASoC: Can't register ac97 bus\n");
@@ -857,7 +857,7 @@ static struct snd_soc_codec *soc_find_codec(const struct device_node *codec_of_n
 			if (codec->dev->of_node != codec_of_node)
 				continue;
 		} else {
-			if (strcmp(codec->name, codec_name))
+			if (strcmp(codec->component.name, codec_name))
 				continue;
 		}
 
@@ -945,7 +945,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 			    dai_link->platform_of_node)
 				continue;
 		} else {
-			if (strcmp(platform->name, platform_name))
+			if (strcmp(platform->component.name, platform_name))
 				continue;
 		}
 
@@ -1177,7 +1177,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 		WARN(codec->dapm.idle_bias_off &&
 			codec->dapm.bias_level != SND_SOC_BIAS_OFF,
 			"codec %s can not start from non-off bias with idle_bias_off==1\n",
-			codec->name);
+			codec->component.name);
 	}
 
 	if (driver->controls)
@@ -1647,7 +1647,8 @@ static struct snd_soc_codec *soc_find_matching_codec(struct snd_soc_card *card,
 		if (aux_dev->codec_of_node &&
 		   (codec->dev->of_node != aux_dev->codec_of_node))
 			continue;
-		if (aux_dev->codec_name && strcmp(codec->name, aux_dev->codec_name))
+		if (aux_dev->codec_name &&
+			strcmp(codec->component.name, aux_dev->codec_name))
 			continue;
 		return codec;
 	}
@@ -4131,11 +4132,6 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 {
 	int ret;
 
-	/* create platform component name */
-	platform->name = fmt_single_name(dev, &platform->id);
-	if (platform->name == NULL)
-		return -ENOMEM;
-
 	platform->dev = dev;
 	platform->driver = platform_drv;
 	platform->dapm.dev = dev;
@@ -4161,7 +4157,8 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 	list_add(&platform->list, &platform_list);
 	mutex_unlock(&client_mutex);
 
-	dev_dbg(dev, "ASoC: Registered platform '%s'\n", platform->name);
+	dev_dbg(dev, "ASoC: Registered platform '%s'\n",
+		platform->component.name);
 
 	return 0;
 }
@@ -4205,8 +4202,7 @@ void snd_soc_remove_platform(struct snd_soc_platform *platform)
 	mutex_unlock(&client_mutex);
 
 	dev_dbg(platform->dev, "ASoC: Unregistered platform '%s'\n",
-		platform->name);
-	kfree(platform->name);
+		platform->component.name);
 }
 EXPORT_SYMBOL_GPL(snd_soc_remove_platform);
 
@@ -4312,13 +4308,6 @@ int snd_soc_register_codec(struct device *dev,
 	if (codec == NULL)
 		return -ENOMEM;
 
-	/* create CODEC component name */
-	codec->name = fmt_single_name(dev, &codec->id);
-	if (codec->name == NULL) {
-		ret = -ENOMEM;
-		goto fail_codec;
-	}
-
 	if (codec_drv->write)
 		codec->component.write = snd_soc_codec_drv_write;
 	if (codec_drv->read)
@@ -4368,19 +4357,17 @@ int snd_soc_register_codec(struct device *dev,
 					   codec, dai_drv, num_dai, false);
 	if (ret < 0) {
 		dev_err(codec->dev, "ASoC: Failed to regster component: %d\n", ret);
-		goto fail_codec_name;
+		goto fail_codec;
 	}
 
-	dev_dbg(codec->dev, "ASoC: Registered codec '%s'\n", codec->name);
+	dev_dbg(codec->dev, "ASoC: Registered codec '%s'\n",
+		codec->component.name);
 	return 0;
 
-fail_codec_name:
+fail_codec:
 	mutex_lock(&client_mutex);
 	list_del(&codec->list);
 	mutex_unlock(&client_mutex);
-
-	kfree(codec->name);
-fail_codec:
 	kfree(codec);
 	return ret;
 }
@@ -4408,10 +4395,10 @@ void snd_soc_unregister_codec(struct device *dev)
 	list_del(&codec->list);
 	mutex_unlock(&client_mutex);
 
-	dev_dbg(codec->dev, "ASoC: Unregistered codec '%s'\n", codec->name);
+	dev_dbg(codec->dev, "ASoC: Unregistered codec '%s'\n",
+			codec->component.name);
 
 	snd_soc_cache_exit(codec);
-	kfree(codec->name);
 	kfree(codec);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);

commit 94f99c875c109e51decf0d8c25ec2c946db20c56
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 16 18:13:01 2014 +0200

    ASoC: Move name_prefix from CODEC to component
    
    Move the name_prefix from the CODEC struct to the component struct. This will
    eventually allow to specify prefixes for all types of components. It is also
    necessary to make the DAPM code component type independent (i.e. a DAPM context
    does not need to know whether it belongs to a CODEC or a platform or something
    else).
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b87d7d882e6d..ba822e927187 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1108,7 +1108,7 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 }
 
 static void soc_set_name_prefix(struct snd_soc_card *card,
-				struct snd_soc_codec *codec)
+				struct snd_soc_component *component)
 {
 	int i;
 
@@ -1117,11 +1117,11 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 
 	for (i = 0; i < card->num_configs; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
-		if (map->of_node && codec->dev->of_node != map->of_node)
+		if (map->of_node && component->dev->of_node != map->of_node)
 			continue;
-		if (map->dev_name && strcmp(codec->name, map->dev_name))
+		if (map->dev_name && strcmp(component->name, map->dev_name))
 			continue;
-		codec->name_prefix = map->name_prefix;
+		component->name_prefix = map->name_prefix;
 		break;
 	}
 }
@@ -1135,7 +1135,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 
 	codec->card = card;
 	codec->dapm.card = card;
-	soc_set_name_prefix(card, codec);
+	soc_set_name_prefix(card, &codec->component);
 
 	if (!try_module_get(codec->dev->driver->owner))
 		return -ENODEV;
@@ -2403,7 +2403,7 @@ int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
 	struct snd_card *card = codec->card->snd_card;
 
 	return snd_soc_add_controls(card, codec->dev, controls, num_controls,
-			codec->name_prefix, &codec->component);
+			codec->component.name_prefix, &codec->component);
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
 

commit 04f87446c2cf2cadb17eaad6c789d75177179743
Merge: 6f821c644966 c1406846e4e1 1d55417e1279 63e54cd9caa3 7b6ad9e85bad 781cbebed750 b87704cef258 7c2fcccc3239 e9382e3b7a04
Author: Mark Brown <broonie@linaro.org>
Date:   Thu May 22 00:24:00 2014 +0100

    Merge remote-tracking branches 'asoc/topic/rt5651', 'asoc/topic/samsung', 'asoc/topic/sgtl5000', 'asoc/topic/sh', 'asoc/topic/simple', 'asoc/topic/sirf', 'asoc/topic/sta350' and 'asoc/topic/tlv320dac33' into asoc-next

commit 6630f30ed5e4d7f9fae9c7d63364225790765aef
Merge: 3a6a489fd869 ee5e4534f7b3 2fa190ce33bd 0aa2a15a7b5c a735d992c2e7 c4839c87f508 780aaeff9681 7b4a469e583f
Author: Mark Brown <broonie@linaro.org>
Date:   Thu May 22 00:23:54 2014 +0100

    Merge remote-tracking branches 'asoc/topic/headers', 'asoc/topic/intel', 'asoc/topic/jz4740', 'asoc/topic/max98090', 'asoc/topic/max98095', 'asoc/topic/mc13783' and 'asoc/topic/multicodec' into asoc-next

commit 566d4eeff85a8112dddab9d455322e1fcf5defe7
Merge: 8e8fbd8f5838 6b0a0b3b4e5c
Author: Mark Brown <broonie@linaro.org>
Date:   Thu May 22 00:23:43 2014 +0100

    Merge remote-tracking branch 'asoc/topic/dt' into asoc-next

commit db88a8e3ca38b840c768e65a3ddb952cf1bf258f
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue May 6 09:39:39 2014 +0200

    ASoC: Remove unused num_dai field from CODEC
    
    Commit d191bd8de8 ("ASoC: snd_soc_codec includes snd_soc_component") removed the
    last user of the num_dai field. Also remove the field itself.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0a2c0720fc2d..a675eec64756 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4277,7 +4277,6 @@ int snd_soc_register_codec(struct device *dev,
 	codec->dapm.stream_event = codec_drv->stream_event;
 	codec->dev = dev;
 	codec->driver = codec_drv;
-	codec->num_dai = num_dai;
 	codec->component.val_bytes = codec_drv->reg_word_size;
 	mutex_init(&codec->mutex);
 

commit af0881ffbd7bfc825c2871c79798d66e3608a50c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue May 6 09:39:38 2014 +0200

    ASoC: Remove unused 'list' field form card
    
    The global card list was removed in commit b19e6e7b7 ("ASoC: core: Use driver
    core probe deferral"). The 'list' field of the snd_soc_card struct has been
    unused since then. This patch removes the field.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ada7cbc9fb94..0a2c0720fc2d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3745,7 +3745,6 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_links; i++)
 		card->rtd[i].dai_link = &card->dai_link[i];
 
-	INIT_LIST_HEAD(&card->list);
 	INIT_LIST_HEAD(&card->dapm_dirty);
 	card->instantiated = 0;
 	mutex_init(&card->mutex);

commit 24faf7656800afa0e0d882f950502c5c03f4b7f0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue May 6 09:39:37 2014 +0200

    ASoC: Remove card's DAI list
    
    Commit f0fba2ad1 ("ASoC: multi-component - ASoC Multi-Component Support") added
    a per card list that keeps track of all the DAIs that have been registered with
    the card, but the list has never been used. This patch removes it again.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 520d2489d23c..ada7cbc9fb94 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1017,7 +1017,6 @@ static void soc_remove_codec_dai(struct snd_soc_dai *codec_dai, int order)
 					codec_dai->name, err);
 		}
 		codec_dai->probed = 0;
-		list_del(&codec_dai->card_list);
 	}
 }
 
@@ -1049,7 +1048,6 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 					cpu_dai->name, err);
 		}
 		cpu_dai->probed = 0;
-		list_del(&cpu_dai->card_list);
 
 		if (!cpu_dai->codec) {
 			snd_soc_dapm_free(&cpu_dai->dapm);
@@ -1405,7 +1403,6 @@ static int soc_probe_codec_dai(struct snd_soc_card *card,
 
 		/* mark codec_dai as probed and add to card dai list */
 		codec_dai->probed = 1;
-		list_add(&codec_dai->card_list, &card->dai_dev_list);
 	}
 
 	return 0;
@@ -1490,8 +1487,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 			}
 		}
 		cpu_dai->probed = 1;
-		/* mark cpu_dai as probed and add to card dai list */
-		list_add(&cpu_dai->card_list, &card->dai_dev_list);
 	}
 
 	/* probe the CODEC DAI */

commit 387f837b3d9f9a989ae9a6deab543e1948b58ce8
Merge: d98812082c87 4da533932ded
Author: Mark Brown <broonie@linaro.org>
Date:   Wed May 7 10:21:22 2014 +0100

    Merge branch 'topic/component' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-core

commit 6b0a0b3b4e5c8510d88824310691e47e694dd35a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun May 4 19:18:30 2014 +0200

    ASoC: Make soc_find_matching_codec() static
    
    The function is only used locally, make it static.
    
    Fixes the following warning from sparse:
            sound/soc/soc-core.c:1644:22: warning: symbol 'soc_find_matching_codec' was not declared. Should it be static?
    
    Fixes: 3ca041ed ("ASoC: dt: Allow Aux Codecs to be specified using DT")
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-By: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 448a60748523..199eb51d4614 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1543,7 +1543,8 @@ static void soc_unregister_ac97_dai_link(struct snd_soc_codec *codec)
 }
 #endif
 
-struct snd_soc_codec *soc_find_matching_codec(struct snd_soc_card *card, int num)
+static struct snd_soc_codec *soc_find_matching_codec(struct snd_soc_card *card,
+	int num)
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	struct snd_soc_codec *codec;

commit d98812082c87732b45c71d63afc6a9ba3cca3f03
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Fri May 2 10:58:11 2014 +0530

    ASoC: add SND_SOC_BYTES_EXT
    
    we need _EXT version for SND_SOC_BYTES so that DSPs can use this to pass data
    for DSP modules
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 799cbe81fe39..7fa3b4a04bd3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3107,6 +3107,18 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_bytes_put);
 
+int snd_soc_bytes_info_ext(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *ucontrol)
+{
+	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
+
+	ucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	ucontrol->count = params->max;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_bytes_info_ext);
+
 /**
  * snd_soc_info_xr_sx - signed multi register info callback
  * @kcontrol: mreg control

commit 3ca041ed04734c1709460184f985f5451a813d69
Author: Sebastian Reichel <sre@kernel.org>
Date:   Mon Apr 28 16:07:22 2014 +0200

    ASoC: dt: Allow Aux Codecs to be specified using DT
    
    This patch adds support for specifying auxiliary codecs and
    codec configuration via device tree phandles.
    
    This change adds new fields to snd_soc_aux_dev and snd_soc_codec_conf
    and adds support for the changes to SoC core methods.
    
    Signed-off-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006281f5..448a60748523 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1104,10 +1104,12 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 
 	for (i = 0; i < card->num_configs; i++) {
 		struct snd_soc_codec_conf *map = &card->codec_conf[i];
-		if (map->dev_name && !strcmp(codec->name, map->dev_name)) {
-			codec->name_prefix = map->name_prefix;
-			break;
-		}
+		if (map->of_node && codec->dev->of_node != map->of_node)
+			continue;
+		if (map->dev_name && strcmp(codec->name, map->dev_name))
+			continue;
+		codec->name_prefix = map->name_prefix;
+		break;
 	}
 }
 
@@ -1541,52 +1543,66 @@ static void soc_unregister_ac97_dai_link(struct snd_soc_codec *codec)
 }
 #endif
 
-static int soc_check_aux_dev(struct snd_soc_card *card, int num)
+struct snd_soc_codec *soc_find_matching_codec(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	struct snd_soc_codec *codec;
 
-	/* find CODEC from registered CODECs*/
+	/* find CODEC from registered CODECs */
 	list_for_each_entry(codec, &codec_list, list) {
-		if (!strcmp(codec->name, aux_dev->codec_name))
-			return 0;
+		if (aux_dev->codec_of_node &&
+		   (codec->dev->of_node != aux_dev->codec_of_node))
+			continue;
+		if (aux_dev->codec_name && strcmp(codec->name, aux_dev->codec_name))
+			continue;
+		return codec;
 	}
 
-	dev_err(card->dev, "ASoC: %s not registered\n", aux_dev->codec_name);
+	return NULL;
+}
+
+static int soc_check_aux_dev(struct snd_soc_card *card, int num)
+{
+	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
+	const char *codecname = aux_dev->codec_name;
+	struct snd_soc_codec *codec = soc_find_matching_codec(card, num);
 
+	if (codec)
+		return 0;
+	if (aux_dev->codec_of_node)
+		codecname = of_node_full_name(aux_dev->codec_of_node);
+
+	dev_err(card->dev, "ASoC: %s not registered\n", codecname);
 	return -EPROBE_DEFER;
 }
 
 static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
-	struct snd_soc_codec *codec;
+	const char *codecname = aux_dev->codec_name;
 	int ret = -ENODEV;
+	struct snd_soc_codec *codec = soc_find_matching_codec(card, num);
 
-	/* find CODEC from registered CODECs*/
-	list_for_each_entry(codec, &codec_list, list) {
-		if (!strcmp(codec->name, aux_dev->codec_name)) {
-			if (codec->probed) {
-				dev_err(codec->dev,
-					"ASoC: codec already probed");
-				ret = -EBUSY;
-				goto out;
-			}
-			goto found;
-		}
+	if (!codec) {
+		if (aux_dev->codec_of_node)
+			codecname = of_node_full_name(aux_dev->codec_of_node);
+
+		/* codec not found */
+		dev_err(card->dev, "ASoC: codec %s not found", codecname);
+		return -EPROBE_DEFER;
+	}
+
+	if (codec->probed) {
+		dev_err(codec->dev, "ASoC: codec already probed");
+		return -EBUSY;
 	}
-	/* codec not found */
-	dev_err(card->dev, "ASoC: codec %s not found", aux_dev->codec_name);
-	return -EPROBE_DEFER;
 
-found:
 	ret = soc_probe_codec(card, codec);
 	if (ret < 0)
 		return ret;
 
 	ret = soc_post_component_init(card, codec, num, 1);
 
-out:
 	return ret;
 }
 

commit 4da533932dedff930596bc536adaba1e508f9ffa
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Apr 28 15:30:51 2014 +0300

    ASoC: core: Fix component_list corruption when unloading modules
    
    This fixes module unload regressions introduced by commits 98e639fb8a3e
    ("ASoC: Track which components have been registered with
    snd_soc_register_component()") and b37f1d123c69 ("ASoC: Let snd_soc_platform
    subclass snd_soc_component").
    
    First commit causes component_list to be corrupted when removing codec and
    second when removing platform. Reason for both is that components associated
    with platform or codec are never removed from the list because for them
    registered_as_component field in struct snd_soc_component is always false.
    
    Now list becomes corrupted when snd_soc_unregister_platform() or
    snd_soc_unregister_codec() frees the platform or codec structure and where
    the associated struct snd_soc_component is embedded.
    
    Fix these by moving component unregistration and cleanup to a new local
    function __snd_soc_unregister_component() that takes component as its
    argument.
    
    Since component is known for platforms and codecs the
    __snd_soc_unregister_component() can be called directly and
    snd_soc_unregister_component() takes care to find and unregister only
    components that were registered using snd_soc_register_component().
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d5cd80b6d320..4a381b307b08 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4010,6 +4010,18 @@ int snd_soc_register_component(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_component);
 
+static void __snd_soc_unregister_component(struct snd_soc_component *cmpnt)
+{
+	snd_soc_unregister_dais(cmpnt);
+
+	mutex_lock(&client_mutex);
+	list_del(&cmpnt->list);
+	mutex_unlock(&client_mutex);
+
+	dev_dbg(cmpnt->dev, "ASoC: Unregistered component '%s'\n", cmpnt->name);
+	kfree(cmpnt->name);
+}
+
 /**
  * snd_soc_unregister_component - Unregister a component from the ASoC core
  *
@@ -4025,14 +4037,7 @@ void snd_soc_unregister_component(struct device *dev)
 	return;
 
 found:
-	snd_soc_unregister_dais(cmpnt);
-
-	mutex_lock(&client_mutex);
-	list_del(&cmpnt->list);
-	mutex_unlock(&client_mutex);
-
-	dev_dbg(dev, "ASoC: Unregistered component '%s'\n", cmpnt->name);
-	kfree(cmpnt->name);
+	__snd_soc_unregister_component(cmpnt);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
@@ -4132,7 +4137,7 @@ EXPORT_SYMBOL_GPL(snd_soc_register_platform);
  */
 void snd_soc_remove_platform(struct snd_soc_platform *platform)
 {
-	snd_soc_unregister_component(platform->dev);
+	__snd_soc_unregister_component(&platform->component);
 
 	mutex_lock(&client_mutex);
 	list_del(&platform->list);
@@ -4337,7 +4342,7 @@ void snd_soc_unregister_codec(struct device *dev)
 	return;
 
 found:
-	snd_soc_unregister_component(dev);
+	__snd_soc_unregister_component(&codec->component);
 
 	mutex_lock(&client_mutex);
 	list_del(&codec->list);

commit 7b4a469e583f7f0e3259f4e0fc0baa844bc72782
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Apr 26 13:02:29 2014 +0200

    ASoC: Remove name_prefix unset during DAI link init hack again
    
    This was initially removed in commit 6479f15ad ("ASoC: Remove name_prefix unset
    during DAI link init hack"), but was brought back in commit 503ae5e0 ("ASoC:
    core: Add helpers for dai link and aux dev init") by accident. This patch
    removes it again.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b2d889667ab4..54a1d91f1d96 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1274,14 +1274,10 @@ static int soc_aux_dev_init(struct snd_soc_card *card,
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
-	const char *temp;
 	int ret;
 
 	rtd->card = card;
 
-	temp = codec->name_prefix;
-	codec->name_prefix = NULL;
-
 	/* do machine specific initialization */
 	if (aux_dev->init) {
 		ret = aux_dev->init(&codec->dapm);
@@ -1289,8 +1285,6 @@ static int soc_aux_dev_init(struct snd_soc_card *card,
 			return ret;
 	}
 
-	codec->name_prefix = temp;
-
 	rtd->codec = codec;
 
 	return 0;
@@ -1302,15 +1296,10 @@ static int soc_dai_link_init(struct snd_soc_card *card,
 {
 	struct snd_soc_dai_link *dai_link =  &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	const char *temp;
 	int ret;
 
 	rtd->card = card;
 
-	/* machine controls, routes and widgets are not prefixed */
-	temp = codec->name_prefix;
-	codec->name_prefix = NULL;
-
 	/* do machine specific initialization */
 	if (dai_link->init) {
 		ret = dai_link->init(rtd);
@@ -1318,8 +1307,6 @@ static int soc_dai_link_init(struct snd_soc_card *card,
 			return ret;
 	}
 
-	codec->name_prefix = temp;
-
 	rtd->codec = codec;
 
 	return 0;

commit 503ae5e036824935d9e214b9819a618499733bdf
Author: Misael Lopez Cruz <misael.lopez@ti.com>
Date:   Thu Apr 24 14:01:44 2014 +0200

    ASoC: core: Add helpers for dai link and aux dev init
    
    Separate DAI link and aux dev initialization in preparation for
    DAI multicodec support.
    Since aux dev will remain using single codecs but DAI links
    will be able to support multiple codecs.
    
    No functional change.
    
    Signed-off-by: Misael Lopez Cruz <misael.lopez@ti.com>
    [fparent@baylibre.com: Adapt to 3.14+]
    Signed-off-by: Fabien Parent <fparent@baylibre.com>
    Signed-off-by: Benoit Cousson <bcousson@baylibre.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 42c5835ba92f..b2d889667ab4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1268,6 +1268,63 @@ static void rtd_release(struct device *dev)
 	kfree(dev);
 }
 
+static int soc_aux_dev_init(struct snd_soc_card *card,
+			    struct snd_soc_codec *codec,
+			    int num)
+{
+	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
+	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
+	const char *temp;
+	int ret;
+
+	rtd->card = card;
+
+	temp = codec->name_prefix;
+	codec->name_prefix = NULL;
+
+	/* do machine specific initialization */
+	if (aux_dev->init) {
+		ret = aux_dev->init(&codec->dapm);
+		if (ret < 0)
+			return ret;
+	}
+
+	codec->name_prefix = temp;
+
+	rtd->codec = codec;
+
+	return 0;
+}
+
+static int soc_dai_link_init(struct snd_soc_card *card,
+			     struct snd_soc_codec *codec,
+			     int num)
+{
+	struct snd_soc_dai_link *dai_link =  &card->dai_link[num];
+	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	const char *temp;
+	int ret;
+
+	rtd->card = card;
+
+	/* machine controls, routes and widgets are not prefixed */
+	temp = codec->name_prefix;
+	codec->name_prefix = NULL;
+
+	/* do machine specific initialization */
+	if (dai_link->init) {
+		ret = dai_link->init(rtd);
+		if (ret < 0)
+			return ret;
+	}
+
+	codec->name_prefix = temp;
+
+	rtd->codec = codec;
+
+	return 0;
+}
+
 static int soc_post_component_init(struct snd_soc_card *card,
 				   struct snd_soc_codec *codec,
 				   int num, int dailess)
@@ -1282,26 +1339,20 @@ static int soc_post_component_init(struct snd_soc_card *card,
 		dai_link = &card->dai_link[num];
 		rtd = &card->rtd[num];
 		name = dai_link->name;
+		ret = soc_dai_link_init(card, codec, num);
 	} else {
 		aux_dev = &card->aux_dev[num];
 		rtd = &card->rtd_aux[num];
 		name = aux_dev->name;
+		ret = soc_aux_dev_init(card, codec, num);
 	}
-	rtd->card = card;
 
-	/* do machine specific initialization */
-	if (!dailess && dai_link->init)
-		ret = dai_link->init(rtd);
-	else if (dailess && aux_dev->init)
-		ret = aux_dev->init(&codec->dapm);
 	if (ret < 0) {
 		dev_err(card->dev, "ASoC: failed to init %s: %d\n", name, ret);
 		return ret;
 	}
 
 	/* register the rtd device */
-	rtd->codec = codec;
-
 	rtd->dev = kzalloc(sizeof(struct device), GFP_KERNEL);
 	if (!rtd->dev)
 		return -ENOMEM;

commit 3dcba280f739772a4156fbcdae39229d6bb5e02b
Author: Nicolin Chen <Guangyu.Chen@freescale.com>
Date:   Mon Apr 21 19:14:46 2014 +0800

    ASoC: core: Don't break component searching if both id and num_dai are 0
    
    The commit e41975ed (ASoC: core: Fix the DAI name getting) added a break
    within the "if (id < 0 || id >= pos->num_dai)" while the original design
    of the search didn't break the loop if that condition contented but only
    mark the ret error and let it go on to search the next component.
    
    In a case like dmaengine which's not a dai but as a component sharing an
    identical name with a dai, both the id and pos->num_dai here could be 0.
    If we break the search, we may never find the dai we want as it might be
    placed behind its dmaengine in the component list.
    
    So this patch fixes the issue above by following the original design to
    let the search carry on.
    
    Signed-off-by: Nicolin Chen <Guangyu.Chen@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7f8efea5c5b1..799cbe81fe39 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4521,7 +4521,7 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 
 			if (id < 0 || id >= pos->num_dai) {
 				ret = -EINVAL;
-				break;
+				continue;
 			}
 
 			ret = 0;

commit 389cb8348cf5ac4a702c71bf13673c4c8bf01e34
Author: Jyri Sarha <jsarha@ti.com>
Date:   Mon Mar 24 12:15:24 2014 +0200

    ASoC: core: Update snd_soc_of_parse_daifmt() interface
    
    Adds struct device_node **bitclkmaster and struct device_node **framemaster
    function parameters. With the new syntax bitclock-master and frame-master
    properties can explicitly indicate the dai-link bit-clock and frame masters
    with a phandle. This patch also makes the minimal changes to simple-card
    for it to work with the updated snd_soc_of_parse_daifmt(). Simple-card appears
    to be the only user of snd_soc_of_parse_daifmt() for now.
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Jean-Francois Moine <moinejf@free.fr>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006281f5..3487a55c9a06 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4554,7 +4554,9 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_routing);
 
 unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
-				     const char *prefix)
+				     const char *prefix,
+				     struct device_node **bitclkmaster,
+				     struct device_node **framemaster)
 {
 	int ret, i;
 	char prop[128];
@@ -4637,9 +4639,13 @@ unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 	 */
 	snprintf(prop, sizeof(prop), "%sbitclock-master", prefix);
 	bit = !!of_get_property(np, prop, NULL);
+	if (bit && bitclkmaster)
+		*bitclkmaster = of_parse_phandle(np, prop, 0);
 
 	snprintf(prop, sizeof(prop), "%sframe-master", prefix);
 	frame = !!of_get_property(np, prop, NULL);
+	if (frame && framemaster)
+		*framemaster = of_parse_phandle(np, prop, 0);
 
 	switch ((bit << 4) + frame) {
 	case 0x11:

commit 907fe36a2cd572fe58d98be01457b945c47b996e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Apr 22 13:23:14 2014 +0200

    ASoC: Move standard kcontrol helpers to the component level
    
    After moving the IO layer inside ASoC to the component level we can now easily
    move the standard control helpers also to the component level. This allows to
    reuse the same standard helper control implementations for other components.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index df3e2931cc0d..d5cd80b6d320 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2353,7 +2353,7 @@ int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
 	struct snd_card *card = codec->card->snd_card;
 
 	return snd_soc_add_controls(card, codec->dev, controls, num_controls,
-			codec->name_prefix, codec);
+			codec->name_prefix, &codec->component);
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
 
@@ -2373,7 +2373,7 @@ int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
 	struct snd_card *card = platform->card->snd_card;
 
 	return snd_soc_add_controls(card, platform->dev, controls, num_controls,
-			NULL, platform);
+			NULL, &platform->component);
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);
 
@@ -2457,12 +2457,15 @@ EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
 int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned int val, item;
 	unsigned int reg_val;
+	int ret;
 
-	reg_val = snd_soc_read(codec, e->reg);
+	ret = snd_soc_component_read(component, e->reg, &reg_val);
+	if (ret)
+		return ret;
 	val = (reg_val >> e->shift_l) & e->mask;
 	item = snd_soc_enum_val_to_item(e, val);
 	ucontrol->value.enumerated.item[0] = item;
@@ -2488,7 +2491,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
 int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned int *item = ucontrol->value.enumerated.item;
 	unsigned int val;
@@ -2505,38 +2508,48 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 		mask |= e->mask << e->shift_r;
 	}
 
-	return snd_soc_update_bits_locked(codec, e->reg, mask, val);
+	return snd_soc_component_update_bits(component, e->reg, mask, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
 
 /**
  * snd_soc_read_signed - Read a codec register and interprete as signed value
- * @codec: codec
+ * @component: component
  * @reg: Register to read
  * @mask: Mask to use after shifting the register value
  * @shift: Right shift of register value
  * @sign_bit: Bit that describes if a number is negative or not.
+ * @signed_val: Pointer to where the read value should be stored
  *
  * This functions reads a codec register. The register value is shifted right
  * by 'shift' bits and masked with the given 'mask'. Afterwards it translates
  * the given registervalue into a signed integer if sign_bit is non-zero.
  *
- * Returns the register value as signed int.
+ * Returns 0 on sucess, otherwise an error value
  */
-static int snd_soc_read_signed(struct snd_soc_codec *codec, unsigned int reg,
-		unsigned int mask, unsigned int shift, unsigned int sign_bit)
+static int snd_soc_read_signed(struct snd_soc_component *component,
+	unsigned int reg, unsigned int mask, unsigned int shift,
+	unsigned int sign_bit, int *signed_val)
 {
 	int ret;
 	unsigned int val;
 
-	val = (snd_soc_read(codec, reg) >> shift) & mask;
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret < 0)
+		return ret;
+
+	val = (val >> shift) & mask;
 
-	if (!sign_bit)
-		return val;
+	if (!sign_bit) {
+		*signed_val = val;
+		return 0;
+	}
 
 	/* non-negative number */
-	if (!(val & BIT(sign_bit)))
-		return val;
+	if (!(val & BIT(sign_bit))) {
+		*signed_val = val;
+		return 0;
+	}
 
 	ret = val;
 
@@ -2548,7 +2561,9 @@ static int snd_soc_read_signed(struct snd_soc_codec *codec, unsigned int reg,
 	 */
 	ret |= ~((int)(BIT(sign_bit) - 1));
 
-	return ret;
+	*signed_val = ret;
+
+	return 0;
 }
 
 /**
@@ -2597,9 +2612,9 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
 int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
 	unsigned int reg2 = mc->rreg;
 	unsigned int shift = mc->shift;
@@ -2609,25 +2624,32 @@ int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	int sign_bit = mc->sign_bit;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
+	int val;
+	int ret;
 
 	if (sign_bit)
 		mask = BIT(sign_bit + 1) - 1;
 
-	ucontrol->value.integer.value[0] = snd_soc_read_signed(codec, reg, mask,
-			shift, sign_bit) - min;
+	ret = snd_soc_read_signed(component, reg, mask, shift, sign_bit, &val);
+	if (ret)
+		return ret;
+
+	ucontrol->value.integer.value[0] = val - min;
 	if (invert)
 		ucontrol->value.integer.value[0] =
 			max - ucontrol->value.integer.value[0];
 
 	if (snd_soc_volsw_is_stereo(mc)) {
 		if (reg == reg2)
-			ucontrol->value.integer.value[1] =
-				snd_soc_read_signed(codec, reg, mask, rshift,
-						sign_bit) - min;
+			ret = snd_soc_read_signed(component, reg, mask, rshift,
+				sign_bit, &val);
 		else
-			ucontrol->value.integer.value[1] =
-				snd_soc_read_signed(codec, reg2, mask, shift,
-						sign_bit) - min;
+			ret = snd_soc_read_signed(component, reg2, mask, shift,
+				sign_bit, &val);
+		if (ret)
+			return ret;
+
+		ucontrol->value.integer.value[1] = val - min;
 		if (invert)
 			ucontrol->value.integer.value[1] =
 				max - ucontrol->value.integer.value[1];
@@ -2650,9 +2672,9 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
 int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
 	unsigned int reg2 = mc->rreg;
 	unsigned int shift = mc->shift;
@@ -2687,12 +2709,13 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 			type_2r = true;
 		}
 	}
-	err = snd_soc_update_bits_locked(codec, reg, val_mask, val);
+	err = snd_soc_component_update_bits(component, reg, val_mask, val);
 	if (err < 0)
 		return err;
 
 	if (type_2r)
-		err = snd_soc_update_bits_locked(codec, reg2, val_mask, val2);
+		err = snd_soc_component_update_bits(component, reg2, val_mask,
+			val2);
 
 	return err;
 }
@@ -2711,10 +2734,9 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 int snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,
 		      struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_mixer_control *mc =
 	    (struct soc_mixer_control *)kcontrol->private_value;
-
 	unsigned int reg = mc->reg;
 	unsigned int reg2 = mc->rreg;
 	unsigned int shift = mc->shift;
@@ -2722,13 +2744,23 @@ int snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,
 	int max = mc->max;
 	int min = mc->min;
 	int mask = (1 << (fls(min + max) - 1)) - 1;
+	unsigned int val;
+	int ret;
 
-	ucontrol->value.integer.value[0] =
-	    ((snd_soc_read(codec, reg) >> shift) - min) & mask;
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret < 0)
+		return ret;
 
-	if (snd_soc_volsw_is_stereo(mc))
-		ucontrol->value.integer.value[1] =
-			((snd_soc_read(codec, reg2) >> rshift) - min) & mask;
+	ucontrol->value.integer.value[0] = ((val >> shift) - min) & mask;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		ret = snd_soc_component_read(component, reg2, &val);
+		if (ret < 0)
+			return ret;
+
+		val = ((val >> rshift) - min) & mask;
+		ucontrol->value.integer.value[1] = val;
+	}
 
 	return 0;
 }
@@ -2746,7 +2778,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw_sx);
 int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
 			 struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_mixer_control *mc =
 	    (struct soc_mixer_control *)kcontrol->private_value;
 
@@ -2764,7 +2796,7 @@ int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
 	val = (ucontrol->value.integer.value[0] + min) & mask;
 	val = val << shift;
 
-	err = snd_soc_update_bits_locked(codec, reg, val_mask, val);
+	err = snd_soc_component_update_bits(component, reg, val_mask, val);
 	if (err < 0)
 		return err;
 
@@ -2773,10 +2805,10 @@ int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
 		val2 = (ucontrol->value.integer.value[1] + min) & mask;
 		val2 = val2 << rshift;
 
-		if (snd_soc_update_bits_locked(codec, reg2, val_mask, val2))
-			return err;
+		err = snd_soc_component_update_bits(component, reg2, val_mask,
+			val2);
 	}
-	return 0;
+	return err;
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_sx);
 
@@ -2823,10 +2855,15 @@ int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
 {
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
+	unsigned int val;
 	int min = mc->min;
-	int val = snd_soc_read(codec, reg);
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret)
+		return ret;
 
 	ucontrol->value.integer.value[0] =
 		((signed char)(val & 0xff))-min;
@@ -2850,7 +2887,7 @@ int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 {
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
 	int min = mc->min;
 	unsigned int val;
@@ -2858,7 +2895,7 @@ int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 	val = (ucontrol->value.integer.value[0]+min) & 0xff;
 	val |= ((ucontrol->value.integer.value[1]+min) & 0xff) << 8;
 
-	return snd_soc_update_bits_locked(codec, reg, 0xffff, val);
+	return snd_soc_component_update_bits(component, reg, 0xffff, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 
@@ -2907,7 +2944,7 @@ int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
 {
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
 	unsigned int rreg = mc->rreg;
 	unsigned int shift = mc->shift;
@@ -2924,7 +2961,7 @@ int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
 	val_mask = mask << shift;
 	val = val << shift;
 
-	ret = snd_soc_update_bits_locked(codec, reg, val_mask, val);
+	ret = snd_soc_component_update_bits(component, reg, val_mask, val);
 	if (ret < 0)
 		return ret;
 
@@ -2935,7 +2972,8 @@ int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
 		val_mask = mask << shift;
 		val = val << shift;
 
-		ret = snd_soc_update_bits_locked(codec, rreg, val_mask, val);
+		ret = snd_soc_component_update_bits(component, rreg, val_mask,
+			val);
 	}
 
 	return ret;
@@ -2954,9 +2992,9 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw_range);
 int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
 	unsigned int rreg = mc->rreg;
 	unsigned int shift = mc->shift;
@@ -2964,9 +3002,14 @@ int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
 	int max = mc->max;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
+	unsigned int val;
+	int ret;
 
-	ucontrol->value.integer.value[0] =
-		(snd_soc_read(codec, reg) >> shift) & mask;
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret)
+		return ret;
+
+	ucontrol->value.integer.value[0] = (val >> shift) & mask;
 	if (invert)
 		ucontrol->value.integer.value[0] =
 			max - ucontrol->value.integer.value[0];
@@ -2974,8 +3017,11 @@ int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
 		ucontrol->value.integer.value[0] - min;
 
 	if (snd_soc_volsw_is_stereo(mc)) {
-		ucontrol->value.integer.value[1] =
-			(snd_soc_read(codec, rreg) >> shift) & mask;
+		ret = snd_soc_component_read(component, rreg, &val);
+		if (ret)
+			return ret;
+
+		ucontrol->value.integer.value[1] = (val >> shift) & mask;
 		if (invert)
 			ucontrol->value.integer.value[1] =
 				max - ucontrol->value.integer.value[1];
@@ -3029,11 +3075,11 @@ EXPORT_SYMBOL_GPL(snd_soc_limit_volume);
 int snd_soc_bytes_info(struct snd_kcontrol *kcontrol,
 		       struct snd_ctl_elem_info *uinfo)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_bytes *params = (void *)kcontrol->private_value;
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	uinfo->count = params->num_regs * codec->component.val_bytes;
+	uinfo->count = params->num_regs * component->val_bytes;
 
 	return 0;
 }
@@ -3042,20 +3088,20 @@ EXPORT_SYMBOL_GPL(snd_soc_bytes_info);
 int snd_soc_bytes_get(struct snd_kcontrol *kcontrol,
 		      struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_bytes *params = (void *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	int ret;
 
-	if (codec->component.regmap)
-		ret = regmap_raw_read(codec->component.regmap, params->base,
+	if (component->regmap)
+		ret = regmap_raw_read(component->regmap, params->base,
 				      ucontrol->value.bytes.data,
-				      params->num_regs * codec->component.val_bytes);
+				      params->num_regs * component->val_bytes);
 	else
 		ret = -EINVAL;
 
 	/* Hide any masked bytes to ensure consistent data reporting */
 	if (ret == 0 && params->mask) {
-		switch (codec->component.val_bytes) {
+		switch (component->val_bytes) {
 		case 1:
 			ucontrol->value.bytes.data[0] &= ~params->mask;
 			break;
@@ -3079,16 +3125,16 @@ EXPORT_SYMBOL_GPL(snd_soc_bytes_get);
 int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 		      struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_bytes *params = (void *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	int ret, len;
 	unsigned int val, mask;
 	void *data;
 
-	if (!codec->component.regmap)
+	if (!component->regmap)
 		return -EINVAL;
 
-	len = params->num_regs * codec->component.val_bytes;
+	len = params->num_regs * component->val_bytes;
 
 	data = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);
 	if (!data)
@@ -3100,27 +3146,27 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 	 * copy.
 	 */
 	if (params->mask) {
-		ret = regmap_read(codec->component.regmap, params->base, &val);
+		ret = regmap_read(component->regmap, params->base, &val);
 		if (ret != 0)
 			goto out;
 
 		val &= params->mask;
 
-		switch (codec->component.val_bytes) {
+		switch (component->val_bytes) {
 		case 1:
 			((u8 *)data)[0] &= ~params->mask;
 			((u8 *)data)[0] |= val;
 			break;
 		case 2:
 			mask = ~params->mask;
-			ret = regmap_parse_val(codec->component.regmap,
+			ret = regmap_parse_val(component->regmap,
 							&mask, &mask);
 			if (ret != 0)
 				goto out;
 
 			((u16 *)data)[0] &= mask;
 
-			ret = regmap_parse_val(codec->component.regmap,
+			ret = regmap_parse_val(component->regmap,
 							&val, &val);
 			if (ret != 0)
 				goto out;
@@ -3129,14 +3175,14 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 			break;
 		case 4:
 			mask = ~params->mask;
-			ret = regmap_parse_val(codec->component.regmap,
+			ret = regmap_parse_val(component->regmap,
 							&mask, &mask);
 			if (ret != 0)
 				goto out;
 
 			((u32 *)data)[0] &= mask;
 
-			ret = regmap_parse_val(codec->component.regmap,
+			ret = regmap_parse_val(component->regmap,
 							&val, &val);
 			if (ret != 0)
 				goto out;
@@ -3149,7 +3195,7 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 		}
 	}
 
-	ret = regmap_raw_write(codec->component.regmap, params->base,
+	ret = regmap_raw_write(component->regmap, params->base,
 			       data, len);
 
 out:
@@ -3200,24 +3246,27 @@ EXPORT_SYMBOL_GPL(snd_soc_info_xr_sx);
 int snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_mreg_control *mc =
 		(struct soc_mreg_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int regbase = mc->regbase;
 	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = codec->component.val_bytes * BITS_PER_BYTE;
+	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
 	unsigned int regwmask = (1<<regwshift)-1;
 	unsigned int invert = mc->invert;
 	unsigned long mask = (1UL<<mc->nbits)-1;
 	long min = mc->min;
 	long max = mc->max;
 	long val = 0;
-	unsigned long regval;
+	unsigned int regval;
 	unsigned int i;
+	int ret;
 
 	for (i = 0; i < regcount; i++) {
-		regval = snd_soc_read(codec, regbase+i) & regwmask;
-		val |= regval << (regwshift*(regcount-i-1));
+		ret = snd_soc_component_read(component, regbase+i, &regval);
+		if (ret)
+			return ret;
+		val |= (regval & regwmask) << (regwshift*(regcount-i-1));
 	}
 	val &= mask;
 	if (min < 0 && val > max)
@@ -3246,12 +3295,12 @@ EXPORT_SYMBOL_GPL(snd_soc_get_xr_sx);
 int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_mreg_control *mc =
 		(struct soc_mreg_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int regbase = mc->regbase;
 	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = codec->component.val_bytes * BITS_PER_BYTE;
+	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
 	unsigned int regwmask = (1<<regwshift)-1;
 	unsigned int invert = mc->invert;
 	unsigned long mask = (1UL<<mc->nbits)-1;
@@ -3266,7 +3315,7 @@ int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
 	for (i = 0; i < regcount; i++) {
 		regval = (val >> (regwshift*(regcount-i-1))) & regwmask;
 		regmask = (mask >> (regwshift*(regcount-i-1))) & regwmask;
-		err = snd_soc_update_bits_locked(codec, regbase+i,
+		err = snd_soc_component_update_bits(component, regbase+i,
 				regmask, regval);
 		if (err < 0)
 			return err;
@@ -3288,14 +3337,21 @@ EXPORT_SYMBOL_GPL(snd_soc_put_xr_sx);
 int snd_soc_get_strobe(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
 	unsigned int shift = mc->shift;
 	unsigned int mask = 1 << shift;
 	unsigned int invert = mc->invert != 0;
-	unsigned int val = snd_soc_read(codec, reg) & mask;
+	unsigned int val;
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret)
+		return ret;
+
+	val &= mask;
 
 	if (shift != 0 && val != 0)
 		val = val >> shift;
@@ -3318,9 +3374,9 @@ EXPORT_SYMBOL_GPL(snd_soc_get_strobe);
 int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
 	unsigned int shift = mc->shift;
 	unsigned int mask = 1 << shift;
@@ -3330,12 +3386,11 @@ int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
 	unsigned int val2 = (strobe ^ invert) ? 0 : mask;
 	int err;
 
-	err = snd_soc_update_bits_locked(codec, reg, mask, val1);
+	err = snd_soc_component_update_bits(component, reg, mask, val1);
 	if (err < 0)
 		return err;
 
-	err = snd_soc_update_bits_locked(codec, reg, mask, val2);
-	return err;
+	return snd_soc_component_update_bits(component, reg, mask, val2);
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_strobe);
 

commit 9f68730dc8be948f0ae0601ef55321765813895c
Merge: 111c0cf56677 02c9c7b91c28
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Apr 22 13:38:14 2014 +0100

    Merge branch 'topic/multicodec' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-component

commit e2c330b9b5665006c99327c05bc22f7a8e471043
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Apr 22 13:23:13 2014 +0200

    ASoC: Move IO abstraction to the component level
    
    We currently have two very similar IO abstractions in ASoC, one for CODECs, the
    other for platforms. Moving this to the component level will allow us to unify
    those two. It will also enable us to move the standard kcontrol helpers as well
    as DAPM support to the component level.
    
    The new component level abstraction layer is primarily build around regmap.
    There is a per component pointer for the regmap instance for the underlying
    device. There are four new function snd_soc_component_read(),
    snd_soc_component_write(), snd_soc_component_update_bits() and
    snd_soc_component_update_bits_async(). They have the same signature as their
    regmap counter-part and will internally forward the call one-to-one to regmap.
    If the component it not using regmap it will fallback to using the custom IO
    callbacks. This is done to be able to support drivers that haven't been
    converted to regmap yet, but it is expected that this will eventually be removed
    in the future once all component drivers have been converted to regmap.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index db577e4cdf49..f7eb21e70611 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -656,8 +656,8 @@ int snd_soc_suspend(struct device *dev)
 				codec->driver->suspend(codec);
 				codec->suspended = 1;
 				codec->cache_sync = 1;
-				if (codec->using_regmap)
-					regcache_mark_dirty(codec->control_data);
+				if (codec->component.regmap)
+					regcache_mark_dirty(codec->component.regmap);
 				/* deactivate pins to sleep state */
 				pinctrl_pm_select_sleep_state(codec->dev);
 				break;
@@ -2971,7 +2971,7 @@ int snd_soc_bytes_info(struct snd_kcontrol *kcontrol,
 	struct soc_bytes *params = (void *)kcontrol->private_value;
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	uinfo->count = params->num_regs * codec->val_bytes;
+	uinfo->count = params->num_regs * codec->component.val_bytes;
 
 	return 0;
 }
@@ -2984,16 +2984,16 @@ int snd_soc_bytes_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	int ret;
 
-	if (codec->using_regmap)
-		ret = regmap_raw_read(codec->control_data, params->base,
+	if (codec->component.regmap)
+		ret = regmap_raw_read(codec->component.regmap, params->base,
 				      ucontrol->value.bytes.data,
-				      params->num_regs * codec->val_bytes);
+				      params->num_regs * codec->component.val_bytes);
 	else
 		ret = -EINVAL;
 
 	/* Hide any masked bytes to ensure consistent data reporting */
 	if (ret == 0 && params->mask) {
-		switch (codec->val_bytes) {
+		switch (codec->component.val_bytes) {
 		case 1:
 			ucontrol->value.bytes.data[0] &= ~params->mask;
 			break;
@@ -3023,10 +3023,10 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 	unsigned int val, mask;
 	void *data;
 
-	if (!codec->using_regmap)
+	if (!codec->component.regmap)
 		return -EINVAL;
 
-	len = params->num_regs * codec->val_bytes;
+	len = params->num_regs * codec->component.val_bytes;
 
 	data = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);
 	if (!data)
@@ -3038,27 +3038,27 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 	 * copy.
 	 */
 	if (params->mask) {
-		ret = regmap_read(codec->control_data, params->base, &val);
+		ret = regmap_read(codec->component.regmap, params->base, &val);
 		if (ret != 0)
 			goto out;
 
 		val &= params->mask;
 
-		switch (codec->val_bytes) {
+		switch (codec->component.val_bytes) {
 		case 1:
 			((u8 *)data)[0] &= ~params->mask;
 			((u8 *)data)[0] |= val;
 			break;
 		case 2:
 			mask = ~params->mask;
-			ret = regmap_parse_val(codec->control_data,
+			ret = regmap_parse_val(codec->component.regmap,
 							&mask, &mask);
 			if (ret != 0)
 				goto out;
 
 			((u16 *)data)[0] &= mask;
 
-			ret = regmap_parse_val(codec->control_data,
+			ret = regmap_parse_val(codec->component.regmap,
 							&val, &val);
 			if (ret != 0)
 				goto out;
@@ -3067,14 +3067,14 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 			break;
 		case 4:
 			mask = ~params->mask;
-			ret = regmap_parse_val(codec->control_data,
+			ret = regmap_parse_val(codec->component.regmap,
 							&mask, &mask);
 			if (ret != 0)
 				goto out;
 
 			((u32 *)data)[0] &= mask;
 
-			ret = regmap_parse_val(codec->control_data,
+			ret = regmap_parse_val(codec->component.regmap,
 							&val, &val);
 			if (ret != 0)
 				goto out;
@@ -3087,7 +3087,7 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 		}
 	}
 
-	ret = regmap_raw_write(codec->control_data, params->base,
+	ret = regmap_raw_write(codec->component.regmap, params->base,
 			       data, len);
 
 out:
@@ -3143,7 +3143,7 @@ int snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int regbase = mc->regbase;
 	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = codec->val_bytes * BITS_PER_BYTE;
+	unsigned int regwshift = codec->component.val_bytes * BITS_PER_BYTE;
 	unsigned int regwmask = (1<<regwshift)-1;
 	unsigned int invert = mc->invert;
 	unsigned long mask = (1UL<<mc->nbits)-1;
@@ -3189,7 +3189,7 @@ int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int regbase = mc->regbase;
 	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = codec->val_bytes * BITS_PER_BYTE;
+	unsigned int regwshift = codec->component.val_bytes * BITS_PER_BYTE;
 	unsigned int regwmask = (1<<regwshift)-1;
 	unsigned int invert = mc->invert;
 	unsigned long mask = (1UL<<mc->nbits)-1;
@@ -3837,6 +3837,8 @@ __snd_soc_register_component(struct device *dev,
 		return -ENOMEM;
 	}
 
+	mutex_init(&cmpnt->io_mutex);
+
 	cmpnt->name = fmt_single_name(dev, &cmpnt->id);
 	if (!cmpnt->name) {
 		dev_err(dev, "ASoC: Failed to simplifying name\n");
@@ -3917,6 +3919,24 @@ void snd_soc_unregister_component(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
+static int snd_soc_platform_drv_write(struct snd_soc_component *component,
+	unsigned int reg, unsigned int val)
+{
+	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
+
+	return platform->driver->write(platform, reg, val);
+}
+
+static int snd_soc_platform_drv_read(struct snd_soc_component *component,
+	unsigned int reg, unsigned int *val)
+{
+	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
+
+	*val = platform->driver->read(platform, reg);
+
+	return 0;
+}
+
 /**
  * snd_soc_add_platform - Add a platform to the ASoC core
  * @dev: The parent device for the platform
@@ -3937,8 +3957,12 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 	platform->driver = platform_drv;
 	platform->dapm.dev = dev;
 	platform->dapm.platform = platform;
+	platform->dapm.component = &platform->component;
 	platform->dapm.stream_event = platform_drv->stream_event;
-	mutex_init(&platform->mutex);
+	if (platform_drv->write)
+		platform->component.write = snd_soc_platform_drv_write;
+	if (platform_drv->read)
+		platform->component.read = snd_soc_platform_drv_read;
 
 	/* register component */
 	ret = __snd_soc_register_component(dev, &platform->component,
@@ -4067,6 +4091,24 @@ static void fixup_codec_formats(struct snd_soc_pcm_stream *stream)
 			stream->formats |= codec_format_map[i];
 }
 
+static int snd_soc_codec_drv_write(struct snd_soc_component *component,
+	unsigned int reg, unsigned int val)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+	return codec->driver->write(codec, reg, val);
+}
+
+static int snd_soc_codec_drv_read(struct snd_soc_component *component,
+	unsigned int reg, unsigned int *val)
+{
+	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+
+	*val = codec->driver->read(codec, reg);
+
+	return 0;
+}
+
 /**
  * snd_soc_register_codec - Register a codec with the ASoC core
  *
@@ -4094,29 +4136,33 @@ int snd_soc_register_codec(struct device *dev,
 		goto fail_codec;
 	}
 
-	codec->write = codec_drv->write;
-	codec->read = codec_drv->read;
+	if (codec_drv->write)
+		codec->component.write = snd_soc_codec_drv_write;
+	if (codec_drv->read)
+		codec->component.read = snd_soc_codec_drv_read;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;
+	codec->dapm.component = &codec->component;
 	codec->dapm.seq_notifier = codec_drv->seq_notifier;
 	codec->dapm.stream_event = codec_drv->stream_event;
 	codec->dev = dev;
 	codec->driver = codec_drv;
 	codec->num_dai = num_dai;
-	codec->val_bytes = codec_drv->reg_word_size;
+	codec->component.val_bytes = codec_drv->reg_word_size;
 	mutex_init(&codec->mutex);
 
-	if (!codec->write) {
+	if (!codec->component.write) {
 		if (codec_drv->get_regmap)
 			regmap = codec_drv->get_regmap(dev);
 		else
 			regmap = dev_get_regmap(dev, NULL);
 
 		if (regmap) {
-			ret = snd_soc_codec_set_cache_io(codec, regmap);
-			if (ret && ret != -ENOTSUPP) {
+			ret = snd_soc_component_init_io(&codec->component,
+				regmap);
+			if (ret) {
 				dev_err(codec->dev,
 						"Failed to set cache I/O:%d\n",
 						ret);

commit 2b17ef4071d37ef5e357a4ec75686315cfa9d3e6
Merge: 66097ca78899 8ab1a06497a1 ab2874a8faac 3477501274b7 7a34b1c1dff7
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Apr 22 13:22:52 2014 +0100

    Merge branches 'topic/sta350', 'topic/core', 'topic/dapm' and 'topic/cache' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-component

commit b7580cde704920da69e50d133cea16eca77ff3bd
Author: Christoph Jaeger <christophjaeger@linux.com>
Date:   Tue Apr 15 22:39:01 2014 +0200

    ASoC: core: use PTR_ERR instead of PTR_RET
    
    PTR_RET is deprecated. PTR_ERR_OR_ZERO should be used instead. However,
    we already know that IS_ERR is true, and thus PTR_ERR_OR_ZERO would
    never yield zero, so we can use PTR_ERR here.
    
    Signed-off-by: Christoph Jaeger <christophjaeger@linux.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 78f0c51c6c83..7f8efea5c5b1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2075,28 +2075,28 @@ static int snd_soc_ac97_parse_pinctl(struct device *dev,
 	p = devm_pinctrl_get(dev);
 	if (IS_ERR(p)) {
 		dev_err(dev, "Failed to get pinctrl\n");
-		return PTR_RET(p);
+		return PTR_ERR(p);
 	}
 	cfg->pctl = p;
 
 	state = pinctrl_lookup_state(p, "ac97-reset");
 	if (IS_ERR(state)) {
 		dev_err(dev, "Can't find pinctrl state ac97-reset\n");
-		return PTR_RET(state);
+		return PTR_ERR(state);
 	}
 	cfg->pstate_reset = state;
 
 	state = pinctrl_lookup_state(p, "ac97-warm-reset");
 	if (IS_ERR(state)) {
 		dev_err(dev, "Can't find pinctrl state ac97-warm-reset\n");
-		return PTR_RET(state);
+		return PTR_ERR(state);
 	}
 	cfg->pstate_warm_reset = state;
 
 	state = pinctrl_lookup_state(p, "ac97-running");
 	if (IS_ERR(state)) {
 		dev_err(dev, "Can't find pinctrl state ac97-running\n");
-		return PTR_RET(state);
+		return PTR_ERR(state);
 	}
 	cfg->pstate_run = state;
 

commit 02c9c7b91c2831b7f4e43c9931007e46f856b659
Author: Misael Lopez Cruz <misael.lopez@ti.com>
Date:   Fri Mar 21 16:27:28 2014 +0100

    ASoC: core: Add function for ac97 codec registration
    
    Add codec registration specific function in preparation
    for DAI-multicodec support.
    
    No functional change.
    
    Signed-off-by: Misael Lopez Cruz <misael.lopez@ti.com>
    [fparent@baylibre.com: Adapt to 3.14+]
    Signed-off-by: Fabien Parent <fparent@baylibre.com>
    Signed-off-by: Benoit Cousson <bcousson@baylibre.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4c0f7dccbd83..42c5835ba92f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1552,14 +1552,15 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 }
 
 #ifdef CONFIG_SND_SOC_AC97_BUS
-static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+static int soc_register_ac97_codec(struct snd_soc_codec *codec,
+				   struct snd_soc_dai *codec_dai)
 {
 	int ret;
 
 	/* Only instantiate AC97 if not already done by the adaptor
 	 * for the generic AC97 subsystem.
 	 */
-	if (rtd->codec_dai->driver->ac97_control && !rtd->codec->ac97_registered) {
+	if (codec_dai->driver->ac97_control && !codec->ac97_registered) {
 		/*
 		 * It is possible that the AC97 device is already registered to
 		 * the device subsystem. This happens when the device is created
@@ -1568,28 +1569,38 @@ static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
 		 *
 		 * In those cases we don't try to register the device again.
 		 */
-		if (!rtd->codec->ac97_created)
+		if (!codec->ac97_created)
 			return 0;
 
-		ret = soc_ac97_dev_register(rtd->codec);
+		ret = soc_ac97_dev_register(codec);
 		if (ret < 0) {
-			dev_err(rtd->codec->dev,
+			dev_err(codec->dev,
 				"ASoC: AC97 device register failed: %d\n", ret);
 			return ret;
 		}
 
-		rtd->codec->ac97_registered = 1;
+		codec->ac97_registered = 1;
 	}
 	return 0;
 }
 
-static void soc_unregister_ac97_dai_link(struct snd_soc_codec *codec)
+static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	return soc_register_ac97_codec(rtd->codec, rtd->codec_dai);
+}
+
+static void soc_unregister_ac97_codec(struct snd_soc_codec *codec)
 {
 	if (codec->ac97_registered) {
 		soc_ac97_dev_unregister(codec);
 		codec->ac97_registered = 0;
 	}
 }
+
+static void soc_unregister_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	soc_unregister_ac97_codec(rtd->codec);
+}
 #endif
 
 static int soc_check_aux_dev(struct snd_soc_card *card, int num)
@@ -1888,7 +1899,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 			dev_err(card->dev,
 				"ASoC: failed to register AC97: %d\n", ret);
 			while (--i >= 0)
-				soc_unregister_ac97_dai_link(card->rtd[i].codec);
+				soc_unregister_ac97_dai_link(&card->rtd[i]);
 			goto probe_aux_dev_err;
 		}
 	}
@@ -2324,7 +2335,7 @@ void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 {
 	mutex_lock(&codec->mutex);
 #ifdef CONFIG_SND_SOC_AC97_BUS
-	soc_unregister_ac97_dai_link(codec);
+	soc_unregister_ac97_codec(codec);
 #endif
 	kfree(codec->ac97->bus);
 	kfree(codec->ac97);

commit 2436a723f3e1fbca517c9318efe9af5ecf7cbcbb
Author: Misael Lopez Cruz <misael.lopez@ti.com>
Date:   Fri Mar 21 16:27:27 2014 +0100

    ASoC: core: Add helper for DAI widgets linking
    
    Add a helper for DAI widgets linking in preparation for
    DAI-multicodec support.
    
    No functional change.
    
    Signed-off-by: Misael Lopez Cruz <misael.lopez@ti.com>
    [fparent@baylibre.com: Adapt to 3.14+]
    Signed-off-by: Fabien Parent <fparent@baylibre.com>
    Signed-off-by: Benoit Cousson <bcousson@baylibre.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1e4945d614a4..4c0f7dccbd83 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1413,6 +1413,42 @@ static int soc_probe_codec_dai(struct snd_soc_card *card,
 	return 0;
 }
 
+static int soc_link_dai_widgets(struct snd_soc_card *card,
+				struct snd_soc_dai_link *dai_link,
+				struct snd_soc_dai *cpu_dai,
+				struct snd_soc_dai *codec_dai)
+{
+	struct snd_soc_dapm_widget *play_w, *capture_w;
+	int ret;
+
+	/* link the DAI widgets */
+	play_w = codec_dai->playback_widget;
+	capture_w = cpu_dai->capture_widget;
+	if (play_w && capture_w) {
+		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
+					   capture_w, play_w);
+		if (ret != 0) {
+			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
+				play_w->name, capture_w->name, ret);
+			return ret;
+		}
+	}
+
+	play_w = cpu_dai->playback_widget;
+	capture_w = codec_dai->capture_widget;
+	if (play_w && capture_w) {
+		ret = snd_soc_dapm_new_pcm(card, dai_link->params,
+					   capture_w, play_w);
+		if (ret != 0) {
+			dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
+				play_w->name, capture_w->name, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
@@ -1421,7 +1457,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dapm_widget *play_w, *capture_w;
 	int ret;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
@@ -1502,29 +1537,10 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 						codec2codec_close_delayed_work);
 
 			/* link the DAI widgets */
-			play_w = codec_dai->playback_widget;
-			capture_w = cpu_dai->capture_widget;
-			if (play_w && capture_w) {
-				ret = snd_soc_dapm_new_pcm(card, dai_link->params,
-						   capture_w, play_w);
-				if (ret != 0) {
-					dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
-						play_w->name, capture_w->name, ret);
-					return ret;
-				}
-			}
-
-			play_w = cpu_dai->playback_widget;
-			capture_w = codec_dai->capture_widget;
-			if (play_w && capture_w) {
-				ret = snd_soc_dapm_new_pcm(card, dai_link->params,
-						   capture_w, play_w);
-				if (ret != 0) {
-					dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
-						play_w->name, capture_w->name, ret);
-					return ret;
-				}
-			}
+			ret = soc_link_dai_widgets(card, dai_link,
+					cpu_dai, codec_dai);
+			if (ret)
+				return ret;
 		}
 	}
 

commit b0aa88af23155b18efb8c18ace963fa75778561a
Author: Misael Lopez Cruz <misael.lopez@ti.com>
Date:   Fri Mar 21 16:27:26 2014 +0100

    ASoC: core: Add helpers for codec DAI probe & remove
    
    Add helper functions for codec DAI probe and remove in
    preparation for DAI-multicodec support.
    
    No functional change.
    
    Signed-off-by: Misael Lopez Cruz <misael.lopez@ti.com>
    [fparent@baylibre.com: Adapt to 3.14+]
    Signed-off-by: Fabien Parent <fparent@baylibre.com>
    Signed-off-by: Benoit Cousson <bcousson@baylibre.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 674da7049db4..1e4945d614a4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1010,21 +1010,10 @@ static void soc_remove_codec(struct snd_soc_codec *codec)
 	module_put(codec->dev->driver->owner);
 }
 
-static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
+static void soc_remove_codec_dai(struct snd_soc_dai *codec_dai, int order)
 {
-	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
 	int err;
 
-	/* unregister the rtd device */
-	if (rtd->dev_registered) {
-		device_remove_file(rtd->dev, &dev_attr_pmdown_time);
-		device_remove_file(rtd->dev, &dev_attr_codec_reg);
-		device_unregister(rtd->dev);
-		rtd->dev_registered = 0;
-	}
-
-	/* remove the CODEC DAI */
 	if (codec_dai && codec_dai->probed &&
 			codec_dai->driver->remove_order == order) {
 		if (codec_dai->driver->remove) {
@@ -1037,6 +1026,24 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 		codec_dai->probed = 0;
 		list_del(&codec_dai->card_list);
 	}
+}
+
+static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
+{
+	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
+	int err;
+
+	/* unregister the rtd device */
+	if (rtd->dev_registered) {
+		device_remove_file(rtd->dev, &dev_attr_pmdown_time);
+		device_remove_file(rtd->dev, &dev_attr_codec_reg);
+		device_unregister(rtd->dev);
+		rtd->dev_registered = 0;
+	}
+
+	/* remove the CODEC DAI */
+	soc_remove_codec_dai(codec_dai, order);
 
 	/* remove the cpu_dai */
 	if (cpu_dai && cpu_dai->probed &&
@@ -1381,6 +1388,31 @@ static int soc_probe_link_components(struct snd_soc_card *card, int num,
 	return 0;
 }
 
+static int soc_probe_codec_dai(struct snd_soc_card *card,
+			       struct snd_soc_dai *codec_dai,
+			       int order)
+{
+	int ret;
+
+	if (!codec_dai->probed && codec_dai->driver->probe_order == order) {
+		if (codec_dai->driver->probe) {
+			ret = codec_dai->driver->probe(codec_dai);
+			if (ret < 0) {
+				dev_err(codec_dai->dev,
+					"ASoC: failed to probe CODEC DAI %s: %d\n",
+					codec_dai->name, ret);
+				return ret;
+			}
+		}
+
+		/* mark codec_dai as probed and add to card dai list */
+		codec_dai->probed = 1;
+		list_add(&codec_dai->card_list, &card->dai_dev_list);
+	}
+
+	return 0;
+}
+
 static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
@@ -1430,21 +1462,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	}
 
 	/* probe the CODEC DAI */
-	if (!codec_dai->probed && codec_dai->driver->probe_order == order) {
-		if (codec_dai->driver->probe) {
-			ret = codec_dai->driver->probe(codec_dai);
-			if (ret < 0) {
-				dev_err(codec_dai->dev,
-					"ASoC: failed to probe CODEC DAI %s: %d\n",
-					codec_dai->name, ret);
-				return ret;
-			}
-		}
-
-		/* mark codec_dai as probed and add to card dai list */
-		codec_dai->probed = 1;
-		list_add(&codec_dai->card_list, &card->dai_dev_list);
-	}
+	ret = soc_probe_codec_dai(card, codec_dai, order);
+	if (ret)
+		return ret;
 
 	/* complete DAI probe during last probe */
 	if (order != SND_SOC_COMP_ORDER_LAST)

commit 12023a9af8f6602e09d9276d3476f6861ca0f127
Author: Misael Lopez Cruz <misael.lopez@ti.com>
Date:   Fri Mar 21 16:27:25 2014 +0100

    ASoC: core: Add helpers for codec and codec_dai search
    
    Add dedicated helpers for codec and codec_dai search in preparation
    for DAI-multicodec. It will help reducing the extra indentation
    that will be introduced by the iteration over multiple codecs.
    
    Previous implementation unnecessarily kept searching for a matching
    codec in the remaining register codecs even if it was already found.
    
    Fix that by returning in case of matching.
    
    Signed-off-by: Misael Lopez Cruz <misael.lopez@ti.com>
    [fparent@baylibre.com: Adapt to 3.14+]
    Signed-off-by: Fabien Parent <fparent@baylibre.com>
    Signed-off-by: Benoit Cousson <bcousson@baylibre.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006281f5..674da7049db4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -854,14 +854,47 @@ EXPORT_SYMBOL_GPL(snd_soc_resume);
 static const struct snd_soc_dai_ops null_dai_ops = {
 };
 
+static struct snd_soc_codec *soc_find_codec(const struct device_node *codec_of_node,
+					    const char *codec_name)
+{
+	struct snd_soc_codec *codec;
+
+	list_for_each_entry(codec, &codec_list, list) {
+		if (codec_of_node) {
+			if (codec->dev->of_node != codec_of_node)
+				continue;
+		} else {
+			if (strcmp(codec->name, codec_name))
+				continue;
+		}
+
+		return codec;
+	}
+
+	return NULL;
+}
+
+static struct snd_soc_dai *soc_find_codec_dai(struct snd_soc_codec *codec,
+					      const char *codec_dai_name)
+{
+	struct snd_soc_dai *codec_dai;
+
+	list_for_each_entry(codec_dai, &codec->component.dai_list, list) {
+		if (!strcmp(codec_dai->name, codec_dai_name)) {
+			return codec_dai;
+		}
+	}
+
+	return NULL;
+}
+
 static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_component *component;
-	struct snd_soc_codec *codec;
 	struct snd_soc_platform *platform;
-	struct snd_soc_dai *codec_dai, *cpu_dai;
+	struct snd_soc_dai *cpu_dai;
 	const char *platform_name;
 
 	dev_dbg(card->dev, "ASoC: binding %s at idx %d\n", dai_link->name, num);
@@ -889,42 +922,24 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		return -EPROBE_DEFER;
 	}
 
-	/* Find CODEC from registered CODECs */
-	list_for_each_entry(codec, &codec_list, list) {
-		if (dai_link->codec_of_node) {
-			if (codec->dev->of_node != dai_link->codec_of_node)
-				continue;
-		} else {
-			if (strcmp(codec->name, dai_link->codec_name))
-				continue;
-		}
-
-		rtd->codec = codec;
-
-		/*
-		 * CODEC found, so find CODEC DAI from registered DAIs from
-		 * this CODEC
-		 */
-		list_for_each_entry(codec_dai, &codec->component.dai_list, list) {
-			if (!strcmp(codec_dai->name, dai_link->codec_dai_name)) {
-				rtd->codec_dai = codec_dai;
-				break;
-			}
-		}
-
-		if (!rtd->codec_dai) {
-			dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
-				dai_link->codec_dai_name);
-			return -EPROBE_DEFER;
-		}
-	}
-
+	/* Find CODEC from registered list */
+	rtd->codec = soc_find_codec(dai_link->codec_of_node,
+				    dai_link->codec_name);
 	if (!rtd->codec) {
 		dev_err(card->dev, "ASoC: CODEC %s not registered\n",
 			dai_link->codec_name);
 		return -EPROBE_DEFER;
 	}
 
+	/* Find CODEC DAI from registered list */
+	rtd->codec_dai = soc_find_codec_dai(rtd->codec,
+					    dai_link->codec_dai_name);
+	if (!rtd->codec_dai) {
+		dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
+			dai_link->codec_dai_name);
+		return -EPROBE_DEFER;
+	}
+
 	/* if there's no platform we match on the empty platform */
 	platform_name = dai_link->platform_name;
 	if (!platform_name && !dai_link->platform_of_node)

commit aa0258adf6078a41a3db06f4e498253aff64d151
Merge: 1a39019e939f b37f1d123c69
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Apr 14 17:42:28 2014 +0100

    Merge branch 'topic/component' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-core
    
    Conflicts:
            sound/soc/soc-core.c

commit 1a39019e939f620f39a1b914231ab6ba9013b208
Author: Bard Liao <bardliao@realtek.com>
Date:   Tue Apr 8 11:18:10 2014 +0800

    ASoC: core: Allow snd_soc_update_bits use 32 bits register
    
    Change reg's type from unsigned short to unsigned int. So that we can use
    32 bits reg value in snd_soc_update_bits.
    
    Signed-off-by: Bard Liao <bardliao@realtek.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 777453158347..7f0a9297e420 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2330,7 +2330,7 @@ EXPORT_SYMBOL_GPL(snd_soc_write);
  *
  * Returns 1 for change, 0 for no change, or negative error code.
  */
-int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value)
 {
 	bool change;
@@ -2371,7 +2371,7 @@ EXPORT_SYMBOL_GPL(snd_soc_update_bits);
  * Returns 1 for change else 0.
  */
 int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
-			       unsigned short reg, unsigned int mask,
+			       unsigned int reg, unsigned int mask,
 			       unsigned int value)
 {
 	int change;
@@ -2396,7 +2396,7 @@ EXPORT_SYMBOL_GPL(snd_soc_update_bits_locked);
  *
  * Returns 1 for change else 0.
  */
-int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value)
 {
 	int change;
@@ -2911,7 +2911,7 @@ int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
 	int min = mc->min;
 	int mask = (1 << (fls(min + max) - 1)) - 1;
 	int err = 0;
-	unsigned short val, val_mask, val2 = 0;
+	unsigned int val, val_mask, val2 = 0;
 
 	val_mask = mask << shift;
 	val = (ucontrol->value.integer.value[0] + min) & mask;

commit b318ad503698160183fe5e0752b9a1bb3e558026
Author: Nariman Poushin <nariman@opensource.wolfsonmicro.com>
Date:   Tue Apr 1 13:59:33 2014 +0100

    ASoC: core: Fail codec probe if we fail to add controls
    
    Signed-off-by: Nariman Poushin <nariman@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d5710fc79b49..777453158347 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1127,9 +1127,17 @@ static int soc_probe_codec(struct snd_soc_card *card,
 
 	soc_init_codec_debugfs(codec);
 
-	if (driver->dapm_widgets)
-		snd_soc_dapm_new_controls(&codec->dapm, driver->dapm_widgets,
-					  driver->num_dapm_widgets);
+	if (driver->dapm_widgets) {
+		ret = snd_soc_dapm_new_controls(&codec->dapm,
+						driver->dapm_widgets,
+					 	driver->num_dapm_widgets);
+
+		if (ret != 0) {
+			dev_err(codec->dev,
+				"Failed to create new controls %d\n", ret);
+			goto err_probe;
+		}
+	}
 
 	/* Create DAPM widgets for each DAI stream */
 	list_for_each_entry(dai, &codec->component.dai_list, list) {

commit 261edc7013a7435e40fd5ebb3682eac6fc3c15ea
Author: Nariman Poushin <nariman@opensource.wolfsonmicro.com>
Date:   Mon Mar 31 15:47:12 2014 +0100

    ASoC: core: Fail probe if we fail to add dai widgets
    
    Signed-off-by: Nariman Poushin <nariman@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006281f5..d5710fc79b49 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1132,8 +1132,15 @@ static int soc_probe_codec(struct snd_soc_card *card,
 					  driver->num_dapm_widgets);
 
 	/* Create DAPM widgets for each DAI stream */
-	list_for_each_entry(dai, &codec->component.dai_list, list)
-		snd_soc_dapm_new_dai_widgets(&codec->dapm, dai);
+	list_for_each_entry(dai, &codec->component.dai_list, list) {
+		ret = snd_soc_dapm_new_dai_widgets(&codec->dapm, dai);
+
+		if (ret != 0) {
+			dev_err(codec->dev,
+				"Failed to create DAI widgets %d\n", ret);
+			goto err_probe;
+		}
+	}
 
 	codec->dapm.idle_bias_off = driver->idle_bias_off;
 

commit b37f1d123c69c0d7730704d65b83eaac780c0e3b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Mar 18 09:02:12 2014 +0100

    ASoC: Let snd_soc_platform subclass snd_soc_component
    
    There is an increasing amount of code that is very similar between platforms,
    CODECS and other components. Making platforms a component will allow us to
    share this code. For now the patch just adds component and component_driver
    fields to the platform and platform_driver structs and registers the platform as
    a component. Followup patches will be used to consolidate code between the
    different types of components.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3314efb365e3..a95c7e524dfc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3921,6 +3921,8 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 		const struct snd_soc_platform_driver *platform_drv)
 {
+	int ret;
+
 	/* create platform component name */
 	platform->name = fmt_single_name(dev, &platform->id);
 	if (platform->name == NULL)
@@ -3933,6 +3935,16 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 	platform->dapm.stream_event = platform_drv->stream_event;
 	mutex_init(&platform->mutex);
 
+	/* register component */
+	ret = __snd_soc_register_component(dev, &platform->component,
+					   &platform_drv->component_driver,
+					   NULL, NULL, 0, false);
+	if (ret < 0) {
+		dev_err(platform->component.dev,
+			"ASoC: Failed to register component: %d\n", ret);
+		return ret;
+	}
+
 	mutex_lock(&client_mutex);
 	list_add(&platform->list, &platform_list);
 	mutex_unlock(&client_mutex);
@@ -3974,6 +3986,8 @@ EXPORT_SYMBOL_GPL(snd_soc_register_platform);
  */
 void snd_soc_remove_platform(struct snd_soc_platform *platform)
 {
+	snd_soc_unregister_component(platform->dev);
+
 	mutex_lock(&client_mutex);
 	list_del(&platform->list);
 	mutex_unlock(&client_mutex);

commit 98e639fb8a3ed1bf2bd512626c3cfc2992a57113
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Mar 18 09:02:11 2014 +0100

    ASoC: Track which components have been registered with snd_soc_register_component()
    
    snd_soc_unregister_component() takes the parent device of the component as a
    parameter and then looks up the component based on this. This is a problem if
    multiple components are registered for the same parent device. Currently drivers
    do not do this, but some drivers register a CPU DAI component and a platform for
    the same parent device. This will become a problem once platforms are also made
    components. To make sure that snd_soc_unregister_component() will not
    accidentally unregister the platform in such a case only consider components
    that were registered with snd_soc_register_component(). This is only meant as
    short term stopgap solution to be able to continue componentisation. Long term
    we'll need something different.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 41bd24348520..3314efb365e3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3879,6 +3879,7 @@ int snd_soc_register_component(struct device *dev,
 	}
 
 	cmpnt->ignore_pmdown_time = true;
+	cmpnt->registered_as_component = true;
 
 	return __snd_soc_register_component(dev, cmpnt, cmpnt_drv, NULL,
 					    dai_drv, num_dai, true);
@@ -3894,7 +3895,7 @@ void snd_soc_unregister_component(struct device *dev)
 	struct snd_soc_component *cmpnt;
 
 	list_for_each_entry(cmpnt, &component_list, list) {
-		if (dev == cmpnt->dev)
+		if (dev == cmpnt->dev && cmpnt->registered_as_component)
 			goto found;
 	}
 	return;

commit 20a0ec27ea11af0251ffeb5ee2b96cc5c72cb517
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Mar 18 09:02:09 2014 +0100

    ASoC: Remove IO register modifier callbacks
    
    There are no ASoC drivers left that use them and new drivers are supposed to use
    regmap for this.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5c0ed3931285..41bd24348520 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -154,22 +154,15 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf,
 		step = codec->driver->reg_cache_step;
 
 	for (i = 0; i < codec->driver->reg_cache_size; i += step) {
-		if (!snd_soc_codec_readable_register(codec, i))
-			continue;
-		if (codec->driver->display_register) {
-			count += codec->driver->display_register(codec, buf + count,
-							 PAGE_SIZE - count, i);
-		} else {
-			/* only support larger than PAGE_SIZE bytes debugfs
-			 * entries for the default case */
-			if (p >= pos) {
-				if (total + len >= count - 1)
-					break;
-				format_register_str(codec, i, buf + total, len);
-				total += len;
-			}
-			p += len;
+		/* only support larger than PAGE_SIZE bytes debugfs
+		 * entries for the default case */
+		if (p >= pos) {
+			if (total + len >= count - 1)
+				break;
+			format_register_str(codec, i, buf + total, len);
+			total += len;
 		}
+		p += len;
 	}
 
 	total = min(total, count - 1);
@@ -1979,60 +1972,6 @@ static struct platform_driver soc_driver = {
 	.remove		= soc_remove,
 };
 
-/**
- * snd_soc_codec_volatile_register: Report if a register is volatile.
- *
- * @codec: CODEC to query.
- * @reg: Register to query.
- *
- * Boolean function indiciating if a CODEC register is volatile.
- */
-int snd_soc_codec_volatile_register(struct snd_soc_codec *codec,
-				    unsigned int reg)
-{
-	if (codec->volatile_register)
-		return codec->volatile_register(codec, reg);
-	else
-		return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_codec_volatile_register);
-
-/**
- * snd_soc_codec_readable_register: Report if a register is readable.
- *
- * @codec: CODEC to query.
- * @reg: Register to query.
- *
- * Boolean function indicating if a CODEC register is readable.
- */
-int snd_soc_codec_readable_register(struct snd_soc_codec *codec,
-				    unsigned int reg)
-{
-	if (codec->readable_register)
-		return codec->readable_register(codec, reg);
-	else
-		return 1;
-}
-EXPORT_SYMBOL_GPL(snd_soc_codec_readable_register);
-
-/**
- * snd_soc_codec_writable_register: Report if a register is writable.
- *
- * @codec: CODEC to query.
- * @reg: Register to query.
- *
- * Boolean function indicating if a CODEC register is writable.
- */
-int snd_soc_codec_writable_register(struct snd_soc_codec *codec,
-				    unsigned int reg)
-{
-	if (codec->writable_register)
-		return codec->writable_register(codec, reg);
-	else
-		return 1;
-}
-EXPORT_SYMBOL_GPL(snd_soc_codec_writable_register);
-
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec
@@ -4136,9 +4075,6 @@ int snd_soc_register_codec(struct device *dev,
 
 	codec->write = codec_drv->write;
 	codec->read = codec_drv->read;
-	codec->volatile_register = codec_drv->volatile_register;
-	codec->readable_register = codec_drv->readable_register;
-	codec->writable_register = codec_drv->writable_register;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 	codec->dapm.dev = dev;

commit 96241c83293de346037b9a85e321f52ace210926
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Mar 18 09:02:07 2014 +0100

    ASoC: Move IO functions to soc-io.c
    
    soc-core.c is getting quite crowded. Move all IO related functions that are
    still in soc-core.c to soc-io.c
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 935c59418b19..5c0ed3931285 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2033,38 +2033,6 @@ int snd_soc_codec_writable_register(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_writable_register);
 
-int snd_soc_platform_read(struct snd_soc_platform *platform,
-					unsigned int reg)
-{
-	unsigned int ret;
-
-	if (!platform->driver->read) {
-		dev_err(platform->dev, "ASoC: platform has no read back\n");
-		return -1;
-	}
-
-	ret = platform->driver->read(platform, reg);
-	dev_dbg(platform->dev, "read %x => %x\n", reg, ret);
-	trace_snd_soc_preg_read(platform, reg, ret);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_platform_read);
-
-int snd_soc_platform_write(struct snd_soc_platform *platform,
-					 unsigned int reg, unsigned int val)
-{
-	if (!platform->driver->write) {
-		dev_err(platform->dev, "ASoC: platform has no write back\n");
-		return -1;
-	}
-
-	dev_dbg(platform->dev, "write %x = %x\n", reg, val);
-	trace_snd_soc_preg_write(platform, reg, val);
-	return platform->driver->write(platform, reg, val);
-}
-EXPORT_SYMBOL_GPL(snd_soc_platform_write);
-
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec
@@ -2283,118 +2251,6 @@ void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 }
 EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
 
-unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
-{
-	unsigned int ret;
-
-	ret = codec->read(codec, reg);
-	dev_dbg(codec->dev, "read %x => %x\n", reg, ret);
-	trace_snd_soc_reg_read(codec, reg, ret);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_read);
-
-unsigned int snd_soc_write(struct snd_soc_codec *codec,
-			   unsigned int reg, unsigned int val)
-{
-	dev_dbg(codec->dev, "write %x = %x\n", reg, val);
-	trace_snd_soc_reg_write(codec, reg, val);
-	return codec->write(codec, reg, val);
-}
-EXPORT_SYMBOL_GPL(snd_soc_write);
-
-/**
- * snd_soc_update_bits - update codec register bits
- * @codec: audio codec
- * @reg: codec register
- * @mask: register mask
- * @value: new value
- *
- * Writes new register value.
- *
- * Returns 1 for change, 0 for no change, or negative error code.
- */
-int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
-				unsigned int mask, unsigned int value)
-{
-	bool change;
-	unsigned int old, new;
-	int ret;
-
-	if (codec->using_regmap) {
-		ret = regmap_update_bits_check(codec->control_data, reg,
-					       mask, value, &change);
-	} else {
-		ret = snd_soc_read(codec, reg);
-		if (ret < 0)
-			return ret;
-
-		old = ret;
-		new = (old & ~mask) | (value & mask);
-		change = old != new;
-		if (change)
-			ret = snd_soc_write(codec, reg, new);
-	}
-
-	if (ret < 0)
-		return ret;
-
-	return change;
-}
-EXPORT_SYMBOL_GPL(snd_soc_update_bits);
-
-/**
- * snd_soc_update_bits_locked - update codec register bits
- * @codec: audio codec
- * @reg: codec register
- * @mask: register mask
- * @value: new value
- *
- * Writes new register value, and takes the codec mutex.
- *
- * Returns 1 for change else 0.
- */
-int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
-			       unsigned short reg, unsigned int mask,
-			       unsigned int value)
-{
-	int change;
-
-	mutex_lock(&codec->mutex);
-	change = snd_soc_update_bits(codec, reg, mask, value);
-	mutex_unlock(&codec->mutex);
-
-	return change;
-}
-EXPORT_SYMBOL_GPL(snd_soc_update_bits_locked);
-
-/**
- * snd_soc_test_bits - test register for change
- * @codec: audio codec
- * @reg: codec register
- * @mask: register mask
- * @value: new value
- *
- * Tests a register with a new value and checks if the new value is
- * different from the old value.
- *
- * Returns 1 for change else 0.
- */
-int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
-				unsigned int mask, unsigned int value)
-{
-	int change;
-	unsigned int old, new;
-
-	old = snd_soc_read(codec, reg);
-	new = (old & ~mask) | value;
-	change = old != new;
-
-	return change;
-}
-EXPORT_SYMBOL_GPL(snd_soc_test_bits);
-
 /**
  * snd_soc_cnew - create new control
  * @_template: control template

commit 6137a5ca326dac848b35bcbdc44b2ff890273375
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Mar 18 09:02:06 2014 +0100

    ASoC: Prepare SOC_SINGLE_XR_SX controls for regmap
    
    SOC_SINGLE_XR_SX controls currently only work with CODECs that set the
    'reg_word_size' field in their snd_soc_codec_driver struct. Going forward
    support for ASoC level IO will eventually be removed and all drivers will be
    converted to regmap. Preparing for the transition this patch adds support for
    CODECs using regmap for IO to the SOC_SINGLE_XR_SX control. We already have the
    val_bytes field in the CODEC struct which holds the number of bytes per word,
    but it is only initialized when regmap is used. Also initialize it for drivers
    still using legacy IO and update the SOC_SINGLE_XR_SX handlers to use it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006281f5..935c59418b19 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3343,7 +3343,7 @@ int snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int regbase = mc->regbase;
 	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = codec->driver->reg_word_size * BITS_PER_BYTE;
+	unsigned int regwshift = codec->val_bytes * BITS_PER_BYTE;
 	unsigned int regwmask = (1<<regwshift)-1;
 	unsigned int invert = mc->invert;
 	unsigned long mask = (1UL<<mc->nbits)-1;
@@ -3389,7 +3389,7 @@ int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int regbase = mc->regbase;
 	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = codec->driver->reg_word_size * BITS_PER_BYTE;
+	unsigned int regwshift = codec->val_bytes * BITS_PER_BYTE;
 	unsigned int regwmask = (1<<regwshift)-1;
 	unsigned int invert = mc->invert;
 	unsigned long mask = (1UL<<mc->nbits)-1;
@@ -4292,6 +4292,7 @@ int snd_soc_register_codec(struct device *dev,
 	codec->dev = dev;
 	codec->driver = codec_drv;
 	codec->num_dai = num_dai;
+	codec->val_bytes = codec_drv->reg_word_size;
 	mutex_init(&codec->mutex);
 
 	for (i = 0; i < num_dai; i++) {

commit a39f75f7907fa3a708751dc283e3ab3e7da526b8
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Wed Mar 26 13:40:23 2014 +0800

    ASoC: core: Move the default regmap I/O setting to snd_soc_register_codec()
    
    Add the default regmap I/O setting to snd_soc_register_codec() while
    the CODEC is initialising, which will be called by CODEC driver device
    probe(), and then we can make XXX_set_cache_io() go away entirely from each
    CODEC ASoC probe.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 051c006281f5..5071a3a0ac83 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1137,16 +1137,6 @@ static int soc_probe_codec(struct snd_soc_card *card,
 
 	codec->dapm.idle_bias_off = driver->idle_bias_off;
 
-	if (!codec->write && dev_get_regmap(codec->dev, NULL)) {
-		/* Set the default I/O up try regmap */
-		ret = snd_soc_codec_set_cache_io(codec, NULL);
-		if (ret < 0) {
-			dev_err(codec->dev,
-				"Failed to set cache I/O: %d\n", ret);
-			goto err_probe;
-		}
-	}
-
 	if (driver->probe) {
 		ret = driver->probe(codec);
 		if (ret < 0) {
@@ -4263,6 +4253,7 @@ int snd_soc_register_codec(struct device *dev,
 			   int num_dai)
 {
 	struct snd_soc_codec *codec;
+	struct regmap *regmap;
 	int ret, i;
 
 	dev_dbg(dev, "codec register %s\n", dev_name(dev));
@@ -4294,6 +4285,23 @@ int snd_soc_register_codec(struct device *dev,
 	codec->num_dai = num_dai;
 	mutex_init(&codec->mutex);
 
+	if (!codec->write) {
+		if (codec_drv->get_regmap)
+			regmap = codec_drv->get_regmap(dev);
+		else
+			regmap = dev_get_regmap(dev, NULL);
+
+		if (regmap) {
+			ret = snd_soc_codec_set_cache_io(codec, regmap);
+			if (ret && ret != -ENOTSUPP) {
+				dev_err(codec->dev,
+						"Failed to set cache I/O:%d\n",
+						ret);
+				return ret;
+			}
+		}
+	}
+
 	for (i = 0; i < num_dai; i++) {
 		fixup_codec_formats(&dai_drv[i].playback);
 		fixup_codec_formats(&dai_drv[i].capture);

commit 69dd89fd2b9406603d218cab8996cfb232d5b8b9
Merge: 8c1d843460f4 c159a85013af
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 31 12:33:09 2014 +0200

    Merge tag 'asoc-v3.15-4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Final updates for v3.15 merge window
    
    A few more updates from last week - use of the tdm_slot mapping from
    Xiubo plus a few smaller fixes and cleanups.

commit c159a85013afbb8283f0c7272812952e04d5c3a1
Merge: bad318cd02e7 5f9e6ff66f49 1ca2e8474df3
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Mar 25 21:22:15 2014 +0000

    Merge remote-tracking branches 'asoc/topic/tdm' and 'asoc/topic/tegra' into asoc-next

commit e5c2151483facbe1a67b12ec881f45ae25b54c21
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Fri Mar 21 14:17:12 2014 +0800

    ASoC: core: remove the 'of_' prefix of of_xlate_tdm_slot_mask.
    
    The 'of_' is not appropriate here for there hasn't any DT parsing.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b322cf294d06..318fee8093ce 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3625,14 +3625,14 @@ int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 
 /**
- * snd_soc_of_xlate_tdm_slot - generate tx/rx slot mask.
+ * snd_soc_xlate_tdm_slot - generate tx/rx slot mask.
  * @slots: Number of slots in use.
  * @tx_mask: bitmask representing active TX slots.
  * @rx_mask: bitmask representing active RX slots.
  *
  * Generates the TDM tx and rx slot default masks for DAI.
  */
-static int snd_soc_of_xlate_tdm_slot_mask(unsigned int slots,
+static int snd_soc_xlate_tdm_slot_mask(unsigned int slots,
 					  unsigned int *tx_mask,
 					  unsigned int *rx_mask)
 {
@@ -3662,11 +3662,11 @@ static int snd_soc_of_xlate_tdm_slot_mask(unsigned int slots,
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
 {
-	if (dai->driver && dai->driver->ops->of_xlate_tdm_slot_mask)
-		dai->driver->ops->of_xlate_tdm_slot_mask(slots,
+	if (dai->driver && dai->driver->ops->xlate_tdm_slot_mask)
+		dai->driver->ops->xlate_tdm_slot_mask(slots,
 						&tx_mask, &rx_mask);
 	else
-		snd_soc_of_xlate_tdm_slot_mask(slots, &tx_mask, &rx_mask);
+		snd_soc_xlate_tdm_slot_mask(slots, &tx_mask, &rx_mask);
 
 	if (dai->driver && dai->driver->ops->set_tdm_slot)
 		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,

commit 6479f15ad7227da99b4bfc2a465cc50a28ff1b5a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Mar 12 15:27:40 2014 +0100

    ASoC: Remove name_prefix unset during DAI link init hack
    
    Before we had card level support for DAPM and controls machine drivers would
    register their controls and DAPM elements with the CODEC. This required us to
    temporarily unset the name_prefix of a CODEC during the rtd init callback to
    avoid the machine level controls getting the CODEC's prefix. Now that all
    machine drivers properly register their machine level controls and DAPM elements
    with the card rather than with the CODEC we can drop the hack that sets the
    CODEC's name_prefix to NULL while calling the DAI link or AUX dev init callback.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b322cf294d06..daca4b7de45c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1253,7 +1253,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	struct snd_soc_dai_link *dai_link = NULL;
 	struct snd_soc_aux_dev *aux_dev = NULL;
 	struct snd_soc_pcm_runtime *rtd;
-	const char *temp, *name;
+	const char *name;
 	int ret = 0;
 
 	if (!dailess) {
@@ -1267,10 +1267,6 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	}
 	rtd->card = card;
 
-	/* machine controls, routes and widgets are not prefixed */
-	temp = codec->name_prefix;
-	codec->name_prefix = NULL;
-
 	/* do machine specific initialization */
 	if (!dailess && dai_link->init)
 		ret = dai_link->init(rtd);
@@ -1280,7 +1276,6 @@ static int soc_post_component_init(struct snd_soc_card *card,
 		dev_err(card->dev, "ASoC: failed to init %s: %d\n", name, ret);
 		return ret;
 	}
-	codec->name_prefix = temp;
 
 	/* register the rtd device */
 	rtd->codec = codec;

commit c320106230c78b37c4bdbe6eafc636169e97bad9
Merge: 5fdb83f190ee 56fe48976db3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 13 19:03:48 2014 +0100

    Merge tag 'asoc-v3.15-2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: Updates for v3.15
    
    This is mostly a few additional fixes from Lars-Peter, a new driver and
    cleaning up a git failure with merging the Intel branch (combined with
    an xargs failure to pay attention to error codes).  The history lists a
    bunch of additional commits for the branch but the content of those
    commits is actually present already but not recorded in history due to
    git failing.  Unfortunately xargs is used in the merge script and it
    doesn't do a good job of noticing errors from the commands it invokes.

commit 2620954d64f6f067b785faf03738b637f3473ca7
Merge: 8b3272bffe58 a32c17b87c17
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Mar 13 14:19:21 2014 +0000

    Merge remote-tracking branch 'asoc/topic/io' into asoc-next

commit 5fdb83f190ee2218d113a46b190b70aa1c979325
Merge: 4c16ecc4c071 deeed33850c8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 13 09:53:25 2014 +0100

    Merge tag 'asoc-v3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: Updates for v3.15
    
    Quite a busy release for ASoC this time, more on janitorial work than
    exciting new features but welcome nontheless:
    
     - Lots of cleanups from Takashi for enumerations; the original API for
       these was error prone so he's refactored lots of code to use more
       modern APIs which avoid issues.
     - Elimination of the ASoC level wrappers for I2C and SPI moving us
       closer to converting to regmap completely and avoiding some
       randconfig hassle.
     - Provide both manually and transparently locked DAPM APIs rather than
       a mix of the two fixing some concurrency issues.
     - Start converting CODEC drivers to use separate bus interface drivers
       rather than having them all in one file helping avoid dependency
       issues.
     - DPCM support for Intel Haswell and Bay Trail platforms.
     - Lots of work on improvements for simple-card, DaVinci and the Renesas
       rcar drivers.
     - New drivers for Analog Devices ADAU1977, TI PCM512x and parts of the
       CSR SiRF SoC.

commit a4b12990b68079290ab62799035afe175b4bdc23
Merge: 84f6965e2b49 c3518d1bd45e 89c678571559 7cb5e1bb9f91 a9576cbbbafa ba9c949f797a
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Mar 12 23:04:35 2014 +0000

    Merge remote-tracking branches 'asoc/topic/ml26124', 'asoc/topic/of', 'asoc/topic/omap', 'asoc/topic/pxa' and 'asoc/topic/rcar' into asoc-next

commit b8f861586c9c2433b22f81e933845cb8aaa18d9e
Merge: 53a2c4db8cf2 6af5263ceaff
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Mar 12 23:03:59 2014 +0000

    Merge remote-tracking branch 'asoc/topic/enum' into asoc-next

commit 5c1d5f091dc39eecf9a34a8be01492d14c23ad91
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Mar 12 08:34:39 2014 +0100

    ASoC: Fix use after free
    
    Freeing the current list element while iterating over the list will cause a use
    after free since the iterator function will still use the current element to
    look up the next. Use list_for_each_safe() and remove the element from the list
    before freeing it to avoid this.
    
    Fixes: 1438c2f60b ("ASoC: Add a per component dai list")
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f34f1a01fce1..a78bba4d52fb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3913,11 +3913,12 @@ static inline char *fmt_multiple_name(struct device *dev,
  */
 static void snd_soc_unregister_dais(struct snd_soc_component *component)
 {
-	struct snd_soc_dai *dai;
+	struct snd_soc_dai *dai, *_dai;
 
-	list_for_each_entry(dai, &component->dai_list, list) {
+	list_for_each_entry_safe(dai, _dai, &component->dai_list, list) {
 		dev_dbg(component->dev, "ASoC: Unregistered DAI '%s'\n",
 			dai->name);
+		list_del(&dai->list);
 		kfree(dai->name);
 		kfree(dai);
 	}

commit a32c17b87c17f5e2e68edcf4d163ee42f9490652
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Tue Mar 11 12:43:22 2014 +0800

    ASoC: core: Fix check before setting default I/O up try regmap
    
    Since the CODEC driver could specify its own I/O(read and write)
    while registering the CODEC for some reason, maybe the MFDs is
    used, etc.
    
    So just do check it, if they are not specified by CODEC driver
    then try to set up the default regmap I/O if regmap is used.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6510a8e4a5af..cbddbd595213 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1137,9 +1137,15 @@ static int soc_probe_codec(struct snd_soc_card *card,
 
 	codec->dapm.idle_bias_off = driver->idle_bias_off;
 
-	/* Set the default I/O up try regmap */
-	if (dev_get_regmap(codec->dev, NULL))
-		snd_soc_codec_set_cache_io(codec, NULL);
+	if (!codec->write && dev_get_regmap(codec->dev, NULL)) {
+		/* Set the default I/O up try regmap */
+		ret = snd_soc_codec_set_cache_io(codec, NULL);
+		if (ret < 0) {
+			dev_err(codec->dev,
+				"Failed to set cache I/O: %d\n", ret);
+			goto err_probe;
+		}
+	}
 
 	if (driver->probe) {
 		ret = driver->probe(codec);

commit 092eba937d948a76ff55825922eff4df010f6a17
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Tue Mar 11 12:43:21 2014 +0800

    ASoC: io: New signature for snd_soc_codec_set_cache_io()
    
    Now that all users have been converted to regmap and the config.reg_bits
    and config.val_bits can be setted by each user through regmap core API.
    So these two params are redundant here.
    
    Since the only control type that left is SND_SOC_REGMAP, so remove it. Drop
    the control params and add struct regmap *regmap to simplify the code.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ad2dd14f0e3e..6510a8e4a5af 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1139,7 +1139,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 
 	/* Set the default I/O up try regmap */
 	if (dev_get_regmap(codec->dev, NULL))
-		snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP);
+		snd_soc_codec_set_cache_io(codec, NULL);
 
 	if (driver->probe) {
 		ret = driver->probe(codec);

commit db5a5ee7c7b20a1780f90c6f2b8de322844b6fe9
Merge: feff9f3c9612 b6592d88ec37 40423285a10e b46f2c5c0054 d07338b0f2e1 58d4d3c976b3 8eeb5c15131d
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Mar 11 09:58:55 2014 +0000

    Merge branches 'topic/ad193x', 'topic/tlv320aic23', 'topic/tlv320aic32x4', 'topic/wm8991', 'fix/si476x' and 'fix/88pm860' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-io

commit 1438c2f60ba955114cff3717f1a334878c7886a9
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Mar 9 17:41:47 2014 +0100

    ASoC: Add a per component dai list
    
    Now that every DAI has a component we can track the DAIs on a per component
    basis. This simplifies the DAI lookup when we are only interested in DAIs of a
    specific component and also makes it possible to have multiple components with
    the same parent device and also register DAIs.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cc522418e9c4..f34f1a01fce1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -56,7 +56,6 @@ EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);
 #endif
 
 static DEFINE_MUTEX(client_mutex);
-static LIST_HEAD(dai_list);
 static LIST_HEAD(platform_list);
 static LIST_HEAD(codec_list);
 static LIST_HEAD(component_list);
@@ -370,18 +369,22 @@ static ssize_t dai_list_read_file(struct file *file, char __user *user_buf,
 {
 	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
 	ssize_t len, ret = 0;
+	struct snd_soc_component *component;
 	struct snd_soc_dai *dai;
 
 	if (!buf)
 		return -ENOMEM;
 
-	list_for_each_entry(dai, &dai_list, list) {
-		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n", dai->name);
-		if (len >= 0)
-			ret += len;
-		if (ret > PAGE_SIZE) {
-			ret = PAGE_SIZE;
-			break;
+	list_for_each_entry(component, &component_list, list) {
+		list_for_each_entry(dai, &component->dai_list, list) {
+			len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
+				dai->name);
+			if (len >= 0)
+				ret += len;
+			if (ret > PAGE_SIZE) {
+				ret = PAGE_SIZE;
+				break;
+			}
 		}
 	}
 
@@ -855,6 +858,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_component *component;
 	struct snd_soc_codec *codec;
 	struct snd_soc_platform *platform;
 	struct snd_soc_dai *codec_dai, *cpu_dai;
@@ -863,18 +867,20 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	dev_dbg(card->dev, "ASoC: binding %s at idx %d\n", dai_link->name, num);
 
 	/* Find CPU DAI from registered DAIs*/
-	list_for_each_entry(cpu_dai, &dai_list, list) {
+	list_for_each_entry(component, &component_list, list) {
 		if (dai_link->cpu_of_node &&
-		    (cpu_dai->dev->of_node != dai_link->cpu_of_node))
+			component->dev->of_node != dai_link->cpu_of_node)
 			continue;
 		if (dai_link->cpu_name &&
-		    strcmp(dev_name(cpu_dai->dev), dai_link->cpu_name))
-			continue;
-		if (dai_link->cpu_dai_name &&
-		    strcmp(cpu_dai->name, dai_link->cpu_dai_name))
+			strcmp(dev_name(component->dev), dai_link->cpu_name))
 			continue;
+		list_for_each_entry(cpu_dai, &component->dai_list, list) {
+			if (dai_link->cpu_dai_name &&
+				strcmp(cpu_dai->name, dai_link->cpu_dai_name))
+				continue;
 
-		rtd->cpu_dai = cpu_dai;
+			rtd->cpu_dai = cpu_dai;
+		}
 	}
 
 	if (!rtd->cpu_dai) {
@@ -899,12 +905,10 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		 * CODEC found, so find CODEC DAI from registered DAIs from
 		 * this CODEC
 		 */
-		list_for_each_entry(codec_dai, &dai_list, list) {
-			if (codec->dev == codec_dai->dev &&
-				!strcmp(codec_dai->name,
-					dai_link->codec_dai_name)) {
-
+		list_for_each_entry(codec_dai, &codec->component.dai_list, list) {
+			if (!strcmp(codec_dai->name, dai_link->codec_dai_name)) {
 				rtd->codec_dai = codec_dai;
+				break;
 			}
 		}
 
@@ -1128,12 +1132,8 @@ static int soc_probe_codec(struct snd_soc_card *card,
 					  driver->num_dapm_widgets);
 
 	/* Create DAPM widgets for each DAI stream */
-	list_for_each_entry(dai, &dai_list, list) {
-		if (dai->dev != codec->dev)
-			continue;
-
+	list_for_each_entry(dai, &codec->component.dai_list, list)
 		snd_soc_dapm_new_dai_widgets(&codec->dapm, dai);
-	}
 
 	codec->dapm.idle_bias_off = driver->idle_bias_off;
 
@@ -1180,6 +1180,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 {
 	int ret = 0;
 	const struct snd_soc_platform_driver *driver = platform->driver;
+	struct snd_soc_component *component;
 	struct snd_soc_dai *dai;
 
 	platform->card = card;
@@ -1195,11 +1196,11 @@ static int soc_probe_platform(struct snd_soc_card *card,
 			driver->dapm_widgets, driver->num_dapm_widgets);
 
 	/* Create DAPM widgets for each DAI stream */
-	list_for_each_entry(dai, &dai_list, list) {
-		if (dai->dev != platform->dev)
+	list_for_each_entry(component, &component_list, list) {
+		if (component->dev != platform->dev)
 			continue;
-
-		snd_soc_dapm_new_dai_widgets(&platform->dapm, dai);
+		list_for_each_entry(dai, &component->dai_list, list)
+			snd_soc_dapm_new_dai_widgets(&platform->dapm, dai);
 	}
 
 	platform->dapm.idle_bias_off = 1;
@@ -3912,21 +3913,14 @@ static inline char *fmt_multiple_name(struct device *dev,
  */
 static void snd_soc_unregister_dais(struct snd_soc_component *component)
 {
-	struct snd_soc_dai *dai, *_dai;
-
-	mutex_lock(&client_mutex);
-	list_for_each_entry_safe(dai, _dai, &dai_list, list) {
-		if (dai->dev != component->dev)
-			continue;
-
-		list_del(&dai->list);
+	struct snd_soc_dai *dai;
 
+	list_for_each_entry(dai, &component->dai_list, list) {
 		dev_dbg(component->dev, "ASoC: Unregistered DAI '%s'\n",
 			dai->name);
 		kfree(dai->name);
 		kfree(dai);
 	}
-	mutex_unlock(&client_mutex);
 }
 
 /**
@@ -3990,13 +3984,10 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 		if (!dai->driver->ops)
 			dai->driver->ops = &null_dai_ops;
 
-
 		if (!dai->codec)
 			dai->dapm.idle_bias_off = 1;
 
-		mutex_lock(&client_mutex);
-		list_add(&dai->list, &dai_list);
-		mutex_unlock(&client_mutex);
+		list_add(&dai->list, &component->dai_list);
 
 		dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
 	}
@@ -4040,6 +4031,7 @@ __snd_soc_register_component(struct device *dev,
 	cmpnt->driver	= cmpnt_drv;
 	cmpnt->dai_drv	= dai_drv;
 	cmpnt->num_dai	= num_dai;
+	INIT_LIST_HEAD(&cmpnt->dai_list);
 
 	ret = snd_soc_register_dais(cmpnt, codec, dai_drv, num_dai,
 		allow_single_dai);

commit 6cc240f39d393c5878bc6cf053aa0fe8e3fe4260
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Mar 9 17:41:46 2014 +0100

    ASoC: Pass CODEC to snd_soc_register_dais()
    
    snd_soc_register_dais() looks up the CODEC that is registering the DAIs by
    looping over all registered CODECs. This patch updates the code to
    simply pass the CODEC that registers the DAIs to snd_soc_register_dais() thus
    avoiding the lookup.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c365be98b0c3..cc522418e9c4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3933,17 +3933,18 @@ static void snd_soc_unregister_dais(struct snd_soc_component *component)
  * snd_soc_register_dais - Register a DAI with the ASoC core
  *
  * @component: The component the DAIs are registered for
+ * @codec: The CODEC that the DAIs are registered for, NULL if the component is
+ *         not a CODEC.
  * @dai_drv: DAI driver to use for the DAIs
  * @count: Number of DAIs
  * @legacy_dai_naming: Use the legacy naming scheme and let the DAI inherit the
  *                     parent's name.
  */
 static int snd_soc_register_dais(struct snd_soc_component *component,
-	struct snd_soc_dai_driver *dai_drv, size_t count,
-	bool legacy_dai_naming)
+	struct snd_soc_codec *codec, struct snd_soc_dai_driver *dai_drv,
+	size_t count, bool legacy_dai_naming)
 {
 	struct device *dev = component->dev;
-	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
 	unsigned int i;
 	int ret;
@@ -3982,28 +3983,19 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 		}
 
 		dai->component = component;
+		dai->codec = codec;
 		dai->dev = dev;
 		dai->driver = &dai_drv[i];
 		dai->dapm.dev = dev;
 		if (!dai->driver->ops)
 			dai->driver->ops = &null_dai_ops;
 
-		mutex_lock(&client_mutex);
-
-		list_for_each_entry(codec, &codec_list, list) {
-			if (codec->dev == dev) {
-				dev_dbg(dev, "ASoC: Mapped DAI %s to CODEC %s\n",
-					dai->name, codec->name);
-				dai->codec = codec;
-				break;
-			}
-		}
 
 		if (!dai->codec)
 			dai->dapm.idle_bias_off = 1;
 
+		mutex_lock(&client_mutex);
 		list_add(&dai->list, &dai_list);
-
 		mutex_unlock(&client_mutex);
 
 		dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
@@ -4025,6 +4017,7 @@ static int
 __snd_soc_register_component(struct device *dev,
 			     struct snd_soc_component *cmpnt,
 			     const struct snd_soc_component_driver *cmpnt_drv,
+			     struct snd_soc_codec *codec,
 			     struct snd_soc_dai_driver *dai_drv,
 			     int num_dai, bool allow_single_dai)
 {
@@ -4048,7 +4041,8 @@ __snd_soc_register_component(struct device *dev,
 	cmpnt->dai_drv	= dai_drv;
 	cmpnt->num_dai	= num_dai;
 
-	ret = snd_soc_register_dais(cmpnt, dai_drv, num_dai, allow_single_dai);
+	ret = snd_soc_register_dais(cmpnt, codec, dai_drv, num_dai,
+		allow_single_dai);
 	if (ret < 0) {
 		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
 		goto error_component_name;
@@ -4083,7 +4077,7 @@ int snd_soc_register_component(struct device *dev,
 
 	cmpnt->ignore_pmdown_time = true;
 
-	return __snd_soc_register_component(dev, cmpnt, cmpnt_drv,
+	return __snd_soc_register_component(dev, cmpnt, cmpnt_drv, NULL,
 					    dai_drv, num_dai, true);
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_component);
@@ -4304,7 +4298,7 @@ int snd_soc_register_codec(struct device *dev,
 	/* register component */
 	ret = __snd_soc_register_component(dev, &codec->component,
 					   &codec_drv->component_driver,
-					   dai_drv, num_dai, false);
+					   codec, dai_drv, num_dai, false);
 	if (ret < 0) {
 		dev_err(codec->dev, "ASoC: Failed to regster component: %d\n", ret);
 		goto fail_codec_name;

commit 32c9ba544b65991b14ede102928c552ed24d4827
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Mar 9 17:41:45 2014 +0100

    ASoC: Consolidate snd_soc_register_dai() and snd_soc_register_dais()
    
    snd_soc_register_dais() has basically the same code as snd_soc_register_dai(),
    but running in a loop. The only difference is that snd_soc_register_dai() calls
    fmt_single_name() to generate the DAIs name and snd_soc_register_dais() calls
    fmt_multiple_name(). This patch pushes the check in __snd_soc_register_component()
    which decides whether to call snd_soc_register_dai() or snd_soc_register_dais()
    to snd_soc_register_dais() to decide which naming scheme to use. This allows us
    to remove snd_soc_register_dai().
    
    The patch also updates snd_soc_register_dais() to unregister every DAI it finds
    for the component rather than trying to unregister one DAI for each DAI that was
    registered. Both have the same result since there won't be more DAIs than what
    have been registered, but the former is easier to implement.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 255eca9afc9b..c365be98b0c3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3906,100 +3906,47 @@ static inline char *fmt_multiple_name(struct device *dev,
 }
 
 /**
- * snd_soc_register_dai - Register a DAI with the ASoC core
+ * snd_soc_unregister_dai - Unregister DAIs from the ASoC core
  *
- * @component: The component the DAIs are registered for
- * @dai_drv: DAI driver to use for the DAIs
+ * @component: The component for which the DAIs should be unregistered
  */
-static int snd_soc_register_dai(struct snd_soc_component *component,
-		struct snd_soc_dai_driver *dai_drv)
+static void snd_soc_unregister_dais(struct snd_soc_component *component)
 {
-	struct device *dev = component->dev;
-	struct snd_soc_codec *codec;
-	struct snd_soc_dai *dai;
-
-	dev_dbg(dev, "ASoC: dai register %s\n", dev_name(dev));
-
-	dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
-	if (dai == NULL)
-		return -ENOMEM;
-
-	/* create DAI component name */
-	dai->name = fmt_single_name(dev, &dai->id);
-	if (dai->name == NULL) {
-		kfree(dai);
-		return -ENOMEM;
-	}
-
-	dai->component = component;
-	dai->dev = dev;
-	dai->driver = dai_drv;
-	dai->dapm.dev = dev;
-	if (!dai->driver->ops)
-		dai->driver->ops = &null_dai_ops;
+	struct snd_soc_dai *dai, *_dai;
 
 	mutex_lock(&client_mutex);
+	list_for_each_entry_safe(dai, _dai, &dai_list, list) {
+		if (dai->dev != component->dev)
+			continue;
 
-	list_for_each_entry(codec, &codec_list, list) {
-		if (codec->dev == dev) {
-			dev_dbg(dev, "ASoC: Mapped DAI %s to CODEC %s\n",
-				dai->name, codec->name);
-			dai->codec = codec;
-			break;
-		}
-	}
-
-	if (!dai->codec)
-		dai->dapm.idle_bias_off = 1;
-
-	list_add(&dai->list, &dai_list);
-
-	mutex_unlock(&client_mutex);
-
-	dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
-
-	return 0;
-}
-
-/**
- * snd_soc_unregister_dai - Unregister a DAI from the ASoC core
- *
- * @dai: DAI to unregister
- */
-static void snd_soc_unregister_dai(struct device *dev)
-{
-	struct snd_soc_dai *dai;
+		list_del(&dai->list);
 
-	list_for_each_entry(dai, &dai_list, list) {
-		if (dev == dai->dev)
-			goto found;
+		dev_dbg(component->dev, "ASoC: Unregistered DAI '%s'\n",
+			dai->name);
+		kfree(dai->name);
+		kfree(dai);
 	}
-	return;
-
-found:
-	mutex_lock(&client_mutex);
-	list_del(&dai->list);
 	mutex_unlock(&client_mutex);
-
-	dev_dbg(dev, "ASoC: Unregistered DAI '%s'\n", dai->name);
-	kfree(dai->name);
-	kfree(dai);
 }
 
 /**
- * snd_soc_register_dais - Register multiple DAIs with the ASoC core
+ * snd_soc_register_dais - Register a DAI with the ASoC core
  *
  * @component: The component the DAIs are registered for
  * @dai_drv: DAI driver to use for the DAIs
  * @count: Number of DAIs
+ * @legacy_dai_naming: Use the legacy naming scheme and let the DAI inherit the
+ *                     parent's name.
  */
 static int snd_soc_register_dais(struct snd_soc_component *component,
-		struct snd_soc_dai_driver *dai_drv, size_t count)
+	struct snd_soc_dai_driver *dai_drv, size_t count,
+	bool legacy_dai_naming)
 {
 	struct device *dev = component->dev;
 	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
-	int i, ret = 0;
+	unsigned int i;
+	int ret;
 
 	dev_dbg(dev, "ASoC: dai register %s #%Zu\n", dev_name(dev), count);
 
@@ -4011,21 +3958,32 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 			goto err;
 		}
 
-		/* create DAI component name */
-		dai->name = fmt_multiple_name(dev, &dai_drv[i]);
+		/*
+		 * Back in the old days when we still had component-less DAIs,
+		 * instead of having a static name, component-less DAIs would
+		 * inherit the name of the parent device so it is possible to
+		 * register multiple instances of the DAI. We still need to keep
+		 * the same naming style even though those DAIs are not
+		 * component-less anymore.
+		 */
+		if (count == 1 && legacy_dai_naming) {
+			dai->name = fmt_single_name(dev, &dai->id);
+		} else {
+			dai->name = fmt_multiple_name(dev, &dai_drv[i]);
+			if (dai_drv[i].id)
+				dai->id = dai_drv[i].id;
+			else
+				dai->id = i;
+		}
 		if (dai->name == NULL) {
 			kfree(dai);
-			ret = -EINVAL;
+			ret = -ENOMEM;
 			goto err;
 		}
 
 		dai->component = component;
 		dai->dev = dev;
 		dai->driver = &dai_drv[i];
-		if (dai->driver->id)
-			dai->id = dai->driver->id;
-		else
-			dai->id = i;
 		dai->dapm.dev = dev;
 		if (!dai->driver->ops)
 			dai->driver->ops = &null_dai_ops;
@@ -4034,8 +3992,7 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 
 		list_for_each_entry(codec, &codec_list, list) {
 			if (codec->dev == dev) {
-				dev_dbg(dev,
-					"ASoC: Mapped DAI %s to CODEC %s\n",
+				dev_dbg(dev, "ASoC: Mapped DAI %s to CODEC %s\n",
 					dai->name, codec->name);
 				dai->codec = codec;
 				break;
@@ -4049,32 +4006,17 @@ static int snd_soc_register_dais(struct snd_soc_component *component,
 
 		mutex_unlock(&client_mutex);
 
-		dev_dbg(dai->dev, "ASoC: Registered DAI '%s'\n", dai->name);
+		dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
 	}
 
 	return 0;
 
 err:
-	for (i--; i >= 0; i--)
-		snd_soc_unregister_dai(dev);
+	snd_soc_unregister_dais(component);
 
 	return ret;
 }
 
-/**
- * snd_soc_unregister_dais - Unregister multiple DAIs from the ASoC core
- *
- * @dai: Array of DAIs to unregister
- * @count: Number of DAIs
- */
-static void snd_soc_unregister_dais(struct device *dev, size_t count)
-{
-	int i;
-
-	for (i = 0; i < count; i++)
-		snd_soc_unregister_dai(dev);
-}
-
 /**
  * snd_soc_register_component - Register a component with the ASoC core
  *
@@ -4106,19 +4048,7 @@ __snd_soc_register_component(struct device *dev,
 	cmpnt->dai_drv	= dai_drv;
 	cmpnt->num_dai	= num_dai;
 
-	/*
-	 * snd_soc_register_dai()  uses fmt_single_name(), and
-	 * snd_soc_register_dais() uses fmt_multiple_name()
-	 * for dai->name which is used for name based matching
-	 *
-	 * this function is used from cpu/codec.
-	 * allow_single_dai flag can ignore "codec" driver reworking
-	 * since it had been used snd_soc_register_dais(),
-	 */
-	if ((1 == num_dai) && allow_single_dai)
-		ret = snd_soc_register_dai(cmpnt, dai_drv);
-	else
-		ret = snd_soc_register_dais(cmpnt, dai_drv, num_dai);
+	ret = snd_soc_register_dais(cmpnt, dai_drv, num_dai, allow_single_dai);
 	if (ret < 0) {
 		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
 		goto error_component_name;
@@ -4173,7 +4103,7 @@ void snd_soc_unregister_component(struct device *dev)
 	return;
 
 found:
-	snd_soc_unregister_dais(dev, cmpnt->num_dai);
+	snd_soc_unregister_dais(cmpnt);
 
 	mutex_lock(&client_mutex);
 	list_del(&cmpnt->list);

commit a707d030da09793956a339066f0c91deafef14a3
Merge: a1a564ed6abf 3d59400fe47e
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Mar 10 12:17:48 2014 +0000

    Merge branch 'topic/pcm' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-core

commit a1a564ed6abf62e05fcffa9ed3f46a826400df3a
Author: Nenghua Cao <nhcao@marvell.com>
Date:   Wed Feb 19 18:44:58 2014 +0800

    ASoC: core: use regmap's parse_val to do endian translation
    
        In snd_soc_bytes_put function, it forces cpu to do cpu_to_be translation,
    but for mmio bus which uses REGMAP_ENDIAN_NATIVE, it doesn't need to do
    endian translation. So it is better to use regmap's api which can decide
    if this translation is needed according to bus configuration.
    
    Signed-off-by: Nenghua Cao <nhcao@marvell.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 45a1fafdbd7b..9d25c2e0fb92 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3234,7 +3234,7 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 	struct soc_bytes *params = (void *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	int ret, len;
-	unsigned int val;
+	unsigned int val, mask;
 	void *data;
 
 	if (!codec->using_regmap)
@@ -3264,12 +3264,36 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 			((u8 *)data)[0] |= val;
 			break;
 		case 2:
-			((u16 *)data)[0] &= cpu_to_be16(~params->mask);
-			((u16 *)data)[0] |= cpu_to_be16(val);
+			mask = ~params->mask;
+			ret = regmap_parse_val(codec->control_data,
+							&mask, &mask);
+			if (ret != 0)
+				goto out;
+
+			((u16 *)data)[0] &= mask;
+
+			ret = regmap_parse_val(codec->control_data,
+							&val, &val);
+			if (ret != 0)
+				goto out;
+
+			((u16 *)data)[0] |= val;
 			break;
 		case 4:
-			((u32 *)data)[0] &= cpu_to_be32(~params->mask);
-			((u32 *)data)[0] |= cpu_to_be32(val);
+			mask = ~params->mask;
+			ret = regmap_parse_val(codec->control_data,
+							&mask, &mask);
+			if (ret != 0)
+				goto out;
+
+			((u32 *)data)[0] &= mask;
+
+			ret = regmap_parse_val(codec->control_data,
+							&val, &val);
+			if (ret != 0)
+				goto out;
+
+			((u32 *)data)[0] |= val;
 			break;
 		default:
 			ret = -EINVAL;

commit 6af5263ceaffc9d4403592dc81cd3b197702dc69
Merge: 234c0b8fb0db 3d59400fe47e
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Mar 6 17:07:39 2014 +0800

    Merge branch 'topic/pcm' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-enum
    
    Conflicts:
            include/sound/soc.h

commit 3d59400fe47e7e8bfb024cd1651433bef42e268e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Mar 5 13:17:48 2014 +0100

    ASoC: Move ignore_pmdown_time from CODEC to component
    
    In preparation for componentization move the ignore_pmdown_time field from the
    snd_soc_codec struct to the snd_soc_component struct. Set it to true for non
    CODEC components for now.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6401e97b2e68..18aecd2841a8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4127,6 +4127,8 @@ int snd_soc_register_component(struct device *dev,
 		return -ENOMEM;
 	}
 
+	cmpnt->ignore_pmdown_time = true;
+
 	return __snd_soc_register_component(dev, cmpnt, cmpnt_drv,
 					    dai_drv, num_dai, true);
 }
@@ -4325,7 +4327,7 @@ int snd_soc_register_codec(struct device *dev,
 	codec->volatile_register = codec_drv->volatile_register;
 	codec->readable_register = codec_drv->readable_register;
 	codec->writable_register = codec_drv->writable_register;
-	codec->ignore_pmdown_time = codec_drv->ignore_pmdown_time;
+	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;

commit 6106d12947d1b05dc15ca3933eb514347d6ed726
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Mar 5 13:17:46 2014 +0100

    ASoC: Add component pointer to the DAI struct
    
    Keep track of which component registered a DAI. We'll need this as
    componentization progresses.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fe1df50805a3..6401e97b2e68 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3884,11 +3884,13 @@ static inline char *fmt_multiple_name(struct device *dev,
 /**
  * snd_soc_register_dai - Register a DAI with the ASoC core
  *
- * @dai: DAI to register
+ * @component: The component the DAIs are registered for
+ * @dai_drv: DAI driver to use for the DAIs
  */
-static int snd_soc_register_dai(struct device *dev,
+static int snd_soc_register_dai(struct snd_soc_component *component,
 		struct snd_soc_dai_driver *dai_drv)
 {
+	struct device *dev = component->dev;
 	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
 
@@ -3905,6 +3907,7 @@ static int snd_soc_register_dai(struct device *dev,
 		return -ENOMEM;
 	}
 
+	dai->component = component;
 	dai->dev = dev;
 	dai->driver = dai_drv;
 	dai->dapm.dev = dev;
@@ -3962,12 +3965,14 @@ static void snd_soc_unregister_dai(struct device *dev)
 /**
  * snd_soc_register_dais - Register multiple DAIs with the ASoC core
  *
- * @dai: Array of DAIs to register
+ * @component: The component the DAIs are registered for
+ * @dai_drv: DAI driver to use for the DAIs
  * @count: Number of DAIs
  */
-static int snd_soc_register_dais(struct device *dev,
+static int snd_soc_register_dais(struct snd_soc_component *component,
 		struct snd_soc_dai_driver *dai_drv, size_t count)
 {
+	struct device *dev = component->dev;
 	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
 	int i, ret = 0;
@@ -3990,6 +3995,7 @@ static int snd_soc_register_dais(struct device *dev,
 			goto err;
 		}
 
+		dai->component = component;
 		dai->dev = dev;
 		dai->driver = &dai_drv[i];
 		if (dai->driver->id)
@@ -4086,9 +4092,9 @@ __snd_soc_register_component(struct device *dev,
 	 * since it had been used snd_soc_register_dais(),
 	 */
 	if ((1 == num_dai) && allow_single_dai)
-		ret = snd_soc_register_dai(dev, dai_drv);
+		ret = snd_soc_register_dai(cmpnt, dai_drv);
 	else
-		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
+		ret = snd_soc_register_dais(cmpnt, dai_drv, num_dai);
 	if (ret < 0) {
 		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
 		goto error_component_name;

commit 939d9f16994166156fa3d6dfece9c46b92e368e0
Author: Nenghua Cao <nhcao@marvell.com>
Date:   Mon Mar 3 19:08:23 2014 +0800

    ASoC: core: fix coccinelle warnings
    
    sound/soc/soc-core.c:2708:6-13: WARNING: Assignment of
    bool to 0/1
    sound/soc/soc-core.c:2726:3-10: WARNING: Assignment of
    bool to 0/1
    
        More information about semantic patching is available at
    http://coccinelle.lip6.fr/
    
    Signed-off-by: Nenghua Cao <nhcao@marvell.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 393ff069af69..45a1fafdbd7b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2818,7 +2818,7 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
 	int err;
-	bool type_2r = 0;
+	bool type_2r = false;
 	unsigned int val2 = 0;
 	unsigned int val, val_mask;
 
@@ -2836,7 +2836,7 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 			val |= val2 << rshift;
 		} else {
 			val2 = val2 << shift;
-			type_2r = 1;
+			type_2r = true;
 		}
 	}
 	err = snd_soc_update_bits_locked(codec, reg, val_mask, val);

commit 29ae2fa5533e607a7d97b7564dc015252f1e73f4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Feb 28 08:31:03 2014 +0100

    ASoC: Consolidate enum and value enum controls
    
    The implementations for enum and value enum controls are almost identical. The
    only difference is that the value enum uses an additional look-up table to map
    the control value to the register value, while the enum control uses a direct
    mapping. Enums and value enums can easily be distinguished at runtime, for value
    enums the values field of the snd_soc_enum struct contains the look-up table,
    while for enums it is NULL. This patch adds two new small helper functions
    called snd_soc_enum_item_to_val() and snd_soc_enum_val_to_item() which map
    between register value and control item. If the items field of the snd_soc_enum
    struct is NULL the function will do a direct mapping otherwise they'll use the
    look-up table to do the mapping. Using these small helper functions it is
    possible to use the same kcontrol handlers for both enums and value enums. The
    functions are added a inline functions in soc.h so they can also be used by the
    DAPM code to accomplish similar consolidation.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 851733897206..2ddc7a4939d2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2596,14 +2596,18 @@ int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int val;
+	unsigned int val, item;
+	unsigned int reg_val;
 
-	val = snd_soc_read(codec, e->reg);
-	ucontrol->value.enumerated.item[0]
-		= (val >> e->shift_l) & e->mask;
-	if (e->shift_l != e->shift_r)
-		ucontrol->value.enumerated.item[1] =
-			(val >> e->shift_r) & e->mask;
+	reg_val = snd_soc_read(codec, e->reg);
+	val = (reg_val >> e->shift_l) & e->mask;
+	item = snd_soc_enum_val_to_item(e, val);
+	ucontrol->value.enumerated.item[0] = item;
+	if (e->shift_l != e->shift_r) {
+		val = (reg_val >> e->shift_l) & e->mask;
+		item = snd_soc_enum_val_to_item(e, val);
+		ucontrol->value.enumerated.item[1] = item;
+	}
 
 	return 0;
 }
@@ -2623,17 +2627,18 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
 	unsigned int val;
 	unsigned int mask;
 
-	if (ucontrol->value.enumerated.item[0] >= e->items)
+	if (item[0] >= e->items)
 		return -EINVAL;
-	val = ucontrol->value.enumerated.item[0] << e->shift_l;
+	val = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;
 	mask = e->mask << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] >= e->items)
+		if (item[1] >= e->items)
 			return -EINVAL;
-		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		val |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_r;
 		mask |= e->mask << e->shift_r;
 	}
 
@@ -2641,80 +2646,6 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
 
-/**
- * snd_soc_get_value_enum_double - semi enumerated double mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a double semi enumerated mixer.
- *
- * Semi enumerated mixer: the enumerated items are referred as values. Can be
- * used for handling bitfield coded enumeration for example.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_value_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int reg_val, val, mux;
-
-	reg_val = snd_soc_read(codec, e->reg);
-	val = (reg_val >> e->shift_l) & e->mask;
-	for (mux = 0; mux < e->items; mux++) {
-		if (val == e->values[mux])
-			break;
-	}
-	ucontrol->value.enumerated.item[0] = mux;
-	if (e->shift_l != e->shift_r) {
-		val = (reg_val >> e->shift_r) & e->mask;
-		for (mux = 0; mux < e->items; mux++) {
-			if (val == e->values[mux])
-				break;
-		}
-		ucontrol->value.enumerated.item[1] = mux;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_value_enum_double);
-
-/**
- * snd_soc_put_value_enum_double - semi enumerated double mixer put callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value of a double semi enumerated mixer.
- *
- * Semi enumerated mixer: the enumerated items are referred as values. Can be
- * used for handling bitfield coded enumeration for example.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_value_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int val;
-	unsigned int mask;
-
-	if (ucontrol->value.enumerated.item[0] >= e->items)
-		return -EINVAL;
-	val = e->values[ucontrol->value.enumerated.item[0]] << e->shift_l;
-	mask = e->mask << e->shift_l;
-	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] >= e->items)
-			return -EINVAL;
-		val |= e->values[ucontrol->value.enumerated.item[1]] << e->shift_r;
-		mask |= e->mask << e->shift_r;
-	}
-
-	return snd_soc_update_bits_locked(codec, e->reg, mask, val);
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_value_enum_double);
-
 /**
  * snd_soc_read_signed - Read a codec register and interprete as signed value
  * @codec: codec

commit a304681f36f5c4bf3f6ea905320715573317d62b
Merge: 27ca2c30f4fe 26e24ddce755 cd21b123346c 1c38450b9fe5 2907cbcc120e d1755bb75c68 e61a35b79849 15b49e73d375
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Mar 1 12:03:16 2014 +0900

    Merge branches 'topic/dapm', 'topic/sign', 'topic/adau1373', 'topic/max98090', 'topic/mc13783', 'fix/wm8994' and 'topic/wm8995' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into asoc-enum

commit fe2265e4833a3ebea426d748b5ecf8d3ff31edc8
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Feb 27 17:49:52 2014 +0800

    ASoC: core: Set the default I/O up try regmap.
    
    For most CODEC drivers which the REGMAP is used, the soc_probe_codec()
    will do the stuff work of snd_soc_codec_set_cache_io(), which the CODEC
    drivers' ASoC probe will do too, and almost at the same time.
    
    This patch set the default I/O up try regmap, and then the CODEC drivers'
    stuff work of snd_soc_codec_set_cache_io() will be redundant, while if one
    CODEC driver needed to set it's own I/O, then it can rewrite the default ones.
    Then could we just discard the snd_soc_codec_set_cache_io() from the CODEC
    drivers' ASoC probe to simplify the code.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fe1df50805a3..93854f031523 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1137,6 +1137,10 @@ static int soc_probe_codec(struct snd_soc_card *card,
 
 	codec->dapm.idle_bias_off = driver->idle_bias_off;
 
+	/* Set the default I/O up try regmap */
+	if (dev_get_regmap(codec->dev, NULL))
+		snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP);
+
 	if (driver->probe) {
 		ret = driver->probe(codec);
 		if (ret < 0) {
@@ -1150,10 +1154,6 @@ static int soc_probe_codec(struct snd_soc_card *card,
 			codec->name);
 	}
 
-	/* If the driver didn't set I/O up try regmap */
-	if (!codec->write && dev_get_regmap(codec->dev, NULL))
-		snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP);
-
 	if (driver->controls)
 		snd_soc_add_codec_controls(codec, driver->controls,
 				     driver->num_controls);

commit 89c6785715592a6b082b3f9f28c27bb14b041c7d
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Fri Feb 14 09:34:35 2014 +0800

    ASoC: core: add TDM slot parsing from DT supports
    
    For some CPU/CODEC DAI devices the TDM slot infomation maybe needed. This
    patch adds the slot parsing from DT supports.
    
    TDM slot properties:
        dai-tdm-slot-num : Number of slots in use.
        dai-tdm-slot-width :  Width in bits for each slot.
    
    For instance:
        dai-tdm-slot-num = <2>;
        dai-tdm-slot-width = <8>;
    
    And for each spcified driver, there could be one .of_xlate_tdm_slot_mask()
    to specify a explicit mapping of the channels and the slots. If it's absent
    the default snd_soc_of_xlate_tdm_slot_mask() will be used to generating the
    tx and rx masks.
    
    For snd_soc_of_xlate_tdm_slot_mask(), the tx and rx masks will use a 1 bit
    for an active slot as default, and the default active bits are at the LSB of
    the masks.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0540cb08e0ea..5b7d3ba87c7a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3608,6 +3608,30 @@ int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 
+/**
+ * snd_soc_of_xlate_tdm_slot - generate tx/rx slot mask.
+ * @slots: Number of slots in use.
+ * @tx_mask: bitmask representing active TX slots.
+ * @rx_mask: bitmask representing active RX slots.
+ *
+ * Generates the TDM tx and rx slot default masks for DAI.
+ */
+static int snd_soc_of_xlate_tdm_slot_mask(unsigned int slots,
+					  unsigned int *tx_mask,
+					  unsigned int *rx_mask)
+{
+	if (*tx_mask || *rx_mask)
+		return 0;
+
+	if (!slots)
+		return -EINVAL;
+
+	*tx_mask = (1 << slots) - 1;
+	*rx_mask = (1 << slots) - 1;
+
+	return 0;
+}
+
 /**
  * snd_soc_dai_set_tdm_slot - configure DAI TDM.
  * @dai: DAI
@@ -3622,6 +3646,12 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
 {
+	if (dai->driver && dai->driver->ops->of_xlate_tdm_slot_mask)
+		dai->driver->ops->of_xlate_tdm_slot_mask(slots,
+						&tx_mask, &rx_mask);
+	else
+		snd_soc_of_xlate_tdm_slot_mask(slots, &tx_mask, &rx_mask);
+
 	if (dai->driver && dai->driver->ops->set_tdm_slot)
 		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
 				slots, slot_width);
@@ -4504,6 +4534,35 @@ int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets);
 
+int snd_soc_of_parse_tdm_slot(struct device_node *np,
+			      unsigned int *slots,
+			      unsigned int *slot_width)
+{
+	u32 val;
+	int ret;
+
+	if (of_property_read_bool(np, "dai-tdm-slot-num")) {
+		ret = of_property_read_u32(np, "dai-tdm-slot-num", &val);
+		if (ret)
+			return ret;
+
+		if (slots)
+			*slots = val;
+	}
+
+	if (of_property_read_bool(np, "dai-tdm-slot-width")) {
+		ret = of_property_read_u32(np, "dai-tdm-slot-width", &val);
+		if (ret)
+			return ret;
+
+		if (slot_width)
+			*slot_width = val;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_tdm_slot);
+
 int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname)
 {

commit 9a8d38db030f016bee45b927af02d9b46398ed46
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 18 08:11:42 2014 +0100

    ASoC: Rename soc_enum.max field with items
    
    The name "max" in struct soc_enum is rather confusing since it
    actually takes the number of items.  With "max", one might try to
    assign (nitems - 1) value.
    
    Rename the field to a more appropriate one, "items", which is also
    used in struct snd_ctl_elem_info, too.
    
    This patch also rewrites some code like "if (x > e->nitems - 1)" with
    "if (x >= e->nitems)".  Not only the latter improves the readability,
    it also fixes a potential bug when e->items is zero.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fe1df50805a3..4372efb4e033 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2571,10 +2571,10 @@ int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
-	uinfo->value.enumerated.items = e->max;
+	uinfo->value.enumerated.items = e->items;
 
-	if (uinfo->value.enumerated.item > e->max - 1)
-		uinfo->value.enumerated.item = e->max - 1;
+	if (uinfo->value.enumerated.item >= e->items)
+		uinfo->value.enumerated.item = e->items - 1;
 	strlcpy(uinfo->value.enumerated.name,
 		e->texts[uinfo->value.enumerated.item],
 		sizeof(uinfo->value.enumerated.name));
@@ -2626,12 +2626,12 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 	unsigned int val;
 	unsigned int mask;
 
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+	if (ucontrol->value.enumerated.item[0] >= e->items)
 		return -EINVAL;
 	val = ucontrol->value.enumerated.item[0] << e->shift_l;
 	mask = e->mask << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+		if (ucontrol->value.enumerated.item[1] >= e->items)
 			return -EINVAL;
 		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
 		mask |= e->mask << e->shift_r;
@@ -2662,14 +2662,14 @@ int snd_soc_get_value_enum_double(struct snd_kcontrol *kcontrol,
 
 	reg_val = snd_soc_read(codec, e->reg);
 	val = (reg_val >> e->shift_l) & e->mask;
-	for (mux = 0; mux < e->max; mux++) {
+	for (mux = 0; mux < e->items; mux++) {
 		if (val == e->values[mux])
 			break;
 	}
 	ucontrol->value.enumerated.item[0] = mux;
 	if (e->shift_l != e->shift_r) {
 		val = (reg_val >> e->shift_r) & e->mask;
-		for (mux = 0; mux < e->max; mux++) {
+		for (mux = 0; mux < e->items; mux++) {
 			if (val == e->values[mux])
 				break;
 		}
@@ -2700,12 +2700,12 @@ int snd_soc_put_value_enum_double(struct snd_kcontrol *kcontrol,
 	unsigned int val;
 	unsigned int mask;
 
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+	if (ucontrol->value.enumerated.item[0] >= e->items)
 		return -EINVAL;
 	val = e->values[ucontrol->value.enumerated.item[0]] << e->shift_l;
 	mask = e->mask << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+		if (ucontrol->value.enumerated.item[1] >= e->items)
 			return -EINVAL;
 		val |= e->values[ucontrol->value.enumerated.item[1]] << e->shift_r;
 		mask |= e->mask << e->shift_r;

commit 102b5a8d4ac62d8ff4920b64da8b4b488ce67261
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:42:55 2014 +0100

    ASoC: core: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous card->dev assignment.
    
    Reviewed-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fe1df50805a3..135ddb01aadb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1654,7 +1654,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	/* card bind complete so register a sound card */
-	ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+	ret = snd_card_new(card->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
 			card->owner, 0, &card->snd_card);
 	if (ret < 0) {
 		dev_err(card->dev,
@@ -1662,7 +1662,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 			card->name, ret);
 		goto base_error;
 	}
-	card->snd_card->dev = card->dev;
 
 	card->dapm.bias_level = SND_SOC_BIAS_OFF;
 	card->dapm.dev = card->dev;

commit 9a6d48605e632e84db2895cf752c65b3c908cd09
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Sat Feb 8 15:59:52 2014 +0800

    ASoC: add snd_soc_of_parse_audio_simple_widgets for DT
    
    This patch adds snd_soc_of_parse_audio_simple_widgets() and supports
    below style of widgets name on DT:
    
            "template-wname", "user supplied wname"
    
    For instance:
            simple-audio-widgets =
                    "Microphone", "Microphone Jack",
                    "Line", "Line In Jack",
                    "Line", "Line Out Jack",
                    "Headphone", "Headphone Jack",
                    "Speaker", "Speaker External";
    
    The "template-wname" currently includes: "Microphone", "Line", "Headphone"
    and "Speaker".
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fe1df50805a3..0540cb08e0ea 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4417,6 +4417,93 @@ int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_card_name);
 
+static const struct snd_soc_dapm_widget simple_widgets[] = {
+	SND_SOC_DAPM_MIC("Microphone", NULL),
+	SND_SOC_DAPM_LINE("Line", NULL),
+	SND_SOC_DAPM_HP("Headphone", NULL),
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+};
+
+int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
+					  const char *propname)
+{
+	struct device_node *np = card->dev->of_node;
+	struct snd_soc_dapm_widget *widgets;
+	const char *template, *wname;
+	int i, j, num_widgets, ret;
+
+	num_widgets = of_property_count_strings(np, propname);
+	if (num_widgets < 0) {
+		dev_err(card->dev,
+			"ASoC: Property '%s' does not exist\n",	propname);
+		return -EINVAL;
+	}
+	if (num_widgets & 1) {
+		dev_err(card->dev,
+			"ASoC: Property '%s' length is not even\n", propname);
+		return -EINVAL;
+	}
+
+	num_widgets /= 2;
+	if (!num_widgets) {
+		dev_err(card->dev, "ASoC: Property '%s's length is zero\n",
+			propname);
+		return -EINVAL;
+	}
+
+	widgets = devm_kcalloc(card->dev, num_widgets, sizeof(*widgets),
+			       GFP_KERNEL);
+	if (!widgets) {
+		dev_err(card->dev,
+			"ASoC: Could not allocate memory for widgets\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < num_widgets; i++) {
+		ret = of_property_read_string_index(np, propname,
+			2 * i, &template);
+		if (ret) {
+			dev_err(card->dev,
+				"ASoC: Property '%s' index %d read error:%d\n",
+				propname, 2 * i, ret);
+			return -EINVAL;
+		}
+
+		for (j = 0; j < ARRAY_SIZE(simple_widgets); j++) {
+			if (!strncmp(template, simple_widgets[j].name,
+				     strlen(simple_widgets[j].name))) {
+				widgets[i] = simple_widgets[j];
+				break;
+			}
+		}
+
+		if (j >= ARRAY_SIZE(simple_widgets)) {
+			dev_err(card->dev,
+				"ASoC: DAPM widget '%s' is not supported\n",
+				template);
+			return -EINVAL;
+		}
+
+		ret = of_property_read_string_index(np, propname,
+						    (2 * i) + 1,
+						    &wname);
+		if (ret) {
+			dev_err(card->dev,
+				"ASoC: Property '%s' index %d read error:%d\n",
+				propname, (2 * i) + 1, ret);
+			return -EINVAL;
+		}
+
+		widgets[i].name = wname;
+	}
+
+	card->dapm_widgets = widgets;
+	card->num_dapm_widgets = num_widgets;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets);
+
 int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname)
 {

commit f227b88f0fce5f9b82aa934f8829a741c2e06d82
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Thu Jan 16 16:02:10 2014 +0100

    ASoC: core: Add signed register volume control logic
    
    Some codecs use signed volume control representation with non standard
    register sizes, e.g. 6 or 7 bit signed integers.
    
    This patch adds generic signed register volume control logic to
    soc-core. Instead of a fixed width signed register control, this
    implementation uses a 'min' value and the signed bit location to translate
    it to an absolute volume. Using the 'sign_bit' we can calculate a
    correct mask for the register values and translate it back into signed
    integers of standard size.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fe1df50805a3..c1d9d8539ee9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2715,6 +2715,48 @@ int snd_soc_put_value_enum_double(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_value_enum_double);
 
+/**
+ * snd_soc_read_signed - Read a codec register and interprete as signed value
+ * @codec: codec
+ * @reg: Register to read
+ * @mask: Mask to use after shifting the register value
+ * @shift: Right shift of register value
+ * @sign_bit: Bit that describes if a number is negative or not.
+ *
+ * This functions reads a codec register. The register value is shifted right
+ * by 'shift' bits and masked with the given 'mask'. Afterwards it translates
+ * the given registervalue into a signed integer if sign_bit is non-zero.
+ *
+ * Returns the register value as signed int.
+ */
+static int snd_soc_read_signed(struct snd_soc_codec *codec, unsigned int reg,
+		unsigned int mask, unsigned int shift, unsigned int sign_bit)
+{
+	int ret;
+	unsigned int val;
+
+	val = (snd_soc_read(codec, reg) >> shift) & mask;
+
+	if (!sign_bit)
+		return val;
+
+	/* non-negative number */
+	if (!(val & BIT(sign_bit)))
+		return val;
+
+	ret = val;
+
+	/*
+	 * The register most probably does not contain a full-sized int.
+	 * Instead we have an arbitrary number of bits in a signed
+	 * representation which has to be translated into a full-sized int.
+	 * This is done by filling up all bits above the sign-bit.
+	 */
+	ret |= ~((int)(BIT(sign_bit) - 1));
+
+	return ret;
+}
+
 /**
  * snd_soc_info_volsw - single mixer info callback
  * @kcontrol: mixer control
@@ -2743,7 +2785,7 @@ int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 
 	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = platform_max;
+	uinfo->value.integer.max = platform_max - mc->min;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
@@ -2769,11 +2811,16 @@ int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	unsigned int shift = mc->shift;
 	unsigned int rshift = mc->rshift;
 	int max = mc->max;
+	int min = mc->min;
+	int sign_bit = mc->sign_bit;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
 
-	ucontrol->value.integer.value[0] =
-		(snd_soc_read(codec, reg) >> shift) & mask;
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	ucontrol->value.integer.value[0] = snd_soc_read_signed(codec, reg, mask,
+			shift, sign_bit) - min;
 	if (invert)
 		ucontrol->value.integer.value[0] =
 			max - ucontrol->value.integer.value[0];
@@ -2781,10 +2828,12 @@ int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	if (snd_soc_volsw_is_stereo(mc)) {
 		if (reg == reg2)
 			ucontrol->value.integer.value[1] =
-				(snd_soc_read(codec, reg) >> rshift) & mask;
+				snd_soc_read_signed(codec, reg, mask, rshift,
+						sign_bit) - min;
 		else
 			ucontrol->value.integer.value[1] =
-				(snd_soc_read(codec, reg2) >> shift) & mask;
+				snd_soc_read_signed(codec, reg2, mask, shift,
+						sign_bit) - min;
 		if (invert)
 			ucontrol->value.integer.value[1] =
 				max - ucontrol->value.integer.value[1];
@@ -2815,6 +2864,8 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 	unsigned int shift = mc->shift;
 	unsigned int rshift = mc->rshift;
 	int max = mc->max;
+	int min = mc->min;
+	unsigned int sign_bit = mc->sign_bit;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
 	int err;
@@ -2822,13 +2873,16 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 	unsigned int val2 = 0;
 	unsigned int val, val_mask;
 
-	val = (ucontrol->value.integer.value[0] & mask);
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	val = ((ucontrol->value.integer.value[0] + min) & mask);
 	if (invert)
 		val = max - val;
 	val_mask = mask << shift;
 	val = val << shift;
 	if (snd_soc_volsw_is_stereo(mc)) {
-		val2 = (ucontrol->value.integer.value[1] & mask);
+		val2 = ((ucontrol->value.integer.value[1] + min) & mask);
 		if (invert)
 			val2 = max - val2;
 		if (reg == reg2) {

commit b2cbb6e1c1544fc889ee7d6c6a6c229c20cd03cd
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Thu Jan 23 13:02:47 2014 +0800

    ASoC: core: set_tdm_slot() will return -ENOTSUPP if no operation provided
    
    Make it easier for generic code to work with set_tdm_slot() by distinguishing
    between the operation not being supported and an error as is done.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fe1df50805a3..393ff069af69 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3626,7 +3626,7 @@ int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
 				slots, slot_width);
 	else
-		return -EINVAL;
+		return -ENOTSUPP;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
 

commit 99896f714a0a940d84476bc6208319f70af30789
Merge: a9b68d3b9098 f7d3c17096f6
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 16 12:42:53 2014 +0000

    Merge remote-tracking branch 'asoc/topic/dapm' into for-tiwai

commit a9b68d3b90988dd13c668d6b1d45cdca1557f070
Merge: efe265d301c6 1104a9c822f0
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 16 12:42:53 2014 +0000

    Merge remote-tracking branch 'asoc/topic/core' into for-tiwai

commit 1104a9c822f0e9f5e57a236f20a142166dd8f91e
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Jan 15 19:04:19 2014 +0000

    ASoC: core: Return -ENOTSUPP from set_sysclk() if no operation provided
    
    Make it easier for generic code to work with set_sysclk() by distinguishing
    between the operation not being supported and an error as is done for
    other operations like set_dai_fmt()
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 03c779ebd729..0ebf1dac330d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3484,7 +3484,7 @@ int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 		return dai->codec->driver->set_sysclk(dai->codec, clk_id, 0,
 						      freq, dir);
 	else
-		return -EINVAL;
+		return -ENOTSUPP;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 
@@ -3505,7 +3505,7 @@ int snd_soc_codec_set_sysclk(struct snd_soc_codec *codec, int clk_id,
 		return codec->driver->set_sysclk(codec, clk_id, source,
 						 freq, dir);
 	else
-		return -EINVAL;
+		return -ENOTSUPP;
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_sysclk);
 

commit b893ea5f1cd1adbbd7e0794d16d47bbb46f80733
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Wed Jan 8 10:40:19 2014 +0000

    ASoC: sapm: Automatically connect DAI link widgets in DAPM graph.
    
    Connect the DAPM graph through each BE DAI link to the componnent(s) on the
    other side of the BE DAI link. This allows the graph to be walked on
    both sides of the link when graph changes are made.
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4e53d87e881d..7d9c0660ab24 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1728,6 +1728,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 
 	snd_soc_dapm_link_dai_widgets(card);
+	snd_soc_dapm_connect_dai_link_widgets(card);
 
 	if (card->controls)
 		snd_soc_add_card_controls(card, card->controls, card->num_controls);

commit 729b47a007345d0af214f7f64a784c6bb3ad4832
Merge: 30010a279657 e41975edc73d
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 2 13:01:50 2014 +0000

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit e41975edc73d2c16d0784e5fa87a6162e2fcab80
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Fri Dec 20 14:39:51 2013 +0800

    ASoC: core: Fix the DAI name getting.
    
    From "ASoC: make snd_soc_dai_link more symmetrical", can we see that
    the name of CPU DAI maybe omitted. If the DAI name is omitted, try to
    use the component name instead.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4e53d87e881d..03c779ebd729 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4617,10 +4617,14 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 
 			if (id < 0 || id >= pos->num_dai) {
 				ret = -EINVAL;
-			} else {
-				*dai_name = pos->dai_drv[id].name;
-				ret = 0;
+				break;
 			}
+
+			ret = 0;
+
+			*dai_name = pos->dai_drv[id].name;
+			if (!*dai_name)
+				*dai_name = pos->name;
 		}
 
 		break;

commit 8f1ec93ae94e95e717283575997dd134a4c5397f
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Fri Nov 29 13:33:11 2013 +0000

    ASoC: core: Use consistent byte ordering in snd_soc_bytes_get
    
    snd_soc_bytes_put treats the data in the binary control as big endian
    words, however snd_soc_bytes_get uses the endian of the host machine.
    This causes the two functions to be inconsistant with how the mask is
    applied on little endian machines.
    
    This patch applies the big_endian format used in snd_soc_bytes_put to
    snd_soc_bytes_get.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4e53d87e881d..a66783e13a9c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3212,11 +3212,11 @@ int snd_soc_bytes_get(struct snd_kcontrol *kcontrol,
 			break;
 		case 2:
 			((u16 *)(&ucontrol->value.bytes.data))[0]
-				&= ~params->mask;
+				&= cpu_to_be16(~params->mask);
 			break;
 		case 4:
 			((u32 *)(&ucontrol->value.bytes.data))[0]
-				&= ~params->mask;
+				&= cpu_to_be32(~params->mask);
 			break;
 		default:
 			return -EINVAL;

commit c6016bdeab11e2deb01058b93133633def62fa27
Merge: d20b09f0c5aa 988e8cc41efe
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Nov 8 10:43:25 2013 +0000

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit d20b09f0c5aaaa49a8a0189837a87adbc40095f0
Merge: 2fc175c4a347 cb470087669a
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Nov 8 10:43:24 2013 +0000

    Merge remote-tracking branch 'asoc/topic/component' into asoc-next

commit 2fc175c4a347153a5e4f370a7dd574d56d46bb8a
Merge: aff79f828283 e54cf76ba2c9
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Nov 8 10:43:24 2013 +0000

    Merge remote-tracking branch 'asoc/topic/bclk' into asoc-next

commit 988e8cc41efecbab53f13184940aa6317047765b
Author: Nicolin Chen <b42378@freescale.com>
Date:   Mon Nov 4 14:57:31 2013 +0800

    ASoC: Add pinctrl PM to components of active DAIs
    
    It's quite popular that more drivers are using pinctrl PM, for example:
    (Documentation/devicetree/bindings/arm/primecell.txt). Just like what
    runtime PM does, it would deactivate and activate pin group depending
    on whether it's being used or not.
    
    And this pinctrl PM might be also beneficial to cpu dai drivers because
    they might have actual pinctrl so as to sleep their pins and wake them
    up as needed.
    
    To achieve this goal, this patch sets pins to the default state during
    resume or startup; While during suspend and shutdown, it would set pins
    to the sleep state.
    
    As pinctrl PM would return zero if there is no such pinctrl sleep state
    settings, this patch would not break current ASoC subsystem directly.
    
    [ However, there is still an exception that the patch can not handle,
    that is, when cpu dai driver does not have pinctrl property but another
    device has it. (The AUDMUX <-> SSI on Freescale i.MX6 series for example.
    SSI as a cpu dai doesn't contain pinctrl property while AUDMUX, an Audio
    Multiplexer, has it). In this case, this kind of cpu dai driver needs to
    find a way to obtain the pinctrl property as its own, by moving property
    from AUDMUX to SSI, or creating a pins link/dependency between these two
    devices, or using a more decent way after we figure it out. ]
    
    Signed-off-by: Nicolin Chen <b42378@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b38e0ee622df..1a4e97773c71 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -662,6 +662,8 @@ int snd_soc_suspend(struct device *dev)
 				codec->cache_sync = 1;
 				if (codec->using_regmap)
 					regcache_mark_dirty(codec->control_data);
+				/* deactivate pins to sleep state */
+				pinctrl_pm_select_sleep_state(codec->dev);
 				break;
 			default:
 				dev_dbg(codec->dev,
@@ -679,6 +681,9 @@ int snd_soc_suspend(struct device *dev)
 
 		if (cpu_dai->driver->suspend && cpu_dai->driver->ac97_control)
 			cpu_dai->driver->suspend(cpu_dai);
+
+		/* deactivate pins to sleep state */
+		pinctrl_pm_select_sleep_state(cpu_dai->dev);
 	}
 
 	if (card->suspend_post)
@@ -807,6 +812,16 @@ int snd_soc_resume(struct device *dev)
 	if (list_empty(&card->codec_dev_list))
 		return 0;
 
+	/* activate pins from sleep state */
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
+		if (cpu_dai->active)
+			pinctrl_pm_select_default_state(cpu_dai->dev);
+		if (codec_dai->active)
+			pinctrl_pm_select_default_state(codec_dai->dev);
+	}
+
 	/* AC97 devices might have other drivers hanging off them so
 	 * need to resume immediately.  Other drivers don't have that
 	 * problem and may take a substantial amount of time to resume
@@ -1930,6 +1945,14 @@ int snd_soc_poweroff(struct device *dev)
 
 	snd_soc_dapm_shutdown(card);
 
+	/* deactivate pins to sleep state */
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
+		pinctrl_pm_select_sleep_state(codec_dai->dev);
+		pinctrl_pm_select_sleep_state(cpu_dai->dev);
+	}
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_poweroff);
@@ -3752,6 +3775,16 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	if (ret != 0)
 		soc_cleanup_card_debugfs(card);
 
+	/* deactivate pins to sleep state */
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
+		if (!codec_dai->active)
+			pinctrl_pm_select_sleep_state(codec_dai->dev);
+		if (!cpu_dai->active)
+			pinctrl_pm_select_sleep_state(cpu_dai->dev);
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_card);

commit a19685cb72bb6a80ac453e76b3ab3bb7770e1742
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 28 14:21:46 2013 +0100

    ASoC: Use strlcpy() for copying in snd_soc_info_enum_double()
    
    The provided texts aren't guaranteed to be in the fixed size.
    Spotted by coverity CID 139318.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0860a7f11299..b38e0ee622df 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2552,8 +2552,9 @@ int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
 
 	if (uinfo->value.enumerated.item > e->max - 1)
 		uinfo->value.enumerated.item = e->max - 1;
-	strcpy(uinfo->value.enumerated.name,
-		e->texts[uinfo->value.enumerated.item]);
+	strlcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item],
+		sizeof(uinfo->value.enumerated.name));
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);

commit 6833c452c2fb47353566aa705d68541c6045c796
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Oct 16 22:05:26 2013 -0700

    ASoC: add snd_soc_of_get_dai_name() default of_xlate
    
    Current snd_soc_of_get_dai_name() needs .of_xlate_dai_name()
    callback on each component drivers.
    But required behavior on almost all these drivers is
    just returns its indexed driver's name.
    
    This patch adds this feature as default behavior.
    .of_xlate_dai_name() can overwrite it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 67cfb5f5ca96..0860a7f11299 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4023,6 +4023,7 @@ __snd_soc_register_component(struct device *dev,
 
 	cmpnt->dev	= dev;
 	cmpnt->driver	= cmpnt_drv;
+	cmpnt->dai_drv	= dai_drv;
 	cmpnt->num_dai	= num_dai;
 
 	/*
@@ -4548,12 +4549,31 @@ int snd_soc_of_get_dai_name(struct device_node *of_node,
 		if (pos->dev->of_node != args.np)
 			continue;
 
-		if (!pos->driver->of_xlate_dai_name) {
-			ret = -ENOSYS;
-			break;
+		if (pos->driver->of_xlate_dai_name) {
+			ret = pos->driver->of_xlate_dai_name(pos, &args, dai_name);
+		} else {
+			int id = -1;
+
+			switch (args.args_count) {
+			case 0:
+				id = 0; /* same as dai_drv[0] */
+				break;
+			case 1:
+				id = args.args[0];
+				break;
+			default:
+				/* not supported */
+				break;
+			}
+
+			if (id < 0 || id >= pos->num_dai) {
+				ret = -EINVAL;
+			} else {
+				*dai_name = pos->dai_drv[id].name;
+				ret = 0;
+			}
 		}
 
-		ret = pos->driver->of_xlate_dai_name(pos, &args, dai_name);
 		break;
 	}
 	mutex_unlock(&client_mutex);

commit 7d930ce26e01470590cd003484b32df29529906c
Merge: 7f05cc98bd9b cb470087669a
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Sep 17 13:25:28 2013 +0100

    Merge remote-tracking branch 'asoc/topic/component' into asoc-core
    
    Conflicts:
            include/sound/soc.h

commit cb470087669a3fab1958fec79dd7db280b33f178
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 10 17:39:56 2013 -0700

    ASoC: add .of_xlate_dai_name on snd_soc_component_driver
    
    ASoC sound driver requires CPU/CODEC drivers for probing,
    and each CPU/CODEC has some DAI on it.
    Then, "dai name matching" have been used to identify
    CPU-CODEC DAI pair on ASoC.
    
    But, the "dai port number matching" is now required from DeviceTree.
    The solution of this issue is to replace
    the dai port number into dai name.
    Now, CPU/CODEC are based on struct snd_soc_component,
    and it can care above as common issue.
    
    This patch adds .of_xlate_dai_name callback interface
    on struct snd_soc_component_driver,
    and snd_soc_of_get_dai_name() which is using .of_xlate_dai_name.
    
    Then, #sound-dai-cells which enables DAI specifier is required
    on CPU/CODEC device tree properties.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 014ac10267da..711bd362028d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4590,6 +4590,41 @@ unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_daifmt);
 
+int snd_soc_of_get_dai_name(struct device_node *of_node,
+			    const char **dai_name)
+{
+	struct snd_soc_component *pos;
+	struct of_phandle_args args;
+	int ret;
+
+	ret = of_parse_phandle_with_args(of_node, "sound-dai",
+					 "#sound-dai-cells", 0, &args);
+	if (ret)
+		return ret;
+
+	ret = -EPROBE_DEFER;
+
+	mutex_lock(&client_mutex);
+	list_for_each_entry(pos, &component_list, list) {
+		if (pos->dev->of_node != args.np)
+			continue;
+
+		if (!pos->driver->of_xlate_dai_name) {
+			ret = -ENOSYS;
+			break;
+		}
+
+		ret = pos->driver->of_xlate_dai_name(pos, &args, dai_name);
+		break;
+	}
+	mutex_unlock(&client_mutex);
+
+	of_node_put(args.np);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_name);
+
 static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS

commit d191bd8de8c61619563f2b19f1fdcc0944ff1a72
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Sep 4 19:39:03 2013 -0700

    ASoC: snd_soc_codec includes snd_soc_component
    
    Codec includes component by this patch,
    and component moved to upside of codec
    to avoid extra declaration.
    Codec dai will be registered via component
    by this patch.
    
    Current component register function
    is used for cpu, and it is using
    dai/dais functions properly to keep
    existing cpu dai name.
    
    And now, it will be used from codec also.
    But codec driver had been used dais function only
    even though it was single dai.
    This patch adds new flag which can selects
    dai/dais function on component register
    function to keep existing codec dai name.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4d0561312f3b..014ac10267da 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4020,6 +4020,112 @@ static void snd_soc_unregister_dais(struct device *dev, size_t count)
 		snd_soc_unregister_dai(dev);
 }
 
+/**
+ * snd_soc_register_component - Register a component with the ASoC core
+ *
+ */
+static int
+__snd_soc_register_component(struct device *dev,
+			     struct snd_soc_component *cmpnt,
+			     const struct snd_soc_component_driver *cmpnt_drv,
+			     struct snd_soc_dai_driver *dai_drv,
+			     int num_dai, bool allow_single_dai)
+{
+	int ret;
+
+	dev_dbg(dev, "component register %s\n", dev_name(dev));
+
+	if (!cmpnt) {
+		dev_err(dev, "ASoC: Failed to connecting component\n");
+		return -ENOMEM;
+	}
+
+	cmpnt->name = fmt_single_name(dev, &cmpnt->id);
+	if (!cmpnt->name) {
+		dev_err(dev, "ASoC: Failed to simplifying name\n");
+		return -ENOMEM;
+	}
+
+	cmpnt->dev	= dev;
+	cmpnt->driver	= cmpnt_drv;
+	cmpnt->num_dai	= num_dai;
+
+	/*
+	 * snd_soc_register_dai()  uses fmt_single_name(), and
+	 * snd_soc_register_dais() uses fmt_multiple_name()
+	 * for dai->name which is used for name based matching
+	 *
+	 * this function is used from cpu/codec.
+	 * allow_single_dai flag can ignore "codec" driver reworking
+	 * since it had been used snd_soc_register_dais(),
+	 */
+	if ((1 == num_dai) && allow_single_dai)
+		ret = snd_soc_register_dai(dev, dai_drv);
+	else
+		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
+	if (ret < 0) {
+		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
+		goto error_component_name;
+	}
+
+	mutex_lock(&client_mutex);
+	list_add(&cmpnt->list, &component_list);
+	mutex_unlock(&client_mutex);
+
+	dev_dbg(cmpnt->dev, "ASoC: Registered component '%s'\n", cmpnt->name);
+
+	return ret;
+
+error_component_name:
+	kfree(cmpnt->name);
+
+	return ret;
+}
+
+int snd_soc_register_component(struct device *dev,
+			       const struct snd_soc_component_driver *cmpnt_drv,
+			       struct snd_soc_dai_driver *dai_drv,
+			       int num_dai)
+{
+	struct snd_soc_component *cmpnt;
+
+	cmpnt = devm_kzalloc(dev, sizeof(*cmpnt), GFP_KERNEL);
+	if (!cmpnt) {
+		dev_err(dev, "ASoC: Failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	return __snd_soc_register_component(dev, cmpnt, cmpnt_drv,
+					    dai_drv, num_dai, true);
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_component);
+
+/**
+ * snd_soc_unregister_component - Unregister a component from the ASoC core
+ *
+ */
+void snd_soc_unregister_component(struct device *dev)
+{
+	struct snd_soc_component *cmpnt;
+
+	list_for_each_entry(cmpnt, &component_list, list) {
+		if (dev == cmpnt->dev)
+			goto found;
+	}
+	return;
+
+found:
+	snd_soc_unregister_dais(dev, cmpnt->num_dai);
+
+	mutex_lock(&client_mutex);
+	list_del(&cmpnt->list);
+	mutex_unlock(&client_mutex);
+
+	dev_dbg(dev, "ASoC: Unregistered component '%s'\n", cmpnt->name);
+	kfree(cmpnt->name);
+}
+EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
+
 /**
  * snd_soc_add_platform - Add a platform to the ASoC core
  * @dev: The parent device for the platform
@@ -4242,10 +4348,12 @@ int snd_soc_register_codec(struct device *dev,
 	list_add(&codec->list, &codec_list);
 	mutex_unlock(&client_mutex);
 
-	/* register any DAIs */
-	ret = snd_soc_register_dais(dev, dai_drv, num_dai);
+	/* register component */
+	ret = __snd_soc_register_component(dev, &codec->component,
+					   &codec_drv->component_driver,
+					   dai_drv, num_dai, false);
 	if (ret < 0) {
-		dev_err(codec->dev, "ASoC: Failed to regster DAIs: %d\n", ret);
+		dev_err(codec->dev, "ASoC: Failed to regster component: %d\n", ret);
 		goto fail_codec_name;
 	}
 
@@ -4280,7 +4388,7 @@ void snd_soc_unregister_codec(struct device *dev)
 	return;
 
 found:
-	snd_soc_unregister_dais(dev, codec->num_dai);
+	snd_soc_unregister_component(dev);
 
 	mutex_lock(&client_mutex);
 	list_del(&codec->list);
@@ -4295,92 +4403,6 @@ void snd_soc_unregister_codec(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
 
-
-/**
- * snd_soc_register_component - Register a component with the ASoC core
- *
- */
-int snd_soc_register_component(struct device *dev,
-			 const struct snd_soc_component_driver *cmpnt_drv,
-			 struct snd_soc_dai_driver *dai_drv,
-			 int num_dai)
-{
-	struct snd_soc_component *cmpnt;
-	int ret;
-
-	dev_dbg(dev, "component register %s\n", dev_name(dev));
-
-	cmpnt = devm_kzalloc(dev, sizeof(*cmpnt), GFP_KERNEL);
-	if (!cmpnt) {
-		dev_err(dev, "ASoC: Failed to allocate memory\n");
-		return -ENOMEM;
-	}
-
-	cmpnt->name = fmt_single_name(dev, &cmpnt->id);
-	if (!cmpnt->name) {
-		dev_err(dev, "ASoC: Failed to simplifying name\n");
-		return -ENOMEM;
-	}
-
-	cmpnt->dev	= dev;
-	cmpnt->driver	= cmpnt_drv;
-	cmpnt->num_dai	= num_dai;
-
-	/*
-	 * snd_soc_register_dai()  uses fmt_single_name(), and
-	 * snd_soc_register_dais() uses fmt_multiple_name()
-	 * for dai->name which is used for name based matching
-	 */
-	if (1 == num_dai)
-		ret = snd_soc_register_dai(dev, dai_drv);
-	else
-		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
-	if (ret < 0) {
-		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
-		goto error_component_name;
-	}
-
-	mutex_lock(&client_mutex);
-	list_add(&cmpnt->list, &component_list);
-	mutex_unlock(&client_mutex);
-
-	dev_dbg(cmpnt->dev, "ASoC: Registered component '%s'\n", cmpnt->name);
-
-	return ret;
-
-error_component_name:
-	kfree(cmpnt->name);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_register_component);
-
-/**
- * snd_soc_unregister_component - Unregister a component from the ASoC core
- *
- */
-void snd_soc_unregister_component(struct device *dev)
-{
-	struct snd_soc_component *cmpnt;
-
-	list_for_each_entry(cmpnt, &component_list, list) {
-		if (dev == cmpnt->dev)
-			goto found;
-	}
-	return;
-
-found:
-	snd_soc_unregister_dais(dev, cmpnt->num_dai);
-
-	mutex_lock(&client_mutex);
-	list_del(&cmpnt->list);
-	mutex_unlock(&client_mutex);
-
-	dev_dbg(dev, "ASoC: Unregistered component '%s'\n", cmpnt->name);
-	kfree(cmpnt->name);
-}
-EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
-
 /* Retrieve a card's name from device tree */
 int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 			       const char *propname)

commit e54cf76ba2c9ec071a68e98f2830226c0cac8086
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Mon Sep 16 13:01:46 2013 +0100

    ASoC: core: Add API for configuration of DAI BCLK ratio
    
    Some codec drivers when running in slave mode require that BCLK to sample rate ratio
    is explicitly set by the machine driver as it may not be exactly rate * frame size.
    
    Extend the DAI API by adding :-
    
    int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio);
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4d0561312f3b..31adad04222d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3576,6 +3576,22 @@ int snd_soc_codec_set_pll(struct snd_soc_codec *codec, int pll_id, int source,
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_pll);
 
+/**
+ * snd_soc_dai_set_bclk_ratio - configure BCLK to sample rate ratio.
+ * @dai: DAI
+ * @ratio Ratio of BCLK to Sample rate.
+ *
+ * Configures the DAI for a preset BCLK to sample rate ratio.
+ */
+int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
+{
+	if (dai->driver && dai->driver->ops->set_bclk_ratio)
+		return dai->driver->ops->set_bclk_ratio(dai, ratio);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
+
 /**
  * snd_soc_dai_set_fmt - configure DAI hardware audio format.
  * @dai: DAI

commit f90fb3f778042b0b9f9aa1fd48cb76047a25eac0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 31 20:31:15 2013 +0200

    ASoC: Remove infrastructure for supporting multiple cache types
    
    The only cache type left is the flat cache and new other cache types won't be
    added since new drivers are supposed to use regmap directly for IO and caching.
    This patch removes the snd_soc_cache_ops indirection that was added to support
    multiple cache types and modifies the code to always use the flat cache
    directly.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index af9648426f4f..16a3930c6375 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1590,17 +1590,13 @@ static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 		soc_remove_codec(codec);
 }
 
-static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,
-				    enum snd_soc_compress_type compress_type)
+static int snd_soc_init_codec_cache(struct snd_soc_codec *codec)
 {
 	int ret;
 
 	if (codec->cache_init)
 		return 0;
 
-	/* override the compress_type if necessary */
-	if (compress_type && codec->compress_type != compress_type)
-		codec->compress_type = compress_type;
 	ret = snd_soc_cache_init(codec);
 	if (ret < 0) {
 		dev_err(codec->dev,
@@ -1615,8 +1611,6 @@ static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,
 static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_codec *codec;
-	struct snd_soc_codec_conf *codec_conf;
-	enum snd_soc_compress_type compress_type;
 	struct snd_soc_dai_link *dai_link;
 	int ret, i, order, dai_fmt;
 
@@ -1640,19 +1634,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	list_for_each_entry(codec, &codec_list, list) {
 		if (codec->cache_init)
 			continue;
-		/* by default we don't override the compress_type */
-		compress_type = 0;
-		/* check to see if we need to override the compress_type */
-		for (i = 0; i < card->num_configs; ++i) {
-			codec_conf = &card->codec_conf[i];
-			if (!strcmp(codec->name, codec_conf->dev_name)) {
-				compress_type = codec_conf->compress_type;
-				if (compress_type && compress_type
-				    != codec->compress_type)
-					break;
-			}
-		}
-		ret = snd_soc_init_codec_cache(codec, compress_type);
+		ret = snd_soc_init_codec_cache(codec);
 		if (ret < 0)
 			goto base_error;
 	}
@@ -4175,11 +4157,6 @@ int snd_soc_register_codec(struct device *dev,
 		goto fail_codec;
 	}
 
-	if (codec_drv->compress_type)
-		codec->compress_type = codec_drv->compress_type;
-	else
-		codec->compress_type = SND_SOC_FLAT_COMPRESSION;
-
 	codec->write = codec_drv->write;
 	codec->read = codec_drv->read;
 	codec->volatile_register = codec_drv->volatile_register;

commit a94ed23436fb28bdcdd66e7fcf68ca5f7967e456
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 31 20:31:14 2013 +0200

    ASoC: Remove 'reg_size' field from snd_soc_codec struct
    
    The reg_size field is calculated in snd_soc_register_codec() and then used
    exactly once in snd_soc_flat_cache_init(). Since it is calculated based on other
    fields from the codec struct just move the calculation to
    snd_soc_flat_cache_init() and remove the 'reg_size' field from the codec struct.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bbe833ab657e..af9648426f4f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4159,7 +4159,6 @@ int snd_soc_register_codec(struct device *dev,
 			   struct snd_soc_dai_driver *dai_drv,
 			   int num_dai)
 {
-	size_t reg_size;
 	struct snd_soc_codec *codec;
 	int ret, i;
 
@@ -4197,12 +4196,6 @@ int snd_soc_register_codec(struct device *dev,
 	codec->num_dai = num_dai;
 	mutex_init(&codec->mutex);
 
-	/* allocate CODEC register cache */
-	if (codec_drv->reg_cache_size && codec_drv->reg_word_size) {
-		reg_size = codec_drv->reg_cache_size * codec_drv->reg_word_size;
-		codec->reg_size = reg_size;
-	}
-
 	for (i = 0; i < num_dai; i++) {
 		fixup_codec_formats(&dai_drv[i].playback);
 		fixup_codec_formats(&dai_drv[i].capture);

commit b012aa619e50d22df0835b64a5dcebc221fb8053
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 31 20:31:13 2013 +0200

    ASoC: Remove reg_def_copy
    
    reg_def_copy was introduced in commit 3335ddca ("ASoC: soc-cache: Use
    reg_def_copy instead of reg_cache_default") to keep a copy of the register
    defaults around in case the register defaults where placed in the __devinitdata
    section. With the __devinitdata section gone we effectivly keep the same data
    around twice. This patch removes reg_def_copy and uses reg_cache_default
    directly instead.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4ce02e6777e5..bbe833ab657e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4201,20 +4201,6 @@ int snd_soc_register_codec(struct device *dev,
 	if (codec_drv->reg_cache_size && codec_drv->reg_word_size) {
 		reg_size = codec_drv->reg_cache_size * codec_drv->reg_word_size;
 		codec->reg_size = reg_size;
-		/* it is necessary to make a copy of the default register cache
-		 * because in the case of using a compression type that requires
-		 * the default register cache to be marked as the
-		 * kernel might have freed the array by the time we initialize
-		 * the cache.
-		 */
-		if (codec_drv->reg_cache_default) {
-			codec->reg_def_copy = kmemdup(codec_drv->reg_cache_default,
-						      reg_size, GFP_KERNEL);
-			if (!codec->reg_def_copy) {
-				ret = -ENOMEM;
-				goto fail_codec_name;
-			}
-		}
 	}
 
 	for (i = 0; i < num_dai; i++) {
@@ -4273,7 +4259,6 @@ void snd_soc_unregister_codec(struct device *dev)
 	dev_dbg(codec->dev, "ASoC: Unregistered codec '%s'\n", codec->name);
 
 	snd_soc_cache_exit(codec);
-	kfree(codec->reg_def_copy);
 	kfree(codec->name);
 	kfree(codec);
 }

commit 2a1212a8342c469cee240cf69fe3001b898cda8e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 31 20:31:12 2013 +0200

    ASoC: Remove snd_soc_bulk_write_raw()
    
    No users of snd_soc_bulk_write_raw() are left and new drivers are going to use
    regmap directly for this, so the function can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f5ec301603d8..4ce02e6777e5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2298,13 +2298,6 @@ unsigned int snd_soc_write(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_write);
 
-unsigned int snd_soc_bulk_write_raw(struct snd_soc_codec *codec,
-				    unsigned int reg, const void *data, size_t len)
-{
-	return codec->bulk_write_raw(codec, reg, data, len);
-}
-EXPORT_SYMBOL_GPL(snd_soc_bulk_write_raw);
-
 /**
  * snd_soc_update_bits - update codec register bits
  * @codec: audio codec

commit 175ee39e8f4053f95e1948afd75c74552b3a175c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 31 20:31:11 2013 +0200

    ASoC: Remove support for reg_access_defaults
    
    No users of reg_access_defaults are left and new drivers are going to use regmap
    for this, so support for it can be removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4d0561312f3b..f5ec301603d8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4224,15 +4224,6 @@ int snd_soc_register_codec(struct device *dev,
 		}
 	}
 
-	if (codec_drv->reg_access_size && codec_drv->reg_access_default) {
-		if (!codec->volatile_register)
-			codec->volatile_register = snd_soc_default_volatile_register;
-		if (!codec->readable_register)
-			codec->readable_register = snd_soc_default_readable_register;
-		if (!codec->writable_register)
-			codec->writable_register = snd_soc_default_writable_register;
-	}
-
 	for (i = 0; i < num_dai; i++) {
 		fixup_codec_formats(&dai_drv[i].playback);
 		fixup_codec_formats(&dai_drv[i].capture);

commit ae10e7e8f1c9d021c8daca750d743cc3baa12e6d
Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>
Date:   Fri Sep 13 18:09:45 2013 +0100

    ASoC: core: Only add platform DAI widgets once.
    
    Currently platform CPU DAI widgets are created in soc_probe_platform and
    soc_probe_link_dais. Remove the extra call in soc_probe_link_dais().
    
    Signed-off-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4d0561312f3b..1a38be0d0ca8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1380,7 +1380,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 				return -ENODEV;
 
 			list_add(&cpu_dai->dapm.list, &card->dapm_list);
-			snd_soc_dapm_new_dai_widgets(&cpu_dai->dapm, cpu_dai);
 		}
 
 		if (cpu_dai->driver->probe) {

commit c79c33af8f867e57ad4b84102db7901aee67485a
Merge: 1c9a341bbdc1 824ef826f3c4
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Aug 30 11:04:14 2013 +0100

    Merge remote-tracking branch 'asoc/topic/core' into tmp

commit 824ef826f3c4d83d1925a5e351313bfd3e5ca6cb
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 27 15:51:01 2013 +0200

    ASoC: Pass card instead of dapm context to snd_soc_dapm_new_widgets()
    
    snd_soc_dapm_new_widgets() works on the ASoC card as a whole not on a specific
    DAPM context. The DAPM context that is passed as the parameter is only used to
    look up the pointer to the card. This patch updates the signature of
    snd_soc_dapm_new_widgets() to take the card directly.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d476f752e3f1..ed3c253066b1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1807,7 +1807,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		list_for_each_entry(codec, &card->codec_dev_list, card_list)
 			snd_soc_dapm_auto_nc_codec_pins(codec);
 
-	snd_soc_dapm_new_widgets(&card->dapm);
+	snd_soc_dapm_new_widgets(card);
 
 	ret = snd_card_register(card->snd_card);
 	if (ret < 0) {

commit dc1632321ba1e93dde25870e96cebe21b7d52517
Merge: 8c193b8dce4f a85f9da70736
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Aug 27 15:40:03 2013 +0100

    Merge remote-tracking branch 'asoc/topic/dmic' into asoc-core

commit 8c193b8dce4f2a2474dc2bc39ec972454df9d439
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 27 15:51:00 2013 +0200

    ASoC: Move call to snd_soc_dapm_new_widgets() after snd_soc_dapm_auto_nc_codec_pins()
    
    Call snd_soc_dapm_new_widgets() before the auto non-connected pins have been
    marked as not connected will power the system under the assumption that those
    pins are connected. Once the pins have been marked as disconnected the system
    there will be an additional power run. This can cause unnecessary power
    transitions. Calling snd_soc_dapm_new_widgets() only after the pins have been
    marked as non-connected avoids this.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 85e2a8b8f288..9375012ccb21 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1803,12 +1803,12 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
-	snd_soc_dapm_new_widgets(&card->dapm);
-
 	if (card->fully_routed)
 		list_for_each_entry(codec, &card->codec_dev_list, card_list)
 			snd_soc_dapm_auto_nc_codec_pins(codec);
 
+	snd_soc_dapm_new_widgets(&card->dapm);
+
 	ret = snd_card_register(card->snd_card);
 	if (ret < 0) {
 		dev_err(card->dev, "ASoC: failed to register soundcard %d\n",

commit 4b52fa211a7c65eab78acf3f434361d40de87688
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Aug 27 15:50:59 2013 +0200

    ASoC: Call snd_soc_dapm_new_widgets() only once during card initialization
    
    Each time snd_soc_dapm_new_widgets() is called it will instantiate all the
    widgets and routes that have been added so far and then power them. Doing this
    multiple times before the card is fully initialized and all widgets have been
    added can cause unnecessary and even invalid power state transitions which can
    result in extra register writes and and also might cause clicks and pops.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f46472d50c9b..85e2a8b8f288 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1230,9 +1230,6 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	}
 	rtd->card = card;
 
-	/* Make sure all DAPM widgets are instantiated */
-	snd_soc_dapm_new_widgets(&codec->dapm);
-
 	/* machine controls, routes and widgets are not prefixed */
 	temp = codec->name_prefix;
 	codec->name_prefix = NULL;
@@ -1728,8 +1725,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 					card->num_dapm_routes);
 
-	snd_soc_dapm_new_widgets(&card->dapm);
-
 	for (i = 0; i < card->num_links; i++) {
 		dai_link = &card->dai_link[i];
 		dai_fmt = dai_link->dai_fmt;

commit 68538bf2bce557c3b5fe8c59b034d45352500db1
Merge: a8cc20999799 43bcb402f84f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 23 14:12:22 2013 +0200

    Merge tag 'asoc-v3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: Updates for v3.12
    
    - DAPM is now mandatory for CODEC drivers in order to avoid the repeated
      regressions in the special cases for non-DAPM CODECs and make it
      easier to integrate with other components on boards.  All existing
      drivers have had some level of DAPM support added.
    - A lot of cleanups in DAPM plus support for maintaining controls in a
      specific state while a DAPM widget all contributed by Lars-Peter Clausen.
    - Core helpers for bitbanged AC'97 reset from Markus Pargmann.
    - New drivers and support for Analog Devices ADAU1702 and ADAU1401(a),
      Asahi Kasei Microdevices AK4554, Atmel AT91ASM9x5 and WM8904 based
      machines, Freescale S/PDIF and SSI AC'97, Renesas R-Car SoCs, Samsung
      Exynos5420 SoCs, Texas Instruments PCM1681 and PCM1792A and Wolfson
      Microelectronics WM8997.
    - Support for building drivers that can support it cross-platform for
      compile test.

commit 8157567013e7368e1945b16aa039a1bfaf2bea5a
Merge: e7ac4fb607a3 2820f6158fae
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Aug 22 14:28:31 2013 +0100

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 6234eabf84d6dcb2e28d4fdae43029c04c1bbc46
Merge: ece59528fa03 92bb4c32708e
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Aug 22 14:28:25 2013 +0100

    Merge remote-tracking branch 'asoc/topic/adsp' into asoc-next

commit 741a509f34d8d702f70d0ad99b8152c57d76961e
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Mon Aug 19 17:05:55 2013 +0200

    ASoC: core: Generic ac97 link reset functions
    
    This patch adds generic ac97 reset functions using pincontrol and gpio
    parsed from devicetree.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d82ee386eab5..b5c91f9aa160 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -30,9 +30,12 @@
 #include <linux/bitops.h>
 #include <linux/debugfs.h>
 #include <linux/platform_device.h>
+#include <linux/pinctrl/consumer.h>
 #include <linux/ctype.h>
 #include <linux/slab.h>
 #include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <sound/ac97_codec.h>
 #include <sound/core.h>
 #include <sound/jack.h>
@@ -69,6 +72,16 @@ static int pmdown_time = 5000;
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
+struct snd_ac97_reset_cfg {
+	struct pinctrl *pctl;
+	struct pinctrl_state *pstate_reset;
+	struct pinctrl_state *pstate_warm_reset;
+	struct pinctrl_state *pstate_run;
+	int gpio_sdata;
+	int gpio_sync;
+	int gpio_reset;
+};
+
 /* returns the minimum number of bytes needed to represent
  * a particular given value */
 static int min_bytes_needed(unsigned long val)
@@ -2080,6 +2093,117 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
 
+static struct snd_ac97_reset_cfg snd_ac97_rst_cfg;
+
+static void snd_soc_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_warm_reset);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 1);
+
+	udelay(10);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
+	msleep(2);
+}
+
+static void snd_soc_ac97_reset(struct snd_ac97 *ac97)
+{
+	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_reset);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sdata, 0);
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 0);
+
+	udelay(10);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 1);
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
+	msleep(2);
+}
+
+static int snd_soc_ac97_parse_pinctl(struct device *dev,
+		struct snd_ac97_reset_cfg *cfg)
+{
+	struct pinctrl *p;
+	struct pinctrl_state *state;
+	int gpio;
+	int ret;
+
+	p = devm_pinctrl_get(dev);
+	if (IS_ERR(p)) {
+		dev_err(dev, "Failed to get pinctrl\n");
+		return PTR_RET(p);
+	}
+	cfg->pctl = p;
+
+	state = pinctrl_lookup_state(p, "ac97-reset");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-reset\n");
+		return PTR_RET(state);
+	}
+	cfg->pstate_reset = state;
+
+	state = pinctrl_lookup_state(p, "ac97-warm-reset");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-warm-reset\n");
+		return PTR_RET(state);
+	}
+	cfg->pstate_warm_reset = state;
+
+	state = pinctrl_lookup_state(p, "ac97-running");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-running\n");
+		return PTR_RET(state);
+	}
+	cfg->pstate_run = state;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 0);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-sync gpio\n");
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link sync");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-sync gpio\n");
+		return ret;
+	}
+	cfg->gpio_sync = gpio;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 1);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-sdata gpio %d\n", gpio);
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link sdata");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-sdata gpio\n");
+		return ret;
+	}
+	cfg->gpio_sdata = gpio;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 2);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-reset gpio\n");
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link reset");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-reset gpio\n");
+		return ret;
+	}
+	cfg->gpio_reset = gpio;
+
+	return 0;
+}
+
 struct snd_ac97_bus_ops *soc_ac97_ops;
 EXPORT_SYMBOL_GPL(soc_ac97_ops);
 
@@ -2097,6 +2221,35 @@ int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
 }
 EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops);
 
+/**
+ * snd_soc_set_ac97_ops_of_reset - Set ac97 ops with generic ac97 reset functions
+ *
+ * This function sets the reset and warm_reset properties of ops and parses
+ * the device node of pdev to get pinctrl states and gpio numbers to use.
+ */
+int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
+		struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct snd_ac97_reset_cfg cfg;
+	int ret;
+
+	ret = snd_soc_ac97_parse_pinctl(dev, &cfg);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_set_ac97_ops(ops);
+	if (ret)
+		return ret;
+
+	ops->warm_reset = snd_soc_ac97_warm_reset;
+	ops->reset = snd_soc_ac97_reset;
+
+	snd_ac97_rst_cfg = cfg;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops_of_reset);
+
 /**
  * snd_soc_free_ac97_codec - free AC97 codec device
  * @codec: audio codec

commit 9a953e6f27fd280a2af5719b77394fbb228c5b46
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 10 21:33:10 2013 +0200

    ASoC: Use snd_soc_info_enum_double() for SOC_ENUM_EXT controls
    
    snd_soc_info_enum_ext() and snd_soc_info_enum_double() are almost identical. The
    only difference is that snd_soc_info_enum_double() is also able to handle stereo
    controls. Using snd_soc_info_enum double() instead of snd_soc_info_enum_ext()
    for the SOC_ENUM_EXT control's info callback allows us to remove
    snd_soc_info_enum_ext().
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6ba5f7c23d3a..f46472d50c9b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2550,33 +2550,6 @@ int snd_soc_put_value_enum_double(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_value_enum_double);
 
-/**
- * snd_soc_info_enum_ext - external enumerated single mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about an external enumerated
- * single mixer.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = e->max;
-
-	if (uinfo->value.enumerated.item > e->max - 1)
-		uinfo->value.enumerated.item = e->max - 1;
-	strcpy(uinfo->value.enumerated.name,
-		e->texts[uinfo->value.enumerated.item]);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_enum_ext);
-
 /**
  * snd_soc_info_volsw - single mixer info callback
  * @kcontrol: mixer control

commit c77f872e663e3f6ea18f774bf4399884884b4b22
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 10 21:33:09 2013 +0200

    ASoC: Remove unused snd_soc_info_volsw_ext()
    
    The SOC_SINGLE_EXT control has been using snd_soc_info_volsw() for its info
    callback since commit 1c433fb ("[ALSA] soc - 0.13 ASoC headers"). The
    snd_soc_info_volsw_ext() function has been unused ever since then, so remove it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c7d16df9efd9..6ba5f7c23d3a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2577,32 +2577,6 @@ int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_enum_ext);
 
-/**
- * snd_soc_info_volsw_ext - external single mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a single external mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	int max = kcontrol->private_value;
-
-	if (max == 1 && !strstr(kcontrol->id.name, " Volume"))
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	else
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = max;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
-
 /**
  * snd_soc_info_volsw - single mixer info callback
  * @kcontrol: mixer control

commit 34d2f1b6feac3bc7e6022d30d624e9f3687717d3
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 10 09:53:14 2013 +0200

    ASoC: Remove unused soc_pm_waitq
    
    The soc_pm_waitq waitqueue has been around as long as the ASoC framework
    existed, but has never been used so far, so remove it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2940e2c04525..c7d16df9efd9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -47,8 +47,6 @@
 
 #define NAME_SIZE	32
 
-static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
-
 #ifdef CONFIG_DEBUG_FS
 struct dentry *snd_soc_debugfs_root;
 EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);

commit 9d58a077465ff23b935042bf1cbdac64cdb78a2c
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Mon Aug 5 13:17:28 2013 +0100

    ASoC: core: init delayed_work for codec-codec links
    
    We must init the delayed_work for codec-codec links
    otherwise shutting down the DAI chain will fault when
    calling flush_delayed_work_sync() on the linked DAI.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0ec070cf7231..2940e2c04525 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -530,6 +530,15 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 }
 #endif
 
+static void codec2codec_close_delayed_work(struct work_struct *work)
+{
+	/* Currently nothing to do for c2c links
+	 * Since c2c links are internal nodes in the DAPM graph and
+	 * don't interface with the outside world or application layer
+	 * we don't have to do any special handling on close.
+	 */
+}
+
 #ifdef CONFIG_PM_SLEEP
 /* powers down audio subsystem for suspend */
 int snd_soc_suspend(struct device *dev)
@@ -1428,6 +1437,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 				return ret;
 			}
 		} else {
+			INIT_DELAYED_WORK(&rtd->delayed_work,
+						codec2codec_close_delayed_work);
+
 			/* link the DAI widgets */
 			play_w = codec_dai->playback_widget;
 			capture_w = cpu_dai->capture_widget;

commit 4fefd69853a4e83040ddaa98d3b6e5e12cc4f97a
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Jul 29 13:51:58 2013 +0100

    ASoC: core: Add snd_soc_card_get_kcontrol()
    
    This is useful for drivers who want to grab a pointer to
    snd_kcontrol outside of the kcontrol callbacks.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0ec070cf7231..cef714effc1e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2299,6 +2299,22 @@ static int snd_soc_add_controls(struct snd_card *card, struct device *dev,
 	return 0;
 }
 
+struct snd_kcontrol *snd_soc_card_get_kcontrol(struct snd_soc_card *soc_card,
+					       const char *name)
+{
+	struct snd_card *card = soc_card->snd_card;
+	struct snd_kcontrol *kctl;
+
+	if (unlikely(!name))
+		return NULL;
+
+	list_for_each_entry(kctl, &card->controls, list)
+		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name)))
+			return kctl;
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_card_get_kcontrol);
+
 /**
  * snd_soc_add_codec_controls - add an array of controls to a codec.
  * Convenience function to add a list of controls. Many codecs were

commit b5c745fb75b7e5ab06e9c99d63427595a234cc89
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Jul 22 09:56:54 2013 +0300

    ASoC: core: double free in snd_soc_add_platform()
    
    There are three callers for this function, and none of them want it to
    free platform for them.  It leads to a double free.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0ec070cf7231..d82ee386eab5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3908,10 +3908,8 @@ int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 {
 	/* create platform component name */
 	platform->name = fmt_single_name(dev, &platform->id);
-	if (platform->name == NULL) {
-		kfree(platform);
+	if (platform->name == NULL)
 		return -ENOMEM;
-	}
 
 	platform->dev = dev;
 	platform->driver = platform_drv;

commit b785a492c6eef578520594d5c4d6e9f2cb47cbeb
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Jul 19 16:24:59 2013 +0900

    ALSA: replace strict_strto*() with kstrto*()
    
    The usage of strict_strto*() is not preferred, because
    strict_strto*() is obsolete. Thus, kstrto*() should be
    used.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0ec070cf7231..88daa649fc06 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -192,7 +192,7 @@ static ssize_t pmdown_time_set(struct device *dev,
 	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
 	int ret;
 
-	ret = strict_strtol(buf, 10, &rtd->pmdown_time);
+	ret = kstrtol(buf, 10, &rtd->pmdown_time);
 	if (ret)
 		return ret;
 
@@ -237,6 +237,7 @@ static ssize_t codec_reg_write_file(struct file *file,
 	char *start = buf;
 	unsigned long reg, value;
 	struct snd_soc_codec *codec = file->private_data;
+	int ret;
 
 	buf_size = min(count, (sizeof(buf)-1));
 	if (copy_from_user(buf, user_buf, buf_size))
@@ -248,8 +249,9 @@ static ssize_t codec_reg_write_file(struct file *file,
 	reg = simple_strtoul(start, &start, 16);
 	while (*start == ' ')
 		start++;
-	if (strict_strtoul(start, 16, &value))
-		return -EINVAL;
+	ret = kstrtoul(start, 16, &value);
+	if (ret)
+		return ret;
 
 	/* Userspace has been fiddling around behind the kernel's back */
 	add_taint(TAINT_USER, LOCKDEP_NOW_UNRELIABLE);

commit ef866ac0c29223d01ce751bb342d8f4fa1b2580a
Merge: bc32134c0523 370887f10502
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 1 11:23:13 2013 +0200

    Merge tag 'asoc-v3.11-3' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Final updates for v3.11
    
    A few final updates:
    
     - A couple of additional bug fixes for the AC'97 refactoring.
     - Some fixes for the ADAU1701 driver.

commit f74b5e253a062004c1d30177f9889501423e403d
Author: Kevin Hilman <khilman@linaro.org>
Date:   Fri Jun 28 11:17:49 2013 -0700

    ASoC: ac97: fixup multi-platform AC'97 module build failure
    
    commit b047e1cc (ASoC: ac97: Support multi-platform AC'97) introduced
    some build failures for modules wanting to access the generic
    soc_ac97_ops.  For example:
    
    ERROR: "soc_ac97_ops" [sound/soc/codecs/snd-soc-wm9712.ko] undefined!
    
    To fix, export soc_ac97_ops to modules.
    
    Cc: Mark Brown <broonie@linaro.org>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 562d72e04e6e..0a8a5f50b466 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2080,6 +2080,7 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
 
 struct snd_ac97_bus_ops *soc_ac97_ops;
+EXPORT_SYMBOL_GPL(soc_ac97_ops);
 
 int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
 {

commit accaf69da1d1e64bd77ac0caad77e4cfc3b654c7
Merge: 975cc02a904a 27516080b21c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 28 13:36:22 2013 +0200

    Merge tag 'asoc-v3.11-2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: More updates for v3.11
    
    Some more fixes and enhancements, and also a bunch of refectoring for
    AC'97 support which enables more than one AC'97 controller driver to be
    built in.

commit b047e1cce8fe32475ab61846772943a5e4c0a908
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Jun 26 12:45:59 2013 +0100

    ASoC: ac97: Support multi-platform AC'97
    
    Currently we can only have a single platform built in with AC'97 support
    due to the use of a global variable to provide the bus operations. Fix
    this by making that variable a pointer and having the bus drivers set the
    operations prior to registering.
    
    This is not a particularly good or nice approach but it avoids blocking
    multiplatform and a real fix involves fixing the fairly deep problems
    with AC'97 support - we should be converting it to a real bus.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d56bbea6e75e..562d72e04e6e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2079,6 +2079,22 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
 
+struct snd_ac97_bus_ops *soc_ac97_ops;
+
+int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
+{
+	if (ops == soc_ac97_ops)
+		return 0;
+
+	if (soc_ac97_ops && ops)
+		return -EBUSY;
+
+	soc_ac97_ops = ops;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops);
+
 /**
  * snd_soc_free_ac97_codec - free AC97 codec device
  * @codec: audio codec

commit 2b581074357c42f63ae827ee28c9f244b91a38ac
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue May 14 11:05:32 2013 +0200

    ASoC: core: Use kasprintf instead of opencoding it
    
    kasprintf calculates the size of the result string, allocates a buffer large
    enough to hold the string and then performs the format string operation. There
    are a couple of places in ASoC where these three steps are done by hand and
    where kasprintf can be used instead.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9d95ef531308..4489c5b7b53a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2237,7 +2237,6 @@ struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
 	struct snd_kcontrol_new template;
 	struct snd_kcontrol *kcontrol;
 	char *name = NULL;
-	int name_len;
 
 	memcpy(&template, _template, sizeof(template));
 	template.index = 0;
@@ -2246,13 +2245,10 @@ struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
 		long_name = template.name;
 
 	if (prefix) {
-		name_len = strlen(long_name) + strlen(prefix) + 2;
-		name = kmalloc(name_len, GFP_KERNEL);
+		name = kasprintf(GFP_KERNEL, "%s %s", prefix, long_name);
 		if (!name)
 			return NULL;
 
-		snprintf(name, name_len, "%s %s", prefix, long_name);
-
 		template.name = name;
 	} else {
 		template.name = long_name;

commit 90996f43b3fa36075e501a52a3e2286896d74e79
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue May 14 11:05:30 2013 +0200

    ASoC: core: Move snd_soc_set_runtime_hwparams() to soc-pcm.c
    
    snd_soc_set_runtime_hwparams() is the only PCM related function that lives in
    soc-core.c. All other PCM related functions live in soc-pcm.c, so move
    snd_soc_set_runtime_hwparams() over as well for a bit more consistency.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 308895a438d6..9d95ef531308 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2219,29 +2219,6 @@ int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
 }
 EXPORT_SYMBOL_GPL(snd_soc_test_bits);
 
-/**
- * snd_soc_set_runtime_hwparams - set the runtime hardware parameters
- * @substream: the pcm substream
- * @hw: the hardware parameters
- *
- * Sets the substream runtime hardware parameters.
- */
-int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,
-	const struct snd_pcm_hardware *hw)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	runtime->hw.info = hw->info;
-	runtime->hw.formats = hw->formats;
-	runtime->hw.period_bytes_min = hw->period_bytes_min;
-	runtime->hw.period_bytes_max = hw->period_bytes_max;
-	runtime->hw.periods_min = hw->periods_min;
-	runtime->hw.periods_max = hw->periods_max;
-	runtime->hw.buffer_bytes_max = hw->buffer_bytes_max;
-	runtime->hw.fifo_size = hw->fifo_size;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);
-
 /**
  * snd_soc_cnew - create new control
  * @_template: control template

commit 10e8aa9af170886266618370e2ef330e0b2055bb
Author: Michał Mirosław <mirq-linux@rere.qmqm.pl>
Date:   Sat May 4 22:21:38 2013 +0200

    ASoC: fix kernel message grepability
    
    Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d56bbea6e75e..308895a438d6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -272,8 +272,8 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 	codec->debugfs_codec_root = debugfs_create_dir(codec->name,
 						       debugfs_card_root);
 	if (!codec->debugfs_codec_root) {
-		dev_warn(codec->dev, "ASoC: Failed to create codec debugfs"
-			" directory\n");
+		dev_warn(codec->dev,
+			"ASoC: Failed to create codec debugfs directory\n");
 		return;
 	}
 
@@ -286,8 +286,8 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 						 codec->debugfs_codec_root,
 						 codec, &codec_reg_fops);
 	if (!codec->debugfs_reg)
-		dev_warn(codec->dev, "ASoC: Failed to create codec register"
-			" debugfs file\n");
+		dev_warn(codec->dev,
+			"ASoC: Failed to create codec register debugfs file\n");
 
 	snd_soc_dapm_debugfs_init(&codec->dapm, codec->debugfs_codec_root);
 }
@@ -631,8 +631,7 @@ int snd_soc_suspend(struct device *dev)
 				 */
 				if (codec->dapm.idle_bias_off) {
 					dev_dbg(codec->dev,
-						"ASoC: idle_bias_off CODEC on"
-						" over suspend\n");
+						"ASoC: idle_bias_off CODEC on over suspend\n");
 					break;
 				}
 			case SND_SOC_BIAS_OFF:
@@ -643,8 +642,8 @@ int snd_soc_suspend(struct device *dev)
 					regcache_mark_dirty(codec->control_data);
 				break;
 			default:
-				dev_dbg(codec->dev, "ASoC: CODEC is on"
-					" over suspend\n");
+				dev_dbg(codec->dev,
+					"ASoC: CODEC is on over suspend\n");
 				break;
 			}
 		}
@@ -713,8 +712,8 @@ static void soc_resume_deferred(struct work_struct *work)
 				codec->suspended = 0;
 				break;
 			default:
-				dev_dbg(codec->dev, "ASoC: CODEC was on over"
-					" suspend\n");
+				dev_dbg(codec->dev,
+					"ASoC: CODEC was on over suspend\n");
 				break;
 			}
 		}
@@ -1110,8 +1109,8 @@ static int soc_probe_codec(struct snd_soc_card *card,
 		}
 		WARN(codec->dapm.idle_bias_off &&
 			codec->dapm.bias_level != SND_SOC_BIAS_OFF,
-			"codec %s can not start from non-off bias"
-			" with idle_bias_off==1\n", codec->name);
+			"codec %s can not start from non-off bias with idle_bias_off==1\n",
+			codec->name);
 	}
 
 	/* If the driver didn't set I/O up try regmap */
@@ -1582,8 +1581,9 @@ static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,
 		codec->compress_type = compress_type;
 	ret = snd_soc_cache_init(codec);
 	if (ret < 0) {
-		dev_err(codec->dev, "ASoC: Failed to set cache compression"
-			" type: %d\n", ret);
+		dev_err(codec->dev,
+			"ASoC: Failed to set cache compression type: %d\n",
+			ret);
 		return ret;
 	}
 	codec->cache_init = 1;
@@ -1639,8 +1639,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
 			card->owner, 0, &card->snd_card);
 	if (ret < 0) {
-		dev_err(card->dev, "ASoC: can't create sound card for"
-			" card %s: %d\n", card->name, ret);
+		dev_err(card->dev,
+			"ASoC: can't create sound card for card %s: %d\n",
+			card->name, ret);
 		goto base_error;
 	}
 	card->snd_card->dev = card->dev;
@@ -1815,8 +1816,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_rtd; i++) {
 		ret = soc_register_ac97_dai_link(&card->rtd[i]);
 		if (ret < 0) {
-			dev_err(card->dev, "ASoC: failed to register AC97:"
-				" %d\n", ret);
+			dev_err(card->dev,
+				"ASoC: failed to register AC97: %d\n", ret);
 			while (--i >= 0)
 				soc_unregister_ac97_dai_link(card->rtd[i].codec);
 			goto probe_aux_dev_err;
@@ -3586,14 +3587,16 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 * not both or neither.
 		 */
 		if (!!link->codec_name == !!link->codec_of_node) {
-			dev_err(card->dev, "ASoC: Neither/both codec"
-				" name/of_node are set for %s\n", link->name);
+			dev_err(card->dev,
+				"ASoC: Neither/both codec name/of_node are set for %s\n",
+				link->name);
 			return -EINVAL;
 		}
 		/* Codec DAI name must be specified */
 		if (!link->codec_dai_name) {
-			dev_err(card->dev, "ASoC: codec_dai_name not"
-				" set for %s\n", link->name);
+			dev_err(card->dev,
+				"ASoC: codec_dai_name not set for %s\n",
+				link->name);
 			return -EINVAL;
 		}
 
@@ -3602,8 +3605,9 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 * can be left unspecified, and a dummy platform will be used.
 		 */
 		if (link->platform_name && link->platform_of_node) {
-			dev_err(card->dev, "ASoC: Both platform name/of_node"
-				" are set for %s\n", link->name);
+			dev_err(card->dev,
+				"ASoC: Both platform name/of_node are set for %s\n",
+				link->name);
 			return -EINVAL;
 		}
 
@@ -3613,8 +3617,9 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 * name alone..
 		 */
 		if (link->cpu_name && link->cpu_of_node) {
-			dev_err(card->dev, "ASoC: Neither/both "
-				"cpu name/of_node are set for %s\n",link->name);
+			dev_err(card->dev,
+				"ASoC: Neither/both cpu name/of_node are set for %s\n",
+				link->name);
 			return -EINVAL;
 		}
 		/*
@@ -3623,8 +3628,9 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 */
 		if (!link->cpu_dai_name &&
 		    !(link->cpu_name || link->cpu_of_node)) {
-			dev_err(card->dev, "ASoC: Neither cpu_dai_name nor "
-				"cpu_name/of_node are set for %s\n", link->name);
+			dev_err(card->dev,
+				"ASoC: Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
+				link->name);
 			return -EINVAL;
 		}
 	}
@@ -3728,8 +3734,9 @@ static inline char *fmt_multiple_name(struct device *dev,
 		struct snd_soc_dai_driver *dai_drv)
 {
 	if (dai_drv->name == NULL) {
-		dev_err(dev, "ASoC: error - multiple DAI %s registered with"
-				" no name\n", dev_name(dev));
+		dev_err(dev,
+			"ASoC: error - multiple DAI %s registered with no name\n",
+			dev_name(dev));
 		return NULL;
 	}
 
@@ -3859,8 +3866,9 @@ static int snd_soc_register_dais(struct device *dev,
 
 		list_for_each_entry(codec, &codec_list, list) {
 			if (codec->dev == dev) {
-				dev_dbg(dev, "ASoC: Mapped DAI %s to "
-					"CODEC %s\n", dai->name, codec->name);
+				dev_dbg(dev,
+					"ASoC: Mapped DAI %s to CODEC %s\n",
+					dai->name, codec->name);
 				dai->codec = codec;
 				break;
 			}
@@ -4296,8 +4304,9 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 
 	num_routes = of_property_count_strings(np, propname);
 	if (num_routes < 0 || num_routes & 1) {
-		dev_err(card->dev, "ASoC: Property '%s' does not exist or its"
-			" length is not even\n", propname);
+		dev_err(card->dev,
+			"ASoC: Property '%s' does not exist or its length is not even\n",
+			propname);
 		return -EINVAL;
 	}
 	num_routes /= 2;

commit 8dd2b66d1a961231685a3bfe5937c85d846fbf5d
Merge: 126825e7ea27 24568ea4bef5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 18 16:24:31 2013 +0200

    Merge tag 'asoc-v3.10-2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: More updates for v3.10
    
    The main additional change here is Lars-Peter's DMA work plus the
    platform conversions which have been tested - getting this in mainline
    will make life easier for development after the merge window.  These
    factor a large chunk of code out of the drivers for the platforms using
    dmaengine, greatly simplifying development.

commit 753e23ea588d353da9d0a2672828336453607265
Merge: c999836d37c6 41ef2d5678d8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 17 14:24:35 2013 +0100

    Merge tag 'v3.9-rc7' into asoc-dma
    
    Linux 3.9-rc7

commit 71a45cda444f9c47bd63516cf4c24fb6d1ccb151
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 15 19:19:49 2013 +0200

    ASoC: Add snd_soc_{add, remove}_platform
    
    snd_soc_{add,remove}_platform are similar to snd_soc_register_platform and
    snd_soc_unregister_platform with the difference that they won't allocate and
    free the snd_soc_platform structure.
    
    Also add snd_soc_lookup_platform which looks up a platform by the device it has
    been registered for.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4d24b5ea3ba7..0e64af1a7df9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3901,21 +3901,14 @@ void snd_soc_unregister_dais(struct device *dev, size_t count)
 EXPORT_SYMBOL_GPL(snd_soc_unregister_dais);
 
 /**
- * snd_soc_register_platform - Register a platform with the ASoC core
- *
- * @platform: platform to register
+ * snd_soc_add_platform - Add a platform to the ASoC core
+ * @dev: The parent device for the platform
+ * @platform: The platform to add
+ * @platform_driver: The driver for the platform
  */
-int snd_soc_register_platform(struct device *dev,
+int snd_soc_add_platform(struct device *dev, struct snd_soc_platform *platform,
 		const struct snd_soc_platform_driver *platform_drv)
 {
-	struct snd_soc_platform *platform;
-
-	dev_dbg(dev, "ASoC: platform register %s\n", dev_name(dev));
-
-	platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);
-	if (platform == NULL)
-		return -ENOMEM;
-
 	/* create platform component name */
 	platform->name = fmt_single_name(dev, &platform->id);
 	if (platform->name == NULL) {
@@ -3938,30 +3931,76 @@ int snd_soc_register_platform(struct device *dev,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_register_platform);
+EXPORT_SYMBOL_GPL(snd_soc_add_platform);
 
 /**
- * snd_soc_unregister_platform - Unregister a platform from the ASoC core
+ * snd_soc_register_platform - Register a platform with the ASoC core
  *
- * @platform: platform to unregister
+ * @platform: platform to register
  */
-void snd_soc_unregister_platform(struct device *dev)
+int snd_soc_register_platform(struct device *dev,
+		const struct snd_soc_platform_driver *platform_drv)
 {
 	struct snd_soc_platform *platform;
+	int ret;
 
-	list_for_each_entry(platform, &platform_list, list) {
-		if (dev == platform->dev)
-			goto found;
-	}
-	return;
+	dev_dbg(dev, "ASoC: platform register %s\n", dev_name(dev));
 
-found:
+	platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);
+	if (platform == NULL)
+		return -ENOMEM;
+
+	ret = snd_soc_add_platform(dev, platform, platform_drv);
+	if (ret)
+		kfree(platform);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_platform);
+
+/**
+ * snd_soc_remove_platform - Remove a platform from the ASoC core
+ * @platform: the platform to remove
+ */
+void snd_soc_remove_platform(struct snd_soc_platform *platform)
+{
 	mutex_lock(&client_mutex);
 	list_del(&platform->list);
 	mutex_unlock(&client_mutex);
 
-	dev_dbg(dev, "ASoC: Unregistered platform '%s'\n", platform->name);
+	dev_dbg(platform->dev, "ASoC: Unregistered platform '%s'\n",
+		platform->name);
 	kfree(platform->name);
+}
+EXPORT_SYMBOL_GPL(snd_soc_remove_platform);
+
+struct snd_soc_platform *snd_soc_lookup_platform(struct device *dev)
+{
+	struct snd_soc_platform *platform;
+
+	list_for_each_entry(platform, &platform_list, list) {
+		if (dev == platform->dev)
+			return platform;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_lookup_platform);
+
+/**
+ * snd_soc_unregister_platform - Unregister a platform from the ASoC core
+ *
+ * @platform: platform to unregister
+ */
+void snd_soc_unregister_platform(struct device *dev)
+{
+	struct snd_soc_platform *platform;
+
+	platform = snd_soc_lookup_platform(dev);
+	if (!platform)
+		return;
+
+	snd_soc_remove_platform(platform);
 	kfree(platform);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);

commit 56c32c751cdf4aee810b4ad537ab1d836ee8f516
Merge: 54b019cbd993 379cf39781fd
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Apr 12 13:56:58 2013 +0100

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit 13419625774f9f3e65e07257ad2a7beb445e9942
Merge: 604c724ba38f 89cab4624a8c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Apr 12 13:56:56 2013 +0100

    Merge remote-tracking branch 'asoc/topic/component' into asoc-next

commit d79e57db84f8359bc96418900f86b8fc4189eff9
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Mar 27 12:02:22 2013 +0100

    ASoC: Constify the 'driver' field of snd_soc_platform
    
    The ASoC core does no not modify the driver of a platform. Making it const
    allows ASoC platform drivers to declare the snd_soc_platform_driver struct as
    const.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0ce075c47b25..4d24b5ea3ba7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3906,7 +3906,7 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dais);
  * @platform: platform to register
  */
 int snd_soc_register_platform(struct device *dev,
-		struct snd_soc_platform_driver *platform_drv)
+		const struct snd_soc_platform_driver *platform_drv)
 {
 	struct snd_soc_platform *platform;
 

commit 2e1cc199fc8666ac5fda200e8a99f1e4dea07175
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Mar 26 16:38:19 2013 -0600

    ASoC: export snd_soc_register_component
    
    Without this, modules will fail to link against those symbols.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f6cda7b6ce44..fb50e00a71e4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4192,6 +4192,7 @@ int snd_soc_register_component(struct device *dev,
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(snd_soc_register_component);
 
 /**
  * snd_soc_unregister_component - Unregister a component from the ASoC core
@@ -4217,6 +4218,7 @@ void snd_soc_unregister_component(struct device *dev)
 	dev_dbg(dev, "ASoC: Unregistered component '%s'\n", cmpnt->name);
 	kfree(cmpnt->name);
 }
+EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
 /* Retrieve a card's name from device tree */
 int snd_soc_of_parse_card_name(struct snd_soc_card *card,

commit f53179c026b11bef674d75154f5ea47ca3248ca9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 21 03:38:30 2013 -0700

    ASoC: snd_soc_[un]register_dai[s]() become non global function
    
    All drivers are using snd_soc_register_component()
    instead of snd_soc_register_dai[s]()
    snd_soc_[un]register_dai[s]() are no longer needed
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2ecaaf13e319..f6cda7b6ce44 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3739,7 +3739,7 @@ static inline char *fmt_multiple_name(struct device *dev,
  *
  * @dai: DAI to register
  */
-int snd_soc_register_dai(struct device *dev,
+static int snd_soc_register_dai(struct device *dev,
 		struct snd_soc_dai_driver *dai_drv)
 {
 	struct snd_soc_codec *codec;
@@ -3786,14 +3786,13 @@ int snd_soc_register_dai(struct device *dev,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 
 /**
  * snd_soc_unregister_dai - Unregister a DAI from the ASoC core
  *
  * @dai: DAI to unregister
  */
-void snd_soc_unregister_dai(struct device *dev)
+static void snd_soc_unregister_dai(struct device *dev)
 {
 	struct snd_soc_dai *dai;
 
@@ -3812,7 +3811,6 @@ void snd_soc_unregister_dai(struct device *dev)
 	kfree(dai->name);
 	kfree(dai);
 }
-EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
 
 /**
  * snd_soc_register_dais - Register multiple DAIs with the ASoC core
@@ -3820,7 +3818,7 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
  * @dai: Array of DAIs to register
  * @count: Number of DAIs
  */
-int snd_soc_register_dais(struct device *dev,
+static int snd_soc_register_dais(struct device *dev,
 		struct snd_soc_dai_driver *dai_drv, size_t count)
 {
 	struct snd_soc_codec *codec;
@@ -3884,7 +3882,6 @@ int snd_soc_register_dais(struct device *dev,
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(snd_soc_register_dais);
 
 /**
  * snd_soc_unregister_dais - Unregister multiple DAIs from the ASoC core
@@ -3892,14 +3889,13 @@ EXPORT_SYMBOL_GPL(snd_soc_register_dais);
  * @dai: Array of DAIs to unregister
  * @count: Number of DAIs
  */
-void snd_soc_unregister_dais(struct device *dev, size_t count)
+static void snd_soc_unregister_dais(struct device *dev, size_t count)
 {
 	int i;
 
 	for (i = 0; i < count; i++)
 		snd_soc_unregister_dai(dev);
 }
-EXPORT_SYMBOL_GPL(snd_soc_unregister_dais);
 
 /**
  * snd_soc_register_platform - Register a platform with the ASoC core

commit a1422b8cb443c6cfc58da38394673b8b8eda6458
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 21 03:27:13 2013 -0700

    ASoC: snd_soc_register_component() uses properly snd_soc_register_dai[s]()
    
    snd_soc_register_dai()  uses fmt_single_name(), and
    snd_soc_register_dais() uses fmt_multiple_name()
    for dai->name which is used for name based matching.
    This patch uses properly snd_soc_register_dai() it it was single driver,
    and uses snd_register_dais() if it were multiple drivers.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9e6118573fef..2ecaaf13e319 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4169,7 +4169,15 @@ int snd_soc_register_component(struct device *dev,
 	cmpnt->driver	= cmpnt_drv;
 	cmpnt->num_dai	= num_dai;
 
-	ret = snd_soc_register_dais(dev, dai_drv, num_dai);
+	/*
+	 * snd_soc_register_dai()  uses fmt_single_name(), and
+	 * snd_soc_register_dais() uses fmt_multiple_name()
+	 * for dai->name which is used for name based matching
+	 */
+	if (1 == num_dai)
+		ret = snd_soc_register_dai(dev, dai_drv);
+	else
+		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
 	if (ret < 0) {
 		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
 		goto error_component_name;

commit 0eaa6cca1f75e12e4f5ec62cbe887330fe3b5fe9
Author: Joonyoung Shim <jy0922.shim@samsung.com>
Date:   Tue Mar 26 14:41:05 2013 +0900

    ASoC: core: Fix to check return value of snd_soc_update_bits_locked()
    
    It can be 0 or 1 return value of snd_soc_update_bits_locked() when it is
    success. So just check return value is negative.
    
    Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 507d251916af..ff4b45a5d796 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2963,7 +2963,7 @@ int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
 	val = val << shift;
 
 	ret = snd_soc_update_bits_locked(codec, reg, val_mask, val);
-	if (ret != 0)
+	if (ret < 0)
 		return ret;
 
 	if (snd_soc_volsw_is_stereo(mc)) {

commit f7ba716f1e704a00d682a8697108f9c86497c551
Author: Silviu-Mihai Popescu <silviupopescu1990@gmail.com>
Date:   Sat Mar 16 13:45:34 2013 +0200

    ASoC: core: fix invalid free of devm_ allocated data
    
    The objects allocated by devm_* APIs are managed by devres and are freed when
    the device is detached. Hence there is no need to use kfree() explicitly.
    
    Signed-off-by: Silviu-Mihai Popescu <silviupopescu1990@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 93341deaa4b9..507d251916af 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4199,7 +4199,6 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 			dev_err(card->dev,
 				"ASoC: Property '%s' index %d could not be read: %d\n",
 				propname, 2 * i, ret);
-			kfree(routes);
 			return -EINVAL;
 		}
 		ret = of_property_read_string_index(np, propname,
@@ -4208,7 +4207,6 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 			dev_err(card->dev,
 				"ASoC: Property '%s' index %d could not be read: %d\n",
 				propname, (2 * i) + 1, ret);
-			kfree(routes);
 			return -EINVAL;
 		}
 	}

commit 030e79f658de11da43d32e7ad814b5d2d64c8bac
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Mar 11 18:27:21 2013 -0700

    ASoC: add snd_soc_register_component()
    
    Current ASoC has register function for platform/codec/dai/card,
    but doesn't have for cpu.
    It often produces confusion and fault on ASoC.
    
    As result of ASoC community discussion,
    we consider new struct snd_soc_component for CPU/CODEC,
    and will switch over to use it.
    
    This patch adds very basic struct snd_soc_component,
    and register function for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b7e84a7cd9ee..9e6118573fef 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -58,6 +58,7 @@ static DEFINE_MUTEX(client_mutex);
 static LIST_HEAD(dai_list);
 static LIST_HEAD(platform_list);
 static LIST_HEAD(codec_list);
+static LIST_HEAD(component_list);
 
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
@@ -4137,6 +4138,82 @@ void snd_soc_unregister_codec(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
 
+
+/**
+ * snd_soc_register_component - Register a component with the ASoC core
+ *
+ */
+int snd_soc_register_component(struct device *dev,
+			 const struct snd_soc_component_driver *cmpnt_drv,
+			 struct snd_soc_dai_driver *dai_drv,
+			 int num_dai)
+{
+	struct snd_soc_component *cmpnt;
+	int ret;
+
+	dev_dbg(dev, "component register %s\n", dev_name(dev));
+
+	cmpnt = devm_kzalloc(dev, sizeof(*cmpnt), GFP_KERNEL);
+	if (!cmpnt) {
+		dev_err(dev, "ASoC: Failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	cmpnt->name = fmt_single_name(dev, &cmpnt->id);
+	if (!cmpnt->name) {
+		dev_err(dev, "ASoC: Failed to simplifying name\n");
+		return -ENOMEM;
+	}
+
+	cmpnt->dev	= dev;
+	cmpnt->driver	= cmpnt_drv;
+	cmpnt->num_dai	= num_dai;
+
+	ret = snd_soc_register_dais(dev, dai_drv, num_dai);
+	if (ret < 0) {
+		dev_err(dev, "ASoC: Failed to regster DAIs: %d\n", ret);
+		goto error_component_name;
+	}
+
+	mutex_lock(&client_mutex);
+	list_add(&cmpnt->list, &component_list);
+	mutex_unlock(&client_mutex);
+
+	dev_dbg(cmpnt->dev, "ASoC: Registered component '%s'\n", cmpnt->name);
+
+	return ret;
+
+error_component_name:
+	kfree(cmpnt->name);
+
+	return ret;
+}
+
+/**
+ * snd_soc_unregister_component - Unregister a component from the ASoC core
+ *
+ */
+void snd_soc_unregister_component(struct device *dev)
+{
+	struct snd_soc_component *cmpnt;
+
+	list_for_each_entry(cmpnt, &component_list, list) {
+		if (dev == cmpnt->dev)
+			goto found;
+	}
+	return;
+
+found:
+	snd_soc_unregister_dais(dev, cmpnt->num_dai);
+
+	mutex_lock(&client_mutex);
+	list_del(&cmpnt->list);
+	mutex_unlock(&client_mutex);
+
+	dev_dbg(dev, "ASoC: Unregistered component '%s'\n", cmpnt->name);
+	kfree(cmpnt->name);
+}
+
 /* Retrieve a card's name from device tree */
 int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 			       const char *propname)

commit e8b18addee32d1f389573b4c116e67ae230216ad
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Tue Mar 12 00:35:14 2013 +0800

    ASoC: core: fix possible memory leak in snd_soc_bytes_put()
    
    'data' is malloced in snd_soc_bytes_put() and should be freed
    before leaving from the error handling cases, otherwise it will cause
    memory leak.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b7e84a7cd9ee..93341deaa4b9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3140,7 +3140,7 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 	if (params->mask) {
 		ret = regmap_read(codec->control_data, params->base, &val);
 		if (ret != 0)
-			return ret;
+			goto out;
 
 		val &= params->mask;
 
@@ -3158,13 +3158,15 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 			((u32 *)data)[0] |= cpu_to_be32(val);
 			break;
 		default:
-			return -EINVAL;
+			ret = -EINVAL;
+			goto out;
 		}
 	}
 
 	ret = regmap_raw_write(codec->control_data, params->base,
 			       data, len);
 
+out:
 	kfree(data);
 
 	return ret;

commit e1328a832c7eeeb4dd3c3666605717c555de9e83
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Mar 7 17:42:33 2013 -0800

    ASoC: core: remove codec from list if registration failed
    
    Current snd_soc_register_codec() adds codec to list, and calls
    snd_soc_register_dais().
    But, this listed codec should be removed if dais registration
    was failed.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e02c374d2243..0ce075c47b25 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4096,6 +4096,10 @@ int snd_soc_register_codec(struct device *dev,
 	return 0;
 
 fail_codec_name:
+	mutex_lock(&client_mutex);
+	list_del(&codec->list);
+	mutex_unlock(&client_mutex);
+
 	kfree(codec->name);
 fail_codec:
 	kfree(codec);

commit 5acd7dfbd7851446fb1d2c947661d365e4c635a0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 25 00:40:40 2013 -0800

    ASoC: core: use snd_soc_register_dais() on codec
    
    snd_soc_register_dais() considers dai counts inside.
    snd_soc_register_codec() does not need to care for it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a872be1ee44d..e02c374d2243 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4086,11 +4086,10 @@ int snd_soc_register_codec(struct device *dev,
 	mutex_unlock(&client_mutex);
 
 	/* register any DAIs */
-	if (num_dai) {
-		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
-		if (ret < 0)
-			dev_err(codec->dev, "ASoC: Failed to regster"
-				" DAIs: %d\n", ret);
+	ret = snd_soc_register_dais(dev, dai_drv, num_dai);
+	if (ret < 0) {
+		dev_err(codec->dev, "ASoC: Failed to regster DAIs: %d\n", ret);
+		goto fail_codec_name;
 	}
 
 	dev_dbg(codec->dev, "ASoC: Registered codec '%s'\n", codec->name);
@@ -4112,7 +4111,6 @@ EXPORT_SYMBOL_GPL(snd_soc_register_codec);
 void snd_soc_unregister_codec(struct device *dev)
 {
 	struct snd_soc_codec *codec;
-	int i;
 
 	list_for_each_entry(codec, &codec_list, list) {
 		if (dev == codec->dev)
@@ -4121,9 +4119,7 @@ void snd_soc_unregister_codec(struct device *dev)
 	return;
 
 found:
-	if (codec->num_dai)
-		for (i = 0; i < codec->num_dai; i++)
-			snd_soc_unregister_dai(dev);
+	snd_soc_unregister_dais(dev, codec->num_dai);
 
 	mutex_lock(&client_mutex);
 	list_del(&codec->list);

commit f790b94d7867fb0555f91ae920b9001b42ae38a6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Feb 25 00:40:09 2013 -0800

    ASoC: core: tidyup snd_soc_register_codec() fail case
    
    kfree() on snd_soc_register_codec() was summarized to one place.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b7e84a7cd9ee..a872be1ee44d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4022,8 +4022,8 @@ int snd_soc_register_codec(struct device *dev,
 	/* create CODEC component name */
 	codec->name = fmt_single_name(dev, &codec->id);
 	if (codec->name == NULL) {
-		kfree(codec);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto fail_codec;
 	}
 
 	if (codec_drv->compress_type)
@@ -4062,7 +4062,7 @@ int snd_soc_register_codec(struct device *dev,
 						      reg_size, GFP_KERNEL);
 			if (!codec->reg_def_copy) {
 				ret = -ENOMEM;
-				goto fail;
+				goto fail_codec_name;
 			}
 		}
 	}
@@ -4096,8 +4096,9 @@ int snd_soc_register_codec(struct device *dev,
 	dev_dbg(codec->dev, "ASoC: Registered codec '%s'\n", codec->name);
 	return 0;
 
-fail:
+fail_codec_name:
 	kfree(codec->name);
+fail_codec:
 	kfree(codec);
 	return ret;
 }

commit 9043a2650cd21f96f831a97f516c2c302e21fb70
Merge: ab7826595e9e d9d8d7ed498e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 15:41:43 2013 -0800

    Merge tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux
    
    Pull module update from Rusty Russell:
     "The sweeping change is to make add_taint() explicitly indicate whether
      to disable lockdep, but it's a mechanical change."
    
    * tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux:
      MODSIGN: Add option to not sign modules during modules_install
      MODSIGN: Add -s <signature> option to sign-file
      MODSIGN: Specify the hash algorithm on sign-file command line
      MODSIGN: Simplify Makefile with a Kconfig helper
      module: clean up load_module a little more.
      modpost: Ignore ARC specific non-alloc sections
      module: constify within_module_*
      taint: add explicit flag to show whether lock dep is still OK.
      module: printk message when module signature fail taints kernel.

commit 556d8b55d083ad487067680feaf179664172bd4e
Merge: f0f3214e8be1 8c2d6a9f9cfa
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Feb 11 11:06:38 2013 +0000

    Merge remote-tracking branch 'asoc/topic/of' into asoc-next

commit d289323286d6b4e738458c31533da51d294d28a0
Merge: 6a47366973be b5a8fe439ab3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Feb 11 11:06:30 2013 +0000

    Merge remote-tracking branch 'asoc/topic/core' into asoc-next

commit da18396f949ecaa45007d3aeb1b81bd6da092811
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Feb 6 15:44:07 2013 +0000

    ASoC: core: Allow digital mute for capture
    
    Help avoid noise from the power up of the capture path propagating through
    into the start of the recording (especially noise caused by the ramp of
    microphone biases) by keeping the capture muted until after we've finished
    powering things up with DAPM in the same manner we do for playback. This
    allows us to take advantage of soft mute support in the hardware more
    effectively and is more consistent.
    
    The core code using the existing digital mute operation is updated to take
    advantage of this. Some additional cases in the soc-pcm code and suspend
    will need separate handling but these are less practically relevant than
    the main runtime stream start/stop case.
    
    Rather than refactor the digital mute function in every single driver a
    new operation is added for drivers taking advantage of this functionality,
    the old operation should be phased out over time.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by Vinod Koul <vinod.koul@intel.com>
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2370063b5824..4eac22797893 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3540,12 +3540,20 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
  * snd_soc_dai_digital_mute - configure DAI system or master clock.
  * @dai: DAI
  * @mute: mute enable
+ * @direction: stream to mute
  *
  * Mutes the DAI DAC.
  */
-int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
+int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,
+			     int direction)
 {
-	if (dai->driver && dai->driver->ops->digital_mute)
+	if (!dai->driver)
+		return -ENOTSUPP;
+
+	if (dai->driver->ops->mute_stream)
+		return dai->driver->ops->mute_stream(dai, mute, direction);
+	else if (direction == SNDRV_PCM_STREAM_PLAYBACK &&
+		 dai->driver->ops->digital_mute)
 		return dai->driver->ops->digital_mute(dai, mute);
 	else
 		return -ENOTSUPP;

commit 8c2d6a9f9cfa59acfa63ee88e70d58f0ba3eaf21
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jan 29 21:03:36 2013 -0800

    ASoC: clock gating is decided by bool on snd_soc_of_parse_daifmt()
    
    ASoC clock gate settings are continuous/gated only.
    This patch decides it as bool, then, gated clock will be default.
    Special thanks to Stephen
    
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9d07dc03a1d3..b3d75d2c966a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4229,9 +4229,6 @@ unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 		{ "pdm",	SND_SOC_DAIFMT_PDM},
 		{ "msb",	SND_SOC_DAIFMT_MSB },
 		{ "lsb",	SND_SOC_DAIFMT_LSB },
-	}, of_clock_table[] = {
-		{ "continuous",	SND_SOC_DAIFMT_CONT },
-		{ "gated",	SND_SOC_DAIFMT_GATED },
 	};
 
 	if (!prefix)
@@ -4253,19 +4250,14 @@ unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
 	}
 
 	/*
-	 * check "[prefix]clock-gating = xxx"
+	 * check "[prefix]continuous-clock"
 	 * SND_SOC_DAIFMT_CLOCK_MASK area
 	 */
-	snprintf(prop, sizeof(prop), "%sclock-gating", prefix);
-	ret = of_property_read_string(np, prop, &str);
-	if (ret == 0) {
-		for (i = 0; i < ARRAY_SIZE(of_clock_table); i++) {
-			if (strcmp(str, of_clock_table[i].name) == 0) {
-				format |= of_clock_table[i].val;
-				break;
-			}
-		}
-	}
+	snprintf(prop, sizeof(prop), "%scontinuous-clock", prefix);
+	if (of_get_property(np, prop, NULL))
+		format |= SND_SOC_DAIFMT_CONT;
+	else
+		format |= SND_SOC_DAIFMT_GATED;
 
 	/*
 	 * check "[prefix]bitclock-inversion"

commit a7930ed458afeacb029cee2b22f77b2a15472ad6
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jan 14 18:36:04 2013 -0800

    ASoC: add snd_soc_of_parse_daifmt() for DeviceTree
    
    This patch adds snd_soc_of_parse_daifmt() and supports below style on DT.
    
            [prefix]format = "i2c";
            [prefix]clock-gating = "continuous";
            [prefix]bitclock-inversion;
            [prefix]bitclock-master;
            [prefix]frame-master;
    
    Each driver can use specific [prefix]
    (ex simple-card,cpu,dai,format = xxx;)
    
    This sample will be
    SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CONT |
    SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBM_CFM
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2370063b5824..9d07dc03a1d3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4208,6 +4208,121 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_routing);
 
+unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
+				     const char *prefix)
+{
+	int ret, i;
+	char prop[128];
+	unsigned int format = 0;
+	int bit, frame;
+	const char *str;
+	struct {
+		char *name;
+		unsigned int val;
+	} of_fmt_table[] = {
+		{ "i2s",	SND_SOC_DAIFMT_I2S },
+		{ "right_j",	SND_SOC_DAIFMT_RIGHT_J },
+		{ "left_j",	SND_SOC_DAIFMT_LEFT_J },
+		{ "dsp_a",	SND_SOC_DAIFMT_DSP_A },
+		{ "dsp_b",	SND_SOC_DAIFMT_DSP_B },
+		{ "ac97",	SND_SOC_DAIFMT_AC97 },
+		{ "pdm",	SND_SOC_DAIFMT_PDM},
+		{ "msb",	SND_SOC_DAIFMT_MSB },
+		{ "lsb",	SND_SOC_DAIFMT_LSB },
+	}, of_clock_table[] = {
+		{ "continuous",	SND_SOC_DAIFMT_CONT },
+		{ "gated",	SND_SOC_DAIFMT_GATED },
+	};
+
+	if (!prefix)
+		prefix = "";
+
+	/*
+	 * check "[prefix]format = xxx"
+	 * SND_SOC_DAIFMT_FORMAT_MASK area
+	 */
+	snprintf(prop, sizeof(prop), "%sformat", prefix);
+	ret = of_property_read_string(np, prop, &str);
+	if (ret == 0) {
+		for (i = 0; i < ARRAY_SIZE(of_fmt_table); i++) {
+			if (strcmp(str, of_fmt_table[i].name) == 0) {
+				format |= of_fmt_table[i].val;
+				break;
+			}
+		}
+	}
+
+	/*
+	 * check "[prefix]clock-gating = xxx"
+	 * SND_SOC_DAIFMT_CLOCK_MASK area
+	 */
+	snprintf(prop, sizeof(prop), "%sclock-gating", prefix);
+	ret = of_property_read_string(np, prop, &str);
+	if (ret == 0) {
+		for (i = 0; i < ARRAY_SIZE(of_clock_table); i++) {
+			if (strcmp(str, of_clock_table[i].name) == 0) {
+				format |= of_clock_table[i].val;
+				break;
+			}
+		}
+	}
+
+	/*
+	 * check "[prefix]bitclock-inversion"
+	 * check "[prefix]frame-inversion"
+	 * SND_SOC_DAIFMT_INV_MASK area
+	 */
+	snprintf(prop, sizeof(prop), "%sbitclock-inversion", prefix);
+	bit = !!of_get_property(np, prop, NULL);
+
+	snprintf(prop, sizeof(prop), "%sframe-inversion", prefix);
+	frame = !!of_get_property(np, prop, NULL);
+
+	switch ((bit << 4) + frame) {
+	case 0x11:
+		format |= SND_SOC_DAIFMT_IB_IF;
+		break;
+	case 0x10:
+		format |= SND_SOC_DAIFMT_IB_NF;
+		break;
+	case 0x01:
+		format |= SND_SOC_DAIFMT_NB_IF;
+		break;
+	default:
+		/* SND_SOC_DAIFMT_NB_NF is default */
+		break;
+	}
+
+	/*
+	 * check "[prefix]bitclock-master"
+	 * check "[prefix]frame-master"
+	 * SND_SOC_DAIFMT_MASTER_MASK area
+	 */
+	snprintf(prop, sizeof(prop), "%sbitclock-master", prefix);
+	bit = !!of_get_property(np, prop, NULL);
+
+	snprintf(prop, sizeof(prop), "%sframe-master", prefix);
+	frame = !!of_get_property(np, prop, NULL);
+
+	switch ((bit << 4) + frame) {
+	case 0x11:
+		format |= SND_SOC_DAIFMT_CBM_CFM;
+		break;
+	case 0x10:
+		format |= SND_SOC_DAIFMT_CBM_CFS;
+		break;
+	case 0x01:
+		format |= SND_SOC_DAIFMT_CBS_CFM;
+		break;
+	default:
+		format |= SND_SOC_DAIFMT_CBS_CFS;
+		break;
+	}
+
+	return format;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_daifmt);
+
 static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS

commit b5a8fe439ab343631d905a51438db3de54ba94df
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jan 20 21:42:22 2013 +0900

    ASoC: core: Ensure SND_SOC_BYTES writes are from DMA safe memory
    
    With some buses the transfers may DMAed, especially for larger blocks.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e0e8ce0c031a..02d826efd7f9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3097,9 +3097,12 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 	if (!codec->using_regmap)
 		return -EINVAL;
 
-	data = ucontrol->value.bytes.data;
 	len = params->num_regs * codec->val_bytes;
 
+	data = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);
+	if (!data)
+		return -ENOMEM;
+
 	/*
 	 * If we've got a mask then we need to preserve the register
 	 * bits.  We shouldn't modify the incoming data so take a
@@ -3112,10 +3115,6 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 
 		val &= params->mask;
 
-		data = kmemdup(data, len, GFP_KERNEL);
-		if (!data)
-			return -ENOMEM;
-
 		switch (codec->val_bytes) {
 		case 1:
 			((u8 *)data)[0] &= ~params->mask;
@@ -3137,8 +3136,7 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 	ret = regmap_raw_write(codec->control_data, params->base,
 			       data, len);
 
-	if (params->mask)
-		kfree(data);
+	kfree(data);
 
 	return ret;
 }

commit 373d4d099761cb1f637bed488ab3871945882273
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Jan 21 17:17:39 2013 +1030

    taint: add explicit flag to show whether lock dep is still OK.
    
    Fix up all callers as they were before, with make one change: an
    unsigned module taints the kernel, but doesn't turn off lockdep.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2370063b5824..4c6526c0db03 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -251,7 +251,7 @@ static ssize_t codec_reg_write_file(struct file *file,
 		return -EINVAL;
 
 	/* Userspace has been fiddling around behind the kernel's back */
-	add_taint(TAINT_USER);
+	add_taint(TAINT_USER, LOCKDEP_NOW_UNRELIABLE);
 
 	snd_soc_write(codec, reg, value);
 	return buf_size;

commit d3bf1561253383a3dbcc40afdb2b039d56093a3e
Author: Chuansheng Liu <chuansheng.liu@intel.com>
Date:   Wed Dec 26 00:57:32 2012 +0800

    ASoC: core: fix the memory leak in case of remove_aux_dev()
    
    When probing aux_dev, initializing is as below:
    device_initialize()
    device_add()
    
    So when remove aux_dev, we need do as below:
    device_del()
    device_put()
    Otherwise, the rtd_release() will not be called.
    
    So here using device_unregister() to replace device_del(),
    like the action in soc_remove_link_dais().
    Signed-off-by: liu chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f7551c1c827c..2370063b5824 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1556,7 +1556,7 @@ static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
 		device_remove_file(rtd->dev, &dev_attr_codec_reg);
-		device_del(rtd->dev);
+		device_unregister(rtd->dev);
 		rtd->dev_registered = 0;
 	}
 

commit 865df9cb122d9e5ecbbb7056f2c9c64933bf8dd0
Author: Chuansheng Liu <chuansheng.liu@intel.com>
Date:   Wed Dec 26 00:56:05 2012 +0800

    ASoC: core: fix the memory leak in case of device_add() failure
    
    After called device_initialize(), even device_add() returns
    error, we still need use the put_device() to release the reference
    to call rtd_release(), which will do the free() action.
    
    Signed-off-by: liu chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 29046e750ad7..f7551c1c827c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1255,6 +1255,8 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].fe_clients);
 	ret = device_add(rtd->dev);
 	if (ret < 0) {
+		/* calling put_device() here to free the rtd->dev */
+		put_device(rtd->dev);
 		dev_err(card->dev,
 			"ASoC: failed to register runtime device: %d\n", ret);
 		return ret;

commit ff541f4b2a7546ffa8edf123f4b3b49bb24574e2
Author: Chuansheng Liu <chuansheng.liu@intel.com>
Date:   Fri Dec 21 18:17:12 2012 +0800

    ASoC: core: giving WARN when device starting from non-off bias with idle_bias_off
    
    Just found some cases that some codec drivers set the bias to _STANDBY and
    set idle_bias_off to 1 during probing.
    It will cause unpaired runtime_get_sync/put() issue. Also as Mark suggested,
    there is no reason to start from _STANDBY bias with idle_bias_off == 1.
    
    So here giving one warning when detected (dapm.idle_bias_off == 1) and
    (dapm.bias_level != SND_SOC_BIAS_OFF) just after driver->probe().
    
    Signed-off-by: liu chuansheng <chuansheng.liu@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 91d592ff67b7..e0e8ce0c031a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1107,6 +1107,10 @@ static int soc_probe_codec(struct snd_soc_card *card,
 				"ASoC: failed to probe CODEC %d\n", ret);
 			goto err_probe;
 		}
+		WARN(codec->dapm.idle_bias_off &&
+			codec->dapm.bias_level != SND_SOC_BIAS_OFF,
+			"codec %s can not start from non-off bias"
+			" with idle_bias_off==1\n", codec->name);
 	}
 
 	/* If the driver didn't set I/O up try regmap */

commit 5db1bc1892aa70d378ea7563852ae87f3772519b
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sat Dec 22 10:38:14 2012 -0200

    ASoC: soc-core: Remove unused 'ret' variable
    
    commit 9bde4f0b1c (ASoC: core: Fix SOC_DOUBLE_RANGE() macros) introduced
    the following build warning:
    
    sound/soc/soc-core.c:2999:6: warning: unused variable 'ret' [-Wunused-variable]
    
    Remove the unused 'ret' variable.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e0d4630bfb4f..29046e750ad7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2996,7 +2996,6 @@ int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
 	int max = mc->max;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
-	int ret;
 
 	ucontrol->value.integer.value[0] =
 		(snd_soc_read(codec, reg) >> shift) & mask;

commit 9bde4f0b1c83d1129a9fc8ec5b2611ba6dab1215
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 19 16:05:00 2012 +0000

    ASoC: core: Fix SOC_DOUBLE_RANGE() macros
    
    Although we've had macros defining double _RANGE controls for a while now
    they've not actually been backed up properly by the implementation, it's
    treated everything as mono. Fix that by implementing the handling in the
    stereo controls, ensuring that the mono controls don't mistakenly get
    treated as stereo.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 91d592ff67b7..e0d4630bfb4f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2917,7 +2917,7 @@ int snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,
 	platform_max = mc->platform_max;
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
+	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
 	uinfo->value.integer.min = 0;
 	uinfo->value.integer.max = platform_max - min;
 
@@ -2941,12 +2941,14 @@ int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
+	unsigned int rreg = mc->rreg;
 	unsigned int shift = mc->shift;
 	int min = mc->min;
 	int max = mc->max;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
 	unsigned int val, val_mask;
+	int ret;
 
 	val = ((ucontrol->value.integer.value[0] + min) & mask);
 	if (invert)
@@ -2954,7 +2956,21 @@ int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
 	val_mask = mask << shift;
 	val = val << shift;
 
-	return snd_soc_update_bits_locked(codec, reg, val_mask, val);
+	ret = snd_soc_update_bits_locked(codec, reg, val_mask, val);
+	if (ret != 0)
+		return ret;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		val = ((ucontrol->value.integer.value[1] + min) & mask);
+		if (invert)
+			val = max - val;
+		val_mask = mask << shift;
+		val = val << shift;
+
+		ret = snd_soc_update_bits_locked(codec, rreg, val_mask, val);
+	}
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_range);
 
@@ -2974,11 +2990,13 @@ int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
+	unsigned int rreg = mc->rreg;
 	unsigned int shift = mc->shift;
 	int min = mc->min;
 	int max = mc->max;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
+	int ret;
 
 	ucontrol->value.integer.value[0] =
 		(snd_soc_read(codec, reg) >> shift) & mask;
@@ -2988,6 +3006,16 @@ int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
 	ucontrol->value.integer.value[0] =
 		ucontrol->value.integer.value[0] - min;
 
+	if (snd_soc_volsw_is_stereo(mc)) {
+		ucontrol->value.integer.value[1] =
+			(snd_soc_read(codec, rreg) >> shift) & mask;
+		if (invert)
+			ucontrol->value.integer.value[1] =
+				max - ucontrol->value.integer.value[1];
+		ucontrol->value.integer.value[1] =
+			ucontrol->value.integer.value[1] - min;
+	}
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_volsw_range);

commit 36adf15107d3e74200e0ffc0f3678ee27c5376a7
Merge: 20694ad27874 c871bd0b2e62
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Dec 15 23:56:45 2012 +0900

    Merge remote-tracking branch 'asoc/topic/log' into asoc-next

commit c871bd0b2e627ff387d0ff055d8175879c80d01f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 10 16:19:52 2012 +0900

    ASoC: core: Fix splitting of log messages
    
    Don't wrap log messages over multiple lines, it makes them hard to grep
    for.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cee37ee6f180..0d42afb3c552 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4155,9 +4155,9 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		ret = of_property_read_string_index(np, propname,
 			2 * i, &routes[i].sink);
 		if (ret) {
-			dev_err(card->dev, "ASoC: Property '%s' index %d"
-				" could not be read: %d\n", propname, 2 * i,
-				ret);
+			dev_err(card->dev,
+				"ASoC: Property '%s' index %d could not be read: %d\n",
+				propname, 2 * i, ret);
 			kfree(routes);
 			return -EINVAL;
 		}
@@ -4165,8 +4165,8 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 			(2 * i) + 1, &routes[i].source);
 		if (ret) {
 			dev_err(card->dev,
-				"ASoC: Property '%s' index %d could not be"
-				" read: %d\n", propname, (2 * i) + 1, ret);
+				"ASoC: Property '%s' index %d could not be read: %d\n",
+				propname, (2 * i) + 1, ret);
 			kfree(routes);
 			return -EINVAL;
 		}

commit 4301aecbdfd2616c500ef629a463638dcd573a72
Merge: edbe08adea97 b1bc7b3c9c46
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 10 00:22:14 2012 +0900

    Merge remote-tracking branch 'asoc/topic/log' into asoc-next

commit f110bfc7ac552f2518d38067e5facf53c24748ba
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Nov 19 14:47:09 2012 +0000

    ASoC: core: Standardise ASoC messages
    
    Currently ASoC has a mixture of message prefixes e.g. "ASoC", "asoc"
    or none and message types e.g. pr_debug or dev_dbg.
    
    Make sure all ASoC core messages use the same "ASoC" prefix and
    convert any component device specific messages to use dev_dbg
    instead of pr_debug.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 10d21be383f6..cee37ee6f180 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -271,7 +271,8 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 	codec->debugfs_codec_root = debugfs_create_dir(codec->name,
 						       debugfs_card_root);
 	if (!codec->debugfs_codec_root) {
-		dev_warn(codec->dev, "Failed to create codec debugfs directory\n");
+		dev_warn(codec->dev, "ASoC: Failed to create codec debugfs"
+			" directory\n");
 		return;
 	}
 
@@ -284,7 +285,8 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 						 codec->debugfs_codec_root,
 						 codec, &codec_reg_fops);
 	if (!codec->debugfs_reg)
-		dev_warn(codec->dev, "Failed to create codec register debugfs file\n");
+		dev_warn(codec->dev, "ASoC: Failed to create codec register"
+			" debugfs file\n");
 
 	snd_soc_dapm_debugfs_init(&codec->dapm, codec->debugfs_codec_root);
 }
@@ -302,7 +304,7 @@ static void soc_init_platform_debugfs(struct snd_soc_platform *platform)
 						       debugfs_card_root);
 	if (!platform->debugfs_platform_root) {
 		dev_warn(platform->dev,
-			"Failed to create platform debugfs directory\n");
+			"ASoC: Failed to create platform debugfs directory\n");
 		return;
 	}
 
@@ -430,7 +432,7 @@ static void soc_init_card_debugfs(struct snd_soc_card *card)
 						    &card->pop_time);
 	if (!card->debugfs_pop_time)
 		dev_warn(card->dev,
-		       "Failed to create pop time debugfs file\n");
+		       "ASoC: Failed to create pop time debugfs file\n");
 }
 
 static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
@@ -475,7 +477,7 @@ struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
 			!strcmp(card->rtd[i].dai_link->name, dai_link))
 			return card->rtd[i].pcm->streams[stream].substream;
 	}
-	dev_dbg(card->dev, "failed to find dai link %s\n", dai_link);
+	dev_dbg(card->dev, "ASoC: failed to find dai link %s\n", dai_link);
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_dai_substream);
@@ -489,7 +491,7 @@ struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
 		if (!strcmp(card->rtd[i].dai_link->name, dai_link))
 			return &card->rtd[i];
 	}
-	dev_dbg(card->dev, "failed to find rtd %s\n", dai_link);
+	dev_dbg(card->dev, "ASoC: failed to find rtd %s\n", dai_link);
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
@@ -519,7 +521,7 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 		     codec->card->snd_card->number, 0, codec->name);
 	err = device_register(&codec->ac97->dev);
 	if (err < 0) {
-		snd_printk(KERN_ERR "Can't register ac97 bus\n");
+		dev_err(codec->dev, "ASoC: Can't register ac97 bus\n");
 		codec->ac97->dev.bus = NULL;
 		return err;
 	}
@@ -628,7 +630,8 @@ int snd_soc_suspend(struct device *dev)
 				 */
 				if (codec->dapm.idle_bias_off) {
 					dev_dbg(codec->dev,
-						"idle_bias_off CODEC on over suspend\n");
+						"ASoC: idle_bias_off CODEC on"
+						" over suspend\n");
 					break;
 				}
 			case SND_SOC_BIAS_OFF:
@@ -639,7 +642,8 @@ int snd_soc_suspend(struct device *dev)
 					regcache_mark_dirty(codec->control_data);
 				break;
 			default:
-				dev_dbg(codec->dev, "CODEC is on over suspend\n");
+				dev_dbg(codec->dev, "ASoC: CODEC is on"
+					" over suspend\n");
 				break;
 			}
 		}
@@ -676,7 +680,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	 * so userspace apps are blocked from touching us
 	 */
 
-	dev_dbg(card->dev, "starting resume work\n");
+	dev_dbg(card->dev, "ASoC: starting resume work\n");
 
 	/* Bring us up into D2 so that DAPM starts enabling things */
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D2);
@@ -708,7 +712,8 @@ static void soc_resume_deferred(struct work_struct *work)
 				codec->suspended = 0;
 				break;
 			default:
-				dev_dbg(codec->dev, "CODEC was on over suspend\n");
+				dev_dbg(codec->dev, "ASoC: CODEC was on over"
+					" suspend\n");
 				break;
 			}
 		}
@@ -758,7 +763,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	if (card->resume_post)
 		card->resume_post(card);
 
-	dev_dbg(card->dev, "resume work completed\n");
+	dev_dbg(card->dev, "ASoC: resume work completed\n");
 
 	/* userspace can access us now we are back as we were before */
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
@@ -790,12 +795,12 @@ int snd_soc_resume(struct device *dev)
 		ac97_control |= cpu_dai->driver->ac97_control;
 	}
 	if (ac97_control) {
-		dev_dbg(dev, "Resuming AC97 immediately\n");
+		dev_dbg(dev, "ASoC: Resuming AC97 immediately\n");
 		soc_resume_deferred(&card->deferred_resume_work);
 	} else {
-		dev_dbg(dev, "Scheduling resume work\n");
+		dev_dbg(dev, "ASoC: Scheduling resume work\n");
 		if (!schedule_work(&card->deferred_resume_work))
-			dev_err(dev, "resume work item may be lost\n");
+			dev_err(dev, "ASoC: resume work item may be lost\n");
 	}
 
 	return 0;
@@ -818,7 +823,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	struct snd_soc_dai *codec_dai, *cpu_dai;
 	const char *platform_name;
 
-	dev_dbg(card->dev, "binding %s at idx %d\n", dai_link->name, num);
+	dev_dbg(card->dev, "ASoC: binding %s at idx %d\n", dai_link->name, num);
 
 	/* Find CPU DAI from registered DAIs*/
 	list_for_each_entry(cpu_dai, &dai_list, list) {
@@ -836,7 +841,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	}
 
 	if (!rtd->cpu_dai) {
-		dev_err(card->dev, "CPU DAI %s not registered\n",
+		dev_err(card->dev, "ASoC: CPU DAI %s not registered\n",
 			dai_link->cpu_dai_name);
 		return -EPROBE_DEFER;
 	}
@@ -867,14 +872,14 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		}
 
 		if (!rtd->codec_dai) {
-			dev_err(card->dev, "CODEC DAI %s not registered\n",
+			dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
 				dai_link->codec_dai_name);
 			return -EPROBE_DEFER;
 		}
 	}
 
 	if (!rtd->codec) {
-		dev_err(card->dev, "CODEC %s not registered\n",
+		dev_err(card->dev, "ASoC: CODEC %s not registered\n",
 			dai_link->codec_name);
 		return -EPROBE_DEFER;
 	}
@@ -898,7 +903,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		rtd->platform = platform;
 	}
 	if (!rtd->platform) {
-		dev_err(card->dev, "platform %s not registered\n",
+		dev_err(card->dev, "ASoC: platform %s not registered\n",
 			dai_link->platform_name);
 		return -EPROBE_DEFER;
 	}
@@ -915,8 +920,8 @@ static int soc_remove_platform(struct snd_soc_platform *platform)
 	if (platform->driver->remove) {
 		ret = platform->driver->remove(platform);
 		if (ret < 0)
-			pr_err("asoc: failed to remove %s: %d\n",
-				platform->name, ret);
+			dev_err(platform->dev, "ASoC: failed to remove %d\n",
+				ret);
 	}
 
 	/* Make sure all DAPM widgets are freed */
@@ -937,9 +942,7 @@ static void soc_remove_codec(struct snd_soc_codec *codec)
 	if (codec->driver->remove) {
 		err = codec->driver->remove(codec);
 		if (err < 0)
-			dev_err(codec->dev,
-				"asoc: failed to remove %s: %d\n",
-				codec->name, err);
+			dev_err(codec->dev, "ASoC: failed to remove %d\n", err);
 	}
 
 	/* Make sure all DAPM widgets are freed */
@@ -971,8 +974,9 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 		if (codec_dai->driver->remove) {
 			err = codec_dai->driver->remove(codec_dai);
 			if (err < 0)
-				pr_err("asoc: failed to remove %s: %d\n",
-							codec_dai->name, err);
+				dev_err(codec_dai->dev,
+					"ASoC: failed to remove %s: %d\n",
+					codec_dai->name, err);
 		}
 		codec_dai->probed = 0;
 		list_del(&codec_dai->card_list);
@@ -984,8 +988,9 @@ static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 		if (cpu_dai->driver->remove) {
 			err = cpu_dai->driver->remove(cpu_dai);
 			if (err < 0)
-				pr_err("asoc: failed to remove %s: %d\n",
-							cpu_dai->name, err);
+				dev_err(cpu_dai->dev,
+					"ASoC: failed to remove %s: %d\n",
+					cpu_dai->name, err);
 		}
 		cpu_dai->probed = 0;
 		list_del(&cpu_dai->card_list);
@@ -1099,8 +1104,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 		ret = driver->probe(codec);
 		if (ret < 0) {
 			dev_err(codec->dev,
-				"asoc: failed to probe CODEC %s: %d\n",
-				codec->name, ret);
+				"ASoC: failed to probe CODEC %d\n", ret);
 			goto err_probe;
 		}
 	}
@@ -1163,8 +1167,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 		ret = driver->probe(platform);
 		if (ret < 0) {
 			dev_err(platform->dev,
-				"asoc: failed to probe platform %s: %d\n",
-				platform->name, ret);
+				"ASoC: failed to probe platform %d\n", ret);
 			goto err_probe;
 		}
 	}
@@ -1229,7 +1232,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	else if (dailess && aux_dev->init)
 		ret = aux_dev->init(&codec->dapm);
 	if (ret < 0) {
-		dev_err(card->dev, "asoc: failed to init %s: %d\n", name, ret);
+		dev_err(card->dev, "ASoC: failed to init %s: %d\n", name, ret);
 		return ret;
 	}
 	codec->name_prefix = temp;
@@ -1253,7 +1256,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	ret = device_add(rtd->dev);
 	if (ret < 0) {
 		dev_err(card->dev,
-			"asoc: failed to register runtime device: %d\n", ret);
+			"ASoC: failed to register runtime device: %d\n", ret);
 		return ret;
 	}
 	rtd->dev_registered = 1;
@@ -1262,14 +1265,13 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	ret = snd_soc_dapm_sys_add(rtd->dev);
 	if (ret < 0)
 		dev_err(codec->dev,
-			"asoc: failed to add codec dapm sysfs entries: %d\n",
-			ret);
+			"ASoC: failed to add codec dapm sysfs entries: %d\n", ret);
 
 	/* add codec sysfs entries */
 	ret = device_create_file(rtd->dev, &dev_attr_codec_reg);
 	if (ret < 0)
 		dev_err(codec->dev,
-			"asoc: failed to add codec sysfs files: %d\n", ret);
+			"ASoC: failed to add codec sysfs files: %d\n", ret);
 
 #ifdef CONFIG_DEBUG_FS
 	/* add DPCM sysfs entries */
@@ -1278,7 +1280,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 
 	ret = soc_dpcm_debugfs_add(rtd);
 	if (ret < 0)
-		dev_err(rtd->dev, "asoc: failed to add dpcm sysfs entries: %d\n", ret);
+		dev_err(rtd->dev, "ASoC: failed to add dpcm sysfs entries: %d\n", ret);
 
 out:
 #endif
@@ -1333,7 +1335,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	struct snd_soc_dapm_widget *play_w, *capture_w;
 	int ret;
 
-	dev_dbg(card->dev, "probe %s dai link %d late %d\n",
+	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
 			card->name, num, order);
 
 	/* config components */
@@ -1359,8 +1361,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 		if (cpu_dai->driver->probe) {
 			ret = cpu_dai->driver->probe(cpu_dai);
 			if (ret < 0) {
-				pr_err("asoc: failed to probe CPU DAI %s: %d\n",
-							cpu_dai->name, ret);
+				dev_err(cpu_dai->dev,
+					"ASoC: failed to probe CPU DAI %s: %d\n",
+					cpu_dai->name, ret);
 				module_put(cpu_dai->dev->driver->owner);
 				return ret;
 			}
@@ -1375,8 +1378,9 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 		if (codec_dai->driver->probe) {
 			ret = codec_dai->driver->probe(codec_dai);
 			if (ret < 0) {
-				pr_err("asoc: failed to probe CODEC DAI %s: %d\n",
-							codec_dai->name, ret);
+				dev_err(codec_dai->dev,
+					"ASoC: failed to probe CODEC DAI %s: %d\n",
+					codec_dai->name, ret);
 				return ret;
 			}
 		}
@@ -1396,13 +1400,14 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 
 	ret = device_create_file(rtd->dev, &dev_attr_pmdown_time);
 	if (ret < 0)
-		pr_warn("asoc: failed to add pmdown_time sysfs:%d\n", ret);
+		dev_warn(rtd->dev, "ASoC: failed to add pmdown_time sysfs: %d\n",
+			ret);
 
 	if (cpu_dai->driver->compress_dai) {
 		/*create compress_device"*/
 		ret = soc_new_compress(rtd, num);
 		if (ret < 0) {
-			pr_err("asoc: can't create compress %s\n",
+			dev_err(card->dev, "ASoC: can't create compress %s\n",
 					 dai_link->stream_name);
 			return ret;
 		}
@@ -1412,7 +1417,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 			/* create the pcm */
 			ret = soc_new_pcm(rtd, num);
 			if (ret < 0) {
-				pr_err("asoc: can't create pcm %s :%d\n",
+				dev_err(card->dev, "ASoC: can't create pcm %s :%d\n",
 				       dai_link->stream_name, ret);
 				return ret;
 			}
@@ -1424,7 +1429,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 				ret = snd_soc_dapm_new_pcm(card, dai_link->params,
 						   capture_w, play_w);
 				if (ret != 0) {
-					dev_err(card->dev, "Can't link %s to %s: %d\n",
+					dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
 						play_w->name, capture_w->name, ret);
 					return ret;
 				}
@@ -1436,7 +1441,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 				ret = snd_soc_dapm_new_pcm(card, dai_link->params,
 						   capture_w, play_w);
 				if (ret != 0) {
-					dev_err(card->dev, "Can't link %s to %s: %d\n",
+					dev_err(card->dev, "ASoC: Can't link %s to %s: %d\n",
 						play_w->name, capture_w->name, ret);
 					return ret;
 				}
@@ -1473,7 +1478,8 @@ static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
 
 		ret = soc_ac97_dev_register(rtd->codec);
 		if (ret < 0) {
-			pr_err("asoc: AC97 device register failed:%d\n", ret);
+			dev_err(rtd->codec->dev,
+				"ASoC: AC97 device register failed: %d\n", ret);
 			return ret;
 		}
 
@@ -1502,7 +1508,7 @@ static int soc_check_aux_dev(struct snd_soc_card *card, int num)
 			return 0;
 	}
 
-	dev_err(card->dev, "%s not registered\n", aux_dev->codec_name);
+	dev_err(card->dev, "ASoC: %s not registered\n", aux_dev->codec_name);
 
 	return -EPROBE_DEFER;
 }
@@ -1518,7 +1524,7 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 		if (!strcmp(codec->name, aux_dev->codec_name)) {
 			if (codec->probed) {
 				dev_err(codec->dev,
-					"asoc: codec already probed");
+					"ASoC: codec already probed");
 				ret = -EBUSY;
 				goto out;
 			}
@@ -1526,7 +1532,7 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 		}
 	}
 	/* codec not found */
-	dev_err(card->dev, "asoc: codec %s not found", aux_dev->codec_name);
+	dev_err(card->dev, "ASoC: codec %s not found", aux_dev->codec_name);
 	return -EPROBE_DEFER;
 
 found:
@@ -1569,8 +1575,8 @@ static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,
 		codec->compress_type = compress_type;
 	ret = snd_soc_cache_init(codec);
 	if (ret < 0) {
-		dev_err(codec->dev, "Failed to set cache compression type: %d\n",
-			ret);
+		dev_err(codec->dev, "ASoC: Failed to set cache compression"
+			" type: %d\n", ret);
 		return ret;
 	}
 	codec->cache_init = 1;
@@ -1626,8 +1632,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
 			card->owner, 0, &card->snd_card);
 	if (ret < 0) {
-		pr_err("asoc: can't create sound card for card %s: %d\n",
-			card->name, ret);
+		dev_err(card->dev, "ASoC: can't create sound card for"
+			" card %s: %d\n", card->name, ret);
 		goto base_error;
 	}
 	card->snd_card->dev = card->dev;
@@ -1663,8 +1669,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		for (i = 0; i < card->num_links; i++) {
 			ret = soc_probe_link_components(card, i, order);
 			if (ret < 0) {
-				pr_err("asoc: failed to instantiate card %s: %d\n",
-				       card->name, ret);
+				dev_err(card->dev,
+					"ASoC: failed to instantiate card %d\n",
+					ret);
 				goto probe_dai_err;
 			}
 		}
@@ -1676,8 +1683,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		for (i = 0; i < card->num_links; i++) {
 			ret = soc_probe_link_dais(card, i, order);
 			if (ret < 0) {
-				pr_err("asoc: failed to instantiate card %s: %d\n",
-				       card->name, ret);
+				dev_err(card->dev,
+					"ASoC: failed to instantiate card %d\n",
+					ret);
 				goto probe_dai_err;
 			}
 		}
@@ -1686,8 +1694,9 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_aux_devs; i++) {
 		ret = soc_probe_aux_dev(card, i);
 		if (ret < 0) {
-			pr_err("asoc: failed to add auxiliary devices %s: %d\n",
-			       card->name, ret);
+			dev_err(card->dev,
+				"ASoC: failed to add auxiliary devices %d\n",
+				ret);
 			goto probe_aux_dev_err;
 		}
 	}
@@ -1712,7 +1721,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 						  dai_fmt);
 			if (ret != 0 && ret != -ENOTSUPP)
 				dev_warn(card->rtd[i].codec_dai->dev,
-					 "Failed to set DAI format: %d\n",
+					 "ASoC: Failed to set DAI format: %d\n",
 					 ret);
 		}
 
@@ -1723,7 +1732,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 						  dai_fmt);
 			if (ret != 0 && ret != -ENOTSUPP)
 				dev_warn(card->rtd[i].cpu_dai->dev,
-					 "Failed to set DAI format: %d\n",
+					 "ASoC: Failed to set DAI format: %d\n",
 					 ret);
 		} else if (dai_fmt) {
 			/* Flip the polarity for the "CPU" end */
@@ -1748,7 +1757,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 						  dai_fmt);
 			if (ret != 0 && ret != -ENOTSUPP)
 				dev_warn(card->rtd[i].cpu_dai->dev,
-					 "Failed to set DAI format: %d\n",
+					 "ASoC: Failed to set DAI format: %d\n",
 					 ret);
 		}
 	}
@@ -1775,7 +1784,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	if (card->late_probe) {
 		ret = card->late_probe(card);
 		if (ret < 0) {
-			dev_err(card->dev, "%s late_probe() failed: %d\n",
+			dev_err(card->dev, "ASoC: %s late_probe() failed: %d\n",
 				card->name, ret);
 			goto probe_aux_dev_err;
 		}
@@ -1789,8 +1798,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	ret = snd_card_register(card->snd_card);
 	if (ret < 0) {
-		pr_err("asoc: failed to register soundcard for %s: %d\n",
-							card->name, ret);
+		dev_err(card->dev, "ASoC: failed to register soundcard %d\n",
+				ret);
 		goto probe_aux_dev_err;
 	}
 
@@ -1799,8 +1808,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_rtd; i++) {
 		ret = soc_register_ac97_dai_link(&card->rtd[i]);
 		if (ret < 0) {
-			pr_err("asoc: failed to register AC97 %s: %d\n",
-							card->name, ret);
+			dev_err(card->dev, "ASoC: failed to register AC97:"
+				" %d\n", ret);
 			while (--i >= 0)
 				soc_unregister_ac97_dai_link(card->rtd[i].codec);
 			goto probe_aux_dev_err;
@@ -1846,7 +1855,7 @@ static int soc_probe(struct platform_device *pdev)
 		return -EINVAL;
 
 	dev_warn(&pdev->dev,
-		 "ASoC machine %s should use snd_soc_register_card()\n",
+		 "ASoC: machine %s should use snd_soc_register_card()\n",
 		 card->name);
 
 	/* Bodge while we unpick instantiation */
@@ -1996,7 +2005,7 @@ int snd_soc_platform_read(struct snd_soc_platform *platform,
 	unsigned int ret;
 
 	if (!platform->driver->read) {
-		dev_err(platform->dev, "platform has no read back\n");
+		dev_err(platform->dev, "ASoC: platform has no read back\n");
 		return -1;
 	}
 
@@ -2012,7 +2021,7 @@ int snd_soc_platform_write(struct snd_soc_platform *platform,
 					 unsigned int reg, unsigned int val)
 {
 	if (!platform->driver->write) {
-		dev_err(platform->dev, "platform has no write back\n");
+		dev_err(platform->dev, "ASoC: platform has no write back\n");
 		return -1;
 	}
 
@@ -2283,7 +2292,8 @@ static int snd_soc_add_controls(struct snd_card *card, struct device *dev,
 		err = snd_ctl_add(card, snd_soc_cnew(control, data,
 						     control->name, prefix));
 		if (err < 0) {
-			dev_err(dev, "Failed to add %s: %d\n", control->name, err);
+			dev_err(dev, "ASoC: Failed to add %s: %d\n",
+				control->name, err);
 			return err;
 		}
 	}
@@ -3534,15 +3544,14 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 * not both or neither.
 		 */
 		if (!!link->codec_name == !!link->codec_of_node) {
-			dev_err(card->dev,
-				"Neither/both codec name/of_node are set for %s\n",
-				link->name);
+			dev_err(card->dev, "ASoC: Neither/both codec"
+				" name/of_node are set for %s\n", link->name);
 			return -EINVAL;
 		}
 		/* Codec DAI name must be specified */
 		if (!link->codec_dai_name) {
-			dev_err(card->dev, "codec_dai_name not set for %s\n",
-				link->name);
+			dev_err(card->dev, "ASoC: codec_dai_name not"
+				" set for %s\n", link->name);
 			return -EINVAL;
 		}
 
@@ -3551,8 +3560,8 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 * can be left unspecified, and a dummy platform will be used.
 		 */
 		if (link->platform_name && link->platform_of_node) {
-			dev_err(card->dev,
-				"Both platform name/of_node are set for %s\n", link->name);
+			dev_err(card->dev, "ASoC: Both platform name/of_node"
+				" are set for %s\n", link->name);
 			return -EINVAL;
 		}
 
@@ -3562,9 +3571,8 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 * name alone..
 		 */
 		if (link->cpu_name && link->cpu_of_node) {
-			dev_err(card->dev,
-				"Neither/both cpu name/of_node are set for %s\n",
-				link->name);
+			dev_err(card->dev, "ASoC: Neither/both "
+				"cpu name/of_node are set for %s\n",link->name);
 			return -EINVAL;
 		}
 		/*
@@ -3573,9 +3581,8 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 */
 		if (!link->cpu_dai_name &&
 		    !(link->cpu_name || link->cpu_of_node)) {
-			dev_err(card->dev,
-				"Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
-				link->name);
+			dev_err(card->dev, "ASoC: Neither cpu_dai_name nor "
+				"cpu_name/of_node are set for %s\n", link->name);
 			return -EINVAL;
 		}
 	}
@@ -3622,7 +3629,7 @@ int snd_soc_unregister_card(struct snd_soc_card *card)
 {
 	if (card->instantiated)
 		soc_cleanup_card_resources(card);
-	dev_dbg(card->dev, "Unregistered card '%s'\n", card->name);
+	dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 
 	return 0;
 }
@@ -3679,8 +3686,8 @@ static inline char *fmt_multiple_name(struct device *dev,
 		struct snd_soc_dai_driver *dai_drv)
 {
 	if (dai_drv->name == NULL) {
-		pr_err("asoc: error - multiple DAI %s registered with no name\n",
-				dev_name(dev));
+		dev_err(dev, "ASoC: error - multiple DAI %s registered with"
+				" no name\n", dev_name(dev));
 		return NULL;
 	}
 
@@ -3698,7 +3705,7 @@ int snd_soc_register_dai(struct device *dev,
 	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
 
-	dev_dbg(dev, "dai register %s\n", dev_name(dev));
+	dev_dbg(dev, "ASoC: dai register %s\n", dev_name(dev));
 
 	dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
 	if (dai == NULL)
@@ -3721,7 +3728,7 @@ int snd_soc_register_dai(struct device *dev,
 
 	list_for_each_entry(codec, &codec_list, list) {
 		if (codec->dev == dev) {
-			dev_dbg(dev, "Mapped DAI %s to CODEC %s\n",
+			dev_dbg(dev, "ASoC: Mapped DAI %s to CODEC %s\n",
 				dai->name, codec->name);
 			dai->codec = codec;
 			break;
@@ -3735,7 +3742,7 @@ int snd_soc_register_dai(struct device *dev,
 
 	mutex_unlock(&client_mutex);
 
-	pr_debug("Registered DAI '%s'\n", dai->name);
+	dev_dbg(dev, "ASoC: Registered DAI '%s'\n", dai->name);
 
 	return 0;
 }
@@ -3761,7 +3768,7 @@ void snd_soc_unregister_dai(struct device *dev)
 	list_del(&dai->list);
 	mutex_unlock(&client_mutex);
 
-	pr_debug("Unregistered DAI '%s'\n", dai->name);
+	dev_dbg(dev, "ASoC: Unregistered DAI '%s'\n", dai->name);
 	kfree(dai->name);
 	kfree(dai);
 }
@@ -3780,7 +3787,7 @@ int snd_soc_register_dais(struct device *dev,
 	struct snd_soc_dai *dai;
 	int i, ret = 0;
 
-	dev_dbg(dev, "dai register %s #%Zu\n", dev_name(dev), count);
+	dev_dbg(dev, "ASoC: dai register %s #%Zu\n", dev_name(dev), count);
 
 	for (i = 0; i < count; i++) {
 
@@ -3812,8 +3819,8 @@ int snd_soc_register_dais(struct device *dev,
 
 		list_for_each_entry(codec, &codec_list, list) {
 			if (codec->dev == dev) {
-				dev_dbg(dev, "Mapped DAI %s to CODEC %s\n",
-					dai->name, codec->name);
+				dev_dbg(dev, "ASoC: Mapped DAI %s to "
+					"CODEC %s\n", dai->name, codec->name);
 				dai->codec = codec;
 				break;
 			}
@@ -3826,7 +3833,7 @@ int snd_soc_register_dais(struct device *dev,
 
 		mutex_unlock(&client_mutex);
 
-		pr_debug("Registered DAI '%s'\n", dai->name);
+		dev_dbg(dai->dev, "ASoC: Registered DAI '%s'\n", dai->name);
 	}
 
 	return 0;
@@ -3864,7 +3871,7 @@ int snd_soc_register_platform(struct device *dev,
 {
 	struct snd_soc_platform *platform;
 
-	dev_dbg(dev, "platform register %s\n", dev_name(dev));
+	dev_dbg(dev, "ASoC: platform register %s\n", dev_name(dev));
 
 	platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);
 	if (platform == NULL)
@@ -3888,7 +3895,7 @@ int snd_soc_register_platform(struct device *dev,
 	list_add(&platform->list, &platform_list);
 	mutex_unlock(&client_mutex);
 
-	pr_debug("Registered platform '%s'\n", platform->name);
+	dev_dbg(dev, "ASoC: Registered platform '%s'\n", platform->name);
 
 	return 0;
 }
@@ -3914,7 +3921,7 @@ void snd_soc_unregister_platform(struct device *dev)
 	list_del(&platform->list);
 	mutex_unlock(&client_mutex);
 
-	pr_debug("Unregistered platform '%s'\n", platform->name);
+	dev_dbg(dev, "ASoC: Unregistered platform '%s'\n", platform->name);
 	kfree(platform->name);
 	kfree(platform);
 }
@@ -4043,11 +4050,11 @@ int snd_soc_register_codec(struct device *dev,
 	if (num_dai) {
 		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
 		if (ret < 0)
-			dev_err(codec->dev, "Failed to regster DAIs: %d\n",
-				ret);
+			dev_err(codec->dev, "ASoC: Failed to regster"
+				" DAIs: %d\n", ret);
 	}
 
-	pr_debug("Registered codec '%s'\n", codec->name);
+	dev_dbg(codec->dev, "ASoC: Registered codec '%s'\n", codec->name);
 	return 0;
 
 fail:
@@ -4082,7 +4089,7 @@ void snd_soc_unregister_codec(struct device *dev)
 	list_del(&codec->list);
 	mutex_unlock(&client_mutex);
 
-	pr_debug("Unregistered codec '%s'\n", codec->name);
+	dev_dbg(codec->dev, "ASoC: Unregistered codec '%s'\n", codec->name);
 
 	snd_soc_cache_exit(codec);
 	kfree(codec->reg_def_copy);
@@ -4106,7 +4113,7 @@ int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 	 */
 	if (ret < 0 && ret != -EINVAL) {
 		dev_err(card->dev,
-			"Property '%s' could not be read: %d\n",
+			"ASoC: Property '%s' could not be read: %d\n",
 			propname, ret);
 		return ret;
 	}
@@ -4125,15 +4132,13 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 
 	num_routes = of_property_count_strings(np, propname);
 	if (num_routes < 0 || num_routes & 1) {
-		dev_err(card->dev,
-		     "Property '%s' does not exist or its length is not even\n",
-		     propname);
+		dev_err(card->dev, "ASoC: Property '%s' does not exist or its"
+			" length is not even\n", propname);
 		return -EINVAL;
 	}
 	num_routes /= 2;
 	if (!num_routes) {
-		dev_err(card->dev,
-			"Property '%s's length is zero\n",
+		dev_err(card->dev, "ASoC: Property '%s's length is zero\n",
 			propname);
 		return -EINVAL;
 	}
@@ -4142,7 +4147,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 			      GFP_KERNEL);
 	if (!routes) {
 		dev_err(card->dev,
-			"Could not allocate DAPM route table\n");
+			"ASoC: Could not allocate DAPM route table\n");
 		return -EINVAL;
 	}
 
@@ -4150,9 +4155,9 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		ret = of_property_read_string_index(np, propname,
 			2 * i, &routes[i].sink);
 		if (ret) {
-			dev_err(card->dev,
-				"Property '%s' index %d could not be read: %d\n",
-				propname, 2 * i, ret);
+			dev_err(card->dev, "ASoC: Property '%s' index %d"
+				" could not be read: %d\n", propname, 2 * i,
+				ret);
 			kfree(routes);
 			return -EINVAL;
 		}
@@ -4160,8 +4165,8 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 			(2 * i) + 1, &routes[i].source);
 		if (ret) {
 			dev_err(card->dev,
-				"Property '%s' index %d could not be read: %d\n",
-				propname, (2 * i) + 1, ret);
+				"ASoC: Property '%s' index %d could not be"
+				" read: %d\n", propname, (2 * i) + 1, ret);
 			kfree(routes);
 			return -EINVAL;
 		}

commit f6e6574499eeeeee747d9cfc7ba9f4328bb1806d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:25:33 2012 -0500

    ASoC: remove use of __devinitconst
    
    CONFIG_HOTPLUG is going away as an option so __devinitconst is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 10d21be383f6..2153e19d8208 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4007,7 +4007,7 @@ int snd_soc_register_codec(struct device *dev,
 		codec->reg_size = reg_size;
 		/* it is necessary to make a copy of the default register cache
 		 * because in the case of using a compression type that requires
-		 * the default register cache to be marked as __devinitconst the
+		 * the default register cache to be marked as the
 		 * kernel might have freed the array by the time we initialize
 		 * the cache.
 		 */

commit d055852ee86703d48b0c571e94bd2eb33aa9b91d
Author: Mukund Navada <navada@ti.com>
Date:   Fri Nov 9 11:53:40 2012 +0530

    ASoC: core: Double control update err for snd_soc_put_volsw_sx
    
    snd_soc_put_volsw_sx function fails to update second control
    if first control is updated by snd_soc_update_bits_locked.
    
    Signed-off-by: Mukund Navada <navada@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d1198627fc40..10d21be383f6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2786,8 +2786,9 @@ int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
 	val = (ucontrol->value.integer.value[0] + min) & mask;
 	val = val << shift;
 
-	if (snd_soc_update_bits_locked(codec, reg, val_mask, val))
-			return err;
+	err = snd_soc_update_bits_locked(codec, reg, val_mask, val);
+	if (err < 0)
+		return err;
 
 	if (snd_soc_volsw_is_stereo(mc)) {
 		val_mask = mask << rshift;

commit f5a246eab9a268f51ba8189ea5b098a1bfff200e
Merge: d5bbd43d5f45 7ff34ad80b70
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 9 07:07:14 2012 +0900

    Merge tag 'sound-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This contains pretty many small commits covering fairly large range of
      files in sound/ directory.  Partly because of additional API support
      and partly because of constantly developed ASoC and ARM stuff.
    
      Some highlights:
    
       - Introduced the helper function and documentation for exposing the
         channel map via control API, as discussed in Plumbers; most of PCI
         drivers are covered, will follow more drivers later
    
       - Most of drivers have been replaced with the new PM callbacks (if
         the bus is supported)
    
       - HD-audio controller got the support of runtime PM and the support
         of D3 clock-stop.  Also changing the power_save option in sysfs
         kicks off immediately to enable / disable the power-save mode.
    
       - Another significant code change in HD-audio is the rewrite of
         firmware loading code.  Other than that, most of changes in
         HD-audio are continued cleanups and standardization for the generic
         auto parser and bug fixes (HBR, device-specific fixups), in
         addition to the support of channel-map API.
    
       - Addition of ASoC bindings for the compressed API, used by the
         mid-x86 drivers.
    
       - Lots of cleanups and API refreshes for ASoC codec drivers and
         DaVinci.
    
       - Conversion of OMAP to dmaengine.
    
       - New machine driver for Wolfson Microelectronics Bells.
    
       - New CODEC driver for Wolfson Microelectronics WM0010.
    
       - Enhancements to the ux500 and wm2000 drivers
    
       - A new driver for DA9055 and the support for regulator bypass mode."
    
    Fix up various arm soc header file reorg conflicts.
    
    * tag 'sound-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (339 commits)
      ALSA: hda - Add new codec ALC283 ALC290 support
      ALSA: hda - avoid unneccesary indices on "Headphone Jack" controls
      ALSA: hda - fix indices on boost volume on Conexant
      ALSA: aloop - add locking to timer access
      ALSA: hda - Fix hang caused by race during suspend.
      sound: Remove unnecessary semicolon
      ALSA: hda/realtek - Fix detection of ALC271X codec
      ALSA: hda - Add inverted internal mic quirk for Lenovo IdeaPad U310
      ALSA: hda - make Realtek/Sigmatel/Conexant use the generic unsol event
      ALSA: hda - make a generic unsol event handler
      ASoC: codecs: Add DA9055 codec driver
      ASoC: eukrea-tlv320: Convert it to platform driver
      ALSA: ASoC: add DT bindings for CS4271
      ASoC: wm_hubs: Ensure volume updates are handled during class W startup
      ASoC: wm5110: Adding missing volume update bits
      ASoC: wm5110: Add OUT3R support
      ASoC: wm5110: Add AEC loopback support
      ASoC: wm5110: Rename EPOUT to HPOUT3
      ASoC: arizona: Add more clock rates
      ASoC: arizona: Add more DSP options for mixer input muxes
      ...

commit 033d9959ed2dc1029217d4165f80a71702dc578e
Merge: 974a847e00cf 7c6e72e46c9e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 09:54:49 2012 -0700

    Merge branch 'for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq
    
    Pull workqueue changes from Tejun Heo:
     "This is workqueue updates for v3.7-rc1.  A lot of activities this
      round including considerable API and behavior cleanups.
    
       * delayed_work combines a timer and a work item.  The handling of the
         timer part has always been a bit clunky leading to confusing
         cancelation API with weird corner-case behaviors.  delayed_work is
         updated to use new IRQ safe timer and cancelation now works as
         expected.
    
       * Another deficiency of delayed_work was lack of the counterpart of
         mod_timer() which led to cancel+queue combinations or open-coded
         timer+work usages.  mod_delayed_work[_on]() are added.
    
         These two delayed_work changes make delayed_work provide interface
         and behave like timer which is executed with process context.
    
       * A work item could be executed concurrently on multiple CPUs, which
         is rather unintuitive and made flush_work() behavior confusing and
         half-broken under certain circumstances.  This problem doesn't
         exist for non-reentrant workqueues.  While non-reentrancy check
         isn't free, the overhead is incurred only when a work item bounces
         across different CPUs and even in simulated pathological scenario
         the overhead isn't too high.
    
         All workqueues are made non-reentrant.  This removes the
         distinction between flush_[delayed_]work() and
         flush_[delayed_]_work_sync().  The former is now as strong as the
         latter and the specified work item is guaranteed to have finished
         execution of any previous queueing on return.
    
       * In addition to the various bug fixes, Lai redid and simplified CPU
         hotplug handling significantly.
    
       * Joonsoo introduced system_highpri_wq and used it during CPU
         hotplug.
    
      There are two merge commits - one to pull in IRQ safe timer from
      tip/timers/core and the other to pull in CPU hotplug fixes from
      wq/for-3.6-fixes as Lai's hotplug restructuring depended on them."
    
    Fixed a number of trivial conflicts, but the more interesting conflicts
    were silent ones where the deprecated interfaces had been used by new
    code in the merge window, and thus didn't cause any real data conflicts.
    
    Tejun pointed out a few of them, I fixed a couple more.
    
    * 'for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq: (46 commits)
      workqueue: remove spurious WARN_ON_ONCE(in_irq()) from try_to_grab_pending()
      workqueue: use cwq_set_max_active() helper for workqueue_set_max_active()
      workqueue: introduce cwq_set_max_active() helper for thaw_workqueues()
      workqueue: remove @delayed from cwq_dec_nr_in_flight()
      workqueue: fix possible stall on try_to_grab_pending() of a delayed work item
      workqueue: use hotcpu_notifier() for workqueue_cpu_down_callback()
      workqueue: use __cpuinit instead of __devinit for cpu callbacks
      workqueue: rename manager_mutex to assoc_mutex
      workqueue: WORKER_REBIND is no longer necessary for idle rebinding
      workqueue: WORKER_REBIND is no longer necessary for busy rebinding
      workqueue: reimplement idle worker rebinding
      workqueue: deprecate __cancel_delayed_work()
      workqueue: reimplement cancel_delayed_work() using try_to_grab_pending()
      workqueue: use mod_delayed_work() instead of __cancel + queue
      workqueue: use irqsafe timer for delayed_work
      workqueue: clean up delayed_work initializers and add missing one
      workqueue: make deferrable delayed_work initializer names consistent
      workqueue: cosmetic whitespace updates for macro definitions
      workqueue: deprecate system_nrt[_freezable]_wq
      workqueue: deprecate flush[_delayed]_work_sync()
      ...

commit 86767b7d5b3cdbd105e7d7066d671b52aa208188
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Sep 14 13:57:27 2012 +0200

    ASoC: Avoid recalculating the bitmask for SOC_ENUM controls
    
    For ENUM controls the bitmask is calculated based on the number of items.
    Currently this is done each time the control is accessed. And while the
    performance impact of this should be negligible we can easily do better. The
    roundup_pow_of_two macro performs the same calculation which is currently done
    manually, but it is also possible to use this macro with compile time constants
    and so it can be used to initialize static data. So we can use it to initialize
    the mask field of a ENUM control during its declaration.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e5b0713e6f3c..9a6daf997319 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2413,16 +2413,14 @@ int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int val, bitmask;
+	unsigned int val;
 
-	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
-		;
 	val = snd_soc_read(codec, e->reg);
 	ucontrol->value.enumerated.item[0]
-		= (val >> e->shift_l) & (bitmask - 1);
+		= (val >> e->shift_l) & e->mask;
 	if (e->shift_l != e->shift_r)
 		ucontrol->value.enumerated.item[1] =
-			(val >> e->shift_r) & (bitmask - 1);
+			(val >> e->shift_r) & e->mask;
 
 	return 0;
 }
@@ -2443,19 +2441,17 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned int val;
-	unsigned int mask, bitmask;
+	unsigned int mask;
 
-	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
-		;
 	if (ucontrol->value.enumerated.item[0] > e->max - 1)
 		return -EINVAL;
 	val = ucontrol->value.enumerated.item[0] << e->shift_l;
-	mask = (bitmask - 1) << e->shift_l;
+	mask = e->mask << e->shift_l;
 	if (e->shift_l != e->shift_r) {
 		if (ucontrol->value.enumerated.item[1] > e->max - 1)
 			return -EINVAL;
 		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
-		mask |= (bitmask - 1) << e->shift_r;
+		mask |= e->mask << e->shift_r;
 	}
 
 	return snd_soc_update_bits_locked(codec, e->reg, mask, val);

commit ab7af5c8d456103ea57c7e9e6f5b03162965e665
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Wed Sep 12 17:06:46 2012 +0200

    ASoC: core: Remove useless kfree
    
    Remove useless kfree() and clean up code related to the removal.
    
    The semantic patch that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r exists@
    position p1,p2;
    expression x;
    @@
    
    if (x@p1 == NULL) { ... kfree@p2(x); ... return ...; }
    
    @unchanged exists@
    position r.p1,r.p2;
    expression e <= r.x,x,e1;
    iterator I;
    statement S;
    @@
    
    if (x@p1 == NULL) { ... when != I(x,...) S
                            when != e = e1
                            when != e += e1
                            when != e -= e1
                            when != ++e
                            when != --e
                            when != e++
                            when != e--
                            when != &e
       kfree@p2(x); ... return ...; }
    
    @ok depends on unchanged exists@
    position any r.p1;
    position r.p2;
    expression x;
    @@
    
    ... when != true x@p1 == NULL
    kfree@p2(x);
    
    @depends on !ok && unchanged@
    position r.p2;
    expression x;
    @@
    
    *kfree@p2(x);
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2b418398ec18..e5b0713e6f3c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4054,8 +4054,6 @@ int snd_soc_register_codec(struct device *dev,
 	return 0;
 
 fail:
-	kfree(codec->reg_def_copy);
-	codec->reg_def_copy = NULL;
 	kfree(codec->name);
 	kfree(codec);
 	return ret;

commit da8b8e0f15b375b44ed8ef4b0c5f5f60f19ccb37
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Sep 12 12:21:52 2012 +0800

    ASoC: core: Mark regmap CODEC register maps as dirty when suspending
    
    The core has for a long time had support for marking the register maps of
    devices dirty when suspending so that they are resynced on resume. Also
    implement this feature for CODECs using regmap.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ad65459da28e..2b418398ec18 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -635,6 +635,8 @@ int snd_soc_suspend(struct device *dev)
 				codec->driver->suspend(codec);
 				codec->suspended = 1;
 				codec->cache_sync = 1;
+				if (codec->using_regmap)
+					regcache_mark_dirty(codec->control_data);
 				break;
 			default:
 				dev_dbg(codec->dev, "CODEC is on over suspend\n");

commit e2d32ff6ce4ee9958f3973a086f3fa5d009e6306
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Aug 31 17:38:32 2012 -0700

    ASoC: dapm: Ensure bypass paths are suspended and resumed
    
    Since bypass paths aren't part of DAPM streams and we may not have any
    DAPM streams there may not be anything that triggers a DAPM sync for
    them. Mark all input and output widgets as dirty and then sync to do so
    at the end of suspend and resume.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b95d1fb388a1..ad65459da28e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -609,6 +609,10 @@ int snd_soc_suspend(struct device *dev)
 					  SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
+	/* Recheck all analogue paths too */
+	dapm_mark_io_dirty(&card->dapm);
+	snd_soc_dapm_sync(&card->dapm);
+
 	/* suspend all CODECs */
 	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
 		/* If there are paths active then the CODEC will be held with
@@ -756,6 +760,10 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	/* userspace can access us now we are back as we were before */
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
+
+	/* Recheck all analogue paths too */
+	dapm_mark_io_dirty(&card->dapm);
+	snd_soc_dapm_sync(&card->dapm);
 }
 
 /* powers up audio subsystem after a suspend */

commit 75d8f2931a803b803cb4a850448460475c20f30b
Merge: ffb690d5aa36 e93c7d1bc350
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Sep 5 20:05:11 2012 +0800

    Merge branch 'asoc-omap' into for-3.7

commit 43829731dd372d04d6706c51052b9dabab9ca356
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 20 14:51:24 2012 -0700

    workqueue: deprecate flush[_delayed]_work_sync()
    
    flush[_delayed]_work_sync() are now spurious.  Mark them deprecated
    and convert all users to flush[_delayed]_work().
    
    If you're cc'd and wondering what's going on: Now all workqueues are
    non-reentrant and the regular flushes guarantee that the work item is
    not pending or running on any CPU on return, so there's no reason to
    use the sync flushes at all and they're going away.
    
    This patch doesn't make any functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Ian Campbell <ian.campbell@citrix.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Mattia Dongili <malattia@linux.it>
    Cc: Kent Yoder <key@linux.vnet.ibm.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Cc: Bryan Wu <bryan.wu@canonical.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Alasdair Kergon <agk@redhat.com>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: linux-wireless@vger.kernel.org
    Cc: Anton Vorontsov <cbou@mail.ru>
    Cc: Sangbeom Kim <sbkim73@samsung.com>
    Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Eric Van Hensbergen <ericvh@gmail.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Petr Vandrovec <petr@vandrovec.name>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Avi Kivity <avi@redhat.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f219b2f7ee68..f6eec782c61e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -591,7 +591,7 @@ int snd_soc_suspend(struct device *dev)
 
 	/* close any waiting streams and save state */
 	for (i = 0; i < card->num_rtd; i++) {
-		flush_delayed_work_sync(&card->rtd[i].delayed_work);
+		flush_delayed_work(&card->rtd[i].delayed_work);
 		card->rtd[i].codec->dapm.suspend_bias_level = card->rtd[i].codec->dapm.bias_level;
 	}
 
@@ -1846,7 +1846,7 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	/* make sure any delayed work runs */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
-		flush_delayed_work_sync(&rtd->delayed_work);
+		flush_delayed_work(&rtd->delayed_work);
 	}
 
 	/* remove auxiliary devices */
@@ -1890,7 +1890,7 @@ int snd_soc_poweroff(struct device *dev)
 	 * now, we're shutting down so no imminent restart. */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
-		flush_delayed_work_sync(&rtd->delayed_work);
+		flush_delayed_work(&rtd->delayed_work);
 	}
 
 	snd_soc_dapm_shutdown(card);

commit 1245b7005de02d5bfa0c321df925f5b6c83c99e1
Author: Namarta Kohli <namartax.kohli@intel.com>
Date:   Thu Aug 16 17:10:41 2012 +0530

    ASoC: add compress stream support
    
    This patch adds the support to parse the compress dai's and then also adds the
    soc-compress.c file while handles the compress stream operations, mostly analogus
    to what is done in the soc-pcm.c and aditional handling of the compress
    opertaions
    
    Signed-off-by: Namarta Kohli <namartax.kohli@intel.com>
    Signed-off-by: Ramesh Babu K V <ramesh.babu@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f585d0239551..c7a00fd8cc66 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1388,37 +1388,48 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 	if (ret < 0)
 		pr_warn("asoc: failed to add pmdown_time sysfs:%d\n", ret);
 
-	if (!dai_link->params) {
-		/* create the pcm */
-		ret = soc_new_pcm(rtd, num);
+	if (cpu_dai->driver->compress_dai) {
+		/*create compress_device"*/
+		ret = soc_new_compress(rtd, num);
 		if (ret < 0) {
-			pr_err("asoc: can't create pcm %s :%d\n",
-			       dai_link->stream_name, ret);
+			pr_err("asoc: can't create compress %s\n",
+					 dai_link->stream_name);
 			return ret;
 		}
 	} else {
-		/* link the DAI widgets */
-		play_w = codec_dai->playback_widget;
-		capture_w = cpu_dai->capture_widget;
-		if (play_w && capture_w) {
-			ret = snd_soc_dapm_new_pcm(card, dai_link->params,
-						   capture_w, play_w);
-			if (ret != 0) {
-				dev_err(card->dev, "Can't link %s to %s: %d\n",
-					play_w->name, capture_w->name, ret);
+
+		if (!dai_link->params) {
+			/* create the pcm */
+			ret = soc_new_pcm(rtd, num);
+			if (ret < 0) {
+				pr_err("asoc: can't create pcm %s :%d\n",
+				       dai_link->stream_name, ret);
 				return ret;
 			}
-		}
+		} else {
+			/* link the DAI widgets */
+			play_w = codec_dai->playback_widget;
+			capture_w = cpu_dai->capture_widget;
+			if (play_w && capture_w) {
+				ret = snd_soc_dapm_new_pcm(card, dai_link->params,
+						   capture_w, play_w);
+				if (ret != 0) {
+					dev_err(card->dev, "Can't link %s to %s: %d\n",
+						play_w->name, capture_w->name, ret);
+					return ret;
+				}
+			}
 
-		play_w = cpu_dai->playback_widget;
-		capture_w = codec_dai->capture_widget;
-		if (play_w && capture_w) {
-			ret = snd_soc_dapm_new_pcm(card, dai_link->params,
+			play_w = cpu_dai->playback_widget;
+			capture_w = codec_dai->capture_widget;
+			if (play_w && capture_w) {
+				ret = snd_soc_dapm_new_pcm(card, dai_link->params,
 						   capture_w, play_w);
-			if (ret != 0) {
-				dev_err(card->dev, "Can't link %s to %s: %d\n",
-					play_w->name, capture_w->name, ret);
-				return ret;
+				if (ret != 0) {
+					dev_err(card->dev, "Can't link %s to %s: %d\n",
+						play_w->name, capture_w->name, ret);
+					return ret;
+				}
 			}
 		}
 	}

commit 3876566a368b30908ec4195d58f04a411f22f736
Author: Jerry Snitselaar <dev@snitselaar.org>
Date:   Thu Aug 9 23:16:26 2012 -0700

    ASoC: core: remove unused variable in soc_probe() in linux-next
    
    With commit 28d528c8 "ASoC: core: Remove pointless error on card
    registration failure", the variable ret is no longer used in
    soc_probe() and generates an unused variable warning during a build.
    
    Signed-off-by: Jerry Snitselaar <dev@snitselaar.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3a43fa6ba2ee..f585d0239551 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1814,7 +1814,6 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 static int soc_probe(struct platform_device *pdev)
 {
 	struct snd_soc_card *card = platform_get_drvdata(pdev);
-	int ret = 0;
 
 	/*
 	 * no card, so machine driver should be registering card

commit 28d528c8dbab5c6b3cf2fc4f0e91470a9a63dbc0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Aug 9 18:45:23 2012 +0100

    ASoC: core: Remove pointless error on card registration failure
    
    If we fail to register the card we should say why somewhere else so there's
    no point in repeating the same thing with less information.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f10f00b5d29f..3a43fa6ba2ee 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1830,13 +1830,7 @@ static int soc_probe(struct platform_device *pdev)
 	/* Bodge while we unpick instantiation */
 	card->dev = &pdev->dev;
 
-	ret = snd_soc_register_card(card);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "Failed to register card\n");
-		return ret;
-	}
-
-	return 0;
+	return snd_soc_register_card(card);
 }
 
 static int soc_cleanup_card_resources(struct snd_soc_card *card)

commit fb099cb712e878b9eb4e78dd6b268312a0b2b50f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Aug 9 18:44:37 2012 +0100

    ASoC: core: Upgrade the severity of probe deferral errors to dev_err()
    
    In the past when ASoC had a custom probe deferral mechanism people
    complained about the logspam it generated and didn't want to know about
    the fact that we were doing probe deferral so all the error messages for
    it were at dev_dbg(), making diagnostics hard. Now that we have probe
    deferral as an accepted thing and it's generating log messages anyway
    there's no need to worry about this so upgrade the severity of all the
    probe deferral sources to dev_err() so that they are displayed by default.
    
    Also add one for missing aux_devs since there wasn't one.
    
    Reported-by: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f81c5976b961..c501af6d8dbe 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -826,7 +826,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	}
 
 	if (!rtd->cpu_dai) {
-		dev_dbg(card->dev, "CPU DAI %s not registered\n",
+		dev_err(card->dev, "CPU DAI %s not registered\n",
 			dai_link->cpu_dai_name);
 		return -EPROBE_DEFER;
 	}
@@ -857,14 +857,14 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		}
 
 		if (!rtd->codec_dai) {
-			dev_dbg(card->dev, "CODEC DAI %s not registered\n",
+			dev_err(card->dev, "CODEC DAI %s not registered\n",
 				dai_link->codec_dai_name);
 			return -EPROBE_DEFER;
 		}
 	}
 
 	if (!rtd->codec) {
-		dev_dbg(card->dev, "CODEC %s not registered\n",
+		dev_err(card->dev, "CODEC %s not registered\n",
 			dai_link->codec_name);
 		return -EPROBE_DEFER;
 	}
@@ -888,7 +888,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		rtd->platform = platform;
 	}
 	if (!rtd->platform) {
-		dev_dbg(card->dev, "platform %s not registered\n",
+		dev_err(card->dev, "platform %s not registered\n",
 			dai_link->platform_name);
 		return -EPROBE_DEFER;
 	}
@@ -1481,6 +1481,8 @@ static int soc_check_aux_dev(struct snd_soc_card *card, int num)
 			return 0;
 	}
 
+	dev_err(card->dev, "%s not registered\n", aux_dev->codec_name);
+
 	return -EPROBE_DEFER;
 }
 

commit 5f800080ca6840326b3048202fb63fc4a71a4c49
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Aug 7 10:24:13 2012 +0300

    ASoC: core: Set dapm->idle_bias_off for DAIs not mapped with a codec
    
    The idle_bias_off flag is not configured for DAIs not mapped with a codec.
    This causes the pm counter to be increased at probe time for the CPU dai
    which unbalances the pm counter handling.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f81c5976b961..f10f00b5d29f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3715,6 +3715,9 @@ int snd_soc_register_dai(struct device *dev,
 		}
 	}
 
+	if (!dai->codec)
+		dai->dapm.idle_bias_off = 1;
+
 	list_add(&dai->list, &dai_list);
 
 	mutex_unlock(&client_mutex);
@@ -3803,6 +3806,9 @@ int snd_soc_register_dais(struct device *dev,
 			}
 		}
 
+		if (!dai->codec)
+			dai->dapm.idle_bias_off = 1;
+
 		list_add(&dai->list, &dai_list);
 
 		mutex_unlock(&client_mutex);

commit 98d3088e534a2a61f6690b5426909b0c3b57a785
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Aug 1 20:05:47 2012 +0100

    ASoC: core: Fix check before defaulting to regmap
    
    Check if the chip has provided a write operation (which is mandatory for
    I/O) rather than looking for control data as some of the MFDs use a global
    for this. Also skip the attempt if there's no regmap available by device
    in case things get confused by the attempt to default.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f219b2f7ee68..f81c5976b961 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1096,7 +1096,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	}
 
 	/* If the driver didn't set I/O up try regmap */
-	if (!codec->control_data)
+	if (!codec->write && dev_get_regmap(codec->dev, NULL))
 		snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP);
 
 	if (driver->controls)

commit b761c0ca2e964a240d74e50da9e27dc0b3be0649
Author: Matthias Kaehlcke <matthias@kaehlcke.net>
Date:   Wed Jul 11 17:36:34 2012 +0200

    ASoC: Free memory in the error paths of soc_of_parse_audio_routing()
    
    Release the memory of the routing table before leaving the function upon errors
    in the device tree
    
    Signed-off-by: Matthias Kaehlcke <matthias@kaehlcke.net>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 64b464ca3bc5..f219b2f7ee68 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4136,6 +4136,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 			dev_err(card->dev,
 				"Property '%s' index %d could not be read: %d\n",
 				propname, 2 * i, ret);
+			kfree(routes);
 			return -EINVAL;
 		}
 		ret = of_property_read_string_index(np, propname,
@@ -4144,6 +4145,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 			dev_err(card->dev,
 				"Property '%s' index %d could not be read: %d\n",
 				propname, (2 * i) + 1, ret);
+			kfree(routes);
 			return -EINVAL;
 		}
 	}

commit 38cbf9598feba97de9f9b43efa9153fd7c1a2ec9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jun 22 13:04:02 2012 +0100

    ASoC: core: Try to use regmap if the driver doesn't set up any I/O
    
    Since most new drivers are expected to use regmap and since frequently the
    only thing we need to do in the CODEC probe function is configure the I/O
    try to initialise the register I/O using regmap if the driver hasn't done
    so after probe().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fe16135250f8..64b464ca3bc5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1095,6 +1095,10 @@ static int soc_probe_codec(struct snd_soc_card *card,
 		}
 	}
 
+	/* If the driver didn't set I/O up try regmap */
+	if (!codec->control_data)
+		snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP);
+
 	if (driver->controls)
 		snd_soc_add_codec_controls(codec, driver->controls,
 				     driver->num_controls);

commit 62ae68fa5d6d6f93d8ca8d00e21ad7ac410f9d58
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Jun 8 12:34:23 2012 -0600

    ASoC: probe CODECs and platforms before DAIs and links
    
    soc_probe_dai_link() currently inter-mixes the probing of CODECs,
    platforms, and DAIs. This can lead to problems such as a CODEC's DAI
    being probed before the CODEC, if that DAI is used as the CPU-side of
    a DAI link without any other of the CODEC's DAIs having been used as
    the CODEC-side of any DAI link that was probed earlier.
    
    To solve this, split soc_probe_dai_link() into soc_probe_link_components()
    and soc_probe_link_dais(). The former is used to probe all CODECs and
    platforms used by a card first, and then the latter is used to probe all
    the DAIs and links later.
    
    A similar change is made to soc_remove_dai_links().
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a539ade477af..fe16135250f8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -941,11 +941,9 @@ static void soc_remove_codec(struct snd_soc_codec *codec)
 	module_put(codec->dev->driver->owner);
 }
 
-static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
+static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	struct snd_soc_codec *codec = rtd->codec;
-	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
 	int err;
 
@@ -970,16 +968,6 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 		list_del(&codec_dai->card_list);
 	}
 
-	/* remove the platform */
-	if (platform && platform->probed &&
-			platform->driver->remove_order == order)
-		soc_remove_platform(platform);
-
-	/* remove the CODEC */
-	if (codec && codec->probed &&
-			codec->driver->remove_order == order)
-		soc_remove_codec(codec);
-
 	/* remove the cpu_dai */
 	if (cpu_dai && cpu_dai->probed &&
 			cpu_dai->driver->remove_order == order) {
@@ -999,6 +987,38 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 	}
 }
 
+static void soc_remove_link_components(struct snd_soc_card *card, int num,
+				       int order)
+{
+	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_codec *codec;
+
+	/* remove the platform */
+	if (platform && platform->probed &&
+	    platform->driver->remove_order == order) {
+		soc_remove_platform(platform);
+	}
+
+	/* remove the CODEC-side CODEC */
+	if (codec_dai) {
+		codec = codec_dai->codec;
+		if (codec && codec->probed &&
+		    codec->driver->remove_order == order)
+			soc_remove_codec(codec);
+	}
+
+	/* remove any CPU-side CODEC */
+	if (cpu_dai) {
+		codec = cpu_dai->codec;
+		if (codec && codec->probed &&
+		    codec->driver->remove_order == order)
+			soc_remove_codec(codec);
+	}
+}
+
 static void soc_remove_dai_links(struct snd_soc_card *card)
 {
 	int dai, order;
@@ -1006,8 +1026,15 @@ static void soc_remove_dai_links(struct snd_soc_card *card)
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
 		for (dai = 0; dai < card->num_rtd; dai++)
-			soc_remove_dai_link(card, dai, order);
+			soc_remove_link_dais(card, dai, order);
+	}
+
+	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
+			order++) {
+		for (dai = 0; dai < card->num_rtd; dai++)
+			soc_remove_link_components(card, dai, order);
 	}
+
 	card->num_rtd = 0;
 }
 
@@ -1244,7 +1271,44 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	return 0;
 }
 
-static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
+static int soc_probe_link_components(struct snd_soc_card *card, int num,
+				     int order)
+{
+	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_platform *platform = rtd->platform;
+	int ret;
+
+	/* probe the CPU-side component, if it is a CODEC */
+	if (cpu_dai->codec &&
+	    !cpu_dai->codec->probed &&
+	    cpu_dai->codec->driver->probe_order == order) {
+		ret = soc_probe_codec(card, cpu_dai->codec);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* probe the CODEC-side component */
+	if (!codec_dai->codec->probed &&
+	    codec_dai->codec->driver->probe_order == order) {
+		ret = soc_probe_codec(card, codec_dai->codec);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* probe the platform */
+	if (!platform->probed &&
+	    platform->driver->probe_order == order) {
+		ret = soc_probe_platform(card, platform);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
@@ -1292,22 +1356,6 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 		list_add(&cpu_dai->card_list, &card->dai_dev_list);
 	}
 
-	/* probe the CODEC */
-	if (!codec->probed &&
-			codec->driver->probe_order == order) {
-		ret = soc_probe_codec(card, codec);
-		if (ret < 0)
-			return ret;
-	}
-
-	/* probe the platform */
-	if (!platform->probed &&
-			platform->driver->probe_order == order) {
-		ret = soc_probe_platform(card, platform);
-		if (ret < 0)
-			return ret;
-	}
-
 	/* probe the CODEC DAI */
 	if (!codec_dai->probed && codec_dai->driver->probe_order == order) {
 		if (codec_dai->driver->probe) {
@@ -1582,14 +1630,27 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 			goto card_probe_error;
 	}
 
-	/* early DAI link probe */
+	/* probe all components used by DAI links on this card */
 	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
 			order++) {
 		for (i = 0; i < card->num_links; i++) {
-			ret = soc_probe_dai_link(card, i, order);
+			ret = soc_probe_link_components(card, i, order);
 			if (ret < 0) {
 				pr_err("asoc: failed to instantiate card %s: %d\n",
-			       card->name, ret);
+				       card->name, ret);
+				goto probe_dai_err;
+			}
+		}
+	}
+
+	/* probe all DAI links on this card */
+	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
+			order++) {
+		for (i = 0; i < card->num_links; i++) {
+			ret = soc_probe_link_dais(card, i, order);
+			if (ret < 0) {
+				pr_err("asoc: failed to instantiate card %s: %d\n",
+				       card->name, ret);
 				goto probe_dai_err;
 			}
 		}

commit d12cd198cba7949c70f596296297b772063175c0
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Jun 8 12:34:22 2012 -0600

    ASoC: factor out soc_remove_platform()
    
    This change simply factors out part of soc_remove_dai_link() into a
    standalone function. This makes platform and CODEC removal much more
    similar at the call-sites.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 621c5bdea483..a539ade477af 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -898,6 +898,28 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	return 0;
 }
 
+static int soc_remove_platform(struct snd_soc_platform *platform)
+{
+	int ret;
+
+	if (platform->driver->remove) {
+		ret = platform->driver->remove(platform);
+		if (ret < 0)
+			pr_err("asoc: failed to remove %s: %d\n",
+				platform->name, ret);
+	}
+
+	/* Make sure all DAPM widgets are freed */
+	snd_soc_dapm_free(&platform->dapm);
+
+	soc_cleanup_platform_debugfs(platform);
+	platform->probed = 0;
+	list_del(&platform->card_list);
+	module_put(platform->dev->driver->owner);
+
+	return 0;
+}
+
 static void soc_remove_codec(struct snd_soc_codec *codec)
 {
 	int err;
@@ -950,22 +972,8 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 
 	/* remove the platform */
 	if (platform && platform->probed &&
-			platform->driver->remove_order == order) {
-		if (platform->driver->remove) {
-			err = platform->driver->remove(platform);
-			if (err < 0)
-				pr_err("asoc: failed to remove %s: %d\n",
-							platform->name, err);
-		}
-
-		/* Make sure all DAPM widgets are freed */
-		snd_soc_dapm_free(&platform->dapm);
-
-		soc_cleanup_platform_debugfs(platform);
-		platform->probed = 0;
-		list_del(&platform->card_list);
-		module_put(platform->dev->driver->owner);
-	}
+			platform->driver->remove_order == order)
+		soc_remove_platform(platform);
 
 	/* remove the CODEC */
 	if (codec && codec->probed &&

commit 18d756440e8ed292b772682c4440a9d33643225b
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Jun 8 12:34:21 2012 -0600

    ASoC: when removing a CPU DAI, clean up its DAPM context
    
    When a standalone CPU DAI (one not part of a CODEC) is probed, widgets
    are created for it. Add a call to snd_soc_dapm_free() in order to clean
    these up when the CPU DAI is removed.
    
    In order for snd_soc_dapm_free() to work, the CPU DAI's DAPM context's
    list member must be initialized, since snd_soc_dapm_free() removes that
    from the list it's part of. Add it to the card's list of DAPM contexts.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 448d4a7c09dd..621c5bdea483 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -984,8 +984,10 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 		cpu_dai->probed = 0;
 		list_del(&cpu_dai->card_list);
 
-		if (!cpu_dai->codec)
+		if (!cpu_dai->codec) {
+			snd_soc_dapm_free(&cpu_dai->dapm);
 			module_put(cpu_dai->dev->driver->owner);
+		}
 	}
 }
 
@@ -1264,6 +1266,7 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 			if (!try_module_get(cpu_dai->dev->driver->owner))
 				return -ENODEV;
 
+			list_add(&cpu_dai->dapm.list, &card->dapm_list);
 			snd_soc_dapm_new_dai_widgets(&cpu_dai->dapm, cpu_dai);
 		}
 

commit a9db7dbee0436f0c741c6dfb39ab0241d4131539
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Jun 8 12:34:20 2012 -0600

    ASoC: when initializing CPU DAI, don't duplicate any CODEC init
    
    If the CPU-side of a DAI link is a CODEC rather than a standalone DAI,
    the codec initialization will call try_module_get() and create the DAI
    widgets. Ensure that this isn't duplicated when the CPU DAI itself is
    probed, if the CPU DAI is part of a CODEC.
    
    Note that this is not a complete fix on its own, since there's no
    guarantee that the CODEC itself will be initialized - currently that only
    happens if the CODEC is also used as the CODEC-side of a DAI link, and
    that initialization may happen before or after the DAIs within the CODEC
    are initialized. However, such a scenario doesn't necessarily currently
    work, and I don't think this change alone makes it any worse. This is
    fixed in a couple patches time.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3d803f3cd272..448d4a7c09dd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -983,7 +983,9 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 		}
 		cpu_dai->probed = 0;
 		list_del(&cpu_dai->card_list);
-		module_put(cpu_dai->dev->driver->owner);
+
+		if (!cpu_dai->codec)
+			module_put(cpu_dai->dev->driver->owner);
 	}
 }
 
@@ -1257,11 +1259,13 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 	/* probe the cpu_dai */
 	if (!cpu_dai->probed &&
 			cpu_dai->driver->probe_order == order) {
-		cpu_dai->dapm.card = card;
-		if (!try_module_get(cpu_dai->dev->driver->owner))
-			return -ENODEV;
+		if (!cpu_dai->codec) {
+			cpu_dai->dapm.card = card;
+			if (!try_module_get(cpu_dai->dev->driver->owner))
+				return -ENODEV;
 
-		snd_soc_dapm_new_dai_widgets(&cpu_dai->dapm, cpu_dai);
+			snd_soc_dapm_new_dai_widgets(&cpu_dai->dapm, cpu_dai);
+		}
 
 		if (cpu_dai->driver->probe) {
 			ret = cpu_dai->driver->probe(cpu_dai);

commit 6c9d8cf6372ed2995a3d982f5c1f966e842101cc
Author: Adam Thomson <Adam.Thomson@diasemi.com>
Date:   Thu May 31 15:18:01 2012 +0100

    ASoC: core: Add single controls with specified range of values
    
    Control type added for cases where a specific range of values
    within a register are required for control.
    
    Added convenience macros:
    
    SOC_SINGLE_RANGE
    SOC_SINGLE_RANGE_TLV
    
    Added accessor implementations:
    
    snd_soc_info_volsw_range
    snd_soc_put_volsw_range
    snd_soc_get_volsw_range
    
    Signed-off-by: Michal Hajduk <Michal.Hajduk@diasemi.com>
    Signed-off-by: Adam Thomson <Adam.Thomson@diasemi.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ec8350570346..3d803f3cd272 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2791,6 +2791,104 @@ int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 
+/**
+ * snd_soc_info_volsw_range - single mixer info callback with range.
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information, within a range, about a single
+ * mixer control.
+ *
+ * returns 0 for success.
+ */
+int snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int platform_max;
+	int min = mc->min;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max - min;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_range);
+
+/**
+ * snd_soc_put_volsw_range - single mixer put value callback with range.
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value, within a range, for a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	int min = mc->min;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val, val_mask;
+
+	val = ((ucontrol->value.integer.value[0] + min) & mask);
+	if (invert)
+		val = max - val;
+	val_mask = mask << shift;
+	val = val << shift;
+
+	return snd_soc_update_bits_locked(codec, reg, val_mask, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_range);
+
+/**
+ * snd_soc_get_volsw_range - single mixer get callback with range
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value, within a range, of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	int min = mc->min;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(codec, reg) >> shift) & mask;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+	ucontrol->value.integer.value[0] =
+		ucontrol->value.integer.value[0] - min;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_range);
+
 /**
  * snd_soc_limit_volume - Set new limit to an existing volume control.
  *

commit bc92657a11c0982783979bbb84ceaf58ba222124
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri May 25 18:22:11 2012 -0600

    ASoC: make snd_soc_dai_link more symmetrical
    
    Prior to this patch, the CPU side of a DAI link was specified using a
    single name. Often, this was the result of calling dev_name() on the
    device providing the DAI, but in the case of a CPU DAI driver that
    provided multiple DAIs, it needed to mix together both the device name
    and some device-relative name, in order to form a single globally unique
    name.
    
    However, the CODEC side of the DAI link was specified using separate
    fields for device (name or OF node) and device-relative DAI name.
    
    This patch allows the CPU side of a DAI link to be specified in the same
    way as the CODEC side, separating concepts of device and device-relative
    DAI name.
    
    I believe this will be important in multi-codec and/or dynamic PCM
    scenarios, where a single CPU driver provides multiple DAIs, while also
    booting using device tree, with accompanying desire not to hard-code the
    CPU side device's name into the original .cpu_dai_name field.
    
    Ideally, both the CPU DAI and CODEC DAI loops in soc_bind_dai_link()
    would now be identical. However, two things prevent that at present:
    
    1) The need to save rtd->codec for the CODEC side, which means we have
    to search for the CODEC explicitly, and not just the CODEC side DAI.
    
    2) Since we know the CODEC side DAI is part of a codec, and not just
    a standalone DAI, it's slightly more efficient to convert .codec_name/
    .codec_of_node into a codec first, and then compare each DAI's .codec
    field, since this avoids strcmp() on each DAI's CODEC's name within
    the loop.
    
    However, the two loops are essentially semantically equivalent.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b37ee8077ed1..ec8350570346 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -812,13 +812,15 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 
 	/* Find CPU DAI from registered DAIs*/
 	list_for_each_entry(cpu_dai, &dai_list, list) {
-		if (dai_link->cpu_dai_of_node) {
-			if (cpu_dai->dev->of_node != dai_link->cpu_dai_of_node)
-				continue;
-		} else {
-			if (strcmp(cpu_dai->name, dai_link->cpu_dai_name))
-				continue;
-		}
+		if (dai_link->cpu_of_node &&
+		    (cpu_dai->dev->of_node != dai_link->cpu_of_node))
+			continue;
+		if (dai_link->cpu_name &&
+		    strcmp(dev_name(cpu_dai->dev), dai_link->cpu_name))
+			continue;
+		if (dai_link->cpu_dai_name &&
+		    strcmp(cpu_dai->name, dai_link->cpu_dai_name))
+			continue;
 
 		rtd->cpu_dai = cpu_dai;
 	}
@@ -3346,6 +3348,12 @@ int snd_soc_register_card(struct snd_soc_card *card)
 				link->name);
 			return -EINVAL;
 		}
+		/* Codec DAI name must be specified */
+		if (!link->codec_dai_name) {
+			dev_err(card->dev, "codec_dai_name not set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
 
 		/*
 		 * Platform may be specified by either name or OF node, but
@@ -3358,12 +3366,24 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		}
 
 		/*
-		 * CPU DAI must be specified by 1 of name or OF node,
-		 * not both or neither.
+		 * CPU device may be specified by either name or OF node, but
+		 * can be left unspecified, and will be matched based on DAI
+		 * name alone..
+		 */
+		if (link->cpu_name && link->cpu_of_node) {
+			dev_err(card->dev,
+				"Neither/both cpu name/of_node are set for %s\n",
+				link->name);
+			return -EINVAL;
+		}
+		/*
+		 * At least one of CPU DAI name or CPU device name/node must be
+		 * specified
 		 */
-		if (!!link->cpu_dai_name == !!link->cpu_dai_of_node) {
+		if (!link->cpu_dai_name &&
+		    !(link->cpu_name || link->cpu_of_node)) {
 			dev_err(card->dev,
-				"Neither/both cpu_dai name/of_node are set for %s\n",
+				"Neither cpu_dai_name nor cpu_name/of_node are set for %s\n",
 				link->name);
 			return -EINVAL;
 		}

commit fe33d4c5e2b27a4b82aa479a58f2621eec103d1b
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon May 14 14:47:22 2012 -0600

    ASoC: don't flip master of DT-instantiated DAI links
    
    Commit 4924082 "ASoC: core: Flip master for CODECs in the CPU slot of a
    CODEC<->CODEC link" added code that was conditional on there being no
    PCM/DMA driver for the link. However, it failed to cover the case where
    the link was instantiated from device tree, and hence was specified by
    DT node rather than name.
    
    This prevents the following error on Toshiba AC100:
    aplay: pcm_write:1603: write error: Input/output error
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2783d2b00dba..b37ee8077ed1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1612,7 +1612,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 
 		/* If this is a regular CPU link there will be a platform */
-		if (dai_fmt && dai_link->platform_name) {
+		if (dai_fmt &&
+		    (dai_link->platform_name || dai_link->platform_of_node)) {
 			ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai,
 						  dai_fmt);
 			if (ret != 0 && ret != -ENOTSUPP)

commit dc2af52c0d6d00fd530e4a5e300834cdb1bb1c1c
Merge: f1992dde7fef 36be50515fe2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun May 13 13:32:54 2012 +0100

    Merge tag 'v3.4-rc7' into for-3.5
    
    Linux 3.4-rc7
    
    Conflicts):
            drivers/base/regmap/regmap.c         (overlap with bug fixes)
            sound/soc/blackfin/bf5xx-ssm2602.c   (overlap with bug fixes)

commit 1c2f95480648ed7326ab2288ca0e2d35551db4be
Merge: 59068e369b6a e9e7183fd267
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 5 10:07:06 2012 -0700

    Merge tag 'sound-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound sound fixes from Takashi Iwai:
     "As good as nothing exciting here; just a few trivial fixes for various
      ASoC stuff."
    
    * tag 'sound-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound:
      ASoC: omap-pcm: Free dma buffers in case of error.
      ASoC: s3c2412-i2s: Fix dai registration
      ASoC: wm8350: Don't use locally allocated codec struct
      ASoC: tlv312aic23: unbreak resume
      ASoC: bf5xx-ssm2602: Set DAI format
      ASoC: core: check of_property_count_strings failure
      ASoC: dt: sgtl5000.txt: Add description for 'reg' field
      ASoC: wm_hubs: Make sure we don't disable differential line outputs

commit cd0f8911c5d0cc04763f87cf118c66b867e2e6d2
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Apr 30 11:05:30 2012 +0100

    ASoC: core: Fix dai_link dereference.
    
    We should check dailess before dereferencing.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4d8869852ad6..a61671b89e9b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1218,7 +1218,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 
 #ifdef CONFIG_DEBUG_FS
 	/* add DPCM sysfs entries */
-	if (!dai_link->dynamic)
+	if (!dailess && !dai_link->dynamic)
 		goto out;
 
 	ret = soc_dpcm_debugfs_add(rtd);

commit 2390c0fca6d31af0c1194a491d9629fbe27703b8
Merge: 65dd4b910801 cff7873554ee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 26 15:32:39 2012 -0700

    Merge tag 'sound-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound fixes from Takashi Iwai:
     "A workaround for an ASUS laptop and a few ASoC changes; most of the
      commits are tagged for stable, too."
    
    * tag 'sound-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound:
      ASoC: wm8994: Improve sequencing of AIF channel enables
      ALSA: HDA: Add external mic quirk for Asus Zenbook UX31E
      ASoC: fsi: update for dmaengine prep_slave_sg fallout.
      ASoC: core: Fix card RTD count for deferred probe.
      ASoC: cs42l73: don't use negative array index
      ASoC: dapm: Ensure power gets managed for line widgets

commit 47c88ffff73d27425be59b34a6d5a91518b5ebed
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Apr 25 12:12:53 2012 +0100

    ASoC: dpcm: Add API for DAI link substream and runtime lookup
    
    Some component drivers will need to be able to look up their
    DAI link substream and RTD data. Provide a mechanism for this.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 201a4d003b9a..4d8869852ad6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -465,6 +465,35 @@ static inline void soc_cleanup_card_debugfs(struct snd_soc_card *card)
 }
 #endif
 
+struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
+		const char *dai_link, int stream)
+{
+	int i;
+
+	for (i = 0; i < card->num_links; i++) {
+		if (card->rtd[i].dai_link->no_pcm &&
+			!strcmp(card->rtd[i].dai_link->name, dai_link))
+			return card->rtd[i].pcm->streams[stream].substream;
+	}
+	dev_dbg(card->dev, "failed to find dai link %s\n", dai_link);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_dai_substream);
+
+struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
+		const char *dai_link)
+{
+	int i;
+
+	for (i = 0; i < card->num_links; i++) {
+		if (!strcmp(card->rtd[i].dai_link->name, dai_link))
+			return &card->rtd[i];
+	}
+	dev_dbg(card->dev, "failed to find rtd %s\n", dai_link);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
+
 #ifdef CONFIG_SND_SOC_AC97_BUS
 /* unregister ac97 codec */
 static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)

commit f86dcef87b771935c223334324a93c1d71f7a84c
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Apr 25 12:12:50 2012 +0100

    ASoC: dpcm: Add debugFS support for DPCM
    
    Add debugFS files for DPCM link management information.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 01220a5cf43e..201a4d003b9a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1187,6 +1187,17 @@ static int soc_post_component_init(struct snd_soc_card *card,
 		dev_err(codec->dev,
 			"asoc: failed to add codec sysfs files: %d\n", ret);
 
+#ifdef CONFIG_DEBUG_FS
+	/* add DPCM sysfs entries */
+	if (!dai_link->dynamic)
+		goto out;
+
+	ret = soc_dpcm_debugfs_add(rtd);
+	if (ret < 0)
+		dev_err(rtd->dev, "asoc: failed to add dpcm sysfs entries: %d\n", ret);
+
+out:
+#endif
 	return 0;
 }
 

commit 01d7584cd2e5a93a2b959c9dddaa0d93ec205404
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Apr 25 12:12:49 2012 +0100

    ASoC: dpcm: Add Dynamic PCM core operations.
    
    The Dynamic PCM core allows digital audio data to be dynamically
    routed between different ALSA PCMs and DAI links on SoC CPUs with
    on chip DSP devices. e.g. audio data could be played on pcm:0,0 and
    routed to any (or all) SoC DAI links.
    
    Dynamic PCM introduces the concept of Front End (FE) PCMs and Back
    End (BE) PCMs. The FE PCMs are normal ALSA PCM devices except that
    they can dynamically route digital audio data to any supported BE
    PCM. A BE PCM has no ALSA device, but represents a DAI link and it's
    substream and audio HW parameters.
    
    e.g. pcm:0,0 routing digital data to 2 external codecs.
    
    FE pcm:0,0  ----> BE (McBSP.0) ----> CODEC 0
                 +--> BE (McPDM.0) ----> CODEC 1
    
    e.g. pcm:0,0 and pcm:0,1 routing digital data to 1 external codec.
    
    FE pcm:0,0 ---
                 +--> BE (McBSP.0) ----> CODEC
    FE pcm:0,1 ---
    
    The digital audio routing is controlled by the usual ALSA method
    of mixer kcontrols. Dynamic PCM uses a DAPM graph to work out the
    routing based upon the mixer settings and configures the BE PCMs
    based on routing and the FE HW params.
    
    DPCM is designed so that most ASoC component drivers will need no
    modification at all. It's intended that existing CODEC, DAI and
    platform drivers can be used in DPCM based audio devices without
    any changes. However, there will be some cases where minor changes
    are required (e.g. for very tightly coupled HW) and there are
    helpers to support this too.
    
    Somethimes the HW params of a FE and BE do not match or are
    incompatible, so in these cases the machine driver can reconfigure
    any hw_params and make any DSP perform sample rate / format conversion.
    
    This patch adds the core DPCM code and contains :-
    
     o The FE and BE PCM operations.
     o FE and BE DAI link support.
     o FE and BE PCM creation.
     o BE support API.
     o BE and FE link management.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index de97bf586c6b..01220a5cf43e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -39,6 +39,7 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
+#include <sound/soc-dpcm.h>
 #include <sound/initval.h>
 
 #define CREATE_TRACE_POINTS
@@ -1161,6 +1162,10 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	rtd->dev->init_name = name;
 	dev_set_drvdata(rtd->dev, rtd);
 	mutex_init(&rtd->pcm_mutex);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].be_clients);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].fe_clients);
+	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_CAPTURE].fe_clients);
 	ret = device_add(rtd->dev);
 	if (ret < 0) {
 		dev_err(card->dev,

commit f20c2cb9995eb8c5cd7084e11af7b54522ef0ab9
Author: Fabio Estevam <festevam@gmail.com>
Date:   Thu Apr 26 01:51:59 2012 -0300

    ASoC: core: Remove unused variable 'min'
    
    commit 4183eed2 (ASoC: core: Add signed multi register control) introduced
    the variable 'min',but it is not used.
    
    Remove it to fix the following build warning:
    
    sound/soc/soc-core.c: In function 'snd_soc_put_xr_sx':
    sound/soc/soc-core.c:2990: warning: unused variable 'min'
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 666b81b400c2..de97bf586c6b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2987,7 +2987,6 @@ int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
 	unsigned int regwmask = (1<<regwshift)-1;
 	unsigned int invert = mc->invert;
 	unsigned long mask = (1UL<<mc->nbits)-1;
-	long min = mc->min;
 	long max = mc->max;
 	long val = ucontrol->value.integer.value[0];
 	unsigned int i, regval, regmask;

commit c34ce320d9fe328e3272def20b152f39ccfa045e
Author: Richard Zhao <richard.zhao@freescale.com>
Date:   Tue Apr 24 15:24:43 2012 +0800

    ASoC: core: check of_property_count_strings failure
    
    Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: stable@vger.kernel.org

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3a4e93e52b6d..b390f00b4e99 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3631,10 +3631,10 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 	int i, ret;
 
 	num_routes = of_property_count_strings(np, propname);
-	if (num_routes & 1) {
+	if (num_routes < 0 || num_routes & 1) {
 		dev_err(card->dev,
-			"Property '%s's length is not even\n",
-			propname);
+		     "Property '%s' does not exist or its length is not even\n",
+		     propname);
 		return -EINVAL;
 	}
 	num_routes /= 2;

commit dd7b10b30c40dddb9750926d78cfe89c0cd8434d
Author: Kristoffer KARLSSON <kristoffer.karlsson@stericsson.com>
Date:   Fri Apr 20 11:32:44 2012 +0200

    ASoC: core: Add strobe control
    
    Added support for a control that strobes a bit in
    a register to high then back to low (or the inverse).
    
    This is typically useful for hardware that requires
    strobing a singe bit to trigger some functionality
    and where exposing the bit in a normal single control
    would require the user to first manually set then
    again unset the bit again for the strobe to trigger.
    
    Added convenience macro.
    
    SOC_SINGLE_STROBE
    
    Added accessor implementations.
    
    snd_soc_get_strobe
    snd_soc_put_strobe
    
    Signed-off-by: Kristoffer KARLSSON <kristoffer.karlsson@stericsson.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 01bbd86cf270..666b81b400c2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3009,6 +3009,69 @@ int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_xr_sx);
 
+/**
+ * snd_soc_get_strobe - strobe get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback get the value of a strobe mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_strobe(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = 1 << shift;
+	unsigned int invert = mc->invert != 0;
+	unsigned int val = snd_soc_read(codec, reg) & mask;
+
+	if (shift != 0 && val != 0)
+		val = val >> shift;
+	ucontrol->value.enumerated.item[0] = val ^ invert;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_strobe);
+
+/**
+ * snd_soc_put_strobe - strobe put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback strobe a register bit to high then low (or the inverse)
+ * in one pass of a single mixer enum control.
+ *
+ * Returns 1 for success.
+ */
+int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = 1 << shift;
+	unsigned int invert = mc->invert != 0;
+	unsigned int strobe = ucontrol->value.enumerated.item[0] != 0;
+	unsigned int val1 = (strobe ^ invert) ? mask : 0;
+	unsigned int val2 = (strobe ^ invert) ? 0 : mask;
+	int err;
+
+	err = snd_soc_update_bits_locked(codec, reg, mask, val1);
+	if (err < 0)
+		return err;
+
+	err = snd_soc_update_bits_locked(codec, reg, mask, val2);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_strobe);
+
 /**
  * snd_soc_dai_set_sysclk - configure DAI system or master clock.
  * @dai: DAI

commit 4183eed288f31c3b9142476915e842f879f36b8e
Author: Kristoffer KARLSSON <kristoffer.karlsson@stericsson.com>
Date:   Fri Apr 20 11:32:13 2012 +0200

    ASoC: core: Add signed multi register control
    
    Added control type that can span multiple consecutive codec registers
    forming a single signed value in a MSB/LSB manner.
    The control dynamically adjusts to the register word size configured
    in driver.
    
    Added convenience macro.
    
    SOC_SINGLE_XR_SX
    
    Added accessor implementations.
    
    snd_soc_info_xr_sx
    snd_soc_get_xr_sx
    snd_soc_put_xr_sx
    
    Signed-off-by: Kristoffer KARLSSON <kristoffer.karlsson@stericsson.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5d308e92f9b0..01bbd86cf270 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2891,6 +2891,124 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_bytes_put);
 
+/**
+ * snd_soc_info_xr_sx - signed multi register info callback
+ * @kcontrol: mreg control
+ * @uinfo: control element information
+ *
+ * Callback to provide information of a control that can
+ * span multiple codec registers which together
+ * forms a single signed value in a MSB/LSB manner.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_xr_sx(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mreg_control *mc =
+		(struct soc_mreg_control *)kcontrol->private_value;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = mc->min;
+	uinfo->value.integer.max = mc->max;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_xr_sx);
+
+/**
+ * snd_soc_get_xr_sx - signed multi register get callback
+ * @kcontrol: mreg control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a control that can span
+ * multiple codec registers which together forms a single
+ * signed value in a MSB/LSB manner. The control supports
+ * specifying total no of bits used to allow for bitfields
+ * across the multiple codec registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mreg_control *mc =
+		(struct soc_mreg_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int regbase = mc->regbase;
+	unsigned int regcount = mc->regcount;
+	unsigned int regwshift = codec->driver->reg_word_size * BITS_PER_BYTE;
+	unsigned int regwmask = (1<<regwshift)-1;
+	unsigned int invert = mc->invert;
+	unsigned long mask = (1UL<<mc->nbits)-1;
+	long min = mc->min;
+	long max = mc->max;
+	long val = 0;
+	unsigned long regval;
+	unsigned int i;
+
+	for (i = 0; i < regcount; i++) {
+		regval = snd_soc_read(codec, regbase+i) & regwmask;
+		val |= regval << (regwshift*(regcount-i-1));
+	}
+	val &= mask;
+	if (min < 0 && val > max)
+		val |= ~mask;
+	if (invert)
+		val = max - val;
+	ucontrol->value.integer.value[0] = val;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_xr_sx);
+
+/**
+ * snd_soc_put_xr_sx - signed multi register get callback
+ * @kcontrol: mreg control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a control that can span
+ * multiple codec registers which together forms a single
+ * signed value in a MSB/LSB manner. The control supports
+ * specifying total no of bits used to allow for bitfields
+ * across the multiple codec registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mreg_control *mc =
+		(struct soc_mreg_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int regbase = mc->regbase;
+	unsigned int regcount = mc->regcount;
+	unsigned int regwshift = codec->driver->reg_word_size * BITS_PER_BYTE;
+	unsigned int regwmask = (1<<regwshift)-1;
+	unsigned int invert = mc->invert;
+	unsigned long mask = (1UL<<mc->nbits)-1;
+	long min = mc->min;
+	long max = mc->max;
+	long val = ucontrol->value.integer.value[0];
+	unsigned int i, regval, regmask;
+	int err;
+
+	if (invert)
+		val = max - val;
+	val &= mask;
+	for (i = 0; i < regcount; i++) {
+		regval = (val >> (regwshift*(regcount-i-1))) & regwmask;
+		regmask = (mask >> (regwshift*(regcount-i-1))) & regwmask;
+		err = snd_soc_update_bits_locked(codec, regbase+i,
+				regmask, regval);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_xr_sx);
+
 /**
  * snd_soc_dai_set_sysclk - configure DAI system or master clock.
  * @dai: DAI

commit a7dbb603423d499acacefb5fad65d2b406f16370
Author: Liam Girdwood <lrg@ti.com>
Date:   Tue Apr 17 18:00:11 2012 +0100

    ASoC: core: Fix card RTD count for deferred probe.
    
    Currently we increment the number of RTD's per card during the DAI link
    bind. This can cause an incorrect RTD count when we cannot find a component
    and defer the probe (and hence perform the DAI link bind for the card again).
    
    Fix the count so that it is cleared before every card registration
    and bind attempt.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8d2ebf502df4..3a4e93e52b6d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3119,6 +3119,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 				 GFP_KERNEL);
 	if (card->rtd == NULL)
 		return -ENOMEM;
+	card->num_rtd = 0;
 	card->rtd_aux = &card->rtd[card->num_links];
 
 	for (i = 0; i < card->num_links; i++)

commit d5efccd5b6843c504042735c1e20d9252daefd98
Merge: 516541a00c6a e816b57a337e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Apr 16 19:40:27 2012 +0100

    ASoC: Merge tag 'v3.4-rc3' into for-3.5
    
    Linux 3.4-rc3 contains a bunch of Tegra changes which are conflicting
    annoyingly with the new development that's going on for Tegra so merge
    it up to resolve those conflicts.
    
    Conflicts:
            sound/soc/soc-core.c
            sound/soc/tegra/tegra_i2s.c
            sound/soc/tegra/tegra_spdif.c

commit c74184ed30ecce2a5e9ae9aa22cb5e3942e0c7c7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 4 22:12:09 2012 +0100

    ASoC: core: Support transparent CODEC<->CODEC DAI links
    
    Rather than having the user half start a stream but avoid any DMA to
    trigger data flow on links which don't pass through the CPU create a
    DAPM route between the two DAI widgets using a hw_params configuration
    provided by the machine driver with the new 'params' member of the
    dai_link struct.  If no configuration is provided in the dai_link then
    use the old style even for CODEC<->CODEC links to avoid breaking
    systems.
    
    This greatly simplifies the userspace usage of such links, making them
    as simple as analogue connections with the stream configuration being
    completely transparent to them.
    
    This is achieved by defining a new dai_link widget type which is created
    when CODECs are linked and triggering the configuration of the link via
    the normal PCM operations from there.  It is expected that the bias
    level callbacks will be used for clock configuration.
    
    Currently only the DAI format, rate and channel count can be configured
    and currently the only DAI operations which can be called are hw_params
    and digital_mute().  This corresponds well to the majority of CODEC
    drivers which only use other callbacks for constraint setting but there
    is obviously much room for extension here.  We can't simply call
    hw_params() on startup as things like the system clocking configuration
    may change at runtime and in future it will be desirable to offer some
    configurability of the link parameters.
    
    At present we are also restricted to a single DAPM link for the entire
    DAI.  Once we have better support for channel mapping it would also be
    desirable to extend this feature so that we can propagate per-channel
    power state over the link.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0caa8d9e685f..77f35292f1b0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1189,7 +1189,9 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_codec *codec = rtd->codec;
 	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dapm_widget *play_w, *capture_w;
 	int ret;
 
 	dev_dbg(card->dev, "probe %s dai link %d late %d\n",
@@ -1270,12 +1272,39 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 	if (ret < 0)
 		pr_warn("asoc: failed to add pmdown_time sysfs:%d\n", ret);
 
-	/* create the pcm */
-	ret = soc_new_pcm(rtd, num);
-	if (ret < 0) {
-		pr_err("asoc: can't create pcm %s :%d\n",
-				dai_link->stream_name, ret);
-		return ret;
+	if (!dai_link->params) {
+		/* create the pcm */
+		ret = soc_new_pcm(rtd, num);
+		if (ret < 0) {
+			pr_err("asoc: can't create pcm %s :%d\n",
+			       dai_link->stream_name, ret);
+			return ret;
+		}
+	} else {
+		/* link the DAI widgets */
+		play_w = codec_dai->playback_widget;
+		capture_w = cpu_dai->capture_widget;
+		if (play_w && capture_w) {
+			ret = snd_soc_dapm_new_pcm(card, dai_link->params,
+						   capture_w, play_w);
+			if (ret != 0) {
+				dev_err(card->dev, "Can't link %s to %s: %d\n",
+					play_w->name, capture_w->name, ret);
+				return ret;
+			}
+		}
+
+		play_w = cpu_dai->playback_widget;
+		capture_w = codec_dai->capture_widget;
+		if (play_w && capture_w) {
+			ret = snd_soc_dapm_new_pcm(card, dai_link->params,
+						   capture_w, play_w);
+			if (ret != 0) {
+				dev_err(card->dev, "Can't link %s to %s: %d\n",
+					play_w->name, capture_w->name, ret);
+				return ret;
+			}
+		}
 	}
 
 	/* add platform data for AC97 devices */

commit 054880febeb890b24d705240384856ea6b3ccf7b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Apr 9 17:29:19 2012 +0100

    ASoC: core: Bind DAIs to CODECs at registration time
    
    We should always have a CODEC already there when registering a CODEC DAI
    and for CODEC<->CODEC links a dai_link will have two CODECs so it's much
    simpler to do things at registration time.
    
    This results in a slight change in the error handling for failed CODEC
    DAI registrations but practically speaking these are never supposed to
    fail so there shouldn't be much issue. The change is that we don't fail
    the overall CODEC registration if the DAI registration fails; this seems
    more robust anyway as we may not need to use a given DAI in a particular
    system.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9eefe9072dfa..0caa8d9e685f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1196,7 +1196,6 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 			card->name, num, order);
 
 	/* config components */
-	codec_dai->codec = codec;
 	cpu_dai->platform = platform;
 	codec_dai->card = card;
 	cpu_dai->card = card;
@@ -3227,6 +3226,7 @@ static inline char *fmt_multiple_name(struct device *dev,
 int snd_soc_register_dai(struct device *dev,
 		struct snd_soc_dai_driver *dai_drv)
 {
+	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
 
 	dev_dbg(dev, "dai register %s\n", dev_name(dev));
@@ -3249,7 +3249,18 @@ int snd_soc_register_dai(struct device *dev,
 		dai->driver->ops = &null_dai_ops;
 
 	mutex_lock(&client_mutex);
+
+	list_for_each_entry(codec, &codec_list, list) {
+		if (codec->dev == dev) {
+			dev_dbg(dev, "Mapped DAI %s to CODEC %s\n",
+				dai->name, codec->name);
+			dai->codec = codec;
+			break;
+		}
+	}
+
 	list_add(&dai->list, &dai_list);
+
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Registered DAI '%s'\n", dai->name);
@@ -3293,6 +3304,7 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
 int snd_soc_register_dais(struct device *dev,
 		struct snd_soc_dai_driver *dai_drv, size_t count)
 {
+	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
 	int i, ret = 0;
 
@@ -3325,7 +3337,18 @@ int snd_soc_register_dais(struct device *dev,
 			dai->driver->ops = &null_dai_ops;
 
 		mutex_lock(&client_mutex);
+
+		list_for_each_entry(codec, &codec_list, list) {
+			if (codec->dev == dev) {
+				dev_dbg(dev, "Mapped DAI %s to CODEC %s\n",
+					dai->name, codec->name);
+				dai->codec = codec;
+				break;
+			}
+		}
+
 		list_add(&dai->list, &dai_list);
+
 		mutex_unlock(&client_mutex);
 
 		pr_debug("Registered DAI '%s'\n", dai->name);
@@ -3537,17 +3560,18 @@ int snd_soc_register_codec(struct device *dev,
 		fixup_codec_formats(&dai_drv[i].capture);
 	}
 
+	mutex_lock(&client_mutex);
+	list_add(&codec->list, &codec_list);
+	mutex_unlock(&client_mutex);
+
 	/* register any DAIs */
 	if (num_dai) {
 		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
 		if (ret < 0)
-			goto fail;
+			dev_err(codec->dev, "Failed to regster DAIs: %d\n",
+				ret);
 	}
 
-	mutex_lock(&client_mutex);
-	list_add(&codec->list, &codec_list);
-	mutex_unlock(&client_mutex);
-
 	pr_debug("Registered codec '%s'\n", codec->name);
 	return 0;
 

commit f04209a7b0a9942aa78f8b27e63a8a5cc097adf8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Apr 9 16:29:21 2012 +0100

    ASoC: core: Flip master for CODECs in the CPU slot of a CODEC<->CODEC link
    
    When two CODEC DAIs are linked directly to each other then if we give the
    same master mode settings to both devices things won't work as either
    neither will drive or they'll drive against each other. Flip the settings
    for the DAI in the CPU slot of the DAI link.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 98a4f7aa4f01..9eefe9072dfa 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1416,7 +1416,7 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 	struct snd_soc_codec_conf *codec_conf;
 	enum snd_soc_compress_type compress_type;
 	struct snd_soc_dai_link *dai_link;
-	int ret, i, order;
+	int ret, i, order, dai_fmt;
 
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
@@ -1525,17 +1525,46 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	for (i = 0; i < card->num_links; i++) {
 		dai_link = &card->dai_link[i];
+		dai_fmt = dai_link->dai_fmt;
 
-		if (dai_link->dai_fmt) {
+		if (dai_fmt) {
 			ret = snd_soc_dai_set_fmt(card->rtd[i].codec_dai,
-						  dai_link->dai_fmt);
+						  dai_fmt);
 			if (ret != 0 && ret != -ENOTSUPP)
 				dev_warn(card->rtd[i].codec_dai->dev,
 					 "Failed to set DAI format: %d\n",
 					 ret);
+		}
+
+		/* If this is a regular CPU link there will be a platform */
+		if (dai_fmt && dai_link->platform_name) {
+			ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai,
+						  dai_fmt);
+			if (ret != 0 && ret != -ENOTSUPP)
+				dev_warn(card->rtd[i].cpu_dai->dev,
+					 "Failed to set DAI format: %d\n",
+					 ret);
+		} else if (dai_fmt) {
+			/* Flip the polarity for the "CPU" end */
+			dai_fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+			switch (dai_link->dai_fmt &
+				SND_SOC_DAIFMT_MASTER_MASK) {
+			case SND_SOC_DAIFMT_CBM_CFM:
+				dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
+				break;
+			case SND_SOC_DAIFMT_CBM_CFS:
+				dai_fmt |= SND_SOC_DAIFMT_CBS_CFM;
+				break;
+			case SND_SOC_DAIFMT_CBS_CFM:
+				dai_fmt |= SND_SOC_DAIFMT_CBM_CFS;
+				break;
+			case SND_SOC_DAIFMT_CBS_CFS:
+				dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+				break;
+			}
 
 			ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai,
-						  dai_link->dai_fmt);
+						  dai_fmt);
 			if (ret != 0 && ret != -ENOTSUPP)
 				dev_warn(card->rtd[i].cpu_dai->dev,
 					 "Failed to set DAI format: %d\n",

commit 04570c628fbd5ede85d87a0b81bd19df7b13bbc4
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Apr 13 19:16:03 2012 +0100

    ASoC: core: Return -ENOTSUPP instead of -EINVAL if mute is not supported
    
    This helps us ignore errors in callers if the operation failed due to not
    being available as opposed to an error.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8a17048dba42..98a4f7aa4f01 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3031,7 +3031,7 @@ int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
 	if (dai->driver && dai->driver->ops->digital_mute)
 		return dai->driver->ops->digital_mute(dai, mute);
 	else
-		return -EINVAL;
+		return -ENOTSUPP;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 

commit a1ada086062101533eb0f841d3884137688091ec
Merge: 39f86a608a3e fae3d88a5c56
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 11 11:07:38 2012 -0700

    Merge tag 'sound-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound fixes from Takashi Iwai:
     - A series of fixes for Conexant 20549 HD-audio codec chip
     - A workaround for HDMI hotplug debug prints that annoyed people
     - A fix for the new support of platform DAPM contexts
     - Many driver-specific minor fixes
    
    * tag 'sound-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound:
      ALSA: hda - hide HDMI/ELD printks unless snd.debug=2
      ALSA: sound/isa/sscape.c: add missing resource-release code
      sound: sound/oss/msnd_pinnacle.c: add vfrees
      ALSA: hda - clean up CX20549 test mixer setup
      ALSA: hda - CX20549 doesn't need pin_amp_workaround.
      ALSA: hda - Remove CD control from model=benq for CX20549
      ALSA: hda - fix record volume controls of CX20459 ("Venice")
      ALSA: hda - Rename capture sources of CX20549 to match common conventions
      ALSA: hda - Fix proc output for ADC amp values of CX20549
      ASoC: tegra: fix i2s compilation when !CONFIG_DEBUG_FS
      ASoC: set idle_bias_off=1 for all platform DAPM contexts
      ASoC: imx-audmux: Check for NULL pointer
      ASoC: imx-audmux: Fix ssi port numbers in sysfs
      ASoC: ak4642: fixup: mute needs +1 step
      MAINTAINERS: Don't list everyone working on Wolfson drivers
      MAINTAINERS: Add missing ASoC OMAP co-maintainer
      ASoC: pxa: pxa2xx-i2s: add io.h for IOMEM macro
      ASoC: tegra: ensure clocks are enabled when touching registers
      ASoC: sgtl5000: Enable VAG when DAC/ADC up
      ALSA: asihpi - fix return value of hpios_locked_mem_alloc()

commit 1eecb8280b038019f2f914abc01b28caf5d0a168
Merge: c2f6702d318e 0034102808e0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Apr 9 11:53:45 2012 +0100

    Merge tag 'v3.4-rc2' into for-3.5
    
    Linux 3.4-rc2 contains some bug fixes we need, including the addition of
    an export for regcache_sync_region().

commit 234e340582901211f40d8c732afc49f0630ecf05
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Apr 5 14:25:11 2012 -0700

    simple_open: automatically convert to simple_open()
    
    Many users of debugfs copy the implementation of default_open() when
    they want to support a custom read/write function op.  This leads to a
    proliferation of the default_open() implementation across the entire
    tree.
    
    Now that the common implementation has been consolidated into libfs we
    can replace all the users of this function with simple_open().
    
    This replacement was done with the following semantic patch:
    
    <smpl>
    @ open @
    identifier open_f != simple_open;
    identifier i, f;
    @@
    -int open_f(struct inode *i, struct file *f)
    -{
    (
    -if (i->i_private)
    -f->private_data = i->i_private;
    |
    -f->private_data = i->i_private;
    )
    -return 0;
    -}
    
    @ has_open depends on open @
    identifier fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...
    -.open = open_f,
    +.open = simple_open,
    ...
    };
    </smpl>
    
    [akpm@linux-foundation.org: checkpatch fixes]
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a4deebc0801a..e19c24ade414 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -201,12 +201,6 @@ static ssize_t pmdown_time_set(struct device *dev,
 static DEVICE_ATTR(pmdown_time, 0644, pmdown_time_show, pmdown_time_set);
 
 #ifdef CONFIG_DEBUG_FS
-static int codec_reg_open_file(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
 static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
 				   size_t count, loff_t *ppos)
 {
@@ -264,7 +258,7 @@ static ssize_t codec_reg_write_file(struct file *file,
 }
 
 static const struct file_operations codec_reg_fops = {
-	.open = codec_reg_open_file,
+	.open = simple_open,
 	.read = codec_reg_read_file,
 	.write = codec_reg_write_file,
 	.llseek = default_llseek,

commit 3fec6b6d5a53d37194735268b9e220f75ca37f19
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Apr 5 12:28:01 2012 -0600

    ASoC: set idle_bias_off=1 for all platform DAPM contexts
    
    The ASoC core currently defaults to using STANDBY rather than OFF for
    idle ASoC platform devices, which causes a permanent pm_runtime_get() on
    them. This keeps the device active unnecessarily. This can be especially
    problematic when the ASoC platform device and DAI device are the same
    device.
    
    The distinction between OFF and STANDBY is likely not relevant for ASoC
    platform drivers, since they aren't analog devices. So, solve this issue
    by hard-coding idle_bias_off = 1 for all ASoC platform devices. If this
    turns out to be a problem, this value could be sourced from the
    snd_soc_platform_driver, similarly to soc_probe_codec().
    
    Note: Prior to this change, this caused a large (10) runtime_active count
    for the Tegra I2S controller even when not in use, and a leak in that
    value as streams were started and stopped. This change probably hides a
    bug.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a4deebc0801a..8d2ebf502df4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1087,6 +1087,8 @@ static int soc_probe_platform(struct snd_soc_card *card,
 		snd_soc_dapm_new_controls(&platform->dapm,
 			driver->dapm_widgets, driver->num_dapm_widgets);
 
+	platform->dapm.idle_bias_off = 1;
+
 	if (driver->probe) {
 		ret = driver->probe(platform);
 		if (ret < 0) {

commit 27f1d75921e7273e484cc2fab132d9fcbe9f845d
Author: Brian Austin <brian.austin@cirrus.com>
Date:   Tue Apr 3 11:33:50 2012 -0500

    ASoC: core: Initialize err for snd_soc_put_volsw_sx
    
    sound/soc/soc-core.c: In function ‘snd_soc_put_volsw_sx’:
    sound/soc/soc-core.c:2600: warning: ‘err’ may be used uninitialized in this function
    
    Signed-off-by: Brian Austin <brian.austin@cirrus.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7b1a4fd932d7..a6922bc96184 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2586,7 +2586,7 @@ int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
 	int max = mc->max;
 	int min = mc->min;
 	int mask = (1 << (fls(min + max) - 1)) - 1;
-	int err;
+	int err = 0;
 	unsigned short val, val_mask, val2 = 0;
 
 	val_mask = mask << shift;

commit 1d99f2436d0d1c7741d6dfd9d27b5376cdbbca40
Author: Brian Austin <brian.austin@cirrus.com>
Date:   Fri Mar 30 10:43:55 2012 -0500

    ASoC: core: Rework SOC_DOUBLE_R_SX_TLV add SOC_SINGLE_SX_TLV
    
    Some codecs namely Cirrus Logic Codecs have a way of wrapping the dB scale around 0dB without 0dB being in the middle.
    
    Rework of SOC_DOUBLE_R_SX_TLV to be more consistent with other asoc tlv macros.
    Add single register macro : SOC_SINGLE_SX_TLV.
    Use snd_soc_info_volsw for .info
    Use snd_soc_get_volsw_sx, snd_soc_put_volsw_sx for single and double.
    
    kcontrols for CS42L51 and CS42L73 are adjusted to these new TLV Macros.
    
    The max value is determined by: (number of steps) +1 for 0dB +max from codec datasheet.
    
    Signed-off-by: Brian Austin <brian.austin@cirrus.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cab72f87c194..7b1a4fd932d7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2527,6 +2527,87 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 
+/**
+ * snd_soc_get_volsw_sx - single mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,
+		      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+	    (struct soc_mixer_control *)kcontrol->private_value;
+
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	int mask = (1 << (fls(min + max) - 1)) - 1;
+
+	ucontrol->value.integer.value[0] =
+	    ((snd_soc_read(codec, reg) >> shift) - min) & mask;
+
+	if (snd_soc_volsw_is_stereo(mc))
+		ucontrol->value.integer.value[1] =
+			((snd_soc_read(codec, reg2) >> rshift) - min) & mask;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_sx);
+
+/**
+ * snd_soc_put_volsw_sx - double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+	    (struct soc_mixer_control *)kcontrol->private_value;
+
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	int mask = (1 << (fls(min + max) - 1)) - 1;
+	int err;
+	unsigned short val, val_mask, val2 = 0;
+
+	val_mask = mask << shift;
+	val = (ucontrol->value.integer.value[0] + min) & mask;
+	val = val << shift;
+
+	if (snd_soc_update_bits_locked(codec, reg, val_mask, val))
+			return err;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		val_mask = mask << rshift;
+		val2 = (ucontrol->value.integer.value[1] + min) & mask;
+		val2 = val2 << rshift;
+
+		if (snd_soc_update_bits_locked(codec, reg2, val_mask, val2))
+			return err;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_sx);
+
 /**
  * snd_soc_info_volsw_s8 - signed mixer info callback
  * @kcontrol: mixer control
@@ -2648,99 +2729,6 @@ int snd_soc_limit_volume(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_limit_volume);
 
-/**
- * snd_soc_info_volsw_2r_sx - double with tlv and variable data size
- *  mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Returns 0 for success.
- */
-int snd_soc_info_volsw_2r_sx(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int max = mc->max;
-	int min = mc->min;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = max-min;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r_sx);
-
-/**
- * snd_soc_get_volsw_2r_sx - double with tlv and variable data size
- *  mixer get callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Returns 0 for success.
- */
-int snd_soc_get_volsw_2r_sx(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int mask = (1<<mc->shift)-1;
-	int min = mc->min;
-	int val = snd_soc_read(codec, mc->reg) & mask;
-	int valr = snd_soc_read(codec, mc->rreg) & mask;
-
-	ucontrol->value.integer.value[0] = ((val & 0xff)-min) & mask;
-	ucontrol->value.integer.value[1] = ((valr & 0xff)-min) & mask;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r_sx);
-
-/**
- * snd_soc_put_volsw_2r_sx - double with tlv and variable data size
- *  mixer put callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Returns 0 for success.
- */
-int snd_soc_put_volsw_2r_sx(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int mask = (1<<mc->shift)-1;
-	int min = mc->min;
-	int ret;
-	unsigned int val, valr, oval, ovalr;
-
-	val = ((ucontrol->value.integer.value[0]+min) & 0xff);
-	val &= mask;
-	valr = ((ucontrol->value.integer.value[1]+min) & 0xff);
-	valr &= mask;
-
-	oval = snd_soc_read(codec, mc->reg) & mask;
-	ovalr = snd_soc_read(codec, mc->rreg) & mask;
-
-	ret = 0;
-	if (oval != val) {
-		ret = snd_soc_write(codec, mc->reg, val);
-		if (ret < 0)
-			return ret;
-	}
-	if (ovalr != valr) {
-		ret = snd_soc_write(codec, mc->rreg, valr);
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r_sx);
-
 int snd_soc_bytes_info(struct snd_kcontrol *kcontrol,
 		       struct snd_ctl_elem_info *uinfo)
 {

commit b19e6e7b763c7144bfe2ceccf988b64d66d6dd0a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 14 21:18:39 2012 +0000

    ASoC: core: Use driver core probe deferral
    
    In version 3.4 the driver core acquired probe deferral which is a core way
    of doing essentially the same thing as ASoC has been doing since forever
    to make sure that all the devices needed to make up the card are present
    without needing open coding in the subsystem.
    
    Make basic use of this probe deferral mechanism for the cards, removing the
    need to handle partially instantiated cards. We should be able to remove
    even more code than this, though some of the checks we're currently doing
    should stay since they're about things like suppressing unneeded DAPM runs
    rather than deferring probes.
    
    In order to avoid robustness issues with our teardown paths (which do need
    quite a bit of TLC) add a check for aux_devs prior to attempting to set
    things up, this means that we've got a reasonable idea that everything will
    be there before we start. As with the removal of partial instantiation
    support more work will be needed to make this work neatly.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 61b51b673d49..cab72f87c194 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -54,7 +54,6 @@ EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);
 #endif
 
 static DEFINE_MUTEX(client_mutex);
-static LIST_HEAD(card_list);
 static LIST_HEAD(dai_list);
 static LIST_HEAD(platform_list);
 static LIST_HEAD(codec_list);
@@ -785,15 +784,9 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	struct snd_soc_dai *codec_dai, *cpu_dai;
 	const char *platform_name;
 
-	if (rtd->complete)
-		return 1;
 	dev_dbg(card->dev, "binding %s at idx %d\n", dai_link->name, num);
 
-	/* do we already have the CPU DAI for this link ? */
-	if (rtd->cpu_dai) {
-		goto find_codec;
-	}
-	/* no, then find CPU DAI from registered DAIs*/
+	/* Find CPU DAI from registered DAIs*/
 	list_for_each_entry(cpu_dai, &dai_list, list) {
 		if (dai_link->cpu_dai_of_node) {
 			if (cpu_dai->dev->of_node != dai_link->cpu_dai_of_node)
@@ -804,18 +797,15 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		}
 
 		rtd->cpu_dai = cpu_dai;
-		goto find_codec;
 	}
-	dev_dbg(card->dev, "CPU DAI %s not registered\n",
-			dai_link->cpu_dai_name);
 
-find_codec:
-	/* do we already have the CODEC for this link ? */
-	if (rtd->codec) {
-		goto find_platform;
+	if (!rtd->cpu_dai) {
+		dev_dbg(card->dev, "CPU DAI %s not registered\n",
+			dai_link->cpu_dai_name);
+		return -EPROBE_DEFER;
 	}
 
-	/* no, then find CODEC from registered CODECs*/
+	/* Find CODEC from registered CODECs */
 	list_for_each_entry(codec, &codec_list, list) {
 		if (dai_link->codec_of_node) {
 			if (codec->dev->of_node != dai_link->codec_of_node)
@@ -837,28 +827,28 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 					dai_link->codec_dai_name)) {
 
 				rtd->codec_dai = codec_dai;
-				goto find_platform;
 			}
 		}
-		dev_dbg(card->dev, "CODEC DAI %s not registered\n",
-				dai_link->codec_dai_name);
 
-		goto find_platform;
+		if (!rtd->codec_dai) {
+			dev_dbg(card->dev, "CODEC DAI %s not registered\n",
+				dai_link->codec_dai_name);
+			return -EPROBE_DEFER;
+		}
 	}
-	dev_dbg(card->dev, "CODEC %s not registered\n",
-			dai_link->codec_name);
 
-find_platform:
-	/* do we need a platform? */
-	if (rtd->platform)
-		goto out;
+	if (!rtd->codec) {
+		dev_dbg(card->dev, "CODEC %s not registered\n",
+			dai_link->codec_name);
+		return -EPROBE_DEFER;
+	}
 
 	/* if there's no platform we match on the empty platform */
 	platform_name = dai_link->platform_name;
 	if (!platform_name && !dai_link->platform_of_node)
 		platform_name = "snd-soc-dummy";
 
-	/* no, then find one from the set of registered platforms */
+	/* find one from the set of registered platforms */
 	list_for_each_entry(platform, &platform_list, list) {
 		if (dai_link->platform_of_node) {
 			if (platform->dev->of_node !=
@@ -870,20 +860,16 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		}
 
 		rtd->platform = platform;
-		goto out;
 	}
-
-	dev_dbg(card->dev, "platform %s not registered\n",
+	if (!rtd->platform) {
+		dev_dbg(card->dev, "platform %s not registered\n",
 			dai_link->platform_name);
-	return 0;
-
-out:
-	/* mark rtd as complete if we found all 4 of our client devices */
-	if (rtd->codec && rtd->codec_dai && rtd->platform && rtd->cpu_dai) {
-		rtd->complete = 1;
-		card->num_rtd++;
+		return -EPROBE_DEFER;
 	}
-	return 1;
+
+	card->num_rtd++;
+
+	return 0;
 }
 
 static void soc_remove_codec(struct snd_soc_codec *codec)
@@ -1346,6 +1332,20 @@ static void soc_unregister_ac97_dai_link(struct snd_soc_codec *codec)
 }
 #endif
 
+static int soc_check_aux_dev(struct snd_soc_card *card, int num)
+{
+	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
+	struct snd_soc_codec *codec;
+
+	/* find CODEC from registered CODECs*/
+	list_for_each_entry(codec, &codec_list, list) {
+		if (!strcmp(codec->name, aux_dev->codec_name))
+			return 0;
+	}
+
+	return -EPROBE_DEFER;
+}
+
 static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
@@ -1366,7 +1366,7 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	}
 	/* codec not found */
 	dev_err(card->dev, "asoc: codec %s not found", aux_dev->codec_name);
-	goto out;
+	return -EPROBE_DEFER;
 
 found:
 	ret = soc_probe_codec(card, codec);
@@ -1416,7 +1416,7 @@ static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,
 	return 0;
 }
 
-static void snd_soc_instantiate_card(struct snd_soc_card *card)
+static int snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct snd_soc_codec *codec;
 	struct snd_soc_codec_conf *codec_conf;
@@ -1426,19 +1426,18 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
-	if (card->instantiated) {
-		mutex_unlock(&card->mutex);
-		return;
-	}
-
 	/* bind DAIs */
-	for (i = 0; i < card->num_links; i++)
-		soc_bind_dai_link(card, i);
+	for (i = 0; i < card->num_links; i++) {
+		ret = soc_bind_dai_link(card, i);
+		if (ret != 0)
+			goto base_error;
+	}
 
-	/* bind completed ? */
-	if (card->num_rtd != card->num_links) {
-		mutex_unlock(&card->mutex);
-		return;
+	/* check aux_devs too */
+	for (i = 0; i < card->num_aux_devs; i++) {
+		ret = soc_check_aux_dev(card, i);
+		if (ret != 0)
+			goto base_error;
 	}
 
 	/* initialize the register cache for each available codec */
@@ -1458,10 +1457,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 			}
 		}
 		ret = snd_soc_init_codec_cache(codec, compress_type);
-		if (ret < 0) {
-			mutex_unlock(&card->mutex);
-			return;
-		}
+		if (ret < 0)
+			goto base_error;
 	}
 
 	/* card bind complete so register a sound card */
@@ -1470,8 +1467,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	if (ret < 0) {
 		pr_err("asoc: can't create sound card for card %s: %d\n",
 			card->name, ret);
-		mutex_unlock(&card->mutex);
-		return;
+		goto base_error;
 	}
 	card->snd_card->dev = card->dev;
 
@@ -1611,7 +1607,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	card->instantiated = 1;
 	snd_soc_dapm_sync(&card->dapm);
 	mutex_unlock(&card->mutex);
-	return;
+
+	return 0;
 
 probe_aux_dev_err:
 	for (i = 0; i < card->num_aux_devs; i++)
@@ -1626,18 +1623,10 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	snd_card_free(card->snd_card);
 
+base_error:
 	mutex_unlock(&card->mutex);
-}
 
-/*
- * Attempt to initialise any uninitialised cards.  Must be called with
- * client_mutex.
- */
-static void snd_soc_instantiate_cards(void)
-{
-	struct snd_soc_card *card;
-	list_for_each_entry(card, &card_list, list)
-		snd_soc_instantiate_card(card);
+	return ret;
 }
 
 /* probes a new socdev */
@@ -3072,7 +3061,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
  */
 int snd_soc_register_card(struct snd_soc_card *card)
 {
-	int i;
+	int i, ret;
 
 	if (!card->name || !card->dev)
 		return -EINVAL;
@@ -3136,14 +3125,11 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	mutex_init(&card->mutex);
 	mutex_init(&card->dapm_mutex);
 
-	mutex_lock(&client_mutex);
-	list_add(&card->list, &card_list);
-	snd_soc_instantiate_cards();
-	mutex_unlock(&client_mutex);
+	ret = snd_soc_instantiate_card(card);
+	if (ret != 0)
+		soc_cleanup_card_debugfs(card);
 
-	dev_dbg(card->dev, "Registered card '%s'\n", card->name);
-
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_card);
 
@@ -3157,9 +3143,6 @@ int snd_soc_unregister_card(struct snd_soc_card *card)
 {
 	if (card->instantiated)
 		soc_cleanup_card_resources(card);
-	mutex_lock(&client_mutex);
-	list_del(&card->list);
-	mutex_unlock(&client_mutex);
 	dev_dbg(card->dev, "Unregistered card '%s'\n", card->name);
 
 	return 0;
@@ -3256,7 +3239,6 @@ int snd_soc_register_dai(struct device *dev,
 
 	mutex_lock(&client_mutex);
 	list_add(&dai->list, &dai_list);
-	snd_soc_instantiate_cards();
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Registered DAI '%s'\n", dai->name);
@@ -3338,9 +3320,6 @@ int snd_soc_register_dais(struct device *dev,
 		pr_debug("Registered DAI '%s'\n", dai->name);
 	}
 
-	mutex_lock(&client_mutex);
-	snd_soc_instantiate_cards();
-	mutex_unlock(&client_mutex);
 	return 0;
 
 err:
@@ -3398,7 +3377,6 @@ int snd_soc_register_platform(struct device *dev,
 
 	mutex_lock(&client_mutex);
 	list_add(&platform->list, &platform_list);
-	snd_soc_instantiate_cards();
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Registered platform '%s'\n", platform->name);
@@ -3557,7 +3535,6 @@ int snd_soc_register_codec(struct device *dev,
 
 	mutex_lock(&client_mutex);
 	list_add(&codec->list, &codec_list);
-	snd_soc_instantiate_cards();
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Registered codec '%s'\n", codec->name);

commit d9b0951b96e4ee0d22fae0a30f0b53354ca541cd
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Mar 7 16:32:59 2012 +0000

    ASoC: dapm: Add platform stream event support
    
    Currently stream events are only perfomed on codec stream widgets only.
    There is now a need to be able to perform stream events on platform
    widgets too.
    
    e.g. we have the ABE platform driver with several DAI links
    to dummy codecs. We need to be able to perform stream events on any
    of the dummy codec DAI links.
    
    This patch also removes the snd_soc_dai * parameter since it's already
    contained within the rtd * parameter.
    
    Finally makle stream event return void since no one checks it anyway.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 42ce14485b92..61b51b673d49 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -573,19 +573,16 @@ int snd_soc_suspend(struct device *dev)
 	}
 
 	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
 		snd_soc_dapm_stream_event(&card->rtd[i],
 					  SNDRV_PCM_STREAM_PLAYBACK,
-					  codec_dai,
 					  SND_SOC_DAPM_STREAM_SUSPEND);
 
 		snd_soc_dapm_stream_event(&card->rtd[i],
 					  SNDRV_PCM_STREAM_CAPTURE,
-					  codec_dai,
 					  SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
@@ -689,17 +686,16 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
 		snd_soc_dapm_stream_event(&card->rtd[i],
-					  SNDRV_PCM_STREAM_PLAYBACK, codec_dai,
+					  SNDRV_PCM_STREAM_PLAYBACK,
 					  SND_SOC_DAPM_STREAM_RESUME);
 
 		snd_soc_dapm_stream_event(&card->rtd[i],
-					  SNDRV_PCM_STREAM_CAPTURE, codec_dai,
+					  SNDRV_PCM_STREAM_CAPTURE,
 					  SND_SOC_DAPM_STREAM_RESUME);
 	}
 

commit be09ad90e17b79fdb0d513a31e814ff4d42e3dff
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Mar 7 11:47:41 2012 +0000

    ASoC: core: Add platform DAI widget mapping
    
    Add platform driver support for CPU DAI DAPM widgets.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4a145cb43018..42ce14485b92 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1074,6 +1074,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 {
 	int ret = 0;
 	const struct snd_soc_platform_driver *driver = platform->driver;
+	struct snd_soc_dai *dai;
 
 	platform->card = card;
 	platform->dapm.card = card;
@@ -1087,6 +1088,14 @@ static int soc_probe_platform(struct snd_soc_card *card,
 		snd_soc_dapm_new_controls(&platform->dapm,
 			driver->dapm_widgets, driver->num_dapm_widgets);
 
+	/* Create DAPM widgets for each DAI stream */
+	list_for_each_entry(dai, &dai_list, list) {
+		if (dai->dev != platform->dev)
+			continue;
+
+		snd_soc_dapm_new_dai_widgets(&platform->dapm, dai);
+	}
+
 	if (driver->probe) {
 		ret = driver->probe(platform);
 		if (ret < 0) {
@@ -1222,9 +1231,12 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 	/* probe the cpu_dai */
 	if (!cpu_dai->probed &&
 			cpu_dai->driver->probe_order == order) {
+		cpu_dai->dapm.card = card;
 		if (!try_module_get(cpu_dai->dev->driver->owner))
 			return -ENODEV;
 
+		snd_soc_dapm_new_dai_widgets(&cpu_dai->dapm, cpu_dai);
+
 		if (cpu_dai->driver->probe) {
 			ret = cpu_dai->driver->probe(cpu_dai);
 			if (ret < 0) {
@@ -3242,6 +3254,7 @@ int snd_soc_register_dai(struct device *dev,
 
 	dai->dev = dev;
 	dai->driver = dai_drv;
+	dai->dapm.dev = dev;
 	if (!dai->driver->ops)
 		dai->driver->ops = &null_dai_ops;
 
@@ -3318,6 +3331,7 @@ int snd_soc_register_dais(struct device *dev,
 			dai->id = dai->driver->id;
 		else
 			dai->id = i;
+		dai->dapm.dev = dev;
 		if (!dai->driver->ops)
 			dai->driver->ops = &null_dai_ops;
 

commit a73fb2df01866b772a48fab93401fe3edbe0b38d
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Mar 7 10:38:26 2012 +0000

    ASoC: dapm: Use DAPM mutex for DAPM ops instead of codec mutex
    
    It has now become necessary to use a DAPM mutex instead of the codec
    mutex to lock the DAPM operations. This is due to the recent multi
    component support and forth coming Dynamic PCM updates.
    
    Currently we lock DAPM operations with the codec mutex of the calling
    RTD context. However, DAPM operations can span the whole card context
    and all components.
    
    This patch updates the DAPM operations that use the codec mutex to
    now use the DAPM mutex PCM subclass for all DAPM ops.
    
    We also add a mutex subclass for DAPM init and PCM operations.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a6da20a72d43..4a145cb43018 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3126,6 +3126,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	INIT_LIST_HEAD(&card->dapm_dirty);
 	card->instantiated = 0;
 	mutex_init(&card->mutex);
+	mutex_init(&card->dapm_mutex);
 
 	mutex_lock(&client_mutex);
 	list_add(&card->list, &card_list);

commit 01b9d99a1f45befa604543ead29f44fdb0878844
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Mar 7 10:38:25 2012 +0000

    ASoC: core: Add card mutex locking subclasses
    
    This is the first part of a change that is intended to improve
    ASoC locking protection for DAPM and PCM operations.
    
    This part of the series adds a mutex class for the soc_card mutex. The
    SND_SOC_CARD_CLASS_INIT class is used for card initialisation only whilst the
    SND_SOC_CARD_CLASS_PCM class is used for the forth coming Dynamic
    PCM operations. The new mutex classes are required otherwise we will see a false
    positive mutex deadlock warning between the card initialisation and the PCM
    operations (something that would never deadlock in real life).
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a4deebc0801a..a6da20a72d43 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1416,7 +1416,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	struct snd_soc_dai_link *dai_link;
 	int ret, i, order;
 
-	mutex_lock(&card->mutex);
+	mutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_INIT);
 
 	if (card->instantiated) {
 		mutex_unlock(&card->mutex);

commit 181a68927b9e6ff7c0ea093c2f056eeb0552a911
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 14 20:18:49 2012 +0000

    ASoC: core: Fix obscure leak of runtime array
    
    We're currently not freeing card->rtd in cases where the card is
    unregistered before being instantiated - convert it to devm_kzalloc() to
    make sure that happens.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 93a0daac5088..a4deebc0801a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1686,7 +1686,6 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 
 	snd_soc_dapm_free(&card->dapm);
 
-	kfree(card->rtd);
 	snd_card_free(card->snd_card);
 	return 0;
 
@@ -3112,9 +3111,10 @@ int snd_soc_register_card(struct snd_soc_card *card)
 
 	soc_init_card_debugfs(card);
 
-	card->rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime) *
-			    (card->num_links + card->num_aux_devs),
-			    GFP_KERNEL);
+	card->rtd = devm_kzalloc(card->dev,
+				 sizeof(struct snd_soc_pcm_runtime) *
+				 (card->num_links + card->num_aux_devs),
+				 GFP_KERNEL);
 	if (card->rtd == NULL)
 		return -ENOMEM;
 	card->rtd_aux = &card->rtd[card->num_links];

commit 5e4ba569a5aa631852ec8240f11142392116633d
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Fri Mar 9 00:59:40 2012 +0800

    ASoC: core: missing set_fmt should not be complaint
    
    Not having a DAI link set_fmt operation is perfectly normal and
    should not be complaint.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c90bb0110bd2..93a0daac5088 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1531,14 +1531,14 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		if (dai_link->dai_fmt) {
 			ret = snd_soc_dai_set_fmt(card->rtd[i].codec_dai,
 						  dai_link->dai_fmt);
-			if (ret != 0)
+			if (ret != 0 && ret != -ENOTSUPP)
 				dev_warn(card->rtd[i].codec_dai->dev,
 					 "Failed to set DAI format: %d\n",
 					 ret);
 
 			ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai,
 						  dai_link->dai_fmt);
-			if (ret != 0)
+			if (ret != 0 && ret != -ENOTSUPP)
 				dev_warn(card->rtd[i].cpu_dai->dev,
 					 "Failed to set DAI format: %d\n",
 					 ret);
@@ -2971,10 +2971,11 @@ EXPORT_SYMBOL_GPL(snd_soc_codec_set_pll);
  */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	if (dai->driver && dai->driver->ops->set_fmt)
-		return dai->driver->ops->set_fmt(dai, fmt);
-	else
+	if (dai->driver == NULL)
 		return -EINVAL;
+	if (dai->driver->ops->set_fmt == NULL)
+		return -ENOTSUPP;
+	return dai->driver->ops->set_fmt(dai, fmt);
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 

commit cc22d37e7f5e1745658760660f03793913f43e49
Author: Liam Girdwood <lrg@ti.com>
Date:   Tue Mar 6 18:16:18 2012 +0000

    ASoC: core: Add platform component mutex
    
    Add mutex support for platform IO operations. e.g. can be used
    for platform DAPM widget IO ops.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7978f6c01ef7..c90bb0110bd2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3382,6 +3382,7 @@ int snd_soc_register_platform(struct device *dev,
 	platform->dapm.dev = dev;
 	platform->dapm.platform = platform;
 	platform->dapm.stream_event = platform_drv->stream_event;
+	mutex_init(&platform->mutex);
 
 	mutex_lock(&client_mutex);
 	list_add(&platform->list, &platform_list);

commit fe4085e84f17a57a533a210a626e0cc9ead381f9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Mar 2 13:07:41 2012 +0000

    ASoC: core: Log a warning when machines use soc-audio
    
    snd_soc_register_card() has been available and strongly preferred since
    2.6.38 but we're still seeing new drivers using it and the conversion rate
    for older machines has been low. Help address both issues by logging a
    warning when the soc-audio device probes.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 29dbbd793fc6..7978f6c01ef7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1645,6 +1645,10 @@ static int soc_probe(struct platform_device *pdev)
 	if (!card)
 		return -EINVAL;
 
+	dev_warn(&pdev->dev,
+		 "ASoC machine %s should use snd_soc_register_card()\n",
+		 card->name);
+
 	/* Bodge while we unpick instantiation */
 	card->dev = &pdev->dev;
 

commit 02db110351019eef2d6b10e08162dd370542e9fd
Author: Liam Girdwood <lrg@ti.com>
Date:   Fri Mar 2 16:13:44 2012 +0000

    ASoC: core: cleanup platform debugfs on probe failure.
    
    Make sure we cleanup the platform debugfs when probe fails.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1bdc67e0bd16..29dbbd793fc6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1112,6 +1112,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	return 0;
 
 err_probe:
+	soc_cleanup_platform_debugfs(platform);
 	module_put(platform->dev->driver->owner);
 
 	return ret;

commit b1dd5897f53647390a7622795541bc89f8a84fe2
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Fri Feb 24 16:25:49 2012 +0530

    ASoC: core: Don't overwrite .poweroff in snd_soc_pm_ops
    
    SET_SYSTEM_SLEEP_PM_OPS writes .poweroff = *_resume once. Then we overwrite it
    again explicitly as .poweroff = snd_soc_poweroff. Even though it works, as the
    second one overwrites the first one, this is not the correct way. Fix this by
    expanding SET_SYSTEM_SLEEP_PM_OPS in our structure.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fc0fd3485e7d..1bdc67e0bd16 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1718,8 +1718,12 @@ int snd_soc_poweroff(struct device *dev)
 EXPORT_SYMBOL_GPL(snd_soc_poweroff);
 
 const struct dev_pm_ops snd_soc_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(snd_soc_suspend, snd_soc_resume)
+	.suspend = snd_soc_suspend,
+	.resume = snd_soc_resume,
+	.freeze = snd_soc_suspend,
+	.thaw = snd_soc_resume,
 	.poweroff = snd_soc_poweroff,
+	.restore = snd_soc_resume,
 };
 EXPORT_SYMBOL_GPL(snd_soc_pm_ops);
 

commit f831b055ececb3172f7fe498db5ca1fb43ff644d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Feb 17 16:20:33 2012 -0800

    ASoC: core: Add support for masking out parts of coefficient blocks
    
    Chip designers frequently include things like the enable and disable
    controls for algorithms in the register blocks which also hold the
    coefficients. Since it's desirable to split out the enable/disable
    control from userspace the plain SND_SOC_BYTES() isn't optimal for
    these devices.
    
    Add a SND_SOC_BYTES_MASK() which allows a bitmask from the first word
    of the block to be excluded from the control. This supports the needs
    of devices I've looked at and lets us have a reasonably simple API.
    Further controls can be added in future if that's needed.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a9786ab70504..fc0fd3485e7d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2763,6 +2763,25 @@ int snd_soc_bytes_get(struct snd_kcontrol *kcontrol,
 	else
 		ret = -EINVAL;
 
+	/* Hide any masked bytes to ensure consistent data reporting */
+	if (ret == 0 && params->mask) {
+		switch (codec->val_bytes) {
+		case 1:
+			ucontrol->value.bytes.data[0] &= ~params->mask;
+			break;
+		case 2:
+			((u16 *)(&ucontrol->value.bytes.data))[0]
+				&= ~params->mask;
+			break;
+		case 4:
+			((u32 *)(&ucontrol->value.bytes.data))[0]
+				&= ~params->mask;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_bytes_get);
@@ -2772,14 +2791,55 @@ int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
 {
 	struct soc_bytes *params = (void *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int ret;
+	int ret, len;
+	unsigned int val;
+	void *data;
 
-	if (codec->using_regmap)
-		ret = regmap_raw_write(codec->control_data, params->base,
-				       ucontrol->value.bytes.data,
-				       params->num_regs * codec->val_bytes);
-	else
-		ret = -EINVAL;
+	if (!codec->using_regmap)
+		return -EINVAL;
+
+	data = ucontrol->value.bytes.data;
+	len = params->num_regs * codec->val_bytes;
+
+	/*
+	 * If we've got a mask then we need to preserve the register
+	 * bits.  We shouldn't modify the incoming data so take a
+	 * copy.
+	 */
+	if (params->mask) {
+		ret = regmap_read(codec->control_data, params->base, &val);
+		if (ret != 0)
+			return ret;
+
+		val &= params->mask;
+
+		data = kmemdup(data, len, GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+
+		switch (codec->val_bytes) {
+		case 1:
+			((u8 *)data)[0] &= ~params->mask;
+			((u8 *)data)[0] |= val;
+			break;
+		case 2:
+			((u16 *)data)[0] &= cpu_to_be16(~params->mask);
+			((u16 *)data)[0] |= cpu_to_be16(val);
+			break;
+		case 4:
+			((u32 *)data)[0] &= cpu_to_be32(~params->mask);
+			((u32 *)data)[0] |= cpu_to_be32(val);
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	ret = regmap_raw_write(codec->control_data, params->base,
+			       data, len);
+
+	if (params->mask)
+		kfree(data);
 
 	return ret;
 }

commit 71d08516b80638a69d5efea4e8cb832c053f9dd9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Oct 10 18:31:26 2011 +0100

    ASoC: core: Add SND_SOC_BYTES control for coefficient blocks
    
    Allow devices to export blocks of registers to the application layer,
    intended for use for reading and writing coefficient data which can't
    usefully be worked with by the kernel at runtime (for example, due to
    requiring complex and expensive calculations or being the results of
    callibration procedures). Currently drivers are using platform data to
    provide configurations for coefficient blocks which isn't at all
    convenient for runtime management or configuration development.
    
    Currently only devices using regmap are supported, an error will be
    generated for any attempt to work with a byte control on a non-regmap
    device. There's no fundamental block to other devices so support could
    be added if required.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3ca70594e242..a9786ab70504 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2736,6 +2736,55 @@ int snd_soc_put_volsw_2r_sx(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r_sx);
 
+int snd_soc_bytes_info(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_bytes *params = (void *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = params->num_regs * codec->val_bytes;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_bytes_info);
+
+int snd_soc_bytes_get(struct snd_kcontrol *kcontrol,
+		      struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_bytes *params = (void *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int ret;
+
+	if (codec->using_regmap)
+		ret = regmap_raw_read(codec->control_data, params->base,
+				      ucontrol->value.bytes.data,
+				      params->num_regs * codec->val_bytes);
+	else
+		ret = -EINVAL;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_bytes_get);
+
+int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
+		      struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_bytes *params = (void *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int ret;
+
+	if (codec->using_regmap)
+		ret = regmap_raw_write(codec->control_data, params->base,
+				       ucontrol->value.bytes.data,
+				       params->num_regs * codec->val_bytes);
+	else
+		ret = -EINVAL;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_bytes_put);
+
 /**
  * snd_soc_dai_set_sysclk - configure DAI system or master clock.
  * @dai: DAI

commit 0837fc624391378ea25c9f811c90d49b8808ba1a
Author: Fabio Estevam <festevam@gmail.com>
Date:   Fri Feb 17 19:40:38 2012 -0200

    ASoC: soc-core: Show the returned values on error messages
    
    Showing the returned values on error messages is useful information.
    
    While at it, use pr_err/pr_warn whenever possible.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 32ca75e20024..3ca70594e242 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -933,7 +933,8 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 		if (codec_dai->driver->remove) {
 			err = codec_dai->driver->remove(codec_dai);
 			if (err < 0)
-				printk(KERN_ERR "asoc: failed to remove %s\n", codec_dai->name);
+				pr_err("asoc: failed to remove %s: %d\n",
+							codec_dai->name, err);
 		}
 		codec_dai->probed = 0;
 		list_del(&codec_dai->card_list);
@@ -945,7 +946,8 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 		if (platform->driver->remove) {
 			err = platform->driver->remove(platform);
 			if (err < 0)
-				printk(KERN_ERR "asoc: failed to remove %s\n", platform->name);
+				pr_err("asoc: failed to remove %s: %d\n",
+							platform->name, err);
 		}
 
 		/* Make sure all DAPM widgets are freed */
@@ -968,7 +970,8 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 		if (cpu_dai->driver->remove) {
 			err = cpu_dai->driver->remove(cpu_dai);
 			if (err < 0)
-				printk(KERN_ERR "asoc: failed to remove %s\n", cpu_dai->name);
+				pr_err("asoc: failed to remove %s: %d\n",
+							cpu_dai->name, err);
 		}
 		cpu_dai->probed = 0;
 		list_del(&cpu_dai->card_list);
@@ -1224,8 +1227,8 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 		if (cpu_dai->driver->probe) {
 			ret = cpu_dai->driver->probe(cpu_dai);
 			if (ret < 0) {
-				printk(KERN_ERR "asoc: failed to probe CPU DAI %s\n",
-						cpu_dai->name);
+				pr_err("asoc: failed to probe CPU DAI %s: %d\n",
+							cpu_dai->name, ret);
 				module_put(cpu_dai->dev->driver->owner);
 				return ret;
 			}
@@ -1256,8 +1259,8 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 		if (codec_dai->driver->probe) {
 			ret = codec_dai->driver->probe(codec_dai);
 			if (ret < 0) {
-				printk(KERN_ERR "asoc: failed to probe CODEC DAI %s\n",
-						codec_dai->name);
+				pr_err("asoc: failed to probe CODEC DAI %s: %d\n",
+							codec_dai->name, ret);
 				return ret;
 			}
 		}
@@ -1277,12 +1280,13 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 
 	ret = device_create_file(rtd->dev, &dev_attr_pmdown_time);
 	if (ret < 0)
-		printk(KERN_WARNING "asoc: failed to add pmdown_time sysfs\n");
+		pr_warn("asoc: failed to add pmdown_time sysfs:%d\n", ret);
 
 	/* create the pcm */
 	ret = soc_new_pcm(rtd, num);
 	if (ret < 0) {
-		printk(KERN_ERR "asoc: can't create pcm %s\n", dai_link->stream_name);
+		pr_err("asoc: can't create pcm %s :%d\n",
+				dai_link->stream_name, ret);
 		return ret;
 	}
 
@@ -1315,7 +1319,7 @@ static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
 
 		ret = soc_ac97_dev_register(rtd->codec);
 		if (ret < 0) {
-			printk(KERN_ERR "asoc: AC97 device register failed\n");
+			pr_err("asoc: AC97 device register failed:%d\n", ret);
 			return ret;
 		}
 
@@ -1455,8 +1459,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
 			card->owner, 0, &card->snd_card);
 	if (ret < 0) {
-		printk(KERN_ERR "asoc: can't create sound card for card %s\n",
-			card->name);
+		pr_err("asoc: can't create sound card for card %s: %d\n",
+			card->name, ret);
 		mutex_unlock(&card->mutex);
 		return;
 	}
@@ -1576,7 +1580,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	ret = snd_card_register(card->snd_card);
 	if (ret < 0) {
-		printk(KERN_ERR "asoc: failed to register soundcard for %s\n", card->name);
+		pr_err("asoc: failed to register soundcard for %s: %d\n",
+							card->name, ret);
 		goto probe_aux_dev_err;
 	}
 
@@ -1585,7 +1590,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_rtd; i++) {
 		ret = soc_register_ac97_dai_link(&card->rtd[i]);
 		if (ret < 0) {
-			printk(KERN_ERR "asoc: failed to register AC97 %s\n", card->name);
+			pr_err("asoc: failed to register AC97 %s: %d\n",
+							card->name, ret);
 			while (--i >= 0)
 				soc_unregister_ac97_dai_link(card->rtd[i].codec);
 			goto probe_aux_dev_err;
@@ -3083,7 +3089,7 @@ static inline char *fmt_multiple_name(struct device *dev,
 		struct snd_soc_dai_driver *dai_drv)
 {
 	if (dai_drv->name == NULL) {
-		printk(KERN_ERR "asoc: error - multiple DAI %s registered with no name\n",
+		pr_err("asoc: error - multiple DAI %s registered with no name\n",
 				dev_name(dev));
 		return NULL;
 	}
@@ -3555,8 +3561,7 @@ static int __init snd_soc_init(void)
 #ifdef CONFIG_DEBUG_FS
 	snd_soc_debugfs_root = debugfs_create_dir("asoc", NULL);
 	if (IS_ERR(snd_soc_debugfs_root) || !snd_soc_debugfs_root) {
-		printk(KERN_WARNING
-		       "ASoC: Failed to create debugfs directory\n");
+		pr_warn("ASoC: Failed to create debugfs directory\n");
 		snd_soc_debugfs_root = NULL;
 	}
 

commit 888df395ebc5c88cde45478660197ca46665efe2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 16 19:37:51 2012 -0800

    ASoC: dapm: Implement and instantiate DAI widgets
    
    In order to allow us to do smarter things with DAI links create DAPM
    widgets which directly represent the DAIs in the DAPM graph. These are
    automatically created from the DAIs as we probe the card with references
    held in both directions between the widget and the DAI.
    
    The widgets are not made available for direct instantiation by drivers,
    they are created automatically from the DAIs.  Drivers should be updated
    to create stream routes using DAPM maps rather than by annotating AIF
    and DAC widgets with streams.
    
    In order to ease transition to this model from existing drivers we
    automatically create DAPM routes between the DAI widgets and the existing
    stream widgets which are started and stopped by the DAI widgets, though
    the old stream handling mechanism is still in place.  This also has the
    nice effect of removing non-DAPM devices as any device with a DAI
    acquires a widget automatically which will allow future simplifications
    to the core DAPM logic.
    
    The intention is that in future the AIF and DAI widgets will gain the
    ability to interact such that we are able to manage activity on
    individual channels independantly rather than powering up and down the
    entire AIF as we do currently.
    
    Currently we only generate these for CODECs, mostly as I have no systems
    with non-CODEC DAPM to integrate with. It should be a simple matter of
    programming to add the additional hookup for these.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 77d230cba61a..32ca75e20024 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1010,6 +1010,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 {
 	int ret = 0;
 	const struct snd_soc_codec_driver *driver = codec->driver;
+	struct snd_soc_dai *dai;
 
 	codec->card = card;
 	codec->dapm.card = card;
@@ -1024,6 +1025,14 @@ static int soc_probe_codec(struct snd_soc_card *card,
 		snd_soc_dapm_new_controls(&codec->dapm, driver->dapm_widgets,
 					  driver->num_dapm_widgets);
 
+	/* Create DAPM widgets for each DAI stream */
+	list_for_each_entry(dai, &dai_list, list) {
+		if (dai->dev != codec->dev)
+			continue;
+
+		snd_soc_dapm_new_dai_widgets(&codec->dapm, dai);
+	}
+
 	codec->dapm.idle_bias_off = driver->idle_bias_off;
 
 	if (driver->probe) {
@@ -1500,6 +1509,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
+	snd_soc_dapm_link_dai_widgets(card);
+
 	if (card->controls)
 		snd_soc_add_card_controls(card, card->controls, card->num_controls);
 

commit 3056557f3b2387d4ac99ca8af14956cd2bf003c2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 16 17:07:42 2012 -0800

    ASoC: dapm: Constify lots of names that are never modified
    
    Neater and avoids warnings when used in other places where const strings
    are desired.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7645b8a545cf..77d230cba61a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2018,7 +2018,7 @@ EXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);
  * Returns 0 for success, else error.
  */
 struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
-				  void *data, char *long_name,
+				  void *data, const char *long_name,
 				  const char *prefix)
 {
 	struct snd_kcontrol_new template;

commit 7bd3a6f34cdd4b1776ca34d0b6fab216e9323759
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 16 15:03:27 2012 -0800

    ASoC: dapm: Supply the DAI and substream when calling stream events
    
    In order to allow us to do something smarter than iterate through widgets
    doing strcmp() to work out what to power up for stream events change the
    interface used to generate them to be based on the combination of a DAI
    and a stream direction rather than just a simple string identifying the
    stream.
    
    At some point we'll probably want a set of channels too.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6bad7cd4131e..7645b8a545cf 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -573,18 +573,20 @@ int snd_soc_suspend(struct device *dev)
 	}
 
 	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;
+		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (driver->playback.stream_name != NULL)
-			snd_soc_dapm_stream_event(&card->rtd[i], driver->playback.stream_name,
-				SND_SOC_DAPM_STREAM_SUSPEND);
+		snd_soc_dapm_stream_event(&card->rtd[i],
+					  SNDRV_PCM_STREAM_PLAYBACK,
+					  codec_dai,
+					  SND_SOC_DAPM_STREAM_SUSPEND);
 
-		if (driver->capture.stream_name != NULL)
-			snd_soc_dapm_stream_event(&card->rtd[i], driver->capture.stream_name,
-				SND_SOC_DAPM_STREAM_SUSPEND);
+		snd_soc_dapm_stream_event(&card->rtd[i],
+					  SNDRV_PCM_STREAM_CAPTURE,
+					  codec_dai,
+					  SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
 	/* suspend all CODECs */
@@ -687,18 +689,18 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;
+		struct snd_soc_dai *codec_dai = card->rtd[i].codec_dai;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (driver->playback.stream_name != NULL)
-			snd_soc_dapm_stream_event(&card->rtd[i], driver->playback.stream_name,
-				SND_SOC_DAPM_STREAM_RESUME);
+		snd_soc_dapm_stream_event(&card->rtd[i],
+					  SNDRV_PCM_STREAM_PLAYBACK, codec_dai,
+					  SND_SOC_DAPM_STREAM_RESUME);
 
-		if (driver->capture.stream_name != NULL)
-			snd_soc_dapm_stream_event(&card->rtd[i], driver->capture.stream_name,
-				SND_SOC_DAPM_STREAM_RESUME);
+		snd_soc_dapm_stream_event(&card->rtd[i],
+					  SNDRV_PCM_STREAM_CAPTURE, codec_dai,
+					  SND_SOC_DAPM_STREAM_RESUME);
 	}
 
 	/* unmute any active DACs */

commit 731f1ab290ca1e59430ab222290d379222eb38a5
Author: Sebastien Guiriec <s-guiriec@ti.com>
Date:   Wed Feb 15 15:25:31 2012 +0000

    ASoC: core: add platform DAPM debugfs support
    
    Allow platform widgets to be visible in debugfs like codec widgets.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 50b8b80acdf4..6bad7cd4131e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -300,6 +300,27 @@ static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 	debugfs_remove_recursive(codec->debugfs_codec_root);
 }
 
+static void soc_init_platform_debugfs(struct snd_soc_platform *platform)
+{
+	struct dentry *debugfs_card_root = platform->card->debugfs_card_root;
+
+	platform->debugfs_platform_root = debugfs_create_dir(platform->name,
+						       debugfs_card_root);
+	if (!platform->debugfs_platform_root) {
+		dev_warn(platform->dev,
+			"Failed to create platform debugfs directory\n");
+		return;
+	}
+
+	snd_soc_dapm_debugfs_init(&platform->dapm,
+		platform->debugfs_platform_root);
+}
+
+static void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform)
+{
+	debugfs_remove_recursive(platform->debugfs_platform_root);
+}
+
 static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
 				    size_t count, loff_t *ppos)
 {
@@ -433,6 +454,14 @@ static inline void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 {
 }
 
+static inline void soc_init_platform_debugfs(struct snd_soc_platform *platform)
+{
+}
+
+static inline void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform)
+{
+}
+
 static inline void soc_init_card_debugfs(struct snd_soc_card *card)
 {
 }
@@ -920,6 +949,7 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 		/* Make sure all DAPM widgets are freed */
 		snd_soc_dapm_free(&platform->dapm);
 
+		soc_cleanup_platform_debugfs(platform);
 		platform->probed = 0;
 		list_del(&platform->card_list);
 		module_put(platform->dev->driver->owner);
@@ -1037,6 +1067,8 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	if (!try_module_get(platform->dev->driver->owner))
 		return -ENODEV;
 
+	soc_init_platform_debugfs(platform);
+
 	if (driver->dapm_widgets)
 		snd_soc_dapm_new_controls(&platform->dapm,
 			driver->dapm_widgets, driver->num_dapm_widgets);

commit 64e60f9f9e59f861fe9b79802b3cb03ca06b422f
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Feb 15 15:15:37 2012 +0000

    ASoC: core: Convert CODEC debugfs init to use dev_warn()
    
    Update the codec debugfs initialisation to use dev_warn() instead of
    printk(KERN_WARNING).
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8bd999530a76..50b8b80acdf4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -277,8 +277,7 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 	codec->debugfs_codec_root = debugfs_create_dir(codec->name,
 						       debugfs_card_root);
 	if (!codec->debugfs_codec_root) {
-		printk(KERN_WARNING
-		       "ASoC: Failed to create codec debugfs directory\n");
+		dev_warn(codec->dev, "Failed to create codec debugfs directory\n");
 		return;
 	}
 
@@ -291,8 +290,7 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 						 codec->debugfs_codec_root,
 						 codec, &codec_reg_fops);
 	if (!codec->debugfs_reg)
-		printk(KERN_WARNING
-		       "ASoC: Failed to create codec register debugfs file\n");
+		dev_warn(codec->dev, "Failed to create codec register debugfs file\n");
 
 	snd_soc_dapm_debugfs_init(&codec->dapm, codec->debugfs_codec_root);
 }

commit a08a499aa3d85b605b5669cfc82b8e14232f7e91
Merge: 6d70934a0248 d65b4e98d7ea
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 9 12:00:22 2012 +0000

    Merge tag 'v3.3-rc3' as we've got several bugfixes in there which are
    colliding annoyingly with development.
    
    Linux 3.3-rc3
    
    .. the number of the half-beast?
    
    Conflicts:
            sound/soc/codecs/wm5100.c
            sound/soc/codecs/wm8994.c

commit 5124e69e2b31f4ded7ed9ac47b18804b7847f677
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Feb 8 13:20:50 2012 +0000

    ASoC: core: Allow CODECs to set ignore_pmdown_time in the driver struct
    
    This is usually not a use case dependant flag anyway.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a3a47cdaac8f..32dbcda5cb22 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3312,6 +3312,7 @@ int snd_soc_register_codec(struct device *dev,
 	codec->volatile_register = codec_drv->volatile_register;
 	codec->readable_register = codec_drv->readable_register;
 	codec->writable_register = codec_drv->writable_register;
+	codec->ignore_pmdown_time = codec_drv->ignore_pmdown_time;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;

commit 022658beab5581ecc1d325d60857f2fc464da22f
Author: Liam Girdwood <lrg@ti.com>
Date:   Fri Feb 3 17:43:09 2012 +0000

    ASoC: core: Add support for DAI and machine kcontrols.
    
    Currently ASoC can only add kcontrols using codec and platform component device
    handles. It's also desirable to add kcontrols for DAIs (i.e. McBSP) and for
    SoC card machine drivers too. This allows the kcontrol to have a direct handle to
    the parent ASoC component DAI/SoC Card/Platform/Codec device and hence easily
    get it's private data.
    
    This change makes snd_soc_add_controls() static and wraps it in the folowing
    calls (card and dai are new) :-
    
    snd_soc_add_card_controls()
    snd_soc_add_codec_controls()
    snd_soc_add_dai_controls()
    snd_soc_add_platform_controls()
    
    This patch also does a lot of small mechanical changes in individual codec drivers
    to replace snd_soc_add_controls() with snd_soc_add_codec_controls().
    
    It also updates the McBSP DAI driver to use snd_soc_add_dai_controls().
    
    Finally, it updates the existing machine drivers that register controls to either :-
    
    1) Use snd_soc_add_card_controls() where no direct codec control is required.
    2) Use snd_soc_add_codec_controls() where there is direct codec control.
    
    In the case of 1) above we also update the machine drivers to get the correct
    component data pointers from the kcontrol (rather than getting the machine pointer
    via the codec pointer).
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 091d5f37ae64..a3a47cdaac8f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -996,7 +996,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	}
 
 	if (driver->controls)
-		snd_soc_add_controls(codec, driver->controls,
+		snd_soc_add_codec_controls(codec, driver->controls,
 				     driver->num_controls);
 	if (driver->dapm_routes)
 		snd_soc_dapm_add_routes(&codec->dapm, driver->dapm_routes,
@@ -1457,13 +1457,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
-	/* We should have a non-codec control add function but we don't */
 	if (card->controls)
-		snd_soc_add_controls(list_first_entry(&card->codec_dev_list,
-						      struct snd_soc_codec,
-						      card_list),
-				     card->controls,
-				     card->num_controls);
+		snd_soc_add_card_controls(card, card->controls, card->num_controls);
 
 	if (card->dapm_routes)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
@@ -2015,9 +2010,28 @@ struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
 }
 EXPORT_SYMBOL_GPL(snd_soc_cnew);
 
+static int snd_soc_add_controls(struct snd_card *card, struct device *dev,
+	const struct snd_kcontrol_new *controls, int num_controls,
+	const char *prefix, void *data)
+{
+	int err, i;
+
+	for (i = 0; i < num_controls; i++) {
+		const struct snd_kcontrol_new *control = &controls[i];
+		err = snd_ctl_add(card, snd_soc_cnew(control, data,
+						     control->name, prefix));
+		if (err < 0) {
+			dev_err(dev, "Failed to add %s: %d\n", control->name, err);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
 /**
- * snd_soc_add_controls - add an array of controls to a codec.
- * Convienience function to add a list of controls. Many codecs were
+ * snd_soc_add_codec_controls - add an array of controls to a codec.
+ * Convenience function to add a list of controls. Many codecs were
  * duplicating this code.
  *
  * @codec: codec to add controls to
@@ -2026,31 +2040,19 @@ EXPORT_SYMBOL_GPL(snd_soc_cnew);
  *
  * Return 0 for success, else error.
  */
-int snd_soc_add_controls(struct snd_soc_codec *codec,
+int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
 	const struct snd_kcontrol_new *controls, int num_controls)
 {
 	struct snd_card *card = codec->card->snd_card;
-	int err, i;
 
-	for (i = 0; i < num_controls; i++) {
-		const struct snd_kcontrol_new *control = &controls[i];
-		err = snd_ctl_add(card, snd_soc_cnew(control, codec,
-						     control->name,
-						     codec->name_prefix));
-		if (err < 0) {
-			dev_err(codec->dev, "%s: Failed to add %s: %d\n",
-				codec->name, control->name, err);
-			return err;
-		}
-	}
-
-	return 0;
+	return snd_soc_add_controls(card, codec->dev, controls, num_controls,
+			codec->name_prefix, codec);
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_controls);
+EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
 
 /**
  * snd_soc_add_platform_controls - add an array of controls to a platform.
- * Convienience function to add a list of controls.
+ * Convenience function to add a list of controls.
  *
  * @platform: platform to add controls to
  * @controls: array of controls to add
@@ -2062,22 +2064,52 @@ int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
 	const struct snd_kcontrol_new *controls, int num_controls)
 {
 	struct snd_card *card = platform->card->snd_card;
-	int err, i;
 
-	for (i = 0; i < num_controls; i++) {
-		const struct snd_kcontrol_new *control = &controls[i];
-		err = snd_ctl_add(card, snd_soc_cnew(control, platform,
-				control->name, NULL));
-		if (err < 0) {
-			dev_err(platform->dev, "Failed to add %s %d\n",control->name, err);
-			return err;
-		}
-	}
-
-	return 0;
+	return snd_soc_add_controls(card, platform->dev, controls, num_controls,
+			NULL, platform);
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);
 
+/**
+ * snd_soc_add_card_controls - add an array of controls to a SoC card.
+ * Convenience function to add a list of controls.
+ *
+ * @soc_card: SoC card to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_card_controls(struct snd_soc_card *soc_card,
+	const struct snd_kcontrol_new *controls, int num_controls)
+{
+	struct snd_card *card = soc_card->snd_card;
+
+	return snd_soc_add_controls(card, soc_card->dev, controls, num_controls,
+			NULL, soc_card);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_card_controls);
+
+/**
+ * snd_soc_add_dai_controls - add an array of controls to a DAI.
+ * Convienience function to add a list of controls.
+ *
+ * @dai: DAI to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
+	const struct snd_kcontrol_new *controls, int num_controls)
+{
+	struct snd_card *card = dai->card->snd_card;
+
+	return snd_soc_add_controls(card, dai->dev, controls, num_controls,
+			NULL, dai);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
+
 /**
  * snd_soc_info_enum_double - enumerated double mixer info callback
  * @kcontrol: mixer control

commit 5aa44b132eca1d08f5bb9c5c5cb46eec612db686
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 31 15:30:28 2012 +0000

    ASoC: core: Support suspend to disk
    
    Use the same pm_ops for all system suspend and resume paths. This isn't
    ideal for suspend to disk with older CODECs as we'll suspend and then
    resume the CODEC before powering off all of which takes a long time due
    to VMID ramps but it's very simple to implement and for modern CODECs the
    overhead should be minimal.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 35a1e639d7f9..091d5f37ae64 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1663,8 +1663,7 @@ int snd_soc_poweroff(struct device *dev)
 EXPORT_SYMBOL_GPL(snd_soc_poweroff);
 
 const struct dev_pm_ops snd_soc_pm_ops = {
-	.suspend = snd_soc_suspend,
-	.resume = snd_soc_resume,
+	SET_SYSTEM_SLEEP_PM_OPS(snd_soc_suspend, snd_soc_resume)
 	.poweroff = snd_soc_poweroff,
 };
 EXPORT_SYMBOL_GPL(snd_soc_pm_ops);

commit 125a25da5729740b7d1dc417a3d5549321baae17
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 31 15:49:10 2012 +0000

    ASoC: core: Better support for idle_bias_off suspend ignores
    
    If an idle_bias_off device is in any state other than off then it is still
    active for some reason (typically a low power function such as accessory
    detection). This wasn't an issue when the feature was implemented as we
    always went to _ON for any active function, subsequent power improvements
    have changed things.
    
    With the modern way of doing things we should overhaul the infrastructure
    to allow devices to explicitly take references for these functions but
    that's a much more invasive change and will require driver updates to
    deploy, this will bring the framework into line with the existing driver
    set before we do that work.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b5ecf6d23214..92cee24ed2dc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -567,6 +567,17 @@ int snd_soc_suspend(struct device *dev)
 		if (!codec->suspended && codec->driver->suspend) {
 			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
+				/*
+				 * If the CODEC is capable of idle
+				 * bias off then being in STANDBY
+				 * means it's doing something,
+				 * otherwise fall through.
+				 */
+				if (codec->dapm.idle_bias_off) {
+					dev_dbg(codec->dev,
+						"idle_bias_off CODEC on over suspend\n");
+					break;
+				}
 			case SND_SOC_BIAS_OFF:
 				codec->driver->suspend(codec);
 				codec->suspended = 1;

commit 8a713da8d1ce9ceaf738b32e2b24f22d4432f886
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Dec 3 12:33:55 2011 +0000

    ASoC: Use regmap update bits operation for drivers using regmap
    
    If a driver is using regmap directly ensure that we're coherent with
    non-ASoC register updates by using the regmap API directly to do our
    read/modify/write cycles. This will bypass the ASoC cache but drivers
    using regmap directly should not be using the ASoC cache.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 41c8e45a23e2..35a1e639d7f9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1869,23 +1869,28 @@ EXPORT_SYMBOL_GPL(snd_soc_bulk_write_raw);
 int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
 				unsigned int mask, unsigned int value)
 {
-	int change;
+	bool change;
 	unsigned int old, new;
 	int ret;
 
-	ret = snd_soc_read(codec, reg);
-	if (ret < 0)
-		return ret;
-
-	old = ret;
-	new = (old & ~mask) | (value & mask);
-	change = old != new;
-	if (change) {
-		ret = snd_soc_write(codec, reg, new);
+	if (codec->using_regmap) {
+		ret = regmap_update_bits_check(codec->control_data, reg,
+					       mask, value, &change);
+	} else {
+		ret = snd_soc_read(codec, reg);
 		if (ret < 0)
 			return ret;
+
+		old = ret;
+		new = (old & ~mask) | (value & mask);
+		change = old != new;
+		if (change)
+			ret = snd_soc_write(codec, reg, new);
 	}
 
+	if (ret < 0)
+		return ret;
+
 	return change;
 }
 EXPORT_SYMBOL_GPL(snd_soc_update_bits);

commit 3b09bb820dda209d5c81e329420ccf36dd30c8eb
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Jan 9 12:09:29 2012 +0000

    ASoC: core - Improve card registration error messaging for large DAI links.
    
    Print out the offending DAI link entry when a naming error occurs. Makes
    thing easier to debug for machines with a large number of DAI links.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b5ecf6d23214..41c8e45a23e2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2864,7 +2864,8 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 */
 		if (!!link->codec_name == !!link->codec_of_node) {
 			dev_err(card->dev,
-				"Neither/both codec name/of_node are set\n");
+				"Neither/both codec name/of_node are set for %s\n",
+				link->name);
 			return -EINVAL;
 		}
 
@@ -2874,7 +2875,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 */
 		if (link->platform_name && link->platform_of_node) {
 			dev_err(card->dev,
-				"Both platform name/of_node are set\n");
+				"Both platform name/of_node are set for %s\n", link->name);
 			return -EINVAL;
 		}
 
@@ -2884,7 +2885,8 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		 */
 		if (!!link->cpu_dai_name == !!link->cpu_dai_of_node) {
 			dev_err(card->dev,
-				"Neither/both cpu_dai name/of_node are set\n");
+				"Neither/both cpu_dai name/of_node are set for %s\n",
+				link->name);
 			return -EINVAL;
 		}
 	}

commit 675c496ba4e751ea5b895c83219e3bb034f648ba
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Jan 16 15:25:37 2012 +0000

    ASoC: core - Free platform DAPM context at platform removal.
    
    Fix platform removal by freeing the platform DAPM resources and remove
    it from the DAPM list.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3986520b4677..b5ecf6d23214 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -907,6 +907,10 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 			if (err < 0)
 				printk(KERN_ERR "asoc: failed to remove %s\n", platform->name);
 		}
+
+		/* Make sure all DAPM widgets are freed */
+		snd_soc_dapm_free(&platform->dapm);
+
 		platform->probed = 0;
 		list_del(&platform->card_list);
 		module_put(platform->dev->driver->owner);

commit 36ae1a96c4dcb0f6581d595cc5d43cf3a7e648c7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jan 6 17:12:45 2012 -0800

    ASoC: Dynamically allocate the rtd device for a non-empty release()
    
    The device model needs a release() function so it can free devices when
    they become dereferenced.  Do that for rtds.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index acbb96005a69..3986520b4677 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -169,8 +169,7 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf,
 static ssize_t codec_reg_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	struct snd_soc_pcm_runtime *rtd =
-			container_of(dev, struct snd_soc_pcm_runtime, dev);
+	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
 
 	return soc_codec_reg_show(rtd->codec, buf, PAGE_SIZE, 0);
 }
@@ -180,8 +179,7 @@ static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
 static ssize_t pmdown_time_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct snd_soc_pcm_runtime *rtd =
-			container_of(dev, struct snd_soc_pcm_runtime, dev);
+	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%ld\n", rtd->pmdown_time);
 }
@@ -190,8 +188,7 @@ static ssize_t pmdown_time_set(struct device *dev,
 			       struct device_attribute *attr,
 			       const char *buf, size_t count)
 {
-	struct snd_soc_pcm_runtime *rtd =
-			container_of(dev, struct snd_soc_pcm_runtime, dev);
+	struct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);
 	int ret;
 
 	ret = strict_strtol(buf, 10, &rtd->pmdown_time);
@@ -884,9 +881,9 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
-		device_remove_file(&rtd->dev, &dev_attr_pmdown_time);
-		device_remove_file(&rtd->dev, &dev_attr_codec_reg);
-		device_unregister(&rtd->dev);
+		device_remove_file(rtd->dev, &dev_attr_pmdown_time);
+		device_remove_file(rtd->dev, &dev_attr_codec_reg);
+		device_unregister(rtd->dev);
 		rtd->dev_registered = 0;
 	}
 
@@ -1061,7 +1058,10 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	return ret;
 }
 
-static void rtd_release(struct device *dev) {}
+static void rtd_release(struct device *dev)
+{
+	kfree(dev);
+}
 
 static int soc_post_component_init(struct snd_soc_card *card,
 				   struct snd_soc_codec *codec,
@@ -1104,11 +1104,17 @@ static int soc_post_component_init(struct snd_soc_card *card,
 
 	/* register the rtd device */
 	rtd->codec = codec;
-	rtd->dev.parent = card->dev;
-	rtd->dev.release = rtd_release;
-	rtd->dev.init_name = name;
+
+	rtd->dev = kzalloc(sizeof(struct device), GFP_KERNEL);
+	if (!rtd->dev)
+		return -ENOMEM;
+	device_initialize(rtd->dev);
+	rtd->dev->parent = card->dev;
+	rtd->dev->release = rtd_release;
+	rtd->dev->init_name = name;
+	dev_set_drvdata(rtd->dev, rtd);
 	mutex_init(&rtd->pcm_mutex);
-	ret = device_register(&rtd->dev);
+	ret = device_add(rtd->dev);
 	if (ret < 0) {
 		dev_err(card->dev,
 			"asoc: failed to register runtime device: %d\n", ret);
@@ -1117,14 +1123,14 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	rtd->dev_registered = 1;
 
 	/* add DAPM sysfs entries for this codec */
-	ret = snd_soc_dapm_sys_add(&rtd->dev);
+	ret = snd_soc_dapm_sys_add(rtd->dev);
 	if (ret < 0)
 		dev_err(codec->dev,
 			"asoc: failed to add codec dapm sysfs entries: %d\n",
 			ret);
 
 	/* add codec sysfs entries */
-	ret = device_create_file(&rtd->dev, &dev_attr_codec_reg);
+	ret = device_create_file(rtd->dev, &dev_attr_codec_reg);
 	if (ret < 0)
 		dev_err(codec->dev,
 			"asoc: failed to add codec sysfs files: %d\n", ret);
@@ -1213,7 +1219,7 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 	if (ret)
 		return ret;
 
-	ret = device_create_file(&rtd->dev, &dev_attr_pmdown_time);
+	ret = device_create_file(rtd->dev, &dev_attr_pmdown_time);
 	if (ret < 0)
 		printk(KERN_WARNING "asoc: failed to add pmdown_time sysfs\n");
 
@@ -1311,8 +1317,8 @@ static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
-		device_remove_file(&rtd->dev, &dev_attr_codec_reg);
-		device_unregister(&rtd->dev);
+		device_remove_file(rtd->dev, &dev_attr_codec_reg);
+		device_del(rtd->dev);
 		rtd->dev_registered = 0;
 	}
 

commit 354a21423d09c2a6afe0fcea9dbbda9cdada6e45
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 22 12:16:39 2011 +0000

    ASoC: Declare soc_new_pcm() properly
    
    Ensure that everything is seeing the same declaration by moving it to
    a header file rather than putting the declaration in soc-core.c
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a4592cbee49b..acbb96005a69 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -59,8 +59,6 @@ static LIST_HEAD(dai_list);
 static LIST_HEAD(platform_list);
 static LIST_HEAD(codec_list);
 
-int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num);
-
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
  * It can be used to eliminate pops between different playback streams, e.g.

commit 5a5049637cf08c4c17805be679c19544bb27fb92
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Dec 21 10:40:59 2011 -0700

    ASoC: Allow DAI links to be specified using device tree nodes
    
    DAI link endpoints and platform (DMA) devices are currently specified
    by name. When instantiating sound cards from device tree, it may be more
    convenient to refer to these devices by phandle in the device tree, and
    for code to describe DAI links using the "struct device_node *"
    ("of_node") those phandles map to.
    
    This change adds new fields to snd_soc_dai_link which can "name" devices
    using of_node, enhances soc_bind_dai_link() to allow binding based on
    of_node, and enhances snd_soc_register_card() to ensure that illegal
    combinations of name and of_node are not used.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 42ad2db8f082..a4592cbee49b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -764,8 +764,13 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	}
 	/* no, then find CPU DAI from registered DAIs*/
 	list_for_each_entry(cpu_dai, &dai_list, list) {
-		if (strcmp(cpu_dai->name, dai_link->cpu_dai_name))
-			continue;
+		if (dai_link->cpu_dai_of_node) {
+			if (cpu_dai->dev->of_node != dai_link->cpu_dai_of_node)
+				continue;
+		} else {
+			if (strcmp(cpu_dai->name, dai_link->cpu_dai_name))
+				continue;
+		}
 
 		rtd->cpu_dai = cpu_dai;
 		goto find_codec;
@@ -781,8 +786,13 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 
 	/* no, then find CODEC from registered CODECs*/
 	list_for_each_entry(codec, &codec_list, list) {
-		if (strcmp(codec->name, dai_link->codec_name))
-			continue;
+		if (dai_link->codec_of_node) {
+			if (codec->dev->of_node != dai_link->codec_of_node)
+				continue;
+		} else {
+			if (strcmp(codec->name, dai_link->codec_name))
+				continue;
+		}
 
 		rtd->codec = codec;
 
@@ -814,13 +824,19 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 
 	/* if there's no platform we match on the empty platform */
 	platform_name = dai_link->platform_name;
-	if (!platform_name)
+	if (!platform_name && !dai_link->platform_of_node)
 		platform_name = "snd-soc-dummy";
 
 	/* no, then find one from the set of registered platforms */
 	list_for_each_entry(platform, &platform_list, list) {
-		if (strcmp(platform->name, platform_name))
-			continue;
+		if (dai_link->platform_of_node) {
+			if (platform->dev->of_node !=
+			    dai_link->platform_of_node)
+				continue;
+		} else {
+			if (strcmp(platform->name, platform_name))
+				continue;
+		}
 
 		rtd->platform = platform;
 		goto out;
@@ -2831,6 +2847,40 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	if (!card->name || !card->dev)
 		return -EINVAL;
 
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_dai_link *link = &card->dai_link[i];
+
+		/*
+		 * Codec must be specified by 1 of name or OF node,
+		 * not both or neither.
+		 */
+		if (!!link->codec_name == !!link->codec_of_node) {
+			dev_err(card->dev,
+				"Neither/both codec name/of_node are set\n");
+			return -EINVAL;
+		}
+
+		/*
+		 * Platform may be specified by either name or OF node, but
+		 * can be left unspecified, and a dummy platform will be used.
+		 */
+		if (link->platform_name && link->platform_of_node) {
+			dev_err(card->dev,
+				"Both platform name/of_node are set\n");
+			return -EINVAL;
+		}
+
+		/*
+		 * CPU DAI must be specified by 1 of name or OF node,
+		 * not both or neither.
+		 */
+		if (!!link->cpu_dai_name == !!link->cpu_dai_of_node) {
+			dev_err(card->dev,
+				"Neither/both cpu_dai name/of_node are set\n");
+			return -EINVAL;
+		}
+	}
+
 	dev_set_drvdata(card->dev, card);
 
 	snd_soc_initialize_card_lists(card);

commit a4a54dd5bb1bb01010f46147d6d8b452255957bf
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Dec 12 15:55:35 2011 -0700

    ASoC: Add utility to parse DAPM routes from device tree
    
    Implement snd_soc_of_parse_audio_routing(), a utility function that can
    parses a simple DAPM route table from device tree.The machine driver
    specifies the DT property to use, since this is binding-specific.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 51eef9b7b53f..42ad2db8f082 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3342,6 +3342,63 @@ int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_card_name);
 
+int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
+				   const char *propname)
+{
+	struct device_node *np = card->dev->of_node;
+	int num_routes;
+	struct snd_soc_dapm_route *routes;
+	int i, ret;
+
+	num_routes = of_property_count_strings(np, propname);
+	if (num_routes & 1) {
+		dev_err(card->dev,
+			"Property '%s's length is not even\n",
+			propname);
+		return -EINVAL;
+	}
+	num_routes /= 2;
+	if (!num_routes) {
+		dev_err(card->dev,
+			"Property '%s's length is zero\n",
+			propname);
+		return -EINVAL;
+	}
+
+	routes = devm_kzalloc(card->dev, num_routes * sizeof(*routes),
+			      GFP_KERNEL);
+	if (!routes) {
+		dev_err(card->dev,
+			"Could not allocate DAPM route table\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < num_routes; i++) {
+		ret = of_property_read_string_index(np, propname,
+			2 * i, &routes[i].sink);
+		if (ret) {
+			dev_err(card->dev,
+				"Property '%s' index %d could not be read: %d\n",
+				propname, 2 * i, ret);
+			return -EINVAL;
+		}
+		ret = of_property_read_string_index(np, propname,
+			(2 * i) + 1, &routes[i].source);
+		if (ret) {
+			dev_err(card->dev,
+				"Property '%s' index %d could not be read: %d\n",
+				propname, (2 * i) + 1, ret);
+			return -EINVAL;
+		}
+	}
+
+	card->num_dapm_routes = num_routes;
+	card->dapm_routes = routes;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_routing);
+
 static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS

commit bec4fa05e25f7e78ec67df389539acc6bb352a2a
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Dec 12 15:55:34 2011 -0700

    ASoC: Add utility to set a card's name from device tree
    
    Implement snd_soc_of_parse_card_name(), a utility function that sets a
    card's name from device tree. The machine driver specifies the DT
    property to use, since this is binding-specific.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1252ab1ebf69..51eef9b7b53f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -32,6 +32,7 @@
 #include <linux/platform_device.h>
 #include <linux/ctype.h>
 #include <linux/slab.h>
+#include <linux/of.h>
 #include <sound/ac97_codec.h>
 #include <sound/core.h>
 #include <sound/jack.h>
@@ -3317,6 +3318,30 @@ void snd_soc_unregister_codec(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
 
+/* Retrieve a card's name from device tree */
+int snd_soc_of_parse_card_name(struct snd_soc_card *card,
+			       const char *propname)
+{
+	struct device_node *np = card->dev->of_node;
+	int ret;
+
+	ret = of_property_read_string_index(np, propname, 0, &card->name);
+	/*
+	 * EINVAL means the property does not exist. This is fine providing
+	 * card->name was previously set, which is checked later in
+	 * snd_soc_register_card.
+	 */
+	if (ret < 0 && ret != -EINVAL) {
+		dev_err(card->dev,
+			"Property '%s' could not be read: %d\n",
+			propname, ret);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_card_name);
+
 static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS

commit 7c08be84f83b23762fb7571ac9a4aea3c34d1a66
Author: Lothar Waßmann <LW@KARO-electronics.de>
Date:   Fri Dec 9 14:16:29 2011 +0100

    ASoC: Fix an obvious copy paste error in an error message
    
    The message was obviously copied from soc_init_codec_debugfs()
    
    Signed-off-by: Lothar Waßmann <LW@KARO-electronics.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ebb104878c48..1252ab1ebf69 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -412,7 +412,7 @@ static void soc_init_card_debugfs(struct snd_soc_card *card)
 						     snd_soc_debugfs_root);
 	if (!card->debugfs_card_root) {
 		dev_warn(card->dev,
-			 "ASoC: Failed to create codec debugfs directory\n");
+			 "ASoC: Failed to create card debugfs directory\n");
 		return;
 	}
 

commit 2610ab7767bba916f65094d71cfed3b8281cba08
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Dec 7 13:58:27 2011 -0700

    ASoC: Refactor some conditions and loop in soc_bind_dai_link()
    
    Transform some loops from:
    
    for_each(x) {
        if (f(x)) {
            work_on(x);
        }
    }
    
    to new structure:
    
    for_each(x) {
        if (!f(x))
            continue;
    
        work_on(x);
    }
    
    This will allow future modification of f(x) with less impact to the code.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5195f0653b35..ebb104878c48 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -763,10 +763,11 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	}
 	/* no, then find CPU DAI from registered DAIs*/
 	list_for_each_entry(cpu_dai, &dai_list, list) {
-		if (!strcmp(cpu_dai->name, dai_link->cpu_dai_name)) {
-			rtd->cpu_dai = cpu_dai;
-			goto find_codec;
-		}
+		if (strcmp(cpu_dai->name, dai_link->cpu_dai_name))
+			continue;
+
+		rtd->cpu_dai = cpu_dai;
+		goto find_codec;
 	}
 	dev_dbg(card->dev, "CPU DAI %s not registered\n",
 			dai_link->cpu_dai_name);
@@ -779,22 +780,28 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 
 	/* no, then find CODEC from registered CODECs*/
 	list_for_each_entry(codec, &codec_list, list) {
-		if (!strcmp(codec->name, dai_link->codec_name)) {
-			rtd->codec = codec;
-
-			/* CODEC found, so find CODEC DAI from registered DAIs from this CODEC*/
-			list_for_each_entry(codec_dai, &dai_list, list) {
-				if (codec->dev == codec_dai->dev &&
-						!strcmp(codec_dai->name, dai_link->codec_dai_name)) {
-					rtd->codec_dai = codec_dai;
-					goto find_platform;
-				}
-			}
-			dev_dbg(card->dev, "CODEC DAI %s not registered\n",
-					dai_link->codec_dai_name);
+		if (strcmp(codec->name, dai_link->codec_name))
+			continue;
+
+		rtd->codec = codec;
 
-			goto find_platform;
+		/*
+		 * CODEC found, so find CODEC DAI from registered DAIs from
+		 * this CODEC
+		 */
+		list_for_each_entry(codec_dai, &dai_list, list) {
+			if (codec->dev == codec_dai->dev &&
+				!strcmp(codec_dai->name,
+					dai_link->codec_dai_name)) {
+
+				rtd->codec_dai = codec_dai;
+				goto find_platform;
+			}
 		}
+		dev_dbg(card->dev, "CODEC DAI %s not registered\n",
+				dai_link->codec_dai_name);
+
+		goto find_platform;
 	}
 	dev_dbg(card->dev, "CODEC %s not registered\n",
 			dai_link->codec_name);
@@ -811,10 +818,11 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 
 	/* no, then find one from the set of registered platforms */
 	list_for_each_entry(platform, &platform_list, list) {
-		if (!strcmp(platform->name, platform_name)) {
-			rtd->platform = platform;
-			goto out;
-		}
+		if (strcmp(platform->name, platform_name))
+			continue;
+
+		rtd->platform = platform;
+		goto out;
 	}
 
 	dev_dbg(card->dev, "platform %s not registered\n",

commit 84b315ee893676e9a9ce8ac42ab5ef44e2af3ee1
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Dec 2 10:18:28 2011 +0100

    ASoC: Drop unused state parameter from CODEC suspend callback
    
    The existence of this parameter is purely historical. None of the CODEC drivers
    uses it and we always pass in the same value anyway, so it should be safe to
    remove it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ec783f0a27e9..5195f0653b35 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -572,7 +572,7 @@ int snd_soc_suspend(struct device *dev)
 			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
 			case SND_SOC_BIAS_OFF:
-				codec->driver->suspend(codec, PMSG_SUSPEND);
+				codec->driver->suspend(codec);
 				codec->suspended = 1;
 				codec->cache_sync = 1;
 				break;

commit b05d8dc15f346224306bda4b4ae39fc5ace74ee6
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Nov 27 19:38:34 2011 +0000

    ASoC: Fix CODEC enumeration for auto_nc_codec_pins
    
    We need to enumerate all the CODECs that are part of the card we're
    instantiating, not all the CODECs that are in the system as the system
    may have multiple cards.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2abaf6dcdb0a..ec783f0a27e9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1489,7 +1489,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	snd_soc_dapm_new_widgets(&card->dapm);
 
 	if (card->fully_routed)
-		list_for_each_entry(codec, &codec_list, list)
+		list_for_each_entry(codec, &card->codec_dev_list, card_list)
 			snd_soc_dapm_auto_nc_codec_pins(codec);
 
 	ret = snd_card_register(card->snd_card);

commit 1633281b79fd276f1c7c2fb37c3b97da74e42ae5
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Nov 23 12:42:04 2011 -0700

    ASoC: Implement fully_routed card property
    
    A card is fully routed if the DAPM route table describes all connections on
    the board.
    
    When a card is fully routed, some operations can be automated by the ASoC
    core. The first, and currently only, such operation is described below, and
    implemented by this patch.
    
    Codecs often have a large number of external pins, and not all of these pins
    will be connected on all board designs. Some machine drivers therefore call
    snd_soc_dapm_nc_pin() for all the unused pins, in order to tell the ASoC core
    never to activate them.
    
    However, when a card is fully routed, the information needed to derive the
    set of unused pins is present in card->dapm_routes. In this case, have
    the ASoC core automatically call snd_soc_dapm_nc_pin() for each unused
    codec pin.
    
    This has been tested with soc/tegra/tegra_wm8903.c and soc/tegra/trimslice.c.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b194842c4cc3..2abaf6dcdb0a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1488,6 +1488,10 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	snd_soc_dapm_new_widgets(&card->dapm);
 
+	if (card->fully_routed)
+		list_for_each_entry(codec, &codec_list, list)
+			snd_soc_dapm_auto_nc_codec_pins(codec);
+
 	ret = snd_card_register(card->snd_card);
 	if (ret < 0) {
 		printk(KERN_ERR "asoc: failed to register soundcard for %s\n", card->name);

commit 983a150a12f8cf729784d3118b25a757f8cbe46a
Merge: 193b2f3f5369 5ff1ddf22b25
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 23 14:58:37 2011 +0000

    Merge branch 'for-3.2' into for-3.3

commit 5ff1ddf22b2584d00d7e0ba5a8eab07b5338bd84
Author: Eric Miao <eric.miao@linaro.org>
Date:   Wed Nov 23 22:37:00 2011 +0800

    ASoC: skip resume of soc-audio devices without codecs
    
    There are cases where there is no working codec on the soc-audio devices,
    and snd_soc_suspend() will skip such device when suspending. Yet its
    counterpart snd_soc_resume() does not check this, causing complaints
    about spinlock lockup:
    
    [  176.726087] BUG: spinlock lockup on CPU#0, kworker/0:2/1067, d8ab82a8
    [  176.732539] [<80014a14>] (unwind_backtrace+0x0/0xec) from [<805b3fc8>] (dump_stack+0x20/0x24)
    [  176.741082] [<805b3fc8>] (dump_stack+0x20/0x24) from [<80322208>] (do_raw_spin_lock+0x118/0x158)
    [  176.749882] [<80322208>] (do_raw_spin_lock+0x118/0x158) from [<805b7874>] (_raw_spin_lock_irqsave+0x5c/0x68)
    [  176.759723] [<805b7874>] (_raw_spin_lock_irqsave+0x5c/0x68) from [<8002a020>] (__wake_up+0x2c/0x5c)
    [  176.768781] [<8002a020>] (__wake_up+0x2c/0x5c) from [<804a6de8>] (soc_resume_deferred+0x3c/0x2b0)
    [  176.777666] [<804a6de8>] (soc_resume_deferred+0x3c/0x2b0) from [<8004ee20>] (process_one_work+0x2e8/0x50c)
    [  176.787334] [<8004ee20>] (process_one_work+0x2e8/0x50c) from [<8004fd08>] (worker_thread+0x1c8/0x2e0)
    [  176.796566] [<8004fd08>] (worker_thread+0x1c8/0x2e0) from [<80053ec8>] (kthread+0xa4/0xb0)
    [  176.804843] [<80053ec8>] (kthread+0xa4/0xb0) from [<8000ea70>] (kernel_thread_exit+0x0/0x8)
    
    Signed-off-by: Eric Miao <eric.miao@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a5d3685a5d38..a25fa63ce9a2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -709,6 +709,12 @@ int snd_soc_resume(struct device *dev)
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	int i, ac97_control = 0;
 
+	/* If the initialization of this soc device failed, there is no codec
+	 * associated with it. Just bail out in this case.
+	 */
+	if (list_empty(&card->codec_dev_list))
+		return 0;
+
 	/* AC97 devices might have other drivers hanging off them so
 	 * need to resume immediately.  Other drivers don't have that
 	 * problem and may take a substantial amount of time to resume

commit 85e7652d89293a6dab42bfd31f276f8bc072d4c5
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 23 11:40:40 2011 +0100

    ASoC: Constify snd_soc_dai_ops structs
    
    Commit 1ee46ebd("ASoC: Make the DAI ops constant in the DAI structure")
    introduced the possibility to have constant DAI ops structures, yet this is
    barley used in both existing drivers and also new drivers being submitted,
    although none of them modifies its DAI ops structure. The later is not
    surprising since existing drivers are often used as templates for new drivers.
    So this patch just constifies all existing snd_soc_dai_ops structs to eliminate
    the issue altogether.
    
    The patch was generated with the following coccinelle semantic patch:
    // <smpl>
    @@
    identifier ops;
    @@
    -struct snd_soc_dai_ops ops =
    +const struct snd_soc_dai_ops ops =
    { ... };
    // </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a5d3685a5d38..bf41d9071f1e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -735,7 +735,7 @@ EXPORT_SYMBOL_GPL(snd_soc_resume);
 #define snd_soc_resume NULL
 #endif
 
-static struct snd_soc_dai_ops null_dai_ops = {
+static const struct snd_soc_dai_ops null_dai_ops = {
 };
 
 static int soc_bind_dai_link(struct snd_soc_card *card, int num)

commit 4b1cfcb4f36dca33b4552d9612537e6c0ca73639
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Oct 18 00:11:49 2011 +0100

    ASoC: Fix prefixing of DAPM controls
    
    We don't want to clear the prefix while we're creating the DAPM controls
    for the device as the prefix is applied during control creation.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d6af52bd97df..a5d3685a5d38 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1055,13 +1055,13 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	}
 	rtd->card = card;
 
+	/* Make sure all DAPM widgets are instantiated */
+	snd_soc_dapm_new_widgets(&codec->dapm);
+
 	/* machine controls, routes and widgets are not prefixed */
 	temp = codec->name_prefix;
 	codec->name_prefix = NULL;
 
-	/* Make sure all DAPM widgets are instantiated */
-	snd_soc_dapm_new_widgets(&codec->dapm);
-
 	/* do machine specific initialization */
 	if (!dailess && dai_link->init)
 		ret = dai_link->init(rtd);

commit b90d2f908465c800388714180217620c4a5b2fe4
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Oct 10 13:38:06 2011 +0100

    ASoC: Instantiate card widgets immediately
    
    This ensures they are available prior to the card late_probe().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8dc9aba3526d..d6af52bd97df 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1430,6 +1430,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 					card->num_dapm_routes);
 
+	snd_soc_dapm_new_widgets(&card->dapm);
+
 	for (i = 0; i < card->num_links; i++) {
 		dai_link = &card->dai_link[i];
 

commit 2dc00213b03669010a67454d6448d91f3af06435
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Oct 8 13:59:44 2011 +0100

    ASoC: Ensure all DAPM widgets are instantiated with the card
    
    Specifically for the widgets added by machine driver late probe functions.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b65e3d40177c..8dc9aba3526d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1478,6 +1478,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
+	snd_soc_dapm_new_widgets(&card->dapm);
+
 	ret = snd_card_register(card->snd_card);
 	if (ret < 0) {
 		printk(KERN_ERR "asoc: failed to register soundcard for %s\n", card->name);

commit 4f4c0072228785179d35b2bd9e48081ce9fa51f6
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Oct 7 14:29:19 2011 +0100

    ASoC: Suppress early calls to snd_soc_dapm_sync()
    
    Ensure we only have one sync during the initial startup of the card by
    making snd_soc_dapm_sync() a noop on non-instantiated cards. This avoids
    any bounces due to things like jacks reporting their initial state on
    partially initialised cards. The callers that don't also get called at
    runtime should just be removed.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2a2507627520..b65e3d40177c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1498,6 +1498,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 #endif
 
 	card->instantiated = 1;
+	snd_soc_dapm_sync(&card->dapm);
 	mutex_unlock(&card->mutex);
 	return;
 

commit 974815ba4f88f3f12f6f01384e822b23be058323
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Oct 5 10:29:25 2011 +0300

    ASoC: core: Combine snd_soc_put_volsw/put_volsw_2r functions
    
    Handle the put_volsw/put_volsw_2r in one function.
    
    To avoid build breakage in twl6040 keep the
    snd_soc_put_volsw_2r as define, and map it snd_soc_put_volsw.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1a13d530f053..2a2507627520 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2327,7 +2327,8 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
  * @kcontrol: mixer control
  * @ucontrol: control element information
  *
- * Callback to set the value of a single mixer control.
+ * Callback to set the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
  *
  * Returns 0 for success.
  */
@@ -2338,73 +2339,44 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
 	unsigned int shift = mc->shift;
 	unsigned int rshift = mc->rshift;
 	int max = mc->max;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
-	unsigned int val, val2, val_mask;
+	int err;
+	bool type_2r = 0;
+	unsigned int val2 = 0;
+	unsigned int val, val_mask;
 
 	val = (ucontrol->value.integer.value[0] & mask);
 	if (invert)
 		val = max - val;
 	val_mask = mask << shift;
 	val = val << shift;
-	if (shift != rshift) {
+	if (snd_soc_volsw_is_stereo(mc)) {
 		val2 = (ucontrol->value.integer.value[1] & mask);
 		if (invert)
 			val2 = max - val2;
-		val_mask |= mask << rshift;
-		val |= val2 << rshift;
-	}
-	return snd_soc_update_bits_locked(codec, reg, val_mask, val);
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
-
-/**
- * snd_soc_put_volsw_2r - double mixer set callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value of a double mixer control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	int err;
-	unsigned int val, val2, val_mask;
-
-	val_mask = mask << shift;
-	val = (ucontrol->value.integer.value[0] & mask);
-	val2 = (ucontrol->value.integer.value[1] & mask);
-
-	if (invert) {
-		val = max - val;
-		val2 = max - val2;
+		if (reg == reg2) {
+			val_mask |= mask << rshift;
+			val |= val2 << rshift;
+		} else {
+			val2 = val2 << shift;
+			type_2r = 1;
+		}
 	}
-
-	val = val << shift;
-	val2 = val2 << shift;
-
 	err = snd_soc_update_bits_locked(codec, reg, val_mask, val);
 	if (err < 0)
 		return err;
 
-	err = snd_soc_update_bits_locked(codec, reg2, val_mask, val2);
+	if (type_2r)
+		err = snd_soc_update_bits_locked(codec, reg2, val_mask, val2);
+
 	return err;
 }
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 
 /**
  * snd_soc_info_volsw_s8 - signed mixer info callback

commit f7915d997554d4e2ce123c7a4ddd28e12c2e034c
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Oct 5 10:29:24 2011 +0300

    ASoC: core: Combine snd_soc_get_volsw/get_volsw_2r functions
    
    Handle the get_volsw/get_volsw_2r in one function.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 34e85506782e..1a13d530f053 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2281,7 +2281,8 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
  * @kcontrol: mixer control
  * @ucontrol: control element information
  *
- * Callback to get the value of a single mixer control.
+ * Callback to get the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
  *
  * Returns 0 for success.
  */
@@ -2292,6 +2293,7 @@ int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
 	unsigned int shift = mc->shift;
 	unsigned int rshift = mc->rshift;
 	int max = mc->max;
@@ -2300,13 +2302,18 @@ int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 
 	ucontrol->value.integer.value[0] =
 		(snd_soc_read(codec, reg) >> shift) & mask;
-	if (shift != rshift)
-		ucontrol->value.integer.value[1] =
-			(snd_soc_read(codec, reg) >> rshift) & mask;
-	if (invert) {
+	if (invert)
 		ucontrol->value.integer.value[0] =
 			max - ucontrol->value.integer.value[0];
-		if (shift != rshift)
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		if (reg == reg2)
+			ucontrol->value.integer.value[1] =
+				(snd_soc_read(codec, reg) >> rshift) & mask;
+		else
+			ucontrol->value.integer.value[1] =
+				(snd_soc_read(codec, reg2) >> shift) & mask;
+		if (invert)
 			ucontrol->value.integer.value[1] =
 				max - ucontrol->value.integer.value[1];
 	}
@@ -2354,43 +2361,6 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 
-/**
- * snd_soc_get_volsw_2r - double mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a double mixer control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-
-	ucontrol->value.integer.value[0] =
-		(snd_soc_read(codec, reg) >> shift) & mask;
-	ucontrol->value.integer.value[1] =
-		(snd_soc_read(codec, reg2) >> shift) & mask;
-	if (invert) {
-		ucontrol->value.integer.value[0] =
-			max - ucontrol->value.integer.value[0];
-		ucontrol->value.integer.value[1] =
-			max - ucontrol->value.integer.value[1];
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r);
-
 /**
  * snd_soc_put_volsw_2r - double mixer set callback
  * @kcontrol: mixer control

commit e8f5a10307f7d224df91776033a0b8559a559844
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Oct 5 10:29:23 2011 +0300

    ASoC: core: Combine snd_soc_info_volsw/info_volsw_2r functions
    
    Handle the info_volsw/info_volsw_2r in one function.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 778c177b5bfb..34e85506782e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2248,7 +2248,8 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
  * @kcontrol: mixer control
  * @uinfo: control element information
  *
- * Callback to provide information about a single mixer control.
+ * Callback to provide information about a single mixer control, or a double
+ * mixer control that spans 2 registers.
  *
  * Returns 0 for success.
  */
@@ -2258,8 +2259,6 @@ int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	int platform_max;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
 
 	if (!mc->platform_max)
 		mc->platform_max = mc->max;
@@ -2270,7 +2269,7 @@ int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	else
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 
-	uinfo->count = shift == rshift ? 1 : 2;
+	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
 	uinfo->value.integer.min = 0;
 	uinfo->value.integer.max = platform_max;
 	return 0;
@@ -2355,39 +2354,6 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 
-/**
- * snd_soc_info_volsw_2r - double mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a double mixer control that
- * spans 2 codec registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int platform_max;
-
-	if (!mc->platform_max)
-		mc->platform_max = mc->max;
-	platform_max = mc->platform_max;
-
-	if (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	else
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-
-	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = platform_max;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
-
 /**
  * snd_soc_get_volsw_2r - double mixer get callback
  * @kcontrol: mixer control

commit db432b414e20b7218bbd91654d7be9c524a4337a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Oct 3 21:06:40 2011 +0100

    ASoC: Do DAPM power checks only for widgets changed since last run
    
    In order to reduce the number of DAPM power checks we run keep a list of
    widgets which have been changed since the last DAPM run and iterate over
    that rather than the full widget list. Whenever we change the power state
    for a widget we add all the source and sink widgets it has to the dirty
    list, ensuring that all widgets in the path are checked.
    
    This covers more widgets than we need to as some of the neighbour widgets
    won't be connected but it's simpler as a first step. On one system I tried
    this gave:
    
               Power    Path   Neighbour
    Before:    207      1939   2461
    After:     114      1066   1327
    
    which seems useful.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1ed8093b44e8..778c177b5bfb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2916,6 +2916,7 @@ int snd_soc_register_card(struct snd_soc_card *card)
 		card->rtd[i].dai_link = &card->dai_link[i];
 
 	INIT_LIST_HEAD(&card->list);
+	INIT_LIST_HEAD(&card->dapm_dirty);
 	card->instantiated = 0;
 	mutex_init(&card->mutex);
 

commit 0b07ab9244d34929b6e07d6a275137a229e9c839
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Sep 28 20:12:01 2011 +0100

    ASoC: Instantiate DAPM widgets before we do the DAI link init
    
    The DAI init function may want to do something that needs the widgets to
    be instantiated.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a58c1fc966eb..1ed8093b44e8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1059,6 +1059,9 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	temp = codec->name_prefix;
 	codec->name_prefix = NULL;
 
+	/* Make sure all DAPM widgets are instantiated */
+	snd_soc_dapm_new_widgets(&codec->dapm);
+
 	/* do machine specific initialization */
 	if (!dailess && dai_link->init)
 		ret = dai_link->init(rtd);
@@ -1070,9 +1073,6 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	}
 	codec->name_prefix = temp;
 
-	/* Make sure all DAPM widgets are instantiated */
-	snd_soc_dapm_new_widgets(&codec->dapm);
-
 	/* register the rtd device */
 	rtd->codec = codec;
 	rtd->dev.parent = card->dev;

commit 75d9ac46b99280f5f381927ae75a9eaf21844d20
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 27 16:41:01 2011 +0100

    ASoC: Allow DAI formats to be specified in the dai_link
    
    For almost all machines the DAI format is a constant, always set to the
    same thing. This means that not only should we normally set it on init
    rather than in hw_params() (where it has been for historical reasons) we
    should also allow users to configure this by setting a variable in the
    dai_link structure. The combination of these two will make many machine
    drivers even more data driven.
    
    Implement a new dai_fmt field in the dai_link doing just that. Since 0 is
    a valid value for many format flags and we need to be able to tell if the
    field is actually set also add one to all the values used to configure
    formats.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bd20154e8b34..a58c1fc966eb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1317,6 +1317,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	struct snd_soc_codec *codec;
 	struct snd_soc_codec_conf *codec_conf;
 	enum snd_soc_compress_type compress_type;
+	struct snd_soc_dai_link *dai_link;
 	int ret, i, order;
 
 	mutex_lock(&card->mutex);
@@ -1429,6 +1430,26 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 					card->num_dapm_routes);
 
+	for (i = 0; i < card->num_links; i++) {
+		dai_link = &card->dai_link[i];
+
+		if (dai_link->dai_fmt) {
+			ret = snd_soc_dai_set_fmt(card->rtd[i].codec_dai,
+						  dai_link->dai_fmt);
+			if (ret != 0)
+				dev_warn(card->rtd[i].codec_dai->dev,
+					 "Failed to set DAI format: %d\n",
+					 ret);
+
+			ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai,
+						  dai_link->dai_fmt);
+			if (ret != 0)
+				dev_warn(card->rtd[i].cpu_dai->dev,
+					 "Failed to set DAI format: %d\n",
+					 ret);
+		}
+	}
+
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
 		 "%s", card->name);
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),

commit 92868de6245197cc06c0e66ab794cf159827281b
Merge: 7c81beb048b4 f0e8ed858edb
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Sep 21 14:54:34 2011 +0100

    Merge branch 'for-3.1' into for-3.2

commit f0e8ed858edb327802ee65fd695cc1538286226f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 20 11:41:54 2011 +0100

    ASoC: Ensure we generate a driver name
    
    Commit 873bd4c (ASoC: Don't set invalid name string to snd_card->driver
    field) broke generation of a driver name for all ASoC cards relying on the
    automatic generation of one. Fix this by using the old default with spaces
    replaced by underscores.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d2ef014af215..ef69f5a02709 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -30,6 +30,7 @@
 #include <linux/bitops.h>
 #include <linux/debugfs.h>
 #include <linux/platform_device.h>
+#include <linux/ctype.h>
 #include <linux/slab.h>
 #include <sound/ac97_codec.h>
 #include <sound/core.h>
@@ -1434,9 +1435,20 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		 "%s", card->name);
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
 		 "%s", card->long_name ? card->long_name : card->name);
-	if (card->driver_name)
-		strlcpy(card->snd_card->driver, card->driver_name,
-			sizeof(card->snd_card->driver));
+	snprintf(card->snd_card->driver, sizeof(card->snd_card->driver),
+		 "%s", card->driver_name ? card->driver_name : card->name);
+	for (i = 0; i < ARRAY_SIZE(card->snd_card->driver); i++) {
+		switch (card->snd_card->driver[i]) {
+		case '_':
+		case '-':
+		case '\0':
+			break;
+		default:
+			if (!isalnum(card->snd_card->driver[i]))
+				card->snd_card->driver[i] = '_';
+			break;
+		}
+	}
 
 	if (card->late_probe) {
 		ret = card->late_probe(card);

commit 3ed464659a1d83a87f4ef79fab4d85a8dcf677c9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 6 16:39:17 2011 -0700

    ASoC: Remove unused step size from debugfs CODEC write function
    
    We don't use the step size so there's no need to work it out.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4ec93d1df047..10e5cdeeb18e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -244,7 +244,6 @@ static ssize_t codec_reg_write_file(struct file *file,
 	size_t buf_size;
 	char *start = buf;
 	unsigned long reg, value;
-	int step = 1;
 	struct snd_soc_codec *codec = file->private_data;
 
 	buf_size = min(count, (sizeof(buf)-1));
@@ -252,9 +251,6 @@ static ssize_t codec_reg_write_file(struct file *file,
 		return -EFAULT;
 	buf[buf_size] = 0;
 
-	if (codec->driver->reg_cache_step)
-		step = codec->driver->reg_cache_step;
-
 	while (*start == ' ')
 		start++;
 	reg = simple_strtoul(start, &start, 16);

commit da1c6ea6cf85544292c30295c70a89e8555358bc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Aug 24 20:09:01 2011 +0100

    ASoC: Allow source specification for CODEC level sysclk
    
    Similarly to PLLs/FLLs some modern CODECs provide selectable system clock
    sources. When the clock is the clock for a DAI we do not usually need to
    identify which clock is being configured so can use clk_id for the source
    clock but with CODEC wide system clocks we will need to specify both the
    clock being configured and the source.
    
    Add a source argument to the CODEC driver set_sysclk() operation to
    reflect this. As this operation is not as widely used as the DAI
    set_sysclk() operation the change is not very invasive. We probably
    ought to go and make the same alternation for DAIs at some point.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fc7fff3604f7..4ec93d1df047 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2670,7 +2670,7 @@ int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 	if (dai->driver && dai->driver->ops->set_sysclk)
 		return dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
 	else if (dai->codec && dai->codec->driver->set_sysclk)
-		return dai->codec->driver->set_sysclk(dai->codec, clk_id,
+		return dai->codec->driver->set_sysclk(dai->codec, clk_id, 0,
 						      freq, dir);
 	else
 		return -EINVAL;
@@ -2681,16 +2681,18 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
  * snd_soc_codec_set_sysclk - configure CODEC system or master clock.
  * @codec: CODEC
  * @clk_id: DAI specific clock ID
+ * @source: Source for the clock
  * @freq: new clock frequency in Hz
  * @dir: new clock direction - input/output.
  *
  * Configures the CODEC master (MCLK) or system (SYSCLK) clocking.
  */
 int snd_soc_codec_set_sysclk(struct snd_soc_codec *codec, int clk_id,
-	unsigned int freq, int dir)
+			     int source, unsigned int freq, int dir)
 {
 	if (codec->driver->set_sysclk)
-		return codec->driver->set_sysclk(codec, clk_id, freq, dir);
+		return codec->driver->set_sysclk(codec, clk_id, source,
+						 freq, dir);
 	else
 		return -EINVAL;
 }

commit b92d150baeb876cbf0fd4cc8d997f005cc57e3f4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 27 18:24:14 2011 +0200

    ASoC: soc_codec_reg_show use snd_soc_codec_readable_register
    
    Use snd_soc_codec_readable_register instead of open-coding it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4065d4e84ea3..fc7fff3604f7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -143,7 +143,7 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf,
 		step = codec->driver->reg_cache_step;
 
 	for (i = 0; i < codec->driver->reg_cache_size; i += step) {
-		if (codec->readable_register && !codec->readable_register(codec, i))
+		if (!snd_soc_codec_readable_register(codec, i))
 			continue;
 		if (codec->driver->display_register) {
 			count += codec->driver->display_register(codec, buf + count,

commit 0f8dd4ce4775806196300dc075ba8d4f1f9b605d
Merge: 35dcf58634cf 6c5b756aaa3e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Aug 31 09:46:42 2011 +0100

    Merge branch 'for-3.1' into for-3.2

commit 63fa0a288cfedca681175fe13cf15677e944cdb2
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Aug 27 18:24:12 2011 +0200

    ASoC: snd_soc_codec_{readable,writable}_register change default to true
    
    Change the default return value of snd_soc_codec_{readable,writable}_register to
    true when no codec specific callback for this function is given. Otherwise all
    registers of that codec will neither be readable nor writable, which is most
    certainly not what we want.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b085d8e87574..d2ef014af215 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1633,7 +1633,7 @@ int snd_soc_codec_readable_register(struct snd_soc_codec *codec,
 	if (codec->readable_register)
 		return codec->readable_register(codec, reg);
 	else
-		return 0;
+		return 1;
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_readable_register);
 
@@ -1651,7 +1651,7 @@ int snd_soc_codec_writable_register(struct snd_soc_codec *codec,
 	if (codec->writable_register)
 		return codec->writable_register(codec, reg);
 	else
-		return 0;
+		return 1;
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_writable_register);
 

commit 09d930ae5198fbb67b86d3d058ad82211f469a46
Merge: 33c5f969b969 c09f5ca7bdc9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 22 23:33:01 2011 +0100

    Merge branch 'for-3.1' into for-3.2

commit 57cf9d4512c86a4a1b58857ca22b18bffbfd6812
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sat Aug 20 11:03:44 2011 +0800

    ASoC: soc-core: use GFP_KERNEL flag for kmalloc in snd_soc_cnew
    
    GFP_ATOMIC is not needed here, use GFP_KERNEL instead.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 83ad8ca27490..b085d8e87574 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1913,7 +1913,7 @@ struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
 
 	if (prefix) {
 		name_len = strlen(long_name) + strlen(prefix) + 2;
-		name = kmalloc(name_len, GFP_ATOMIC);
+		name = kmalloc(name_len, GFP_KERNEL);
 		if (!name)
 			return NULL;
 

commit 33c5f969b969c277e96cd9e9bf8472c4b8709c25
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 22 18:40:30 2011 +0100

    ASoC: Allow idle_bias_off to be specified in CODEC drivers
    
    If devices can unconditionally support idle_bias_off let them flag it in
    their driver structure.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ae93aa81244c..f8f985a4f2a8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -956,6 +956,8 @@ static int soc_probe_codec(struct snd_soc_card *card,
 		snd_soc_dapm_new_controls(&codec->dapm, driver->dapm_widgets,
 					  driver->num_dapm_widgets);
 
+	codec->dapm.idle_bias_off = driver->idle_bias_off;
+
 	if (driver->probe) {
 		ret = driver->probe(codec);
 		if (ret < 0) {

commit 25032c119e5f43725b624ab30e2ccb8c23b9ebd3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 1 13:52:48 2011 +0900

    ASoC: Trivial formatting fix in soc-core.c
    
    Utterly trivial but it annoys me.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9d3935bbbd0c..ae93aa81244c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -105,7 +105,7 @@ static int format_register_str(struct snd_soc_codec *codec,
 	if (wordsize + regsize + 2 + 1 != len)
 		return -EINVAL;
 
-	ret = snd_soc_read(codec , reg);
+	ret = snd_soc_read(codec, reg);
 	if (ret < 0) {
 		memset(regbuf, 'X', regsize);
 		regbuf[regsize] = '\0';

commit 64a648c2204b0c750fe49828158751183d8b5f83
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Jul 25 11:15:15 2011 +0100

    ASoC: dapm - Add DAPM stream completion event.
    
    In preparation for Dynamic PCM (AKA DSP) support.
    
    This adds a callback function to be called at the completion of a DAPM stream
    event.
    
    This can be used by DSP components to perform calculations based on DAPM graphs
    after completion of stream events.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 83ad8ca27490..9d3935bbbd0c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3141,6 +3141,7 @@ int snd_soc_register_platform(struct device *dev,
 	platform->driver = platform_drv;
 	platform->dapm.dev = dev;
 	platform->dapm.platform = platform;
+	platform->dapm.stream_event = platform_drv->stream_event;
 
 	mutex_lock(&client_mutex);
 	list_add(&platform->list, &platform_list);
@@ -3253,6 +3254,7 @@ int snd_soc_register_codec(struct device *dev,
 	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;
 	codec->dapm.seq_notifier = codec_drv->seq_notifier;
+	codec->dapm.stream_event = codec_drv->stream_event;
 	codec->dev = dev;
 	codec->driver = codec_drv;
 	codec->num_dai = num_dai;

commit 1c8371d61e3a8e65fe6ef4ac535d1cd6d8ec7650
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Sun Jul 17 18:00:26 2011 +0200

    ASoC: core: make comments fit the code
    
    In one comment, cpu_dai was mentioned although codec_dai was used in the
    code. Also, fix the name for the card dai list which has no seperation
    into card_dai and codec_dai.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 93109a4e2bc8..83ad8ca27490 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1141,7 +1141,7 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 			}
 		}
 		cpu_dai->probed = 1;
-		/* mark cpu_dai as probed and add to card cpu_dai list */
+		/* mark cpu_dai as probed and add to card dai list */
 		list_add(&cpu_dai->card_list, &card->dai_dev_list);
 	}
 
@@ -1172,7 +1172,7 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 			}
 		}
 
-		/* mark cpu_dai as probed and add to card cpu_dai list */
+		/* mark codec_dai as probed and add to card dai list */
 		codec_dai->probed = 1;
 		list_add(&codec_dai->card_list, &card->dai_dev_list);
 	}

commit 7be4ba24a3ea53bc8ade841635e4d4a59e98ceb5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jul 18 13:17:13 2011 +0900

    ASoC: Mark cache as dirty when suspending
    
    Since quite a few drivers are not managing to flag the cache as needing
    to be resynced after suspend and it's a reasonable thing to do flag the
    cache as needing sync automatically when suspending.
    
    The expectation is that systems will mainly only keep the CODEC powered
    when doing audio through the CODEC so we won't actually suspend the
    device anyway; drivers which want to can override this behaviour when
    they resume.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Cc: stable@kernel.org

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e44267f66216..93109a4e2bc8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -577,6 +577,7 @@ int snd_soc_suspend(struct device *dev)
 			case SND_SOC_BIAS_OFF:
 				codec->driver->suspend(codec, PMSG_SUSPEND);
 				codec->suspended = 1;
+				codec->cache_sync = 1;
 				break;
 			default:
 				dev_dbg(codec->dev, "CODEC is on over suspend\n");

commit 71ae391d45bf5d983c3cdabfa83e2afa3c99c5ab
Merge: b5d5f59be2ac 18361bbe3180
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Jul 9 18:20:36 2011 +0900

    Merge branch 'for-3.0' into for-3.1

commit a82ce2ae0d91cfa261cbe6f27f4031963ace097c
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Jul 4 22:10:50 2011 +0100

    ASoC: core - Add platform IO tracing
    
    Trace platform IO just like CODEC IO.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3049c37b14e0..70f477941892 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1665,6 +1665,7 @@ int snd_soc_platform_read(struct snd_soc_platform *platform,
 
 	ret = platform->driver->read(platform, reg);
 	dev_dbg(platform->dev, "read %x => %x\n", reg, ret);
+	trace_snd_soc_preg_read(platform, reg, ret);
 
 	return ret;
 }
@@ -1679,6 +1680,7 @@ int snd_soc_platform_write(struct snd_soc_platform *platform,
 	}
 
 	dev_dbg(platform->dev, "write %x = %x\n", reg, val);
+	trace_snd_soc_preg_write(platform, reg, val);
 	return platform->driver->write(platform, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_platform_write);

commit cb2cf612fbdf457291b6e47064fed24f0dfdd9a5
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Jul 4 22:10:53 2011 +0100

    ASoC: core - Add convenience register for platform kcontrol and DAPM
    
    Allow platform probe to register platform kcontrols and DAPM just like
    the CODEC probe().
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 38f954af7bb5..3049c37b14e0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -998,6 +998,10 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	if (!try_module_get(platform->dev->driver->owner))
 		return -ENODEV;
 
+	if (driver->dapm_widgets)
+		snd_soc_dapm_new_controls(&platform->dapm,
+			driver->dapm_widgets, driver->num_dapm_widgets);
+
 	if (driver->probe) {
 		ret = driver->probe(platform);
 		if (ret < 0) {
@@ -1008,6 +1012,13 @@ static int soc_probe_platform(struct snd_soc_card *card,
 		}
 	}
 
+	if (driver->controls)
+		snd_soc_add_platform_controls(platform, driver->controls,
+				     driver->num_controls);
+	if (driver->dapm_routes)
+		snd_soc_dapm_add_routes(&platform->dapm, driver->dapm_routes,
+					driver->num_dapm_routes);
+
 	/* mark platform as probed and add to card platform list */
 	platform->probed = 1;
 	list_add(&platform->card_list, &card->platform_dev_list);

commit b7950641374ddb41e9a03ff61b43f9ab3fcf763d
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Jul 4 22:10:52 2011 +0100

    ASoC: core - Add platform widget IO
    
    Allow platform driver widgets to perform any IO required for DAPM.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 16651814ecba..38f954af7bb5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -993,6 +993,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	const struct snd_soc_platform_driver *driver = platform->driver;
 
 	platform->card = card;
+	platform->dapm.card = card;
 
 	if (!try_module_get(platform->dev->driver->owner))
 		return -ENODEV;
@@ -1010,6 +1011,7 @@ static int soc_probe_platform(struct snd_soc_card *card,
 	/* mark platform as probed and add to card platform list */
 	platform->probed = 1;
 	list_add(&platform->card_list, &card->platform_dev_list);
+	list_add(&platform->dapm.list, &card->dapm_list);
 
 	return 0;
 
@@ -3122,6 +3124,8 @@ int snd_soc_register_platform(struct device *dev,
 
 	platform->dev = dev;
 	platform->driver = platform_drv;
+	platform->dapm.dev = dev;
+	platform->dapm.platform = platform;
 
 	mutex_lock(&client_mutex);
 	list_add(&platform->list, &platform_list);

commit a491a5c84f34febfebd4cb0b8c9add97977efa97
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Jul 4 22:10:51 2011 +0100

    ASoC: core - Add API call to register platform kcontrols.
    
    In preparation for Dynamic PCM (AKA DSP) support.
    
    Allow platform drivers to register kcontrols.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d08abf4e3eb3..16651814ecba 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1948,6 +1948,36 @@ int snd_soc_add_controls(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_add_controls);
 
+/**
+ * snd_soc_add_platform_controls - add an array of controls to a platform.
+ * Convienience function to add a list of controls.
+ *
+ * @platform: platform to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
+	const struct snd_kcontrol_new *controls, int num_controls)
+{
+	struct snd_card *card = platform->card->snd_card;
+	int err, i;
+
+	for (i = 0; i < num_controls; i++) {
+		const struct snd_kcontrol_new *control = &controls[i];
+		err = snd_ctl_add(card, snd_soc_cnew(control, platform,
+				control->name, NULL));
+		if (err < 0) {
+			dev_err(platform->dev, "Failed to add %s %d\n",control->name, err);
+			return err;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);
+
 /**
  * snd_soc_info_enum_double - enumerated double mixer info callback
  * @kcontrol: mixer control

commit 873bd4cb4fbba6a3e99f750e17ef2ba6ef96e9d3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 5 09:25:59 2011 +0200

    ASoC: Don't set invalid name string to snd_card->driver field
    
    The snd_card->driver field contains a driver name string, and in
    general it shouldn't contain space or special letters.  The commit
    2b39535b9e54888649923beaab443af212b6c0fd changed the string copy from
    card->name, but the long name string may contain such letters, thus
    it may still lead to a segfault.
    
    A temporary fix is not to copy the long name string but just keep it
    empty as the earlier version did.
    
    Reported-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d75043ed7fc0..b194be09e74d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1929,8 +1929,9 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		 "%s", card->name);
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
 		 "%s", card->long_name ? card->long_name : card->name);
-	snprintf(card->snd_card->driver, sizeof(card->snd_card->driver),
-		 "%s", card->driver_name ? card->driver_name : card->name);
+	if (card->driver_name)
+		strlcpy(card->snd_card->driver, card->driver_name,
+			sizeof(card->snd_card->driver));
 
 	if (card->late_probe) {
 		ret = card->late_probe(card);

commit f1442bc1e9bd5ff4c2470d66075d066e535a2c86
Author: Liam Girdwood <lrg@ti.com>
Date:   Mon Jul 4 11:10:15 2011 +0100

    ASoC: core - Add platform read and write.
    
    In preparation for ASoC Dynamic PCM (AKA DSP) support.
    
    Allow platform driver to perform IO. Intended for platform DAPM.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d49f0ed56f9c..d08abf4e3eb3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1640,6 +1640,36 @@ int snd_soc_codec_writable_register(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_writable_register);
 
+int snd_soc_platform_read(struct snd_soc_platform *platform,
+					unsigned int reg)
+{
+	unsigned int ret;
+
+	if (!platform->driver->read) {
+		dev_err(platform->dev, "platform has no read back\n");
+		return -1;
+	}
+
+	ret = platform->driver->read(platform, reg);
+	dev_dbg(platform->dev, "read %x => %x\n", reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_platform_read);
+
+int snd_soc_platform_write(struct snd_soc_platform *platform,
+					 unsigned int reg, unsigned int val)
+{
+	if (!platform->driver->write) {
+		dev_err(platform->dev, "platform has no write back\n");
+		return -1;
+	}
+
+	dev_dbg(platform->dev, "write %x = %x\n", reg, val);
+	return platform->driver->write(platform, reg, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_platform_write);
+
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec

commit 956245e9cd229138ad26521c326650eed8b88333
Author: Liam Girdwood <lrg@ti.com>
Date:   Fri Jul 1 16:54:08 2011 +0100

    ASoC: core - Make platform probe more like codec probe.
    
    In preparation for ASoC dynamic PCM support (AKA ASoC DSP)
    
    Platform will also support DAPM so separate out the probe function
    to simplify the code (just like the codec probe).
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 32bc50387f61..d49f0ed56f9c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -986,6 +986,39 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	return ret;
 }
 
+static int soc_probe_platform(struct snd_soc_card *card,
+			   struct snd_soc_platform *platform)
+{
+	int ret = 0;
+	const struct snd_soc_platform_driver *driver = platform->driver;
+
+	platform->card = card;
+
+	if (!try_module_get(platform->dev->driver->owner))
+		return -ENODEV;
+
+	if (driver->probe) {
+		ret = driver->probe(platform);
+		if (ret < 0) {
+			dev_err(platform->dev,
+				"asoc: failed to probe platform %s: %d\n",
+				platform->name, ret);
+			goto err_probe;
+		}
+	}
+
+	/* mark platform as probed and add to card platform list */
+	platform->probed = 1;
+	list_add(&platform->card_list, &card->platform_dev_list);
+
+	return 0;
+
+err_probe:
+	module_put(platform->dev->driver->owner);
+
+	return ret;
+}
+
 static void rtd_release(struct device *dev) {}
 
 static int soc_post_component_init(struct snd_soc_card *card,
@@ -1109,21 +1142,9 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 	/* probe the platform */
 	if (!platform->probed &&
 			platform->driver->probe_order == order) {
-		if (!try_module_get(platform->dev->driver->owner))
-			return -ENODEV;
-
-		if (platform->driver->probe) {
-			ret = platform->driver->probe(platform);
-			if (ret < 0) {
-				printk(KERN_ERR "asoc: failed to probe platform %s\n",
-						platform->name);
-				module_put(platform->dev->driver->owner);
-				return ret;
-			}
-		}
-		/* mark platform as probed and add to card platform list */
-		platform->probed = 1;
-		list_add(&platform->card_list, &card->platform_dev_list);
+		ret = soc_probe_platform(card, platform);
+		if (ret < 0)
+			return ret;
 	}
 
 	/* probe the CODEC DAI */

commit b8c0dab9bf3373010e857a8d3f1b594c60a348dd
Author: Liam Girdwood <lrg@ti.com>
Date:   Thu Jun 9 17:04:39 2011 +0100

    ASoC: core - PCM mutex per rtd
    
    In preparation for the new ASoC Dynamic PCM support (AKA DSP support).
    
    The new ASoC Dynamic PCM core allows DAIs to be dynamically re-routed
    at runtime between the PCM device end (or Frontend - FE) and the physical DAI
    (Backend - BE) using regular kcontrols (just like a hardware CODEC routes
    audio in the analog domain). The Dynamic PCM core therefore must be
    able to call PCM operations for both the Frontend and Backend(s) DAIs at
    the same time.
    
    Currently we have a global pcm_mutex that is used to serialise
    the ASoC PCM operations. This patch removes the global mutex
    and adds a mutex per RTD allowing the PCM operations to be reentrant and
    allow control of more than one DAI at at time. e.g. a frontend PCM hw_params()
    could configure multiple backend DAI hw_params() with similar or different
    hw parameters at the same time.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 32d7d2f8147c..32bc50387f61 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1032,6 +1032,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	rtd->dev.parent = card->dev;
 	rtd->dev.release = rtd_release;
 	rtd->dev.init_name = name;
+	mutex_init(&rtd->pcm_mutex);
 	ret = device_register(&rtd->dev);
 	if (ret < 0) {
 		dev_err(card->dev,

commit ddee627cf6bb601aa980104fc17d4f84201380be
Author: Liam Girdwood <lrg@ti.com>
Date:   Thu Jun 9 14:45:53 2011 +0100

    ASoC: core - Separate out PCM operations into new file.
    
    In preparation for Dynamic PCM support (AKA DSP support).
    
    There will be future patches that add support to allow PCMs to be dynamically
    routed to multiple DAIs at startup and also during stream runtime. This patch
    moves the ASoC core PCM operaitions into a new file called soc-pcm.c.  This will
    in simplify the ASoC core features into distinct files.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index df5608db3350..32d7d2f8147c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -44,7 +44,6 @@
 
 #define NAME_SIZE	32
 
-static DEFINE_MUTEX(pcm_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 
 #ifdef CONFIG_DEBUG_FS
@@ -58,7 +57,7 @@ static LIST_HEAD(dai_list);
 static LIST_HEAD(platform_list);
 static LIST_HEAD(codec_list);
 
-static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num);
+int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num);
 
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
@@ -485,552 +484,6 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 }
 #endif
 
-static int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	int ret;
-
-	if (!codec_dai->driver->symmetric_rates &&
-	    !cpu_dai->driver->symmetric_rates &&
-	    !rtd->dai_link->symmetric_rates)
-		return 0;
-
-	/* This can happen if multiple streams are starting simultaneously -
-	 * the second can need to get its constraints before the first has
-	 * picked a rate.  Complain and allow the application to carry on.
-	 */
-	if (!rtd->rate) {
-		dev_warn(&rtd->dev,
-			 "Not enforcing symmetric_rates due to race\n");
-		return 0;
-	}
-
-	dev_dbg(&rtd->dev, "Symmetry forces %dHz rate\n", rtd->rate);
-
-	ret = snd_pcm_hw_constraint_minmax(substream->runtime,
-					   SNDRV_PCM_HW_PARAM_RATE,
-					   rtd->rate, rtd->rate);
-	if (ret < 0) {
-		dev_err(&rtd->dev,
-			"Unable to apply rate symmetry constraint: %d\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-/*
- * Called by ALSA when a PCM substream is opened, the runtime->hw record is
- * then initialized and any private data can be allocated. This also calls
- * startup for the cpu DAI, platform, machine and codec DAI.
- */
-static int soc_pcm_open(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_dai_driver *cpu_dai_drv = cpu_dai->driver;
-	struct snd_soc_dai_driver *codec_dai_drv = codec_dai->driver;
-	int ret = 0;
-
-	mutex_lock(&pcm_mutex);
-
-	/* startup the audio subsystem */
-	if (cpu_dai->driver->ops->startup) {
-		ret = cpu_dai->driver->ops->startup(substream, cpu_dai);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: can't open interface %s\n",
-				cpu_dai->name);
-			goto out;
-		}
-	}
-
-	if (platform->driver->ops && platform->driver->ops->open) {
-		ret = platform->driver->ops->open(substream);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: can't open platform %s\n", platform->name);
-			goto platform_err;
-		}
-	}
-
-	if (codec_dai->driver->ops->startup) {
-		ret = codec_dai->driver->ops->startup(substream, codec_dai);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: can't open codec %s\n",
-				codec_dai->name);
-			goto codec_dai_err;
-		}
-	}
-
-	if (rtd->dai_link->ops && rtd->dai_link->ops->startup) {
-		ret = rtd->dai_link->ops->startup(substream);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: %s startup failed\n", rtd->dai_link->name);
-			goto machine_err;
-		}
-	}
-
-	/* Check that the codec and cpu DAIs are compatible */
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		runtime->hw.rate_min =
-			max(codec_dai_drv->playback.rate_min,
-			    cpu_dai_drv->playback.rate_min);
-		runtime->hw.rate_max =
-			min(codec_dai_drv->playback.rate_max,
-			    cpu_dai_drv->playback.rate_max);
-		runtime->hw.channels_min =
-			max(codec_dai_drv->playback.channels_min,
-				cpu_dai_drv->playback.channels_min);
-		runtime->hw.channels_max =
-			min(codec_dai_drv->playback.channels_max,
-				cpu_dai_drv->playback.channels_max);
-		runtime->hw.formats =
-			codec_dai_drv->playback.formats & cpu_dai_drv->playback.formats;
-		runtime->hw.rates =
-			codec_dai_drv->playback.rates & cpu_dai_drv->playback.rates;
-		if (codec_dai_drv->playback.rates
-			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
-			runtime->hw.rates |= cpu_dai_drv->playback.rates;
-		if (cpu_dai_drv->playback.rates
-			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
-			runtime->hw.rates |= codec_dai_drv->playback.rates;
-	} else {
-		runtime->hw.rate_min =
-			max(codec_dai_drv->capture.rate_min,
-			    cpu_dai_drv->capture.rate_min);
-		runtime->hw.rate_max =
-			min(codec_dai_drv->capture.rate_max,
-			    cpu_dai_drv->capture.rate_max);
-		runtime->hw.channels_min =
-			max(codec_dai_drv->capture.channels_min,
-				cpu_dai_drv->capture.channels_min);
-		runtime->hw.channels_max =
-			min(codec_dai_drv->capture.channels_max,
-				cpu_dai_drv->capture.channels_max);
-		runtime->hw.formats =
-			codec_dai_drv->capture.formats & cpu_dai_drv->capture.formats;
-		runtime->hw.rates =
-			codec_dai_drv->capture.rates & cpu_dai_drv->capture.rates;
-		if (codec_dai_drv->capture.rates
-			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
-			runtime->hw.rates |= cpu_dai_drv->capture.rates;
-		if (cpu_dai_drv->capture.rates
-			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
-			runtime->hw.rates |= codec_dai_drv->capture.rates;
-	}
-
-	ret = -EINVAL;
-	snd_pcm_limit_hw_rates(runtime);
-	if (!runtime->hw.rates) {
-		printk(KERN_ERR "asoc: %s <-> %s No matching rates\n",
-			codec_dai->name, cpu_dai->name);
-		goto config_err;
-	}
-	if (!runtime->hw.formats) {
-		printk(KERN_ERR "asoc: %s <-> %s No matching formats\n",
-			codec_dai->name, cpu_dai->name);
-		goto config_err;
-	}
-	if (!runtime->hw.channels_min || !runtime->hw.channels_max ||
-	    runtime->hw.channels_min > runtime->hw.channels_max) {
-		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",
-				codec_dai->name, cpu_dai->name);
-		goto config_err;
-	}
-
-	/* Symmetry only applies if we've already got an active stream. */
-	if (cpu_dai->active || codec_dai->active) {
-		ret = soc_pcm_apply_symmetry(substream);
-		if (ret != 0)
-			goto config_err;
-	}
-
-	pr_debug("asoc: %s <-> %s info:\n",
-			codec_dai->name, cpu_dai->name);
-	pr_debug("asoc: rate mask 0x%x\n", runtime->hw.rates);
-	pr_debug("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
-		 runtime->hw.channels_max);
-	pr_debug("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
-		 runtime->hw.rate_max);
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		cpu_dai->playback_active++;
-		codec_dai->playback_active++;
-	} else {
-		cpu_dai->capture_active++;
-		codec_dai->capture_active++;
-	}
-	cpu_dai->active++;
-	codec_dai->active++;
-	rtd->codec->active++;
-	mutex_unlock(&pcm_mutex);
-	return 0;
-
-config_err:
-	if (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)
-		rtd->dai_link->ops->shutdown(substream);
-
-machine_err:
-	if (codec_dai->driver->ops->shutdown)
-		codec_dai->driver->ops->shutdown(substream, codec_dai);
-
-codec_dai_err:
-	if (platform->driver->ops && platform->driver->ops->close)
-		platform->driver->ops->close(substream);
-
-platform_err:
-	if (cpu_dai->driver->ops->shutdown)
-		cpu_dai->driver->ops->shutdown(substream, cpu_dai);
-out:
-	mutex_unlock(&pcm_mutex);
-	return ret;
-}
-
-/*
- * Power down the audio subsystem pmdown_time msecs after close is called.
- * This is to ensure there are no pops or clicks in between any music tracks
- * due to DAPM power cycling.
- */
-static void close_delayed_work(struct work_struct *work)
-{
-	struct snd_soc_pcm_runtime *rtd =
-			container_of(work, struct snd_soc_pcm_runtime, delayed_work.work);
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-
-	mutex_lock(&pcm_mutex);
-
-	pr_debug("pop wq checking: %s status: %s waiting: %s\n",
-		 codec_dai->driver->playback.stream_name,
-		 codec_dai->playback_active ? "active" : "inactive",
-		 codec_dai->pop_wait ? "yes" : "no");
-
-	/* are we waiting on this codec DAI stream */
-	if (codec_dai->pop_wait == 1) {
-		codec_dai->pop_wait = 0;
-		snd_soc_dapm_stream_event(rtd,
-			codec_dai->driver->playback.stream_name,
-			SND_SOC_DAPM_STREAM_STOP);
-	}
-
-	mutex_unlock(&pcm_mutex);
-}
-
-/*
- * Called by ALSA when a PCM substream is closed. Private data can be
- * freed here. The cpu DAI, codec DAI, machine and platform are also
- * shutdown.
- */
-static int soc_codec_close(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = rtd->codec;
-
-	mutex_lock(&pcm_mutex);
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		cpu_dai->playback_active--;
-		codec_dai->playback_active--;
-	} else {
-		cpu_dai->capture_active--;
-		codec_dai->capture_active--;
-	}
-
-	cpu_dai->active--;
-	codec_dai->active--;
-	codec->active--;
-
-	/* Muting the DAC suppresses artifacts caused during digital
-	 * shutdown, for example from stopping clocks.
-	 */
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		snd_soc_dai_digital_mute(codec_dai, 1);
-
-	if (cpu_dai->driver->ops->shutdown)
-		cpu_dai->driver->ops->shutdown(substream, cpu_dai);
-
-	if (codec_dai->driver->ops->shutdown)
-		codec_dai->driver->ops->shutdown(substream, codec_dai);
-
-	if (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)
-		rtd->dai_link->ops->shutdown(substream);
-
-	if (platform->driver->ops && platform->driver->ops->close)
-		platform->driver->ops->close(substream);
-	cpu_dai->runtime = NULL;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		/* start delayed pop wq here for playback streams */
-		codec_dai->pop_wait = 1;
-		schedule_delayed_work(&rtd->delayed_work,
-			msecs_to_jiffies(rtd->pmdown_time));
-	} else {
-		/* capture streams can be powered down now */
-		snd_soc_dapm_stream_event(rtd,
-			codec_dai->driver->capture.stream_name,
-			SND_SOC_DAPM_STREAM_STOP);
-	}
-
-	mutex_unlock(&pcm_mutex);
-	return 0;
-}
-
-/*
- * Called by ALSA when the PCM substream is prepared, can set format, sample
- * rate, etc.  This function is non atomic and can be called multiple times,
- * it can refer to the runtime info.
- */
-static int soc_pcm_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	int ret = 0;
-
-	mutex_lock(&pcm_mutex);
-
-	if (rtd->dai_link->ops && rtd->dai_link->ops->prepare) {
-		ret = rtd->dai_link->ops->prepare(substream);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: machine prepare error\n");
-			goto out;
-		}
-	}
-
-	if (platform->driver->ops && platform->driver->ops->prepare) {
-		ret = platform->driver->ops->prepare(substream);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: platform prepare error\n");
-			goto out;
-		}
-	}
-
-	if (codec_dai->driver->ops->prepare) {
-		ret = codec_dai->driver->ops->prepare(substream, codec_dai);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: codec DAI prepare error\n");
-			goto out;
-		}
-	}
-
-	if (cpu_dai->driver->ops->prepare) {
-		ret = cpu_dai->driver->ops->prepare(substream, cpu_dai);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: cpu DAI prepare error\n");
-			goto out;
-		}
-	}
-
-	/* cancel any delayed stream shutdown that is pending */
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
-	    codec_dai->pop_wait) {
-		codec_dai->pop_wait = 0;
-		cancel_delayed_work(&rtd->delayed_work);
-	}
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		snd_soc_dapm_stream_event(rtd,
-					  codec_dai->driver->playback.stream_name,
-					  SND_SOC_DAPM_STREAM_START);
-	else
-		snd_soc_dapm_stream_event(rtd,
-					  codec_dai->driver->capture.stream_name,
-					  SND_SOC_DAPM_STREAM_START);
-
-	snd_soc_dai_digital_mute(codec_dai, 0);
-
-out:
-	mutex_unlock(&pcm_mutex);
-	return ret;
-}
-
-/*
- * Called by ALSA when the hardware params are set by application. This
- * function can also be called multiple times and can allocate buffers
- * (using snd_pcm_lib_* ). It's non-atomic.
- */
-static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
-				struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	int ret = 0;
-
-	mutex_lock(&pcm_mutex);
-
-	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_params) {
-		ret = rtd->dai_link->ops->hw_params(substream, params);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: machine hw_params failed\n");
-			goto out;
-		}
-	}
-
-	if (codec_dai->driver->ops->hw_params) {
-		ret = codec_dai->driver->ops->hw_params(substream, params, codec_dai);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
-				codec_dai->name);
-			goto codec_err;
-		}
-	}
-
-	if (cpu_dai->driver->ops->hw_params) {
-		ret = cpu_dai->driver->ops->hw_params(substream, params, cpu_dai);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: interface %s hw params failed\n",
-				cpu_dai->name);
-			goto interface_err;
-		}
-	}
-
-	if (platform->driver->ops && platform->driver->ops->hw_params) {
-		ret = platform->driver->ops->hw_params(substream, params);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: platform %s hw params failed\n",
-				platform->name);
-			goto platform_err;
-		}
-	}
-
-	rtd->rate = params_rate(params);
-
-out:
-	mutex_unlock(&pcm_mutex);
-	return ret;
-
-platform_err:
-	if (cpu_dai->driver->ops->hw_free)
-		cpu_dai->driver->ops->hw_free(substream, cpu_dai);
-
-interface_err:
-	if (codec_dai->driver->ops->hw_free)
-		codec_dai->driver->ops->hw_free(substream, codec_dai);
-
-codec_err:
-	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)
-		rtd->dai_link->ops->hw_free(substream);
-
-	mutex_unlock(&pcm_mutex);
-	return ret;
-}
-
-/*
- * Frees resources allocated by hw_params, can be called multiple times
- */
-static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_codec *codec = rtd->codec;
-
-	mutex_lock(&pcm_mutex);
-
-	/* apply codec digital mute */
-	if (!codec->active)
-		snd_soc_dai_digital_mute(codec_dai, 1);
-
-	/* free any machine hw params */
-	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)
-		rtd->dai_link->ops->hw_free(substream);
-
-	/* free any DMA resources */
-	if (platform->driver->ops && platform->driver->ops->hw_free)
-		platform->driver->ops->hw_free(substream);
-
-	/* now free hw params for the DAIs  */
-	if (codec_dai->driver->ops->hw_free)
-		codec_dai->driver->ops->hw_free(substream, codec_dai);
-
-	if (cpu_dai->driver->ops->hw_free)
-		cpu_dai->driver->ops->hw_free(substream, cpu_dai);
-
-	mutex_unlock(&pcm_mutex);
-	return 0;
-}
-
-static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	int ret;
-
-	if (codec_dai->driver->ops->trigger) {
-		ret = codec_dai->driver->ops->trigger(substream, cmd, codec_dai);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (platform->driver->ops && platform->driver->ops->trigger) {
-		ret = platform->driver->ops->trigger(substream, cmd);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (cpu_dai->driver->ops->trigger) {
-		ret = cpu_dai->driver->ops->trigger(substream, cmd, cpu_dai);
-		if (ret < 0)
-			return ret;
-	}
-	return 0;
-}
-
-/*
- * soc level wrapper for pointer callback
- * If cpu_dai, codec_dai, platform driver has the delay callback, than
- * the runtime->delay will be updated accordingly.
- */
-static snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	snd_pcm_uframes_t offset = 0;
-	snd_pcm_sframes_t delay = 0;
-
-	if (platform->driver->ops && platform->driver->ops->pointer)
-		offset = platform->driver->ops->pointer(substream);
-
-	if (cpu_dai->driver->ops->delay)
-		delay += cpu_dai->driver->ops->delay(substream, cpu_dai);
-
-	if (codec_dai->driver->ops->delay)
-		delay += codec_dai->driver->ops->delay(substream, codec_dai);
-
-	if (platform->driver->delay)
-		delay += platform->driver->delay(substream, codec_dai);
-
-	runtime->delay = delay;
-
-	return offset;
-}
-
-/* ASoC PCM operations */
-static struct snd_pcm_ops soc_pcm_ops = {
-	.open		= soc_pcm_open,
-	.close		= soc_codec_close,
-	.hw_params	= soc_pcm_hw_params,
-	.hw_free	= soc_pcm_hw_free,
-	.prepare	= soc_pcm_prepare,
-	.trigger	= soc_pcm_trigger,
-	.pointer	= soc_pcm_pointer,
-};
-
 #ifdef CONFIG_PM_SLEEP
 /* powers down audio subsystem for suspend */
 int snd_soc_suspend(struct device *dev)
@@ -1692,9 +1145,6 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 	if (order != SND_SOC_COMP_ORDER_LAST)
 		return 0;
 
-	/* DAPM dai link stream work */
-	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
-
 	ret = soc_post_component_init(card, codec, num, 0);
 	if (ret)
 		return ret;
@@ -2114,66 +1564,6 @@ static struct platform_driver soc_driver = {
 	.remove		= soc_remove,
 };
 
-/* create a new pcm */
-static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
-{
-	struct snd_soc_codec *codec = rtd->codec;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
-	struct snd_pcm *pcm;
-	char new_name[64];
-	int ret = 0, playback = 0, capture = 0;
-
-	/* check client and interface hw capabilities */
-	snprintf(new_name, sizeof(new_name), "%s %s-%d",
-			rtd->dai_link->stream_name, codec_dai->name, num);
-
-	if (codec_dai->driver->playback.channels_min)
-		playback = 1;
-	if (codec_dai->driver->capture.channels_min)
-		capture = 1;
-
-	dev_dbg(rtd->card->dev, "registered pcm #%d %s\n",num,new_name);
-	ret = snd_pcm_new(rtd->card->snd_card, new_name,
-			num, playback, capture, &pcm);
-	if (ret < 0) {
-		printk(KERN_ERR "asoc: can't create pcm for codec %s\n", codec->name);
-		return ret;
-	}
-
-	rtd->pcm = pcm;
-	pcm->private_data = rtd;
-	if (platform->driver->ops) {
-		soc_pcm_ops.mmap = platform->driver->ops->mmap;
-		soc_pcm_ops.pointer = platform->driver->ops->pointer;
-		soc_pcm_ops.ioctl = platform->driver->ops->ioctl;
-		soc_pcm_ops.copy = platform->driver->ops->copy;
-		soc_pcm_ops.silence = platform->driver->ops->silence;
-		soc_pcm_ops.ack = platform->driver->ops->ack;
-		soc_pcm_ops.page = platform->driver->ops->page;
-	}
-
-	if (playback)
-		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
-
-	if (capture)
-		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &soc_pcm_ops);
-
-	if (platform->driver->pcm_new) {
-		ret = platform->driver->pcm_new(rtd);
-		if (ret < 0) {
-			pr_err("asoc: platform pcm constructor failed\n");
-			return ret;
-		}
-	}
-
-	pcm->private_free = platform->driver->pcm_free;
-	printk(KERN_INFO "asoc: %s <-> %s mapping ok\n", codec_dai->name,
-		cpu_dai->name);
-	return ret;
-}
-
 /**
  * snd_soc_codec_volatile_register: Report if a register is volatile.
  *

commit 0168bf0d130de83cd3532b834237c6228a6158dd
Author: Liam Girdwood <lrg@ti.com>
Date:   Tue Jun 7 16:08:05 2011 +0100

    ASoC: core - Allow components to probe/remove in sequence.
    
    Some ASoC components depend on other ASoC components to provide clocks and
    power resources in order to probe() and vice versa for remove().
    
    Allow components to be ordered so that components can be probed() and removed()
    in sequences that conform to their dependencies.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 29bf9fbd3e29..df5608db3350 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1394,7 +1394,7 @@ static void soc_remove_codec(struct snd_soc_codec *codec)
 	module_put(codec->dev->driver->owner);
 }
 
-static void soc_remove_dai_link(struct snd_soc_card *card, int num)
+static void soc_remove_dai_link(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_codec *codec = rtd->codec;
@@ -1411,7 +1411,8 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 	}
 
 	/* remove the CODEC DAI */
-	if (codec_dai && codec_dai->probed) {
+	if (codec_dai && codec_dai->probed &&
+			codec_dai->driver->remove_order == order) {
 		if (codec_dai->driver->remove) {
 			err = codec_dai->driver->remove(codec_dai);
 			if (err < 0)
@@ -1422,7 +1423,8 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 	}
 
 	/* remove the platform */
-	if (platform && platform->probed) {
+	if (platform && platform->probed &&
+			platform->driver->remove_order == order) {
 		if (platform->driver->remove) {
 			err = platform->driver->remove(platform);
 			if (err < 0)
@@ -1434,11 +1436,13 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 	}
 
 	/* remove the CODEC */
-	if (codec && codec->probed)
+	if (codec && codec->probed &&
+			codec->driver->remove_order == order)
 		soc_remove_codec(codec);
 
 	/* remove the cpu_dai */
-	if (cpu_dai && cpu_dai->probed) {
+	if (cpu_dai && cpu_dai->probed &&
+			cpu_dai->driver->remove_order == order) {
 		if (cpu_dai->driver->remove) {
 			err = cpu_dai->driver->remove(cpu_dai);
 			if (err < 0)
@@ -1452,11 +1456,13 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 
 static void soc_remove_dai_links(struct snd_soc_card *card)
 {
-	int i;
-
-	for (i = 0; i < card->num_rtd; i++)
-		soc_remove_dai_link(card, i);
+	int dai, order;
 
+	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
+			order++) {
+		for (dai = 0; dai < card->num_rtd; dai++)
+			soc_remove_dai_link(card, dai, order);
+	}
 	card->num_rtd = 0;
 }
 
@@ -1597,7 +1603,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	return 0;
 }
 
-static int soc_probe_dai_link(struct snd_soc_card *card, int num)
+static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
@@ -1606,7 +1612,8 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
 	int ret;
 
-	dev_dbg(card->dev, "probe %s dai link %d\n", card->name, num);
+	dev_dbg(card->dev, "probe %s dai link %d late %d\n",
+			card->name, num, order);
 
 	/* config components */
 	codec_dai->codec = codec;
@@ -1618,7 +1625,8 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	rtd->pmdown_time = pmdown_time;
 
 	/* probe the cpu_dai */
-	if (!cpu_dai->probed) {
+	if (!cpu_dai->probed &&
+			cpu_dai->driver->probe_order == order) {
 		if (!try_module_get(cpu_dai->dev->driver->owner))
 			return -ENODEV;
 
@@ -1637,14 +1645,16 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	}
 
 	/* probe the CODEC */
-	if (!codec->probed) {
+	if (!codec->probed &&
+			codec->driver->probe_order == order) {
 		ret = soc_probe_codec(card, codec);
 		if (ret < 0)
 			return ret;
 	}
 
 	/* probe the platform */
-	if (!platform->probed) {
+	if (!platform->probed &&
+			platform->driver->probe_order == order) {
 		if (!try_module_get(platform->dev->driver->owner))
 			return -ENODEV;
 
@@ -1663,7 +1673,7 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	}
 
 	/* probe the CODEC DAI */
-	if (!codec_dai->probed) {
+	if (!codec_dai->probed && codec_dai->driver->probe_order == order) {
 		if (codec_dai->driver->probe) {
 			ret = codec_dai->driver->probe(codec_dai);
 			if (ret < 0) {
@@ -1678,6 +1688,10 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 		list_add(&codec_dai->card_list, &card->dai_dev_list);
 	}
 
+	/* complete DAI probe during last probe */
+	if (order != SND_SOC_COMP_ORDER_LAST)
+		return 0;
+
 	/* DAPM dai link stream work */
 	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
 
@@ -1818,7 +1832,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	struct snd_soc_codec *codec;
 	struct snd_soc_codec_conf *codec_conf;
 	enum snd_soc_compress_type compress_type;
-	int ret, i;
+	int ret, i, order;
 
 	mutex_lock(&card->mutex);
 
@@ -1896,12 +1910,16 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 			goto card_probe_error;
 	}
 
-	for (i = 0; i < card->num_links; i++) {
-		ret = soc_probe_dai_link(card, i);
-		if (ret < 0) {
-			pr_err("asoc: failed to instantiate card %s: %d\n",
+	/* early DAI link probe */
+	for (order = SND_SOC_COMP_ORDER_FIRST; order <= SND_SOC_COMP_ORDER_LAST;
+			order++) {
+		for (i = 0; i < card->num_links; i++) {
+			ret = soc_probe_dai_link(card, i, order);
+			if (ret < 0) {
+				pr_err("asoc: failed to instantiate card %s: %d\n",
 			       card->name, ret);
-			goto probe_dai_err;
+				goto probe_dai_err;
+			}
 		}
 	}
 

commit 552d1ef6b5a98d7b95959d5b139071e3c90cebf1
Author: Liam Girdwood <lrg@ti.com>
Date:   Tue Jun 7 16:08:33 2011 +0100

    ASoC: core - Optimise and refactor pcm_new() to pass only rtd
    
    Currently pcm_new() passes in 3 arguments :- card, pcm and DAI.
    
    Refactor this to only pass in 1 argument (i.e. the rtd) since struct rtd contains
    card, pcm and DAI along with other members too that are useful too.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c53f5d589591..29bf9fbd3e29 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2143,8 +2143,7 @@ static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &soc_pcm_ops);
 
 	if (platform->driver->pcm_new) {
-		ret = platform->driver->pcm_new(rtd->card->snd_card,
-						codec_dai, pcm);
+		ret = platform->driver->pcm_new(rtd);
 		if (ret < 0) {
 			pr_err("asoc: platform pcm constructor failed\n");
 			return ret;

commit 78bf3c9ab69a957dfa58e521ce7fca056c86b980
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jun 3 17:09:14 2011 +0100

    ASoC: Enforce the mask in snd_soc_update_bits()
    
    Avoids issues if someone does a read followed by restore and doesn't mask
    out only the bits being updated.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 13a40fc78d32..c53f5d589591 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2323,7 +2323,7 @@ int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
 		return ret;
 
 	old = ret;
-	new = (old & ~mask) | value;
+	new = (old & ~mask) | (value & mask);
 	change = old != new;
 	if (change) {
 		ret = snd_soc_write(codec, reg, new);

commit d21685ec258f803d3badae5eae821383a34815a9
Merge: 74ab24af4fe1 ea02c63d57d7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 30 10:54:18 2011 +0800

    Merge branch 'for-2.6.40' into for-2.6.41

commit 82e14e8bdd88b69018fe757192b01dd98582905e
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed May 25 14:06:41 2011 -0600

    ASoC: core: Don't schedule deferred_resume_work twice
    
    For cards that have two or more DAIs, snd_soc_resume's loop over all
    DAIs ends up calling schedule_work(deferred_resume_work) once per DAI.
    Since this is the same work item each time, the 2nd and subsequent
    calls return 0 (work item already queued), and trigger the dev_err
    message below stating that a work item may have been lost.
    
    Solve this by adjusting the loop to simply calculate whether to run the
    resume work immediately or defer it, and then call schedule work (or not)
    one time based on that.
    
    Note: This has not been tested in mainline, but only in chromeos-2.6.38;
    mainline doesn't support suspend/resume on Tegra, nor does the mainline
    Tegra ASoC driver contain multiple DAIs. It has been compile-checked in
    mainline.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a477e218aa28..c261eeb835b4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1256,7 +1256,7 @@ static void soc_resume_deferred(struct work_struct *work)
 int snd_soc_resume(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
-	int i;
+	int i, ac97_control = 0;
 
 	/* AC97 devices might have other drivers hanging off them so
 	 * need to resume immediately.  Other drivers don't have that
@@ -1265,14 +1265,15 @@ int snd_soc_resume(struct device *dev)
 	 */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
-		if (cpu_dai->driver->ac97_control) {
-			dev_dbg(dev, "Resuming AC97 immediately\n");
-			soc_resume_deferred(&card->deferred_resume_work);
-		} else {
-			dev_dbg(dev, "Scheduling resume work\n");
-			if (!schedule_work(&card->deferred_resume_work))
-				dev_err(dev, "resume work item may be lost\n");
-		}
+		ac97_control |= cpu_dai->driver->ac97_control;
+	}
+	if (ac97_control) {
+		dev_dbg(dev, "Resuming AC97 immediately\n");
+		soc_resume_deferred(&card->deferred_resume_work);
+	} else {
+		dev_dbg(dev, "Scheduling resume work\n");
+		if (!schedule_work(&card->deferred_resume_work))
+			dev_err(dev, "resume work item may be lost\n");
 	}
 
 	return 0;

commit 92505299a131b47992d318f2875d5629ac870d87
Author: Liam Girdwood <lrg@ti.com>
Date:   Tue May 24 17:38:52 2011 +0100

    ASoC: core - remove superfluous new line.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 07991d438796..d75043ed7fc0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1617,7 +1617,6 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	rtd->pmdown_time = pmdown_time;
 
 	/* probe the cpu_dai */
-
 	if (!cpu_dai->probed) {
 		if (!try_module_get(cpu_dai->dev->driver->owner))
 			return -ENODEV;

commit 61b61e3c5c9bf37ca2915ac981f444989ab22f10
Author: Liam Girdwood <lrg@ti.com>
Date:   Tue May 24 13:57:43 2011 +0100

    ASoC: core - fix module reference counting for CPU DAIs
    
    Currently CODEC and platform drivers have their module reference count
    incremented soc_probe_dai_link() whilst CPU DAI drivers have their reference
    count incremented in soc_bind_dai_link().
    
    CPU DAIs should have their reference count incremented in soc_probe_dai_link()
    just like the CODEC and platform drivers.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bb7cd5812945..07991d438796 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1306,10 +1306,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	/* no, then find CPU DAI from registered DAIs*/
 	list_for_each_entry(cpu_dai, &dai_list, list) {
 		if (!strcmp(cpu_dai->name, dai_link->cpu_dai_name)) {
-
-			if (!try_module_get(cpu_dai->dev->driver->owner))
-				return -ENODEV;
-
 			rtd->cpu_dai = cpu_dai;
 			goto find_codec;
 		}
@@ -1621,12 +1617,17 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	rtd->pmdown_time = pmdown_time;
 
 	/* probe the cpu_dai */
+
 	if (!cpu_dai->probed) {
+		if (!try_module_get(cpu_dai->dev->driver->owner))
+			return -ENODEV;
+
 		if (cpu_dai->driver->probe) {
 			ret = cpu_dai->driver->probe(cpu_dai);
 			if (ret < 0) {
 				printk(KERN_ERR "asoc: failed to probe CPU DAI %s\n",
 						cpu_dai->name);
+				module_put(cpu_dai->dev->driver->owner);
 				return ret;
 			}
 		}

commit 2b39535b9e54888649923beaab443af212b6c0fd
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Fri May 20 15:47:40 2011 +0300

    ASoC: core: Don't set "(null)" as a driver name
    
    Commit 22de71b ("ASoC: core - allow ASoC more flexible machine name")
    writes "(null)" to driver name string in struct snd_card if card->driver_name
    is NULL. This causes segmentation faults with some user space ALSA utilities
    like aplay and arecord.
    
    Fix this by using the card->name if no driver name is specified.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5968745213f8..bb7cd5812945 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1930,7 +1930,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
 		 "%s", card->long_name ? card->long_name : card->name);
 	snprintf(card->snd_card->driver, sizeof(card->snd_card->driver),
-		 "%s", card->driver_name);
+		 "%s", card->driver_name ? card->driver_name : card->name);
 
 	if (card->late_probe) {
 		ret = card->late_probe(card);

commit 34e268d87d60da7968d7300aae7d575be9d16ae7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu May 12 16:50:10 2011 -0700

    ASoC: Silence DEBUG_STRICT_USER_COPY_CHECKS=y warning
    
    Enabling DEBUG_STRICT_USER_COPY_CHECKS causes the following
    warning:
    
    In file included from arch/x86/include/asm/uaccess.h:573,
                     from include/linux/poll.h:14,
                     from include/sound/pcm.h:29,
                     from include/sound/ac97_codec.h:31,
                     from sound/soc/soc-core.c:34:
    In function 'copy_from_user',
        inlined from 'codec_reg_write_file' at
        sound/soc/soc-core.c:252:
    arch/x86/include/asm/uaccess_64.h:65:
    warning: call to 'copy_from_user_overflow' declared with
    attribute warning: copy_from_user() buffer size is not provably
    correct
    
    presumably due to buf_size being signed causing GCC to fail to
    see that buf_size can't become negative.
    
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c1a4cf480c72..5968745213f8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -242,7 +242,7 @@ static ssize_t codec_reg_write_file(struct file *file,
 		const char __user *user_buf, size_t count, loff_t *ppos)
 {
 	char buf[32];
-	int buf_size;
+	size_t buf_size;
 	char *start = buf;
 	unsigned long reg, value;
 	int step = 1;

commit 22de71ba03311cdc1063757c50a1488cb90a1fca
Author: Liam Girdwood <lrg@ti.com>
Date:   Thu May 12 16:14:04 2011 +0100

    ASoC: core - allow ASoC more flexible machine name
    
    Allow ASoC machine drivers to register a driver name
    and a longname. This allows user space to determine
    the flavour of machine driver.
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a477e218aa28..c1a4cf480c72 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1926,9 +1926,11 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 					card->num_dapm_routes);
 
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
-		 "%s",  card->name);
-	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
 		 "%s", card->name);
+	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
+		 "%s", card->long_name ? card->long_name : card->name);
+	snprintf(card->snd_card->driver, sizeof(card->snd_card->driver),
+		 "%s", card->driver_name);
 
 	if (card->late_probe) {
 		ret = card->late_probe(card);

commit 77530150fba769d7b7e260b3f16ed2294c1737b6
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu May 5 16:59:09 2011 +0200

    ASoC: Create codec DAPM widgets before calling the codecs probe function
    
    This allows to create DAPM routes depending on those widgets in the
    codecs probe function.  This is helpful when supporting similar codecs
    with minor differences in the DAPM routing with the same driver.
    
    Something similar has already been done for cards in commit
    a841ebb9 (ASoC: Create card DAPM widgets early so they can be used in
    callbacks).
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 133edeb9728a..a477e218aa28 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1495,6 +1495,10 @@ static int soc_probe_codec(struct snd_soc_card *card,
 
 	soc_init_codec_debugfs(codec);
 
+	if (driver->dapm_widgets)
+		snd_soc_dapm_new_controls(&codec->dapm, driver->dapm_widgets,
+					  driver->num_dapm_widgets);
+
 	if (driver->probe) {
 		ret = driver->probe(codec);
 		if (ret < 0) {
@@ -1508,9 +1512,6 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	if (driver->controls)
 		snd_soc_add_controls(codec, driver->controls,
 				     driver->num_controls);
-	if (driver->dapm_widgets)
-		snd_soc_dapm_new_controls(&codec->dapm, driver->dapm_widgets,
-					  driver->num_dapm_widgets);
 	if (driver->dapm_routes)
 		snd_soc_dapm_add_routes(&codec->dapm, driver->dapm_routes,
 					driver->num_dapm_routes);

commit 20ed0938bfb132638f68618ba2e694aafe24d3e2
Merge: e1a02066080d 9ab88434e8b5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue May 3 23:30:36 2011 +0100

    Merge branch 'for-2.6.39' into for-2.6.40

commit ed77cc122a8402db8f9c3492649aa0c3fee7b385
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue May 3 18:25:34 2011 +0100

    ASoC: Don't crash on PM operations
    
    The move over to exposing snd_soc_register_card() let the initialisation
    of the driver data we use to find the card in PM operations go AWOL. Fix
    this by setting the driver data when we register the card.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d8562ce4de7a..dd55d1069468 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3291,6 +3291,8 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	if (!card->name || !card->dev)
 		return -EINVAL;
 
+	dev_set_drvdata(card->dev, card);
+
 	snd_soc_initialize_card_lists(card);
 
 	soc_init_card_debugfs(card);

commit d5d1e0bef4385a0cd726613c0fc1909cd23efd39
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Apr 30 19:45:49 2011 +0200

    ASoC: Move DAPM widget debugfs entry creation to snd_soc_dapm_new_widgets
    
    Currently debugfs entries for a DAPM widgets are only added in
    snd_soc_dapm_debugfs_init. If a widget is added later (for example in the
    dai_link's probe callback) it will not show up in debugfs.
    This patch moves the creation of the widget debugfs entry to
    snd_soc_dapm_new_widgets where it will be added after the widget has been
    properly instantiated.
    
    As a side-effect this will also reduce the number of times the DAPM widget list
    is iterated during a card's instantiation.
    
    Since it is possible that snd_soc_dapm_new_widgets is invoked form the codecs or
    cards probe callbacks, the creation of the debugfs dapm directory has to be
    moved before these are called.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 983ec640d4d7..fbd011ebe19f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1493,6 +1493,8 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	if (!try_module_get(codec->dev->driver->owner))
 		return -ENODEV;
 
+	soc_init_codec_debugfs(codec);
+
 	if (driver->probe) {
 		ret = driver->probe(codec);
 		if (ret < 0) {
@@ -1513,8 +1515,6 @@ static int soc_probe_codec(struct snd_soc_card *card,
 		snd_soc_dapm_add_routes(&codec->dapm, driver->dapm_routes,
 					driver->num_dapm_routes);
 
-	soc_init_codec_debugfs(codec);
-
 	/* mark codec as probed and add to card codec list */
 	codec->probed = 1;
 	list_add(&codec->card_list, &card->codec_dev_list);
@@ -1523,6 +1523,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	return 0;
 
 err_probe:
+	soc_cleanup_codec_debugfs(codec);
 	module_put(codec->dev->driver->owner);
 
 	return ret;
@@ -1873,6 +1874,10 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	card->dapm.card = card;
 	list_add(&card->dapm.list, &card->dapm_list);
 
+#ifdef CONFIG_DEBUG_FS
+	snd_soc_dapm_debugfs_init(&card->dapm, card->debugfs_card_root);
+#endif
+
 #ifdef CONFIG_PM_SLEEP
 	/* deferred resume work */
 	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
@@ -1919,10 +1924,6 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 					card->num_dapm_routes);
 
-#ifdef CONFIG_DEBUG_FS
-	snd_soc_dapm_debugfs_init(&card->dapm, card->debugfs_card_root);
-#endif
-
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
 		 "%s",  card->name);
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),

commit 8eecaf62445e175572ffabaab090b471001c5a2c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Apr 30 19:45:48 2011 +0200

    ASoC: Move DAPM debugfs directory creation to snd_soc_dapm_debugfs_init
    
    Move the creation of the DAPM debugfs directory to snd_soc_dapm_debugfs_init
    instead of having the same duplicated code in both codec and card DAPM setup.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6a3cb53185cb..983ec640d4d7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -302,13 +302,7 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 		printk(KERN_WARNING
 		       "ASoC: Failed to create codec register debugfs file\n");
 
-	codec->dapm.debugfs_dapm = debugfs_create_dir("dapm",
-						 codec->debugfs_codec_root);
-	if (!codec->dapm.debugfs_dapm)
-		printk(KERN_WARNING
-		       "Failed to create DAPM debugfs directory\n");
-
-	snd_soc_dapm_debugfs_init(&codec->dapm);
+	snd_soc_dapm_debugfs_init(&codec->dapm, codec->debugfs_codec_root);
 }
 
 static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
@@ -1926,13 +1920,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 					card->num_dapm_routes);
 
 #ifdef CONFIG_DEBUG_FS
-	card->dapm.debugfs_dapm = debugfs_create_dir("dapm",
-						     card->debugfs_card_root);
-	if (!card->dapm.debugfs_dapm)
-		printk(KERN_WARNING
-		       "Failed to create card DAPM debugfs directory\n");
-
-	snd_soc_dapm_debugfs_init(&card->dapm);
+	snd_soc_dapm_debugfs_init(&card->dapm, card->debugfs_card_root);
 #endif
 
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),

commit 0aaae527c71e6af571093d90474f37c8662008d5
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Apr 30 19:45:47 2011 +0200

    ASoC: Free the card's DAPM context
    
    Free the card's DAPM context when the card is removed.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a823654ef367..6a3cb53185cb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2047,6 +2047,8 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 	if (card->remove)
 		card->remove(card);
 
+	snd_soc_dapm_free(&card->dapm);
+
 	kfree(card->rtd);
 	snd_card_free(card->snd_card);
 	return 0;

commit fb257897bf20c5f0e1df584bb5b874e811651263
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Apr 28 10:57:54 2011 +0100

    ASoC: Work around allmodconfig failure
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 16be3e5cf9e7..a823654ef367 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3868,12 +3868,16 @@ static int __init snd_soc_init(void)
 		pr_warn("ASoC: Failed to create platform list debugfs file\n");
 #endif
 
+	snd_soc_util_init();
+
 	return platform_driver_register(&soc_driver);
 }
 module_init(snd_soc_init);
 
 static void __exit snd_soc_exit(void)
 {
+	snd_soc_util_exit();
+
 #ifdef CONFIG_DEBUG_FS
 	debugfs_remove_recursive(snd_soc_debugfs_root);
 #endif

commit 848dd8beef44df18f2eb61e00981b0692adb801b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 27 18:16:32 2011 +0100

    ASoC: Add more natural support for no-DMA DAIs
    
    Since we can now support multiple platforms allow machines to not specify
    a platform in a DAI link. Since the rest of the code requires that we have
    a struct device for all objects we do this by substituting in a dummy
    device that we register automatically.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Jassi Brar <jassisinghbrar@gmail.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9dc13113fa26..16be3e5cf9e7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1299,6 +1299,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	struct snd_soc_codec *codec;
 	struct snd_soc_platform *platform;
 	struct snd_soc_dai *codec_dai, *cpu_dai;
+	const char *platform_name;
 
 	if (rtd->complete)
 		return 1;
@@ -1351,13 +1352,18 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 			dai_link->codec_name);
 
 find_platform:
-	/* do we already have the CODEC DAI for this link ? */
-	if (rtd->platform) {
+	/* do we need a platform? */
+	if (rtd->platform)
 		goto out;
-	}
-	/* no, then find CPU DAI from registered DAIs*/
+
+	/* if there's no platform we match on the empty platform */
+	platform_name = dai_link->platform_name;
+	if (!platform_name)
+		platform_name = "snd-soc-dummy";
+
+	/* no, then find one from the set of registered platforms */
 	list_for_each_entry(platform, &platform_list, list) {
-		if (!strcmp(platform->name, dai_link->platform_name)) {
+		if (!strcmp(platform->name, platform_name)) {
 			rtd->platform = platform;
 			goto out;
 		}

commit 8842c72afe9f954d9462da577a25d4a32bfe0a2b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 27 18:58:17 2011 +0100

    ASoC: Allow platform drivers to have no ops structure
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Jassi Brar <jassisinghbrar@gmail.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a6f37d454220..9dc13113fa26 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -555,7 +555,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		}
 	}
 
-	if (platform->driver->ops->open) {
+	if (platform->driver->ops && platform->driver->ops->open) {
 		ret = platform->driver->ops->open(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open platform %s\n", platform->name);
@@ -685,7 +685,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		codec_dai->driver->ops->shutdown(substream, codec_dai);
 
 codec_dai_err:
-	if (platform->driver->ops->close)
+	if (platform->driver->ops && platform->driver->ops->close)
 		platform->driver->ops->close(substream);
 
 platform_err:
@@ -767,7 +767,7 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	if (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)
 		rtd->dai_link->ops->shutdown(substream);
 
-	if (platform->driver->ops->close)
+	if (platform->driver->ops && platform->driver->ops->close)
 		platform->driver->ops->close(substream);
 	cpu_dai->runtime = NULL;
 
@@ -810,7 +810,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 		}
 	}
 
-	if (platform->driver->ops->prepare) {
+	if (platform->driver->ops && platform->driver->ops->prepare) {
 		ret = platform->driver->ops->prepare(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: platform prepare error\n");
@@ -899,7 +899,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
-	if (platform->driver->ops->hw_params) {
+	if (platform->driver->ops && platform->driver->ops->hw_params) {
 		ret = platform->driver->ops->hw_params(substream, params);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: platform %s hw params failed\n",
@@ -952,7 +952,7 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 		rtd->dai_link->ops->hw_free(substream);
 
 	/* free any DMA resources */
-	if (platform->driver->ops->hw_free)
+	if (platform->driver->ops && platform->driver->ops->hw_free)
 		platform->driver->ops->hw_free(substream);
 
 	/* now free hw params for the DAIs  */
@@ -980,7 +980,7 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 			return ret;
 	}
 
-	if (platform->driver->ops->trigger) {
+	if (platform->driver->ops && platform->driver->ops->trigger) {
 		ret = platform->driver->ops->trigger(substream, cmd);
 		if (ret < 0)
 			return ret;
@@ -1009,7 +1009,7 @@ static snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)
 	snd_pcm_uframes_t offset = 0;
 	snd_pcm_sframes_t delay = 0;
 
-	if (platform->driver->ops->pointer)
+	if (platform->driver->ops && platform->driver->ops->pointer)
 		offset = platform->driver->ops->pointer(substream);
 
 	if (cpu_dai->driver->ops->delay)
@@ -2125,13 +2125,15 @@ static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 
 	rtd->pcm = pcm;
 	pcm->private_data = rtd;
-	soc_pcm_ops.mmap = platform->driver->ops->mmap;
-	soc_pcm_ops.pointer = platform->driver->ops->pointer;
-	soc_pcm_ops.ioctl = platform->driver->ops->ioctl;
-	soc_pcm_ops.copy = platform->driver->ops->copy;
-	soc_pcm_ops.silence = platform->driver->ops->silence;
-	soc_pcm_ops.ack = platform->driver->ops->ack;
-	soc_pcm_ops.page = platform->driver->ops->page;
+	if (platform->driver->ops) {
+		soc_pcm_ops.mmap = platform->driver->ops->mmap;
+		soc_pcm_ops.pointer = platform->driver->ops->pointer;
+		soc_pcm_ops.ioctl = platform->driver->ops->ioctl;
+		soc_pcm_ops.copy = platform->driver->ops->copy;
+		soc_pcm_ops.silence = platform->driver->ops->silence;
+		soc_pcm_ops.ack = platform->driver->ops->ack;
+		soc_pcm_ops.page = platform->driver->ops->page;
+	}
 
 	if (playback)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
@@ -2139,10 +2141,13 @@ static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 	if (capture)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &soc_pcm_ops);
 
-	ret = platform->driver->pcm_new(rtd->card->snd_card, codec_dai, pcm);
-	if (ret < 0) {
-		printk(KERN_ERR "asoc: platform pcm constructor failed\n");
-		return ret;
+	if (platform->driver->pcm_new) {
+		ret = platform->driver->pcm_new(rtd->card->snd_card,
+						codec_dai, pcm);
+		if (ret < 0) {
+			pr_err("asoc: platform pcm constructor failed\n");
+			return ret;
+		}
 	}
 
 	pcm->private_free = platform->driver->pcm_free;

commit a739362362982f3d8177df0621b68cb9156b1b60
Author: Lu Guanqun <guanqun.lu@intel.com>
Date:   Wed Apr 20 16:00:51 2011 +0800

    ASoC: fix two ident style problems
    
    Signed-off-by: Lu Guanqun <guanqun.lu@intel.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3b3a377d0874..a6f37d454220 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3475,7 +3475,7 @@ int snd_soc_register_dai(struct device *dev,
 
 	dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
 	if (dai == NULL)
-			return -ENOMEM;
+		return -ENOMEM;
 
 	/* create DAI component name */
 	dai->name = fmt_single_name(dev, &dai->id);
@@ -3614,7 +3614,7 @@ int snd_soc_register_platform(struct device *dev,
 
 	platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);
 	if (platform == NULL)
-			return -ENOMEM;
+		return -ENOMEM;
 
 	/* create platform component name */
 	platform->name = fmt_single_name(dev, &platform->id);

commit 9a841ebb9cac3f1b7253bb01c304f89b1af25aba
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 12 17:51:37 2011 -0700

    ASoC: Create card DAPM widgets early so they can be used in callbacks
    
    This helps with things like setting up the initial state.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1f114673e952..3b3a377d0874 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1878,6 +1878,10 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
 #endif
 
+	if (card->dapm_widgets)
+		snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
+					  card->num_dapm_widgets);
+
 	/* initialise the sound card only once */
 	if (card->probe) {
 		ret = card->probe(card);
@@ -1911,9 +1915,6 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 				     card->controls,
 				     card->num_controls);
 
-	if (card->dapm_widgets)
-		snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
-					  card->num_dapm_widgets);
 	if (card->dapm_routes)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 					card->num_dapm_routes);

commit 0671fd8ef4b32200e75396cd299f0853002fc11e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Apr 8 14:50:44 2011 +0900

    ASoC: Add soc_remove_dai_links
    
    card->num_rtd should be 0 after soc_romve_dai_link
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f75f13926049..1f114673e952 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1453,6 +1453,16 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 	}
 }
 
+static void soc_remove_dai_links(struct snd_soc_card *card)
+{
+	int i;
+
+	for (i = 0; i < card->num_rtd; i++)
+		soc_remove_dai_link(card, i);
+
+	card->num_rtd = 0;
+}
+
 static void soc_set_name_prefix(struct snd_soc_card *card,
 				struct snd_soc_codec *codec)
 {
@@ -1960,8 +1970,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		soc_remove_aux_dev(card, i);
 
 probe_dai_err:
-	for (i = 0; i < card->num_links; i++)
-		soc_remove_dai_link(card, i);
+	soc_remove_dai_links(card);
 
 card_probe_error:
 	if (card->remove)
@@ -2023,8 +2032,7 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 		soc_remove_aux_dev(card, i);
 
 	/* remove and free each DAI */
-	for (i = 0; i < card->num_rtd; i++)
-		soc_remove_dai_link(card, i);
+	soc_remove_dai_links(card);
 
 	soc_cleanup_card_debugfs(card);
 

commit b7af1dafdfaf8419065399d07fb7cbae14b286ef
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Apr 7 19:18:44 2011 +0900

    ASoC: Add data based control initialisation for CODECs and cards
    
    Allow CODEC and card drivers to point to an array of controls from their
    driver structure rather than explicitly calling snd_soc_add_controls().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f31afe9d4edd..f75f13926049 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1493,6 +1493,9 @@ static int soc_probe_codec(struct snd_soc_card *card,
 		}
 	}
 
+	if (driver->controls)
+		snd_soc_add_controls(codec, driver->controls,
+				     driver->num_controls);
 	if (driver->dapm_widgets)
 		snd_soc_dapm_new_controls(&codec->dapm, driver->dapm_widgets,
 					  driver->num_dapm_widgets);
@@ -1890,6 +1893,14 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
+	/* We should have a non-codec control add function but we don't */
+	if (card->controls)
+		snd_soc_add_controls(list_first_entry(&card->codec_dev_list,
+						      struct snd_soc_codec,
+						      card_list),
+				     card->controls,
+				     card->num_controls);
+
 	if (card->dapm_widgets)
 		snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
 					  card->num_dapm_widgets);

commit d9b3e4c5156476a4baf0d7e0f47ba2816b4fff8e
Merge: fb631eae1f21 baa8160382e2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Apr 7 08:27:06 2011 +0900

    Merge branch 'for-2.6.39' into for-2.6.40

commit c51def659870d25c735a9e06648e560ab39dbbb6
Author: Lu Guanqun <guanqun.lu@intel.com>
Date:   Wed Apr 6 23:25:21 2011 +0800

    ASoC: fix config error path
    
    initialize ret to invalid value so that when we reach the config error path in
    soc_pcm_open, it will return the correct error code. without this patch, though
    config error path is executed, soc_pcm_open will return 0 in
    snd_pcm_open_substream and then cause double release of substream.
    
    Signed-off-by: Lu Guanqun <guanqun.lu@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4f42fef26c98..d8562ce4de7a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -629,6 +629,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 			runtime->hw.rates |= codec_dai_drv->capture.rates;
 	}
 
+	ret = -EINVAL;
 	snd_pcm_limit_hw_rates(runtime);
 	if (!runtime->hw.rates) {
 		printk(KERN_ERR "asoc: %s <-> %s No matching rates\n",

commit b04cfcf70b35e032071a6b482273cc642675c8e4
Author: Lu Guanqun <guanqun.lu@intel.com>
Date:   Wed Apr 6 23:25:11 2011 +0800

    ASoC: check channel mismatch between cpu_dai and codec_dai
    
    Suppose we have:
    
            cpu_dai
                    channels_min = 1
                    channels_max = 1
    
            codec_dai
                    channels_min = 2
                    channels_max = 2
    
    This is a mismatch that should not happen, however according to the current
    code, the result of runtime->hw will be:
    
                    channels_min = 2
                    channels_max = 1
    
    We better spot it early. This patch checks this mismatch.
    
    Signed-off-by: Lu Guanqun <guanqun.lu@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 960718b3beb8..4f42fef26c98 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -640,7 +640,8 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 			codec_dai->name, cpu_dai->name);
 		goto config_err;
 	}
-	if (!runtime->hw.channels_min || !runtime->hw.channels_max) {
+	if (!runtime->hw.channels_min || !runtime->hw.channels_max ||
+	    runtime->hw.channels_min > runtime->hw.channels_max) {
 		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",
 				codec_dai->name, cpu_dai->name);
 		goto config_err;

commit fa880004682cf0d10e7a7c71dc8d56bbd67ac3d5
Merge: 09f68072b320 deb2607e6c3d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 6 23:15:15 2011 +0900

    Merge branch 'for-2.6.39' into for-2.6.40

commit deb2607e6c3d75c7185bb8aba658d9cd57e6e54a
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Apr 5 19:35:30 2011 -0600

    ASoC: Tegra: Suspend/resume support
    
    ASoC machine drivers that are their own platform_driver (as opposed to
    those using the soc-audio platform_driver) need to explicitly set up
    power-management operation callbacks.
    
    To avoid cut/paste, snd_soc_pm_ops also needs to be exported.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b76b74db0968..960718b3beb8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2060,6 +2060,7 @@ const struct dev_pm_ops snd_soc_pm_ops = {
 	.resume = snd_soc_resume,
 	.poweroff = snd_soc_poweroff,
 };
+EXPORT_SYMBOL_GPL(snd_soc_pm_ops);
 
 /* ASoC platform driver */
 static struct platform_driver soc_driver = {

commit f6fcdc145679f5c86ff3fe587b060c9c3709d360
Merge: 04368d051a6a 00b317a41c54
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Apr 3 22:12:15 2011 +0900

    Merge branch 'for-2.6.39' into for-2.6.40

commit 00b317a41c5428b13eb7e5b4bbc691b1aa7afa80
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Apr 1 14:50:44 2011 -0600

    ASoC: format_register_str: Don't clip register values
    
    wordsize is used as the textual width of a register address.
    
    regsize is used as the textual width of a register value.
    
    The assignments to these values were swapped. In the case of WM8903, which
    has 8-bit register addresses and 16-bit register values, this caused the
    register values to be clipped to 2 digits instead of the full 4.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4dda58926bc5..b76b74db0968 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -92,8 +92,8 @@ static int min_bytes_needed(unsigned long val)
 static int format_register_str(struct snd_soc_codec *codec,
 			       unsigned int reg, char *buf, size_t len)
 {
-	int wordsize = codec->driver->reg_word_size * 2;
-	int regsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
+	int wordsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
+	int regsize = codec->driver->reg_word_size * 2;
 	int ret;
 	char tmpbuf[len + 1];
 	char regbuf[regsize + 1];
@@ -132,8 +132,8 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf,
 	size_t total = 0;
 	loff_t p = 0;
 
-	wordsize = codec->driver->reg_word_size * 2;
-	regsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
+	wordsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
+	regsize = codec->driver->reg_word_size * 2;
 
 	len = wordsize + regsize + 2 + 1;
 

commit 239c970626b9d9c7449de751d91f9a9da1018b85
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Mar 24 13:45:18 2011 +0000

    ASoC: Add snd_soc_codec_{readable,writable}_register()
    
    Provide the top level ASoC core functions for indicating whether
    a given register is readable or writable.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 074a0c6e99f4..5ae70a107f1f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2146,6 +2146,42 @@ int snd_soc_codec_volatile_register(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_volatile_register);
 
+/**
+ * snd_soc_codec_readable_register: Report if a register is readable.
+ *
+ * @codec: CODEC to query.
+ * @reg: Register to query.
+ *
+ * Boolean function indicating if a CODEC register is readable.
+ */
+int snd_soc_codec_readable_register(struct snd_soc_codec *codec,
+				    unsigned int reg)
+{
+	if (codec->readable_register)
+		return codec->readable_register(codec, reg);
+	else
+		return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_codec_readable_register);
+
+/**
+ * snd_soc_codec_writable_register: Report if a register is writable.
+ *
+ * @codec: CODEC to query.
+ * @reg: Register to query.
+ *
+ * Boolean function indicating if a CODEC register is writable.
+ */
+int snd_soc_codec_writable_register(struct snd_soc_codec *codec,
+				    unsigned int reg)
+{
+	if (codec->writable_register)
+		return codec->writable_register(codec, reg);
+	else
+		return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_codec_writable_register);
+
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec

commit 8020454c9a1ec5ac5801805896b5f69d0c573e17
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Mar 24 13:45:17 2011 +0000

    ASoC: Add default snd_soc_default_writable_register() callback
    
    By using struct snd_soc_reg_access for the read/write/vol attributes
    of the registers, we provide callbacks that automatically determine whether
    a given register is readable/writable or volatile.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 636328e868e8..074a0c6e99f4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3673,6 +3673,7 @@ int snd_soc_register_codec(struct device *dev,
 	codec->read = codec_drv->read;
 	codec->volatile_register = codec_drv->volatile_register;
 	codec->readable_register = codec_drv->readable_register;
+	codec->writable_register = codec_drv->writable_register;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;
@@ -3707,6 +3708,8 @@ int snd_soc_register_codec(struct device *dev,
 			codec->volatile_register = snd_soc_default_volatile_register;
 		if (!codec->readable_register)
 			codec->readable_register = snd_soc_default_readable_register;
+		if (!codec->writable_register)
+			codec->writable_register = snd_soc_default_writable_register;
 	}
 
 	for (i = 0; i < num_dai; i++) {

commit 5fb609d435f0679ed322ddeb1fdafe6142463fdf
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Tue Mar 22 10:37:03 2011 +0000

    ASoC: soc-cache: Introduce raw bulk write support
    
    As it has become more common to have to write firmware or similar
    large chunks of data to the hardware, add a function to perform
    raw bulk writes that bypass the cache.  This only handles volatile
    registers as we should avoid getting out of sync with the actual
    cache.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4dda58926bc5..636328e868e8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2228,6 +2228,13 @@ unsigned int snd_soc_write(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_write);
 
+unsigned int snd_soc_bulk_write_raw(struct snd_soc_codec *codec,
+				    unsigned int reg, const void *data, size_t len)
+{
+	return codec->bulk_write_raw(codec, reg, data, len);
+}
+EXPORT_SYMBOL_GPL(snd_soc_bulk_write_raw);
+
 /**
  * snd_soc_update_bits - update codec register bits
  * @codec: audio codec

commit b1a56b331aec59be04f25ac99694d855d591c539
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 16 18:18:53 2011 +0000

    ASoC: Remove bogus check for register validity in debugfs write
    
    Since not all registers need to be cached and the cache is entirely
    optional anyway we shouldn't be checking that a register is in the
    cached range. If the register is invalid then the actual I/O code
    can determine that and report an error.
    
    Similarly, the step size can and should be enforced by the lower level
    code if it's important.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 17efacdb248a..4dda58926bc5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -259,8 +259,6 @@ static ssize_t codec_reg_write_file(struct file *file,
 	while (*start == ' ')
 		start++;
 	reg = simple_strtoul(start, &start, 16);
-	if ((reg >= codec->driver->reg_cache_size) || (reg % step))
-		return -EINVAL;
 	while (*start == ' ')
 		start++;
 	if (strict_strtoul(start, 16, &value))

commit efb7ac3f9c28fcb379c51f987b63174f727b7453
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 8 17:23:24 2011 +0000

    ASoC: Fix prefixing of DAPM controls by factoring prefix into snd_soc_cnew()
    
    Currently will ignore prefixes when creating DAPM controls. Since currently
    all control creation goes through snd_soc_cnew() we can fix this by factoring
    the prefixing into that function.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index db3075dd11fe..17efacdb248a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2344,22 +2344,45 @@ EXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);
  * @_template: control template
  * @data: control private data
  * @long_name: control long name
+ * @prefix: control name prefix
  *
  * Create a new mixer control from a template control.
  *
  * Returns 0 for success, else error.
  */
 struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
-	void *data, char *long_name)
+				  void *data, char *long_name,
+				  const char *prefix)
 {
 	struct snd_kcontrol_new template;
+	struct snd_kcontrol *kcontrol;
+	char *name = NULL;
+	int name_len;
 
 	memcpy(&template, _template, sizeof(template));
-	if (long_name)
-		template.name = long_name;
 	template.index = 0;
 
-	return snd_ctl_new1(&template, data);
+	if (!long_name)
+		long_name = template.name;
+
+	if (prefix) {
+		name_len = strlen(long_name) + strlen(prefix) + 2;
+		name = kmalloc(name_len, GFP_ATOMIC);
+		if (!name)
+			return NULL;
+
+		snprintf(name, name_len, "%s %s", prefix, long_name);
+
+		template.name = name;
+	} else {
+		template.name = long_name;
+	}
+
+	kcontrol = snd_ctl_new1(&template, data);
+
+	kfree(name);
+
+	return kcontrol;
 }
 EXPORT_SYMBOL_GPL(snd_soc_cnew);
 
@@ -2378,22 +2401,16 @@ int snd_soc_add_controls(struct snd_soc_codec *codec,
 	const struct snd_kcontrol_new *controls, int num_controls)
 {
 	struct snd_card *card = codec->card->snd_card;
-	char prefixed_name[44], *name;
 	int err, i;
 
 	for (i = 0; i < num_controls; i++) {
 		const struct snd_kcontrol_new *control = &controls[i];
-		if (codec->name_prefix) {
-			snprintf(prefixed_name, sizeof(prefixed_name), "%s %s",
-				 codec->name_prefix, control->name);
-			name = prefixed_name;
-		} else {
-			name = control->name;
-		}
-		err = snd_ctl_add(card, snd_soc_cnew(control, codec, name));
+		err = snd_ctl_add(card, snd_soc_cnew(control, codec,
+						     control->name,
+						     codec->name_prefix));
 		if (err < 0) {
 			dev_err(codec->dev, "%s: Failed to add %s: %d\n",
-				codec->name, name, err);
+				codec->name, control->name, err);
 			return err;
 		}
 	}

commit c4ef87867b42bd1fa7d6dacaa28bf07cf741a724
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 8 00:17:56 2011 +0000

    ASoC: Warn rather than set a silly constraint when we can't do symmetry
    
    Symmetric rate configuration can fail if the second stream starting tries
    to apply the symmetric constraint before the first stream has got far
    enough to pick a rate. Rather than try to enforce a nonsensical rate of
    0Hz log a warning and allow the application to carry on. Things might go
    wrong later on but the user will know about it and there's unlikely to be
    lasting damage.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 65ff61211a85..db3075dd11fe 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -505,6 +505,16 @@ static int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream)
 	    !rtd->dai_link->symmetric_rates)
 		return 0;
 
+	/* This can happen if multiple streams are starting simultaneously -
+	 * the second can need to get its constraints before the first has
+	 * picked a rate.  Complain and allow the application to carry on.
+	 */
+	if (!rtd->rate) {
+		dev_warn(&rtd->dev,
+			 "Not enforcing symmetric_rates due to race\n");
+		return 0;
+	}
+
 	dev_dbg(&rtd->dev, "Symmetry forces %dHz rate\n", rtd->rate);
 
 	ret = snd_pcm_hw_constraint_minmax(substream->runtime,

commit 4f333b20aef4459a24590fa8545e974f8f137f62
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 8 00:11:15 2011 +0000

    ASoC: Refactor symmetric_rates check to reduce indentation
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c2ec6cb05631..65ff61211a85 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -500,20 +500,20 @@ static int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream)
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret;
 
-	if (codec_dai->driver->symmetric_rates || cpu_dai->driver->symmetric_rates ||
-			rtd->dai_link->symmetric_rates) {
-		dev_dbg(&rtd->dev, "Symmetry forces %dHz rate\n",
-				rtd->rate);
-
-		ret = snd_pcm_hw_constraint_minmax(substream->runtime,
-						   SNDRV_PCM_HW_PARAM_RATE,
-						   rtd->rate,
-						   rtd->rate);
-		if (ret < 0) {
-			dev_err(&rtd->dev,
-				"Unable to apply rate symmetry constraint: %d\n", ret);
-			return ret;
-		}
+	if (!codec_dai->driver->symmetric_rates &&
+	    !cpu_dai->driver->symmetric_rates &&
+	    !rtd->dai_link->symmetric_rates)
+		return 0;
+
+	dev_dbg(&rtd->dev, "Symmetry forces %dHz rate\n", rtd->rate);
+
+	ret = snd_pcm_hw_constraint_minmax(substream->runtime,
+					   SNDRV_PCM_HW_PARAM_RATE,
+					   rtd->rate, rtd->rate);
+	if (ret < 0) {
+		dev_err(&rtd->dev,
+			"Unable to apply rate symmetry constraint: %d\n", ret);
+		return ret;
 	}
 
 	return 0;

commit ec4ee52a8f5fb5b8e235ae9f02589d60d54740cc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Mar 7 20:58:11 2011 +0000

    ASoC: Provide CODEC clocking operations and API calls
    
    When multi component systems use DAIless amplifiers which require clocking
    configuration it is at best hard to use the current clocking API as this
    requires a DAI even though the device may not even have one. Address this
    by adding set_sysclk() and set_pll() operations and APIs for CODECs.
    
    In order to avoid issues with devices which could be used either with or
    without DAIs make the DAI variants call through to their CODEC counterparts
    if there is no DAI specific operation. Converting over entirely would create
    problems for multi-DAI devices which offer per-DAI clocking setup.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c12f2bd23a4e..c2ec6cb05631 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3064,11 +3064,33 @@ int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 {
 	if (dai->driver && dai->driver->ops->set_sysclk)
 		return dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
+	else if (dai->codec && dai->codec->driver->set_sysclk)
+		return dai->codec->driver->set_sysclk(dai->codec, clk_id,
+						      freq, dir);
 	else
 		return -EINVAL;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 
+/**
+ * snd_soc_codec_set_sysclk - configure CODEC system or master clock.
+ * @codec: CODEC
+ * @clk_id: DAI specific clock ID
+ * @freq: new clock frequency in Hz
+ * @dir: new clock direction - input/output.
+ *
+ * Configures the CODEC master (MCLK) or system (SYSCLK) clocking.
+ */
+int snd_soc_codec_set_sysclk(struct snd_soc_codec *codec, int clk_id,
+	unsigned int freq, int dir)
+{
+	if (codec->driver->set_sysclk)
+		return codec->driver->set_sysclk(codec, clk_id, freq, dir);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_codec_set_sysclk);
+
 /**
  * snd_soc_dai_set_clkdiv - configure DAI clock dividers.
  * @dai: DAI
@@ -3105,11 +3127,35 @@ int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
 	if (dai->driver && dai->driver->ops->set_pll)
 		return dai->driver->ops->set_pll(dai, pll_id, source,
 					 freq_in, freq_out);
+	else if (dai->codec && dai->codec->driver->set_pll)
+		return dai->codec->driver->set_pll(dai->codec, pll_id, source,
+						   freq_in, freq_out);
 	else
 		return -EINVAL;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
 
+/*
+ * snd_soc_codec_set_pll - configure codec PLL.
+ * @codec: CODEC
+ * @pll_id: DAI specific PLL ID
+ * @source: DAI specific source for the PLL
+ * @freq_in: PLL input clock frequency in Hz
+ * @freq_out: requested PLL output clock frequency in Hz
+ *
+ * Configures and enables PLL to generate output clock based on input clock.
+ */
+int snd_soc_codec_set_pll(struct snd_soc_codec *codec, int pll_id, int source,
+			  unsigned int freq_in, unsigned int freq_out)
+{
+	if (codec->driver->set_pll)
+		return codec->driver->set_pll(codec, pll_id, source,
+					      freq_in, freq_out);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_codec_set_pll);
+
 /**
  * snd_soc_dai_set_fmt - configure DAI hardware audio format.
  * @dai: DAI

commit 89b95ac09e408b5d88a8b3792dc76c863e45fb31
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Mar 7 16:38:44 2011 +0000

    ASoC: Add DAPM widget and path data to CODEC driver structure
    
    Allow a slight simplification of CODEC drivers by allowing DAPM routes and
    widgets to be provided in a table. They will be instantiated at the end of
    CODEC probe.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index be34f6b95386..c12f2bd23a4e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1464,6 +1464,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 			   struct snd_soc_codec *codec)
 {
 	int ret = 0;
+	const struct snd_soc_codec_driver *driver = codec->driver;
 
 	codec->card = card;
 	codec->dapm.card = card;
@@ -1472,8 +1473,8 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	if (!try_module_get(codec->dev->driver->owner))
 		return -ENODEV;
 
-	if (codec->driver->probe) {
-		ret = codec->driver->probe(codec);
+	if (driver->probe) {
+		ret = driver->probe(codec);
 		if (ret < 0) {
 			dev_err(codec->dev,
 				"asoc: failed to probe CODEC %s: %d\n",
@@ -1482,6 +1483,13 @@ static int soc_probe_codec(struct snd_soc_card *card,
 		}
 	}
 
+	if (driver->dapm_widgets)
+		snd_soc_dapm_new_controls(&codec->dapm, driver->dapm_widgets,
+					  driver->num_dapm_widgets);
+	if (driver->dapm_routes)
+		snd_soc_dapm_add_routes(&codec->dapm, driver->dapm_routes,
+					driver->num_dapm_routes);
+
 	soc_init_codec_debugfs(codec);
 
 	/* mark codec as probed and add to card codec list */

commit a2721fd9fa6d4181fd66c58316d3893b597ba118
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Mar 7 11:09:25 2011 +0000

    ASoC: Add missing debugfs conditionals
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8926d38fc5a3..be34f6b95386 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1879,6 +1879,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 					card->num_dapm_routes);
 
+#ifdef CONFIG_DEBUG_FS
 	card->dapm.debugfs_dapm = debugfs_create_dir("dapm",
 						     card->debugfs_card_root);
 	if (!card->dapm.debugfs_dapm)
@@ -1886,6 +1887,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		       "Failed to create card DAPM debugfs directory\n");
 
 	snd_soc_dapm_debugfs_init(&card->dapm);
+#endif
 
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
 		 "%s",  card->name);

commit 28e9ad921d3b7defd8940a3e30e8241c8ed734db
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 2 18:36:34 2011 +0000

    ASoC: Add a late_probe() callback to cards
    
    This is run after the DAPM widgets and routes are added, allowing setup
    of things like jacks using the routes. The main card probe() is run before
    anything else so can't be used for this purpose.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6a2839c18447..8926d38fc5a3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1892,6 +1892,15 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
 		 "%s", card->name);
 
+	if (card->late_probe) {
+		ret = card->late_probe(card);
+		if (ret < 0) {
+			dev_err(card->dev, "%s late_probe() failed: %d\n",
+				card->name, ret);
+			goto probe_aux_dev_err;
+		}
+	}
+
 	ret = snd_card_register(card->snd_card);
 	if (ret < 0) {
 		printk(KERN_ERR "asoc: failed to register soundcard for %s\n", card->name);

commit b8ad29debd7401d257da923480d32838172c431a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 2 18:35:51 2011 +0000

    ASoC: Allow card DAPM widgets and routes to be set up at registration
    
    These will be added after all devices are registered and allow most DAI
    init functions in machine drivers to be replaced by simple data.
    Regular controls are not supported as the registration function still
    works in terms of CODECs.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 24bfc3ff8e17..6a2839c18447 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1872,6 +1872,13 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
+	if (card->dapm_widgets)
+		snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
+					  card->num_dapm_widgets);
+	if (card->dapm_routes)
+		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
+					card->num_dapm_routes);
+
 	card->dapm.debugfs_dapm = debugfs_create_dir("dapm",
 						     card->debugfs_card_root);
 	if (!card->dapm.debugfs_dapm)

commit e37a4970cd7ab6aec9e848cd3c355fd47fd18afd
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 2 18:21:57 2011 +0000

    ASoC: Add a per-card DAPM context
    
    This means that rather than adding the board specific DAPM widgets to a
    random CODEC DAPM context they can be added to the card itself which is
    a bit cleaner. Previously there only was one DAPM context and it was
    tied to the single supported CODEC.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 64befac3f9c3..24bfc3ff8e17 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1837,6 +1837,11 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 	card->snd_card->dev = card->dev;
 
+	card->dapm.bias_level = SND_SOC_BIAS_OFF;
+	card->dapm.dev = card->dev;
+	card->dapm.card = card;
+	list_add(&card->dapm.list, &card->dapm_list);
+
 #ifdef CONFIG_PM_SLEEP
 	/* deferred resume work */
 	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
@@ -1867,6 +1872,14 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
+	card->dapm.debugfs_dapm = debugfs_create_dir("dapm",
+						     card->debugfs_card_root);
+	if (!card->dapm.debugfs_dapm)
+		printk(KERN_WARNING
+		       "Failed to create card DAPM debugfs directory\n");
+
+	snd_soc_dapm_debugfs_init(&card->dapm);
+
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
 		 "%s",  card->name);
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),

commit 567d6f48759a30f4578c88c2672a8c0b0394be4c
Merge: 13fd179f1471 0962bb217ac7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Feb 2 20:52:14 2011 +0000

    Merge branch 'for-2.6.38' into for-2.6.39

commit 0962bb217ac74c4b8fae34c5367ebc63131c962c
Author: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
Date:   Wed Feb 2 21:11:41 2011 +0100

    ASoC: fill in snd_soc_pcm_runtime.card before calling snd_soc_dai_link.init()
    
    The .card member of the snd_soc_pcm_runtime structure pointed to by the
    snd_soc_dai_link.init() argument used to be initialized before the
    function being called. This has changed, probably unintentionally,
    after recent refactorings. Since the function implementations are free
    to make use of this pointer, move its assignment back before the
    function is called to avoid NULL pointer dereferences.
    
    Created and tested on Amstrad Delta againts linux-2.6.38-rc2
    
    Signed-off-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c4b60610beb0..c3f6f1e72790 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1449,6 +1449,7 @@ static int soc_post_component_init(struct snd_soc_card *card,
 		rtd = &card->rtd_aux[num];
 		name = aux_dev->name;
 	}
+	rtd->card = card;
 
 	/* machine controls, routes and widgets are not prefixed */
 	temp = codec->name_prefix;
@@ -1471,7 +1472,6 @@ static int soc_post_component_init(struct snd_soc_card *card,
 
 	/* register the rtd device */
 	rtd->codec = codec;
-	rtd->card = card;
 	rtd->dev.parent = card->dev;
 	rtd->dev.release = rtd_release;
 	rtd->dev.init_name = name;

commit 13fd179f14712cc89b5b3812673891b96e0ab3a2
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Feb 2 13:58:58 2011 +0000

    ASoC: soc-core: Support debugfs entries larger than PAGE_SIZE bytes
    
    For some codecs with large register maps, it was not possible to dump
    all registers via the codec_reg file but only up to PAGE_SIZE bytes.
    This patch fixes this problem.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 10bc3c23b525..0c789f9150c3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -87,15 +87,56 @@ static int min_bytes_needed(unsigned long val)
 	return c;
 }
 
+/* fill buf which is 'len' bytes with a formatted
+ * string of the form 'reg: value\n' */
+static int format_register_str(struct snd_soc_codec *codec,
+			       unsigned int reg, char *buf, size_t len)
+{
+	int wordsize = codec->driver->reg_word_size * 2;
+	int regsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
+	int ret;
+	char tmpbuf[len + 1];
+	char regbuf[regsize + 1];
+
+	/* since tmpbuf is allocated on the stack, warn the callers if they
+	 * try to abuse this function */
+	WARN_ON(len > 63);
+
+	/* +2 for ': ' and + 1 for '\n' */
+	if (wordsize + regsize + 2 + 1 != len)
+		return -EINVAL;
+
+	ret = snd_soc_read(codec , reg);
+	if (ret < 0) {
+		memset(regbuf, 'X', regsize);
+		regbuf[regsize] = '\0';
+	} else {
+		snprintf(regbuf, regsize + 1, "%.*x", regsize, ret);
+	}
+
+	/* prepare the buffer */
+	snprintf(tmpbuf, len + 1, "%.*x: %s\n", wordsize, reg, regbuf);
+	/* copy it back to the caller without the '\0' */
+	memcpy(buf, tmpbuf, len);
+
+	return 0;
+}
+
 /* codec register dump */
-static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
+static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf,
+				  size_t count, loff_t pos)
 {
-	int ret, i, step = 1, count = 0;
+	int i, step = 1;
 	int wordsize, regsize;
+	int len;
+	size_t total = 0;
+	loff_t p = 0;
 
 	wordsize = codec->driver->reg_word_size * 2;
 	regsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
 
+	len = wordsize + regsize + 2 + 1;
+
 	if (!codec->driver->reg_cache_size)
 		return 0;
 
@@ -105,51 +146,34 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 	for (i = 0; i < codec->driver->reg_cache_size; i += step) {
 		if (codec->readable_register && !codec->readable_register(codec, i))
 			continue;
-
-		count += sprintf(buf + count, "%.*x: ", regsize, i);
-		if (count >= PAGE_SIZE - 1)
-			break;
-
 		if (codec->driver->display_register) {
 			count += codec->driver->display_register(codec, buf + count,
 							 PAGE_SIZE - count, i);
 		} else {
-			/* If the read fails it's almost certainly due to
-			 * the register being volatile and the device being
-			 * powered off.
-			 */
-			ret = snd_soc_read(codec, i);
-			if (ret >= 0)
-				count += snprintf(buf + count,
-						  PAGE_SIZE - count,
-						  "%.*x", wordsize, ret);
-			else
-				count += snprintf(buf + count,
-						  PAGE_SIZE - count,
-						  "<no data: %d>", ret);
+			/* only support larger than PAGE_SIZE bytes debugfs
+			 * entries for the default case */
+			if (p >= pos) {
+				if (total + len >= count - 1)
+					break;
+				format_register_str(codec, i, buf + total, len);
+				total += len;
+			}
+			p += len;
 		}
-
-		if (count >= PAGE_SIZE - 1)
-			break;
-
-		count += snprintf(buf + count, PAGE_SIZE - count, "\n");
-		if (count >= PAGE_SIZE - 1)
-			break;
 	}
 
-	/* Truncate count; min() would cause a warning */
-	if (count >= PAGE_SIZE)
-		count = PAGE_SIZE - 1;
+	total = min(total, count - 1);
 
-	return count;
+	return total;
 }
+
 static ssize_t codec_reg_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	struct snd_soc_pcm_runtime *rtd =
 			container_of(dev, struct snd_soc_pcm_runtime, dev);
 
-	return soc_codec_reg_show(rtd->codec, buf);
+	return soc_codec_reg_show(rtd->codec, buf, PAGE_SIZE, 0);
 }
 
 static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
@@ -188,16 +212,28 @@ static int codec_reg_open_file(struct inode *inode, struct file *file)
 }
 
 static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
+				   size_t count, loff_t *ppos)
 {
 	ssize_t ret;
 	struct snd_soc_codec *codec = file->private_data;
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	char *buf;
+
+	if (*ppos < 0 || !count)
+		return -EINVAL;
+
+	buf = kmalloc(count, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
-	ret = soc_codec_reg_show(codec, buf);
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+
+	ret = soc_codec_reg_show(codec, buf, count, *ppos);
+	if (ret >= 0) {
+		if (copy_to_user(user_buf, buf, ret)) {
+			kfree(buf);
+			return -EFAULT;
+		}
+		*ppos += ret;
+	}
+
 	kfree(buf);
 	return ret;
 }

commit 88ee1c611d0ac0f771212f907bdfb33905a5dc89
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Feb 2 10:43:26 2011 +0000

    ASoC: Update PM ifdefs for exported suspend/resume
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 205cbd7b149f..10bc3c23b525 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1801,7 +1801,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	}
 	card->snd_card->dev = card->dev;
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	/* deferred resume work */
 	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
 #endif

commit 2bc9a81e2aa3c95b1e709f3109c3bbc6d969cc06
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Tue Feb 1 12:24:08 2011 +0000

    ASoC: soc-core: Ensure codec_reg has fixed length fields
    
    Make the format of the codec_reg file more easily parsable.  Remove
    the header field which gives the codec name.  These changes are important
    when it comes to extend the debugfs codec_reg file to dump more than
    PAGE_SIZE bytes to make it easier to calculate offsets within the
    file.
    
    We still need to handle the case when the snd_soc_read() call fails
    and <no data: %d> is outputted.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3feddd91b973..205cbd7b149f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -69,10 +69,32 @@ static int pmdown_time = 5000;
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
+/* returns the minimum number of bytes needed to represent
+ * a particular given value */
+static int min_bytes_needed(unsigned long val)
+{
+	int c = 0;
+	int i;
+
+	for (i = (sizeof val * 8) - 1; i >= 0; --i, ++c)
+		if (val & (1UL << i))
+			break;
+	c = (sizeof val * 8) - c;
+	if (!c || (c % 8))
+		c = (c + 8) / 8;
+	else
+		c /= 8;
+	return c;
+}
+
 /* codec register dump */
 static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 {
 	int ret, i, step = 1, count = 0;
+	int wordsize, regsize;
+
+	wordsize = codec->driver->reg_word_size * 2;
+	regsize = min_bytes_needed(codec->driver->reg_cache_size) * 2;
 
 	if (!codec->driver->reg_cache_size)
 		return 0;
@@ -80,12 +102,11 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 	if (codec->driver->reg_cache_step)
 		step = codec->driver->reg_cache_step;
 
-	count += sprintf(buf, "%s registers\n", codec->name);
 	for (i = 0; i < codec->driver->reg_cache_size; i += step) {
 		if (codec->readable_register && !codec->readable_register(codec, i))
 			continue;
 
-		count += sprintf(buf + count, "%2x: ", i);
+		count += sprintf(buf + count, "%.*x: ", regsize, i);
 		if (count >= PAGE_SIZE - 1)
 			break;
 
@@ -101,7 +122,7 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 			if (ret >= 0)
 				count += snprintf(buf + count,
 						  PAGE_SIZE - count,
-						  "%4x", ret);
+						  "%.*x", wordsize, ret);
 			else
 				count += snprintf(buf + count,
 						  PAGE_SIZE - count,

commit 111c6419ffeef0ef225dfdd2c8b7b03cc6bb228e
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Jan 28 14:26:35 2011 -0700

    ASoC: Move card list initialization to snd_soc_register_card
    
    All ASoC cards need snd_soc_initialize_card_lists called. Previously, it was
    only called for cards backed by a "soc-audio" platform device, via
    soc_probe(). However, it's also needed for cards backed by other platform
    devices, and registered directly via snd_soc_register_card().
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9dfbb8fcb765..3feddd91b973 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1881,7 +1881,6 @@ static int soc_probe(struct platform_device *pdev)
 
 	/* Bodge while we unpick instantiation */
 	card->dev = &pdev->dev;
-	snd_soc_initialize_card_lists(card);
 
 	ret = snd_soc_register_card(card);
 	if (ret != 0) {
@@ -3122,6 +3121,8 @@ int snd_soc_register_card(struct snd_soc_card *card)
 	if (!card->name || !card->dev)
 		return -EINVAL;
 
+	snd_soc_initialize_card_lists(card);
+
 	soc_init_card_debugfs(card);
 
 	card->rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime) *

commit 70d29331ac551c11e6e3934f43a548ae8154351e
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Thu Jan 27 16:24:22 2011 +0200

    ASoC: soc-core: Increment codec and platform driver refcounts before probing
    
    Commit f6c2ed5 "ASoC: Fix the device references to codec and platform drivers"
    moved codec and platform driver refcount increments from soc_bind_dai_link
    to more appropriate places.
    
    Adjust a little them so that refcounts are incremented before executing the
    driver probe functions.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Harsha Priya <priya.harsha@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e9f81c551e5e..9dfbb8fcb765 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1412,26 +1412,31 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	codec->dapm.card = card;
 	soc_set_name_prefix(card, codec);
 
+	if (!try_module_get(codec->dev->driver->owner))
+		return -ENODEV;
+
 	if (codec->driver->probe) {
 		ret = codec->driver->probe(codec);
 		if (ret < 0) {
 			dev_err(codec->dev,
 				"asoc: failed to probe CODEC %s: %d\n",
 				codec->name, ret);
-			return ret;
+			goto err_probe;
 		}
 	}
 
 	soc_init_codec_debugfs(codec);
 
 	/* mark codec as probed and add to card codec list */
-	if (!try_module_get(codec->dev->driver->owner))
-		return -ENODEV;
-
 	codec->probed = 1;
 	list_add(&codec->card_list, &card->codec_dev_list);
 	list_add(&codec->dapm.list, &card->dapm_list);
 
+	return 0;
+
+err_probe:
+	module_put(codec->dev->driver->owner);
+
 	return ret;
 }
 
@@ -1549,19 +1554,19 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 
 	/* probe the platform */
 	if (!platform->probed) {
+		if (!try_module_get(platform->dev->driver->owner))
+			return -ENODEV;
+
 		if (platform->driver->probe) {
 			ret = platform->driver->probe(platform);
 			if (ret < 0) {
 				printk(KERN_ERR "asoc: failed to probe platform %s\n",
 						platform->name);
+				module_put(platform->dev->driver->owner);
 				return ret;
 			}
 		}
 		/* mark platform as probed and add to card platform list */
-
-		if (!try_module_get(platform->dev->driver->owner))
-			return -ENODEV;
-
 		platform->probed = 1;
 		list_add(&platform->card_list, &card->platform_dev_list);
 	}

commit 8c9daae2cfe3b17f946ff998a692bddc9cd3e3b6
Merge: f85a9e0d2609 c73e0c83f512
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jan 27 15:16:52 2011 +0000

    Merge branch 'for-2.6.38' into for-2.6.39

commit aaee8ef146111566e1c607bdf368d73fb966be2e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jan 26 20:53:50 2011 +0000

    ASoC: Make cache status available via debugfs
    
    Could just as well live in sysfs but sysfs doesn't have the simple
    value export helpers debugfs does.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5dffc7a469c0..8af47f7a8fcb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -235,6 +235,11 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 		return;
 	}
 
+	debugfs_create_bool("cache_sync", 0444, codec->debugfs_codec_root,
+			    &codec->cache_sync);
+	debugfs_create_bool("cache_only", 0444, codec->debugfs_codec_root,
+			    &codec->cache_only);
+
 	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
 						 codec->debugfs_codec_root,
 						 codec, &codec_reg_fops);

commit 6f8ab4ac292f81b9246ddf363bf1c6a2fc7a0629
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jan 26 14:59:27 2011 +0000

    ASoC: Export card PM callbacks for use in direct registered cards
    
    Allow hookup of cards registered directly with the core to the PM
    operations by exporting the device power management operations to
    modules, also exporting the default PM operations since it is
    expected that most cards will end up using exactly the same setup.
    
    Note that the callbacks require that the driver data for the card be
    the snd_soc_card.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4bc2365bf1dd..5dffc7a469c0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -965,12 +965,11 @@ static struct snd_pcm_ops soc_pcm_ops = {
 	.pointer	= soc_pcm_pointer,
 };
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 /* powers down audio subsystem for suspend */
-static int soc_suspend(struct device *dev)
+int snd_soc_suspend(struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct snd_soc_card *card = dev_get_drvdata(dev);
 	struct snd_soc_codec *codec;
 	int i;
 
@@ -1082,6 +1081,7 @@ static int soc_suspend(struct device *dev)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_soc_suspend);
 
 /* deferred resume work, so resume can complete before we finished
  * setting our codec back up, which can be very slow on I2C
@@ -1187,10 +1187,9 @@ static void soc_resume_deferred(struct work_struct *work)
 }
 
 /* powers up audio subsystem after a suspend */
-static int soc_resume(struct device *dev)
+int snd_soc_resume(struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct snd_soc_card *card = dev_get_drvdata(dev);
 	int i;
 
 	/* AC97 devices might have other drivers hanging off them so
@@ -1212,9 +1211,10 @@ static int soc_resume(struct device *dev)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_soc_resume);
 #else
-#define soc_suspend	NULL
-#define soc_resume	NULL
+#define snd_soc_suspend NULL
+#define snd_soc_resume NULL
 #endif
 
 static struct snd_soc_dai_ops null_dai_ops = {
@@ -1924,10 +1924,9 @@ static int soc_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int soc_poweroff(struct device *dev)
+int snd_soc_poweroff(struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct snd_soc_card *card = dev_get_drvdata(dev);
 	int i;
 
 	if (!card->instantiated)
@@ -1944,11 +1943,12 @@ static int soc_poweroff(struct device *dev)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_soc_poweroff);
 
-static const struct dev_pm_ops soc_pm_ops = {
-	.suspend = soc_suspend,
-	.resume = soc_resume,
-	.poweroff = soc_poweroff,
+const struct dev_pm_ops snd_soc_pm_ops = {
+	.suspend = snd_soc_suspend,
+	.resume = snd_soc_resume,
+	.poweroff = snd_soc_poweroff,
 };
 
 /* ASoC platform driver */
@@ -1956,7 +1956,7 @@ static struct platform_driver soc_driver = {
 	.driver		= {
 		.name		= "soc-audio",
 		.owner		= THIS_MODULE,
-		.pm		= &soc_pm_ops,
+		.pm		= &snd_soc_pm_ops,
 	},
 	.probe		= soc_probe,
 	.remove		= soc_remove,

commit e7361ec4996c170c63c4ac379085896db85ff34d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jan 26 14:17:20 2011 +0000

    ASoC: Replace pdev with card in machine driver probe and remove
    
    In order to support cards instantiated without using soc-audio remove
    the use of the platform device in the card probe() and remove() ops.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 446838e7d3ec..4bc2365bf1dd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1717,7 +1717,6 @@ static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,
 
 static void snd_soc_instantiate_card(struct snd_soc_card *card)
 {
-	struct platform_device *pdev = to_platform_device(card->dev);
 	struct snd_soc_codec *codec;
 	struct snd_soc_codec_conf *codec_conf;
 	enum snd_soc_compress_type compress_type;
@@ -1781,7 +1780,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 
 	/* initialise the sound card only once */
 	if (card->probe) {
-		ret = card->probe(pdev);
+		ret = card->probe(card);
 		if (ret < 0)
 			goto card_probe_error;
 	}
@@ -1842,7 +1841,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 
 card_probe_error:
 	if (card->remove)
-		card->remove(pdev);
+		card->remove(card);
 
 	snd_card_free(card->snd_card);
 
@@ -1888,7 +1887,6 @@ static int soc_probe(struct platform_device *pdev)
 
 static int soc_cleanup_card_resources(struct snd_soc_card *card)
 {
-	struct platform_device *pdev = to_platform_device(card->dev);
 	int i;
 
 	/* make sure any delayed work runs */
@@ -1909,7 +1907,7 @@ static int soc_cleanup_card_resources(struct snd_soc_card *card)
 
 	/* remove the card */
 	if (card->remove)
-		card->remove(pdev);
+		card->remove(card);
 
 	kfree(card->rtd);
 	snd_card_free(card->snd_card);

commit 70b2ac126a60c87145ae8a8eb1b4dccaa0bf5468
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jan 26 14:05:25 2011 +0000

    ASoC: Use card rather than soc-audio device to card PM functions
    
    The platform device for the card is tied closely to the soc-audio
    implementation which we're currently trying to remove in favour of
    allowing cards to have their own devices. Begin removing it by
    replacing it with the card in the suspend and resume callbacks we
    give to cards, also taking the opportunity to remove the legacy
    suspend types which are currently hard coded anyway.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 14861f95f629..446838e7d3ec 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1011,7 +1011,7 @@ static int soc_suspend(struct device *dev)
 	}
 
 	if (card->suspend_pre)
-		card->suspend_pre(pdev, PMSG_SUSPEND);
+		card->suspend_pre(card);
 
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
@@ -1078,7 +1078,7 @@ static int soc_suspend(struct device *dev)
 	}
 
 	if (card->suspend_post)
-		card->suspend_post(pdev, PMSG_SUSPEND);
+		card->suspend_post(card);
 
 	return 0;
 }
@@ -1090,7 +1090,6 @@ static void soc_resume_deferred(struct work_struct *work)
 {
 	struct snd_soc_card *card =
 			container_of(work, struct snd_soc_card, deferred_resume_work);
-	struct platform_device *pdev = to_platform_device(card->dev);
 	struct snd_soc_codec *codec;
 	int i;
 
@@ -1104,7 +1103,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D2);
 
 	if (card->resume_pre)
-		card->resume_pre(pdev);
+		card->resume_pre(card);
 
 	/* resume AC97 DAIs */
 	for (i = 0; i < card->num_rtd; i++) {
@@ -1179,7 +1178,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	if (card->resume_post)
-		card->resume_post(pdev);
+		card->resume_post(card);
 
 	dev_dbg(card->dev, "resume work completed\n");
 

commit c73e0c83f512012e7c357e516a0d7c0a832bfa34
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Wed Jan 26 16:39:37 2011 +0200

    ASoC: Fix module refcount for auxiliary devices
    
    Commit f6c2ed5 "ASoC: Fix the device references to codec and platform drivers"
    moved codec driver refcount increments from soc_bind_dai_link into
    soc_probe_codec.
    
    However, the commit didn't remove try_module_get from soc_probe_aux_dev so
    the auxiliary device reference counts are incremented twice as the
    soc_probe_codec is called from soc_probe_aux_dev too.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bac7291b6ff6..c4b60610beb0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1664,9 +1664,6 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	goto out;
 
 found:
-	if (!try_module_get(codec->dev->driver->owner))
-		return -ENODEV;
-
 	ret = soc_probe_codec(card, codec);
 	if (ret < 0)
 		return ret;

commit 181e055e6bed80afbf8ba2bb5e3ce84fbd3f633c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jan 24 14:05:25 2011 +0000

    ASoC: Fix type for snd_soc_volatile_register()
    
    We generally refer to registers as unsigned ints (including in the
    underlying CODEC driver operation).
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b0e7689159c1..14861f95f629 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2029,7 +2029,8 @@ static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
  *
  * Boolean function indiciating if a CODEC register is volatile.
  */
-int snd_soc_codec_volatile_register(struct snd_soc_codec *codec, int reg)
+int snd_soc_codec_volatile_register(struct snd_soc_codec *codec,
+				    unsigned int reg)
 {
 	if (codec->volatile_register)
 		return codec->volatile_register(codec, reg);

commit 474b62d6eee733abdcd36f8e3e5ce504fbb9110b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 18 16:14:44 2011 +0000

    ASoC: Provide per widget type callback when executing DAPM sequences
    
    Many modern devices have features such as DC servos which take time to start.
    Currently these are handled by per-widget events but this makes it difficult
    to paralleise operations on multiple widgets, meaning delays can end up
    being needlessly serialised. By providing a callback to drivers when all
    widgets of a given type have been handled during a DAPM sequence the core
    allows drivers to start operations separately and wait for them to complete
    much more simply.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9e68984423b2..b0e7689159c1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3496,6 +3496,7 @@ int snd_soc_register_codec(struct device *dev,
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;
+	codec->dapm.seq_notifier = codec_drv->seq_notifier;
 	codec->dev = dev;
 	codec->driver = codec_drv;
 	codec->num_dai = num_dai;

commit 0d00a85752ab0fb4f0f7758e35d54b931a25d812
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Tue Jan 18 15:51:45 2011 +0200

    ASoC: core: Remove dapm_sync call from soc_post_component_init
    
    snd_soc_dapm_new_widgets will call dapm_power_widgets at
    the end, so there is no need to call snd_soc_dapm_sync
    after snd_soc_dapm_new_widgets.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Reviewed-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 69117b686fdc..9e68984423b2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1470,7 +1470,6 @@ static int soc_post_component_init(struct snd_soc_card *card,
 
 	/* Make sure all DAPM widgets are instantiated */
 	snd_soc_dapm_new_widgets(&codec->dapm);
-	snd_soc_dapm_sync(&codec->dapm);
 
 	/* register the rtd device */
 	rtd->codec = codec;

commit 70a7ca34dbdcc6f0ed332baf2b308bab2871424a
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Fri Jan 14 19:22:48 2011 +0530

    ASoC: soc core allow machine driver to register the card
    
    The machine driver can't register the card directly and need to do this thru
    soc-audio device creation
    
    This patch allows the register and unregister card to be directly called by
    machine drivers
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Harsha Priya <priya.harsha@intel.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 83057127b2fa..69117b686fdc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -58,8 +58,6 @@ static LIST_HEAD(dai_list);
 static LIST_HEAD(platform_list);
 static LIST_HEAD(codec_list);
 
-static int snd_soc_register_card(struct snd_soc_card *card);
-static int snd_soc_unregister_card(struct snd_soc_card *card);
 static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num);
 
 /*
@@ -1870,6 +1868,13 @@ static int soc_probe(struct platform_device *pdev)
 	struct snd_soc_card *card = platform_get_drvdata(pdev);
 	int ret = 0;
 
+	/*
+	 * no card, so machine driver should be registering card
+	 * we should not be here in that case so ret error
+	 */
+	if (!card)
+		return -EINVAL;
+
 	/* Bodge while we unpick instantiation */
 	card->dev = &pdev->dev;
 	snd_soc_initialize_card_lists(card);
@@ -3105,11 +3110,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
  *
  * @card: Card to register
  *
- * Note that currently this is an internal only function: it will be
- * exposed to machine drivers after further backporting of ASoC v2
- * registration APIs.
  */
-static int snd_soc_register_card(struct snd_soc_card *card)
+int snd_soc_register_card(struct snd_soc_card *card)
 {
 	int i;
 
@@ -3141,17 +3143,15 @@ static int snd_soc_register_card(struct snd_soc_card *card)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_soc_register_card);
 
 /**
  * snd_soc_unregister_card - Unregister a card with the ASoC core
  *
  * @card: Card to unregister
  *
- * Note that currently this is an internal only function: it will be
- * exposed to machine drivers after further backporting of ASoC v2
- * registration APIs.
  */
-static int snd_soc_unregister_card(struct snd_soc_card *card)
+int snd_soc_unregister_card(struct snd_soc_card *card)
 {
 	if (card->instantiated)
 		soc_cleanup_card_resources(card);
@@ -3162,6 +3162,7 @@ static int snd_soc_unregister_card(struct snd_soc_card *card)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_soc_unregister_card);
 
 /*
  * Simplify DAI link configuration by removing ".-1" from device names

commit 4e10bda05d6c7d4aba509bbbab5ba748d54c702f
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Jan 13 22:48:52 2011 +0530

    ASoC: soc core add inline to handle card list initialzation
    
    Currently the soc_probe initializes the card hence it does the card list
    initialzation. But if machines directly register the card they would need to
    do these steps, so putting them as inline would save lot of code
    
    This patch adds an inline to do list initialzation
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Harsha Priya <harsha.priya@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9c5e7cff3f01..83057127b2fa 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1872,12 +1872,7 @@ static int soc_probe(struct platform_device *pdev)
 
 	/* Bodge while we unpick instantiation */
 	card->dev = &pdev->dev;
-	INIT_LIST_HEAD(&card->dai_dev_list);
-	INIT_LIST_HEAD(&card->codec_dev_list);
-	INIT_LIST_HEAD(&card->platform_dev_list);
-	INIT_LIST_HEAD(&card->widgets);
-	INIT_LIST_HEAD(&card->paths);
-	INIT_LIST_HEAD(&card->dapm_list);
+	snd_soc_initialize_card_lists(card);
 
 	ret = snd_soc_register_card(card);
 	if (ret != 0) {

commit 150dd2f8c42bdb3c51533459e3ff5075d8720260
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Jan 13 22:48:32 2011 +0530

    ASoC: soc core move the card debugfs initialization
    
    The card debugfs initialization is done in soc_probe but would be better if it
    is done when the card in registered
    
    This patch moves the debugfs initialization to register_card()
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Harsha Priya <harsha.priya@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 318c3a720216..9c5e7cff3f01 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1879,8 +1879,6 @@ static int soc_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&card->paths);
 	INIT_LIST_HEAD(&card->dapm_list);
 
-	soc_init_card_debugfs(card);
-
 	ret = snd_soc_register_card(card);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to register card\n");
@@ -3123,6 +3121,8 @@ static int snd_soc_register_card(struct snd_soc_card *card)
 	if (!card->name || !card->dev)
 		return -EINVAL;
 
+	soc_init_card_debugfs(card);
+
 	card->rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime) *
 			    (card->num_links + card->num_aux_devs),
 			    GFP_KERNEL);

commit b0e264855cc42106cc41426e68651b5d67df444d
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Jan 13 22:48:02 2011 +0530

    ASoC: soc core move card cleanup from soc_remove()
    
    In soc_remove() the card resources are cleaned up.
    This can also be done in card_unregister()
    
    This patch move this cleanup into a new function and calls it from
    card_unregister. This paves way for further work to allow card registartion
    from machine.
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Harsha Priya <priya.harsha@intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 30d76e8bc9df..318c3a720216 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1890,37 +1890,42 @@ static int soc_probe(struct platform_device *pdev)
 	return 0;
 }
 
-/* removes a socdev */
-static int soc_remove(struct platform_device *pdev)
+static int soc_cleanup_card_resources(struct snd_soc_card *card)
 {
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct platform_device *pdev = to_platform_device(card->dev);
 	int i;
 
-	if (card->instantiated) {
+	/* make sure any delayed work runs */
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+		flush_delayed_work_sync(&rtd->delayed_work);
+	}
 
-		/* make sure any delayed work runs */
-		for (i = 0; i < card->num_rtd; i++) {
-			struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
-			flush_delayed_work_sync(&rtd->delayed_work);
-		}
+	/* remove auxiliary devices */
+	for (i = 0; i < card->num_aux_devs; i++)
+		soc_remove_aux_dev(card, i);
 
-		/* remove auxiliary devices */
-		for (i = 0; i < card->num_aux_devs; i++)
-			soc_remove_aux_dev(card, i);
+	/* remove and free each DAI */
+	for (i = 0; i < card->num_rtd; i++)
+		soc_remove_dai_link(card, i);
 
-		/* remove and free each DAI */
-		for (i = 0; i < card->num_rtd; i++)
-			soc_remove_dai_link(card, i);
+	soc_cleanup_card_debugfs(card);
 
-		soc_cleanup_card_debugfs(card);
+	/* remove the card */
+	if (card->remove)
+		card->remove(pdev);
 
-		/* remove the card */
-		if (card->remove)
-			card->remove(pdev);
+	kfree(card->rtd);
+	snd_card_free(card->snd_card);
+	return 0;
+
+}
+
+/* removes a socdev */
+static int soc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
 
-		kfree(card->rtd);
-		snd_card_free(card->snd_card);
-	}
 	snd_soc_unregister_card(card);
 	return 0;
 }
@@ -3153,6 +3158,8 @@ static int snd_soc_register_card(struct snd_soc_card *card)
  */
 static int snd_soc_unregister_card(struct snd_soc_card *card)
 {
+	if (card->instantiated)
+		soc_cleanup_card_resources(card);
 	mutex_lock(&client_mutex);
 	list_del(&card->list);
 	mutex_unlock(&client_mutex);

commit 1500b7b5ffaacb8199e0a61162f5d349fb19acbe
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Jan 13 12:20:38 2011 +0000

    ASoC: Automatically assign the default readable()/volatile() functions
    
    Ensure that all calls to readable_register()/volatile_register() go via
    the snd_soc_codec function pointers.
    
    If the default register access table has been given but no functions
    for handling readable()/volatile() registers, use the default ones provided
    by soc-cache.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b5e5758456bd..30d76e8bc9df 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -84,7 +84,7 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 
 	count += sprintf(buf, "%s registers\n", codec->name);
 	for (i = 0; i < codec->driver->reg_cache_size; i += step) {
-		if (codec->driver->readable_register && !codec->driver->readable_register(codec, i))
+		if (codec->readable_register && !codec->readable_register(codec, i))
 			continue;
 
 		count += sprintf(buf + count, "%2x: ", i);
@@ -2029,8 +2029,8 @@ static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
  */
 int snd_soc_codec_volatile_register(struct snd_soc_codec *codec, int reg)
 {
-	if (codec->driver->volatile_register)
-		return codec->driver->volatile_register(codec, reg);
+	if (codec->volatile_register)
+		return codec->volatile_register(codec, reg);
 	else
 		return 0;
 }
@@ -3489,6 +3489,8 @@ int snd_soc_register_codec(struct device *dev,
 
 	codec->write = codec_drv->write;
 	codec->read = codec_drv->read;
+	codec->volatile_register = codec_drv->volatile_register;
+	codec->readable_register = codec_drv->readable_register;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;
@@ -3517,6 +3519,13 @@ int snd_soc_register_codec(struct device *dev,
 		}
 	}
 
+	if (codec_drv->reg_access_size && codec_drv->reg_access_default) {
+		if (!codec->volatile_register)
+			codec->volatile_register = snd_soc_default_volatile_register;
+		if (!codec->readable_register)
+			codec->readable_register = snd_soc_default_readable_register;
+	}
+
 	for (i = 0; i < num_dai; i++) {
 		fixup_codec_formats(&dai_drv[i].playback);
 		fixup_codec_formats(&dai_drv[i].capture);

commit d4754ec91c7b094298f0b2ba02327e6887671edc
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Jan 13 12:20:37 2011 +0000

    ASoC: Update users of readable_register()/volatile_register()
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cbac50b69c39..b5e5758456bd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -84,7 +84,7 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 
 	count += sprintf(buf, "%s registers\n", codec->name);
 	for (i = 0; i < codec->driver->reg_cache_size; i += step) {
-		if (codec->driver->readable_register && !codec->driver->readable_register(i))
+		if (codec->driver->readable_register && !codec->driver->readable_register(codec, i))
 			continue;
 
 		count += sprintf(buf + count, "%2x: ", i);
@@ -2030,7 +2030,7 @@ static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 int snd_soc_codec_volatile_register(struct snd_soc_codec *codec, int reg)
 {
 	if (codec->driver->volatile_register)
-		return codec->driver->volatile_register(reg);
+		return codec->driver->volatile_register(codec, reg);
 	else
 		return 0;
 }

commit aea170a099793abcd0e6de46b947458073204241
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Wed Jan 12 10:38:58 2011 +0000

    ASoC: soc-cache: Add reg_size as a member to snd_soc_codec
    
    Simplify the use of reg_size, by calculating it once and storing it in
    the codec structure for later reference.  The value of reg_size is
    reg_cache_size * reg_word_size.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 04475c18003c..cbac50b69c39 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3500,6 +3500,7 @@ int snd_soc_register_codec(struct device *dev,
 	/* allocate CODEC register cache */
 	if (codec_drv->reg_cache_size && codec_drv->reg_word_size) {
 		reg_size = codec_drv->reg_cache_size * codec_drv->reg_word_size;
+		codec->reg_size = reg_size;
 		/* it is necessary to make a copy of the default register cache
 		 * because in the case of using a compression type that requires
 		 * the default register cache to be marked as __devinitconst the

commit 9f040c7941df09eca6e6a15cfa766b719d8cafb3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jan 10 19:06:08 2011 +0000

    ASoC: Fix indentation in soc_remove()
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fb170a073763..04475c18003c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1896,7 +1896,7 @@ static int soc_remove(struct platform_device *pdev)
 	struct snd_soc_card *card = platform_get_drvdata(pdev);
 	int i;
 
-		if (card->instantiated) {
+	if (card->instantiated) {
 
 		/* make sure any delayed work runs */
 		for (i = 0; i < card->num_rtd; i++) {

commit 861f2faf4fbd4fb46a436d41dcb5ff75b243ab3a
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Tue Jan 11 11:43:51 2011 +0000

    ASoC: soc-core: Simplify compress_type overriding functionality
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6cc68140fa67..fb170a073763 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1748,6 +1748,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	list_for_each_entry(codec, &codec_list, list) {
 		if (codec->cache_init)
 			continue;
+		/* by default we don't override the compress_type */
+		compress_type = 0;
 		/* check to see if we need to override the compress_type */
 		for (i = 0; i < card->num_configs; ++i) {
 			codec_conf = &card->codec_conf[i];
@@ -1758,18 +1760,6 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 					break;
 			}
 		}
-		if (i == card->num_configs) {
-			/* no need to override the compress_type so
-			 * go ahead and do the standard thing */
-			ret = snd_soc_init_codec_cache(codec, 0);
-			if (ret < 0) {
-				mutex_unlock(&card->mutex);
-				return;
-			}
-			continue;
-		}
-		/* override the compress_type with the one supplied in
-		 * the machine driver */
 		ret = snd_soc_init_codec_cache(codec, compress_type);
 		if (ret < 0) {
 			mutex_unlock(&card->mutex);

commit 180c329d6b0db49687c88303e7f3754e7afdc3bf
Author: Timur Tabi <timur@freescale.com>
Date:   Mon Jan 10 15:58:13 2011 -0600

    ASoC: let snd_soc_update_bits() return an error code
    
    Update snd_soc_update_bits() so that it returns a negative error code if the
    the read or write operation fails.
    
    Note that currently, a lot of the lower-level read functions have an unsigned
    integer return type (and some of them even try to return a negative number),
    but this code still appears to work in those cases.
    
    An examination of the code shows that all current callers are compatible with
    this change.
    
    Signed-off-by: Timur Tabi <timur@freescale.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2ff708a41119..6cc68140fa67 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2137,19 +2137,27 @@ EXPORT_SYMBOL_GPL(snd_soc_write);
  *
  * Writes new register value.
  *
- * Returns 1 for change else 0.
+ * Returns 1 for change, 0 for no change, or negative error code.
  */
 int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
 				unsigned int mask, unsigned int value)
 {
 	int change;
 	unsigned int old, new;
+	int ret;
 
-	old = snd_soc_read(codec, reg);
+	ret = snd_soc_read(codec, reg);
+	if (ret < 0)
+		return ret;
+
+	old = ret;
 	new = (old & ~mask) | value;
 	change = old != new;
-	if (change)
-		snd_soc_write(codec, reg, new);
+	if (change) {
+		ret = snd_soc_write(codec, reg, new);
+		if (ret < 0)
+			return ret;
+	}
 
 	return change;
 }

commit 8a9dab1a555e3f2088c68cae792dfd7e854e65e4
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jan 10 22:25:21 2011 +0000

    ASoC: Update name of debugfs root symbol to snd_soc_
    
    Everything else is using snd_soc_ so we should use it here too.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0484e504b589..2ff708a41119 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -48,8 +48,8 @@ static DEFINE_MUTEX(pcm_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 
 #ifdef CONFIG_DEBUG_FS
-struct dentry *asoc_debugfs_root;
-EXPORT_SYMBOL_GPL(asoc_debugfs_root);
+struct dentry *snd_soc_debugfs_root;
+EXPORT_SYMBOL_GPL(snd_soc_debugfs_root);
 #endif
 
 static DEFINE_MUTEX(client_mutex);
@@ -361,7 +361,7 @@ static const struct file_operations platform_list_fops = {
 static void soc_init_card_debugfs(struct snd_soc_card *card)
 {
 	card->debugfs_card_root = debugfs_create_dir(card->name,
-						     asoc_debugfs_root);
+						     snd_soc_debugfs_root);
 	if (!card->debugfs_card_root) {
 		dev_warn(card->dev,
 			 "ASoC: Failed to create codec debugfs directory\n");
@@ -3584,22 +3584,22 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
 static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS
-	asoc_debugfs_root = debugfs_create_dir("asoc", NULL);
-	if (IS_ERR(asoc_debugfs_root) || !asoc_debugfs_root) {
+	snd_soc_debugfs_root = debugfs_create_dir("asoc", NULL);
+	if (IS_ERR(snd_soc_debugfs_root) || !snd_soc_debugfs_root) {
 		printk(KERN_WARNING
 		       "ASoC: Failed to create debugfs directory\n");
-		asoc_debugfs_root = NULL;
+		snd_soc_debugfs_root = NULL;
 	}
 
-	if (!debugfs_create_file("codecs", 0444, asoc_debugfs_root, NULL,
+	if (!debugfs_create_file("codecs", 0444, snd_soc_debugfs_root, NULL,
 				 &codec_list_fops))
 		pr_warn("ASoC: Failed to create CODEC list debugfs file\n");
 
-	if (!debugfs_create_file("dais", 0444, asoc_debugfs_root, NULL,
+	if (!debugfs_create_file("dais", 0444, snd_soc_debugfs_root, NULL,
 				 &dai_list_fops))
 		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
 
-	if (!debugfs_create_file("platforms", 0444, asoc_debugfs_root, NULL,
+	if (!debugfs_create_file("platforms", 0444, snd_soc_debugfs_root, NULL,
 				 &platform_list_fops))
 		pr_warn("ASoC: Failed to create platform list debugfs file\n");
 #endif
@@ -3611,7 +3611,7 @@ module_init(snd_soc_init);
 static void __exit snd_soc_exit(void)
 {
 #ifdef CONFIG_DEBUG_FS
-	debugfs_remove_recursive(asoc_debugfs_root);
+	debugfs_remove_recursive(snd_soc_debugfs_root);
 #endif
 	platform_driver_unregister(&soc_driver);
 }

commit faff4bb067d15a3bc0dde8c50cbc1a7075e314de
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Jan 7 22:36:11 2011 -0700

    ASoC: Export debugfs root dentry
    
    A couple Tegra ASoC drivers will create debugfs entries. Mark requested
    these by under debugfs/asoc/ not just debugfs/. To enable this, export
    the dentry representing debugfs/asoc/.
    
    Also, rename debugfs_root -> asoc_debugfs_root now it's exported to
    prevent potential symbol name clashes.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4274435853df..0484e504b589 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -48,7 +48,8 @@ static DEFINE_MUTEX(pcm_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 
 #ifdef CONFIG_DEBUG_FS
-static struct dentry *debugfs_root;
+struct dentry *asoc_debugfs_root;
+EXPORT_SYMBOL_GPL(asoc_debugfs_root);
 #endif
 
 static DEFINE_MUTEX(client_mutex);
@@ -360,7 +361,7 @@ static const struct file_operations platform_list_fops = {
 static void soc_init_card_debugfs(struct snd_soc_card *card)
 {
 	card->debugfs_card_root = debugfs_create_dir(card->name,
-						     debugfs_root);
+						     asoc_debugfs_root);
 	if (!card->debugfs_card_root) {
 		dev_warn(card->dev,
 			 "ASoC: Failed to create codec debugfs directory\n");
@@ -3583,22 +3584,22 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
 static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS
-	debugfs_root = debugfs_create_dir("asoc", NULL);
-	if (IS_ERR(debugfs_root) || !debugfs_root) {
+	asoc_debugfs_root = debugfs_create_dir("asoc", NULL);
+	if (IS_ERR(asoc_debugfs_root) || !asoc_debugfs_root) {
 		printk(KERN_WARNING
 		       "ASoC: Failed to create debugfs directory\n");
-		debugfs_root = NULL;
+		asoc_debugfs_root = NULL;
 	}
 
-	if (!debugfs_create_file("codecs", 0444, debugfs_root, NULL,
+	if (!debugfs_create_file("codecs", 0444, asoc_debugfs_root, NULL,
 				 &codec_list_fops))
 		pr_warn("ASoC: Failed to create CODEC list debugfs file\n");
 
-	if (!debugfs_create_file("dais", 0444, debugfs_root, NULL,
+	if (!debugfs_create_file("dais", 0444, asoc_debugfs_root, NULL,
 				 &dai_list_fops))
 		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
 
-	if (!debugfs_create_file("platforms", 0444, debugfs_root, NULL,
+	if (!debugfs_create_file("platforms", 0444, asoc_debugfs_root, NULL,
 				 &platform_list_fops))
 		pr_warn("ASoC: Failed to create platform list debugfs file\n");
 #endif
@@ -3610,7 +3611,7 @@ module_init(snd_soc_init);
 static void __exit snd_soc_exit(void)
 {
 #ifdef CONFIG_DEBUG_FS
-	debugfs_remove_recursive(debugfs_root);
+	debugfs_remove_recursive(asoc_debugfs_root);
 #endif
 	platform_driver_unregister(&soc_driver);
 }

commit 2aa86323d815bab62a7e1d3ef8ed6c81a6dfeffa
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Jan 10 10:10:56 2011 +0000

    ASoC: soc-core: Add support for NULL default register caches
    
    The infrastructure for handling NULL default register maps is already
    included in the soc-cache code, just ensure that we don't try to dereference
    a NULL pointer while accessing a NULL register cache.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Timur Tabi <timur@freescale.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 96bf381683f7..4274435853df 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3507,11 +3507,13 @@ int snd_soc_register_codec(struct device *dev,
 		 * kernel might have freed the array by the time we initialize
 		 * the cache.
 		 */
-		codec->reg_def_copy = kmemdup(codec_drv->reg_cache_default,
-					      reg_size, GFP_KERNEL);
-		if (!codec->reg_def_copy) {
-			ret = -ENOMEM;
-			goto fail;
+		if (codec_drv->reg_cache_default) {
+			codec->reg_def_copy = kmemdup(codec_drv->reg_cache_default,
+						      reg_size, GFP_KERNEL);
+			if (!codec->reg_def_copy) {
+				ret = -ENOMEM;
+				goto fail;
+			}
 		}
 	}
 

commit 0d51a9cbb6c1275cc0f3840c36f8b7840a438c59
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jan 6 16:04:57 2011 +0000

    ASoC: Taint the kernel if debugfs is used to write directly to CODECs
    
    Since direct register writes may confuse the drivers and are supposed
    to be used only in diagnostic situations discourage their use in
    production by tainting the kernel when we do a write.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bac7291b6ff6..96bf381683f7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -209,6 +209,10 @@ static ssize_t codec_reg_write_file(struct file *file,
 		start++;
 	if (strict_strtoul(start, 16, &value))
 		return -EINVAL;
+
+	/* Userspace has been fiddling around behind the kernel's back */
+	add_taint(TAINT_USER);
+
 	snd_soc_write(codec, reg, value);
 	return buf_size;
 }

commit f6c2ed5dd6ab43447dacc136585fc894e3f3a82d
Author: Harsha Priya <priya.harsha@intel.com>
Date:   Wed Jan 5 11:34:51 2011 +0530

    ASoC: Fix the device references to codec and platform drivers
    
    The soc-core takes the platform and codec driver reference during probe. Few of
    these references are not released during remove. This cause the platform and
    codec driver module unload to fail.
    
    This patch fixes by the taking only one reference to platform and codec module
    during probe and releases them correctly during remove. This allows load/unload
    properly
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Harsha Priya <priya.harsha@intel.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a233607a73c6..bac7291b6ff6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1259,9 +1259,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 		if (!strcmp(codec->name, dai_link->codec_name)) {
 			rtd->codec = codec;
 
-			if (!try_module_get(codec->dev->driver->owner))
-				return -ENODEV;
-
 			/* CODEC found, so find CODEC DAI from registered DAIs from this CODEC*/
 			list_for_each_entry(codec_dai, &dai_list, list) {
 				if (codec->dev == codec_dai->dev &&
@@ -1287,10 +1284,6 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	/* no, then find CPU DAI from registered DAIs*/
 	list_for_each_entry(platform, &platform_list, list) {
 		if (!strcmp(platform->name, dai_link->platform_name)) {
-
-			if (!try_module_get(platform->dev->driver->owner))
-				return -ENODEV;
-
 			rtd->platform = platform;
 			goto out;
 		}
@@ -1425,6 +1418,9 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	soc_init_codec_debugfs(codec);
 
 	/* mark codec as probed and add to card codec list */
+	if (!try_module_get(codec->dev->driver->owner))
+		return -ENODEV;
+
 	codec->probed = 1;
 	list_add(&codec->card_list, &card->codec_dev_list);
 	list_add(&codec->dapm.list, &card->dapm_list);
@@ -1556,6 +1552,10 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 			}
 		}
 		/* mark platform as probed and add to card platform list */
+
+		if (!try_module_get(platform->dev->driver->owner))
+			return -ENODEV;
+
 		platform->probed = 1;
 		list_add(&platform->card_list, &card->platform_dev_list);
 	}

commit 7be31be880ee00c6f8d38184368e8a834923b469
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Tue Dec 14 12:18:32 2010 +0200

    ASoC: Extend DAPM to handle power changes on cross-device paths
    
    Power change event like stream start/stop or kcontrol change in a
    cross-device path originates from one device but codec bias and widget power
    changes must be populated to another devices on that path as well.
    
    This patch modifies the dapm_power_widgets so that all the widgets on a
    sound card are checked for a power change, not just those that are specific
    to originating device. Also bias management is extended to check all the
    devices. Only exception in bias management are widgetless codecs whose bias
    state is changed only if power change is originating from that context.
    
    DAPM context test is added to dapm_seq_run to take care of if power sequence
    extends to an another device which requires separate register writes.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bd183a7ed696..a233607a73c6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1427,6 +1427,7 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	/* mark codec as probed and add to card codec list */
 	codec->probed = 1;
 	list_add(&codec->card_list, &card->codec_dev_list);
+	list_add(&codec->dapm.list, &card->dapm_list);
 
 	return ret;
 }
@@ -1881,6 +1882,7 @@ static int soc_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&card->platform_dev_list);
 	INIT_LIST_HEAD(&card->widgets);
 	INIT_LIST_HEAD(&card->paths);
+	INIT_LIST_HEAD(&card->dapm_list);
 
 	soc_init_card_debugfs(card);
 

commit 97c866defc0fc6e18b49603ac19f732f53e79c46
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Tue Dec 14 12:18:31 2010 +0200

    ASoC: Move widgets from DAPM context to snd_soc_card
    
    Decoupling widgets from DAPM context is required when extending the ASoC
    core to cross-device paths. Even the list of widgets are now kept in
    struct snd_soc_card, the widget listing in sysfs and debugs remain sorted
    per device.
    
    This patch makes possible to build cross-device paths but does not extend
    yet the DAPM to handle codec bias and widget power changes of an another
    device.
    
    Cross-device paths are registered by listing the widgets from device A in
    a map for device B. In case of conflicting widget names between the devices,
    a uniform name prefix is needed to separate them. See commit ead9b91
    "ASoC: Add optional name_prefix for kcontrol, widget and route names" for
    help.
    
    An example below shows a path that connects MONO out of A into Line In of B:
    
    static const struct snd_soc_dapm_route mapA[] = {
            {"MONO", NULL, "DAC"},
    };
    
    static const struct snd_soc_dapm_route mapB[] = {
            {"Line In", NULL, "MONO"},
    };
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bdb2ca9da58b..bd183a7ed696 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1879,6 +1879,7 @@ static int soc_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&card->dai_dev_list);
 	INIT_LIST_HEAD(&card->codec_dev_list);
 	INIT_LIST_HEAD(&card->platform_dev_list);
+	INIT_LIST_HEAD(&card->widgets);
 	INIT_LIST_HEAD(&card->paths);
 
 	soc_init_card_debugfs(card);
@@ -3481,7 +3482,6 @@ int snd_soc_register_codec(struct device *dev,
 	else
 		codec->compress_type = SND_SOC_FLAT_COMPRESSION;
 
-	INIT_LIST_HEAD(&codec->dapm.widgets);
 	codec->write = codec_drv->write;
 	codec->read = codec_drv->read;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;

commit 8ddab3f5107c3955e70e87a632d4d179ddba1189
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Tue Dec 14 12:18:30 2010 +0200

    ASoC: Move DAPM paths from DAPM context to snd_soc_card
    
    Decoupling DAPM paths from DAPM context is a first prerequisite when
    extending ASoC core to cross-device paths. This patch is almost a nullop and
    does not allow to construct cross-device setup but the path clean-up part in
    dapm_free_widgets is prepared to remove cross-device paths between a device
    being removed and others.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1dc4b11c1988..bdb2ca9da58b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1879,6 +1879,7 @@ static int soc_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&card->dai_dev_list);
 	INIT_LIST_HEAD(&card->codec_dev_list);
 	INIT_LIST_HEAD(&card->platform_dev_list);
+	INIT_LIST_HEAD(&card->paths);
 
 	soc_init_card_debugfs(card);
 
@@ -3481,7 +3482,6 @@ int snd_soc_register_codec(struct device *dev,
 		codec->compress_type = SND_SOC_FLAT_COMPRESSION;
 
 	INIT_LIST_HEAD(&codec->dapm.widgets);
-	INIT_LIST_HEAD(&codec->dapm.paths);
 	codec->write = codec_drv->write;
 	codec->read = codec_drv->read;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;

commit 7d8316df44053687625eef792d53b3ac62e82248
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 13 17:03:27 2010 +0000

    ASoC: Fix AC'97 registration unwind
    
    soc_unregister_ac97_dai_link() takes a CODEC as an argument, not a
    rtd like the registration function, so give it what it's looking for.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 68edc693a8a5..1dc4b11c1988 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1830,7 +1830,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: failed to register AC97 %s\n", card->name);
 			while (--i >= 0)
-				soc_unregister_ac97_dai_link(&card->rtd[i]);
+				soc_unregister_ac97_dai_link(card->rtd[i].codec);
 			goto probe_aux_dev_err;
 		}
 	}

commit 20aeeb356ba2e8daa99b5942c528ae2b3ea28433
Merge: 07a9e2b2fbdd 5b84ba26a967
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 13 09:28:43 2010 +0100

    Merge branch 'topic/workq-update' into topic/asoc
    
    Conflicts:
            sound/soc/codecs/wm8350.c
            sound/soc/codecs/wm8753.c
            sound/soc/sh/fsi.c
            sound/soc/soc-core.c

commit 5b84ba26a9672e615897234fa5efd3eea2d6b295
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Dec 11 17:51:26 2010 +0100

    sound: don't use flush_scheduled_work()
    
    flush_scheduled_work() is deprecated and scheduled to be removed.
    
    * cancel[_delayed]_work() + flush_scheduled_work() ->
      cancel[_delayed]_work_sync().
    
    * wm8350, wm8753 and soc-core use custom code to cancel a delayed
      work, execute it immediately if it was pending and wait for its
      completion.  This is equivalent to flush_delayed_work_sync().  Use
      it instead.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 441285ade024..b54ea9a0a1db 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -67,25 +67,6 @@ static int pmdown_time = 5000;
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
-/*
- * This function forces any delayed work to be queued and run.
- */
-static int run_delayed_work(struct delayed_work *dwork)
-{
-	int ret;
-
-	/* cancel any work waiting to be queued. */
-	ret = cancel_delayed_work(dwork);
-
-	/* if there was any work waiting then we run it now and
-	 * wait for it's completion */
-	if (ret) {
-		schedule_delayed_work(dwork, 0);
-		flush_scheduled_work();
-	}
-	return ret;
-}
-
 /* codec register dump */
 static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 {
@@ -1016,7 +997,7 @@ static int soc_suspend(struct device *dev)
 
 	/* close any waiting streams and save state */
 	for (i = 0; i < card->num_rtd; i++) {
-		run_delayed_work(&card->rtd[i].delayed_work);
+		flush_delayed_work_sync(&card->rtd[i].delayed_work);
 		card->rtd[i].codec->suspend_bias_level = card->rtd[i].codec->bias_level;
 	}
 
@@ -1687,7 +1668,7 @@ static int soc_remove(struct platform_device *pdev)
 		/* make sure any delayed work runs */
 		for (i = 0; i < card->num_rtd; i++) {
 			struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
-			run_delayed_work(&rtd->delayed_work);
+			flush_delayed_work_sync(&rtd->delayed_work);
 		}
 
 		/* remove and free each DAI */
@@ -1718,7 +1699,7 @@ static int soc_poweroff(struct device *dev)
 	 * now, we're shutting down so no imminent restart. */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
-		run_delayed_work(&rtd->delayed_work);
+		flush_delayed_work_sync(&rtd->delayed_work);
 	}
 
 	snd_soc_dapm_shutdown(card);

commit e4f078d8c0790e94e09af975ca0b870e2f050e17
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Tue Dec 7 16:30:38 2010 +0000

    ASoC: soc-core: Fix null pointer dereference
    
    In case the codec driver did not provide a read/write function,
    codec->driver->read|write will be NULL.  Ensure that we use the one
    specified in codec->read|write to avoid oopsing when we access
    the debugfs entries.  This is achieved by using snd_soc_read() and
    snd_soc_write().
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b4c8c3800503..a14a0507bbd0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -117,7 +117,7 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 			 * the register being volatile and the device being
 			 * powered off.
 			 */
-			ret = codec->driver->read(codec, i);
+			ret = snd_soc_read(codec, i);
 			if (ret >= 0)
 				count += snprintf(buf + count,
 						  PAGE_SIZE - count,
@@ -228,7 +228,7 @@ static ssize_t codec_reg_write_file(struct file *file,
 		start++;
 	if (strict_strtoul(start, 16, &value))
 		return -EINVAL;
-	codec->driver->write(codec, reg, value);
+	snd_soc_write(codec, reg, value);
 	return buf_size;
 }
 

commit 6b3ed78535c5af8c1d25ed7eaaea7557698843a1
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Dec 7 16:12:29 2010 +0800

    ASoC: Fix snd_soc_instantiate_card error path
    
    Properly free the resources in the case of snd_card_register failure
    and soc_register_ac97_dai_link failure.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 392d33625327..b4c8c3800503 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1839,18 +1839,20 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	ret = snd_card_register(card->snd_card);
 	if (ret < 0) {
 		printk(KERN_ERR "asoc: failed to register soundcard for %s\n", card->name);
-		goto probe_dai_err;
+		goto probe_aux_dev_err;
 	}
 
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	/* register any AC97 codecs */
 	for (i = 0; i < card->num_rtd; i++) {
-			ret = soc_register_ac97_dai_link(&card->rtd[i]);
-			if (ret < 0) {
-				printk(KERN_ERR "asoc: failed to register AC97 %s\n", card->name);
-				goto probe_dai_err;
-			}
+		ret = soc_register_ac97_dai_link(&card->rtd[i]);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: failed to register AC97 %s\n", card->name);
+			while (--i >= 0)
+				soc_unregister_ac97_dai_link(&card->rtd[i]);
+			goto probe_aux_dev_err;
 		}
+	}
 #endif
 
 	card->instantiated = 1;

commit 0b9a214a606f8c7c7af3e66e7fe0caf3233cfe16
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Dec 6 15:49:20 2010 +0000

    ASoC: soc-core: Remove useless inline function construct
    
    There is no need to mark this function as inline.  Inline functions
    usually are small and concise functions that benefit from not needing
    to set up a stack frame and undergo a call/ret sequence upon each
    invocation.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b2c327b14b00..392d33625327 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3175,7 +3175,7 @@ static int snd_soc_unregister_card(struct snd_soc_card *card)
  * Simplify DAI link configuration by removing ".-1" from device names
  * and sanitizing names.
  */
-static inline char *fmt_single_name(struct device *dev, int *id)
+static char *fmt_single_name(struct device *dev, int *id)
 {
 	char *found, name[NAME_SIZE];
 	int id1, id2;

commit 58818a77cd415e2f76607749de5a1ff24e58cefe
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Dec 6 15:42:17 2010 +0000

    ASoC: soc-core: Replace use of strncpy() with strlcpy()
    
    By using strncpy() if the source string does not have a null byte in the
    first n bytes, then the destination string is not null-terminated.
    This can be fixed in a two-step process by manually null-terminating the
    array after the use of strncpy() or by using strlcpy().
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b3605a1c8c46..b2c327b14b00 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3183,7 +3183,7 @@ static inline char *fmt_single_name(struct device *dev, int *id)
 	if (dev_name(dev) == NULL)
 		return NULL;
 
-	strncpy(name, dev_name(dev), NAME_SIZE);
+	strlcpy(name, dev_name(dev), NAME_SIZE);
 
 	/* are we a "%s.%d" name (platform and SPI components) */
 	found = strstr(name, dev->driver->name);
@@ -3206,7 +3206,7 @@ static inline char *fmt_single_name(struct device *dev, int *id)
 
 			/* sanitize component name for DAI link creation */
 			snprintf(tmp, NAME_SIZE, "%s.%s", dev->driver->name, name);
-			strncpy(name, tmp, NAME_SIZE);
+			strlcpy(name, tmp, NAME_SIZE);
 		} else
 			*id = 0;
 	}

commit 589c3563f6476950f26b5bcc9beb1b39a7bcc644
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Mon Dec 6 16:27:07 2010 +0200

    ASoC: Merge common code in DAI link and auxiliary codec probing/removal
    
    Commit 2eea392 "ASoC: Add support for optional auxiliary dailess codecs"
    added much of code that can be shared with DAI link codec probing/removal.
    Merge now this common code into new soc_probe_codec, soc_remove_codec and
    soc_post_component_init functions.
    
    Error prints in these functions are converted to use dev_err and to print
    the error code.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 17dcd56a2520..b3605a1c8c46 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1328,6 +1328,27 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	return 1;
 }
 
+static void soc_remove_codec(struct snd_soc_codec *codec)
+{
+	int err;
+
+	if (codec->driver->remove) {
+		err = codec->driver->remove(codec);
+		if (err < 0)
+			dev_err(codec->dev,
+				"asoc: failed to remove %s: %d\n",
+				codec->name, err);
+	}
+
+	/* Make sure all DAPM widgets are freed */
+	snd_soc_dapm_free(&codec->dapm);
+
+	soc_cleanup_codec_debugfs(codec);
+	codec->probed = 0;
+	list_del(&codec->card_list);
+	module_put(codec->dev->driver->owner);
+}
+
 static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
@@ -1339,6 +1360,7 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
 		device_remove_file(&rtd->dev, &dev_attr_pmdown_time);
+		device_remove_file(&rtd->dev, &dev_attr_codec_reg);
 		device_unregister(&rtd->dev);
 		rtd->dev_registered = 0;
 	}
@@ -1367,22 +1389,8 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 	}
 
 	/* remove the CODEC */
-	if (codec && codec->probed) {
-		if (codec->driver->remove) {
-			err = codec->driver->remove(codec);
-			if (err < 0)
-				printk(KERN_ERR "asoc: failed to remove %s\n", codec->name);
-		}
-
-		/* Make sure all DAPM widgets are freed */
-		snd_soc_dapm_free(&codec->dapm);
-
-		soc_cleanup_codec_debugfs(codec);
-		device_remove_file(&rtd->dev, &dev_attr_codec_reg);
-		codec->probed = 0;
-		list_del(&codec->card_list);
-		module_put(codec->dev->driver->owner);
-	}
+	if (codec && codec->probed)
+		soc_remove_codec(codec);
 
 	/* remove the cpu_dai */
 	if (cpu_dai && cpu_dai->probed) {
@@ -1414,8 +1422,105 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 	}
 }
 
+static int soc_probe_codec(struct snd_soc_card *card,
+			   struct snd_soc_codec *codec)
+{
+	int ret = 0;
+
+	codec->card = card;
+	codec->dapm.card = card;
+	soc_set_name_prefix(card, codec);
+
+	if (codec->driver->probe) {
+		ret = codec->driver->probe(codec);
+		if (ret < 0) {
+			dev_err(codec->dev,
+				"asoc: failed to probe CODEC %s: %d\n",
+				codec->name, ret);
+			return ret;
+		}
+	}
+
+	soc_init_codec_debugfs(codec);
+
+	/* mark codec as probed and add to card codec list */
+	codec->probed = 1;
+	list_add(&codec->card_list, &card->codec_dev_list);
+
+	return ret;
+}
+
 static void rtd_release(struct device *dev) {}
 
+static int soc_post_component_init(struct snd_soc_card *card,
+				   struct snd_soc_codec *codec,
+				   int num, int dailess)
+{
+	struct snd_soc_dai_link *dai_link = NULL;
+	struct snd_soc_aux_dev *aux_dev = NULL;
+	struct snd_soc_pcm_runtime *rtd;
+	const char *temp, *name;
+	int ret = 0;
+
+	if (!dailess) {
+		dai_link = &card->dai_link[num];
+		rtd = &card->rtd[num];
+		name = dai_link->name;
+	} else {
+		aux_dev = &card->aux_dev[num];
+		rtd = &card->rtd_aux[num];
+		name = aux_dev->name;
+	}
+
+	/* machine controls, routes and widgets are not prefixed */
+	temp = codec->name_prefix;
+	codec->name_prefix = NULL;
+
+	/* do machine specific initialization */
+	if (!dailess && dai_link->init)
+		ret = dai_link->init(rtd);
+	else if (dailess && aux_dev->init)
+		ret = aux_dev->init(&codec->dapm);
+	if (ret < 0) {
+		dev_err(card->dev, "asoc: failed to init %s: %d\n", name, ret);
+		return ret;
+	}
+	codec->name_prefix = temp;
+
+	/* Make sure all DAPM widgets are instantiated */
+	snd_soc_dapm_new_widgets(&codec->dapm);
+	snd_soc_dapm_sync(&codec->dapm);
+
+	/* register the rtd device */
+	rtd->codec = codec;
+	rtd->card = card;
+	rtd->dev.parent = card->dev;
+	rtd->dev.release = rtd_release;
+	rtd->dev.init_name = name;
+	ret = device_register(&rtd->dev);
+	if (ret < 0) {
+		dev_err(card->dev,
+			"asoc: failed to register runtime device: %d\n", ret);
+		return ret;
+	}
+	rtd->dev_registered = 1;
+
+	/* add DAPM sysfs entries for this codec */
+	ret = snd_soc_dapm_sys_add(&rtd->dev);
+	if (ret < 0)
+		dev_err(codec->dev,
+			"asoc: failed to add codec dapm sysfs entries: %d\n",
+			ret);
+
+	/* add codec sysfs entries */
+	ret = device_create_file(&rtd->dev, &dev_attr_codec_reg);
+	if (ret < 0)
+		dev_err(codec->dev,
+			"asoc: failed to add codec sysfs files: %d\n", ret);
+
+	return 0;
+}
+
 static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
@@ -1423,17 +1528,13 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	struct snd_soc_codec *codec = rtd->codec;
 	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
-	const char *temp;
 	int ret;
 
 	dev_dbg(card->dev, "probe %s dai link %d\n", card->name, num);
 
 	/* config components */
 	codec_dai->codec = codec;
-	codec->card = card;
 	cpu_dai->platform = platform;
-	rtd->card = card;
-	rtd->dev.parent = card->dev;
 	codec_dai->card = card;
 	cpu_dai->card = card;
 
@@ -1457,22 +1558,9 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 
 	/* probe the CODEC */
 	if (!codec->probed) {
-		codec->dapm.card = card;
-		soc_set_name_prefix(card, codec);
-		if (codec->driver->probe) {
-			ret = codec->driver->probe(codec);
-			if (ret < 0) {
-				printk(KERN_ERR "asoc: failed to probe CODEC %s\n",
-						codec->name);
-				return ret;
-			}
-		}
-
-		soc_init_codec_debugfs(codec);
-
-		/* mark codec as probed and add to card codec list */
-		codec->probed = 1;
-		list_add(&codec->card_list, &card->codec_dev_list);
+		ret = soc_probe_codec(card, codec);
+		if (ret < 0)
+			return ret;
 	}
 
 	/* probe the platform */
@@ -1509,47 +1597,14 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	/* DAPM dai link stream work */
 	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
 
-	/* now that all clients have probed, initialise the DAI link */
-	if (dai_link->init) {
-		/* machine controls, routes and widgets are not prefixed */
-		temp = rtd->codec->name_prefix;
-		rtd->codec->name_prefix = NULL;
-		ret = dai_link->init(rtd);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: failed to init %s\n", dai_link->stream_name);
-			return ret;
-		}
-		rtd->codec->name_prefix = temp;
-	}
-
-	/* Make sure all DAPM widgets are instantiated */
-	snd_soc_dapm_new_widgets(&codec->dapm);
-	snd_soc_dapm_sync(&codec->dapm);
-
-	/* register the rtd device */
-	rtd->dev.release = rtd_release;
-	rtd->dev.init_name = dai_link->name;
-	ret = device_register(&rtd->dev);
-	if (ret < 0) {
-		printk(KERN_ERR "asoc: failed to register DAI runtime device %d\n", ret);
+	ret = soc_post_component_init(card, codec, num, 0);
+	if (ret)
 		return ret;
-	}
 
-	rtd->dev_registered = 1;
 	ret = device_create_file(&rtd->dev, &dev_attr_pmdown_time);
 	if (ret < 0)
 		printk(KERN_WARNING "asoc: failed to add pmdown_time sysfs\n");
 
-	/* add DAPM sysfs entries for this codec */
-	ret = snd_soc_dapm_sys_add(&rtd->dev);
-	if (ret < 0)
-		printk(KERN_WARNING "asoc: failed to add codec dapm sysfs entries\n");
-
-	/* add codec sysfs entries */
-	ret = device_create_file(&rtd->dev, &dev_attr_codec_reg);
-	if (ret < 0)
-		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
-
 	/* create the pcm */
 	ret = soc_new_pcm(rtd, num);
 	if (ret < 0) {
@@ -1607,9 +1662,7 @@ static void soc_unregister_ac97_dai_link(struct snd_soc_codec *codec)
 static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
-	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
 	struct snd_soc_codec *codec;
-	const char *temp;
 	int ret = -ENODEV;
 
 	/* find CODEC from registered CODECs*/
@@ -1632,67 +1685,11 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	if (!try_module_get(codec->dev->driver->owner))
 		return -ENODEV;
 
-	codec->card = card;
-	codec->dapm.card = card;
-
-	soc_set_name_prefix(card, codec);
-	if (codec->driver->probe) {
-		ret = codec->driver->probe(codec);
-		if (ret < 0) {
-			dev_err(codec->dev, "asoc: failed to probe CODEC");
-			return ret;
-		}
-	}
-
-	soc_init_codec_debugfs(codec);
-
-	/* mark codec as probed and add to card codec list */
-	codec->probed = 1;
-	list_add(&codec->card_list, &card->codec_dev_list);
-
-	/* now that all clients have probed, initialise the DAI link */
-	if (aux_dev->init) {
-		/* machine controls, routes and widgets are not prefixed */
-		temp = codec->name_prefix;
-		codec->name_prefix = NULL;
-		ret = aux_dev->init(&codec->dapm);
-		if (ret < 0) {
-			dev_err(codec->dev,
-				"asoc: failed to init %s\n", aux_dev->name);
-			return ret;
-		}
-		codec->name_prefix = temp;
-	}
-
-	/* Make sure all DAPM widgets are instantiated */
-	snd_soc_dapm_new_widgets(&codec->dapm);
-	snd_soc_dapm_sync(&codec->dapm);
-
-	/* register the rtd device */
-	rtd->codec = codec;
-	rtd->card = card;
-	rtd->dev.parent = card->dev;
-	rtd->dev.release = rtd_release;
-	rtd->dev.init_name = aux_dev->name;
-	ret = device_register(&rtd->dev);
-	if (ret < 0) {
-		dev_err(codec->dev,
-			"asoc: failed to register aux runtime device %d\n",
-			ret);
-		return ret;
-	}
-	rtd->dev_registered = 1;
-
-	/* add DAPM sysfs entries for this codec */
-	ret = snd_soc_dapm_sys_add(&rtd->dev);
+	ret = soc_probe_codec(card, codec);
 	if (ret < 0)
-		dev_err(codec->dev,
-			"asoc: failed to add codec dapm sysfs entries\n");
+		return ret;
 
-	/* add codec sysfs entries */
-	ret = device_create_file(&rtd->dev, &dev_attr_codec_reg);
-	if (ret < 0)
-		dev_err(codec->dev, "asoc: failed to add codec sysfs files\n");
+	ret = soc_post_component_init(card, codec, num, 1);
 
 out:
 	return ret;
@@ -1702,33 +1699,16 @@ static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
 	struct snd_soc_codec *codec = rtd->codec;
-	int err;
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
+		device_remove_file(&rtd->dev, &dev_attr_codec_reg);
 		device_unregister(&rtd->dev);
 		rtd->dev_registered = 0;
 	}
 
-	/* remove the CODEC */
-	if (codec && codec->probed) {
-		if (codec->driver->remove) {
-			err = codec->driver->remove(codec);
-			if (err < 0)
-				dev_err(codec->dev,
-					"asoc: failed to remove %s\n",
-					codec->name);
-		}
-
-		/* Make sure all DAPM widgets are freed */
-		snd_soc_dapm_free(&codec->dapm);
-
-		soc_cleanup_codec_debugfs(codec);
-		device_remove_file(&rtd->dev, &dev_attr_codec_reg);
-		codec->probed = 0;
-		list_del(&codec->card_list);
-		module_put(codec->dev->driver->owner);
-	}
+	if (codec && codec->probed)
+		soc_remove_codec(codec);
 }
 
 static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,

commit 0afc8c733e95642ee9200966081da82564af8f8f
Merge: 0d735eaa2c1d 1dcb4f38e5bc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 6 14:14:47 2010 +0000

    Merge branch 'for-2.6.37' into for-2.6.38
    
    Conflicts:
            include/linux/mfd/wm8994/pdata.h

commit 0d735eaa2c1d80c997fd775b679e36b80b8e85d1
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Mon Dec 6 09:51:57 2010 +0000

    ASoC: soc-cache: Add optional cache name member to snd_soc_cache_ops
    
    Added an optional name member to snd_soc_cache_ops to enable more
    sensible diagnostic messages during cache init, exit and sync.
    
    Remove redundant newline in source code.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 822bd3bcf148..a90e067fb0ab 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1742,8 +1742,6 @@ static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,
 	/* override the compress_type if necessary */
 	if (compress_type && codec->compress_type != compress_type)
 		codec->compress_type = compress_type;
-	dev_dbg(codec->dev, "Cache compress_type for %s is %d\n",
-		codec->name, codec->compress_type);
 	ret = snd_soc_cache_init(codec);
 	if (ret < 0) {
 		dev_err(codec->dev, "Failed to set cache compression type: %d\n",
@@ -1754,7 +1752,6 @@ static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,
 	return 0;
 }
 
-
 static void snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct platform_device *pdev = to_platform_device(card->dev);

commit 3028eb8c51d968b9e7b44a9786a4e521e37afb13
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Dec 5 12:22:46 2010 +0000

    ASoC: Add trace events for jack detection
    
    As jack detection can trigger DAPM and the latency in debouncing can create
    confusing windows in operation provide some trace events which will hopefully
    help in diagnostics. The soc-jack core traces all reports that it gets and
    the resulting notifications to upper layers. An event for jack IRQs is also
    provided for instrumentation of debounce, and used in the GPIO jack code.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 78a01014079a..822bd3bcf148 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -33,6 +33,7 @@
 #include <linux/slab.h>
 #include <sound/ac97_codec.h>
 #include <sound/core.h>
+#include <sound/jack.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>

commit 1dcb4f38e5bc28dfce0f8c7eef184a090b03bfc7
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Dec 6 16:48:03 2010 +0800

    ASoC: Hold client_mutex while calling snd_soc_instantiate_cards()
    
    As the comments of snd_soc_instantiate_cards() said,
    snd_soc_instantiate_cards() must be called with client_mutex.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 441285ade024..02ae7bea3b50 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3072,7 +3072,9 @@ int snd_soc_register_dais(struct device *dev,
 		pr_debug("Registered DAI '%s'\n", dai->name);
 	}
 
+	mutex_lock(&client_mutex);
 	snd_soc_instantiate_cards();
+	mutex_unlock(&client_mutex);
 	return 0;
 
 err:

commit 001ae4c0350a35e8358514326e5c3d165357979a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 2 16:21:08 2010 +0000

    ASoC: Constify struct snd_soc_codec_driver
    
    Allow the CODEC driver structure to be marked const by making all
    the APIs that use it do so.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e9aa9ce59c06..78a01014079a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3491,8 +3491,9 @@ static void fixup_codec_formats(struct snd_soc_pcm_stream *stream)
  * @codec: codec to register
  */
 int snd_soc_register_codec(struct device *dev,
-		struct snd_soc_codec_driver *codec_drv,
-		struct snd_soc_dai_driver *dai_drv, int num_dai)
+			   const struct snd_soc_codec_driver *codec_drv,
+			   struct snd_soc_dai_driver *dai_drv,
+			   int num_dai)
 {
 	size_t reg_size;
 	struct snd_soc_codec *codec;

commit fdf0f54dab8e401fd9bdd441c3fc4fa5c8837646
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Dec 2 16:11:06 2010 +0000

    ASoC: soc-core: Allow machine drivers to override compress_type
    
    This patch allows machine drivers to override the compression type
    provided by the codec driver.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a95d111a6531..e9aa9ce59c06 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1730,9 +1730,36 @@ static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 	}
 }
 
+static int snd_soc_init_codec_cache(struct snd_soc_codec *codec,
+				    enum snd_soc_compress_type compress_type)
+{
+	int ret;
+
+	if (codec->cache_init)
+		return 0;
+
+	/* override the compress_type if necessary */
+	if (compress_type && codec->compress_type != compress_type)
+		codec->compress_type = compress_type;
+	dev_dbg(codec->dev, "Cache compress_type for %s is %d\n",
+		codec->name, codec->compress_type);
+	ret = snd_soc_cache_init(codec);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to set cache compression type: %d\n",
+			ret);
+		return ret;
+	}
+	codec->cache_init = 1;
+	return 0;
+}
+
+
 static void snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct platform_device *pdev = to_platform_device(card->dev);
+	struct snd_soc_codec *codec;
+	struct snd_soc_codec_conf *codec_conf;
+	enum snd_soc_compress_type compress_type;
 	int ret, i;
 
 	mutex_lock(&card->mutex);
@@ -1752,6 +1779,39 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		return;
 	}
 
+	/* initialize the register cache for each available codec */
+	list_for_each_entry(codec, &codec_list, list) {
+		if (codec->cache_init)
+			continue;
+		/* check to see if we need to override the compress_type */
+		for (i = 0; i < card->num_configs; ++i) {
+			codec_conf = &card->codec_conf[i];
+			if (!strcmp(codec->name, codec_conf->dev_name)) {
+				compress_type = codec_conf->compress_type;
+				if (compress_type && compress_type
+				    != codec->compress_type)
+					break;
+			}
+		}
+		if (i == card->num_configs) {
+			/* no need to override the compress_type so
+			 * go ahead and do the standard thing */
+			ret = snd_soc_init_codec_cache(codec, 0);
+			if (ret < 0) {
+				mutex_unlock(&card->mutex);
+				return;
+			}
+			continue;
+		}
+		/* override the compress_type with the one supplied in
+		 * the machine driver */
+		ret = snd_soc_init_codec_cache(codec, compress_type);
+		if (ret < 0) {
+			mutex_unlock(&card->mutex);
+			return;
+		}
+	}
+
 	/* card bind complete so register a sound card */
 	ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
 			card->owner, 0, &card->snd_card);
@@ -3481,13 +3541,7 @@ int snd_soc_register_codec(struct device *dev,
 					      reg_size, GFP_KERNEL);
 		if (!codec->reg_def_copy) {
 			ret = -ENOMEM;
-			goto error_cache;
-		}
-		ret = snd_soc_cache_init(codec);
-		if (ret < 0) {
-			dev_err(codec->dev, "Failed to set cache compression type: %d\n",
-				ret);
-			goto error_cache;
+			goto fail;
 		}
 	}
 
@@ -3500,7 +3554,7 @@ int snd_soc_register_codec(struct device *dev,
 	if (num_dai) {
 		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
 		if (ret < 0)
-			goto error_dais;
+			goto fail;
 	}
 
 	mutex_lock(&client_mutex);
@@ -3511,9 +3565,7 @@ int snd_soc_register_codec(struct device *dev,
 	pr_debug("Registered codec '%s'\n", codec->name);
 	return 0;
 
-error_dais:
-	snd_soc_cache_exit(codec);
-error_cache:
+fail:
 	kfree(codec->reg_def_copy);
 	codec->reg_def_copy = NULL;
 	kfree(codec->name);

commit 3335ddca9367675f4ee0bd50cc70402c4919a10d
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Dec 2 16:11:05 2010 +0000

    ASoC: soc-cache: Use reg_def_copy instead of reg_cache_default
    
    Make sure to use codec->reg_def_copy instead of codec_drv->reg_cache_default
    wherever necessary.  This change is necessary because in the next patch we
    move the cache initialization code outside snd_soc_register_codec() and by that
    time any data marked as __devinitconst such as the original reg_cache_default
    array might have already been freed by the kernel.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4649db6163b8..a95d111a6531 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3434,6 +3434,7 @@ int snd_soc_register_codec(struct device *dev,
 		struct snd_soc_codec_driver *codec_drv,
 		struct snd_soc_dai_driver *dai_drv, int num_dai)
 {
+	size_t reg_size;
 	struct snd_soc_codec *codec;
 	int ret, i;
 
@@ -3469,6 +3470,19 @@ int snd_soc_register_codec(struct device *dev,
 
 	/* allocate CODEC register cache */
 	if (codec_drv->reg_cache_size && codec_drv->reg_word_size) {
+		reg_size = codec_drv->reg_cache_size * codec_drv->reg_word_size;
+		/* it is necessary to make a copy of the default register cache
+		 * because in the case of using a compression type that requires
+		 * the default register cache to be marked as __devinitconst the
+		 * kernel might have freed the array by the time we initialize
+		 * the cache.
+		 */
+		codec->reg_def_copy = kmemdup(codec_drv->reg_cache_default,
+					      reg_size, GFP_KERNEL);
+		if (!codec->reg_def_copy) {
+			ret = -ENOMEM;
+			goto error_cache;
+		}
 		ret = snd_soc_cache_init(codec);
 		if (ret < 0) {
 			dev_err(codec->dev, "Failed to set cache compression type: %d\n",
@@ -3500,6 +3514,8 @@ int snd_soc_register_codec(struct device *dev,
 error_dais:
 	snd_soc_cache_exit(codec);
 error_cache:
+	kfree(codec->reg_def_copy);
+	codec->reg_def_copy = NULL;
 	kfree(codec->name);
 	kfree(codec);
 	return ret;
@@ -3534,6 +3550,7 @@ void snd_soc_unregister_codec(struct device *dev)
 	pr_debug("Unregistered codec '%s'\n", codec->name);
 
 	snd_soc_cache_exit(codec);
+	kfree(codec->reg_def_copy);
 	kfree(codec->name);
 	kfree(codec);
 }

commit ff819b8357df0ca9903ff7c9ad518b949c410123
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Dec 2 14:53:03 2010 +0000

    ASoC: soc-core: Generalize snd_soc_prefix_map and rename to snd_soc_codec_conf
    
    The snd_soc_codec_conf struct now holds codec specific configuration
    information.
    
    A new configuration option has been added to allow machine drivers to
    override the compression type set by the codec driver.
    
    In the absence of providing an snd_soc_codec_conf struct or when providing
    one but not setting the compress_type member to anything, the one supplied
    by the codec driver will be used instead.  In all other cases the one
    set in the snd_soc_codec_conf struct takes effect.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1fd1d1a62af1..4649db6163b8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1401,11 +1401,11 @@ static void soc_set_name_prefix(struct snd_soc_card *card,
 {
 	int i;
 
-	if (card->prefix_map == NULL)
+	if (card->codec_conf == NULL)
 		return;
 
-	for (i = 0; i < card->num_prefixes; i++) {
-		struct snd_soc_prefix_map *map = &card->prefix_map[i];
+	for (i = 0; i < card->num_configs; i++) {
+		struct snd_soc_codec_conf *map = &card->codec_conf[i];
 		if (map->dev_name && !strcmp(codec->name, map->dev_name)) {
 			codec->name_prefix = map->name_prefix;
 			break;

commit 23bbce34f47762ce944ea9b8b3b3e05e220c6a2e
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Dec 2 14:53:01 2010 +0000

    ASoC: Add compress_type as a member to snd_soc_codec
    
    We need to keep a copy of the compress_type supplied by the codec driver
    so that we can override it if necessary with whatever the machine driver
    has provided us with.  The reason for not modifying the codec->driver
    struct directly is that ideally we'd like to keep it const.
    
    Adjust the code in soc-cache and soc-core to make use of the compress_type
    member in the snd_soc_codec struct.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2b1fcae4131e..1fd1d1a62af1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3450,6 +3450,11 @@ int snd_soc_register_codec(struct device *dev,
 		return -ENOMEM;
 	}
 
+	if (codec_drv->compress_type)
+		codec->compress_type = codec_drv->compress_type;
+	else
+		codec->compress_type = SND_SOC_FLAT_COMPRESSION;
+
 	INIT_LIST_HEAD(&codec->dapm.widgets);
 	INIT_LIST_HEAD(&codec->dapm.paths);
 	codec->write = codec_drv->write;

commit 676ad98a06a629e6273819a54b70f3987044b608
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Fri Dec 3 09:18:22 2010 +0200

    ASoC: Don't oops in soc_probe_aux_dev in case of missing codec
    
    Blind copy of codec finding algorithm from soc_bind_dai_link does not work
    in soc_probe_aux_dev if matching codec name is not found. In that case the
    code falls through and tries to start the probing procedure with invalid
    codec pointer.
    
    Fix this and add an error print showing the codec name that cannot be found.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5720dbcefbc4..2b1fcae4131e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1609,7 +1609,7 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
 	struct snd_soc_codec *codec;
 	const char *temp;
-	int ret = 0;
+	int ret = -ENODEV;
 
 	/* find CODEC from registered CODECs*/
 	list_for_each_entry(codec, &codec_list, list) {
@@ -1620,10 +1620,14 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 				ret = -EBUSY;
 				goto out;
 			}
-			break;
+			goto found;
 		}
 	}
+	/* codec not found */
+	dev_err(card->dev, "asoc: codec %s not found", aux_dev->codec_name);
+	goto out;
 
+found:
 	if (!try_module_get(codec->dev->driver->owner))
 		return -ENODEV;
 

commit c3acec2671cc448bc549b06b561ae2454238e9a0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 2 16:15:29 2010 +0000

    ASoC: Move active copy of CODEC read and write into runtime structure
    
    We shouldn't be assigning to the driver structure (which really ought
    to be const, further patch to follow) though there's unlikely to be any
    actual problem except in the unlikely case that two devices with the
    same driver but different bus types appear in the same system.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 20dcc978588f..5720dbcefbc4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2077,7 +2077,7 @@ unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
 {
 	unsigned int ret;
 
-	ret = codec->driver->read(codec, reg);
+	ret = codec->read(codec, reg);
 	dev_dbg(codec->dev, "read %x => %x\n", reg, ret);
 	trace_snd_soc_reg_read(codec, reg, ret);
 
@@ -2090,7 +2090,7 @@ unsigned int snd_soc_write(struct snd_soc_codec *codec,
 {
 	dev_dbg(codec->dev, "write %x = %x\n", reg, val);
 	trace_snd_soc_reg_write(codec, reg, val);
-	return codec->driver->write(codec, reg, val);
+	return codec->write(codec, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_write);
 
@@ -3448,6 +3448,8 @@ int snd_soc_register_codec(struct device *dev,
 
 	INIT_LIST_HEAD(&codec->dapm.widgets);
 	INIT_LIST_HEAD(&codec->dapm.paths);
+	codec->write = codec_drv->write;
+	codec->read = codec_drv->read;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;

commit a00f90f9306c06bee8e909628f39052bb3b0cc9e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 2 16:24:24 2010 +0000

    ASoC: Apostrophe patrol in soc-core.c
    
    Silly little grammar nit but it bugs the hell out of me.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index eb950f73076a..20dcc978588f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -525,7 +525,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		}
 	}
 
-	/* Check that the codec and cpu DAI's are compatible */
+	/* Check that the codec and cpu DAIs are compatible */
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		runtime->hw.rate_min =
 			max(codec_dai_drv->playback.rate_min,
@@ -874,7 +874,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 }
 
 /*
- * Free's resources allocated by hw_params, can be called multiple times
+ * Frees resources allocated by hw_params, can be called multiple times
  */
 static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 {
@@ -898,7 +898,7 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 	if (platform->driver->ops->hw_free)
 		platform->driver->ops->hw_free(substream);
 
-	/* now free hw params for the DAI's  */
+	/* now free hw params for the DAIs  */
 	if (codec_dai->driver->ops->hw_free)
 		codec_dai->driver->ops->hw_free(substream, codec_dai);
 
@@ -1005,7 +1005,7 @@ static int soc_suspend(struct device *dev)
 	/* we're going to block userspace touching us until resume completes */
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D3hot);
 
-	/* mute any active DAC's */
+	/* mute any active DACs */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *dai = card->rtd[i].codec_dai;
 		struct snd_soc_dai_driver *drv = dai->driver;

commit 06c6f4d34a23f7c9c783f1a875bb492b15fa23ac
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Wed Dec 1 09:10:47 2010 +0200

    ASoC: Fix build failure in soc-core.c
    
    Commit 2eea392 "ASoC: Add support for optional auxiliary dailess codecs"
    causes a build failure in soc-core.c: soc_probe_aux_dev since code tries to
    access non-existing struct snd_soc_dapm_context and struct snd_soc_card
    members.
    
    Root cause for this was a double accident. Author sent the RFC patch from
    top of another patch set and the RFC got committed. Fix the build failure
    by removing the code line that depends on that another patch set.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a7670d5ac13d..eb950f73076a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1644,7 +1644,6 @@ static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
 	/* mark codec as probed and add to card codec list */
 	codec->probed = 1;
 	list_add(&codec->card_list, &card->codec_dev_list);
-	list_add(&codec->dapm.list, &card->dapm_list);
 
 	/* now that all clients have probed, initialise the DAI link */
 	if (aux_dev->init) {

commit 2eea392d0a28a0a07d36a9da544eb40f81bf4cb6
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Thu Nov 25 17:47:38 2010 +0200

    ASoC: Add support for optional auxiliary dailess codecs
    
    This makes possible to register auxiliary dailess codecs in a machine
    driver. Term dailess is used here for amplifiers and codecs without DAI or
    DAI being unused.
    
    Dailess auxiliary codecs are kept in struct snd_soc_aux_dev and those codecs
    are probed after initializing the DAI links. There are no major differences
    between DAI link codecs and dailess codecs in ASoC core point of view. DAPM
    handles them equally and sysfs and debugfs directories for dailess codecs
    are similar except the pmdown_time node is not created.
    
    Only suspend and resume functions are modified to traverse all probed codecs
    instead of DAI link codecs.
    
    Example below shows a dailess codec registration.
    
    struct snd_soc_aux_dev foo_aux_dev[] = {
            {
                    .name = "Amp",
                    .codec_name = "codec.2",
                    .init = foo_init2,
            },
    };
    
    static struct snd_soc_card card = {
            ...
            .aux_dev = foo_aux_dev,
            .num_aux_devs = ARRAY_SIZE(foo_aux_dev),
    };
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c8d8dde7f4dd..a7670d5ac13d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -986,6 +986,7 @@ static int soc_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
 	int i;
 
 	/* If the initialization of this soc device failed, there is no codec
@@ -1064,8 +1065,7 @@ static int soc_suspend(struct device *dev)
 	}
 
 	/* suspend all CODECs */
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_codec *codec = card->rtd[i].codec;
+	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
 		/* If there are paths active then the CODEC will be held with
 		 * bias _ON and should not be suspended. */
 		if (!codec->suspended && codec->driver->suspend) {
@@ -1106,6 +1106,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	struct snd_soc_card *card =
 			container_of(work, struct snd_soc_card, deferred_resume_work);
 	struct platform_device *pdev = to_platform_device(card->dev);
+	struct snd_soc_codec *codec;
 	int i;
 
 	/* our power state is still SNDRV_CTL_POWER_D3hot from suspend time,
@@ -1131,8 +1132,7 @@ static void soc_resume_deferred(struct work_struct *work)
 			cpu_dai->driver->resume(cpu_dai);
 	}
 
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_codec *codec = card->rtd[i].codec;
+	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
 		/* If the CODEC was idle over suspend then it will have been
 		 * left with bias OFF or STANDBY and suspended so we must now
 		 * resume.  Otherwise the suspend was suppressed.
@@ -1603,6 +1603,130 @@ static void soc_unregister_ac97_dai_link(struct snd_soc_codec *codec)
 }
 #endif
 
+static int soc_probe_aux_dev(struct snd_soc_card *card, int num)
+{
+	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
+	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
+	struct snd_soc_codec *codec;
+	const char *temp;
+	int ret = 0;
+
+	/* find CODEC from registered CODECs*/
+	list_for_each_entry(codec, &codec_list, list) {
+		if (!strcmp(codec->name, aux_dev->codec_name)) {
+			if (codec->probed) {
+				dev_err(codec->dev,
+					"asoc: codec already probed");
+				ret = -EBUSY;
+				goto out;
+			}
+			break;
+		}
+	}
+
+	if (!try_module_get(codec->dev->driver->owner))
+		return -ENODEV;
+
+	codec->card = card;
+	codec->dapm.card = card;
+
+	soc_set_name_prefix(card, codec);
+	if (codec->driver->probe) {
+		ret = codec->driver->probe(codec);
+		if (ret < 0) {
+			dev_err(codec->dev, "asoc: failed to probe CODEC");
+			return ret;
+		}
+	}
+
+	soc_init_codec_debugfs(codec);
+
+	/* mark codec as probed and add to card codec list */
+	codec->probed = 1;
+	list_add(&codec->card_list, &card->codec_dev_list);
+	list_add(&codec->dapm.list, &card->dapm_list);
+
+	/* now that all clients have probed, initialise the DAI link */
+	if (aux_dev->init) {
+		/* machine controls, routes and widgets are not prefixed */
+		temp = codec->name_prefix;
+		codec->name_prefix = NULL;
+		ret = aux_dev->init(&codec->dapm);
+		if (ret < 0) {
+			dev_err(codec->dev,
+				"asoc: failed to init %s\n", aux_dev->name);
+			return ret;
+		}
+		codec->name_prefix = temp;
+	}
+
+	/* Make sure all DAPM widgets are instantiated */
+	snd_soc_dapm_new_widgets(&codec->dapm);
+	snd_soc_dapm_sync(&codec->dapm);
+
+	/* register the rtd device */
+	rtd->codec = codec;
+	rtd->card = card;
+	rtd->dev.parent = card->dev;
+	rtd->dev.release = rtd_release;
+	rtd->dev.init_name = aux_dev->name;
+	ret = device_register(&rtd->dev);
+	if (ret < 0) {
+		dev_err(codec->dev,
+			"asoc: failed to register aux runtime device %d\n",
+			ret);
+		return ret;
+	}
+	rtd->dev_registered = 1;
+
+	/* add DAPM sysfs entries for this codec */
+	ret = snd_soc_dapm_sys_add(&rtd->dev);
+	if (ret < 0)
+		dev_err(codec->dev,
+			"asoc: failed to add codec dapm sysfs entries\n");
+
+	/* add codec sysfs entries */
+	ret = device_create_file(&rtd->dev, &dev_attr_codec_reg);
+	if (ret < 0)
+		dev_err(codec->dev, "asoc: failed to add codec sysfs files\n");
+
+out:
+	return ret;
+}
+
+static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
+{
+	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
+	struct snd_soc_codec *codec = rtd->codec;
+	int err;
+
+	/* unregister the rtd device */
+	if (rtd->dev_registered) {
+		device_unregister(&rtd->dev);
+		rtd->dev_registered = 0;
+	}
+
+	/* remove the CODEC */
+	if (codec && codec->probed) {
+		if (codec->driver->remove) {
+			err = codec->driver->remove(codec);
+			if (err < 0)
+				dev_err(codec->dev,
+					"asoc: failed to remove %s\n",
+					codec->name);
+		}
+
+		/* Make sure all DAPM widgets are freed */
+		snd_soc_dapm_free(&codec->dapm);
+
+		soc_cleanup_codec_debugfs(codec);
+		device_remove_file(&rtd->dev, &dev_attr_codec_reg);
+		codec->probed = 0;
+		list_del(&codec->card_list);
+		module_put(codec->dev->driver->owner);
+	}
+}
+
 static void snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct platform_device *pdev = to_platform_device(card->dev);
@@ -1657,6 +1781,15 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		}
 	}
 
+	for (i = 0; i < card->num_aux_devs; i++) {
+		ret = soc_probe_aux_dev(card, i);
+		if (ret < 0) {
+			pr_err("asoc: failed to add auxiliary devices %s: %d\n",
+			       card->name, ret);
+			goto probe_aux_dev_err;
+		}
+	}
+
 	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
 		 "%s",  card->name);
 	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
@@ -1683,6 +1816,10 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	mutex_unlock(&card->mutex);
 	return;
 
+probe_aux_dev_err:
+	for (i = 0; i < card->num_aux_devs; i++)
+		soc_remove_aux_dev(card, i);
+
 probe_dai_err:
 	for (i = 0; i < card->num_links; i++)
 		soc_remove_dai_link(card, i);
@@ -1744,6 +1881,10 @@ static int soc_remove(struct platform_device *pdev)
 			run_delayed_work(&rtd->delayed_work);
 		}
 
+		/* remove auxiliary devices */
+		for (i = 0; i < card->num_aux_devs; i++)
+			soc_remove_aux_dev(card, i);
+
 		/* remove and free each DAI */
 		for (i = 0; i < card->num_rtd; i++)
 			soc_remove_dai_link(card, i);
@@ -2946,10 +3087,12 @@ static int snd_soc_register_card(struct snd_soc_card *card)
 	if (!card->name || !card->dev)
 		return -EINVAL;
 
-	card->rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime) * card->num_links,
-			GFP_KERNEL);
+	card->rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime) *
+			    (card->num_links + card->num_aux_devs),
+			    GFP_KERNEL);
 	if (card->rtd == NULL)
 		return -ENOMEM;
+	card->rtd_aux = &card->rtd[card->num_links];
 
 	for (i = 0; i < card->num_links; i++)
 		card->rtd[i].dai_link = &card->dai_link[i];

commit 505fb824e754efcc9702ce68d3911e7b86d3c690
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Sun Nov 21 19:48:45 2010 +0200

    ASoC: Do not include soc-dapm.h
    
    There is no need to include soc-dapm.h since soc.h includes it.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2540efd67ee7..c8d8dde7f4dd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -36,7 +36,6 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
-#include <sound/soc-dapm.h>
 #include <sound/initval.h>
 
 #define CREATE_TRACE_POINTS

commit ead9b9199c09653dd9b889933c7af75f020c7286
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Sat Nov 13 20:40:44 2010 +0200

    ASoC: Add optional name_prefix for codec kcontrol, widget and route names
    
    There is a need to prefix codec kcontrol, widget and internal route names in
    an ASoC machine that has multiple codecs with conflicting names. The name
    collision would occur when codec drivers try to registering kcontrols with
    the same name or when building audio paths.
    
    This patch introduces optional prefix_map into struct snd_soc_card. With it
    machine drivers can specify a unique name prefix to each codec that have
    conflicting names with anothers. Prefix to codec is matched with codec
    name.
    
    Following example illustrates a machine that has two same codec instances.
    Name collision from kcontrol registration is avoided by specifying a name
    prefix "foo" for the second codec. As the codec widget names are prefixed
    then second audio map for that codec shows a prefixed widget name.
    
    static const struct snd_soc_dapm_route map0[] = {
            {"Spk", NULL, "MONO"},
    };
    
    static const struct snd_soc_dapm_route map1[] = {
            {"Vibra", NULL, "foo MONO"},
    };
    
    static struct snd_soc_prefix_map codec_prefix[] = {
            {
                    .dev_name = "codec.2",
                    .name_prefix = "foo",
            },
    };
    
    static struct snd_soc_card card = {
            ...
            .prefix_map = codec_prefix,
            .num_prefixes = ARRAY_SIZE(codec_prefix),
    };
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3d70ce58d03c..2540efd67ee7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1397,6 +1397,23 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 	}
 }
 
+static void soc_set_name_prefix(struct snd_soc_card *card,
+				struct snd_soc_codec *codec)
+{
+	int i;
+
+	if (card->prefix_map == NULL)
+		return;
+
+	for (i = 0; i < card->num_prefixes; i++) {
+		struct snd_soc_prefix_map *map = &card->prefix_map[i];
+		if (map->dev_name && !strcmp(codec->name, map->dev_name)) {
+			codec->name_prefix = map->name_prefix;
+			break;
+		}
+	}
+}
+
 static void rtd_release(struct device *dev) {}
 
 static int soc_probe_dai_link(struct snd_soc_card *card, int num)
@@ -1406,6 +1423,7 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	struct snd_soc_codec *codec = rtd->codec;
 	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
+	const char *temp;
 	int ret;
 
 	dev_dbg(card->dev, "probe %s dai link %d\n", card->name, num);
@@ -1440,6 +1458,7 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	/* probe the CODEC */
 	if (!codec->probed) {
 		codec->dapm.card = card;
+		soc_set_name_prefix(card, codec);
 		if (codec->driver->probe) {
 			ret = codec->driver->probe(codec);
 			if (ret < 0) {
@@ -1492,11 +1511,15 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 
 	/* now that all clients have probed, initialise the DAI link */
 	if (dai_link->init) {
+		/* machine controls, routes and widgets are not prefixed */
+		temp = rtd->codec->name_prefix;
+		rtd->codec->name_prefix = NULL;
 		ret = dai_link->init(rtd);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: failed to init %s\n", dai_link->stream_name);
 			return ret;
 		}
+		rtd->codec->name_prefix = temp;
 	}
 
 	/* Make sure all DAPM widgets are instantiated */
@@ -2072,14 +2095,22 @@ int snd_soc_add_controls(struct snd_soc_codec *codec,
 	const struct snd_kcontrol_new *controls, int num_controls)
 {
 	struct snd_card *card = codec->card->snd_card;
+	char prefixed_name[44], *name;
 	int err, i;
 
 	for (i = 0; i < num_controls; i++) {
 		const struct snd_kcontrol_new *control = &controls[i];
-		err = snd_ctl_add(card, snd_soc_cnew(control, codec, NULL));
+		if (codec->name_prefix) {
+			snprintf(prefixed_name, sizeof(prefixed_name), "%s %s",
+				 codec->name_prefix, control->name);
+			name = prefixed_name;
+		} else {
+			name = control->name;
+		}
+		err = snd_ctl_add(card, snd_soc_cnew(control, codec, name));
 		if (err < 0) {
 			dev_err(codec->dev, "%s: Failed to add %s: %d\n",
-				codec->name, control->name, err);
+				codec->name, name, err);
 			return err;
 		}
 	}

commit 7a30a3db34cc7b2180a1a6c4a51d19d93c8a8b80
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Nov 11 10:04:57 2010 +0000

    ASoC: soc-cache: Add support for flat register caching
    
    This patch introduces the new caching API and migrates the
    old caching interface into the new one.  The flat register caching
    technique does not use compression at all and it is equivalent to
    the old caching technique.  One can still access codec->reg_cache
    directly but this is not advised as that will not be portable
    across different caching strategies.
    
    None of the existing drivers need to be changed to adapt to this
    caching technique.  There should be no noticeable overhead associated
    with using the new caching API.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 700a6d5b9721..3d70ce58d03c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3279,29 +3279,21 @@ int snd_soc_register_codec(struct device *dev,
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 	codec->dapm.dev = dev;
 	codec->dapm.codec = codec;
+	codec->dev = dev;
+	codec->driver = codec_drv;
+	codec->num_dai = num_dai;
+	mutex_init(&codec->mutex);
 
 	/* allocate CODEC register cache */
 	if (codec_drv->reg_cache_size && codec_drv->reg_word_size) {
-
-		if (codec_drv->reg_cache_default)
-			codec->reg_cache = kmemdup(codec_drv->reg_cache_default,
-				codec_drv->reg_cache_size * codec_drv->reg_word_size, GFP_KERNEL);
-		else
-			codec->reg_cache = kzalloc(codec_drv->reg_cache_size *
-				codec_drv->reg_word_size, GFP_KERNEL);
-
-		if (codec->reg_cache == NULL) {
-			kfree(codec->name);
-			kfree(codec);
-			return -ENOMEM;
+		ret = snd_soc_cache_init(codec);
+		if (ret < 0) {
+			dev_err(codec->dev, "Failed to set cache compression type: %d\n",
+				ret);
+			goto error_cache;
 		}
 	}
 
-	codec->dev = dev;
-	codec->driver = codec_drv;
-	codec->num_dai = num_dai;
-	mutex_init(&codec->mutex);
-
 	for (i = 0; i < num_dai; i++) {
 		fixup_codec_formats(&dai_drv[i].playback);
 		fixup_codec_formats(&dai_drv[i].capture);
@@ -3311,7 +3303,7 @@ int snd_soc_register_codec(struct device *dev,
 	if (num_dai) {
 		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
 		if (ret < 0)
-			goto error;
+			goto error_dais;
 	}
 
 	mutex_lock(&client_mutex);
@@ -3322,9 +3314,9 @@ int snd_soc_register_codec(struct device *dev,
 	pr_debug("Registered codec '%s'\n", codec->name);
 	return 0;
 
-error:
-	if (codec->reg_cache)
-		kfree(codec->reg_cache);
+error_dais:
+	snd_soc_cache_exit(codec);
+error_cache:
 	kfree(codec->name);
 	kfree(codec);
 	return ret;
@@ -3358,8 +3350,7 @@ void snd_soc_unregister_codec(struct device *dev)
 
 	pr_debug("Unregistered codec '%s'\n", codec->name);
 
-	if (codec->reg_cache)
-		kfree(codec->reg_cache);
+	snd_soc_cache_exit(codec);
 	kfree(codec->name);
 	kfree(codec);
 }

commit a8b1d34f3ee1bc139ac5fbe3f84f6d16c90136bb
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 3 18:05:58 2010 -0400

    ASoC: Add trace events for ASoC register read/write
    
    The trace subsystem provides a convenient way of instrumenting the kernel
    which can be left on all the time with extremely low impact on the system
    unlike prints to the kernel log which can be very spammy. Begin adding
    support for instrumenting ASoC via this interface by adding trace for the
    register access primitives.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c18ce1dc51b8..700a6d5b9721 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -39,6 +39,9 @@
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/asoc.h>
+
 #define NAME_SIZE	32
 
 static DEFINE_MUTEX(pcm_mutex);
@@ -1914,6 +1917,7 @@ unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
 
 	ret = codec->driver->read(codec, reg);
 	dev_dbg(codec->dev, "read %x => %x\n", reg, ret);
+	trace_snd_soc_reg_read(codec, reg, ret);
 
 	return ret;
 }
@@ -1923,6 +1927,7 @@ unsigned int snd_soc_write(struct snd_soc_codec *codec,
 			   unsigned int reg, unsigned int val)
 {
 	dev_dbg(codec->dev, "write %x = %x\n", reg, val);
+	trace_snd_soc_reg_write(codec, reg, val);
 	return codec->driver->write(codec, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_write);

commit b95fccbc025cb5788776ed8b80dba20b24529b15
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Nov 9 17:06:44 2010 +0800

    ASoC: Fix compile error if CONFIG_DEBUG_FS is not configured
    
    Add soc_init_card_debugfs and soc_cleanup_card_debugfs functions to fix below error.
    
      CC      sound/soc/soc-core.o
    sound/soc/soc-core.c: In function 'soc_probe':
    sound/soc/soc-core.c:1689: error: implicit declaration of function 'soc_init_card_debugfs'
    sound/soc/soc-core.c: In function 'soc_remove':
    sound/soc/soc-core.c:1718: error: implicit declaration of function 'soc_cleanup_card_debugfs'
    make[2]: *** [sound/soc/soc-core.o] Error 1
    make[1]: *** [sound/soc] Error 2
    make: *** [sound] Error 2
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f030521c48d1..c18ce1dc51b8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -401,6 +401,14 @@ static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 static inline void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 {
 }
+
+static inline void soc_init_card_debugfs(struct snd_soc_card *card)
+{
+}
+
+static inline void soc_cleanup_card_debugfs(struct snd_soc_card *card)
+{
+}
 #endif
 
 #ifdef CONFIG_SND_SOC_AC97_BUS

commit 3a45b8672d3f8542e430e7a5c7366ec9bdded054
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Fri Nov 5 20:35:21 2010 +0200

    ASoC: Move pop time from DAPM context to sound card
    
    Based on discussion the dapm_pop_time in debugsfs should be per card rather
    than per device. Single pop time value for entire card is cleaner when the
    DAPM sequencing is extended to cross-device paths.
    
    debugfs/asoc/{card->name}/{codec dir}/dapm_pop_time
    ->
    debugfs/asoc/{card->name}/dapm_pop_time
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 57e5d7bfb130..f030521c48d1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -255,13 +255,6 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 		printk(KERN_WARNING
 		       "ASoC: Failed to create codec register debugfs file\n");
 
-	codec->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0644,
-						     codec->debugfs_codec_root,
-						     &codec->dapm.pop_time);
-	if (!codec->debugfs_pop_time)
-		printk(KERN_WARNING
-		       "Failed to create pop time debugfs file\n");
-
 	codec->dapm.debugfs_dapm = debugfs_create_dir("dapm",
 						 codec->debugfs_codec_root);
 	if (!codec->dapm.debugfs_dapm)
@@ -380,9 +373,18 @@ static void soc_init_card_debugfs(struct snd_soc_card *card)
 {
 	card->debugfs_card_root = debugfs_create_dir(card->name,
 						     debugfs_root);
-	if (!card->debugfs_card_root)
+	if (!card->debugfs_card_root) {
 		dev_warn(card->dev,
 			 "ASoC: Failed to create codec debugfs directory\n");
+		return;
+	}
+
+	card->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0644,
+						    card->debugfs_card_root,
+						    &card->pop_time);
+	if (!card->debugfs_pop_time)
+		dev_warn(card->dev,
+		       "Failed to create pop time debugfs file\n");
 }
 
 static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
@@ -1426,6 +1428,7 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 
 	/* probe the CODEC */
 	if (!codec->probed) {
+		codec->dapm.card = card;
 		if (codec->driver->probe) {
 			ret = codec->driver->probe(codec);
 			if (ret < 0) {

commit d6ce4cf3967dca78f967cd0bf70b175084885f40
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Fri Nov 5 20:35:20 2010 +0200

    ASoC: Move codec debugfs directories under parent card directory
    
    Make use of sound card debugfs directory and move codec directories under
    the parent card debugfs directory.
    
    debugfs/asoc/{codec dir} -> debugfs/asoc/{card->name}/{codec dir}.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b0f635ccf176..57e5d7bfb130 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -238,8 +238,10 @@ static const struct file_operations codec_reg_fops = {
 
 static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
-	codec->debugfs_codec_root = debugfs_create_dir(codec->name ,
-						       debugfs_root);
+	struct dentry *debugfs_card_root = codec->card->debugfs_card_root;
+
+	codec->debugfs_codec_root = debugfs_create_dir(codec->name,
+						       debugfs_card_root);
 	if (!codec->debugfs_codec_root) {
 		printk(KERN_WARNING
 		       "ASoC: Failed to create codec debugfs directory\n");

commit a6052154944c822993d04ca8f8d8926e8b73b749
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Fri Nov 5 20:35:19 2010 +0200

    ASoC: Add sound card directory under debugfs/asoc/
    
    There will be need to have sound card specific debugfs entries. This patch
    introduces a new debugfs/asoc/{card->name}/ directory but does not add yet
    any entries there.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3c7c884f212c..b0f635ccf176 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -374,6 +374,20 @@ static const struct file_operations platform_list_fops = {
 	.llseek = default_llseek,/* read accesses f_pos */
 };
 
+static void soc_init_card_debugfs(struct snd_soc_card *card)
+{
+	card->debugfs_card_root = debugfs_create_dir(card->name,
+						     debugfs_root);
+	if (!card->debugfs_card_root)
+		dev_warn(card->dev,
+			 "ASoC: Failed to create codec debugfs directory\n");
+}
+
+static void soc_cleanup_card_debugfs(struct snd_soc_card *card)
+{
+	debugfs_remove_recursive(card->debugfs_card_root);
+}
+
 #else
 
 static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
@@ -1667,6 +1681,8 @@ static int soc_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&card->codec_dev_list);
 	INIT_LIST_HEAD(&card->platform_dev_list);
 
+	soc_init_card_debugfs(card);
+
 	ret = snd_soc_register_card(card);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to register card\n");
@@ -1694,6 +1710,8 @@ static int soc_remove(struct platform_device *pdev)
 		for (i = 0; i < card->num_rtd; i++)
 			soc_remove_dai_link(card, i);
 
+		soc_cleanup_card_debugfs(card);
+
 		/* remove the card */
 		if (card->remove)
 			card->remove(pdev);

commit ce6120cca2589ede530200c7cfe11ac9f144333c
Author: Liam Girdwood <lrg@slimlogic.co.uk>
Date:   Fri Nov 5 15:53:46 2010 +0200

    ASoC: Decouple DAPM from CODECs
    
    Decoupling Dynamic Audio Power Management (DAPM) from codec devices is
    required when developing ASoC further. Such as for other ASoC components to
    have DAPM widgets or when extending DAPM to handle cross-device paths.
    
    This patch decouples DAPM related variables from struct snd_soc_codec and
    moves them to new struct snd_soc_dapm_context that is used to encapsulate
    DAPM context of a device. ASoC core and API of DAPM functions are modified
    to use DAPM context instead of codec.
    
    This patch does not change current functionality and a large part of changes
    come because of structure and internal API changes.
    
    Core implementation is from Liam Girdwood <lrg@slimlogic.co.uk> with some
    minor core changes, codecs and machine driver conversions from
    Jarkko Nikula <jhnikula@gmail.com>.
    
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Manuel Lauss <manuel.lauss@googlemail.com>
    Cc: Mike Frysinger <vapier.adi@gmail.com>
    Cc: Cliff Cai <cliff.cai@analog.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Ryan Mallon <ryan@bluewatersys.com>
    Cc: Timur Tabi <timur@freescale.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Arnaud Patard (Rtp) <arnaud.patard@rtp-net.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Jassi Brar <jassi.brar@samsung.com>
    Cc: Daniel Gloeckner <dg@emlix.com>
    Cc: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2198936cfb68..3c7c884f212c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -255,18 +255,18 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 
 	codec->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0644,
 						     codec->debugfs_codec_root,
-						     &codec->pop_time);
+						     &codec->dapm.pop_time);
 	if (!codec->debugfs_pop_time)
 		printk(KERN_WARNING
 		       "Failed to create pop time debugfs file\n");
 
-	codec->debugfs_dapm = debugfs_create_dir("dapm",
+	codec->dapm.debugfs_dapm = debugfs_create_dir("dapm",
 						 codec->debugfs_codec_root);
-	if (!codec->debugfs_dapm)
+	if (!codec->dapm.debugfs_dapm)
 		printk(KERN_WARNING
 		       "Failed to create DAPM debugfs directory\n");
 
-	snd_soc_dapm_debugfs_init(codec);
+	snd_soc_dapm_debugfs_init(&codec->dapm);
 }
 
 static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
@@ -1017,7 +1017,7 @@ static int soc_suspend(struct device *dev)
 	/* close any waiting streams and save state */
 	for (i = 0; i < card->num_rtd; i++) {
 		run_delayed_work(&card->rtd[i].delayed_work);
-		card->rtd[i].codec->suspend_bias_level = card->rtd[i].codec->bias_level;
+		card->rtd[i].codec->dapm.suspend_bias_level = card->rtd[i].codec->dapm.bias_level;
 	}
 
 	for (i = 0; i < card->num_rtd; i++) {
@@ -1041,7 +1041,7 @@ static int soc_suspend(struct device *dev)
 		/* If there are paths active then the CODEC will be held with
 		 * bias _ON and should not be suspended. */
 		if (!codec->suspended && codec->driver->suspend) {
-			switch (codec->bias_level) {
+			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
 			case SND_SOC_BIAS_OFF:
 				codec->driver->suspend(codec, PMSG_SUSPEND);
@@ -1110,7 +1110,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		 * resume.  Otherwise the suspend was suppressed.
 		 */
 		if (codec->driver->resume && codec->suspended) {
-			switch (codec->bias_level) {
+			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
 			case SND_SOC_BIAS_OFF:
 				codec->driver->resume(codec);
@@ -1346,7 +1346,7 @@ static void soc_remove_dai_link(struct snd_soc_card *card, int num)
 		}
 
 		/* Make sure all DAPM widgets are freed */
-		snd_soc_dapm_free(codec);
+		snd_soc_dapm_free(&codec->dapm);
 
 		soc_cleanup_codec_debugfs(codec);
 		device_remove_file(&rtd->dev, &dev_attr_codec_reg);
@@ -1470,8 +1470,8 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	}
 
 	/* Make sure all DAPM widgets are instantiated */
-	snd_soc_dapm_new_widgets(codec);
-	snd_soc_dapm_sync(codec);
+	snd_soc_dapm_new_widgets(&codec->dapm);
+	snd_soc_dapm_sync(&codec->dapm);
 
 	/* register the rtd device */
 	rtd->dev.release = rtd_release;
@@ -3238,6 +3238,12 @@ int snd_soc_register_codec(struct device *dev,
 		return -ENOMEM;
 	}
 
+	INIT_LIST_HEAD(&codec->dapm.widgets);
+	INIT_LIST_HEAD(&codec->dapm.paths);
+	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
+	codec->dapm.dev = dev;
+	codec->dapm.codec = codec;
+
 	/* allocate CODEC register cache */
 	if (codec_drv->reg_cache_size && codec_drv->reg_word_size) {
 
@@ -3257,11 +3263,8 @@ int snd_soc_register_codec(struct device *dev,
 
 	codec->dev = dev;
 	codec->driver = codec_drv;
-	codec->bias_level = SND_SOC_BIAS_OFF;
 	codec->num_dai = num_dai;
 	mutex_init(&codec->mutex);
-	INIT_LIST_HEAD(&codec->dapm_widgets);
-	INIT_LIST_HEAD(&codec->dapm_paths);
 
 	for (i = 0; i < num_dai; i++) {
 		fixup_codec_formats(&dai_drv[i].playback);

commit a8ea54da5e47bde9ba19230bb3609b0502a288c3
Merge: 11e16eb365f4 6424dca23e6b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Nov 5 09:16:07 2010 -0400

    Merge branch 'for-2.6.37' into HEAD

commit c3753707991218aa2c18449a921847877533aa09
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Nov 1 15:41:57 2010 -0400

    ASoC: Push snd_soc_write() and snd_soc_read() into the source file
    
    Facilitating adding trace type stuff. For a first pass add some dev_dbg()
    statements into them.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 614a8b30d87b..4360436ef035 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1877,6 +1877,25 @@ void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 }
 EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
 
+unsigned int snd_soc_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	unsigned int ret;
+
+	ret = codec->driver->read(codec, reg);
+	dev_dbg(codec->dev, "read %x => %x\n", reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_read);
+
+unsigned int snd_soc_write(struct snd_soc_codec *codec,
+			   unsigned int reg, unsigned int val)
+{
+	dev_dbg(codec->dev, "write %x = %x\n", reg, val);
+	return codec->driver->write(codec, reg, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_write);
+
 /**
  * snd_soc_update_bits - update codec register bits
  * @codec: audio codec

commit c46e0079cec40b49fbdb86a088cfd50b250fef47
Author: Axel Lin <axel.lin@gmail.com>
Date:   Wed Nov 3 15:04:45 2010 +0800

    ASoC: Fix snd_soc_register_dais error handling
    
    kzalloc for dai may fail at any iteration of the for loop,
    thus properly unregister already registered DAIs before return error.
    
    The error handling code in snd_soc_register_dais() already ensure all the DAIs
    are unregistered before return error, we can remove the error handling code
    to unregister DAIs in snd_soc_register_codec().
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 614a8b30d87b..441285ade024 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3043,8 +3043,10 @@ int snd_soc_register_dais(struct device *dev,
 	for (i = 0; i < count; i++) {
 
 		dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
-		if (dai == NULL)
-			return -ENOMEM;
+		if (dai == NULL) {
+			ret = -ENOMEM;
+			goto err;
+		}
 
 		/* create DAI component name */
 		dai->name = fmt_multiple_name(dev, &dai_drv[i]);
@@ -3263,9 +3265,6 @@ int snd_soc_register_codec(struct device *dev,
 	return 0;
 
 error:
-	for (i--; i >= 0; i--)
-		snd_soc_unregister_dai(dev);
-
 	if (codec->reg_cache)
 		kfree(codec->reg_cache);
 	kfree(codec->name);

commit 29c798fecb9b846b363b0a02fa662ff42fc19426
Merge: cb9906229595 c8ddb2713c62
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 2 09:41:56 2010 -0400

    Merge commit 'v2.6.37-rc1' into for-2.6.37

commit c593b520cf70b0672680da04cc1e8c5f93bd739d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Oct 27 20:11:17 2010 -0700

    ASoC: Check return value of struct_strtoul() in pmdown_time_set()
    
    strict_strtoul() has just been made must check so do so.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 70d9a7394b2b..805343fe903b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -165,8 +165,11 @@ static ssize_t pmdown_time_set(struct device *dev,
 {
 	struct snd_soc_pcm_runtime *rtd =
 			container_of(dev, struct snd_soc_pcm_runtime, dev);
+	int ret;
 
-	strict_strtol(buf, 10, &rtd->pmdown_time);
+	ret = strict_strtol(buf, 10, &rtd->pmdown_time);
+	if (ret)
+		return ret;
 
 	return count;
 }

commit 33081adf8b89d5a716d7e1c60171768d39795b39
Merge: c55960499f81 506ecbca71d0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 25 08:32:05 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6: (365 commits)
      ALSA: hda - Disable sticky PCM stream assignment for AD codecs
      ALSA: usb - Creative USB X-Fi volume knob support
      ALSA: ca0106: Use card specific dac id for mute controls.
      ALSA: ca0106: Allow different sound cards to use different SPI channel mappings.
      ALSA: ca0106: Create a nice spot for mapping channels to dacs.
      ALSA: ca0106: Move enabling of front dac out of hardcoded setup sequence.
      ALSA: ca0106: Pull out dac powering routine into separate function.
      ALSA: ca0106 - add Sound Blaster 5.1vx info.
      ASoC: tlv320dac33: Use usleep_range for delays
      ALSA: usb-audio: add Novation Launchpad support
      ALSA: hda - Add workarounds for CT-IBG controllers
      ALSA: hda - Fix wrong TLV mute bit for STAC/IDT codecs
      ASoC: tpa6130a2: Error handling for broken chip
      ASoC: max98088: Staticise m98088_eq_band
      ASoC: soc-core: Fix codec->name memory leak
      ALSA: hda - Apply ideapad quirk to Acer laptops with Cxt5066
      ALSA: hda - Add some workarounds for Creative IBG
      ALSA: hda - Fix wrong SPDIF NID assignment for CA0110
      ALSA: hda - Fix codec rename rules for ALC662-compatible codecs
      ALSA: hda - Add alc_init_jacks() call to other codecs
      ...

commit 1aafcd4d6966453ab44587c6e1214d463f3e88e2
Author: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
Date:   Thu Oct 21 13:19:45 2010 +0100

    ASoC: soc-core: Fix codec->name memory leak
    
    Ensure that the codec->name is freed when unregistering the codec.
    
    Signed-off-by: Dimitris Papastamos <dp@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 862b1af5fbdf..70d9a7394b2b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3299,6 +3299,7 @@ void snd_soc_unregister_codec(struct device *dev)
 
 	if (codec->reg_cache)
 		kfree(codec->reg_cache);
+	kfree(codec->name);
 	kfree(codec);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);

commit 0589944661b9a9b9692f455fbbfce5eeda8fa7b6
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Tue Oct 19 11:10:45 2010 +0300

    ASoC: Fix I2C component device id number creation
    
    Use bitwise AND instead of logical AND when masking.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 63c80e634a37..862b1af5fbdf 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2929,7 +2929,7 @@ static inline char *fmt_single_name(struct device *dev, int *id)
 			char tmp[NAME_SIZE];
 
 			/* create unique ID number from I2C addr and bus */
-			*id = ((id1 && 0xffff) << 16) + id2;
+			*id = ((id1 & 0xffff) << 16) + id2;
 
 			/* sanitize component name for DAI link creation */
 			snprintf(tmp, NAME_SIZE, "%s.%s", dev->driver->name, name);

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index acc91daa1c55..4057d35343bb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -223,6 +223,7 @@ static const struct file_operations codec_reg_fops = {
 	.open = codec_reg_open_file,
 	.read = codec_reg_read_file,
 	.write = codec_reg_write_file,
+	.llseek = default_llseek,
 };
 
 static void soc_init_codec_debugfs(struct snd_soc_codec *codec)

commit 0f9141c974b2dc29b7d1cf245bbf4685350521be
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Oct 12 15:43:21 2010 +0100

    ASoC: Pay attention to driver supplied DAI IDs
    
    The driver can specify a DAI ID number so use that.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6cee97e23da6..63c80e634a37 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3051,8 +3051,11 @@ int snd_soc_register_dais(struct device *dev,
 		}
 
 		dai->dev = dev;
-		dai->id = i;
 		dai->driver = &dai_drv[i];
+		if (dai->driver->id)
+			dai->id = dai->driver->id;
+		else
+			dai->id = i;
 		if (!dai->driver->ops)
 			dai->driver->ops = &null_dai_ops;
 

commit 2b194f9db444875b4509e6dc92c949c57437c826
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Oct 13 10:52:16 2010 +0100

    ASoC: Check list debugfs files for PAGE_SIZE overflow
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 225b5bd2802e..6cee97e23da6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -274,15 +274,22 @@ static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
 				    size_t count, loff_t *ppos)
 {
 	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	ssize_t ret = 0;
+	ssize_t len, ret = 0;
 	struct snd_soc_codec *codec;
 
 	if (!buf)
 		return -ENOMEM;
 
-	list_for_each_entry(codec, &codec_list, list)
-		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
-				codec->name);
+	list_for_each_entry(codec, &codec_list, list) {
+		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
+			       codec->name);
+		if (len >= 0)
+			ret += len;
+		if (ret > PAGE_SIZE) {
+			ret = PAGE_SIZE;
+			break;
+		}
+	}
 
 	if (ret >= 0)
 		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
@@ -301,17 +308,23 @@ static ssize_t dai_list_read_file(struct file *file, char __user *user_buf,
 				  size_t count, loff_t *ppos)
 {
 	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	ssize_t ret = 0;
+	ssize_t len, ret = 0;
 	struct snd_soc_dai *dai;
 
 	if (!buf)
 		return -ENOMEM;
 
-	list_for_each_entry(dai, &dai_list, list)
-		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%s\n", dai->name);
+	list_for_each_entry(dai, &dai_list, list) {
+		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n", dai->name);
+		if (len >= 0)
+			ret += len;
+		if (ret > PAGE_SIZE) {
+			ret = PAGE_SIZE;
+			break;
+		}
+	}
 
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
 	kfree(buf);
 
@@ -328,18 +341,24 @@ static ssize_t platform_list_read_file(struct file *file,
 				       size_t count, loff_t *ppos)
 {
 	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	ssize_t ret = 0;
+	ssize_t len, ret = 0;
 	struct snd_soc_platform *platform;
 
 	if (!buf)
 		return -ENOMEM;
 
-	list_for_each_entry(platform, &platform_list, list)
-		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
-				platform->name);
+	list_for_each_entry(platform, &platform_list, list) {
+		len = snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
+			       platform->name);
+		if (len >= 0)
+			ret += len;
+		if (ret > PAGE_SIZE) {
+			ret = PAGE_SIZE;
+			break;
+		}
+	}
 
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 
 	kfree(buf);
 

commit 4abe8e16a8ad879027de3a0a088f281577ad24a9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Oct 12 17:41:03 2010 +0100

    ASoC: Move soc-core module init next to functon definition
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7d22b5d5bc0d..225b5bd2802e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3306,6 +3306,7 @@ static int __init snd_soc_init(void)
 
 	return platform_driver_register(&soc_driver);
 }
+module_init(snd_soc_init);
 
 static void __exit snd_soc_exit(void)
 {
@@ -3314,8 +3315,6 @@ static void __exit snd_soc_exit(void)
 #endif
 	platform_driver_unregister(&soc_driver);
 }
-
-module_init(snd_soc_init);
 module_exit(snd_soc_exit);
 
 /* Module information */

commit 0562f7882d968463119bb63d47ef4bdaba7d6631
Author: Mika Westerberg <mika.westerberg@iki.fi>
Date:   Wed Oct 13 11:30:32 2010 +0300

    ASoC: don't register AC97 devices twice
    
    With generic AC97 ASoC glue driver (codec/ac97.c), we get following warning when
    the device is registered (slightly stripped the backtrace):
    
    kobject (c5a863e8): tried to init an initialized object, something is seriously
                        wrong.
    [<c00254fc>] (unwind_backtrace+0x0/0xec)
    [<c014fad0>] (kobject_init+0x38/0x70)
    [<c0171e94>] (device_initialize+0x20/0x70)
    [<c017267c>] (device_register+0xc/0x18)
    [<bf20db70>] (snd_soc_instantiate_cards+0x924/0xacc [snd_soc_core])
    [<bf20e0d0>] (snd_soc_register_platform+0x16c/0x198 [snd_soc_core])
    [<c0175304>] (platform_drv_probe+0x18/0x1c)
    [<c0174454>] (driver_probe_device+0xb0/0x16c)
    [<c017456c>] (__driver_attach+0x5c/0x7c)
    [<c0173cec>] (bus_for_each_dev+0x48/0x78)
    [<c0173600>] (bus_add_driver+0x98/0x214)
    [<c0174834>] (driver_register+0xa4/0x130)
    [<c001f410>] (do_one_initcall+0xd0/0x1a4)
    [<c0062ddc>] (sys_init_module+0x12b0/0x1454)
    
    This happens because the generic AC97 glue driver creates its codec->ac97 via
    calling snd_ac97_mixer(). snd_ac97_mixer() provides own version of
    snd_device.register which handles the device registration when
    snd_card_register() is called.
    
    To avoid registering the AC97 device twice, we add a new flag to the
    snd_soc_codec: ac97_created which tells whether the AC97 device was created by
    SoC subsystem.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@iki.fi>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8751efdea119..7d22b5d5bc0d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1497,6 +1497,16 @@ static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
 	 * for the generic AC97 subsystem.
 	 */
 	if (rtd->codec_dai->driver->ac97_control && !rtd->codec->ac97_registered) {
+		/*
+		 * It is possible that the AC97 device is already registered to
+		 * the device subsystem. This happens when the device is created
+		 * via snd_ac97_mixer(). Currently only SoC codec that does so
+		 * is the generic AC97 glue but others migh emerge.
+		 *
+		 * In those cases we don't try to register the device again.
+		 */
+		if (!rtd->codec->ac97_created)
+			return 0;
 
 		ret = soc_ac97_dev_register(rtd->codec);
 		if (ret < 0) {
@@ -1812,6 +1822,13 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 
 	codec->ac97->bus->ops = ops;
 	codec->ac97->num = num;
+
+	/*
+	 * Mark the AC97 device to be created by us. This way we ensure that the
+	 * device will be registered with the device subsystem later on.
+	 */
+	codec->ac97_created = 1;
+
 	mutex_unlock(&codec->mutex);
 	return 0;
 }
@@ -1832,6 +1849,7 @@ void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 	kfree(codec->ac97->bus);
 	kfree(codec->ac97);
 	codec->ac97 = NULL;
+	codec->ac97_created = 0;
 	mutex_unlock(&codec->mutex);
 }
 EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);

commit 321de0d05a4bbe0ee74d473e00d7947851bf5284
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 21 15:09:37 2010 +0100

    ASoC: Report error codes for card DAI instantiation failures
    
    Also clean up the error print a bit.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e9968ffecd1c..8751efdea119 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1566,7 +1566,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_links; i++) {
 		ret = soc_probe_dai_link(card, i);
 		if (ret < 0) {
-			printk(KERN_ERR "asoc: failed to instanciate card %s\n", card->name);
+			pr_err("asoc: failed to instantiate card %s: %d\n",
+			       card->name, ret);
 			goto probe_dai_err;
 		}
 	}

commit 0b25ad0571e9208c2bd1302a41ce219794c6f901
Author: Jarkko Nikula <jhnikula@gmail.com>
Date:   Tue Sep 21 15:36:49 2010 +0300

    ASoC: Remove extra rtd->dev.init_name assignment in soc_probe_dai_link
    
    rtd->dev.init_name is set twice in soc_probe_dai_link. I removed the first
    assignement from dai_link->stream_name since then there won't be sysfs name
    changes and usually dai_link->name seems to fit anyway better for a sysfs
    directory name.
    
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ab01e39a0a81..e9968ffecd1c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1451,7 +1451,6 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	snd_soc_dapm_sync(codec);
 
 	/* register the rtd device */
-	rtd->dev.init_name = rtd->dai_link->stream_name;
 	rtd->dev.release = rtd_release;
 	rtd->dev.init_name = dai_link->name;
 	ret = device_register(&rtd->dev);

commit 082100dc9210449dac8ad8c7d20180cc1a0c319d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Sep 20 19:03:28 2010 +0100

    ASoC: Report error code when failing to add controls
    
    Helps with diagnostics.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6001b7f0a138..ab01e39a0a81 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1982,8 +1982,8 @@ int snd_soc_add_controls(struct snd_soc_codec *codec,
 		const struct snd_kcontrol_new *control = &controls[i];
 		err = snd_ctl_add(card, snd_soc_cnew(control, codec, NULL));
 		if (err < 0) {
-			dev_err(codec->dev, "%s: Failed to add %s\n",
-				codec->name, control->name);
+			dev_err(codec->dev, "%s: Failed to add %s: %d\n",
+				codec->name, control->name, err);
 			return err;
 		}
 	}

commit 19c7ac27a1e6a37f5fb5810ad8ac780c62a204c4
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Sep 15 18:22:40 2010 +0100

    ASoC: Add platform listing to debugfs
    
    List registered platforms in debugfs to improve debugability of machine
    drivers.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 63d93b3b7b7a..6001b7f0a138 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -323,6 +323,34 @@ static const struct file_operations dai_list_fops = {
 	.llseek = default_llseek,/* read accesses f_pos */
 };
 
+static ssize_t platform_list_read_file(struct file *file,
+				       char __user *user_buf,
+				       size_t count, loff_t *ppos)
+{
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	ssize_t ret = 0;
+	struct snd_soc_platform *platform;
+
+	if (!buf)
+		return -ENOMEM;
+
+	list_for_each_entry(platform, &platform_list, list)
+		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
+				platform->name);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations platform_list_fops = {
+	.read = platform_list_read_file,
+	.llseek = default_llseek,/* read accesses f_pos */
+};
+
 #else
 
 static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
@@ -3252,6 +3280,10 @@ static int __init snd_soc_init(void)
 	if (!debugfs_create_file("dais", 0444, debugfs_root, NULL,
 				 &dai_list_fops))
 		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
+
+	if (!debugfs_create_file("platforms", 0444, debugfs_root, NULL,
+				 &platform_list_fops))
+		pr_warn("ASoC: Failed to create platform list debugfs file\n");
 #endif
 
 	return platform_driver_register(&soc_driver);

commit f320878032be5c755509583c8a24b57d2ee50b20
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Sep 15 18:19:07 2010 +0100

    ASoC: Add DAI list to debugfs
    
    Allow the user to inspect the list of registered DAIs at runtime to
    improve diagnostics for machine driver setup.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 94a2edf9cfd5..63d93b3b7b7a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -297,6 +297,32 @@ static const struct file_operations codec_list_fops = {
 	.llseek = default_llseek,/* read accesses f_pos */
 };
 
+static ssize_t dai_list_read_file(struct file *file, char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	ssize_t ret = 0;
+	struct snd_soc_dai *dai;
+
+	if (!buf)
+		return -ENOMEM;
+
+	list_for_each_entry(dai, &dai_list, list)
+		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%s\n", dai->name);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations dai_list_fops = {
+	.read = dai_list_read_file,
+	.llseek = default_llseek,/* read accesses f_pos */
+};
+
 #else
 
 static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
@@ -3223,6 +3249,9 @@ static int __init snd_soc_init(void)
 				 &codec_list_fops))
 		pr_warn("ASoC: Failed to create CODEC list debugfs file\n");
 
+	if (!debugfs_create_file("dais", 0444, debugfs_root, NULL,
+				 &dai_list_fops))
+		pr_warn("ASoC: Failed to create DAI list debugfs file\n");
 #endif
 
 	return platform_driver_register(&soc_driver);

commit c3c5a19a50866869996cc219aed2021acf091d6e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Sep 15 18:15:14 2010 +0100

    ASoC: Add debugfs listing of registered CODECs
    
    Help with diagnostics for machine driver setup by listing all the
    registered CODECs in debugfs.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 42542e0da2a3..94a2edf9cfd5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -270,6 +270,33 @@ static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 	debugfs_remove_recursive(codec->debugfs_codec_root);
 }
 
+static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	ssize_t ret = 0;
+	struct snd_soc_codec *codec;
+
+	if (!buf)
+		return -ENOMEM;
+
+	list_for_each_entry(codec, &codec_list, list)
+		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%s\n",
+				codec->name);
+
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations codec_list_fops = {
+	.read = codec_list_read_file,
+	.llseek = default_llseek,/* read accesses f_pos */
+};
+
 #else
 
 static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
@@ -3191,6 +3218,11 @@ static int __init snd_soc_init(void)
 		       "ASoC: Failed to create debugfs directory\n");
 		debugfs_root = NULL;
 	}
+
+	if (!debugfs_create_file("codecs", 0444, debugfs_root, NULL,
+				 &codec_list_fops))
+		pr_warn("ASoC: Failed to create CODEC list debugfs file\n");
+
 #endif
 
 	return platform_driver_register(&soc_driver);

commit 7eba6c05c5075f885f0b26244e1fdac76355f562
Merge: e4b6b74ffd32 708fafb3c540
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Aug 27 20:10:22 2010 +0100

    Merge branch 'for-2.6.36' into for-2.6.37

commit 708fafb3c54039caa5dadc8e9d2dfd999f88f190
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Aug 27 10:34:27 2010 +0800

    ASoC: soc-core: fix debugfs_pop_time file permissions
    
    I think this is a typo, debugfs_pop_time should not be executable.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimloogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 844ae8221a3a..acc91daa1c55 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -251,7 +251,7 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 		printk(KERN_WARNING
 		       "ASoC: Failed to create codec register debugfs file\n");
 
-	codec->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0744,
+	codec->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0644,
 						     codec->debugfs_codec_root,
 						     &codec->pop_time);
 	if (!codec->debugfs_pop_time)

commit 26b01ccdc8ded270a1a65721b99acacf0c44e088
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Aug 18 20:20:55 2010 +0100

    ASoC: Don't call DAI registration for CODECs with no DAI
    
    Otherwise we generate worrying (but benign) warnings for amps.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7093c1787128..65352c7d4b7f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3122,10 +3122,12 @@ int snd_soc_register_codec(struct device *dev,
 		fixup_codec_formats(&dai_drv[i].capture);
 	}
 
-	/* register DAIs */
-	ret = snd_soc_register_dais(dev, dai_drv, num_dai);
-	if (ret < 0)
+	/* register any DAIs */
+	if (num_dai) {
+		ret = snd_soc_register_dais(dev, dai_drv, num_dai);
+		if (ret < 0)
 			goto error;
+	}
 
 	mutex_lock(&client_mutex);
 	list_add(&codec->list, &codec_list);
@@ -3164,8 +3166,9 @@ void snd_soc_unregister_codec(struct device *dev)
 	return;
 
 found:
-	for (i = 0; i < codec->num_dai; i++)
-		snd_soc_unregister_dai(dev);
+	if (codec->num_dai)
+		for (i = 0; i < codec->num_dai; i++)
+			snd_soc_unregister_dai(dev);
 
 	mutex_lock(&client_mutex);
 	list_del(&codec->list);

commit 720ffa4cf3f6b76c27737a9d57bd0e6cc6af1fba
Author: Liam Girdwood <lrg@slimlogic.co.uk>
Date:   Wed Aug 18 00:30:30 2010 +0100

    ASoC: core - fix build warning on x86_64
    
    Output size_t type as a "%Zu" to avoid warnings.
    
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3d480eb3555f..7093c1787128 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2916,7 +2916,7 @@ int snd_soc_register_dais(struct device *dev,
 	struct snd_soc_dai *dai;
 	int i, ret = 0;
 
-	dev_dbg(dev, "dai register %s #%d\n", dev_name(dev), count);
+	dev_dbg(dev, "dai register %s #%Zu\n", dev_name(dev), count);
 
 	for (i = 0; i < count; i++) {
 

commit e4862f2f6f5653dfb67f3ba2b6f0bc74516ed51a
Merge: ec62dbd7eb8e b2c1e07b81a1
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 16 18:42:58 2010 +0100

    Merge branch 'for-2.6.36' into for-2.6.37
    
    Fairly simple conflicts, the most serious ones are the i.MX ones which I
    suspect now need another rename.
    
    Conflicts:
            arch/arm/mach-mx2/clock_imx27.c
            arch/arm/mach-mx2/devices.c
            arch/arm/mach-omap2/board-rx51-peripherals.c
            arch/arm/mach-omap2/board-zoom2.c
            sound/soc/fsl/mpc5200_dma.c
            sound/soc/fsl/mpc5200_dma.h
            sound/soc/fsl/mpc8610_hpcd.c
            sound/soc/pxa/spitz.c

commit 6ba6c9c3414b95c3ed50d529fb0efa744ed45761
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Aug 12 15:49:52 2010 +0100

    ASoC: Remove redundant device name from debugfs directory
    
    Since the core now includes deduplication in the name of CODEC
    devices there's no need to add extra for the debugfs directory name.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ac0fa228c7b3..cea0fe488623 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -234,16 +234,7 @@ static const struct file_operations codec_reg_fops = {
 
 static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
-	char codec_root[128];
-
-	if (codec->dev)
-		snprintf(codec_root, sizeof(codec_root),
-			"%s.%s", codec->name, dev_name(codec->dev));
-	else
-		snprintf(codec_root, sizeof(codec_root),
-			"%s", codec->name);
-
-	codec->debugfs_codec_root = debugfs_create_dir(codec_root,
+	codec->debugfs_codec_root = debugfs_create_dir(codec->name ,
 						       debugfs_root);
 	if (!codec->debugfs_codec_root) {
 		printk(KERN_WARNING

commit 13cb61f8c261ca6a218f83f4ee9c3bd5cfc223a5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Aug 12 15:44:04 2010 +0100

    ASoC: Set up debugfs only once per CODEC
    
    Since the debugfs directory is current per CODEC we should only init
    it when the CODEC is initialised, otherwise we end up with errors
    being generated when an attempt is made to add duplicate debugfs
    entries.
    
    Since most of this stuff is actually for the card we should refactor
    but this can come later.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a004876a39a9..ac0fa228c7b3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1323,6 +1323,9 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 				return ret;
 			}
 		}
+
+		soc_init_codec_debugfs(codec);
+
 		/* mark codec as probed and add to card codec list */
 		codec->probed = 1;
 		list_add(&codec->card_list, &card->codec_dev_list);
@@ -1400,8 +1403,6 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num)
 	if (ret < 0)
 		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
 
-	soc_init_codec_debugfs(codec);
-
 	/* create the pcm */
 	ret = soc_new_pcm(rtd, num);
 	if (ret < 0) {

commit f0fba2ad1b6b53d5360125c41953b7afcd6deff0
Author: Liam Girdwood <lrg@slimlogic.co.uk>
Date:   Wed Mar 17 20:15:21 2010 +0000

    ASoC: multi-component - ASoC Multi-Component Support
    
    This patch extends the ASoC API to allow sound cards to have more than one
    CODEC and more than one platform DMA controller. This is achieved by dividing
    some current ASoC structures that contain both driver data and device data into
    structures that only either contain device data or driver data. i.e.
    
     struct snd_soc_codec    --->  struct snd_soc_codec (device data)
                              +->  struct snd_soc_codec_driver (driver data)
    
     struct snd_soc_platform --->  struct snd_soc_platform (device data)
                              +->  struct snd_soc_platform_driver (driver data)
    
     struct snd_soc_dai      --->  struct snd_soc_dai (device data)
                              +->  struct snd_soc_dai_driver (driver data)
    
     struct snd_soc_device   --->  deleted
    
    This now allows ASoC to be more tightly aligned with the Linux driver model and
    also means that every ASoC codec, platform and (platform) DAI is a kernel
    device. ASoC component private data is now stored as device private data.
    
    The ASoC sound card struct snd_soc_card has also been updated to store lists
    of it's components rather than a pointer to a codec and platform. The PCM
    runtime struct soc_pcm_runtime now has pointers to all its components.
    
    This patch adds DAPM support for ASoC multi-component and removes struct
    snd_soc_socdev from DAPM core. All DAPM calls are now made on a card, codec
    or runtime PCM level basis rather than using snd_soc_socdev.
    
    Other notable multi-component changes:-
    
     * Stream operations now de-reference less structures.
     * close_delayed work() now runs on a DAI basis rather than looping all DAIs
       in a card.
     * PM suspend()/resume() operations can now handle N CODECs and Platforms
       per sound card.
     * Added soc_bind_dai_link() to bind the component devices to the sound card.
     * Added soc_dai_link_probe() and soc_dai_link_remove() to probe and remove
       DAI link components.
     * sysfs entries can now be registered per component per card.
     * snd_soc_new_pcms() functionailty rolled into dai_link_probe().
     * snd_soc_register_codec() now does all the codec list and mutex init.
    
    This patch changes the probe() and remove() of the CODEC drivers as follows:-
    
     o Make CODEC driver a platform driver
     o Moved all struct snd_soc_codec list, mutex, etc initialiasation to core.
     o Removed all static codec pointers (drivers now support > 1 codec dev)
     o snd_soc_register_pcms() now done by core.
     o snd_soc_register_dai() folded into snd_soc_register_codec().
    
    CS4270 portions:
    Acked-by: Timur Tabi <timur@freescale.com>
    
    Some TLV320aic23 and Cirrus platform fixes.
    Signed-off-by: Ryan Mallon <ryan@bluewatersys.com>
    
    TI CODEC and OMAP fixes
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Signed-off-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    Signed-off-by: Jarkko Nikula <jhnikula@gmail.com>
    
    Samsung platform and misc fixes :-
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Jassi Brar <jassi.brar@samsung.com>
    Signed-off-by: Seungwhan Youn <sw.youn@samsung.com>
    
    MPC8610 and PPC fixes.
    Signed-off-by: Timur Tabi <timur@freescale.com>
    
    i.MX fixes and some core fixes.
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    
    J4740 platform fixes:-
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    
    CC: Tony Lindgren <tony@atomide.com>
    CC: Nicolas Ferre <nicolas.ferre@atmel.com>
    CC: Kevin Hilman <khilman@deeprootsystems.com>
    CC: Sascha Hauer <s.hauer@pengutronix.de>
    CC: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    CC: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    CC: Daniel Gloeckner <dg@emlix.com>
    CC: Manuel Lauss <mano@roarinelk.homelinux.net>
    CC: Mike Frysinger <vapier.adi@gmail.com>
    CC: Arnaud Patard <apatard@mandriva.com>
    CC: Wan ZongShun <mcuos.com@gmail.com>
    
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5299932db0b6..a004876a39a9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3,6 +3,8 @@
  *
  * Copyright 2005 Wolfson Microelectronics PLC.
  * Copyright 2005 Openedhand Ltd.
+ * Copyright (C) 2010 Slimlogic Ltd.
+ * Copyright (C) 2010 Texas Instruments Inc.
  *
  * Author: Liam Girdwood <lrg@slimlogic.co.uk>
  *         with code, comments and ideas from :-
@@ -37,6 +39,8 @@
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
 
+#define NAME_SIZE	32
+
 static DEFINE_MUTEX(pcm_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 
@@ -52,6 +56,7 @@ static LIST_HEAD(codec_list);
 
 static int snd_soc_register_card(struct snd_soc_card *card);
 static int snd_soc_unregister_card(struct snd_soc_card *card);
+static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num);
 
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
@@ -86,30 +91,30 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 {
 	int ret, i, step = 1, count = 0;
 
-	if (!codec->reg_cache_size)
+	if (!codec->driver->reg_cache_size)
 		return 0;
 
-	if (codec->reg_cache_step)
-		step = codec->reg_cache_step;
+	if (codec->driver->reg_cache_step)
+		step = codec->driver->reg_cache_step;
 
 	count += sprintf(buf, "%s registers\n", codec->name);
-	for (i = 0; i < codec->reg_cache_size; i += step) {
-		if (codec->readable_register && !codec->readable_register(i))
+	for (i = 0; i < codec->driver->reg_cache_size; i += step) {
+		if (codec->driver->readable_register && !codec->driver->readable_register(i))
 			continue;
 
 		count += sprintf(buf + count, "%2x: ", i);
 		if (count >= PAGE_SIZE - 1)
 			break;
 
-		if (codec->display_register) {
-			count += codec->display_register(codec, buf + count,
+		if (codec->driver->display_register) {
+			count += codec->driver->display_register(codec, buf + count,
 							 PAGE_SIZE - count, i);
 		} else {
 			/* If the read fails it's almost certainly due to
 			 * the register being volatile and the device being
 			 * powered off.
 			 */
-			ret = codec->read(codec, i);
+			ret = codec->driver->read(codec, i);
 			if (ret >= 0)
 				count += snprintf(buf + count,
 						  PAGE_SIZE - count,
@@ -137,8 +142,10 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 static ssize_t codec_reg_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	struct snd_soc_device *devdata = dev_get_drvdata(dev);
-	return soc_codec_reg_show(devdata->card->codec, buf);
+	struct snd_soc_pcm_runtime *rtd =
+			container_of(dev, struct snd_soc_pcm_runtime, dev);
+
+	return soc_codec_reg_show(rtd->codec, buf);
 }
 
 static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
@@ -146,20 +153,20 @@ static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
 static ssize_t pmdown_time_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct snd_soc_device *socdev = dev_get_drvdata(dev);
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_pcm_runtime *rtd =
+			container_of(dev, struct snd_soc_pcm_runtime, dev);
 
-	return sprintf(buf, "%ld\n", card->pmdown_time);
+	return sprintf(buf, "%ld\n", rtd->pmdown_time);
 }
 
 static ssize_t pmdown_time_set(struct device *dev,
 			       struct device_attribute *attr,
 			       const char *buf, size_t count)
 {
-	struct snd_soc_device *socdev = dev_get_drvdata(dev);
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_pcm_runtime *rtd =
+			container_of(dev, struct snd_soc_pcm_runtime, dev);
 
-	strict_strtol(buf, 10, &card->pmdown_time);
+	strict_strtol(buf, 10, &rtd->pmdown_time);
 
 	return count;
 }
@@ -203,19 +210,19 @@ static ssize_t codec_reg_write_file(struct file *file,
 		return -EFAULT;
 	buf[buf_size] = 0;
 
-	if (codec->reg_cache_step)
-		step = codec->reg_cache_step;
+	if (codec->driver->reg_cache_step)
+		step = codec->driver->reg_cache_step;
 
 	while (*start == ' ')
 		start++;
 	reg = simple_strtoul(start, &start, 16);
-	if ((reg >= codec->reg_cache_size) || (reg % step))
+	if ((reg >= codec->driver->reg_cache_size) || (reg % step))
 		return -EINVAL;
 	while (*start == ' ')
 		start++;
 	if (strict_strtoul(start, 16, &value))
 		return -EINVAL;
-	codec->write(codec, reg, value);
+	codec->driver->write(codec, reg, value);
 	return buf_size;
 }
 
@@ -305,7 +312,7 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 	codec->ac97->dev.release = soc_ac97_device_release;
 
 	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
-		     codec->card->number, 0, codec->name);
+		     codec->card->snd_card->number, 0, codec->name);
 	err = device_register(&codec->ac97->dev);
 	if (err < 0) {
 		snd_printk(KERN_ERR "Can't register ac97 bus\n");
@@ -319,24 +326,21 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 static int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret;
 
-	if (codec_dai->symmetric_rates || cpu_dai->symmetric_rates ||
-	    machine->symmetric_rates) {
-		dev_dbg(card->dev, "Symmetry forces %dHz rate\n",
-			machine->rate);
+	if (codec_dai->driver->symmetric_rates || cpu_dai->driver->symmetric_rates ||
+			rtd->dai_link->symmetric_rates) {
+		dev_dbg(&rtd->dev, "Symmetry forces %dHz rate\n",
+				rtd->rate);
 
 		ret = snd_pcm_hw_constraint_minmax(substream->runtime,
 						   SNDRV_PCM_HW_PARAM_RATE,
-						   machine->rate,
-						   machine->rate);
+						   rtd->rate,
+						   rtd->rate);
 		if (ret < 0) {
-			dev_err(card->dev,
+			dev_err(&rtd->dev,
 				"Unable to apply rate symmetry constraint: %d\n", ret);
 			return ret;
 		}
@@ -353,20 +357,19 @@ static int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream)
 static int soc_pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_card *card = socdev->card;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai_driver *cpu_dai_drv = cpu_dai->driver;
+	struct snd_soc_dai_driver *codec_dai_drv = codec_dai->driver;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
 
 	/* startup the audio subsystem */
-	if (cpu_dai->ops->startup) {
-		ret = cpu_dai->ops->startup(substream, cpu_dai);
+	if (cpu_dai->driver->ops->startup) {
+		ret = cpu_dai->driver->ops->startup(substream, cpu_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open interface %s\n",
 				cpu_dai->name);
@@ -374,16 +377,16 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		}
 	}
 
-	if (platform->pcm_ops->open) {
-		ret = platform->pcm_ops->open(substream);
+	if (platform->driver->ops->open) {
+		ret = platform->driver->ops->open(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open platform %s\n", platform->name);
 			goto platform_err;
 		}
 	}
 
-	if (codec_dai->ops->startup) {
-		ret = codec_dai->ops->startup(substream, codec_dai);
+	if (codec_dai->driver->ops->startup) {
+		ret = codec_dai->driver->ops->startup(substream, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open codec %s\n",
 				codec_dai->name);
@@ -391,10 +394,10 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		}
 	}
 
-	if (machine->ops && machine->ops->startup) {
-		ret = machine->ops->startup(substream);
+	if (rtd->dai_link->ops && rtd->dai_link->ops->startup) {
+		ret = rtd->dai_link->ops->startup(substream);
 		if (ret < 0) {
-			printk(KERN_ERR "asoc: %s startup failed\n", machine->name);
+			printk(KERN_ERR "asoc: %s startup failed\n", rtd->dai_link->name);
 			goto machine_err;
 		}
 	}
@@ -402,50 +405,50 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	/* Check that the codec and cpu DAI's are compatible */
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		runtime->hw.rate_min =
-			max(codec_dai->playback.rate_min,
-			    cpu_dai->playback.rate_min);
+			max(codec_dai_drv->playback.rate_min,
+			    cpu_dai_drv->playback.rate_min);
 		runtime->hw.rate_max =
-			min(codec_dai->playback.rate_max,
-			    cpu_dai->playback.rate_max);
+			min(codec_dai_drv->playback.rate_max,
+			    cpu_dai_drv->playback.rate_max);
 		runtime->hw.channels_min =
-			max(codec_dai->playback.channels_min,
-				cpu_dai->playback.channels_min);
+			max(codec_dai_drv->playback.channels_min,
+				cpu_dai_drv->playback.channels_min);
 		runtime->hw.channels_max =
-			min(codec_dai->playback.channels_max,
-				cpu_dai->playback.channels_max);
+			min(codec_dai_drv->playback.channels_max,
+				cpu_dai_drv->playback.channels_max);
 		runtime->hw.formats =
-			codec_dai->playback.formats & cpu_dai->playback.formats;
+			codec_dai_drv->playback.formats & cpu_dai_drv->playback.formats;
 		runtime->hw.rates =
-			codec_dai->playback.rates & cpu_dai->playback.rates;
-		if (codec_dai->playback.rates
+			codec_dai_drv->playback.rates & cpu_dai_drv->playback.rates;
+		if (codec_dai_drv->playback.rates
 			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
-			runtime->hw.rates |= cpu_dai->playback.rates;
-		if (cpu_dai->playback.rates
+			runtime->hw.rates |= cpu_dai_drv->playback.rates;
+		if (cpu_dai_drv->playback.rates
 			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
-			runtime->hw.rates |= codec_dai->playback.rates;
+			runtime->hw.rates |= codec_dai_drv->playback.rates;
 	} else {
 		runtime->hw.rate_min =
-			max(codec_dai->capture.rate_min,
-			    cpu_dai->capture.rate_min);
+			max(codec_dai_drv->capture.rate_min,
+			    cpu_dai_drv->capture.rate_min);
 		runtime->hw.rate_max =
-			min(codec_dai->capture.rate_max,
-			    cpu_dai->capture.rate_max);
+			min(codec_dai_drv->capture.rate_max,
+			    cpu_dai_drv->capture.rate_max);
 		runtime->hw.channels_min =
-			max(codec_dai->capture.channels_min,
-				cpu_dai->capture.channels_min);
+			max(codec_dai_drv->capture.channels_min,
+				cpu_dai_drv->capture.channels_min);
 		runtime->hw.channels_max =
-			min(codec_dai->capture.channels_max,
-				cpu_dai->capture.channels_max);
+			min(codec_dai_drv->capture.channels_max,
+				cpu_dai_drv->capture.channels_max);
 		runtime->hw.formats =
-			codec_dai->capture.formats & cpu_dai->capture.formats;
+			codec_dai_drv->capture.formats & cpu_dai_drv->capture.formats;
 		runtime->hw.rates =
-			codec_dai->capture.rates & cpu_dai->capture.rates;
-		if (codec_dai->capture.rates
+			codec_dai_drv->capture.rates & cpu_dai_drv->capture.rates;
+		if (codec_dai_drv->capture.rates
 			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
-			runtime->hw.rates |= cpu_dai->capture.rates;
-		if (cpu_dai->capture.rates
+			runtime->hw.rates |= cpu_dai_drv->capture.rates;
+		if (cpu_dai_drv->capture.rates
 			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
-			runtime->hw.rates |= codec_dai->capture.rates;
+			runtime->hw.rates |= codec_dai_drv->capture.rates;
 	}
 
 	snd_pcm_limit_hw_rates(runtime);
@@ -461,7 +464,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	}
 	if (!runtime->hw.channels_min || !runtime->hw.channels_max) {
 		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",
-			codec_dai->name, cpu_dai->name);
+				codec_dai->name, cpu_dai->name);
 		goto config_err;
 	}
 
@@ -472,7 +475,8 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 			goto config_err;
 	}
 
-	pr_debug("asoc: %s <-> %s info:\n", codec_dai->name, cpu_dai->name);
+	pr_debug("asoc: %s <-> %s info:\n",
+			codec_dai->name, cpu_dai->name);
 	pr_debug("asoc: rate mask 0x%x\n", runtime->hw.rates);
 	pr_debug("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
 		 runtime->hw.channels_max);
@@ -480,33 +484,33 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		 runtime->hw.rate_max);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		cpu_dai->playback.active++;
-		codec_dai->playback.active++;
+		cpu_dai->playback_active++;
+		codec_dai->playback_active++;
 	} else {
-		cpu_dai->capture.active++;
-		codec_dai->capture.active++;
+		cpu_dai->capture_active++;
+		codec_dai->capture_active++;
 	}
 	cpu_dai->active++;
 	codec_dai->active++;
-	card->codec->active++;
+	rtd->codec->active++;
 	mutex_unlock(&pcm_mutex);
 	return 0;
 
 config_err:
-	if (machine->ops && machine->ops->shutdown)
-		machine->ops->shutdown(substream);
+	if (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)
+		rtd->dai_link->ops->shutdown(substream);
 
 machine_err:
-	if (codec_dai->ops->shutdown)
-		codec_dai->ops->shutdown(substream, codec_dai);
+	if (codec_dai->driver->ops->shutdown)
+		codec_dai->driver->ops->shutdown(substream, codec_dai);
 
 codec_dai_err:
-	if (platform->pcm_ops->close)
-		platform->pcm_ops->close(substream);
+	if (platform->driver->ops->close)
+		platform->driver->ops->close(substream);
 
 platform_err:
-	if (cpu_dai->ops->shutdown)
-		cpu_dai->ops->shutdown(substream, cpu_dai);
+	if (cpu_dai->driver->ops->shutdown)
+		cpu_dai->driver->ops->shutdown(substream, cpu_dai);
 out:
 	mutex_unlock(&pcm_mutex);
 	return ret;
@@ -519,29 +523,25 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
  */
 static void close_delayed_work(struct work_struct *work)
 {
-	struct snd_soc_card *card = container_of(work, struct snd_soc_card,
-						 delayed_work.work);
-	struct snd_soc_codec *codec = card->codec;
-	struct snd_soc_dai *codec_dai;
-	int i;
+	struct snd_soc_pcm_runtime *rtd =
+			container_of(work, struct snd_soc_pcm_runtime, delayed_work.work);
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 
 	mutex_lock(&pcm_mutex);
-	for (i = 0; i < codec->num_dai; i++) {
-		codec_dai = &codec->dai[i];
-
-		pr_debug("pop wq checking: %s status: %s waiting: %s\n",
-			 codec_dai->playback.stream_name,
-			 codec_dai->playback.active ? "active" : "inactive",
-			 codec_dai->pop_wait ? "yes" : "no");
-
-		/* are we waiting on this codec DAI stream */
-		if (codec_dai->pop_wait == 1) {
-			codec_dai->pop_wait = 0;
-			snd_soc_dapm_stream_event(codec,
-				codec_dai->playback.stream_name,
-				SND_SOC_DAPM_STREAM_STOP);
-		}
+
+	pr_debug("pop wq checking: %s status: %s waiting: %s\n",
+		 codec_dai->driver->playback.stream_name,
+		 codec_dai->playback_active ? "active" : "inactive",
+		 codec_dai->pop_wait ? "yes" : "no");
+
+	/* are we waiting on this codec DAI stream */
+	if (codec_dai->pop_wait == 1) {
+		codec_dai->pop_wait = 0;
+		snd_soc_dapm_stream_event(rtd,
+			codec_dai->driver->playback.stream_name,
+			SND_SOC_DAPM_STREAM_STOP);
 	}
+
 	mutex_unlock(&pcm_mutex);
 }
 
@@ -553,22 +553,19 @@ static void close_delayed_work(struct work_struct *work)
 static int soc_codec_close(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
-	struct snd_soc_codec *codec = card->codec;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = rtd->codec;
 
 	mutex_lock(&pcm_mutex);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		cpu_dai->playback.active--;
-		codec_dai->playback.active--;
+		cpu_dai->playback_active--;
+		codec_dai->playback_active--;
 	} else {
-		cpu_dai->capture.active--;
-		codec_dai->capture.active--;
+		cpu_dai->capture_active--;
+		codec_dai->capture_active--;
 	}
 
 	cpu_dai->active--;
@@ -581,27 +578,28 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		snd_soc_dai_digital_mute(codec_dai, 1);
 
-	if (cpu_dai->ops->shutdown)
-		cpu_dai->ops->shutdown(substream, cpu_dai);
+	if (cpu_dai->driver->ops->shutdown)
+		cpu_dai->driver->ops->shutdown(substream, cpu_dai);
 
-	if (codec_dai->ops->shutdown)
-		codec_dai->ops->shutdown(substream, codec_dai);
+	if (codec_dai->driver->ops->shutdown)
+		codec_dai->driver->ops->shutdown(substream, codec_dai);
 
-	if (machine->ops && machine->ops->shutdown)
-		machine->ops->shutdown(substream);
+	if (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)
+		rtd->dai_link->ops->shutdown(substream);
 
-	if (platform->pcm_ops->close)
-		platform->pcm_ops->close(substream);
+	if (platform->driver->ops->close)
+		platform->driver->ops->close(substream);
+	cpu_dai->runtime = NULL;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* start delayed pop wq here for playback streams */
 		codec_dai->pop_wait = 1;
-		schedule_delayed_work(&card->delayed_work,
-			msecs_to_jiffies(card->pmdown_time));
+		schedule_delayed_work(&rtd->delayed_work,
+			msecs_to_jiffies(rtd->pmdown_time));
 	} else {
 		/* capture streams can be powered down now */
-		snd_soc_dapm_stream_event(codec,
-			codec_dai->capture.stream_name,
+		snd_soc_dapm_stream_event(rtd,
+			codec_dai->driver->capture.stream_name,
 			SND_SOC_DAPM_STREAM_STOP);
 	}
 
@@ -617,43 +615,39 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
-	struct snd_soc_codec *codec = card->codec;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
 
-	if (machine->ops && machine->ops->prepare) {
-		ret = machine->ops->prepare(substream);
+	if (rtd->dai_link->ops && rtd->dai_link->ops->prepare) {
+		ret = rtd->dai_link->ops->prepare(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: machine prepare error\n");
 			goto out;
 		}
 	}
 
-	if (platform->pcm_ops->prepare) {
-		ret = platform->pcm_ops->prepare(substream);
+	if (platform->driver->ops->prepare) {
+		ret = platform->driver->ops->prepare(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: platform prepare error\n");
 			goto out;
 		}
 	}
 
-	if (codec_dai->ops->prepare) {
-		ret = codec_dai->ops->prepare(substream, codec_dai);
+	if (codec_dai->driver->ops->prepare) {
+		ret = codec_dai->driver->ops->prepare(substream, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: codec DAI prepare error\n");
 			goto out;
 		}
 	}
 
-	if (cpu_dai->ops->prepare) {
-		ret = cpu_dai->ops->prepare(substream, cpu_dai);
+	if (cpu_dai->driver->ops->prepare) {
+		ret = cpu_dai->driver->ops->prepare(substream, cpu_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: cpu DAI prepare error\n");
 			goto out;
@@ -664,16 +658,16 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    codec_dai->pop_wait) {
 		codec_dai->pop_wait = 0;
-		cancel_delayed_work(&card->delayed_work);
+		cancel_delayed_work(&rtd->delayed_work);
 	}
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		snd_soc_dapm_stream_event(codec,
-					  codec_dai->playback.stream_name,
+		snd_soc_dapm_stream_event(rtd,
+					  codec_dai->driver->playback.stream_name,
 					  SND_SOC_DAPM_STREAM_START);
 	else
-		snd_soc_dapm_stream_event(codec,
-					  codec_dai->capture.stream_name,
+		snd_soc_dapm_stream_event(rtd,
+					  codec_dai->driver->capture.stream_name,
 					  SND_SOC_DAPM_STREAM_START);
 
 	snd_soc_dai_digital_mute(codec_dai, 0);
@@ -692,26 +686,23 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
 
-	if (machine->ops && machine->ops->hw_params) {
-		ret = machine->ops->hw_params(substream, params);
+	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_params) {
+		ret = rtd->dai_link->ops->hw_params(substream, params);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: machine hw_params failed\n");
 			goto out;
 		}
 	}
 
-	if (codec_dai->ops->hw_params) {
-		ret = codec_dai->ops->hw_params(substream, params, codec_dai);
+	if (codec_dai->driver->ops->hw_params) {
+		ret = codec_dai->driver->ops->hw_params(substream, params, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
 				codec_dai->name);
@@ -719,8 +710,8 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
-	if (cpu_dai->ops->hw_params) {
-		ret = cpu_dai->ops->hw_params(substream, params, cpu_dai);
+	if (cpu_dai->driver->ops->hw_params) {
+		ret = cpu_dai->driver->ops->hw_params(substream, params, cpu_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: interface %s hw params failed\n",
 				cpu_dai->name);
@@ -728,8 +719,8 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
-	if (platform->pcm_ops->hw_params) {
-		ret = platform->pcm_ops->hw_params(substream, params);
+	if (platform->driver->ops->hw_params) {
+		ret = platform->driver->ops->hw_params(substream, params);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: platform %s hw params failed\n",
 				platform->name);
@@ -737,23 +728,23 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
-	machine->rate = params_rate(params);
+	rtd->rate = params_rate(params);
 
 out:
 	mutex_unlock(&pcm_mutex);
 	return ret;
 
 platform_err:
-	if (cpu_dai->ops->hw_free)
-		cpu_dai->ops->hw_free(substream, cpu_dai);
+	if (cpu_dai->driver->ops->hw_free)
+		cpu_dai->driver->ops->hw_free(substream, cpu_dai);
 
 interface_err:
-	if (codec_dai->ops->hw_free)
-		codec_dai->ops->hw_free(substream, codec_dai);
+	if (codec_dai->driver->ops->hw_free)
+		codec_dai->driver->ops->hw_free(substream, codec_dai);
 
 codec_err:
-	if (machine->ops && machine->ops->hw_free)
-		machine->ops->hw_free(substream);
+	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)
+		rtd->dai_link->ops->hw_free(substream);
 
 	mutex_unlock(&pcm_mutex);
 	return ret;
@@ -765,13 +756,10 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
-	struct snd_soc_codec *codec = card->codec;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_codec *codec = rtd->codec;
 
 	mutex_lock(&pcm_mutex);
 
@@ -780,19 +768,19 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 		snd_soc_dai_digital_mute(codec_dai, 1);
 
 	/* free any machine hw params */
-	if (machine->ops && machine->ops->hw_free)
-		machine->ops->hw_free(substream);
+	if (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)
+		rtd->dai_link->ops->hw_free(substream);
 
 	/* free any DMA resources */
-	if (platform->pcm_ops->hw_free)
-		platform->pcm_ops->hw_free(substream);
+	if (platform->driver->ops->hw_free)
+		platform->driver->ops->hw_free(substream);
 
 	/* now free hw params for the DAI's  */
-	if (codec_dai->ops->hw_free)
-		codec_dai->ops->hw_free(substream, codec_dai);
+	if (codec_dai->driver->ops->hw_free)
+		codec_dai->driver->ops->hw_free(substream, codec_dai);
 
-	if (cpu_dai->ops->hw_free)
-		cpu_dai->ops->hw_free(substream, cpu_dai);
+	if (cpu_dai->driver->ops->hw_free)
+		cpu_dai->driver->ops->hw_free(substream, cpu_dai);
 
 	mutex_unlock(&pcm_mutex);
 	return 0;
@@ -801,28 +789,25 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_card *card= socdev->card;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret;
 
-	if (codec_dai->ops->trigger) {
-		ret = codec_dai->ops->trigger(substream, cmd, codec_dai);
+	if (codec_dai->driver->ops->trigger) {
+		ret = codec_dai->driver->ops->trigger(substream, cmd, codec_dai);
 		if (ret < 0)
 			return ret;
 	}
 
-	if (platform->pcm_ops->trigger) {
-		ret = platform->pcm_ops->trigger(substream, cmd);
+	if (platform->driver->ops->trigger) {
+		ret = platform->driver->ops->trigger(substream, cmd);
 		if (ret < 0)
 			return ret;
 	}
 
-	if (cpu_dai->ops->trigger) {
-		ret = cpu_dai->ops->trigger(substream, cmd, cpu_dai);
+	if (cpu_dai->driver->ops->trigger) {
+		ret = cpu_dai->driver->ops->trigger(substream, cmd, cpu_dai);
 		if (ret < 0)
 			return ret;
 	}
@@ -837,27 +822,24 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 static snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t offset = 0;
 	snd_pcm_sframes_t delay = 0;
 
-	if (platform->pcm_ops->pointer)
-		offset = platform->pcm_ops->pointer(substream);
+	if (platform->driver->ops->pointer)
+		offset = platform->driver->ops->pointer(substream);
 
-	if (cpu_dai->ops->delay)
-		delay += cpu_dai->ops->delay(substream, cpu_dai);
+	if (cpu_dai->driver->ops->delay)
+		delay += cpu_dai->driver->ops->delay(substream, cpu_dai);
 
-	if (codec_dai->ops->delay)
-		delay += codec_dai->ops->delay(substream, codec_dai);
+	if (codec_dai->driver->ops->delay)
+		delay += codec_dai->driver->ops->delay(substream, codec_dai);
 
-	if (platform->delay)
-		delay += platform->delay(substream, codec_dai);
+	if (platform->driver->delay)
+		delay += platform->driver->delay(substream, codec_dai);
 
 	runtime->delay = delay;
 
@@ -880,104 +862,111 @@ static struct snd_pcm_ops soc_pcm_ops = {
 static int soc_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
-	struct snd_soc_codec *codec = card->codec;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
 	int i;
 
 	/* If the initialization of this soc device failed, there is no codec
 	 * associated with it. Just bail out in this case.
 	 */
-	if (!codec)
+	if (list_empty(&card->codec_dev_list))
 		return 0;
 
 	/* Due to the resume being scheduled into a workqueue we could
 	* suspend before that's finished - wait for it to complete.
 	 */
-	snd_power_lock(codec->card);
-	snd_power_wait(codec->card, SNDRV_CTL_POWER_D0);
-	snd_power_unlock(codec->card);
+	snd_power_lock(card->snd_card);
+	snd_power_wait(card->snd_card, SNDRV_CTL_POWER_D0);
+	snd_power_unlock(card->snd_card);
 
 	/* we're going to block userspace touching us until resume completes */
-	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D3hot);
+	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D3hot);
 
 	/* mute any active DAC's */
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *dai = card->rtd[i].codec_dai;
+		struct snd_soc_dai_driver *drv = dai->driver;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (dai->ops->digital_mute && dai->playback.active)
-			dai->ops->digital_mute(dai, 1);
+		if (drv->ops->digital_mute && dai->playback_active)
+			drv->ops->digital_mute(dai, 1);
 	}
 
 	/* suspend all pcms */
-	for (i = 0; i < card->num_links; i++) {
-		if (card->dai_link[i].ignore_suspend)
+	for (i = 0; i < card->num_rtd; i++) {
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		snd_pcm_suspend_all(card->dai_link[i].pcm);
+		snd_pcm_suspend_all(card->rtd[i].pcm);
 	}
 
 	if (card->suspend_pre)
 		card->suspend_pre(pdev, PMSG_SUSPEND);
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai  *cpu_dai = card->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_platform *platform = card->rtd[i].platform;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->suspend && !cpu_dai->ac97_control)
-			cpu_dai->suspend(cpu_dai);
-		if (platform->suspend)
-			platform->suspend(&card->dai_link[i]);
+		if (cpu_dai->driver->suspend && !cpu_dai->driver->ac97_control)
+			cpu_dai->driver->suspend(cpu_dai);
+		if (platform->driver->suspend && !platform->suspended) {
+			platform->driver->suspend(cpu_dai);
+			platform->suspended = 1;
+		}
 	}
 
 	/* close any waiting streams and save state */
-	run_delayed_work(&card->delayed_work);
-	codec->suspend_bias_level = codec->bias_level;
+	for (i = 0; i < card->num_rtd; i++) {
+		run_delayed_work(&card->rtd[i].delayed_work);
+		card->rtd[i].codec->suspend_bias_level = card->rtd[i].codec->bias_level;
+	}
 
-	for (i = 0; i < codec->num_dai; i++) {
-		char *stream = codec->dai[i].playback.stream_name;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (stream != NULL)
-			snd_soc_dapm_stream_event(codec, stream,
+		if (driver->playback.stream_name != NULL)
+			snd_soc_dapm_stream_event(&card->rtd[i], driver->playback.stream_name,
 				SND_SOC_DAPM_STREAM_SUSPEND);
-		stream = codec->dai[i].capture.stream_name;
-		if (stream != NULL)
-			snd_soc_dapm_stream_event(codec, stream,
+
+		if (driver->capture.stream_name != NULL)
+			snd_soc_dapm_stream_event(&card->rtd[i], driver->capture.stream_name,
 				SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
-	/* If there are paths active then the CODEC will be held with
-	 * bias _ON and should not be suspended. */
-	if (codec_dev->suspend) {
-		switch (codec->bias_level) {
-		case SND_SOC_BIAS_STANDBY:
-		case SND_SOC_BIAS_OFF:
-			codec_dev->suspend(pdev, PMSG_SUSPEND);
-			break;
-		default:
-			dev_dbg(socdev->dev, "CODEC is on over suspend\n");
-			break;
+	/* suspend all CODECs */
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_codec *codec = card->rtd[i].codec;
+		/* If there are paths active then the CODEC will be held with
+		 * bias _ON and should not be suspended. */
+		if (!codec->suspended && codec->driver->suspend) {
+			switch (codec->bias_level) {
+			case SND_SOC_BIAS_STANDBY:
+			case SND_SOC_BIAS_OFF:
+				codec->driver->suspend(codec, PMSG_SUSPEND);
+				codec->suspended = 1;
+				break;
+			default:
+				dev_dbg(codec->dev, "CODEC is on over suspend\n");
+				break;
+			}
 		}
 	}
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->suspend && cpu_dai->ac97_control)
-			cpu_dai->suspend(cpu_dai);
+		if (cpu_dai->driver->suspend && cpu_dai->driver->ac97_control)
+			cpu_dai->driver->suspend(cpu_dai);
 	}
 
 	if (card->suspend_post)
@@ -991,127 +980,127 @@ static int soc_suspend(struct device *dev)
  */
 static void soc_resume_deferred(struct work_struct *work)
 {
-	struct snd_soc_card *card = container_of(work,
-						 struct snd_soc_card,
-						 deferred_resume_work);
-	struct snd_soc_device *socdev = card->socdev;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
-	struct snd_soc_codec *codec = card->codec;
-	struct platform_device *pdev = to_platform_device(socdev->dev);
+	struct snd_soc_card *card =
+			container_of(work, struct snd_soc_card, deferred_resume_work);
+	struct platform_device *pdev = to_platform_device(card->dev);
 	int i;
 
 	/* our power state is still SNDRV_CTL_POWER_D3hot from suspend time,
 	 * so userspace apps are blocked from touching us
 	 */
 
-	dev_dbg(socdev->dev, "starting resume work\n");
+	dev_dbg(card->dev, "starting resume work\n");
 
 	/* Bring us up into D2 so that DAPM starts enabling things */
-	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D2);
+	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D2);
 
 	if (card->resume_pre)
 		card->resume_pre(pdev);
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+	/* resume AC97 DAIs */
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->resume && cpu_dai->ac97_control)
-			cpu_dai->resume(cpu_dai);
-	}
-
-	/* If the CODEC was idle over suspend then it will have been
-	 * left with bias OFF or STANDBY and suspended so we must now
-	 * resume.  Otherwise the suspend was suppressed.
-	 */
-	if (codec_dev->resume) {
-		switch (codec->bias_level) {
-		case SND_SOC_BIAS_STANDBY:
-		case SND_SOC_BIAS_OFF:
-			codec_dev->resume(pdev);
-			break;
-		default:
-			dev_dbg(socdev->dev, "CODEC was on over suspend\n");
-			break;
+		if (cpu_dai->driver->resume && cpu_dai->driver->ac97_control)
+			cpu_dai->driver->resume(cpu_dai);
+	}
+
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_codec *codec = card->rtd[i].codec;
+		/* If the CODEC was idle over suspend then it will have been
+		 * left with bias OFF or STANDBY and suspended so we must now
+		 * resume.  Otherwise the suspend was suppressed.
+		 */
+		if (codec->driver->resume && codec->suspended) {
+			switch (codec->bias_level) {
+			case SND_SOC_BIAS_STANDBY:
+			case SND_SOC_BIAS_OFF:
+				codec->driver->resume(codec);
+				codec->suspended = 0;
+				break;
+			default:
+				dev_dbg(codec->dev, "CODEC was on over suspend\n");
+				break;
+			}
 		}
 	}
 
-	for (i = 0; i < codec->num_dai; i++) {
-		char *stream = codec->dai[i].playback.stream_name;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (stream != NULL)
-			snd_soc_dapm_stream_event(codec, stream,
+		if (driver->playback.stream_name != NULL)
+			snd_soc_dapm_stream_event(&card->rtd[i], driver->playback.stream_name,
 				SND_SOC_DAPM_STREAM_RESUME);
-		stream = codec->dai[i].capture.stream_name;
-		if (stream != NULL)
-			snd_soc_dapm_stream_event(codec, stream,
+
+		if (driver->capture.stream_name != NULL)
+			snd_soc_dapm_stream_event(&card->rtd[i], driver->capture.stream_name,
 				SND_SOC_DAPM_STREAM_RESUME);
 	}
 
 	/* unmute any active DACs */
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *dai = card->rtd[i].codec_dai;
+		struct snd_soc_dai_driver *drv = dai->driver;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (dai->ops->digital_mute && dai->playback.active)
-			dai->ops->digital_mute(dai, 0);
+		if (drv->ops->digital_mute && dai->playback_active)
+			drv->ops->digital_mute(dai, 0);
 	}
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_platform *platform = card->rtd[i].platform;
 
-		if (card->dai_link[i].ignore_suspend)
+		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->resume && !cpu_dai->ac97_control)
-			cpu_dai->resume(cpu_dai);
-		if (platform->resume)
-			platform->resume(&card->dai_link[i]);
+		if (cpu_dai->driver->resume && !cpu_dai->driver->ac97_control)
+			cpu_dai->driver->resume(cpu_dai);
+		if (platform->driver->resume && platform->suspended) {
+			platform->driver->resume(cpu_dai);
+			platform->suspended = 0;
+		}
 	}
 
 	if (card->resume_post)
 		card->resume_post(pdev);
 
-	dev_dbg(socdev->dev, "resume work completed\n");
+	dev_dbg(card->dev, "resume work completed\n");
 
 	/* userspace can access us now we are back as we were before */
-	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D0);
+	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
 }
 
 /* powers up audio subsystem after a suspend */
 static int soc_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_dai *cpu_dai = card->dai_link[0].cpu_dai;
-
-	/* If the initialization of this soc device failed, there is no codec
-	 * associated with it. Just bail out in this case.
-	 */
-	if (!card->codec)
-		return 0;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	int i;
 
 	/* AC97 devices might have other drivers hanging off them so
 	 * need to resume immediately.  Other drivers don't have that
 	 * problem and may take a substantial amount of time to resume
 	 * due to I/O costs and anti-pop so handle them out of line.
 	 */
-	if (cpu_dai->ac97_control) {
-		dev_dbg(socdev->dev, "Resuming AC97 immediately\n");
-		soc_resume_deferred(&card->deferred_resume_work);
-	} else {
-		dev_dbg(socdev->dev, "Scheduling resume work\n");
-		if (!schedule_work(&card->deferred_resume_work))
-			dev_err(socdev->dev, "resume work item may be lost\n");
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		if (cpu_dai->driver->ac97_control) {
+			dev_dbg(dev, "Resuming AC97 immediately\n");
+			soc_resume_deferred(&card->deferred_resume_work);
+		} else {
+			dev_dbg(dev, "Scheduling resume work\n");
+			if (!schedule_work(&card->deferred_resume_work))
+				dev_err(dev, "resume work item may be lost\n");
+		}
 	}
 
 	return 0;
@@ -1124,198 +1113,429 @@ static int soc_resume(struct device *dev)
 static struct snd_soc_dai_ops null_dai_ops = {
 };
 
-static void snd_soc_instantiate_card(struct snd_soc_card *card)
+static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 {
-	struct platform_device *pdev = container_of(card->dev,
-						    struct platform_device,
-						    dev);
-	struct snd_soc_codec_device *codec_dev = card->socdev->codec_dev;
+	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
+	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_codec *codec;
 	struct snd_soc_platform *platform;
-	struct snd_soc_dai *dai;
-	int i, found, ret, ac97;
+	struct snd_soc_dai *codec_dai, *cpu_dai;
 
-	if (card->instantiated)
-		return;
+	if (rtd->complete)
+		return 1;
+	dev_dbg(card->dev, "binding %s at idx %d\n", dai_link->name, num);
 
-	found = 0;
-	list_for_each_entry(platform, &platform_list, list)
-		if (card->platform == platform) {
-			found = 1;
-			break;
+	/* do we already have the CPU DAI for this link ? */
+	if (rtd->cpu_dai) {
+		goto find_codec;
+	}
+	/* no, then find CPU DAI from registered DAIs*/
+	list_for_each_entry(cpu_dai, &dai_list, list) {
+		if (!strcmp(cpu_dai->name, dai_link->cpu_dai_name)) {
+
+			if (!try_module_get(cpu_dai->dev->driver->owner))
+				return -ENODEV;
+
+			rtd->cpu_dai = cpu_dai;
+			goto find_codec;
 		}
-	if (!found) {
-		dev_dbg(card->dev, "Platform %s not registered\n",
-			card->platform->name);
-		return;
 	}
+	dev_dbg(card->dev, "CPU DAI %s not registered\n",
+			dai_link->cpu_dai_name);
 
-	ac97 = 0;
-	for (i = 0; i < card->num_links; i++) {
-		found = 0;
-		list_for_each_entry(dai, &dai_list, list)
-			if (card->dai_link[i].cpu_dai == dai) {
-				found = 1;
-				break;
+find_codec:
+	/* do we already have the CODEC for this link ? */
+	if (rtd->codec) {
+		goto find_platform;
+	}
+
+	/* no, then find CODEC from registered CODECs*/
+	list_for_each_entry(codec, &codec_list, list) {
+		if (!strcmp(codec->name, dai_link->codec_name)) {
+			rtd->codec = codec;
+
+			if (!try_module_get(codec->dev->driver->owner))
+				return -ENODEV;
+
+			/* CODEC found, so find CODEC DAI from registered DAIs from this CODEC*/
+			list_for_each_entry(codec_dai, &dai_list, list) {
+				if (codec->dev == codec_dai->dev &&
+						!strcmp(codec_dai->name, dai_link->codec_dai_name)) {
+					rtd->codec_dai = codec_dai;
+					goto find_platform;
+				}
 			}
-		if (!found) {
-			dev_dbg(card->dev, "DAI %s not registered\n",
-				card->dai_link[i].cpu_dai->name);
-			return;
+			dev_dbg(card->dev, "CODEC DAI %s not registered\n",
+					dai_link->codec_dai_name);
+
+			goto find_platform;
 		}
+	}
+	dev_dbg(card->dev, "CODEC %s not registered\n",
+			dai_link->codec_name);
 
-		if (card->dai_link[i].cpu_dai->ac97_control)
-			ac97 = 1;
+find_platform:
+	/* do we already have the CODEC DAI for this link ? */
+	if (rtd->platform) {
+		goto out;
 	}
+	/* no, then find CPU DAI from registered DAIs*/
+	list_for_each_entry(platform, &platform_list, list) {
+		if (!strcmp(platform->name, dai_link->platform_name)) {
 
-	for (i = 0; i < card->num_links; i++) {
-		if (!card->dai_link[i].codec_dai->ops)
-			card->dai_link[i].codec_dai->ops = &null_dai_ops;
+			if (!try_module_get(platform->dev->driver->owner))
+				return -ENODEV;
+
+			rtd->platform = platform;
+			goto out;
+		}
 	}
 
-	/* If we have AC97 in the system then don't wait for the
-	 * codec.  This will need revisiting if we have to handle
-	 * systems with mixed AC97 and non-AC97 parts.  Only check for
-	 * DAIs currently; we can't do this per link since some AC97
-	 * codecs have non-AC97 DAIs.
-	 */
-	if (!ac97)
-		for (i = 0; i < card->num_links; i++) {
-			found = 0;
-			list_for_each_entry(dai, &dai_list, list)
-				if (card->dai_link[i].codec_dai == dai) {
-					found = 1;
-					break;
-				}
-			if (!found) {
-				dev_dbg(card->dev, "DAI %s not registered\n",
-					card->dai_link[i].codec_dai->name);
-				return;
-			}
+	dev_dbg(card->dev, "platform %s not registered\n",
+			dai_link->platform_name);
+	return 0;
+
+out:
+	/* mark rtd as complete if we found all 4 of our client devices */
+	if (rtd->codec && rtd->codec_dai && rtd->platform && rtd->cpu_dai) {
+		rtd->complete = 1;
+		card->num_rtd++;
+	}
+	return 1;
+}
+
+static void soc_remove_dai_link(struct snd_soc_card *card, int num)
+{
+	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
+	int err;
+
+	/* unregister the rtd device */
+	if (rtd->dev_registered) {
+		device_remove_file(&rtd->dev, &dev_attr_pmdown_time);
+		device_unregister(&rtd->dev);
+		rtd->dev_registered = 0;
+	}
+
+	/* remove the CODEC DAI */
+	if (codec_dai && codec_dai->probed) {
+		if (codec_dai->driver->remove) {
+			err = codec_dai->driver->remove(codec_dai);
+			if (err < 0)
+				printk(KERN_ERR "asoc: failed to remove %s\n", codec_dai->name);
 		}
+		codec_dai->probed = 0;
+		list_del(&codec_dai->card_list);
+	}
 
-	/* Note that we do not current check for codec components */
+	/* remove the platform */
+	if (platform && platform->probed) {
+		if (platform->driver->remove) {
+			err = platform->driver->remove(platform);
+			if (err < 0)
+				printk(KERN_ERR "asoc: failed to remove %s\n", platform->name);
+		}
+		platform->probed = 0;
+		list_del(&platform->card_list);
+		module_put(platform->dev->driver->owner);
+	}
 
-	dev_dbg(card->dev, "All components present, instantiating\n");
+	/* remove the CODEC */
+	if (codec && codec->probed) {
+		if (codec->driver->remove) {
+			err = codec->driver->remove(codec);
+			if (err < 0)
+				printk(KERN_ERR "asoc: failed to remove %s\n", codec->name);
+		}
 
-	/* Found everything, bring it up */
-	card->pmdown_time = pmdown_time;
+		/* Make sure all DAPM widgets are freed */
+		snd_soc_dapm_free(codec);
 
-	if (card->probe) {
-		ret = card->probe(pdev);
-		if (ret < 0)
-			return;
+		soc_cleanup_codec_debugfs(codec);
+		device_remove_file(&rtd->dev, &dev_attr_codec_reg);
+		codec->probed = 0;
+		list_del(&codec->card_list);
+		module_put(codec->dev->driver->owner);
 	}
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->probe) {
-			ret = cpu_dai->probe(pdev, cpu_dai);
-			if (ret < 0)
-				goto cpu_dai_err;
+	/* remove the cpu_dai */
+	if (cpu_dai && cpu_dai->probed) {
+		if (cpu_dai->driver->remove) {
+			err = cpu_dai->driver->remove(cpu_dai);
+			if (err < 0)
+				printk(KERN_ERR "asoc: failed to remove %s\n", cpu_dai->name);
 		}
+		cpu_dai->probed = 0;
+		list_del(&cpu_dai->card_list);
+		module_put(cpu_dai->dev->driver->owner);
 	}
+}
 
-	if (codec_dev->probe) {
-		ret = codec_dev->probe(pdev);
-		if (ret < 0)
-			goto cpu_dai_err;
+static void rtd_release(struct device *dev) {}
+
+static int soc_probe_dai_link(struct snd_soc_card *card, int num)
+{
+	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
+	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
+	int ret;
+
+	dev_dbg(card->dev, "probe %s dai link %d\n", card->name, num);
+
+	/* config components */
+	codec_dai->codec = codec;
+	codec->card = card;
+	cpu_dai->platform = platform;
+	rtd->card = card;
+	rtd->dev.parent = card->dev;
+	codec_dai->card = card;
+	cpu_dai->card = card;
+
+	/* set default power off timeout */
+	rtd->pmdown_time = pmdown_time;
+
+	/* probe the cpu_dai */
+	if (!cpu_dai->probed) {
+		if (cpu_dai->driver->probe) {
+			ret = cpu_dai->driver->probe(cpu_dai);
+			if (ret < 0) {
+				printk(KERN_ERR "asoc: failed to probe CPU DAI %s\n",
+						cpu_dai->name);
+				return ret;
+			}
+		}
+		cpu_dai->probed = 1;
+		/* mark cpu_dai as probed and add to card cpu_dai list */
+		list_add(&cpu_dai->card_list, &card->dai_dev_list);
 	}
-	codec = card->codec;
 
-	if (platform->probe) {
-		ret = platform->probe(pdev);
-		if (ret < 0)
-			goto platform_err;
+	/* probe the CODEC */
+	if (!codec->probed) {
+		if (codec->driver->probe) {
+			ret = codec->driver->probe(codec);
+			if (ret < 0) {
+				printk(KERN_ERR "asoc: failed to probe CODEC %s\n",
+						codec->name);
+				return ret;
+			}
+		}
+		/* mark codec as probed and add to card codec list */
+		codec->probed = 1;
+		list_add(&codec->card_list, &card->codec_dev_list);
 	}
 
-	/* DAPM stream work */
-	INIT_DELAYED_WORK(&card->delayed_work, close_delayed_work);
-#ifdef CONFIG_PM
-	/* deferred resume work */
-	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
-#endif
+	/* probe the platform */
+	if (!platform->probed) {
+		if (platform->driver->probe) {
+			ret = platform->driver->probe(platform);
+			if (ret < 0) {
+				printk(KERN_ERR "asoc: failed to probe platform %s\n",
+						platform->name);
+				return ret;
+			}
+		}
+		/* mark platform as probed and add to card platform list */
+		platform->probed = 1;
+		list_add(&platform->card_list, &card->platform_dev_list);
+	}
 
-	for (i = 0; i < card->num_links; i++) {
-		if (card->dai_link[i].init) {
-			ret = card->dai_link[i].init(codec);
+	/* probe the CODEC DAI */
+	if (!codec_dai->probed) {
+		if (codec_dai->driver->probe) {
+			ret = codec_dai->driver->probe(codec_dai);
 			if (ret < 0) {
-				printk(KERN_ERR "asoc: failed to init %s\n",
-					card->dai_link[i].stream_name);
-				continue;
+				printk(KERN_ERR "asoc: failed to probe CODEC DAI %s\n",
+						codec_dai->name);
+				return ret;
 			}
 		}
-		if (card->dai_link[i].codec_dai->ac97_control)
-			ac97 = 1;
+
+		/* mark cpu_dai as probed and add to card cpu_dai list */
+		codec_dai->probed = 1;
+		list_add(&codec_dai->card_list, &card->dai_dev_list);
 	}
 
-	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
-		 "%s",  card->name);
-	snprintf(codec->card->longname, sizeof(codec->card->longname),
-		 "%s (%s)", card->name, codec->name);
+	/* DAPM dai link stream work */
+	INIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);
+
+	/* now that all clients have probed, initialise the DAI link */
+	if (dai_link->init) {
+		ret = dai_link->init(rtd);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: failed to init %s\n", dai_link->stream_name);
+			return ret;
+		}
+	}
 
 	/* Make sure all DAPM widgets are instantiated */
 	snd_soc_dapm_new_widgets(codec);
+	snd_soc_dapm_sync(codec);
 
-	ret = snd_card_register(codec->card);
+	/* register the rtd device */
+	rtd->dev.init_name = rtd->dai_link->stream_name;
+	rtd->dev.release = rtd_release;
+	rtd->dev.init_name = dai_link->name;
+	ret = device_register(&rtd->dev);
 	if (ret < 0) {
-		printk(KERN_ERR "asoc: failed to register soundcard for %s\n",
-				codec->name);
-		goto card_err;
+		printk(KERN_ERR "asoc: failed to register DAI runtime device %d\n", ret);
+		return ret;
 	}
 
-	mutex_lock(&codec->mutex);
+	rtd->dev_registered = 1;
+	ret = device_create_file(&rtd->dev, &dev_attr_pmdown_time);
+	if (ret < 0)
+		printk(KERN_WARNING "asoc: failed to add pmdown_time sysfs\n");
+
+	/* add DAPM sysfs entries for this codec */
+	ret = snd_soc_dapm_sys_add(&rtd->dev);
+	if (ret < 0)
+		printk(KERN_WARNING "asoc: failed to add codec dapm sysfs entries\n");
+
+	/* add codec sysfs entries */
+	ret = device_create_file(&rtd->dev, &dev_attr_codec_reg);
+	if (ret < 0)
+		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
+
+	soc_init_codec_debugfs(codec);
+
+	/* create the pcm */
+	ret = soc_new_pcm(rtd, num);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: can't create pcm %s\n", dai_link->stream_name);
+		return ret;
+	}
+
+	/* add platform data for AC97 devices */
+	if (rtd->codec_dai->driver->ac97_control)
+		snd_ac97_dev_add_pdata(codec->ac97, rtd->cpu_dai->ac97_pdata);
+
+	return 0;
+}
+
 #ifdef CONFIG_SND_SOC_AC97_BUS
+static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret;
+
 	/* Only instantiate AC97 if not already done by the adaptor
 	 * for the generic AC97 subsystem.
 	 */
-	if (ac97 && strcmp(codec->name, "AC97") != 0) {
-		ret = soc_ac97_dev_register(codec);
+	if (rtd->codec_dai->driver->ac97_control && !rtd->codec->ac97_registered) {
+
+		ret = soc_ac97_dev_register(rtd->codec);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: AC97 device register failed\n");
-			snd_card_free(codec->card);
-			mutex_unlock(&codec->mutex);
-			goto card_err;
+			return ret;
 		}
+
+		rtd->codec->ac97_registered = 1;
 	}
+	return 0;
+}
+
+static void soc_unregister_ac97_dai_link(struct snd_soc_codec *codec)
+{
+	if (codec->ac97_registered) {
+		soc_ac97_dev_unregister(codec);
+		codec->ac97_registered = 0;
+	}
+}
 #endif
 
-	ret = snd_soc_dapm_sys_add(card->socdev->dev);
-	if (ret < 0)
-		printk(KERN_WARNING "asoc: failed to add dapm sysfs entries\n");
+static void snd_soc_instantiate_card(struct snd_soc_card *card)
+{
+	struct platform_device *pdev = to_platform_device(card->dev);
+	int ret, i;
 
-	ret = device_create_file(card->socdev->dev, &dev_attr_pmdown_time);
-	if (ret < 0)
-		printk(KERN_WARNING "asoc: failed to add pmdown_time sysfs\n");
+	mutex_lock(&card->mutex);
 
-	ret = device_create_file(card->socdev->dev, &dev_attr_codec_reg);
-	if (ret < 0)
-		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
+	if (card->instantiated) {
+		mutex_unlock(&card->mutex);
+		return;
+	}
 
-	soc_init_codec_debugfs(codec);
-	mutex_unlock(&codec->mutex);
+	/* bind DAIs */
+	for (i = 0; i < card->num_links; i++)
+		soc_bind_dai_link(card, i);
 
-	card->instantiated = 1;
+	/* bind completed ? */
+	if (card->num_rtd != card->num_links) {
+		mutex_unlock(&card->mutex);
+		return;
+	}
 
-	return;
+	/* card bind complete so register a sound card */
+	ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			card->owner, 0, &card->snd_card);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: can't create sound card for card %s\n",
+			card->name);
+		mutex_unlock(&card->mutex);
+		return;
+	}
+	card->snd_card->dev = card->dev;
+
+#ifdef CONFIG_PM
+	/* deferred resume work */
+	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
+#endif
 
-card_err:
-	if (platform->remove)
-		platform->remove(pdev);
+	/* initialise the sound card only once */
+	if (card->probe) {
+		ret = card->probe(pdev);
+		if (ret < 0)
+			goto card_probe_error;
+	}
 
-platform_err:
-	if (codec_dev->remove)
-		codec_dev->remove(pdev);
+	for (i = 0; i < card->num_links; i++) {
+		ret = soc_probe_dai_link(card, i);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: failed to instanciate card %s\n", card->name);
+			goto probe_dai_err;
+		}
+	}
 
-cpu_dai_err:
-	for (i--; i >= 0; i--) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->remove)
-			cpu_dai->remove(pdev, cpu_dai);
+	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
+		 "%s",  card->name);
+	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
+		 "%s", card->name);
+
+	ret = snd_card_register(card->snd_card);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: failed to register soundcard for %s\n", card->name);
+		goto probe_dai_err;
 	}
 
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	/* register any AC97 codecs */
+	for (i = 0; i < card->num_rtd; i++) {
+			ret = soc_register_ac97_dai_link(&card->rtd[i]);
+			if (ret < 0) {
+				printk(KERN_ERR "asoc: failed to register AC97 %s\n", card->name);
+				goto probe_dai_err;
+			}
+		}
+#endif
+
+	card->instantiated = 1;
+	mutex_unlock(&card->mutex);
+	return;
+
+probe_dai_err:
+	for (i = 0; i < card->num_links; i++)
+		soc_remove_dai_link(card, i);
+
+card_probe_error:
 	if (card->remove)
 		card->remove(pdev);
+
+	snd_card_free(card->snd_card);
+
+	mutex_unlock(&card->mutex);
 }
 
 /*
@@ -1332,15 +1552,15 @@ static void snd_soc_instantiate_cards(void)
 /* probes a new socdev */
 static int soc_probe(struct platform_device *pdev)
 {
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
 	int ret = 0;
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
-
-	/* Bodge while we push things out of socdev */
-	card->socdev = socdev;
 
 	/* Bodge while we unpick instantiation */
 	card->dev = &pdev->dev;
+	INIT_LIST_HEAD(&card->dai_dev_list);
+	INIT_LIST_HEAD(&card->codec_dev_list);
+	INIT_LIST_HEAD(&card->platform_dev_list);
+
 	ret = snd_soc_register_card(card);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to register card\n");
@@ -1353,50 +1573,49 @@ static int soc_probe(struct platform_device *pdev)
 /* removes a socdev */
 static int soc_remove(struct platform_device *pdev)
 {
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
 	int i;
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
-	if (card->instantiated) {
-		run_delayed_work(&card->delayed_work);
+		if (card->instantiated) {
 
-		if (platform->remove)
-			platform->remove(pdev);
-
-		if (codec_dev->remove)
-			codec_dev->remove(pdev);
-
-		for (i = 0; i < card->num_links; i++) {
-			struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-			if (cpu_dai->remove)
-				cpu_dai->remove(pdev, cpu_dai);
+		/* make sure any delayed work runs */
+		for (i = 0; i < card->num_rtd; i++) {
+			struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+			run_delayed_work(&rtd->delayed_work);
 		}
 
+		/* remove and free each DAI */
+		for (i = 0; i < card->num_rtd; i++)
+			soc_remove_dai_link(card, i);
+
+		/* remove the card */
 		if (card->remove)
 			card->remove(pdev);
-	}
 
+		kfree(card->rtd);
+		snd_card_free(card->snd_card);
+	}
 	snd_soc_unregister_card(card);
-
 	return 0;
 }
 
 static int soc_poweroff(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	int i;
 
 	if (!card->instantiated)
 		return 0;
 
 	/* Flush out pmdown_time work - we actually do want to run it
 	 * now, we're shutting down so no imminent restart. */
-	run_delayed_work(&card->delayed_work);
+	for (i = 0; i < card->num_rtd; i++) {
+		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
+		run_delayed_work(&rtd->delayed_work);
+	}
 
-	snd_soc_dapm_shutdown(socdev);
+	snd_soc_dapm_shutdown(card);
 
 	return 0;
 }
@@ -1419,53 +1638,42 @@ static struct platform_driver soc_driver = {
 };
 
 /* create a new pcm */
-static int soc_new_pcm(struct snd_soc_device *socdev,
-	struct snd_soc_dai_link *dai_link, int num)
-{
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_codec *codec = card->codec;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_dai *codec_dai = dai_link->codec_dai;
-	struct snd_soc_dai *cpu_dai = dai_link->cpu_dai;
-	struct snd_soc_pcm_runtime *rtd;
+static int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_pcm *pcm;
 	char new_name[64];
 	int ret = 0, playback = 0, capture = 0;
 
-	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
-	if (rtd == NULL)
-		return -ENOMEM;
-
-	rtd->dai = dai_link;
-	rtd->socdev = socdev;
-	codec_dai->codec = card->codec;
-
 	/* check client and interface hw capabilities */
 	snprintf(new_name, sizeof(new_name), "%s %s-%d",
-		 dai_link->stream_name, codec_dai->name, num);
+			rtd->dai_link->stream_name, codec_dai->name, num);
 
-	if (codec_dai->playback.channels_min)
+	if (codec_dai->driver->playback.channels_min)
 		playback = 1;
-	if (codec_dai->capture.channels_min)
+	if (codec_dai->driver->capture.channels_min)
 		capture = 1;
 
-	ret = snd_pcm_new(codec->card, new_name, codec->pcm_devs++, playback,
-		capture, &pcm);
+	dev_dbg(rtd->card->dev, "registered pcm #%d %s\n",num,new_name);
+	ret = snd_pcm_new(rtd->card->snd_card, new_name,
+			num, playback, capture, &pcm);
 	if (ret < 0) {
-		printk(KERN_ERR "asoc: can't create pcm for codec %s\n",
-			codec->name);
-		kfree(rtd);
+		printk(KERN_ERR "asoc: can't create pcm for codec %s\n", codec->name);
 		return ret;
 	}
 
-	dai_link->pcm = pcm;
+	rtd->pcm = pcm;
 	pcm->private_data = rtd;
-	soc_pcm_ops.mmap = platform->pcm_ops->mmap;
-	soc_pcm_ops.ioctl = platform->pcm_ops->ioctl;
-	soc_pcm_ops.copy = platform->pcm_ops->copy;
-	soc_pcm_ops.silence = platform->pcm_ops->silence;
-	soc_pcm_ops.ack = platform->pcm_ops->ack;
-	soc_pcm_ops.page = platform->pcm_ops->page;
+	soc_pcm_ops.mmap = platform->driver->ops->mmap;
+	soc_pcm_ops.pointer = platform->driver->ops->pointer;
+	soc_pcm_ops.ioctl = platform->driver->ops->ioctl;
+	soc_pcm_ops.copy = platform->driver->ops->copy;
+	soc_pcm_ops.silence = platform->driver->ops->silence;
+	soc_pcm_ops.ack = platform->driver->ops->ack;
+	soc_pcm_ops.page = platform->driver->ops->page;
 
 	if (playback)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
@@ -1473,14 +1681,13 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	if (capture)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &soc_pcm_ops);
 
-	ret = platform->pcm_new(codec->card, codec_dai, pcm);
+	ret = platform->driver->pcm_new(rtd->card->snd_card, codec_dai, pcm);
 	if (ret < 0) {
 		printk(KERN_ERR "asoc: platform pcm constructor failed\n");
-		kfree(rtd);
 		return ret;
 	}
 
-	pcm->private_free = platform->pcm_free;
+	pcm->private_free = platform->driver->pcm_free;
 	printk(KERN_INFO "asoc: %s <-> %s mapping ok\n", codec_dai->name,
 		cpu_dai->name);
 	return ret;
@@ -1496,8 +1703,8 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
  */
 int snd_soc_codec_volatile_register(struct snd_soc_codec *codec, int reg)
 {
-	if (codec->volatile_register)
-		return codec->volatile_register(reg);
+	if (codec->driver->volatile_register)
+		return codec->driver->volatile_register(reg);
 	else
 		return 0;
 }
@@ -1532,7 +1739,6 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 
 	codec->ac97->bus->ops = ops;
 	codec->ac97->num = num;
-	codec->dev = &codec->ac97->dev;
 	mutex_unlock(&codec->mutex);
 	return 0;
 }
@@ -1547,6 +1753,9 @@ EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
 void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
 {
 	mutex_lock(&codec->mutex);
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	soc_unregister_ac97_dai_link(codec);
+#endif
 	kfree(codec->ac97->bus);
 	kfree(codec->ac97);
 	codec->ac97 = NULL;
@@ -1632,95 +1841,6 @@ int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
 }
 EXPORT_SYMBOL_GPL(snd_soc_test_bits);
 
-/**
- * snd_soc_new_pcms - create new sound card and pcms
- * @socdev: the SoC audio device
- * @idx: ALSA card index
- * @xid: card identification
- *
- * Create a new sound card based upon the codec and interface pcms.
- *
- * Returns 0 for success, else error.
- */
-int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
-{
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_codec *codec = card->codec;
-	int ret, i;
-
-	mutex_lock(&codec->mutex);
-
-	/* register a sound card */
-	ret = snd_card_create(idx, xid, codec->owner, 0, &codec->card);
-	if (ret < 0) {
-		printk(KERN_ERR "asoc: can't create sound card for codec %s\n",
-			codec->name);
-		mutex_unlock(&codec->mutex);
-		return ret;
-	}
-
-	codec->socdev = socdev;
-	codec->card->dev = socdev->dev;
-	codec->card->private_data = codec;
-	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));
-
-	/* create the pcms */
-	for (i = 0; i < card->num_links; i++) {
-		ret = soc_new_pcm(socdev, &card->dai_link[i], i);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: can't create pcm %s\n",
-				card->dai_link[i].stream_name);
-			mutex_unlock(&codec->mutex);
-			return ret;
-		}
-		/* Check for codec->ac97 to handle the ac97.c fun */
-		if (card->dai_link[i].codec_dai->ac97_control && codec->ac97) {
-			snd_ac97_dev_add_pdata(codec->ac97,
-				card->dai_link[i].cpu_dai->ac97_pdata);
-		}
-	}
-
-	mutex_unlock(&codec->mutex);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
-
-/**
- * snd_soc_free_pcms - free sound card and pcms
- * @socdev: the SoC audio device
- *
- * Frees sound card and pcms associated with the socdev.
- * Also unregister the codec if it is an AC97 device.
- */
-void snd_soc_free_pcms(struct snd_soc_device *socdev)
-{
-	struct snd_soc_codec *codec = socdev->card->codec;
-#ifdef CONFIG_SND_SOC_AC97_BUS
-	struct snd_soc_dai *codec_dai;
-	int i;
-#endif
-
-	mutex_lock(&codec->mutex);
-	soc_cleanup_codec_debugfs(codec);
-#ifdef CONFIG_SND_SOC_AC97_BUS
-	for (i = 0; i < codec->num_dai; i++) {
-		codec_dai = &codec->dai[i];
-		if (codec_dai->ac97_control && codec->ac97 &&
-		    strcmp(codec->name, "AC97") != 0) {
-			soc_ac97_dev_unregister(codec);
-			goto free_card;
-		}
-	}
-free_card:
-#endif
-
-	if (codec->card)
-		snd_card_free(codec->card);
-	device_remove_file(socdev->dev, &dev_attr_codec_reg);
-	mutex_unlock(&codec->mutex);
-}
-EXPORT_SYMBOL_GPL(snd_soc_free_pcms);
-
 /**
  * snd_soc_set_runtime_hwparams - set the runtime hardware parameters
  * @substream: the pcm substream
@@ -1782,7 +1902,7 @@ EXPORT_SYMBOL_GPL(snd_soc_cnew);
 int snd_soc_add_controls(struct snd_soc_codec *codec,
 	const struct snd_kcontrol_new *controls, int num_controls)
 {
-	struct snd_card *card = codec->card;
+	struct snd_card *card = codec->card->snd_card;
 	int err, i;
 
 	for (i = 0; i < num_controls; i++) {
@@ -2337,7 +2457,7 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 int snd_soc_limit_volume(struct snd_soc_codec *codec,
 	const char *name, int max)
 {
-	struct snd_card *card = codec->card;
+	struct snd_card *card = codec->card->snd_card;
 	struct snd_kcontrol *kctl;
 	struct soc_mixer_control *mc;
 	int found = 0;
@@ -2469,8 +2589,8 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r_sx);
 int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 	unsigned int freq, int dir)
 {
-	if (dai->ops && dai->ops->set_sysclk)
-		return dai->ops->set_sysclk(dai, clk_id, freq, dir);
+	if (dai->driver && dai->driver->ops->set_sysclk)
+		return dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);
 	else
 		return -EINVAL;
 }
@@ -2489,8 +2609,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
 	int div_id, int div)
 {
-	if (dai->ops && dai->ops->set_clkdiv)
-		return dai->ops->set_clkdiv(dai, div_id, div);
+	if (dai->driver && dai->driver->ops->set_clkdiv)
+		return dai->driver->ops->set_clkdiv(dai, div_id, div);
 	else
 		return -EINVAL;
 }
@@ -2509,8 +2629,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
 	unsigned int freq_in, unsigned int freq_out)
 {
-	if (dai->ops && dai->ops->set_pll)
-		return dai->ops->set_pll(dai, pll_id, source,
+	if (dai->driver && dai->driver->ops->set_pll)
+		return dai->driver->ops->set_pll(dai, pll_id, source,
 					 freq_in, freq_out);
 	else
 		return -EINVAL;
@@ -2526,8 +2646,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
  */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	if (dai->ops && dai->ops->set_fmt)
-		return dai->ops->set_fmt(dai, fmt);
+	if (dai->driver && dai->driver->ops->set_fmt)
+		return dai->driver->ops->set_fmt(dai, fmt);
 	else
 		return -EINVAL;
 }
@@ -2547,8 +2667,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
 {
-	if (dai->ops && dai->ops->set_tdm_slot)
-		return dai->ops->set_tdm_slot(dai, tx_mask, rx_mask,
+	if (dai->driver && dai->driver->ops->set_tdm_slot)
+		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
 				slots, slot_width);
 	else
 		return -EINVAL;
@@ -2571,8 +2691,8 @@ int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,
 	unsigned int tx_num, unsigned int *tx_slot,
 	unsigned int rx_num, unsigned int *rx_slot)
 {
-	if (dai->ops && dai->ops->set_channel_map)
-		return dai->ops->set_channel_map(dai, tx_num, tx_slot,
+	if (dai->driver && dai->driver->ops->set_channel_map)
+		return dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,
 			rx_num, rx_slot);
 	else
 		return -EINVAL;
@@ -2588,8 +2708,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);
  */
 int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
 {
-	if (dai->ops && dai->ops->set_tristate)
-		return dai->ops->set_tristate(dai, tristate);
+	if (dai->driver && dai->driver->ops->set_tristate)
+		return dai->driver->ops->set_tristate(dai, tristate);
 	else
 		return -EINVAL;
 }
@@ -2604,8 +2724,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
  */
 int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
 {
-	if (dai->ops && dai->ops->digital_mute)
-		return dai->ops->digital_mute(dai, mute);
+	if (dai->driver && dai->driver->ops->digital_mute)
+		return dai->driver->ops->digital_mute(dai, mute);
 	else
 		return -EINVAL;
 }
@@ -2622,11 +2742,22 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
  */
 static int snd_soc_register_card(struct snd_soc_card *card)
 {
+	int i;
+
 	if (!card->name || !card->dev)
 		return -EINVAL;
 
+	card->rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime) * card->num_links,
+			GFP_KERNEL);
+	if (card->rtd == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < card->num_links; i++)
+		card->rtd[i].dai_link = &card->dai_link[i];
+
 	INIT_LIST_HEAD(&card->list);
 	card->instantiated = 0;
+	mutex_init(&card->mutex);
 
 	mutex_lock(&client_mutex);
 	list_add(&card->list, &card_list);
@@ -2652,30 +2783,97 @@ static int snd_soc_unregister_card(struct snd_soc_card *card)
 	mutex_lock(&client_mutex);
 	list_del(&card->list);
 	mutex_unlock(&client_mutex);
-
 	dev_dbg(card->dev, "Unregistered card '%s'\n", card->name);
 
 	return 0;
 }
 
+/*
+ * Simplify DAI link configuration by removing ".-1" from device names
+ * and sanitizing names.
+ */
+static inline char *fmt_single_name(struct device *dev, int *id)
+{
+	char *found, name[NAME_SIZE];
+	int id1, id2;
+
+	if (dev_name(dev) == NULL)
+		return NULL;
+
+	strncpy(name, dev_name(dev), NAME_SIZE);
+
+	/* are we a "%s.%d" name (platform and SPI components) */
+	found = strstr(name, dev->driver->name);
+	if (found) {
+		/* get ID */
+		if (sscanf(&found[strlen(dev->driver->name)], ".%d", id) == 1) {
+
+			/* discard ID from name if ID == -1 */
+			if (*id == -1)
+				found[strlen(dev->driver->name)] = '\0';
+		}
+
+	} else {
+		/* I2C component devices are named "bus-addr"  */
+		if (sscanf(name, "%x-%x", &id1, &id2) == 2) {
+			char tmp[NAME_SIZE];
+
+			/* create unique ID number from I2C addr and bus */
+			*id = ((id1 && 0xffff) << 16) + id2;
+
+			/* sanitize component name for DAI link creation */
+			snprintf(tmp, NAME_SIZE, "%s.%s", dev->driver->name, name);
+			strncpy(name, tmp, NAME_SIZE);
+		} else
+			*id = 0;
+	}
+
+	return kstrdup(name, GFP_KERNEL);
+}
+
+/*
+ * Simplify DAI link naming for single devices with multiple DAIs by removing
+ * any ".-1" and using the DAI name (instead of device name).
+ */
+static inline char *fmt_multiple_name(struct device *dev,
+		struct snd_soc_dai_driver *dai_drv)
+{
+	if (dai_drv->name == NULL) {
+		printk(KERN_ERR "asoc: error - multiple DAI %s registered with no name\n",
+				dev_name(dev));
+		return NULL;
+	}
+
+	return kstrdup(dai_drv->name, GFP_KERNEL);
+}
+
 /**
  * snd_soc_register_dai - Register a DAI with the ASoC core
  *
  * @dai: DAI to register
  */
-int snd_soc_register_dai(struct snd_soc_dai *dai)
+int snd_soc_register_dai(struct device *dev,
+		struct snd_soc_dai_driver *dai_drv)
 {
-	if (!dai->name)
-		return -EINVAL;
+	struct snd_soc_dai *dai;
+
+	dev_dbg(dev, "dai register %s\n", dev_name(dev));
 
-	/* The device should become mandatory over time */
-	if (!dai->dev)
-		printk(KERN_WARNING "No device for DAI %s\n", dai->name);
+	dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
+	if (dai == NULL)
+			return -ENOMEM;
 
-	if (!dai->ops)
-		dai->ops = &null_dai_ops;
+	/* create DAI component name */
+	dai->name = fmt_single_name(dev, &dai->id);
+	if (dai->name == NULL) {
+		kfree(dai);
+		return -ENOMEM;
+	}
 
-	INIT_LIST_HEAD(&dai->list);
+	dai->dev = dev;
+	dai->driver = dai_drv;
+	if (!dai->driver->ops)
+		dai->driver->ops = &null_dai_ops;
 
 	mutex_lock(&client_mutex);
 	list_add(&dai->list, &dai_list);
@@ -2693,13 +2891,24 @@ EXPORT_SYMBOL_GPL(snd_soc_register_dai);
  *
  * @dai: DAI to unregister
  */
-void snd_soc_unregister_dai(struct snd_soc_dai *dai)
+void snd_soc_unregister_dai(struct device *dev)
 {
+	struct snd_soc_dai *dai;
+
+	list_for_each_entry(dai, &dai_list, list) {
+		if (dev == dai->dev)
+			goto found;
+	}
+	return;
+
+found:
 	mutex_lock(&client_mutex);
 	list_del(&dai->list);
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Unregistered DAI '%s'\n", dai->name);
+	kfree(dai->name);
+	kfree(dai);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
 
@@ -2709,21 +2918,47 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
  * @dai: Array of DAIs to register
  * @count: Number of DAIs
  */
-int snd_soc_register_dais(struct snd_soc_dai *dai, size_t count)
+int snd_soc_register_dais(struct device *dev,
+		struct snd_soc_dai_driver *dai_drv, size_t count)
 {
-	int i, ret;
+	struct snd_soc_dai *dai;
+	int i, ret = 0;
+
+	dev_dbg(dev, "dai register %s #%d\n", dev_name(dev), count);
 
 	for (i = 0; i < count; i++) {
-		ret = snd_soc_register_dai(&dai[i]);
-		if (ret != 0)
+
+		dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL);
+		if (dai == NULL)
+			return -ENOMEM;
+
+		/* create DAI component name */
+		dai->name = fmt_multiple_name(dev, &dai_drv[i]);
+		if (dai->name == NULL) {
+			kfree(dai);
+			ret = -EINVAL;
 			goto err;
+		}
+
+		dai->dev = dev;
+		dai->id = i;
+		dai->driver = &dai_drv[i];
+		if (!dai->driver->ops)
+			dai->driver->ops = &null_dai_ops;
+
+		mutex_lock(&client_mutex);
+		list_add(&dai->list, &dai_list);
+		mutex_unlock(&client_mutex);
+
+		pr_debug("Registered DAI '%s'\n", dai->name);
 	}
 
+	snd_soc_instantiate_cards();
 	return 0;
 
 err:
 	for (i--; i >= 0; i--)
-		snd_soc_unregister_dai(&dai[i]);
+		snd_soc_unregister_dai(dev);
 
 	return ret;
 }
@@ -2735,12 +2970,12 @@ EXPORT_SYMBOL_GPL(snd_soc_register_dais);
  * @dai: Array of DAIs to unregister
  * @count: Number of DAIs
  */
-void snd_soc_unregister_dais(struct snd_soc_dai *dai, size_t count)
+void snd_soc_unregister_dais(struct device *dev, size_t count)
 {
 	int i;
 
 	for (i = 0; i < count; i++)
-		snd_soc_unregister_dai(&dai[i]);
+		snd_soc_unregister_dai(dev);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_dais);
 
@@ -2749,12 +2984,26 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dais);
  *
  * @platform: platform to register
  */
-int snd_soc_register_platform(struct snd_soc_platform *platform)
+int snd_soc_register_platform(struct device *dev,
+		struct snd_soc_platform_driver *platform_drv)
 {
-	if (!platform->name)
-		return -EINVAL;
+	struct snd_soc_platform *platform;
+
+	dev_dbg(dev, "platform register %s\n", dev_name(dev));
+
+	platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);
+	if (platform == NULL)
+			return -ENOMEM;
+
+	/* create platform component name */
+	platform->name = fmt_single_name(dev, &platform->id);
+	if (platform->name == NULL) {
+		kfree(platform);
+		return -ENOMEM;
+	}
 
-	INIT_LIST_HEAD(&platform->list);
+	platform->dev = dev;
+	platform->driver = platform_drv;
 
 	mutex_lock(&client_mutex);
 	list_add(&platform->list, &platform_list);
@@ -2772,13 +3021,24 @@ EXPORT_SYMBOL_GPL(snd_soc_register_platform);
  *
  * @platform: platform to unregister
  */
-void snd_soc_unregister_platform(struct snd_soc_platform *platform)
+void snd_soc_unregister_platform(struct device *dev)
 {
+	struct snd_soc_platform *platform;
+
+	list_for_each_entry(platform, &platform_list, list) {
+		if (dev == platform->dev)
+			goto found;
+	}
+	return;
+
+found:
 	mutex_lock(&client_mutex);
 	list_del(&platform->list);
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Unregistered platform '%s'\n", platform->name);
+	kfree(platform->name);
+	kfree(platform);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);
 
@@ -2820,32 +3080,78 @@ static void fixup_codec_formats(struct snd_soc_pcm_stream *stream)
  *
  * @codec: codec to register
  */
-int snd_soc_register_codec(struct snd_soc_codec *codec)
+int snd_soc_register_codec(struct device *dev,
+		struct snd_soc_codec_driver *codec_drv,
+		struct snd_soc_dai_driver *dai_drv, int num_dai)
 {
-	int i;
+	struct snd_soc_codec *codec;
+	int ret, i;
 
-	if (!codec->name)
-		return -EINVAL;
+	dev_dbg(dev, "codec register %s\n", dev_name(dev));
+
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
 
-	/* The device should become mandatory over time */
-	if (!codec->dev)
-		printk(KERN_WARNING "No device for codec %s\n", codec->name);
+	/* create CODEC component name */
+	codec->name = fmt_single_name(dev, &codec->id);
+	if (codec->name == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+
+	/* allocate CODEC register cache */
+	if (codec_drv->reg_cache_size && codec_drv->reg_word_size) {
 
-	INIT_LIST_HEAD(&codec->list);
+		if (codec_drv->reg_cache_default)
+			codec->reg_cache = kmemdup(codec_drv->reg_cache_default,
+				codec_drv->reg_cache_size * codec_drv->reg_word_size, GFP_KERNEL);
+		else
+			codec->reg_cache = kzalloc(codec_drv->reg_cache_size *
+				codec_drv->reg_word_size, GFP_KERNEL);
 
-	for (i = 0; i < codec->num_dai; i++) {
-		fixup_codec_formats(&codec->dai[i].playback);
-		fixup_codec_formats(&codec->dai[i].capture);
+		if (codec->reg_cache == NULL) {
+			kfree(codec->name);
+			kfree(codec);
+			return -ENOMEM;
+		}
 	}
 
+	codec->dev = dev;
+	codec->driver = codec_drv;
+	codec->bias_level = SND_SOC_BIAS_OFF;
+	codec->num_dai = num_dai;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	for (i = 0; i < num_dai; i++) {
+		fixup_codec_formats(&dai_drv[i].playback);
+		fixup_codec_formats(&dai_drv[i].capture);
+	}
+
+	/* register DAIs */
+	ret = snd_soc_register_dais(dev, dai_drv, num_dai);
+	if (ret < 0)
+			goto error;
+
 	mutex_lock(&client_mutex);
 	list_add(&codec->list, &codec_list);
 	snd_soc_instantiate_cards();
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Registered codec '%s'\n", codec->name);
-
 	return 0;
+
+error:
+	for (i--; i >= 0; i--)
+		snd_soc_unregister_dai(dev);
+
+	if (codec->reg_cache)
+		kfree(codec->reg_cache);
+	kfree(codec->name);
+	kfree(codec);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_codec);
 
@@ -2854,13 +3160,30 @@ EXPORT_SYMBOL_GPL(snd_soc_register_codec);
  *
  * @codec: codec to unregister
  */
-void snd_soc_unregister_codec(struct snd_soc_codec *codec)
+void snd_soc_unregister_codec(struct device *dev)
 {
+	struct snd_soc_codec *codec;
+	int i;
+
+	list_for_each_entry(codec, &codec_list, list) {
+		if (dev == codec->dev)
+			goto found;
+	}
+	return;
+
+found:
+	for (i = 0; i < codec->num_dai; i++)
+		snd_soc_unregister_dai(dev);
+
 	mutex_lock(&client_mutex);
 	list_del(&codec->list);
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Unregistered codec '%s'\n", codec->name);
+
+	if (codec->reg_cache)
+		kfree(codec->reg_cache);
+	kfree(codec);
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
 

commit faa38b5e0e092914764cdba9f83d31a3f794d182
Merge: 78417334b5cb 74bf40f0793f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 7 17:07:31 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6: (214 commits)
      ALSA: hda - Add pin-fix for HP dc5750
      ALSA: als4000: Fix potentially invalid DMA mode setup
      ALSA: als4000: enable burst mode
      ALSA: hda - Fix initial capsrc selection in patch_alc269()
      ASoC: TWL4030: Capture route runtime DAPM ordering fix
      ALSA: hda - Add PC-beep whitelist for an Intel board
      ALSA: hda - More relax for pending period handling
      ALSA: hda - Define AC_FMT_* constants
      ALSA: hda - Fix beep frequency on IDT 92HD73xx and 92HD71Bxx codecs
      ALSA: hda - Add support for HDMI HBR passthrough
      ALSA: hda - Set Stream Type in Stream Format according to AES0
      ALSA: hda - Fix Thinkpad X300 so SPDIF is not exposed
      ALSA: hda - FIX to not expose SPDIF on Thinkpad X301, since it does not have the ability to use SPDIF
      ASoC: wm9081: fix resource reclaim in wm9081_register error path
      ASoC: wm8978: fix a memory leak if a wm8978_register fail
      ASoC: wm8974: fix a memory leak if another WM8974 is registered
      ASoC: wm8961: fix resource reclaim in wm8961_register error path
      ASoC: wm8955: fix resource reclaim in wm8955_register error path
      ASoC: wm8940: fix a memory leak if wm8940_register return error
      ASoC: wm8904: fix resource reclaim in wm8904_register error path
      ...

commit 5164d74d74447895aaa31c094a1b9e666acaa656
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jul 14 16:14:33 2010 +0100

    ASoC: Handle read failures in codec_reg
    
    When a device is powered down volatile registers can't be read so
    attempts to display codec_reg will show error values, and obviously
    it is also possible for there to be hardware errors too. Check for
    errors from reads and display them more clearly when formatting
    codec_reg.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8b79d90efdc1..5299932db0b6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -84,7 +84,7 @@ static int run_delayed_work(struct delayed_work *dwork)
 /* codec register dump */
 static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 {
-	int i, step = 1, count = 0;
+	int ret, i, step = 1, count = 0;
 
 	if (!codec->reg_cache_size)
 		return 0;
@@ -101,12 +101,24 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 		if (count >= PAGE_SIZE - 1)
 			break;
 
-		if (codec->display_register)
+		if (codec->display_register) {
 			count += codec->display_register(codec, buf + count,
 							 PAGE_SIZE - count, i);
-		else
-			count += snprintf(buf + count, PAGE_SIZE - count,
-					  "%4x", codec->read(codec, i));
+		} else {
+			/* If the read fails it's almost certainly due to
+			 * the register being volatile and the device being
+			 * powered off.
+			 */
+			ret = codec->read(codec, i);
+			if (ret >= 0)
+				count += snprintf(buf + count,
+						  PAGE_SIZE - count,
+						  "%4x", ret);
+			else
+				count += snprintf(buf + count,
+						  PAGE_SIZE - count,
+						  "<no data: %d>", ret);
+		}
 
 		if (count >= PAGE_SIZE - 1)
 			break;

commit 20630c7f5966419dd6a1f00b669a7771e228510a
Author: Stuart Longland <redhatter@gentoo.org>
Date:   Fri Jun 18 12:56:10 2010 +1000

    ASoC: Fix overflow bug in SOC_DOUBLE_R_SX_TLV
    
    When SX_TLV widgets are read, if the gain is set to a value below 0dB,
    the mixer control is erroniously read as being at maximum volume.
    
    The value read out of the CODEC register is never sign-extended, and
    when the minimum value is subtracted (read; added, since the minimum is
    negative) the result is a number greater than the maximum allowed value
    for the control, and hence it saturates.
    
    Solution: Mask the result so that it "wraps around", emulating
    sign-extension.
    
    Signed-off-by: Stuart Longland <redhatter@gentoo.org>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 26f17323ef19..8b79d90efdc1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2396,8 +2396,8 @@ int snd_soc_get_volsw_2r_sx(struct snd_kcontrol *kcontrol,
 	int val = snd_soc_read(codec, mc->reg) & mask;
 	int valr = snd_soc_read(codec, mc->rreg) & mask;
 
-	ucontrol->value.integer.value[0] = ((val & 0xff)-min);
-	ucontrol->value.integer.value[1] = ((valr & 0xff)-min);
+	ucontrol->value.integer.value[0] = ((val & 0xff)-min) & mask;
+	ucontrol->value.integer.value[1] = ((valr & 0xff)-min) & mask;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r_sx);

commit 421f91d21ad6f799dc7b489bb33cc560ccc56f98
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Fri Jun 11 12:17:00 2010 +0200

    fix typos concerning "initiali[zs]e"
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 998569d60330..e048e0910099 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1307,7 +1307,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 }
 
 /*
- * Attempt to initialise any uninitalised cards.  Must be called with
+ * Attempt to initialise any uninitialised cards.  Must be called with
  * client_mutex.
  */
 static void snd_soc_instantiate_cards(void)

commit f1df5aec68946e427eb4884c4d80e3259361478c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jun 15 15:14:31 2010 +0100

    ASoC: Pay attention to write errors in volsw_2r_sx
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 254dd1c6914d..26f17323ef19 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2433,14 +2433,12 @@ int snd_soc_put_volsw_2r_sx(struct snd_kcontrol *kcontrol,
 	if (oval != val) {
 		ret = snd_soc_write(codec, mc->reg, val);
 		if (ret < 0)
-			return 0;
-		ret = 1;
+			return ret;
 	}
 	if (ovalr != valr) {
 		ret = snd_soc_write(codec, mc->rreg, valr);
 		if (ret < 0)
-			return 0;
-		ret = 1;
+			return ret;
 	}
 
 	return 0;

commit e37c83c06c2690157a989df40dc99a6b61c9ea15
Merge: ce1f7d30766f 67a3e12b05e0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 31 11:07:15 2010 +0100

    Merge commit 'v2.6.35-rc1' into for-2.6.36

commit d71f4cece4bd97d05592836202fc04ff2e7817e3
Merge: 19008bdacb9f ad8332c1302b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu May 20 12:00:43 2010 +0200

    Merge branch 'topic/asoc' into for-linus
    
    Conflicts:
            sound/soc/codecs/ad1938.c

commit b6f4bb383d69cac46f17e2305720f9a3d426c5ed
Author: apatard@mandriva.com <apatard@mandriva.com>
Date:   Sat May 15 17:30:01 2010 +0200

    ASoC: Add SOC_DOUBLE_R_SX_TLV control
    
    This patch is adding a new control which has the following capabilities:
    - tlv
    - variable data size (for instance, 7 ou 8 bit)
    - double mixer
    - data range centered around 0
    
    Signed-off-by: Arnaud Patard <apatard@mandriva.com>
    Acked-by: Liam Girdwood <lrg@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e1043f644730..6220bc1ee427 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2351,6 +2351,101 @@ int snd_soc_limit_volume(struct snd_soc_codec *codec,
 }
 EXPORT_SYMBOL_GPL(snd_soc_limit_volume);
 
+/**
+ * snd_soc_info_volsw_2r_sx - double with tlv and variable data size
+ *  mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_2r_sx(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int max = mc->max;
+	int min = mc->min;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = max-min;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r_sx);
+
+/**
+ * snd_soc_get_volsw_2r_sx - double with tlv and variable data size
+ *  mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_2r_sx(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int mask = (1<<mc->shift)-1;
+	int min = mc->min;
+	int val = snd_soc_read(codec, mc->reg) & mask;
+	int valr = snd_soc_read(codec, mc->rreg) & mask;
+
+	ucontrol->value.integer.value[0] = ((val & 0xff)-min);
+	ucontrol->value.integer.value[1] = ((valr & 0xff)-min);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r_sx);
+
+/**
+ * snd_soc_put_volsw_2r_sx - double with tlv and variable data size
+ *  mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_2r_sx(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int mask = (1<<mc->shift)-1;
+	int min = mc->min;
+	int ret;
+	unsigned int val, valr, oval, ovalr;
+
+	val = ((ucontrol->value.integer.value[0]+min) & 0xff);
+	val &= mask;
+	valr = ((ucontrol->value.integer.value[1]+min) & 0xff);
+	valr &= mask;
+
+	oval = snd_soc_read(codec, mc->reg) & mask;
+	ovalr = snd_soc_read(codec, mc->rreg) & mask;
+
+	ret = 0;
+	if (oval != val) {
+		ret = snd_soc_write(codec, mc->reg, val);
+		if (ret < 0)
+			return 0;
+		ret = 1;
+	}
+	if (ovalr != valr) {
+		ret = snd_soc_write(codec, mc->rreg, valr);
+		if (ret < 0)
+			return 0;
+		ret = 1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r_sx);
+
 /**
  * snd_soc_dai_set_sysclk - configure DAI system or master clock.
  * @dai: DAI

commit d11bb4a925613fa814ed4ae350440eb24ebff336
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Mon May 10 14:39:24 2010 +0300

    ASoC: core: Fix for the volume limiting when invert is in use
    
    If the register for the volume needs invert, than the inversion
    need to be done from the chip maximum, and not from the platform
    dependent limit.
    Introduce soc_mixer_control.platform_max value, which initially
    equals to chip maximum.
    The snd_soc_limit_volume function only modify the platform_max,
    all volsw_info call returns this as well.
    The .max value holds the chip default (maximum), and it is used
    for the inversion, if it is needed.
    
    Additional check in the volsw_info call has been added to check
    the validity of the platform_max in case, when custom macros
    used by codec drivers are not initializing it correctly.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 34f71bf60140..e1043f644730 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2017,18 +2017,22 @@ int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 {
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	int max = mc->max;
+	int platform_max;
 	unsigned int shift = mc->shift;
 	unsigned int rshift = mc->rshift;
 
-	if (max == 1 && !strstr(kcontrol->id.name, " Volume"))
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	if (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	else
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 
 	uinfo->count = shift == rshift ? 1 : 2;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = max;
+	uinfo->value.integer.max = platform_max;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
@@ -2126,16 +2130,20 @@ int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
 {
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	int max = mc->max;
+	int platform_max;
 
-	if (max == 1 && !strstr(kcontrol->id.name, " Volume"))
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	if (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	else
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 
 	uinfo->count = 2;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = max;
+	uinfo->value.integer.max = platform_max;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
@@ -2236,13 +2244,17 @@ int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
 {
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
-	int max = mc->max;
+	int platform_max;
 	int min = mc->min;
 
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = max-min;
+	uinfo->value.integer.max = platform_max - min;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw_s8);
@@ -2331,7 +2343,7 @@ int snd_soc_limit_volume(struct snd_soc_codec *codec,
 	if (found) {
 		mc = (struct soc_mixer_control *)kctl->private_value;
 		if (max <= mc->max) {
-			mc->max = max;
+			mc->platform_max = max;
 			ret = 0;
 		}
 	}

commit 3efab7dcc0f4d0087f73ff975eaa2fddc02ffc69
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun May 9 13:25:43 2010 +0100

    ASoC: Allow DAI links to be kept active over suspend
    
    As well as allowing DAPM pins to be marked as ignoring suspend allow DAI
    links to be similarly marked.  This is primarily intended for digital
    links between CODECs and non-CPU devices such as basebands in mobile
    phones and will suppress all suspend calls for the DAI link.  It is
    likely that this will need to be revisited if used with devices which
    are part of the SoC CPU.
    
    Tested-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8661e5b4adb1..34f71bf60140 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -893,19 +893,31 @@ static int soc_suspend(struct device *dev)
 	/* mute any active DAC's */
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
+
+		if (card->dai_link[i].ignore_suspend)
+			continue;
+
 		if (dai->ops->digital_mute && dai->playback.active)
 			dai->ops->digital_mute(dai, 1);
 	}
 
 	/* suspend all pcms */
-	for (i = 0; i < card->num_links; i++)
+	for (i = 0; i < card->num_links; i++) {
+		if (card->dai_link[i].ignore_suspend)
+			continue;
+
 		snd_pcm_suspend_all(card->dai_link[i].pcm);
+	}
 
 	if (card->suspend_pre)
 		card->suspend_pre(pdev, PMSG_SUSPEND);
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai  *cpu_dai = card->dai_link[i].cpu_dai;
+
+		if (card->dai_link[i].ignore_suspend)
+			continue;
+
 		if (cpu_dai->suspend && !cpu_dai->ac97_control)
 			cpu_dai->suspend(cpu_dai);
 		if (platform->suspend)
@@ -918,6 +930,10 @@ static int soc_suspend(struct device *dev)
 
 	for (i = 0; i < codec->num_dai; i++) {
 		char *stream = codec->dai[i].playback.stream_name;
+
+		if (card->dai_link[i].ignore_suspend)
+			continue;
+
 		if (stream != NULL)
 			snd_soc_dapm_stream_event(codec, stream,
 				SND_SOC_DAPM_STREAM_SUSPEND);
@@ -943,6 +959,10 @@ static int soc_suspend(struct device *dev)
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+
+		if (card->dai_link[i].ignore_suspend)
+			continue;
+
 		if (cpu_dai->suspend && cpu_dai->ac97_control)
 			cpu_dai->suspend(cpu_dai);
 	}
@@ -982,6 +1002,10 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+
+		if (card->dai_link[i].ignore_suspend)
+			continue;
+
 		if (cpu_dai->resume && cpu_dai->ac97_control)
 			cpu_dai->resume(cpu_dai);
 	}
@@ -1004,6 +1028,10 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	for (i = 0; i < codec->num_dai; i++) {
 		char *stream = codec->dai[i].playback.stream_name;
+
+		if (card->dai_link[i].ignore_suspend)
+			continue;
+
 		if (stream != NULL)
 			snd_soc_dapm_stream_event(codec, stream,
 				SND_SOC_DAPM_STREAM_RESUME);
@@ -1016,12 +1044,20 @@ static void soc_resume_deferred(struct work_struct *work)
 	/* unmute any active DACs */
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
+
+		if (card->dai_link[i].ignore_suspend)
+			continue;
+
 		if (dai->ops->digital_mute && dai->playback.active)
 			dai->ops->digital_mute(dai, 0);
 	}
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+
+		if (card->dai_link[i].ignore_suspend)
+			continue;
+
 		if (cpu_dai->resume && !cpu_dai->ac97_control)
 			cpu_dai->resume(cpu_dai);
 		if (platform->resume)

commit 1547aba993c990e5a316751431328145b38e1fea
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri May 7 21:11:40 2010 +0100

    ASoC: Support leaving paths enabled over system suspend
    
    Some devices can usefully run audio while the Linux system is suspended.
    One of the most common examples is smartphone systems, which are normally
    designed to allow audio to be run between the baseband and the CODEC
    without passing through the CPU and so can suspend the CPU when on a
    voice call for additional power savings.
    
    Support such systems by providing an API snd_soc_dapm_ignore_suspend().
    This can be used to mark DAPM endpoints as not being sensitive to
    system suspend. When the system is being suspended paths between
    endpoints which are marked as ignoring suspend will be kept active.
    Both source and sink must be marked, and there must already be an
    active path between the two endpoints prior to suspend.
    
    When paths are active over suspend the bias management will hold the
    device bias in the ON state. This is used to avoid suspending the
    CODEC while it is still in use.
    
    Tested-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 95739767ec45..8661e5b4adb1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -927,8 +927,19 @@ static int soc_suspend(struct device *dev)
 				SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
-	if (codec_dev->suspend)
-		codec_dev->suspend(pdev, PMSG_SUSPEND);
+	/* If there are paths active then the CODEC will be held with
+	 * bias _ON and should not be suspended. */
+	if (codec_dev->suspend) {
+		switch (codec->bias_level) {
+		case SND_SOC_BIAS_STANDBY:
+		case SND_SOC_BIAS_OFF:
+			codec_dev->suspend(pdev, PMSG_SUSPEND);
+			break;
+		default:
+			dev_dbg(socdev->dev, "CODEC is on over suspend\n");
+			break;
+		}
+	}
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
@@ -975,8 +986,21 @@ static void soc_resume_deferred(struct work_struct *work)
 			cpu_dai->resume(cpu_dai);
 	}
 
-	if (codec_dev->resume)
-		codec_dev->resume(pdev);
+	/* If the CODEC was idle over suspend then it will have been
+	 * left with bias OFF or STANDBY and suspended so we must now
+	 * resume.  Otherwise the suspend was suppressed.
+	 */
+	if (codec_dev->resume) {
+		switch (codec->bias_level) {
+		case SND_SOC_BIAS_STANDBY:
+		case SND_SOC_BIAS_OFF:
+			codec_dev->resume(pdev);
+			break;
+		default:
+			dev_dbg(socdev->dev, "CODEC was on over suspend\n");
+			break;
+		}
+	}
 
 	for (i = 0; i < codec->num_dai; i++) {
 		char *stream = codec->dai[i].playback.stream_name;

commit 9949788b793826f2d19e929ac0219ad0e0891e2d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri May 7 20:24:05 2010 +0100

    ASoC: Refactor DAPM suspend handling
    
    Instead of using stream events to handle power down during suspend
    integrate the handling with the normal widget path checking by
    replacing all cases where we report a connected endpoint in a path
    with a function snd_soc_dapm_suspend_check() which looks at the ALSA
    power state for the card and reports false if we are in a D3 state.
    
    Since the core moves us into D3 prior to initating the suspend all
    power checks during suspend will cause the widgets to be powered
    down. In order to ensure that widgets are powered up on resume set
    the card to D2 at the start of resume handling (ALSA API calls
    require D0 so we are still protected against userspace access).
    
    Tested-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4079223203eb..95739767ec45 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -963,6 +963,9 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	dev_dbg(socdev->dev, "starting resume work\n");
 
+	/* Bring us up into D2 so that DAPM starts enabling things */
+	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D2);
+
 	if (card->resume_pre)
 		card->resume_pre(pdev);
 

commit 637d3847ba0ca2c7780e6521cbe75568d19ff0db
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Fri May 7 14:05:49 2010 +0300

    ASoC: core: Support for limiting the volume
    
    Add support for the core to limit the maximum volume on an
    existing control.
    The function will modify the soc_mixer_control.max value
    of the given control.
    The new value must be lower than the original one (chip maximum)
    
    If there is a need for limiting a gain on a given control,
    than machine drivers can do the following in their
    snd_soc_dai_link.init function:
    
    snd_soc_limit_volume(codec, "TPA6140A2 Headphone Playback Volume", 21);
    
    This will modify the original 31 (chip maximum) to 21, so user
    space will not be able to set the gain higher than this.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d59076e2ca84..4079223203eb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2237,6 +2237,45 @@ int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 
+/**
+ * snd_soc_limit_volume - Set new limit to an existing volume control.
+ *
+ * @codec: where to look for the control
+ * @name: Name of the control
+ * @max: new maximum limit
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_limit_volume(struct snd_soc_codec *codec,
+	const char *name, int max)
+{
+	struct snd_card *card = codec->card;
+	struct snd_kcontrol *kctl;
+	struct soc_mixer_control *mc;
+	int found = 0;
+	int ret = -EINVAL;
+
+	/* Sanity check for name and max */
+	if (unlikely(!name || max <= 0))
+		return -EINVAL;
+
+	list_for_each_entry(kctl, &card->controls, list) {
+		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name))) {
+			found = 1;
+			break;
+		}
+	}
+	if (found) {
+		mc = (struct soc_mixer_control *)kctl->private_value;
+		if (max <= mc->max) {
+			mc->max = max;
+			ret = 0;
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_limit_volume);
+
 /**
  * snd_soc_dai_set_sysclk - configure DAI system or master clock.
  * @dai: DAI

commit 84db18bbeb5c9c1a9c86e38a89d76ee526fd2c6f
Merge: 6948ec70355a 55b371d4ac5e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 7 08:42:25 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6:
      ALSA: mixart: range checking proc file
      ALSA: hda - Fix a wrong array range check in patch_realtek.c
      ALSA: ASoC: move dma_data from snd_soc_dai to snd_soc_pcm_stream
      ALSA: hda - Enable amplifiers on Acer Inspire 6530G
      ASoC: Only do WM8994 bias off transition from standby
      ASoC: Don't use DCS_DATAPATH_BUSY for WM hubs devices
      ASoC: Don't do runtime wm_hubs DC servo updates if using offset correction
      ASoC: Support second DC servo readback method for wm_hubs
      ASoC: Avoid wraparound in wm_hubs DC servo correction
      ALSA: echoaudio - Eliminate use after free
      ALSA: i2c: cleanup: change parameter to pointer
      ALSA: hda - Add MSI blacklist for Aopen MZ915-M
      ASoC: OMAP: Fix capture pointer handling for OMAP1510 to work correctly with recent ALSA PCM code
      ALSA: hda - Update document about MSI and interrupts
      ALSA: hda: Fix 0 dB offset for Lenovo Thinkpad models using AD1981
      ALSA: hda - Add missing printk argument in previous patch
      ASoC: Fix passing platform_data to ac97 bus users and fix a leak
      ALSA: hda - Fix ADC/MUX assignment of ALC269 codec
      ALSA: hda - Fix invalid bit values passed to snd_hda_codec_amp_stereo()
      ASoC: wm8994: playback => capture

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c8b0556ef431..2320153bd923 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -28,6 +28,7 @@
 #include <linux/bitops.h>
 #include <linux/debugfs.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
 #include <sound/ac97_codec.h>
 #include <sound/core.h>
 #include <sound/pcm.h>

commit 2c9504228fe4e4cc65f3debf6d2a6a0f44cf4c2d
Merge: 9dd7b79a86c5 fb48e3c6a4d8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Mar 29 21:03:20 2010 +0100

    Merge branch 'for-2.6.34' into for-2.6.35

commit fb48e3c6a4d8888aff61fbf567aadac7d206e973
Author: Graham Gower <graham.gower@gmail.com>
Date:   Thu Mar 25 10:52:12 2010 +1030

    ASoC: Fix passing platform_data to ac97 bus users and fix a leak
    
    [The issue is an attempt to write the pdata without the AC97 device
    allocated when using ac97.c - also added a comment in soc-core.c for the
    special case for ac97. -- broonie]
    
    Signed-off-by: Graham Gower <graham.gower@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c8b0556ef431..d0efd5eaaa0b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1548,7 +1548,8 @@ int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 			mutex_unlock(&codec->mutex);
 			return ret;
 		}
-		if (card->dai_link[i].codec_dai->ac97_control) {
+		/* Check for codec->ac97 to handle the ac97.c fun */
+		if (card->dai_link[i].codec_dai->ac97_control && codec->ac97) {
 			snd_ac97_dev_add_pdata(codec->ac97,
 				card->dai_link[i].cpu_dai->ac97_pdata);
 		}

commit b2dfa62c525fbe4d89790b6fa90af7c3f1c052ae
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Thu Mar 18 08:23:33 2010 +0100

    ASoC: remove a card from the list, if instantiation failed
    
    If instantiation of a card failed, we still have to remove it from the
    card list on unregistration. This fixes an Oops on Migo-R, triggering,
    when after a failed firmware load attempt the driver modules are removed
    and re-inserted again.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index eb73aab78b94..1ff553bbc063 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1283,26 +1283,25 @@ static int soc_remove(struct platform_device *pdev)
 	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
-	if (!card->instantiated)
-		return 0;
+	if (card->instantiated) {
+		run_delayed_work(&card->delayed_work);
 
-	run_delayed_work(&card->delayed_work);
+		if (platform->remove)
+			platform->remove(pdev);
 
-	if (platform->remove)
-		platform->remove(pdev);
+		if (codec_dev->remove)
+			codec_dev->remove(pdev);
 
-	if (codec_dev->remove)
-		codec_dev->remove(pdev);
+		for (i = 0; i < card->num_links; i++) {
+			struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+			if (cpu_dai->remove)
+				cpu_dai->remove(pdev, cpu_dai);
+		}
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->remove)
-			cpu_dai->remove(pdev, cpu_dai);
+		if (card->remove)
+			card->remove(pdev);
 	}
 
-	if (card->remove)
-		card->remove(pdev);
-
 	snd_soc_unregister_card(card);
 
 	return 0;

commit d9ad6296ec3b4a55ba25f2c5e4824be487242e1f
Author: Jassi Brar <jassi.brar@samsung.com>
Date:   Fri Mar 12 13:38:52 2010 +0900

    ASoC: PCM_RATE: Check for KNOT and CONTINUOUS flags
    
    For ASoC, if either CPU or CODEC driver has set the flag, the MACHINE driver
    should be given a chance to figure out if the dai, that set the flag, can
    accomodate a rate that it does not explicitly specify but is specified
    by the dai at the other end of the link.
    
    Signed-off-by: Jassi Brar <jassi.brar@samsung.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 06c38d1502b7..eb73aab78b94 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -404,6 +404,12 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 			codec_dai->playback.formats & cpu_dai->playback.formats;
 		runtime->hw.rates =
 			codec_dai->playback.rates & cpu_dai->playback.rates;
+		if (codec_dai->playback.rates
+			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
+			runtime->hw.rates |= cpu_dai->playback.rates;
+		if (cpu_dai->playback.rates
+			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
+			runtime->hw.rates |= codec_dai->playback.rates;
 	} else {
 		runtime->hw.rate_min =
 			max(codec_dai->capture.rate_min,
@@ -421,6 +427,12 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 			codec_dai->capture.formats & cpu_dai->capture.formats;
 		runtime->hw.rates =
 			codec_dai->capture.rates & cpu_dai->capture.rates;
+		if (codec_dai->capture.rates
+			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
+			runtime->hw.rates |= cpu_dai->capture.rates;
+		if (cpu_dai->capture.rates
+			   & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))
+			runtime->hw.rates |= codec_dai->capture.rates;
 	}
 
 	snd_pcm_limit_hw_rates(runtime);

commit fad837c16cdd856c68ce2e1335ad0fe836ed8ecd
Merge: 51c6ab130642 57d54889cd00
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 10 15:02:37 2010 +0000

    Merge commit 'v2.6.34-rc1' into for-2.6.35

commit bb1c04784d39b95a4382bd283f3048c4eb859b58
Author: Jassi Brar <jassi.brar@samsung.com>
Date:   Thu Feb 25 11:24:53 2010 +0900

    ASoC: soc_pcm_open: Add missing bailout tag
    
    The codec_dai needs to be shutdown should the machine startup fails.
    This patch adds another bailout tag for that case and rename the tag
    for configuration failures.
    
    Signed-off-by: Jassi Brar <jassi.brar@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a03bac943aaf..c8b0556ef431 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -427,24 +427,24 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	if (!runtime->hw.rates) {
 		printk(KERN_ERR "asoc: %s <-> %s No matching rates\n",
 			codec_dai->name, cpu_dai->name);
-		goto machine_err;
+		goto config_err;
 	}
 	if (!runtime->hw.formats) {
 		printk(KERN_ERR "asoc: %s <-> %s No matching formats\n",
 			codec_dai->name, cpu_dai->name);
-		goto machine_err;
+		goto config_err;
 	}
 	if (!runtime->hw.channels_min || !runtime->hw.channels_max) {
 		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",
 			codec_dai->name, cpu_dai->name);
-		goto machine_err;
+		goto config_err;
 	}
 
 	/* Symmetry only applies if we've already got an active stream. */
 	if (cpu_dai->active || codec_dai->active) {
 		ret = soc_pcm_apply_symmetry(substream);
 		if (ret != 0)
-			goto machine_err;
+			goto config_err;
 	}
 
 	pr_debug("asoc: %s <-> %s info:\n", codec_dai->name, cpu_dai->name);
@@ -464,10 +464,14 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	mutex_unlock(&pcm_mutex);
 	return 0;
 
-machine_err:
+config_err:
 	if (machine->ops && machine->ops->shutdown)
 		machine->ops->shutdown(substream);
 
+machine_err:
+	if (codec_dai->ops->shutdown)
+		codec_dai->ops->shutdown(substream, codec_dai);
+
 codec_dai_err:
 	if (platform->pcm_ops->close)
 		platform->pcm_ops->close(substream);

commit 258020d0882e89c1462800a70eb414b8a4fec78c
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Wed Mar 3 15:08:07 2010 +0200

    ASoC: core: Add delay operation to snd_soc_dai_ops
    
    The delay callback can be used by the core to query the delay
    on the dai caused by FIFO or delay in the platform side.
    In case if both CPU and CODEC dai has FIFO the delay reported
    by each will be added to form the full delay on the chain.
    If none of the dai has FIFO, than the delay will be kept as
    zero.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index feb572c616cd..4011ad3dc57a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -802,6 +802,8 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 
 /*
  * soc level wrapper for pointer callback
+ * If cpu_dai, codec_dai, platform driver has the delay callback, than
+ * the runtime->delay will be updated accordingly.
  */
 static snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)
 {
@@ -809,11 +811,27 @@ static snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_platform *platform = card->platform;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_uframes_t offset = 0;
+	snd_pcm_sframes_t delay = 0;
 
 	if (platform->pcm_ops->pointer)
 		offset = platform->pcm_ops->pointer(substream);
 
+	if (cpu_dai->ops->delay)
+		delay += cpu_dai->ops->delay(substream, cpu_dai);
+
+	if (codec_dai->ops->delay)
+		delay += codec_dai->ops->delay(substream, codec_dai);
+
+	if (platform->delay)
+		delay += platform->delay(substream, codec_dai);
+
+	runtime->delay = delay;
+
 	return offset;
 }
 

commit 377b6f62effcb91c53cd7ff8709a94d72d23b6ae
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Wed Mar 3 15:08:06 2010 +0200

    ASoC: core: soc level wrapper for pcm_pointer callback
    
    Create a soc level wrapper for pcm_pointer callback.
    This will facilitate the soc level handling of different
    HW buffers in the audio path.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7b4179eca893..feb572c616cd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -800,6 +800,23 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	return 0;
 }
 
+/*
+ * soc level wrapper for pointer callback
+ */
+static snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_platform *platform = card->platform;
+	snd_pcm_uframes_t offset = 0;
+
+	if (platform->pcm_ops->pointer)
+		offset = platform->pcm_ops->pointer(substream);
+
+	return offset;
+}
+
 /* ASoC PCM operations */
 static struct snd_pcm_ops soc_pcm_ops = {
 	.open		= soc_pcm_open,
@@ -808,6 +825,7 @@ static struct snd_pcm_ops soc_pcm_ops = {
 	.hw_free	= soc_pcm_hw_free,
 	.prepare	= soc_pcm_prepare,
 	.trigger	= soc_pcm_trigger,
+	.pointer	= soc_pcm_pointer,
 };
 
 #ifdef CONFIG_PM
@@ -1328,7 +1346,6 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	dai_link->pcm = pcm;
 	pcm->private_data = rtd;
 	soc_pcm_ops.mmap = platform->pcm_ops->mmap;
-	soc_pcm_ops.pointer = platform->pcm_ops->pointer;
 	soc_pcm_ops.ioctl = platform->pcm_ops->ioctl;
 	soc_pcm_ops.copy = platform->pcm_ops->copy;
 	soc_pcm_ops.silence = platform->pcm_ops->silence;

commit 50831450503b828b3f8c031aa664340062afb3b0
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Wed Mar 3 15:08:04 2010 +0200

    ASoC: core: fix tailing whitespace in soc_pcm_apply_symmetry
    
    My editor removes the tailing spaces, which causes problems when
    changing the soc-core.c
    Removing the space.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f30959cc954a..7b4179eca893 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -315,7 +315,7 @@ static int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream)
 
 	if (codec_dai->symmetric_rates || cpu_dai->symmetric_rates ||
 	    machine->symmetric_rates) {
-		dev_dbg(card->dev, "Symmetry forces %dHz rate\n", 
+		dev_dbg(card->dev, "Symmetry forces %dHz rate\n",
 			machine->rate);
 
 		ret = snd_pcm_hw_constraint_minmax(substream->runtime,

commit 14dc5734bdac2629ed4228f3d30662bb440a3982
Author: Jassi Brar <jassi.brar@samsung.com>
Date:   Fri Feb 26 09:12:32 2010 +0900

    ASoC: Allow mulitple usage count of codec and cpu dai
    
    If we are to have a snd_soc_dai i.e, cpu_dai and codec_dai, shared among two
    or more dai_links we need to log the number of active users of the dai.
    For that, we change semantics of the snd_soc_dai.active flag from indicator
    to reference counter.
    
    Signed-off-by: Jassi Brar <jassi.brar@samsung.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1215a0ec2df0..f30959cc954a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -454,11 +454,15 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	pr_debug("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
 		 runtime->hw.rate_max);
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		cpu_dai->playback.active = codec_dai->playback.active = 1;
-	else
-		cpu_dai->capture.active = codec_dai->capture.active = 1;
-	cpu_dai->active = codec_dai->active = 1;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		cpu_dai->playback.active++;
+		codec_dai->playback.active++;
+	} else {
+		cpu_dai->capture.active++;
+		codec_dai->capture.active++;
+	}
+	cpu_dai->active++;
+	codec_dai->active++;
 	card->codec->active++;
 	mutex_unlock(&pcm_mutex);
 	return 0;
@@ -530,15 +534,16 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 
 	mutex_lock(&pcm_mutex);
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		cpu_dai->playback.active = codec_dai->playback.active = 0;
-	else
-		cpu_dai->capture.active = codec_dai->capture.active = 0;
-
-	if (codec_dai->playback.active == 0 &&
-		codec_dai->capture.active == 0) {
-		cpu_dai->active = codec_dai->active = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		cpu_dai->playback.active--;
+		codec_dai->playback.active--;
+	} else {
+		cpu_dai->capture.active--;
+		codec_dai->capture.active--;
 	}
+
+	cpu_dai->active--;
+	codec_dai->active--;
 	codec->active--;
 
 	/* Muting the DAC suppresses artifacts caused during digital

commit b9dd94a87e5b4d0e864636698931aeeeb3c9d770
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Mon Feb 22 13:27:13 2010 +0200

    ASoC: core: On resume also check the soc device state
    
    Check the card->codec on soc_resume to detect if the soc
    device is properly initialized.
    If the card->codec is NULL, than do not continue the resume
    operation, since the device is not initialized properly.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e1c0336868e1..a03bac943aaf 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -963,6 +963,12 @@ static int soc_resume(struct device *dev)
 	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_dai *cpu_dai = card->dai_link[0].cpu_dai;
 
+	/* If the initialization of this soc device failed, there is no codec
+	 * associated with it. Just bail out in this case.
+	 */
+	if (!card->codec)
+		return 0;
+
 	/* AC97 devices might have other drivers hanging off them so
 	 * need to resume immediately.  Other drivers don't have that
 	 * problem and may take a substantial amount of time to resume

commit 6423c1875c87fa5ae56974ab8386d7c6110e3701
Author: jassi brar <jassisinghbrar@gmail.com>
Date:   Mon Feb 22 16:00:20 2010 +0900

    ASoC: Remove runtime field from DAI
    
    In order for having snd_soc_dais shared among two or more dai_links,
    remove the relatively global runtime field from the struct snd_soc_dai
    
    Signed-off-by: Jassi Brar <jassi.brar@samsung.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 524a85a73aca..1215a0ec2df0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -459,7 +459,6 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	else
 		cpu_dai->capture.active = codec_dai->capture.active = 1;
 	cpu_dai->active = codec_dai->active = 1;
-	cpu_dai->runtime = runtime;
 	card->codec->active++;
 	mutex_unlock(&pcm_mutex);
 	return 0;
@@ -559,7 +558,6 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 
 	if (platform->pcm_ops->close)
 		platform->pcm_ops->close(substream);
-	cpu_dai->runtime = NULL;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* start delayed pop wq here for playback streams */

commit d273ebe77a780d3aba1f5b86615af3b0e87b76bf
Author: jassi brar <jassisinghbrar@gmail.com>
Date:   Mon Feb 22 15:58:04 2010 +0900

    ASoC: Pass dai_link as argument to platform suspend and resume
    
    Passing pointer to relevant dai_link provides easier reach to the
    ASoC tree in suspend/resume of snd_soc_platform. It also provides
    direct access to the dai at the other end of the dai_link.
    
    Signed-off-by: Jassi Brar <jassi.brar@samsung.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e1c0336868e1..524a85a73aca 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -854,7 +854,7 @@ static int soc_suspend(struct device *dev)
 		if (cpu_dai->suspend && !cpu_dai->ac97_control)
 			cpu_dai->suspend(cpu_dai);
 		if (platform->suspend)
-			platform->suspend(cpu_dai);
+			platform->suspend(&card->dai_link[i]);
 	}
 
 	/* close any waiting streams and save state */
@@ -943,7 +943,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		if (cpu_dai->resume && !cpu_dai->ac97_control)
 			cpu_dai->resume(cpu_dai);
 		if (platform->resume)
-			platform->resume(cpu_dai);
+			platform->resume(&card->dai_link[i]);
 	}
 
 	if (card->resume_post)

commit 6c5f1fed49f96a0600aa9a97ac3faf972c33a341
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Feb 17 14:30:44 2010 +0000

    ASoC: Make pmdown_time a long
    
    Fixes a warning.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c2008bc9c64a..e1c0336868e1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -136,7 +136,7 @@ static ssize_t pmdown_time_show(struct device *dev,
 	struct snd_soc_device *socdev = dev_get_drvdata(dev);
 	struct snd_soc_card *card = socdev->card;
 
-	return sprintf(buf, "%d\n", card->pmdown_time);
+	return sprintf(buf, "%ld\n", card->pmdown_time);
 }
 
 static ssize_t pmdown_time_set(struct device *dev,

commit dbe21408b15f04da4f80fb89a27b7cb067d6103e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Feb 12 11:37:24 2010 +0000

    ASoC: Make pmdown_time runtime configurable
    
    Provide a sysfs file allowing userspace to inspect and change the
    pmdown_time setting at runtime.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 94b9cde26139..c2008bc9c64a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -130,6 +130,29 @@ static ssize_t codec_reg_show(struct device *dev,
 
 static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
 
+static ssize_t pmdown_time_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *socdev = dev_get_drvdata(dev);
+	struct snd_soc_card *card = socdev->card;
+
+	return sprintf(buf, "%d\n", card->pmdown_time);
+}
+
+static ssize_t pmdown_time_set(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct snd_soc_device *socdev = dev_get_drvdata(dev);
+	struct snd_soc_card *card = socdev->card;
+
+	strict_strtol(buf, 10, &card->pmdown_time);
+
+	return count;
+}
+
+static DEVICE_ATTR(pmdown_time, 0644, pmdown_time_show, pmdown_time_set);
+
 #ifdef CONFIG_DEBUG_FS
 static int codec_reg_open_file(struct inode *inode, struct file *file)
 {
@@ -1124,6 +1147,10 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	if (ret < 0)
 		printk(KERN_WARNING "asoc: failed to add dapm sysfs entries\n");
 
+	ret = device_create_file(card->socdev->dev, &dev_attr_pmdown_time);
+	if (ret < 0)
+		printk(KERN_WARNING "asoc: failed to add pmdown_time sysfs\n");
+
 	ret = device_create_file(card->socdev->dev, &dev_attr_codec_reg);
 	if (ret < 0)
 		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");

commit 96dd362284ddcb546d2783035ae7eeda73692eda
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Feb 12 11:05:44 2010 +0000

    ASoC: Make pmdown_time a per-card setting
    
    Make the pmdown_time a per-card setting rather than a global one,
    initialised before the card initialisation runs. This allows cards
    to override the default setting if it makes sense to do so (for
    example, due to an unavoidable pop).
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ca89c782132d..94b9cde26139 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -542,7 +542,7 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 		/* start delayed pop wq here for playback streams */
 		codec_dai->pop_wait = 1;
 		schedule_delayed_work(&card->delayed_work,
-			msecs_to_jiffies(pmdown_time));
+			msecs_to_jiffies(card->pmdown_time));
 	} else {
 		/* capture streams can be powered down now */
 		snd_soc_dapm_stream_event(codec,
@@ -1039,6 +1039,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	dev_dbg(card->dev, "All components present, instantiating\n");
 
 	/* Found everything, bring it up */
+	card->pmdown_time = pmdown_time;
+
 	if (card->probe) {
 		ret = card->probe(pdev);
 		if (ret < 0)

commit 2718625fba1e07bf2ce8a752036658737c1f76a7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jan 28 12:36:29 2010 +0000

    ASoC: Set codec->dev for AC97 devices
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9085b40fa04b..ca89c782132d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1368,6 +1368,7 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 
 	codec->ac97->bus->ops = ops;
 	codec->ac97->num = num;
+	codec->dev = &codec->ac97->dev;
 	mutex_unlock(&codec->mutex);
 	return 0;
 }

commit 163849ea9b4c5d50fbd324692461983d18faadad
Merge: 2138301e1687 5ee518ecbcb5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 12 12:59:05 2010 +0000

    Merge branch 'for-2.6.33' into for-2.6.34

commit 40ca114265a281d51b261771df551a373fc8ff3c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 24 13:44:28 2009 +0000

    ASoC: Use snprintf() when generating stream names
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8b900a842677..9b36c5eec75c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1276,8 +1276,8 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	codec_dai->codec = card->codec;
 
 	/* check client and interface hw capabilities */
-	sprintf(new_name, "%s %s-%d", dai_link->stream_name, codec_dai->name,
-		num);
+	snprintf(new_name, sizeof(new_name), "%s %s-%d",
+		 dai_link->stream_name, codec_dai->name, num);
 
 	if (codec_dai->playback.channels_min)
 		playback = 1;

commit 471452104b8520337ae2fb48c4e61cd4896e025d
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Dec 14 18:00:08 2009 -0800

    const: constify remaining dev_pm_ops
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ef8f28284cb9..0a6440c6f54a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1236,7 +1236,7 @@ static int soc_poweroff(struct device *dev)
 	return 0;
 }
 
-static struct dev_pm_ops soc_pm_ops = {
+static const struct dev_pm_ops soc_pm_ops = {
 	.suspend = soc_suspend,
 	.resume = soc_resume,
 	.poweroff = soc_poweroff,

commit dd1b3d53c2e5b9cccec9001fc0b63f6b686a4ac9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Dec 4 14:22:03 2009 +0000

    ASoC: Export snd_soc_update_bits_unlocked()
    
    Allows custom controls to use it.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ef8f28284cb9..8b900a842677 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1427,9 +1427,9 @@ EXPORT_SYMBOL_GPL(snd_soc_update_bits);
  *
  * Returns 1 for change else 0.
  */
-static int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
-				unsigned short reg, unsigned int mask,
-				unsigned int value)
+int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
+			       unsigned short reg, unsigned int mask,
+			       unsigned int value)
 {
 	int change;
 
@@ -1439,6 +1439,7 @@ static int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
 
 	return change;
 }
+EXPORT_SYMBOL_GPL(snd_soc_update_bits_locked);
 
 /**
  * snd_soc_test_bits - test register for change

commit f773205300fa4a5a405f8ed6e3bb97e46c6eefb4
Author: Barry Song <21cnbao@gmail.com>
Date:   Thu Nov 12 12:01:47 2009 +0800

    ASoC: move setting ac97 platformdata earlier than ac97 read/write
    
    While probing, AC97 codec drivers and soc-core generically execute the
    following sequence:
    snd_soc_new_ac97_codec -> snd_soc_new_pcms -> reset ac-link/read AC97 ID
    to detect ->...  -> set platform_data to ac97 by soc-core
    
    commit 474828a40f6ddab6e2a3475a19c5c84aa3ec7d60 adds platform_data to
    snd_ac97 instance. But ac97 platform data hasn't given to snd_ac97
    before actual ac97 operations. Then while ac97_read access platform_data
    of snd_ac97 for detecting, NULL pointer oops will fire. That means old
    platform_data patch doesn't work in real-life cases.
    
    This patch moves the operation of setting ac97 platform_data earlier
    than ac97 reading/writing operations. Then it makes platform_data of
    AC97 become practically useful.
    
    Signed-off-by: Barry Song <21cnbao@gmail.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e2b6d75f16e3..ef8f28284cb9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1083,11 +1083,8 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 				continue;
 			}
 		}
-		if (card->dai_link[i].codec_dai->ac97_control) {
+		if (card->dai_link[i].codec_dai->ac97_control)
 			ac97 = 1;
-			snd_ac97_dev_add_pdata(codec->ac97,
-				card->dai_link[i].cpu_dai->ac97_pdata);
-		}
 	}
 
 	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
@@ -1510,6 +1507,10 @@ int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 			mutex_unlock(&codec->mutex);
 			return ret;
 		}
+		if (card->dai_link[i].codec_dai->ac97_control) {
+			snd_ac97_dev_add_pdata(codec->ac97,
+				card->dai_link[i].cpu_dai->ac97_pdata);
+		}
 	}
 
 	mutex_unlock(&codec->mutex);

commit fe3e78e073d25308756f38019956061153267769
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 3 22:13:13 2009 +0000

    ASoC: Factor out snd_soc_init_card()
    
    snd_soc_init_card() is always called as the last part of the CODEC probe
    function so we can factor it out into the core card setup rather than
    have each CODEC replicate the code to do the initialiastation. This will
    be required to support multiple CODECs per card.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d81a16187769..e2b6d75f16e3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -970,6 +970,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 						    struct platform_device,
 						    dev);
 	struct snd_soc_codec_device *codec_dev = card->socdev->codec_dev;
+	struct snd_soc_codec *codec;
 	struct snd_soc_platform *platform;
 	struct snd_soc_dai *dai;
 	int i, found, ret, ac97;
@@ -1058,6 +1059,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		if (ret < 0)
 			goto cpu_dai_err;
 	}
+	codec = card->codec;
 
 	if (platform->probe) {
 		ret = platform->probe(pdev);
@@ -1072,10 +1074,72 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
 #endif
 
+	for (i = 0; i < card->num_links; i++) {
+		if (card->dai_link[i].init) {
+			ret = card->dai_link[i].init(codec);
+			if (ret < 0) {
+				printk(KERN_ERR "asoc: failed to init %s\n",
+					card->dai_link[i].stream_name);
+				continue;
+			}
+		}
+		if (card->dai_link[i].codec_dai->ac97_control) {
+			ac97 = 1;
+			snd_ac97_dev_add_pdata(codec->ac97,
+				card->dai_link[i].cpu_dai->ac97_pdata);
+		}
+	}
+
+	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
+		 "%s",  card->name);
+	snprintf(codec->card->longname, sizeof(codec->card->longname),
+		 "%s (%s)", card->name, codec->name);
+
+	/* Make sure all DAPM widgets are instantiated */
+	snd_soc_dapm_new_widgets(codec);
+
+	ret = snd_card_register(codec->card);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: failed to register soundcard for %s\n",
+				codec->name);
+		goto card_err;
+	}
+
+	mutex_lock(&codec->mutex);
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	/* Only instantiate AC97 if not already done by the adaptor
+	 * for the generic AC97 subsystem.
+	 */
+	if (ac97 && strcmp(codec->name, "AC97") != 0) {
+		ret = soc_ac97_dev_register(codec);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: AC97 device register failed\n");
+			snd_card_free(codec->card);
+			mutex_unlock(&codec->mutex);
+			goto card_err;
+		}
+	}
+#endif
+
+	ret = snd_soc_dapm_sys_add(card->socdev->dev);
+	if (ret < 0)
+		printk(KERN_WARNING "asoc: failed to add dapm sysfs entries\n");
+
+	ret = device_create_file(card->socdev->dev, &dev_attr_codec_reg);
+	if (ret < 0)
+		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
+
+	soc_init_codec_debugfs(codec);
+	mutex_unlock(&codec->mutex);
+
 	card->instantiated = 1;
 
 	return;
 
+card_err:
+	if (platform->remove)
+		platform->remove(pdev);
+
 platform_err:
 	if (codec_dev->remove)
 		codec_dev->remove(pdev);
@@ -1453,83 +1517,6 @@ int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 }
 EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
 
-/**
- * snd_soc_init_card - register sound card
- * @socdev: the SoC audio device
- *
- * Register a SoC sound card. Also registers an AC97 device if the
- * codec is AC97 for ad hoc devices.
- *
- * Returns 0 for success, else error.
- */
-int snd_soc_init_card(struct snd_soc_device *socdev)
-{
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_codec *codec = card->codec;
-	int ret = 0, i, ac97 = 0, err = 0;
-
-	for (i = 0; i < card->num_links; i++) {
-		if (card->dai_link[i].init) {
-			err = card->dai_link[i].init(codec);
-			if (err < 0) {
-				printk(KERN_ERR "asoc: failed to init %s\n",
-					card->dai_link[i].stream_name);
-				continue;
-			}
-		}
-		if (card->dai_link[i].codec_dai->ac97_control) {
-			ac97 = 1;
-			snd_ac97_dev_add_pdata(codec->ac97,
-				card->dai_link[i].cpu_dai->ac97_pdata);
-		}
-	}
-	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
-		 "%s",  card->name);
-	snprintf(codec->card->longname, sizeof(codec->card->longname),
-		 "%s (%s)", card->name, codec->name);
-
-	/* Make sure all DAPM widgets are instantiated */
-	snd_soc_dapm_new_widgets(codec);
-
-	ret = snd_card_register(codec->card);
-	if (ret < 0) {
-		printk(KERN_ERR "asoc: failed to register soundcard for %s\n",
-				codec->name);
-		goto out;
-	}
-
-	mutex_lock(&codec->mutex);
-#ifdef CONFIG_SND_SOC_AC97_BUS
-	/* Only instantiate AC97 if not already done by the adaptor
-	 * for the generic AC97 subsystem.
-	 */
-	if (ac97 && strcmp(codec->name, "AC97") != 0) {
-		ret = soc_ac97_dev_register(codec);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: AC97 device register failed\n");
-			snd_card_free(codec->card);
-			mutex_unlock(&codec->mutex);
-			goto out;
-		}
-	}
-#endif
-
-	err = snd_soc_dapm_sys_add(socdev->dev);
-	if (err < 0)
-		printk(KERN_WARNING "asoc: failed to add dapm sysfs entries\n");
-
-	err = device_create_file(socdev->dev, &dev_attr_codec_reg);
-	if (err < 0)
-		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
-
-	soc_init_codec_debugfs(codec);
-	mutex_unlock(&codec->mutex);
-
-out:
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_init_card);
-
 /**
  * snd_soc_free_pcms - free sound card and pcms
  * @socdev: the SoC audio device

commit 2624d5fa67a5d3d720613a4ab0672e8c387ba806
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 3 21:56:13 2009 +0000

    ASoC: Move sysfs and debugfs functions to head of soc-core.c
    
    A fairly hefty change in diff terms but no actual code changes, will be
    used by the next commit.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6e24654194ee..d81a16187769 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -80,6 +80,173 @@ static int run_delayed_work(struct delayed_work *dwork)
 	return ret;
 }
 
+/* codec register dump */
+static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
+{
+	int i, step = 1, count = 0;
+
+	if (!codec->reg_cache_size)
+		return 0;
+
+	if (codec->reg_cache_step)
+		step = codec->reg_cache_step;
+
+	count += sprintf(buf, "%s registers\n", codec->name);
+	for (i = 0; i < codec->reg_cache_size; i += step) {
+		if (codec->readable_register && !codec->readable_register(i))
+			continue;
+
+		count += sprintf(buf + count, "%2x: ", i);
+		if (count >= PAGE_SIZE - 1)
+			break;
+
+		if (codec->display_register)
+			count += codec->display_register(codec, buf + count,
+							 PAGE_SIZE - count, i);
+		else
+			count += snprintf(buf + count, PAGE_SIZE - count,
+					  "%4x", codec->read(codec, i));
+
+		if (count >= PAGE_SIZE - 1)
+			break;
+
+		count += snprintf(buf + count, PAGE_SIZE - count, "\n");
+		if (count >= PAGE_SIZE - 1)
+			break;
+	}
+
+	/* Truncate count; min() would cause a warning */
+	if (count >= PAGE_SIZE)
+		count = PAGE_SIZE - 1;
+
+	return count;
+}
+static ssize_t codec_reg_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
+	return soc_codec_reg_show(devdata->card->codec, buf);
+}
+
+static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
+
+#ifdef CONFIG_DEBUG_FS
+static int codec_reg_open_file(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	struct snd_soc_codec *codec = file->private_data;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	ret = soc_codec_reg_show(codec, buf);
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+	return ret;
+}
+
+static ssize_t codec_reg_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[32];
+	int buf_size;
+	char *start = buf;
+	unsigned long reg, value;
+	int step = 1;
+	struct snd_soc_codec *codec = file->private_data;
+
+	buf_size = min(count, (sizeof(buf)-1));
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+
+	if (codec->reg_cache_step)
+		step = codec->reg_cache_step;
+
+	while (*start == ' ')
+		start++;
+	reg = simple_strtoul(start, &start, 16);
+	if ((reg >= codec->reg_cache_size) || (reg % step))
+		return -EINVAL;
+	while (*start == ' ')
+		start++;
+	if (strict_strtoul(start, 16, &value))
+		return -EINVAL;
+	codec->write(codec, reg, value);
+	return buf_size;
+}
+
+static const struct file_operations codec_reg_fops = {
+	.open = codec_reg_open_file,
+	.read = codec_reg_read_file,
+	.write = codec_reg_write_file,
+};
+
+static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
+{
+	char codec_root[128];
+
+	if (codec->dev)
+		snprintf(codec_root, sizeof(codec_root),
+			"%s.%s", codec->name, dev_name(codec->dev));
+	else
+		snprintf(codec_root, sizeof(codec_root),
+			"%s", codec->name);
+
+	codec->debugfs_codec_root = debugfs_create_dir(codec_root,
+						       debugfs_root);
+	if (!codec->debugfs_codec_root) {
+		printk(KERN_WARNING
+		       "ASoC: Failed to create codec debugfs directory\n");
+		return;
+	}
+
+	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
+						 codec->debugfs_codec_root,
+						 codec, &codec_reg_fops);
+	if (!codec->debugfs_reg)
+		printk(KERN_WARNING
+		       "ASoC: Failed to create codec register debugfs file\n");
+
+	codec->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0744,
+						     codec->debugfs_codec_root,
+						     &codec->pop_time);
+	if (!codec->debugfs_pop_time)
+		printk(KERN_WARNING
+		       "Failed to create pop time debugfs file\n");
+
+	codec->debugfs_dapm = debugfs_create_dir("dapm",
+						 codec->debugfs_codec_root);
+	if (!codec->debugfs_dapm)
+		printk(KERN_WARNING
+		       "Failed to create DAPM debugfs directory\n");
+
+	snd_soc_dapm_debugfs_init(codec);
+}
+
+static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
+{
+	debugfs_remove_recursive(codec->debugfs_codec_root);
+}
+
+#else
+
+static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
+{
+}
+
+static inline void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
+{
+}
+#endif
+
 #ifdef CONFIG_SND_SOC_AC97_BUS
 /* unregister ac97 codec */
 static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
@@ -1111,173 +1278,6 @@ int snd_soc_codec_volatile_register(struct snd_soc_codec *codec, int reg)
 }
 EXPORT_SYMBOL_GPL(snd_soc_codec_volatile_register);
 
-/* codec register dump */
-static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
-{
-	int i, step = 1, count = 0;
-
-	if (!codec->reg_cache_size)
-		return 0;
-
-	if (codec->reg_cache_step)
-		step = codec->reg_cache_step;
-
-	count += sprintf(buf, "%s registers\n", codec->name);
-	for (i = 0; i < codec->reg_cache_size; i += step) {
-		if (codec->readable_register && !codec->readable_register(i))
-			continue;
-
-		count += sprintf(buf + count, "%2x: ", i);
-		if (count >= PAGE_SIZE - 1)
-			break;
-
-		if (codec->display_register)
-			count += codec->display_register(codec, buf + count,
-							 PAGE_SIZE - count, i);
-		else
-			count += snprintf(buf + count, PAGE_SIZE - count,
-					  "%4x", codec->read(codec, i));
-
-		if (count >= PAGE_SIZE - 1)
-			break;
-
-		count += snprintf(buf + count, PAGE_SIZE - count, "\n");
-		if (count >= PAGE_SIZE - 1)
-			break;
-	}
-
-	/* Truncate count; min() would cause a warning */
-	if (count >= PAGE_SIZE)
-		count = PAGE_SIZE - 1;
-
-	return count;
-}
-static ssize_t codec_reg_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct snd_soc_device *devdata = dev_get_drvdata(dev);
-	return soc_codec_reg_show(devdata->card->codec, buf);
-}
-
-static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
-
-#ifdef CONFIG_DEBUG_FS
-static int codec_reg_open_file(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
-{
-	ssize_t ret;
-	struct snd_soc_codec *codec = file->private_data;
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-	ret = soc_codec_reg_show(codec, buf);
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-	kfree(buf);
-	return ret;
-}
-
-static ssize_t codec_reg_write_file(struct file *file,
-		const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	char buf[32];
-	int buf_size;
-	char *start = buf;
-	unsigned long reg, value;
-	int step = 1;
-	struct snd_soc_codec *codec = file->private_data;
-
-	buf_size = min(count, (sizeof(buf)-1));
-	if (copy_from_user(buf, user_buf, buf_size))
-		return -EFAULT;
-	buf[buf_size] = 0;
-
-	if (codec->reg_cache_step)
-		step = codec->reg_cache_step;
-
-	while (*start == ' ')
-		start++;
-	reg = simple_strtoul(start, &start, 16);
-	if ((reg >= codec->reg_cache_size) || (reg % step))
-		return -EINVAL;
-	while (*start == ' ')
-		start++;
-	if (strict_strtoul(start, 16, &value))
-		return -EINVAL;
-	codec->write(codec, reg, value);
-	return buf_size;
-}
-
-static const struct file_operations codec_reg_fops = {
-	.open = codec_reg_open_file,
-	.read = codec_reg_read_file,
-	.write = codec_reg_write_file,
-};
-
-static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
-{
-	char codec_root[128];
-
-	if (codec->dev)
-		snprintf(codec_root, sizeof(codec_root),
-			"%s.%s", codec->name, dev_name(codec->dev));
-	else
-		snprintf(codec_root, sizeof(codec_root),
-			"%s", codec->name);
-
-	codec->debugfs_codec_root = debugfs_create_dir(codec_root,
-						       debugfs_root);
-	if (!codec->debugfs_codec_root) {
-		printk(KERN_WARNING
-		       "ASoC: Failed to create codec debugfs directory\n");
-		return;
-	}
-
-	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
-						 codec->debugfs_codec_root,
-						 codec, &codec_reg_fops);
-	if (!codec->debugfs_reg)
-		printk(KERN_WARNING
-		       "ASoC: Failed to create codec register debugfs file\n");
-
-	codec->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0744,
-						     codec->debugfs_codec_root,
-						     &codec->pop_time);
-	if (!codec->debugfs_pop_time)
-		printk(KERN_WARNING
-		       "Failed to create pop time debugfs file\n");
-
-	codec->debugfs_dapm = debugfs_create_dir("dapm",
-						 codec->debugfs_codec_root);
-	if (!codec->debugfs_dapm)
-		printk(KERN_WARNING
-		       "Failed to create DAPM debugfs directory\n");
-
-	snd_soc_dapm_debugfs_init(codec);
-}
-
-static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
-{
-	debugfs_remove_recursive(codec->debugfs_codec_root);
-}
-
-#else
-
-static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
-{
-}
-
-static inline void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
-{
-}
-#endif
-
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec

commit 6c508c62f90240ef58300a5e12093ee769a44364
Author: Eero Nurkkala <ext-eero.nurkkala@nokia.com>
Date:   Fri Oct 30 13:34:03 2009 +0200

    ASoC: refactor snd_soc_update_bits()
    
    Introduce a wrapper call snd_soc_update_bits_locked()
    that will take the codec mutex. This call is used
    when the codec mutex is not already taken.
    
    Drivers calling snd_soc_update_bits() may wish to
    make sure the codec mutex is taken from the driver.
    
    Signed-off-by: Eero Nurkkala <ext-eero.nurkkala@nokia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 025c5a7f8b72..6e24654194ee 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1355,6 +1355,30 @@ int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
 }
 EXPORT_SYMBOL_GPL(snd_soc_update_bits);
 
+/**
+ * snd_soc_update_bits_locked - update codec register bits
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value, and takes the codec mutex.
+ *
+ * Returns 1 for change else 0.
+ */
+static int snd_soc_update_bits_locked(struct snd_soc_codec *codec,
+				unsigned short reg, unsigned int mask,
+				unsigned int value)
+{
+	int change;
+
+	mutex_lock(&codec->mutex);
+	change = snd_soc_update_bits(codec, reg, mask, value);
+	mutex_unlock(&codec->mutex);
+
+	return change;
+}
+
 /**
  * snd_soc_test_bits - test register for change
  * @codec: audio codec
@@ -1706,7 +1730,7 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 		mask |= (bitmask - 1) << e->shift_r;
 	}
 
-	return snd_soc_update_bits(codec, e->reg, mask, val);
+	return snd_soc_update_bits_locked(codec, e->reg, mask, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
 
@@ -1780,7 +1804,7 @@ int snd_soc_put_value_enum_double(struct snd_kcontrol *kcontrol,
 		mask |= e->mask << e->shift_r;
 	}
 
-	return snd_soc_update_bits(codec, e->reg, mask, val);
+	return snd_soc_update_bits_locked(codec, e->reg, mask, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_value_enum_double);
 
@@ -1941,7 +1965,7 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 		val_mask |= mask << rshift;
 		val |= val2 << rshift;
 	}
-	return snd_soc_update_bits(codec, reg, val_mask, val);
+	return snd_soc_update_bits_locked(codec, reg, val_mask, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 
@@ -2047,11 +2071,11 @@ int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
 	val = val << shift;
 	val2 = val2 << shift;
 
-	err = snd_soc_update_bits(codec, reg, val_mask, val);
+	err = snd_soc_update_bits_locked(codec, reg, val_mask, val);
 	if (err < 0)
 		return err;
 
-	err = snd_soc_update_bits(codec, reg2, val_mask, val2);
+	err = snd_soc_update_bits_locked(codec, reg2, val_mask, val2);
 	return err;
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);
@@ -2130,7 +2154,7 @@ int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 	val = (ucontrol->value.integer.value[0]+min) & 0xff;
 	val |= ((ucontrol->value.integer.value[1]+min) & 0xff) << 8;
 
-	return snd_soc_update_bits(codec, reg, 0xffff, val);
+	return snd_soc_update_bits_locked(codec, reg, 0xffff, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 

commit 8538a119bfb9031c402a33fc65c276ab9bfafdd5
Author: Eero Nurkkala <ext-eero.nurkkala@nokia.com>
Date:   Fri Oct 30 13:34:02 2009 +0200

    ASoC: remove io_mutex
    
    Remove the io_mutex. It has a drawback of serializing
    all accesses to snd_soc_update_bits() even when multiple
    codecs are in use. In addition, it fails to actually do
    its task - during snd_soc_update_bits(), dapm_update_bits()
    may also be accessing the same register which may result in
    an outdated register value.
    
    Signed-off-by: Eero Nurkkala <ext-eero.nurkkala@nokia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2d190df9fccc..025c5a7f8b72 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -37,7 +37,6 @@
 #include <sound/initval.h>
 
 static DEFINE_MUTEX(pcm_mutex);
-static DEFINE_MUTEX(io_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 
 #ifdef CONFIG_DEBUG_FS
@@ -1346,14 +1345,12 @@ int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
 	int change;
 	unsigned int old, new;
 
-	mutex_lock(&io_mutex);
 	old = snd_soc_read(codec, reg);
 	new = (old & ~mask) | value;
 	change = old != new;
 	if (change)
 		snd_soc_write(codec, reg, new);
 
-	mutex_unlock(&io_mutex);
 	return change;
 }
 EXPORT_SYMBOL_GPL(snd_soc_update_bits);
@@ -1376,11 +1373,9 @@ int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
 	int change;
 	unsigned int old, new;
 
-	mutex_lock(&io_mutex);
 	old = snd_soc_read(codec, reg);
 	new = (old & ~mask) | value;
 	change = old != new;
-	mutex_unlock(&io_mutex);
 
 	return change;
 }

commit 9927f327717400a3372ff8931859509986b8ad37
Merge: 4f066173fe8d 02a06d3042e2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Oct 19 16:15:35 2009 +0100

    Merge branch 'for-2.6.32' into for-2.6.33

commit 02a06d3042e208cb74369838b178ca9512192be4
Author: Barry Song <21cnbao@gmail.com>
Date:   Fri Oct 16 18:13:38 2009 +0800

    ASoC: Fix possible codec_dai->ops NULL pointer problems
    
    Some codec DAIs like stac9766, wm9712, wm9713, ad1980 don't register themselves
    then it loses to the chance to be given a null_dai_ops in snd_soc_register_dai
    if they have no ops. When functions like soc_pcm_open, soc_pcm_hw_params etc.
    access the ops field in these DAIs, panic will happen.
    
    Signed-off-by: Barry Song <21cnbao@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7ff04ad2a97e..0a1b2f64bbee 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -834,6 +834,9 @@ EXPORT_SYMBOL_GPL(snd_soc_resume_device);
 #define soc_resume	NULL
 #endif
 
+static struct snd_soc_dai_ops null_dai_ops = {
+};
+
 static void snd_soc_instantiate_card(struct snd_soc_card *card)
 {
 	struct platform_device *pdev = container_of(card->dev,
@@ -877,6 +880,11 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 			ac97 = 1;
 	}
 
+	for (i = 0; i < card->num_links; i++) {
+		if (!card->dai_link[i].codec_dai->ops)
+			card->dai_link[i].codec_dai->ops = &null_dai_ops;
+	}
+
 	/* If we have AC97 in the system then don't wait for the
 	 * codec.  This will need revisiting if we have to handle
 	 * systems with mixed AC97 and non-AC97 parts.  Only check for
@@ -2329,9 +2337,6 @@ static int snd_soc_unregister_card(struct snd_soc_card *card)
 	return 0;
 }
 
-static struct snd_soc_dai_ops null_dai_ops = {
-};
-
 /**
  * snd_soc_register_dai - Register a DAI with the ASoC core
  *

commit d2058b0cd039aad89b111d83b9c347e9d8f57a84
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Oct 13 17:39:56 2009 +0100

    ASoC: Remove snd_soc_suspend_device()
    
    The PM core will grow pm_link infrastructure in 2.6.33 which can be
    used to implement the intended functionality of the ASoC-specific
    device suspend and resume callbacks so drop them.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1dec9d21c55e..fa0da3cac705 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -790,45 +790,6 @@ static int soc_resume(struct device *dev)
 
 	return 0;
 }
-
-/**
- * snd_soc_suspend_device: Notify core of device suspend
- *
- * @dev: Device being suspended.
- *
- * In order to ensure that the entire audio subsystem is suspended in a
- * coordinated fashion ASoC devices should suspend themselves when
- * called by ASoC.  When the standard kernel suspend process asks the
- * device to suspend it should call this function to initiate a suspend
- * of the entire ASoC card.
- *
- * \note Currently this function is stubbed out.
- */
-int snd_soc_suspend_device(struct device *dev)
-{
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_suspend_device);
-
-/**
- * snd_soc_resume_device: Notify core of device resume
- *
- * @dev: Device being resumed.
- *
- * In order to ensure that the entire audio subsystem is resumed in a
- * coordinated fashion ASoC devices should resume themselves when called
- * by ASoC.  When the standard kernel resume process asks the device
- * to resume it should call this function.  Once all the components of
- * the card have notified that they are ready to be resumed the card
- * will be resumed.
- *
- * \note Currently this function is stubbed out.
- */
-int snd_soc_resume_device(struct device *dev)
-{
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_resume_device);
 #else
 #define soc_suspend	NULL
 #define soc_resume	NULL

commit ce3e3737a3361e0c7030f8598eec36bb82050de6
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Fri Oct 2 09:17:37 2009 +0300

    ASoC: Improve the debugfs hierarchy
    
    Change the way the debugfs entries are created:
    If the codec->dev is valid, than use:
    debugfs/asoc/{codec->name}.{dev_name(codec->dev)}/
    
    if the codec->dev is NULL:
    debugfs/asoc/{codec->name}/
    
    as root for the debugfs entries.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e4ab36daf3f7..1dec9d21c55e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1256,8 +1256,12 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
 	char codec_root[128];
 
-	snprintf(codec_root, sizeof(codec_root),
-		 "%s-%s", dev_name(codec->socdev->dev), codec->name);
+	if (codec->dev)
+		snprintf(codec_root, sizeof(codec_root),
+			"%s.%s", codec->name, dev_name(codec->dev));
+	else
+		snprintf(codec_root, sizeof(codec_root),
+			"%s", codec->name);
 
 	codec->debugfs_codec_root = debugfs_create_dir(codec_root,
 						       debugfs_root);

commit 88439ac793934a47f47ad285656b63d09f5937c8
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Thu Oct 1 10:32:47 2009 +0300

    ASoC: add support for multiple cards/codecs in debugfs
    
    In order to support multiple codecs on the same system in the debugfs
    the directory hierarchy need to be changed by adding directory per codec
    under the asoc direcorty:
    
    debugfs/asoc/{dev_name(socdev->dev)}-{codec->name}/codec_reg
                                                      /dapm_pop_time
                                                      /dapm/{widgets}
    
    With the original implementation only the debugfs files are only
    created for the first codec, other codecs loaded later would fail to
    create the debugfs files (since they are already exist).
    Furthermore in this situation any of the codecs has been removed, would
    cause the debugfs entries to disappear, regardless if the codec, which
    created them are still loaded (the one which loaded first).
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f5b356f8acfb..e4ab36daf3f7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1254,21 +1254,35 @@ static const struct file_operations codec_reg_fops = {
 
 static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
+	char codec_root[128];
+
+	snprintf(codec_root, sizeof(codec_root),
+		 "%s-%s", dev_name(codec->socdev->dev), codec->name);
+
+	codec->debugfs_codec_root = debugfs_create_dir(codec_root,
+						       debugfs_root);
+	if (!codec->debugfs_codec_root) {
+		printk(KERN_WARNING
+		       "ASoC: Failed to create codec debugfs directory\n");
+		return;
+	}
+
 	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
-						 debugfs_root, codec,
-						 &codec_reg_fops);
+						 codec->debugfs_codec_root,
+						 codec, &codec_reg_fops);
 	if (!codec->debugfs_reg)
 		printk(KERN_WARNING
 		       "ASoC: Failed to create codec register debugfs file\n");
 
 	codec->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0744,
-						     debugfs_root,
+						     codec->debugfs_codec_root,
 						     &codec->pop_time);
 	if (!codec->debugfs_pop_time)
 		printk(KERN_WARNING
 		       "Failed to create pop time debugfs file\n");
 
-	codec->debugfs_dapm = debugfs_create_dir("dapm", debugfs_root);
+	codec->debugfs_dapm = debugfs_create_dir("dapm",
+						 codec->debugfs_codec_root);
 	if (!codec->debugfs_dapm)
 		printk(KERN_WARNING
 		       "Failed to create DAPM debugfs directory\n");
@@ -1278,9 +1292,7 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 
 static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 {
-	debugfs_remove_recursive(codec->debugfs_dapm);
-	debugfs_remove(codec->debugfs_pop_time);
-	debugfs_remove(codec->debugfs_reg);
+	debugfs_remove_recursive(codec->debugfs_codec_root);
 }
 
 #else

commit 472df3cbae8da6a949f1392a11958b8d21383735
Author: Barry Song <21cnbao@gmail.com>
Date:   Sat Sep 12 01:16:29 2009 +0800

    ASoC: Provide API for reordering channels
    
    The patch adds an interface to set the relationship between audio
    channel number and slot number. The interface should be really useful
    because audio channel n doesn't always use slot n in all platforms. And
    for some devices, the relationship even can change with sound mode
    switch in 2.1,3.1,4.1,5.1,6.1,7.1 etc.
    
    Signed-off-by: Barry Song <21cnbao@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 05fdc8023da4..f5b356f8acfb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2252,6 +2252,30 @@ int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
 
+/**
+ * snd_soc_dai_set_channel_map - configure DAI audio channel map
+ * @dai: DAI
+ * @tx_num: how many TX channels
+ * @tx_slot: pointer to an array which imply the TX slot number channel
+ *           0~num-1 uses
+ * @rx_num: how many RX channels
+ * @rx_slot: pointer to an array which imply the RX slot number channel
+ *           0~num-1 uses
+ *
+ * configure the relationship between channel number and TDM slot number.
+ */
+int snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,
+	unsigned int tx_num, unsigned int *tx_slot,
+	unsigned int rx_num, unsigned int *rx_slot)
+{
+	if (dai->ops && dai->ops->set_channel_map)
+		return dai->ops->set_channel_map(dai, tx_num, tx_slot,
+			rx_num, rx_slot);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);
+
 /**
  * snd_soc_dai_set_tristate - configure DAI system or master clock.
  * @dai: DAI

commit 85488037bb9b533b064be66412dbe1dbcd2734d9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Sep 5 18:52:16 2009 +0100

    ASoC: Add source argument to PLL configuration
    
    More and more devices feature PLLs and FLLs with the ability to select
    between multiple input clocks. In order to better support these devices
    a new argument, source, has been added to the set_pll() configuration
    API. Using set_clkdiv() is often difficult due to the need to stop the
    PLL/FLL before any reconfiguration can be done.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7ff04ad2a97e..05fdc8023da4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2197,16 +2197,18 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
  * snd_soc_dai_set_pll - configure DAI PLL.
  * @dai: DAI
  * @pll_id: DAI specific PLL ID
+ * @source: DAI specific source for the PLL
  * @freq_in: PLL input clock frequency in Hz
  * @freq_out: requested PLL output clock frequency in Hz
  *
  * Configures and enables PLL to generate output clock based on input clock.
  */
-int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
-	int pll_id, unsigned int freq_in, unsigned int freq_out)
+int snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
+	unsigned int freq_in, unsigned int freq_out)
 {
 	if (dai->ops && dai->ops->set_pll)
-		return dai->ops->set_pll(dai, pll_id, freq_in, freq_out);
+		return dai->ops->set_pll(dai, pll_id, source,
+					 freq_in, freq_out);
 	else
 		return -EINVAL;
 }

commit 79fb9387f88b6b44bbc46e19cae26d2c9fe3bb6a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Aug 21 16:38:13 2009 +0100

    ASoC: Add DAPM widget power decision debugfs files
    
    Currently when built with DEBUG DAPM will dump information about
    the power state decisions it is taking for each widget to dmesg.
    This isn't an ideal way of getting the information - it requires
    a kernel build to turn it on and off and for large hub CODECs the
    volume of information is so large as to be illegible. When the
    output goes to the console it can also cause a noticable impact
    on performance simply to print it out.
    
    Improve the situation by adding a dapm directory to our debugfs
    tree containing a file per widget with the same information in
    it. This still requires a decision to build with debugfs support
    but is easier to navigate and much less intrusive.
    
    In addition to the previously displayed information active streams
    are also shown in these files.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e984a17cd656..7ff04ad2a97e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1267,10 +1267,18 @@ static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 	if (!codec->debugfs_pop_time)
 		printk(KERN_WARNING
 		       "Failed to create pop time debugfs file\n");
+
+	codec->debugfs_dapm = debugfs_create_dir("dapm", debugfs_root);
+	if (!codec->debugfs_dapm)
+		printk(KERN_WARNING
+		       "Failed to create DAPM debugfs directory\n");
+
+	snd_soc_dapm_debugfs_init(codec);
 }
 
 static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 {
+	debugfs_remove_recursive(codec->debugfs_dapm);
 	debugfs_remove(codec->debugfs_pop_time);
 	debugfs_remove(codec->debugfs_reg);
 }

commit a5479e389e989acfeca9c32eeb0083d086202280
Author: Daniel Ribeiro <drwyrm@gmail.com>
Date:   Mon Jun 15 21:44:31 2009 -0300

    ASoC: change set_tdm_slot api to allow slot_width override.
    
    Extend set_tdm_slot to allow the user to arbitrarily set the frame width
    and active TX/RX slots.
    
    Updates magician.c and wm9081.c for the new set_tdm_slot(). wm9081.c
    still doesn't handle the slot_width override.
    
    While being there, correct an incorrect use of SlotsPerFrm(7) use in
    bitmask on pxa-ssp.c (SSCR0_SlotsPerFrm(x) is (((x) - 1) << 24)) ).
    
    (this series is meant for Mark's for-2.6.32 branch)
    
    Signed-off-by: Daniel Ribeiro <drwyrm@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fb8d7a766155..e984a17cd656 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2223,17 +2223,20 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 /**
  * snd_soc_dai_set_tdm_slot - configure DAI TDM.
  * @dai: DAI
- * @mask: DAI specific mask representing used slots.
+ * @tx_mask: bitmask representing active TX slots.
+ * @rx_mask: bitmask representing active RX slots.
  * @slots: Number of slots in use.
+ * @slot_width: Width in bits for each slot.
  *
  * Configures a DAI for TDM operation. Both mask and slots are codec and DAI
  * specific.
  */
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
-	unsigned int mask, int slots)
+	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
 {
 	if (dai->ops && dai->ops->set_tdm_slot)
-		return dai->ops->set_tdm_slot(dai, mask, slots);
+		return dai->ops->set_tdm_slot(dai, tx_mask, rx_mask,
+				slots, slot_width);
 	else
 		return -EINVAL;
 }

commit 77ee09c67e051a5ebd19a53ba3945dbdc8d21b3c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jul 31 18:26:51 2009 +0100

    ASoC: Allow CODECs to flag invalid registers
    
    This helps CODECs with sparse register maps work better with the
    register cache display interface.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5eabb7117608..fb8d7a766155 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1156,6 +1156,9 @@ static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 
 	count += sprintf(buf, "%s registers\n", codec->name);
 	for (i = 0; i < codec->reg_cache_size; i += step) {
+		if (codec->readable_register && !codec->readable_register(i))
+			continue;
+
 		count += sprintf(buf + count, "%2x: ", i);
 		if (count >= PAGE_SIZE - 1)
 			break;

commit 474828a40f6ddab6e2a3475a19c5c84aa3ec7d60
Author: Marek Vasut <marek.vasut@gmail.com>
Date:   Wed Jul 22 13:01:03 2009 +0200

    ALSA: Allow passing platform_data to devices attached to AC97 bus
    
    This patch allows passing platform_data to devices attached to AC97 bus
    (like touchscreens, battery measurement chips ...).
    
    Signed-off-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8bf49a4e664a..5eabb7117608 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -28,6 +28,7 @@
 #include <linux/bitops.h>
 #include <linux/debugfs.h>
 #include <linux/platform_device.h>
+#include <sound/ac97_codec.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -1461,8 +1462,11 @@ int snd_soc_init_card(struct snd_soc_device *socdev)
 				continue;
 			}
 		}
-		if (card->dai_link[i].codec_dai->ac97_control)
+		if (card->dai_link[i].codec_dai->ac97_control) {
 			ac97 = 1;
+			snd_ac97_dev_add_pdata(codec->ac97,
+				card->dai_link[i].cpu_dai->ac97_pdata);
+		}
 	}
 	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
 		 "%s",  card->name);

commit 096e49d5e6f7bd93395e7ddf7e0239e1644d0505
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jul 5 15:12:22 2009 +0100

    ASoC: Add CODEC volatile register operation
    
    Add a volatile_register() operation to the CODEC structure providing a
    standard operation to query if a register is volatile. This will be used
    to factor out the register cache I/O operations for the CODECs.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index dfc03c0bacb6..8bf49a4e664a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1125,6 +1125,23 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	return ret;
 }
 
+/**
+ * snd_soc_codec_volatile_register: Report if a register is volatile.
+ *
+ * @codec: CODEC to query.
+ * @reg: Register to query.
+ *
+ * Boolean function indiciating if a CODEC register is volatile.
+ */
+int snd_soc_codec_volatile_register(struct snd_soc_codec *codec, int reg)
+{
+	if (codec->volatile_register)
+		return codec->volatile_register(reg);
+	else
+		return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_codec_volatile_register);
+
 /* codec register dump */
 static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 {

commit 416356fcfad46bdebcf8e2afdb94919401ff99d3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jun 30 19:05:15 2009 +0100

    ASoC: Convert to dev_pm_ops
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 235503230fe7..dfc03c0bacb6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -619,8 +619,9 @@ static struct snd_pcm_ops soc_pcm_ops = {
 
 #ifdef CONFIG_PM
 /* powers down audio subsystem for suspend */
-static int soc_suspend(struct platform_device *pdev, pm_message_t state)
+static int soc_suspend(struct device *dev)
 {
+	struct platform_device *pdev = to_platform_device(dev);
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_platform *platform = card->platform;
@@ -656,7 +657,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 		snd_pcm_suspend_all(card->dai_link[i].pcm);
 
 	if (card->suspend_pre)
-		card->suspend_pre(pdev, state);
+		card->suspend_pre(pdev, PMSG_SUSPEND);
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai  *cpu_dai = card->dai_link[i].cpu_dai;
@@ -682,7 +683,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	}
 
 	if (codec_dev->suspend)
-		codec_dev->suspend(pdev, state);
+		codec_dev->suspend(pdev, PMSG_SUSPEND);
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
@@ -691,7 +692,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	}
 
 	if (card->suspend_post)
-		card->suspend_post(pdev, state);
+		card->suspend_post(pdev, PMSG_SUSPEND);
 
 	return 0;
 }
@@ -765,8 +766,9 @@ static void soc_resume_deferred(struct work_struct *work)
 }
 
 /* powers up audio subsystem after a suspend */
-static int soc_resume(struct platform_device *pdev)
+static int soc_resume(struct device *dev)
 {
+	struct platform_device *pdev = to_platform_device(dev);
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_dai *cpu_dai = card->dai_link[0].cpu_dai;
@@ -826,7 +828,6 @@ int snd_soc_resume_device(struct device *dev)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_resume_device);
-
 #else
 #define soc_suspend	NULL
 #define soc_resume	NULL
@@ -1020,32 +1021,39 @@ static int soc_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static void soc_shutdown(struct platform_device *pdev)
+static int soc_poweroff(struct device *dev)
 {
+	struct platform_device *pdev = to_platform_device(dev);
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_card *card = socdev->card;
 
 	if (!card->instantiated)
-		return;
+		return 0;
 
 	/* Flush out pmdown_time work - we actually do want to run it
 	 * now, we're shutting down so no imminent restart. */
 	run_delayed_work(&card->delayed_work);
 
 	snd_soc_dapm_shutdown(socdev);
+
+	return 0;
 }
 
+static struct dev_pm_ops soc_pm_ops = {
+	.suspend = soc_suspend,
+	.resume = soc_resume,
+	.poweroff = soc_poweroff,
+};
+
 /* ASoC platform driver */
 static struct platform_driver soc_driver = {
 	.driver		= {
 		.name		= "soc-audio",
 		.owner		= THIS_MODULE,
+		.pm		= &soc_pm_ops,
 	},
 	.probe		= soc_probe,
 	.remove		= soc_remove,
-	.suspend	= soc_suspend,
-	.resume		= soc_resume,
-	.shutdown	= soc_shutdown,
 };
 
 /* create a new pcm */

commit d5fc3b5fe374f24b6773c22e90ef4bdda718b845
Merge: e2f551dacbdf dd5e8e6b1d4c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jun 25 13:58:37 2009 +0100

    Merge branch 'for-2.6.31' into for-2.6.32

commit 517374704da44c1ba77c1600714fe214524af286
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jun 22 13:16:51 2009 +0100

    ASoC: Add a shutdown callback
    
    Ensure that the audio subsystem is powered down cleanly when the system
    shuts down by providing a shutdown operation. This ensures that all the
    components have been returned to an off state cleanly which should avoid
    audio issues from partially charged capacitors or noise on digital inputs
    if the system is restarted quickly.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Tested-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 44141178ff4a..55d45c43ba16 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1020,6 +1020,21 @@ static int soc_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void soc_shutdown(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_card *card = socdev->card;
+
+	if (!card->instantiated)
+		return;
+
+	/* Flush out pmdown_time work - we actually do want to run it
+	 * now, we're shutting down so no imminent restart. */
+	run_delayed_work(&card->delayed_work);
+
+	snd_soc_dapm_shutdown(socdev);
+}
+
 /* ASoC platform driver */
 static struct platform_driver soc_driver = {
 	.driver		= {
@@ -1030,6 +1045,7 @@ static struct platform_driver soc_driver = {
 	.remove		= soc_remove,
 	.suspend	= soc_suspend,
 	.resume		= soc_resume,
+	.shutdown	= soc_shutdown,
 };
 
 /* create a new pcm */

commit 6d5701b29e392f77d222254aa8e375315d59f0aa
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jun 14 11:33:37 2009 +0100

    ASoC: Instantiate any forgotten DAPM widgets
    
    With the recent changes to the DAPM power checks it has become important
    to explicitly instantiate all widgets but some drivers were forgetting
    to do that.  Since everything needs to do it add a call to instantiate
    them immediately before the card registration - it does no harm when it
    is called repeatedly and saves work in drivers.
    
    Tested-by: pHilipp Zabel <philipp.zabel@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3f44150d8e30..1d70829464ef 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1389,6 +1389,9 @@ int snd_soc_init_card(struct snd_soc_device *socdev)
 	snprintf(codec->card->longname, sizeof(codec->card->longname),
 		 "%s (%s)", card->name, codec->name);
 
+	/* Make sure all DAPM widgets are instantiated */
+	snd_soc_dapm_new_widgets(codec);
+
 	ret = snd_card_register(codec->card);
 	if (ret < 0) {
 		printk(KERN_ERR "asoc: failed to register soundcard for %s\n",

commit 831dc0f10f7b2a4856094ff160c018bf19f77527
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Jun 13 19:55:02 2009 +0100

    ASoC: Add stub suspend and resume calls for ASoC subdevices
    
    Now that ASoC subdevices can be regular devices they can have normal
    suspend and resume calls from their buses.  However, suspending them
    individually is not desirable since this can lead to problems such as
    pops and clicks from devices being suspended with their signals being
    amplified or clocks being stopped suddenly.
    
    This will be resolved by having the normal device model suspend and
    resume calls call into ASoC which will suspend the entire card while any
    of its components are suspended.  At present this is not yet implemented
    but in order to aid the transition of drivers to the standard device
    model this patch adds API calls for the notifications.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e1a920cd8953..44141178ff4a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -788,6 +788,45 @@ static int soc_resume(struct platform_device *pdev)
 	return 0;
 }
 
+/**
+ * snd_soc_suspend_device: Notify core of device suspend
+ *
+ * @dev: Device being suspended.
+ *
+ * In order to ensure that the entire audio subsystem is suspended in a
+ * coordinated fashion ASoC devices should suspend themselves when
+ * called by ASoC.  When the standard kernel suspend process asks the
+ * device to suspend it should call this function to initiate a suspend
+ * of the entire ASoC card.
+ *
+ * \note Currently this function is stubbed out.
+ */
+int snd_soc_suspend_device(struct device *dev)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_suspend_device);
+
+/**
+ * snd_soc_resume_device: Notify core of device resume
+ *
+ * @dev: Device being resumed.
+ *
+ * In order to ensure that the entire audio subsystem is resumed in a
+ * coordinated fashion ASoC devices should resume themselves when called
+ * by ASoC.  When the standard kernel resume process asks the device
+ * to resume it should call this function.  Once all the components of
+ * the card have notified that they are ready to be resumed the card
+ * will be resumed.
+ *
+ * \note Currently this function is stubbed out.
+ */
+int snd_soc_resume_device(struct device *dev)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_resume_device);
+
 #else
 #define soc_suspend	NULL
 #define soc_resume	NULL

commit 46f5822f7841697d4aedaf4672661d7a765172cd
Author: Daniel Ribeiro <drwyrm@gmail.com>
Date:   Sun Jun 7 02:49:11 2009 -0300

    ASoC: Allow 32 bit registers for DAPM
    
    Replace the remaining unsigned shorts with unsigned ints.
    Tested with pcap2 codec (25 bits registers).
    
    Signed-off-by: Daniel Ribeiro <drwyrm@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 3f44150d8e30..e1a920cd8953 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1264,10 +1264,10 @@ EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
  * Returns 1 for change else 0.
  */
 int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
-				unsigned short mask, unsigned short value)
+				unsigned int mask, unsigned int value)
 {
 	int change;
-	unsigned short old, new;
+	unsigned int old, new;
 
 	mutex_lock(&io_mutex);
 	old = snd_soc_read(codec, reg);
@@ -1294,10 +1294,10 @@ EXPORT_SYMBOL_GPL(snd_soc_update_bits);
  * Returns 1 for change else 0.
  */
 int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
-				unsigned short mask, unsigned short value)
+				unsigned int mask, unsigned int value)
 {
 	int change;
-	unsigned short old, new;
+	unsigned int old, new;
 
 	mutex_lock(&io_mutex);
 	old = snd_soc_read(codec, reg);
@@ -1583,7 +1583,7 @@ int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned short val, bitmask;
+	unsigned int val, bitmask;
 
 	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
 		;
@@ -1612,8 +1612,8 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned short val;
-	unsigned short mask, bitmask;
+	unsigned int val;
+	unsigned int mask, bitmask;
 
 	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
 		;
@@ -1649,7 +1649,7 @@ int snd_soc_get_value_enum_double(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned short reg_val, val, mux;
+	unsigned int reg_val, val, mux;
 
 	reg_val = snd_soc_read(codec, e->reg);
 	val = (reg_val >> e->shift_l) & e->mask;
@@ -1688,8 +1688,8 @@ int snd_soc_put_value_enum_double(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned short val;
-	unsigned short mask;
+	unsigned int val;
+	unsigned int mask;
 
 	if (ucontrol->value.enumerated.item[0] > e->max - 1)
 		return -EINVAL;
@@ -1849,7 +1849,7 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 	int max = mc->max;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
-	unsigned short val, val2, val_mask;
+	unsigned int val, val2, val_mask;
 
 	val = (ucontrol->value.integer.value[0] & mask);
 	if (invert)
@@ -1915,7 +1915,7 @@ int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
 	unsigned int reg2 = mc->rreg;
 	unsigned int shift = mc->shift;
 	int max = mc->max;
-	unsigned int mask = (1<<fls(max))-1;
+	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
 
 	ucontrol->value.integer.value[0] =
@@ -1955,7 +1955,7 @@ int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
 	int err;
-	unsigned short val, val2, val_mask;
+	unsigned int val, val2, val_mask;
 
 	val_mask = mask << shift;
 	val = (ucontrol->value.integer.value[0] & mask);
@@ -2047,7 +2047,7 @@ int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int reg = mc->reg;
 	int min = mc->min;
-	unsigned short val;
+	unsigned int val;
 
 	val = (ucontrol->value.integer.value[0]+min) & 0xff;
 	val |= ((ucontrol->value.integer.value[1]+min) & 0xff) << 8;

commit e3509ff0fb9df53e45cd68488e3b463a80455db7
Author: Daniel Mack <daniel@caiaq.de>
Date:   Wed Jun 3 17:44:49 2009 +0200

    ASoC: fix NULL pointer dereference in soc_suspend()
    
    In case the initalization of an soc_device failed, there is no codec
    associated with it. soc_suspend() will still dereference the pointer
    and cause an Ooops when entering the sleep mode.
    
    This happens on our board with a multi-target kernel image when booted
    on a machine without audio circuits.
    
    This patch makes the code bail out very early in this special case.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4aa8e2d35061..3f44150d8e30 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -628,6 +628,12 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	struct snd_soc_codec *codec = card->codec;
 	int i;
 
+	/* If the initialization of this soc device failed, there is no codec
+	 * associated with it. Just bail out in this case.
+	 */
+	if (!codec)
+		return 0;
+
 	/* Due to the resume being scheduled into a workqueue we could
 	* suspend before that's finished - wait for it to complete.
 	 */

commit 452c5eaa0d5162e02ffee742ea17540887bc2904
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun May 17 21:41:23 2009 +0100

    ASoC: Integrate bias management with DAPM power management
    
    Rather than managing the bias level of the system based on if there is
    an active audio stream manage it based on there being an active DAPM
    widget. This simplifies the code a little, moving the power handling
    into one place, and improves audio performance for bypass paths when no
    playbacks or captures are active.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c0e706645ec4..4aa8e2d35061 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -299,7 +299,6 @@ static void close_delayed_work(struct work_struct *work)
 {
 	struct snd_soc_card *card = container_of(work, struct snd_soc_card,
 						 delayed_work.work);
-	struct snd_soc_device *socdev = card->socdev;
 	struct snd_soc_codec *codec = card->codec;
 	struct snd_soc_dai *codec_dai;
 	int i;
@@ -315,27 +314,10 @@ static void close_delayed_work(struct work_struct *work)
 
 		/* are we waiting on this codec DAI stream */
 		if (codec_dai->pop_wait == 1) {
-
-			/* Reduce power if no longer active */
-			if (codec->active == 0) {
-				pr_debug("pop wq D1 %s %s\n", codec->name,
-					 codec_dai->playback.stream_name);
-				snd_soc_dapm_set_bias_level(socdev,
-					SND_SOC_BIAS_PREPARE);
-			}
-
 			codec_dai->pop_wait = 0;
 			snd_soc_dapm_stream_event(codec,
 				codec_dai->playback.stream_name,
 				SND_SOC_DAPM_STREAM_STOP);
-
-			/* Fall into standby if no longer active */
-			if (codec->active == 0) {
-				pr_debug("pop wq D3 %s %s\n", codec->name,
-					 codec_dai->playback.stream_name);
-				snd_soc_dapm_set_bias_level(socdev,
-					SND_SOC_BIAS_STANDBY);
-			}
 		}
 	}
 	mutex_unlock(&pcm_mutex);
@@ -399,10 +381,6 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 		snd_soc_dapm_stream_event(codec,
 			codec_dai->capture.stream_name,
 			SND_SOC_DAPM_STREAM_STOP);
-
-		if (codec->active == 0 && codec_dai->pop_wait == 0)
-			snd_soc_dapm_set_bias_level(socdev,
-						SND_SOC_BIAS_STANDBY);
 	}
 
 	mutex_unlock(&pcm_mutex);
@@ -467,36 +445,16 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 		cancel_delayed_work(&card->delayed_work);
 	}
 
-	/* do we need to power up codec */
-	if (codec->bias_level != SND_SOC_BIAS_ON) {
-		snd_soc_dapm_set_bias_level(socdev,
-					    SND_SOC_BIAS_PREPARE);
-
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-			snd_soc_dapm_stream_event(codec,
-					codec_dai->playback.stream_name,
-					SND_SOC_DAPM_STREAM_START);
-		else
-			snd_soc_dapm_stream_event(codec,
-					codec_dai->capture.stream_name,
-					SND_SOC_DAPM_STREAM_START);
-
-		snd_soc_dapm_set_bias_level(socdev, SND_SOC_BIAS_ON);
-		snd_soc_dai_digital_mute(codec_dai, 0);
-
-	} else {
-		/* codec already powered - power on widgets */
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-			snd_soc_dapm_stream_event(codec,
-					codec_dai->playback.stream_name,
-					SND_SOC_DAPM_STREAM_START);
-		else
-			snd_soc_dapm_stream_event(codec,
-					codec_dai->capture.stream_name,
-					SND_SOC_DAPM_STREAM_START);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_dapm_stream_event(codec,
+					  codec_dai->playback.stream_name,
+					  SND_SOC_DAPM_STREAM_START);
+	else
+		snd_soc_dapm_stream_event(codec,
+					  codec_dai->capture.stream_name,
+					  SND_SOC_DAPM_STREAM_START);
 
-		snd_soc_dai_digital_mute(codec_dai, 0);
-	}
+	snd_soc_dai_digital_mute(codec_dai, 0);
 
 out:
 	mutex_unlock(&pcm_mutex);
@@ -1372,6 +1330,7 @@ int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 		return ret;
 	}
 
+	codec->socdev = socdev;
 	codec->card->dev = socdev->dev;
 	codec->card->private_data = codec;
 	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));

commit 13e2c86c20f5d07b20d5a6dee24bcdd2b30b859f
Merge: 97b8096dc92a 1ffafeb556d5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue May 12 10:53:33 2009 +0100

    Merge branch 'for-2.6.30' into for-2.6.31

commit 914dc18255e430ceabb10b57394e01814c69c5cd
Author: Mike Rapoport <mike@compulab.co.il>
Date:   Mon May 11 13:04:55 2009 +0300

    ASoC: soc-core: fix crash when removing not instantiated card
    
    If the card was not instantiated in snd_soc_instantiate_card, calling
    soc-remove will crash because some of codec, cpu_dai and card .remove
    methods are called twice.
    Fix this by returning from soc_remove immediately.
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 99712f652d0d..1cd149b9ce69 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -954,6 +954,9 @@ static int soc_remove(struct platform_device *pdev)
 	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
+	if (!card->instantiated)
+		return 0;
+
 	run_delayed_work(&card->delayed_work);
 
 	if (platform->remove)

commit 151ab22cf71b7a1b9dd696d65a1a41e13d90cd00
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat May 9 16:22:58 2009 +0100

    ASoC: Fix up CODEC DAI formats for big endian CPUs
    
    ASoC uses the standard ALSA data format definitions to specify the wire
    format used between the CPU and CODEC. Since the ALSA data formats all
    include the endianess of the data but this information is not relevant
    by the time the data has been encoded onto the serial link to the CODEC
    this means that either all the CODEC drivers need to declare both big and
    little endian variants or the core needs to fix up the format constraints
    specified by CODEC drivers.
    
    For now take the latter approach - this will need to be revisited if any
    CODECs are endianness dependant.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index af11791a3b8c..6ac68e47b3a6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2387,6 +2387,39 @@ void snd_soc_unregister_platform(struct snd_soc_platform *platform)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);
 
+static u64 codec_format_map[] = {
+	SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE,
+	SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_U16_BE,
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE,
+	SNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_U24_BE,
+	SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_BE,
+	SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_U32_BE,
+	SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_U24_3BE,
+	SNDRV_PCM_FMTBIT_U24_3LE | SNDRV_PCM_FMTBIT_U24_3BE,
+	SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE,
+	SNDRV_PCM_FMTBIT_U20_3LE | SNDRV_PCM_FMTBIT_U20_3BE,
+	SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S18_3BE,
+	SNDRV_PCM_FMTBIT_U18_3LE | SNDRV_PCM_FMTBIT_U18_3BE,
+	SNDRV_PCM_FMTBIT_FLOAT_LE | SNDRV_PCM_FMTBIT_FLOAT_BE,
+	SNDRV_PCM_FMTBIT_FLOAT64_LE | SNDRV_PCM_FMTBIT_FLOAT64_BE,
+	SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE
+	| SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE,
+};
+
+/* Fix up the DAI formats for endianness: codecs don't actually see
+ * the endianness of the data but we're using the CPU format
+ * definitions which do need to include endianness so we ensure that
+ * codec DAIs always have both big and little endian variants set.
+ */
+static void fixup_codec_formats(struct snd_soc_pcm_stream *stream)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(codec_format_map); i++)
+		if (stream->formats & codec_format_map[i])
+			stream->formats |= codec_format_map[i];
+}
+
 /**
  * snd_soc_register_codec - Register a codec with the ASoC core
  *
@@ -2394,6 +2427,8 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);
  */
 int snd_soc_register_codec(struct snd_soc_codec *codec)
 {
+	int i;
+
 	if (!codec->name)
 		return -EINVAL;
 
@@ -2403,6 +2438,11 @@ int snd_soc_register_codec(struct snd_soc_codec *codec)
 
 	INIT_LIST_HEAD(&codec->list);
 
+	for (i = 0; i < codec->num_dai; i++) {
+		fixup_codec_formats(&codec->dai[i].playback);
+		fixup_codec_formats(&codec->dai[i].capture);
+	}
+
 	mutex_lock(&client_mutex);
 	list_add(&codec->list, &codec_list);
 	snd_soc_instantiate_cards();

commit fd5dfad9cf51bc3575b5e50193403de4a3de23bc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 15 21:37:46 2009 +0100

    ASoC: Volume controls are never of boolean type
    
    Some limited volume controls (mostly simple attenuations) have only two
    settings so the ASoC info functions misreport them as booleans. Since
    we currently have no better information check for " Volume" in the
    control name and always report any controls matching as being integer.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 92503927b0c6..af11791a3b8c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1779,7 +1779,7 @@ int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
 {
 	int max = kcontrol->private_value;
 
-	if (max == 1)
+	if (max == 1 && !strstr(kcontrol->id.name, " Volume"))
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	else
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
@@ -1809,7 +1809,7 @@ int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	unsigned int shift = mc->shift;
 	unsigned int rshift = mc->rshift;
 
-	if (max == 1)
+	if (max == 1 && !strstr(kcontrol->id.name, " Volume"))
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	else
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
@@ -1916,7 +1916,7 @@ int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
 		(struct soc_mixer_control *)kcontrol->private_value;
 	int max = mc->max;
 
-	if (max == 1)
+	if (max == 1 && !strstr(kcontrol->id.name, " Volume"))
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	else
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;

commit 3f1a4d826751d9759fc95da4e47d08d2745e0055
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 15 21:35:26 2009 +0100

    ASoC: Check we have DAI ops when calling via accessor functions
    
    Also make sure we're checking for the right operation while we're here.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index dd28009f8969..92503927b0c6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2100,7 +2100,7 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 	unsigned int freq, int dir)
 {
-	if (dai->ops->set_sysclk)
+	if (dai->ops && dai->ops->set_sysclk)
 		return dai->ops->set_sysclk(dai, clk_id, freq, dir);
 	else
 		return -EINVAL;
@@ -2120,7 +2120,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
 	int div_id, int div)
 {
-	if (dai->ops->set_clkdiv)
+	if (dai->ops && dai->ops->set_clkdiv)
 		return dai->ops->set_clkdiv(dai, div_id, div);
 	else
 		return -EINVAL;
@@ -2139,7 +2139,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
 	int pll_id, unsigned int freq_in, unsigned int freq_out)
 {
-	if (dai->ops->set_pll)
+	if (dai->ops && dai->ops->set_pll)
 		return dai->ops->set_pll(dai, pll_id, freq_in, freq_out);
 	else
 		return -EINVAL;
@@ -2155,7 +2155,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
  */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	if (dai->ops->set_fmt)
+	if (dai->ops && dai->ops->set_fmt)
 		return dai->ops->set_fmt(dai, fmt);
 	else
 		return -EINVAL;
@@ -2174,7 +2174,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int mask, int slots)
 {
-	if (dai->ops->set_sysclk)
+	if (dai->ops && dai->ops->set_tdm_slot)
 		return dai->ops->set_tdm_slot(dai, mask, slots);
 	else
 		return -EINVAL;
@@ -2190,7 +2190,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
  */
 int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
 {
-	if (dai->ops->set_sysclk)
+	if (dai->ops && dai->ops->set_tristate)
 		return dai->ops->set_tristate(dai, tristate);
 	else
 		return -EINVAL;
@@ -2206,7 +2206,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
  */
 int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
 {
-	if (dai->ops->digital_mute)
+	if (dai->ops && dai->ops->digital_mute)
 		return dai->ops->digital_mute(dai, mute);
 	else
 		return -EINVAL;

commit 06f409d76f1d382167eb1cadde2e23a73272865d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 7 18:10:13 2009 +0100

    ASoC: Provide core support for symmetric sample rates
    
    Many devices require symmetric configurations of capture and playback
    data formats, often due to shared clocking but sometimes also due to
    other shared playback and record configuration in the device. Start
    providing core support for this by allowing the DAIs or the machine
    to specify that the sample rates used should be kept symmetric.
    
    A flag symmetric_rates is provided in the snd_soc_dai and
    snd_soc_dai_link structures. If this is set in either of the DAIs or in
    the machine then a constraint will be applied when a stream is already
    open preventing any changes in sample rate.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 99712f652d0d..dd28009f8969 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -113,6 +113,35 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 }
 #endif
 
+static int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	int ret;
+
+	if (codec_dai->symmetric_rates || cpu_dai->symmetric_rates ||
+	    machine->symmetric_rates) {
+		dev_dbg(card->dev, "Symmetry forces %dHz rate\n", 
+			machine->rate);
+
+		ret = snd_pcm_hw_constraint_minmax(substream->runtime,
+						   SNDRV_PCM_HW_PARAM_RATE,
+						   machine->rate,
+						   machine->rate);
+		if (ret < 0) {
+			dev_err(card->dev,
+				"Unable to apply rate symmetry constraint: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 /*
  * Called by ALSA when a PCM substream is opened, the runtime->hw record is
  * then initialized and any private data can be allocated. This also calls
@@ -221,6 +250,13 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		goto machine_err;
 	}
 
+	/* Symmetry only applies if we've already got an active stream. */
+	if (cpu_dai->active || codec_dai->active) {
+		ret = soc_pcm_apply_symmetry(substream);
+		if (ret != 0)
+			goto machine_err;
+	}
+
 	pr_debug("asoc: %s <-> %s info:\n", codec_dai->name, cpu_dai->name);
 	pr_debug("asoc: rate mask 0x%x\n", runtime->hw.rates);
 	pr_debug("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
@@ -521,6 +557,8 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
+	machine->rate = params_rate(params);
+
 out:
 	mutex_unlock(&pcm_mutex);
 	return ret;

commit 4ac5c61f0fc9b01946911a52d827f67947ab01a8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 1 19:35:01 2009 +0100

    ASoC: Set parent for AC97 devices we register
    
    Ensure that any AC97 devices that bind to the CODEC are below the
    ASoC device in the device tree so the suspend and resume code can
    figure out what order to handle them in.
    
    Reported-by: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6c62d4a54cdf..99712f652d0d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -98,7 +98,7 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 	int err;
 
 	codec->ac97->dev.bus = &ac97_bus_type;
-	codec->ac97->dev.parent = NULL;
+	codec->ac97->dev.parent = codec->card->dev;
 	codec->ac97->dev.release = soc_ac97_device_release;
 
 	dev_set_name(&codec->ac97->dev, "%d-%d:%s",

commit 64ab9baa00fa99070da993f00173c35a8e99abfa
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 31 11:27:03 2009 +0100

    ASoC: Don't defer resume work for AC97 codecs
    
    AC97 devices may have other drivers hanging off them directly so need to
    have resumed when the resume function returns meaning that we can't defer
    the resume - complete it immediately for them. Non-AC97 devices should
    not have other drivers hanging directly off the ASoC devices.
    
    We only really need the deferral for non-AC97 devices - it's there since
    some I2C buses are very slow and non-AC97 codecs often have large numbers
    of registers to restore and require delays to bring the codec up cleanly
    leading to a substantial impact on overall resume time.
    
    Reported-by: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6e710f705a74..6c62d4a54cdf 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -767,11 +767,21 @@ static int soc_resume(struct platform_device *pdev)
 {
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_dai *cpu_dai = card->dai_link[0].cpu_dai;
 
-	dev_dbg(socdev->dev, "scheduling resume work\n");
-
-	if (!schedule_work(&card->deferred_resume_work))
-		dev_err(socdev->dev, "resume work item may be lost\n");
+	/* AC97 devices might have other drivers hanging off them so
+	 * need to resume immediately.  Other drivers don't have that
+	 * problem and may take a substantial amount of time to resume
+	 * due to I/O costs and anti-pop so handle them out of line.
+	 */
+	if (cpu_dai->ac97_control) {
+		dev_dbg(socdev->dev, "Resuming AC97 immediately\n");
+		soc_resume_deferred(&card->deferred_resume_work);
+	} else {
+		dev_dbg(socdev->dev, "Scheduling resume work\n");
+		if (!schedule_work(&card->deferred_resume_work))
+			dev_err(socdev->dev, "resume work item may be lost\n");
+	}
 
 	return 0;
 }

commit d2314e0e27566f8830ebed3587cc049e07e6a4ee
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Mar 16 23:26:20 2009 +0900

    ASoC: Only deregister AC97 dev if it's name was not "AC97"
    
    The commit 14fa43f53ff3a9c3d8b9662574b7369812a31a97 ("ASoC: Only
    register AC97 bus if it's not done already") added a condition for
    calling of soc_ac97_dev_register() but not added for calling of
    soc_ac97_dev_unregister().  This patch adds same condition for
    soc_ac97_dev_unregister().  Without this fix, kernel crashes when
    unloading an asoc driver.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 16518329f6b2..6e710f705a74 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1432,7 +1432,8 @@ void snd_soc_free_pcms(struct snd_soc_device *socdev)
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];
-		if (codec_dai->ac97_control && codec->ac97) {
+		if (codec_dai->ac97_control && codec->ac97 &&
+		    strcmp(codec->name, "AC97") != 0) {
 			soc_ac97_dev_unregister(codec);
 			goto free_card;
 		}

commit 6335d05548eece40092000aa91b64a50310d69d5
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Tue Mar 3 09:41:00 2009 +0800

    ASoC: make ops a pointer in 'struct snd_soc_dai'
    
    Considering the fact that most cpu_dai or codec_dai are using a same
    'snd_soc_dai_ops' for several similar interfaces, 'ops' would be better
    made a pointer instead, to make sharing easier and code a bit cleaner.
    
    The patch below is rather preliminary since the asoc tree is being
    actively developed, and this touches almost every piece of code,
    (and possibly many others in development need to be changed as
    well). Building of all codecs are OK, yet to every SoC, I didn't test
    that.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Acked-by: Timur Tabi <timur@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index d4b90d82a098..16518329f6b2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -133,8 +133,8 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	mutex_lock(&pcm_mutex);
 
 	/* startup the audio subsystem */
-	if (cpu_dai->ops.startup) {
-		ret = cpu_dai->ops.startup(substream, cpu_dai);
+	if (cpu_dai->ops->startup) {
+		ret = cpu_dai->ops->startup(substream, cpu_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open interface %s\n",
 				cpu_dai->name);
@@ -150,8 +150,8 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		}
 	}
 
-	if (codec_dai->ops.startup) {
-		ret = codec_dai->ops.startup(substream, codec_dai);
+	if (codec_dai->ops->startup) {
+		ret = codec_dai->ops->startup(substream, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open codec %s\n",
 				codec_dai->name);
@@ -247,8 +247,8 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		platform->pcm_ops->close(substream);
 
 platform_err:
-	if (cpu_dai->ops.shutdown)
-		cpu_dai->ops.shutdown(substream, cpu_dai);
+	if (cpu_dai->ops->shutdown)
+		cpu_dai->ops->shutdown(substream, cpu_dai);
 out:
 	mutex_unlock(&pcm_mutex);
 	return ret;
@@ -340,11 +340,11 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		snd_soc_dai_digital_mute(codec_dai, 1);
 
-	if (cpu_dai->ops.shutdown)
-		cpu_dai->ops.shutdown(substream, cpu_dai);
+	if (cpu_dai->ops->shutdown)
+		cpu_dai->ops->shutdown(substream, cpu_dai);
 
-	if (codec_dai->ops.shutdown)
-		codec_dai->ops.shutdown(substream, codec_dai);
+	if (codec_dai->ops->shutdown)
+		codec_dai->ops->shutdown(substream, codec_dai);
 
 	if (machine->ops && machine->ops->shutdown)
 		machine->ops->shutdown(substream);
@@ -408,16 +408,16 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 		}
 	}
 
-	if (codec_dai->ops.prepare) {
-		ret = codec_dai->ops.prepare(substream, codec_dai);
+	if (codec_dai->ops->prepare) {
+		ret = codec_dai->ops->prepare(substream, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: codec DAI prepare error\n");
 			goto out;
 		}
 	}
 
-	if (cpu_dai->ops.prepare) {
-		ret = cpu_dai->ops.prepare(substream, cpu_dai);
+	if (cpu_dai->ops->prepare) {
+		ret = cpu_dai->ops->prepare(substream, cpu_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: cpu DAI prepare error\n");
 			goto out;
@@ -494,8 +494,8 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
-	if (codec_dai->ops.hw_params) {
-		ret = codec_dai->ops.hw_params(substream, params, codec_dai);
+	if (codec_dai->ops->hw_params) {
+		ret = codec_dai->ops->hw_params(substream, params, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
 				codec_dai->name);
@@ -503,8 +503,8 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
-	if (cpu_dai->ops.hw_params) {
-		ret = cpu_dai->ops.hw_params(substream, params, cpu_dai);
+	if (cpu_dai->ops->hw_params) {
+		ret = cpu_dai->ops->hw_params(substream, params, cpu_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: interface %s hw params failed\n",
 				cpu_dai->name);
@@ -526,12 +526,12 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	return ret;
 
 platform_err:
-	if (cpu_dai->ops.hw_free)
-		cpu_dai->ops.hw_free(substream, cpu_dai);
+	if (cpu_dai->ops->hw_free)
+		cpu_dai->ops->hw_free(substream, cpu_dai);
 
 interface_err:
-	if (codec_dai->ops.hw_free)
-		codec_dai->ops.hw_free(substream, codec_dai);
+	if (codec_dai->ops->hw_free)
+		codec_dai->ops->hw_free(substream, codec_dai);
 
 codec_err:
 	if (machine->ops && machine->ops->hw_free)
@@ -570,11 +570,11 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 		platform->pcm_ops->hw_free(substream);
 
 	/* now free hw params for the DAI's  */
-	if (codec_dai->ops.hw_free)
-		codec_dai->ops.hw_free(substream, codec_dai);
+	if (codec_dai->ops->hw_free)
+		codec_dai->ops->hw_free(substream, codec_dai);
 
-	if (cpu_dai->ops.hw_free)
-		cpu_dai->ops.hw_free(substream, cpu_dai);
+	if (cpu_dai->ops->hw_free)
+		cpu_dai->ops->hw_free(substream, cpu_dai);
 
 	mutex_unlock(&pcm_mutex);
 	return 0;
@@ -591,8 +591,8 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	int ret;
 
-	if (codec_dai->ops.trigger) {
-		ret = codec_dai->ops.trigger(substream, cmd, codec_dai);
+	if (codec_dai->ops->trigger) {
+		ret = codec_dai->ops->trigger(substream, cmd, codec_dai);
 		if (ret < 0)
 			return ret;
 	}
@@ -603,8 +603,8 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 			return ret;
 	}
 
-	if (cpu_dai->ops.trigger) {
-		ret = cpu_dai->ops.trigger(substream, cmd, cpu_dai);
+	if (cpu_dai->ops->trigger) {
+		ret = cpu_dai->ops->trigger(substream, cmd, cpu_dai);
 		if (ret < 0)
 			return ret;
 	}
@@ -645,8 +645,8 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	/* mute any active DAC's */
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
-		if (dai->ops.digital_mute && dai->playback.active)
-			dai->ops.digital_mute(dai, 1);
+		if (dai->ops->digital_mute && dai->playback.active)
+			dai->ops->digital_mute(dai, 1);
 	}
 
 	/* suspend all pcms */
@@ -741,8 +741,8 @@ static void soc_resume_deferred(struct work_struct *work)
 	/* unmute any active DACs */
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
-		if (dai->ops.digital_mute && dai->playback.active)
-			dai->ops.digital_mute(dai, 0);
+		if (dai->ops->digital_mute && dai->playback.active)
+			dai->ops->digital_mute(dai, 0);
 	}
 
 	for (i = 0; i < card->num_links; i++) {
@@ -2051,8 +2051,8 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 	unsigned int freq, int dir)
 {
-	if (dai->ops.set_sysclk)
-		return dai->ops.set_sysclk(dai, clk_id, freq, dir);
+	if (dai->ops->set_sysclk)
+		return dai->ops->set_sysclk(dai, clk_id, freq, dir);
 	else
 		return -EINVAL;
 }
@@ -2071,8 +2071,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
 	int div_id, int div)
 {
-	if (dai->ops.set_clkdiv)
-		return dai->ops.set_clkdiv(dai, div_id, div);
+	if (dai->ops->set_clkdiv)
+		return dai->ops->set_clkdiv(dai, div_id, div);
 	else
 		return -EINVAL;
 }
@@ -2090,8 +2090,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
 	int pll_id, unsigned int freq_in, unsigned int freq_out)
 {
-	if (dai->ops.set_pll)
-		return dai->ops.set_pll(dai, pll_id, freq_in, freq_out);
+	if (dai->ops->set_pll)
+		return dai->ops->set_pll(dai, pll_id, freq_in, freq_out);
 	else
 		return -EINVAL;
 }
@@ -2106,8 +2106,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
  */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	if (dai->ops.set_fmt)
-		return dai->ops.set_fmt(dai, fmt);
+	if (dai->ops->set_fmt)
+		return dai->ops->set_fmt(dai, fmt);
 	else
 		return -EINVAL;
 }
@@ -2125,8 +2125,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int mask, int slots)
 {
-	if (dai->ops.set_sysclk)
-		return dai->ops.set_tdm_slot(dai, mask, slots);
+	if (dai->ops->set_sysclk)
+		return dai->ops->set_tdm_slot(dai, mask, slots);
 	else
 		return -EINVAL;
 }
@@ -2141,8 +2141,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
  */
 int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
 {
-	if (dai->ops.set_sysclk)
-		return dai->ops.set_tristate(dai, tristate);
+	if (dai->ops->set_sysclk)
+		return dai->ops->set_tristate(dai, tristate);
 	else
 		return -EINVAL;
 }
@@ -2157,8 +2157,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
  */
 int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
 {
-	if (dai->ops.digital_mute)
-		return dai->ops.digital_mute(dai, mute);
+	if (dai->ops->digital_mute)
+		return dai->ops->digital_mute(dai, mute);
 	else
 		return -EINVAL;
 }
@@ -2211,6 +2211,9 @@ static int snd_soc_unregister_card(struct snd_soc_card *card)
 	return 0;
 }
 
+static struct snd_soc_dai_ops null_dai_ops = {
+};
+
 /**
  * snd_soc_register_dai - Register a DAI with the ASoC core
  *
@@ -2225,6 +2228,9 @@ int snd_soc_register_dai(struct snd_soc_dai *dai)
 	if (!dai->dev)
 		printk(KERN_WARNING "No device for DAI %s\n", dai->name);
 
+	if (!dai->ops)
+		dai->ops = &null_dai_ops;
+
 	INIT_LIST_HEAD(&dai->list);
 
 	mutex_lock(&client_mutex);

commit c85e5a4161b4768599deaee7a5df3ded9c34ea3b
Merge: d5e9ba1d58b6 14fa43f53ff3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Feb 13 14:02:08 2009 +0000

    Merge branch 'for-2.6.29' into for-2.6.30

commit 14fa43f53ff3a9c3d8b9662574b7369812a31a97
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 12 19:33:19 2009 +0000

    ASoC: Only register AC97 bus if it's not done already
    
    ASoC supports both explicit codec drivers for AC97 devices and a simple
    driver which uses the standard ALSA AC97 framework for codec support.
    When used with the generic AC97 codec support that will provide the
    ad hoc AC97 device for drivers like touchscreens to attach to so the
    core shouldn't do so.
    
    Reported-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 55fdb4abb179..ec3f8bb4b51d 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1385,7 +1385,10 @@ int snd_soc_init_card(struct snd_soc_device *socdev)
 
 	mutex_lock(&codec->mutex);
 #ifdef CONFIG_SND_SOC_AC97_BUS
-	if (ac97) {
+	/* Only instantiate AC97 if not already done by the adaptor
+	 * for the generic AC97 subsystem.
+	 */
+	if (ac97 && strcmp(codec->name, "AC97") != 0) {
 		ret = soc_ac97_dev_register(codec);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: AC97 device register failed\n");

commit 67fcdead3c7424d51e7108c220c9ab1a5e752ed3
Merge: 006f367e38fb b1a0aac05f04
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 08:08:32 2009 +0100

    Merge branch 'topic/snd_card_new-err' into topic/asoc
    
    Conflicts:
            sound/soc/soc-core.c

commit 6627a653bceb3a54e55e5cdc478ec5b8d5c9cc44
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jan 23 22:55:23 2009 +0000

    ASoC: Push the codec runtime storage into the card structure
    
    This is a further stage on the road to refactoring away the ASoC
    platform device.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8313d52a6e8c..f18c7a3e36d1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -234,7 +234,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		cpu_dai->capture.active = codec_dai->capture.active = 1;
 	cpu_dai->active = codec_dai->active = 1;
 	cpu_dai->runtime = runtime;
-	socdev->codec->active++;
+	card->codec->active++;
 	mutex_unlock(&pcm_mutex);
 	return 0;
 
@@ -264,7 +264,7 @@ static void close_delayed_work(struct work_struct *work)
 	struct snd_soc_card *card = container_of(work, struct snd_soc_card,
 						 delayed_work.work);
 	struct snd_soc_device *socdev = card->socdev;
-	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec *codec = card->codec;
 	struct snd_soc_dai *codec_dai;
 	int i;
 
@@ -319,7 +319,7 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
-	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec *codec = card->codec;
 
 	mutex_lock(&pcm_mutex);
 
@@ -387,7 +387,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
-	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec *codec = card->codec;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
@@ -553,7 +553,7 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
-	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec *codec = card->codec;
 
 	mutex_lock(&pcm_mutex);
 
@@ -629,7 +629,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
-	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec *codec = card->codec;
 	int i;
 
 	/* Due to the resume being scheduled into a workqueue we could
@@ -705,7 +705,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	struct snd_soc_device *socdev = card->socdev;
 	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
-	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec *codec = card->codec;
 	struct platform_device *pdev = to_platform_device(socdev->dev);
 	int i;
 
@@ -982,8 +982,8 @@ static struct platform_driver soc_driver = {
 static int soc_new_pcm(struct snd_soc_device *socdev,
 	struct snd_soc_dai_link *dai_link, int num)
 {
-	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_codec *codec = card->codec;
 	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *codec_dai = dai_link->codec_dai;
 	struct snd_soc_dai *cpu_dai = dai_link->cpu_dai;
@@ -998,7 +998,7 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 
 	rtd->dai = dai_link;
 	rtd->socdev = socdev;
-	codec_dai->codec = socdev->codec;
+	codec_dai->codec = card->codec;
 
 	/* check client and interface hw capabilities */
 	sprintf(new_name, "%s %s-%d", dai_link->stream_name, codec_dai->name,
@@ -1048,9 +1048,8 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 }
 
 /* codec register dump */
-static ssize_t soc_codec_reg_show(struct snd_soc_device *devdata, char *buf)
+static ssize_t soc_codec_reg_show(struct snd_soc_codec *codec, char *buf)
 {
-	struct snd_soc_codec *codec = devdata->codec;
 	int i, step = 1, count = 0;
 
 	if (!codec->reg_cache_size)
@@ -1090,7 +1089,7 @@ static ssize_t codec_reg_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	struct snd_soc_device *devdata = dev_get_drvdata(dev);
-	return soc_codec_reg_show(devdata, buf);
+	return soc_codec_reg_show(devdata->card->codec, buf);
 }
 
 static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
@@ -1107,12 +1106,10 @@ static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
 {
 	ssize_t ret;
 	struct snd_soc_codec *codec = file->private_data;
-	struct device *card_dev = codec->card->dev;
-	struct snd_soc_device *devdata = card_dev->driver_data;
 	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
-	ret = soc_codec_reg_show(devdata, buf);
+	ret = soc_codec_reg_show(codec, buf);
 	if (ret >= 0)
 		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
 	kfree(buf);
@@ -1309,8 +1306,8 @@ EXPORT_SYMBOL_GPL(snd_soc_test_bits);
  */
 int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 {
-	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_codec *codec = card->codec;
 	int ret = 0, i;
 
 	mutex_lock(&codec->mutex);
@@ -1355,8 +1352,8 @@ EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
  */
 int snd_soc_init_card(struct snd_soc_device *socdev)
 {
-	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_codec *codec = card->codec;
 	int ret = 0, i, ac97 = 0, err = 0;
 
 	for (i = 0; i < card->num_links; i++) {
@@ -1404,7 +1401,7 @@ int snd_soc_init_card(struct snd_soc_device *socdev)
 	if (err < 0)
 		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
 
-	soc_init_codec_debugfs(socdev->codec);
+	soc_init_codec_debugfs(codec);
 	mutex_unlock(&codec->mutex);
 
 out:
@@ -1421,14 +1418,14 @@ EXPORT_SYMBOL_GPL(snd_soc_init_card);
  */
 void snd_soc_free_pcms(struct snd_soc_device *socdev)
 {
-	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec *codec = socdev->card->codec;
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	struct snd_soc_dai *codec_dai;
 	int i;
 #endif
 
 	mutex_lock(&codec->mutex);
-	soc_cleanup_codec_debugfs(socdev->codec);
+	soc_cleanup_codec_debugfs(codec);
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];

commit bd7dd77c2a05c530684eea2e3af16449ae9c5d52
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:45:02 2008 +0100

    ALSA: Convert to snd_card_create() in other sound/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in other sound subdirectories.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6cbe7e82f238..318dfdd54d7f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1311,17 +1311,17 @@ int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 {
 	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_card *card = socdev->card;
-	int ret = 0, i;
+	int ret, i;
 
 	mutex_lock(&codec->mutex);
 
 	/* register a sound card */
-	codec->card = snd_card_new(idx, xid, codec->owner, 0);
-	if (!codec->card) {
+	ret = snd_card_create(idx, xid, codec->owner, 0, &codec->card);
+	if (ret < 0) {
 		printk(KERN_ERR "asoc: can't create sound card for codec %s\n",
 			codec->name);
 		mutex_unlock(&codec->mutex);
-		return -ENODEV;
+		return ret;
 	}
 
 	codec->card->dev = socdev->dev;

commit 5852973c129cf7c7e6c229abb7250673fc2a50c9
Merge: 3e8e1952e3a3 c6d1662b2294
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jan 9 11:03:55 2009 +0000

    Merge branch 'for-2.6.29' into for-2.6.30

commit 3e8e1952e3a3dd59b11233a532ca68e6471742d9
Author: Ian Molton <ian@mnementh.co.uk>
Date:   Fri Jan 9 00:23:21 2009 +0000

    ASoC: cleanup duplicated code.
    
    Many codec drivers were implementing cookie-cutter copies of the function
    that adds kcontrols to the codec.
    
    This patch moves this code to a common function snd_soc_add_controls() in
    soc-core.c and updates all drivers using copies of this function to use the
    new common version.
    
    [Edited to raise priority of error log message and document parameters.
     -- broonie]
    
    Signed-off-by: Ian Molton <ian@mnementh.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6cbe7e82f238..d3b97a7542e0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1494,6 +1494,37 @@ struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
 }
 EXPORT_SYMBOL_GPL(snd_soc_cnew);
 
+/**
+ * snd_soc_add_controls - add an array of controls to a codec.
+ * Convienience function to add a list of controls. Many codecs were
+ * duplicating this code.
+ *
+ * @codec: codec to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_controls(struct snd_soc_codec *codec,
+	const struct snd_kcontrol_new *controls, int num_controls)
+{
+	struct snd_card *card = codec->card;
+	int err, i;
+
+	for (i = 0; i < num_controls; i++) {
+		const struct snd_kcontrol_new *control = &controls[i];
+		err = snd_ctl_add(card, snd_soc_cnew(control, codec, NULL));
+		if (err < 0) {
+			dev_err(codec->dev, "%s: Failed to add %s\n",
+				codec->name, control->name);
+			return err;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_controls);
+
 /**
  * snd_soc_info_enum_double - enumerated double mixer info callback
  * @kcontrol: mixer control

commit 741555568f8ba307c626019787c412f4386cafdc
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Thu Jan 8 13:34:29 2009 +0200

    ASoC: Merge the soc_value_enum to soc_enum struct
    
    Merge the recently introduced soc_value_enum structure to the soc_enum.
    The value based enums are still handled separately from the normal enum types,
    but with the merge some of the newly introduced functions can be removed.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6cbe7e82f238..55fdb4abb179 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1584,37 +1584,6 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
 
-/**
- * snd_soc_info_value_enum_double - semi enumerated double mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a double semi enumerated
- * mixer control.
- *
- * Semi enumerated mixer: the enumerated items are referred as values. Can be
- * used for handling bitfield coded enumeration for example.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_value_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_value_enum *e = (struct soc_value_enum *)
-			kcontrol->private_value;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
-	uinfo->value.enumerated.items = e->max;
-
-	if (uinfo->value.enumerated.item > e->max - 1)
-		uinfo->value.enumerated.item = e->max - 1;
-	strcpy(uinfo->value.enumerated.name,
-		e->texts[uinfo->value.enumerated.item]);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_value_enum_double);
-
 /**
  * snd_soc_get_value_enum_double - semi enumerated double mixer get callback
  * @kcontrol: mixer control
@@ -1631,8 +1600,7 @@ int snd_soc_get_value_enum_double(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_value_enum *e = (struct soc_value_enum *)
-			kcontrol->private_value;
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned short reg_val, val, mux;
 
 	reg_val = snd_soc_read(codec, e->reg);
@@ -1671,8 +1639,7 @@ int snd_soc_put_value_enum_double(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_value_enum *e = (struct soc_value_enum *)
-			kcontrol->private_value;
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned short val;
 	unsigned short mask;
 

commit 2e72f8e3716bc3bbf4c9b5b987fb5ab3223f60bf
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Mon Jan 5 09:54:57 2009 +0200

    ASoC: New enum type: value_enum
    
    This patch introduces a new enum type.
    In this enum type each enumerated items referred with a value.
    
    This new enum type can handle enums encoded in bitfield, or any other
    weird ways. twl4030 codec has several mux selection register, where the
    input/output mux is coded in a bitfield. With the normal enum type this type
    of mux can not be handled in a clean way.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f73c1341437c..6cbe7e82f238 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1584,6 +1584,113 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
 
+/**
+ * snd_soc_info_value_enum_double - semi enumerated double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double semi enumerated
+ * mixer control.
+ *
+ * Semi enumerated mixer: the enumerated items are referred as values. Can be
+ * used for handling bitfield coded enumeration for example.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_value_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_value_enum *e = (struct soc_value_enum *)
+			kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
+	uinfo->value.enumerated.items = e->max;
+
+	if (uinfo->value.enumerated.item > e->max - 1)
+		uinfo->value.enumerated.item = e->max - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_value_enum_double);
+
+/**
+ * snd_soc_get_value_enum_double - semi enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a double semi enumerated mixer.
+ *
+ * Semi enumerated mixer: the enumerated items are referred as values. Can be
+ * used for handling bitfield coded enumeration for example.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_value_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_value_enum *e = (struct soc_value_enum *)
+			kcontrol->private_value;
+	unsigned short reg_val, val, mux;
+
+	reg_val = snd_soc_read(codec, e->reg);
+	val = (reg_val >> e->shift_l) & e->mask;
+	for (mux = 0; mux < e->max; mux++) {
+		if (val == e->values[mux])
+			break;
+	}
+	ucontrol->value.enumerated.item[0] = mux;
+	if (e->shift_l != e->shift_r) {
+		val = (reg_val >> e->shift_r) & e->mask;
+		for (mux = 0; mux < e->max; mux++) {
+			if (val == e->values[mux])
+				break;
+		}
+		ucontrol->value.enumerated.item[1] = mux;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_value_enum_double);
+
+/**
+ * snd_soc_put_value_enum_double - semi enumerated double mixer put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a double semi enumerated mixer.
+ *
+ * Semi enumerated mixer: the enumerated items are referred as values. Can be
+ * used for handling bitfield coded enumeration for example.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_value_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_value_enum *e = (struct soc_value_enum *)
+			kcontrol->private_value;
+	unsigned short val;
+	unsigned short mask;
+
+	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+		return -EINVAL;
+	val = e->values[ucontrol->value.enumerated.item[0]] << e->shift_l;
+	mask = e->mask << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+			return -EINVAL;
+		val |= e->values[ucontrol->value.enumerated.item[1]] << e->shift_r;
+		mask |= e->mask << e->shift_r;
+	}
+
+	return snd_soc_update_bits(codec, e->reg, mask, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_value_enum_double);
+
 /**
  * snd_soc_info_enum_ext - external enumerated single mixer info callback
  * @kcontrol: mixer control

commit ac11a2b35cc25c77d28218aaf60e7f7c6c7ee5d3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jan 1 12:18:17 2009 +0000

    ASoC: Clean up kerneldoc warnings
    
    Almost all parameters that have been misnamed in the comments.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b098c0b4c584..f73c1341437c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1300,6 +1300,8 @@ EXPORT_SYMBOL_GPL(snd_soc_test_bits);
 /**
  * snd_soc_new_pcms - create new sound card and pcms
  * @socdev: the SoC audio device
+ * @idx: ALSA card index
+ * @xid: card identification
  *
  * Create a new sound card based upon the codec and interface pcms.
  *
@@ -1472,7 +1474,7 @@ EXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);
  * snd_soc_cnew - create new control
  * @_template: control template
  * @data: control private data
- * @lnng_name: control long name
+ * @long_name: control long name
  *
  * Create a new mixer control from a template control.
  *
@@ -1522,7 +1524,7 @@ EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
 /**
  * snd_soc_get_enum_double - enumerated double mixer get callback
  * @kcontrol: mixer control
- * @uinfo: control element information
+ * @ucontrol: control element information
  *
  * Callback to get the value of a double enumerated mixer.
  *
@@ -1551,7 +1553,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
 /**
  * snd_soc_put_enum_double - enumerated double mixer put callback
  * @kcontrol: mixer control
- * @uinfo: control element information
+ * @ucontrol: control element information
  *
  * Callback to set the value of a double enumerated mixer.
  *
@@ -1668,7 +1670,7 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
 /**
  * snd_soc_get_volsw - single mixer get callback
  * @kcontrol: mixer control
- * @uinfo: control element information
+ * @ucontrol: control element information
  *
  * Callback to get the value of a single mixer control.
  *
@@ -1707,7 +1709,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
 /**
  * snd_soc_put_volsw - single mixer put callback
  * @kcontrol: mixer control
- * @uinfo: control element information
+ * @ucontrol: control element information
  *
  * Callback to set the value of a single mixer control.
  *
@@ -1775,7 +1777,7 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
 /**
  * snd_soc_get_volsw_2r - double mixer get callback
  * @kcontrol: mixer control
- * @uinfo: control element information
+ * @ucontrol: control element information
  *
  * Callback to get the value of a double mixer control that spans 2 registers.
  *
@@ -1812,7 +1814,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r);
 /**
  * snd_soc_put_volsw_2r - double mixer set callback
  * @kcontrol: mixer control
- * @uinfo: control element information
+ * @ucontrol: control element information
  *
  * Callback to set the value of a double mixer control that spans 2 registers.
  *
@@ -1882,7 +1884,7 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_s8);
 /**
  * snd_soc_get_volsw_s8 - signed mixer get callback
  * @kcontrol: mixer control
- * @uinfo: control element information
+ * @ucontrol: control element information
  *
  * Callback to get the value of a signed mixer control.
  *
@@ -1909,7 +1911,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw_s8);
 /**
  * snd_soc_put_volsw_sgn - signed mixer put callback
  * @kcontrol: mixer control
- * @uinfo: control element information
+ * @ucontrol: control element information
  *
  * Callback to set the value of a signed mixer control.
  *
@@ -1954,7 +1956,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 /**
  * snd_soc_dai_set_clkdiv - configure DAI clock dividers.
  * @dai: DAI
- * @clk_id: DAI specific clock divider ID
+ * @div_id: DAI specific clock divider ID
  * @div: new clock divisor.
  *
  * Configures the clock dividers. This is used to derive the best DAI bit and
@@ -2060,7 +2062,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 /**
  * snd_soc_register_card - Register a card with the ASoC core
  *
- * @param card Card to register
+ * @card: Card to register
  *
  * Note that currently this is an internal only function: it will be
  * exposed to machine drivers after further backporting of ASoC v2
@@ -2087,7 +2089,7 @@ static int snd_soc_register_card(struct snd_soc_card *card)
 /**
  * snd_soc_unregister_card - Unregister a card with the ASoC core
  *
- * @param card Card to unregister
+ * @card: Card to unregister
  *
  * Note that currently this is an internal only function: it will be
  * exposed to machine drivers after further backporting of ASoC v2
@@ -2107,7 +2109,7 @@ static int snd_soc_unregister_card(struct snd_soc_card *card)
 /**
  * snd_soc_register_dai - Register a DAI with the ASoC core
  *
- * @param dai DAI to register
+ * @dai: DAI to register
  */
 int snd_soc_register_dai(struct snd_soc_dai *dai)
 {
@@ -2134,7 +2136,7 @@ EXPORT_SYMBOL_GPL(snd_soc_register_dai);
 /**
  * snd_soc_unregister_dai - Unregister a DAI from the ASoC core
  *
- * @param dai DAI to unregister
+ * @dai: DAI to unregister
  */
 void snd_soc_unregister_dai(struct snd_soc_dai *dai)
 {
@@ -2149,8 +2151,8 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
 /**
  * snd_soc_register_dais - Register multiple DAIs with the ASoC core
  *
- * @param dai Array of DAIs to register
- * @param count Number of DAIs
+ * @dai: Array of DAIs to register
+ * @count: Number of DAIs
  */
 int snd_soc_register_dais(struct snd_soc_dai *dai, size_t count)
 {
@@ -2175,8 +2177,8 @@ EXPORT_SYMBOL_GPL(snd_soc_register_dais);
 /**
  * snd_soc_unregister_dais - Unregister multiple DAIs from the ASoC core
  *
- * @param dai Array of DAIs to unregister
- * @param count Number of DAIs
+ * @dai: Array of DAIs to unregister
+ * @count: Number of DAIs
  */
 void snd_soc_unregister_dais(struct snd_soc_dai *dai, size_t count)
 {
@@ -2190,7 +2192,7 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_dais);
 /**
  * snd_soc_register_platform - Register a platform with the ASoC core
  *
- * @param platform platform to register
+ * @platform: platform to register
  */
 int snd_soc_register_platform(struct snd_soc_platform *platform)
 {
@@ -2213,7 +2215,7 @@ EXPORT_SYMBOL_GPL(snd_soc_register_platform);
 /**
  * snd_soc_unregister_platform - Unregister a platform from the ASoC core
  *
- * @param platform platform to unregister
+ * @platform: platform to unregister
  */
 void snd_soc_unregister_platform(struct snd_soc_platform *platform)
 {
@@ -2228,7 +2230,7 @@ EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);
 /**
  * snd_soc_register_codec - Register a codec with the ASoC core
  *
- * @param codec codec to register
+ * @codec: codec to register
  */
 int snd_soc_register_codec(struct snd_soc_codec *codec)
 {
@@ -2255,7 +2257,7 @@ EXPORT_SYMBOL_GPL(snd_soc_register_codec);
 /**
  * snd_soc_unregister_codec - Unregister a codec from the ASoC core
  *
- * @param codec codec to unregister
+ * @codec: codec to unregister
  */
 void snd_soc_unregister_codec(struct snd_soc_codec *codec)
 {

commit 0d0cf00a7fc63cee9a4c4a3b8612879b4f7f42ba
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 10 14:32:45 2008 +0000

    ASoC: Add codec registration API
    
    Another part of the backporting of Liam's ASoC v2 work. Using this is
    more complicated than the other registration types since currently the
    codec is instantiated during the probe of the ASoC device so we can't
    currently readily wait for the codec to register.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4d2db7cfaf4c..b098c0b4c584 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -47,6 +47,7 @@ static DEFINE_MUTEX(client_mutex);
 static LIST_HEAD(card_list);
 static LIST_HEAD(dai_list);
 static LIST_HEAD(platform_list);
+static LIST_HEAD(codec_list);
 
 static int snd_soc_register_card(struct snd_soc_card *card);
 static int snd_soc_unregister_card(struct snd_soc_card *card);
@@ -2224,6 +2225,48 @@ void snd_soc_unregister_platform(struct snd_soc_platform *platform)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);
 
+/**
+ * snd_soc_register_codec - Register a codec with the ASoC core
+ *
+ * @param codec codec to register
+ */
+int snd_soc_register_codec(struct snd_soc_codec *codec)
+{
+	if (!codec->name)
+		return -EINVAL;
+
+	/* The device should become mandatory over time */
+	if (!codec->dev)
+		printk(KERN_WARNING "No device for codec %s\n", codec->name);
+
+	INIT_LIST_HEAD(&codec->list);
+
+	mutex_lock(&client_mutex);
+	list_add(&codec->list, &codec_list);
+	snd_soc_instantiate_cards();
+	mutex_unlock(&client_mutex);
+
+	pr_debug("Registered codec '%s'\n", codec->name);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_codec);
+
+/**
+ * snd_soc_unregister_codec - Unregister a codec from the ASoC core
+ *
+ * @param codec codec to unregister
+ */
+void snd_soc_unregister_codec(struct snd_soc_codec *codec)
+{
+	mutex_lock(&client_mutex);
+	list_del(&codec->list);
+	mutex_unlock(&client_mutex);
+
+	pr_debug("Unregistered codec '%s'\n", codec->name);
+}
+EXPORT_SYMBOL_GPL(snd_soc_unregister_codec);
+
 static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS

commit c9b3a40ff2b3dea9914e36965a17c802650bb603
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Dec 10 07:47:22 2008 +0100

    ALSA: ASoC - Fix wrong section types
    
    The module init entries should be __init instead of __devinit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 76a89eb65baf..4d2db7cfaf4c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2224,7 +2224,7 @@ void snd_soc_unregister_platform(struct snd_soc_platform *platform)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);
 
-static int __devinit snd_soc_init(void)
+static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS
 	debugfs_root = debugfs_create_dir("asoc", NULL);

commit 6b05eda6383d89bffc21da654d148733e7839540
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 8 19:26:48 2008 +0000

    ASoC: Wait for non-AC97 codec DAIs before instantiating
    
    This will allow codec drivers to be refactored to allow them to be
    registered out of line with the ASoC device registration.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 717db0e6499b..76a89eb65baf 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -788,7 +788,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	struct snd_soc_codec_device *codec_dev = card->socdev->codec_dev;
 	struct snd_soc_platform *platform;
 	struct snd_soc_dai *dai;
-	int i, found, ret;
+	int i, found, ret, ac97;
 
 	if (card->instantiated)
 		return;
@@ -805,6 +805,7 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		return;
 	}
 
+	ac97 = 0;
 	for (i = 0; i < card->num_links; i++) {
 		found = 0;
 		list_for_each_entry(dai, &dai_list, list)
@@ -817,8 +818,32 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 				card->dai_link[i].cpu_dai->name);
 			return;
 		}
+
+		if (card->dai_link[i].cpu_dai->ac97_control)
+			ac97 = 1;
 	}
 
+	/* If we have AC97 in the system then don't wait for the
+	 * codec.  This will need revisiting if we have to handle
+	 * systems with mixed AC97 and non-AC97 parts.  Only check for
+	 * DAIs currently; we can't do this per link since some AC97
+	 * codecs have non-AC97 DAIs.
+	 */
+	if (!ac97)
+		for (i = 0; i < card->num_links; i++) {
+			found = 0;
+			list_for_each_entry(dai, &dai_list, list)
+				if (card->dai_link[i].codec_dai == dai) {
+					found = 1;
+					break;
+				}
+			if (!found) {
+				dev_dbg(card->dev, "DAI %s not registered\n",
+					card->dai_link[i].codec_dai->name);
+				return;
+			}
+		}
+
 	/* Note that we do not current check for codec components */
 
 	dev_dbg(card->dev, "All components present, instantiating\n");

commit 435c5e2588893e3f7aba0bd4de67991bf00b3c9d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 4 15:32:53 2008 +0000

    ASoC: Initial framework for dynamic card instantiation
    
    Use the lists of platforms, platform DAIs and cards to check to see that
    everything has registered. Since relationships are still specified by
    direct references to the structures in the drivers and the drivers all
    register everything at modprobe there should be no practical effect yet.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ffae370b45df..717db0e6499b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -780,30 +780,54 @@ static int soc_resume(struct platform_device *pdev)
 #define soc_resume	NULL
 #endif
 
-/* probes a new socdev */
-static int soc_probe(struct platform_device *pdev)
-{
-	int ret = 0, i;
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = card->platform;
-	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
-
-	/* Bodge while we push things out of socdev */
-	card->socdev = socdev;
+static void snd_soc_instantiate_card(struct snd_soc_card *card)
+{
+	struct platform_device *pdev = container_of(card->dev,
+						    struct platform_device,
+						    dev);
+	struct snd_soc_codec_device *codec_dev = card->socdev->codec_dev;
+	struct snd_soc_platform *platform;
+	struct snd_soc_dai *dai;
+	int i, found, ret;
+
+	if (card->instantiated)
+		return;
+
+	found = 0;
+	list_for_each_entry(platform, &platform_list, list)
+		if (card->platform == platform) {
+			found = 1;
+			break;
+		}
+	if (!found) {
+		dev_dbg(card->dev, "Platform %s not registered\n",
+			card->platform->name);
+		return;
+	}
 
-	/* Bodge while we unpick instantiation */
-	card->dev = &pdev->dev;
-	ret = snd_soc_register_card(card);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "Failed to register card\n");
-		return ret;
+	for (i = 0; i < card->num_links; i++) {
+		found = 0;
+		list_for_each_entry(dai, &dai_list, list)
+			if (card->dai_link[i].cpu_dai == dai) {
+				found = 1;
+				break;
+			}
+		if (!found) {
+			dev_dbg(card->dev, "DAI %s not registered\n",
+				card->dai_link[i].cpu_dai->name);
+			return;
+		}
 	}
 
+	/* Note that we do not current check for codec components */
+
+	dev_dbg(card->dev, "All components present, instantiating\n");
+
+	/* Found everything, bring it up */
 	if (card->probe) {
 		ret = card->probe(pdev);
 		if (ret < 0)
-			return ret;
+			return;
 	}
 
 	for (i = 0; i < card->num_links; i++) {
@@ -834,7 +858,9 @@ static int soc_probe(struct platform_device *pdev)
 	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
 #endif
 
-	return 0;
+	card->instantiated = 1;
+
+	return;
 
 platform_err:
 	if (codec_dev->remove)
@@ -849,8 +875,38 @@ static int soc_probe(struct platform_device *pdev)
 
 	if (card->remove)
 		card->remove(pdev);
+}
 
-	return ret;
+/*
+ * Attempt to initialise any uninitalised cards.  Must be called with
+ * client_mutex.
+ */
+static void snd_soc_instantiate_cards(void)
+{
+	struct snd_soc_card *card;
+	list_for_each_entry(card, &card_list, list)
+		snd_soc_instantiate_card(card);
+}
+
+/* probes a new socdev */
+static int soc_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_card *card = socdev->card;
+
+	/* Bodge while we push things out of socdev */
+	card->socdev = socdev;
+
+	/* Bodge while we unpick instantiation */
+	card->dev = &pdev->dev;
+	ret = snd_soc_register_card(card);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to register card\n");
+		return ret;
+	}
+
+	return 0;
 }
 
 /* removes a socdev */
@@ -1994,6 +2050,7 @@ static int snd_soc_register_card(struct snd_soc_card *card)
 
 	mutex_lock(&client_mutex);
 	list_add(&card->list, &card_list);
+	snd_soc_instantiate_cards();
 	mutex_unlock(&client_mutex);
 
 	dev_dbg(card->dev, "Registered card '%s'\n", card->name);
@@ -2039,6 +2096,7 @@ int snd_soc_register_dai(struct snd_soc_dai *dai)
 
 	mutex_lock(&client_mutex);
 	list_add(&dai->list, &dai_list);
+	snd_soc_instantiate_cards();
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Registered DAI '%s'\n", dai->name);
@@ -2117,6 +2175,7 @@ int snd_soc_register_platform(struct snd_soc_platform *platform)
 
 	mutex_lock(&client_mutex);
 	list_add(&platform->list, &platform_list);
+	snd_soc_instantiate_cards();
 	mutex_unlock(&client_mutex);
 
 	pr_debug("Registered platform '%s'\n", platform->name);

commit 12a48a8c0087ba39d926cf1d63938ccbdb9752c3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 3 19:40:30 2008 +0000

    ASoC: Add platform registration API
    
    ASoC v2 allows platform drivers to instantiate independantly of the
    overall ASoC card. This API allows drivers to notify the core when
    they are registered.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 03460b068f1e..ffae370b45df 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -46,6 +46,7 @@ static struct dentry *debugfs_root;
 static DEFINE_MUTEX(client_mutex);
 static LIST_HEAD(card_list);
 static LIST_HEAD(dai_list);
+static LIST_HEAD(platform_list);
 
 static int snd_soc_register_card(struct snd_soc_card *card);
 static int snd_soc_unregister_card(struct snd_soc_card *card);
@@ -2102,6 +2103,43 @@ void snd_soc_unregister_dais(struct snd_soc_dai *dai, size_t count)
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_dais);
 
+/**
+ * snd_soc_register_platform - Register a platform with the ASoC core
+ *
+ * @param platform platform to register
+ */
+int snd_soc_register_platform(struct snd_soc_platform *platform)
+{
+	if (!platform->name)
+		return -EINVAL;
+
+	INIT_LIST_HEAD(&platform->list);
+
+	mutex_lock(&client_mutex);
+	list_add(&platform->list, &platform_list);
+	mutex_unlock(&client_mutex);
+
+	pr_debug("Registered platform '%s'\n", platform->name);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_platform);
+
+/**
+ * snd_soc_unregister_platform - Unregister a platform from the ASoC core
+ *
+ * @param platform platform to unregister
+ */
+void snd_soc_unregister_platform(struct snd_soc_platform *platform)
+{
+	mutex_lock(&client_mutex);
+	list_del(&platform->list);
+	mutex_unlock(&client_mutex);
+
+	pr_debug("Unregistered platform '%s'\n", platform->name);
+}
+EXPORT_SYMBOL_GPL(snd_soc_unregister_platform);
+
 static int __devinit snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS

commit 9115171a6b79b6b4d5c6697f123556b6efc37f1f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Nov 30 23:31:24 2008 +0000

    ASoC: Add DAI registration API
    
    Add API calls to register and unregister DAIs with the core.  Currently
    these APIs are ineffective.  Since multiple DAIs for a given device are
    a common case bulk variants are provided.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 44fbd71ce80f..03460b068f1e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -45,6 +45,7 @@ static struct dentry *debugfs_root;
 
 static DEFINE_MUTEX(client_mutex);
 static LIST_HEAD(card_list);
+static LIST_HEAD(dai_list);
 
 static int snd_soc_register_card(struct snd_soc_card *card);
 static int snd_soc_unregister_card(struct snd_soc_card *card);
@@ -2019,6 +2020,88 @@ static int snd_soc_unregister_card(struct snd_soc_card *card)
 	return 0;
 }
 
+/**
+ * snd_soc_register_dai - Register a DAI with the ASoC core
+ *
+ * @param dai DAI to register
+ */
+int snd_soc_register_dai(struct snd_soc_dai *dai)
+{
+	if (!dai->name)
+		return -EINVAL;
+
+	/* The device should become mandatory over time */
+	if (!dai->dev)
+		printk(KERN_WARNING "No device for DAI %s\n", dai->name);
+
+	INIT_LIST_HEAD(&dai->list);
+
+	mutex_lock(&client_mutex);
+	list_add(&dai->list, &dai_list);
+	mutex_unlock(&client_mutex);
+
+	pr_debug("Registered DAI '%s'\n", dai->name);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_dai);
+
+/**
+ * snd_soc_unregister_dai - Unregister a DAI from the ASoC core
+ *
+ * @param dai DAI to unregister
+ */
+void snd_soc_unregister_dai(struct snd_soc_dai *dai)
+{
+	mutex_lock(&client_mutex);
+	list_del(&dai->list);
+	mutex_unlock(&client_mutex);
+
+	pr_debug("Unregistered DAI '%s'\n", dai->name);
+}
+EXPORT_SYMBOL_GPL(snd_soc_unregister_dai);
+
+/**
+ * snd_soc_register_dais - Register multiple DAIs with the ASoC core
+ *
+ * @param dai Array of DAIs to register
+ * @param count Number of DAIs
+ */
+int snd_soc_register_dais(struct snd_soc_dai *dai, size_t count)
+{
+	int i, ret;
+
+	for (i = 0; i < count; i++) {
+		ret = snd_soc_register_dai(&dai[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	for (i--; i >= 0; i--)
+		snd_soc_unregister_dai(&dai[i]);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_dais);
+
+/**
+ * snd_soc_unregister_dais - Unregister multiple DAIs from the ASoC core
+ *
+ * @param dai Array of DAIs to unregister
+ * @param count Number of DAIs
+ */
+void snd_soc_unregister_dais(struct snd_soc_dai *dai, size_t count)
+{
+	int i;
+
+	for (i = 0; i < count; i++)
+		snd_soc_unregister_dai(&dai[i]);
+}
+EXPORT_SYMBOL_GPL(snd_soc_unregister_dais);
+
 static int __devinit snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS

commit c5af3a2e192d333997d1e191f3eba7fd2f869681
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Nov 28 13:29:45 2008 +0000

    ASoC: Add card registration API
    
    ASoC v2 allows cards, codecs and platforms to instantiate separately,
    with the overall ASoC device only being instantiated once all the
    required components have registered. As part of backporting Liam's work
    introduce an initial version of the card registration functions. At
    present these do nothing active and are internal only, they will be
    exposed to machine drivers after further backporting.  Adding this now
    allows the datastructures used for dynamic card instantiation to be
    built up gradually.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2f2a8d93bbf0..44fbd71ce80f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -43,6 +43,12 @@ static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 static struct dentry *debugfs_root;
 #endif
 
+static DEFINE_MUTEX(client_mutex);
+static LIST_HEAD(card_list);
+
+static int snd_soc_register_card(struct snd_soc_card *card);
+static int snd_soc_unregister_card(struct snd_soc_card *card);
+
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
  * It can be used to eliminate pops between different playback streams, e.g.
@@ -784,6 +790,14 @@ static int soc_probe(struct platform_device *pdev)
 	/* Bodge while we push things out of socdev */
 	card->socdev = socdev;
 
+	/* Bodge while we unpick instantiation */
+	card->dev = &pdev->dev;
+	ret = snd_soc_register_card(card);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to register card\n");
+		return ret;
+	}
+
 	if (card->probe) {
 		ret = card->probe(pdev);
 		if (ret < 0)
@@ -863,6 +877,8 @@ static int soc_remove(struct platform_device *pdev)
 	if (card->remove)
 		card->remove(pdev);
 
+	snd_soc_unregister_card(card);
+
 	return 0;
 }
 
@@ -1957,6 +1973,52 @@ int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 
+/**
+ * snd_soc_register_card - Register a card with the ASoC core
+ *
+ * @param card Card to register
+ *
+ * Note that currently this is an internal only function: it will be
+ * exposed to machine drivers after further backporting of ASoC v2
+ * registration APIs.
+ */
+static int snd_soc_register_card(struct snd_soc_card *card)
+{
+	if (!card->name || !card->dev)
+		return -EINVAL;
+
+	INIT_LIST_HEAD(&card->list);
+	card->instantiated = 0;
+
+	mutex_lock(&client_mutex);
+	list_add(&card->list, &card_list);
+	mutex_unlock(&client_mutex);
+
+	dev_dbg(card->dev, "Registered card '%s'\n", card->name);
+
+	return 0;
+}
+
+/**
+ * snd_soc_unregister_card - Unregister a card with the ASoC core
+ *
+ * @param card Card to unregister
+ *
+ * Note that currently this is an internal only function: it will be
+ * exposed to machine drivers after further backporting of ASoC v2
+ * registration APIs.
+ */
+static int snd_soc_unregister_card(struct snd_soc_card *card)
+{
+	mutex_lock(&client_mutex);
+	list_del(&card->list);
+	mutex_unlock(&client_mutex);
+
+	dev_dbg(card->dev, "Unregistered card '%s'\n", card->name);
+
+	return 0;
+}
+
 static int __devinit snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS

commit dc7d7b830ee1f4111696e73d1c25da683b461548
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 3 18:21:52 2008 +0000

    ASoC: Remove platform device from DAI suspend and resume operations
    
    None of the DAIs use it except s3c2412-i2s which only uses it for
    dev_() printouts.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f83852f11463..2f2a8d93bbf0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -650,7 +650,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai  *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->suspend && !cpu_dai->ac97_control)
-			cpu_dai->suspend(pdev, cpu_dai);
+			cpu_dai->suspend(cpu_dai);
 		if (platform->suspend)
 			platform->suspend(cpu_dai);
 	}
@@ -676,7 +676,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->suspend && cpu_dai->ac97_control)
-			cpu_dai->suspend(pdev, cpu_dai);
+			cpu_dai->suspend(cpu_dai);
 	}
 
 	if (card->suspend_post)
@@ -712,7 +712,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->resume && cpu_dai->ac97_control)
-			cpu_dai->resume(pdev, cpu_dai);
+			cpu_dai->resume(cpu_dai);
 	}
 
 	if (codec_dev->resume)
@@ -739,7 +739,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->resume && !cpu_dai->ac97_control)
-			cpu_dai->resume(pdev, cpu_dai);
+			cpu_dai->resume(cpu_dai);
 		if (platform->resume)
 			platform->resume(cpu_dai);
 	}

commit 07c84d0409f3551b79d676630d8ee76bb551598d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 3 18:17:28 2008 +0000

    ASoC: Remove device from platform suspend and resume operations
    
    None of the platforms are actually using the SoC device so remove it
    (only atmel actually has a suspend method).
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 34114398b914..f83852f11463 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -652,7 +652,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 		if (cpu_dai->suspend && !cpu_dai->ac97_control)
 			cpu_dai->suspend(pdev, cpu_dai);
 		if (platform->suspend)
-			platform->suspend(pdev, cpu_dai);
+			platform->suspend(cpu_dai);
 	}
 
 	/* close any waiting streams and save state */
@@ -741,7 +741,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		if (cpu_dai->resume && !cpu_dai->ac97_control)
 			cpu_dai->resume(pdev, cpu_dai);
 		if (platform->resume)
-			platform->resume(pdev, cpu_dai);
+			platform->resume(cpu_dai);
 	}
 
 	if (card->resume_post)

commit 384c89e2e4cb5879b86a38414d1b3bb2b23ec8ee
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 3 17:34:03 2008 +0000

    ASoC: Push debugfs files out of the snd_soc_device structure
    
    This is in preparation for the removal of struct snd_soc_device.
    
    The pop time configuration should really be a property of the card not
    the codec but since DAPM currently uses the codec rather than the card
    using the codec is fine for now.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index fe89260c9028..34114398b914 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -39,6 +39,10 @@ static DEFINE_MUTEX(pcm_mutex);
 static DEFINE_MUTEX(io_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 
+#ifdef CONFIG_DEBUG_FS
+static struct dentry *debugfs_root;
+#endif
+
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
  * It can be used to eliminate pops between different playback streams, e.g.
@@ -1002,7 +1006,9 @@ static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
 			       size_t count, loff_t *ppos)
 {
 	ssize_t ret;
-	struct snd_soc_device *devdata = file->private_data;
+	struct snd_soc_codec *codec = file->private_data;
+	struct device *card_dev = codec->card->dev;
+	struct snd_soc_device *devdata = card_dev->driver_data;
 	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
@@ -1021,8 +1027,7 @@ static ssize_t codec_reg_write_file(struct file *file,
 	char *start = buf;
 	unsigned long reg, value;
 	int step = 1;
-	struct snd_soc_device *devdata = file->private_data;
-	struct snd_soc_codec *codec = devdata->codec;
+	struct snd_soc_codec *codec = file->private_data;
 
 	buf_size = min(count, (sizeof(buf)-1));
 	if (copy_from_user(buf, user_buf, buf_size))
@@ -1051,44 +1056,36 @@ static const struct file_operations codec_reg_fops = {
 	.write = codec_reg_write_file,
 };
 
-static void soc_init_debugfs(struct snd_soc_device *socdev)
+static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
-	struct dentry *root, *file;
-	struct snd_soc_codec *codec = socdev->codec;
-	root = debugfs_create_dir(dev_name(socdev->dev), NULL);
-	if (IS_ERR(root) || !root)
-		goto exit1;
-
-	file = debugfs_create_file("codec_reg", 0644,
-			root, socdev, &codec_reg_fops);
-	if (!file)
-		goto exit2;
-
-	file = debugfs_create_u32("dapm_pop_time", 0744,
-			root, &codec->pop_time);
-	if (!file)
-		goto exit2;
-	socdev->debugfs_root = root;
-	return;
-exit2:
-	debugfs_remove_recursive(root);
-exit1:
-	dev_err(socdev->dev, "debugfs is not available\n");
+	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
+						 debugfs_root, codec,
+						 &codec_reg_fops);
+	if (!codec->debugfs_reg)
+		printk(KERN_WARNING
+		       "ASoC: Failed to create codec register debugfs file\n");
+
+	codec->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0744,
+						     debugfs_root,
+						     &codec->pop_time);
+	if (!codec->debugfs_pop_time)
+		printk(KERN_WARNING
+		       "Failed to create pop time debugfs file\n");
 }
 
-static void soc_cleanup_debugfs(struct snd_soc_device *socdev)
+static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 {
-	debugfs_remove_recursive(socdev->debugfs_root);
-	socdev->debugfs_root = NULL;
+	debugfs_remove(codec->debugfs_pop_time);
+	debugfs_remove(codec->debugfs_reg);
 }
 
 #else
 
-static inline void soc_init_debugfs(struct snd_soc_device *socdev)
+static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
 }
 
-static inline void soc_cleanup_debugfs(struct snd_soc_device *socdev)
+static inline void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
 {
 }
 #endif
@@ -1305,7 +1302,7 @@ int snd_soc_init_card(struct snd_soc_device *socdev)
 	if (err < 0)
 		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
 
-	soc_init_debugfs(socdev);
+	soc_init_codec_debugfs(socdev->codec);
 	mutex_unlock(&codec->mutex);
 
 out:
@@ -1329,7 +1326,7 @@ void snd_soc_free_pcms(struct snd_soc_device *socdev)
 #endif
 
 	mutex_lock(&codec->mutex);
-	soc_cleanup_debugfs(socdev);
+	soc_cleanup_codec_debugfs(socdev->codec);
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];
@@ -1962,11 +1959,23 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 
 static int __devinit snd_soc_init(void)
 {
+#ifdef CONFIG_DEBUG_FS
+	debugfs_root = debugfs_create_dir("asoc", NULL);
+	if (IS_ERR(debugfs_root) || !debugfs_root) {
+		printk(KERN_WARNING
+		       "ASoC: Failed to create debugfs directory\n");
+		debugfs_root = NULL;
+	}
+#endif
+
 	return platform_driver_register(&soc_driver);
 }
 
 static void __exit snd_soc_exit(void)
 {
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(debugfs_root);
+#endif
 	platform_driver_unregister(&soc_driver);
 }
 

commit 87689d567a45f80416feea0a2aa6d3a2a6b8963a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Dec 2 16:01:14 2008 +0000

    ASoC: Push platform registration down into the card
    
    As part of the deprecation of snd_soc_device push the registration of
    the platform down into the card structure.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c4b22e6984e6..fe89260c9028 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -109,9 +109,10 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_card *card = socdev->card;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	int ret = 0;
@@ -302,7 +303,7 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	struct snd_soc_codec *codec = socdev->codec;
@@ -370,7 +371,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	struct snd_soc_codec *codec = socdev->codec;
@@ -464,7 +465,8 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	int ret = 0;
@@ -534,7 +536,8 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	struct snd_soc_codec *codec = socdev->codec;
@@ -568,8 +571,9 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_card *card= socdev->card;
 	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
 	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	int ret;
@@ -610,7 +614,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
 	int i;
@@ -686,7 +690,7 @@ static void soc_resume_deferred(struct work_struct *work)
 						 struct snd_soc_card,
 						 deferred_resume_work);
 	struct snd_soc_device *socdev = card->socdev;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
 	struct platform_device *pdev = to_platform_device(socdev->dev);
@@ -770,7 +774,7 @@ static int soc_probe(struct platform_device *pdev)
 	int ret = 0, i;
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
 	/* Bodge while we push things out of socdev */
@@ -835,7 +839,7 @@ static int soc_remove(struct platform_device *pdev)
 	int i;
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_card *card = socdev->card;
-	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
 	run_delayed_work(&card->delayed_work);
@@ -875,6 +879,8 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	struct snd_soc_dai_link *dai_link, int num)
 {
 	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_platform *platform = card->platform;
 	struct snd_soc_dai *codec_dai = dai_link->codec_dai;
 	struct snd_soc_dai *cpu_dai = dai_link->cpu_dai;
 	struct snd_soc_pcm_runtime *rtd;
@@ -910,13 +916,13 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 
 	dai_link->pcm = pcm;
 	pcm->private_data = rtd;
-	soc_pcm_ops.mmap = socdev->platform->pcm_ops->mmap;
-	soc_pcm_ops.pointer = socdev->platform->pcm_ops->pointer;
-	soc_pcm_ops.ioctl = socdev->platform->pcm_ops->ioctl;
-	soc_pcm_ops.copy = socdev->platform->pcm_ops->copy;
-	soc_pcm_ops.silence = socdev->platform->pcm_ops->silence;
-	soc_pcm_ops.ack = socdev->platform->pcm_ops->ack;
-	soc_pcm_ops.page = socdev->platform->pcm_ops->page;
+	soc_pcm_ops.mmap = platform->pcm_ops->mmap;
+	soc_pcm_ops.pointer = platform->pcm_ops->pointer;
+	soc_pcm_ops.ioctl = platform->pcm_ops->ioctl;
+	soc_pcm_ops.copy = platform->pcm_ops->copy;
+	soc_pcm_ops.silence = platform->pcm_ops->silence;
+	soc_pcm_ops.ack = platform->pcm_ops->ack;
+	soc_pcm_ops.page = platform->pcm_ops->page;
 
 	if (playback)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
@@ -924,14 +930,14 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	if (capture)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &soc_pcm_ops);
 
-	ret = socdev->platform->pcm_new(codec->card, codec_dai, pcm);
+	ret = platform->pcm_new(codec->card, codec_dai, pcm);
 	if (ret < 0) {
 		printk(KERN_ERR "asoc: platform pcm constructor failed\n");
 		kfree(rtd);
 		return ret;
 	}
 
-	pcm->private_free = socdev->platform->pcm_free;
+	pcm->private_free = platform->pcm_free;
 	printk(KERN_INFO "asoc: %s <-> %s mapping ok\n", codec_dai->name,
 		cpu_dai->name);
 	return ret;

commit 6308419a199eed66086cd756ab8dc81b88d54a6b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Dec 2 15:08:03 2008 +0000

    ASoC: Push workqueue data into snd_soc_card
    
    ASoC v2 does not use the struct snd_soc_device at runtime, using struct
    snd_soc_card as the root of the card.  Begin removing data from
    snd_soc_device by pushing the workqueue data into snd_soc_card, using a
    backpointer to the snd_soc_device to keep things going for the time
    being.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7eb2ea1fd42e..c4b22e6984e6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -247,8 +247,9 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
  */
 static void close_delayed_work(struct work_struct *work)
 {
-	struct snd_soc_device *socdev =
-		container_of(work, struct snd_soc_device, delayed_work.work);
+	struct snd_soc_card *card = container_of(work, struct snd_soc_card,
+						 delayed_work.work);
+	struct snd_soc_device *socdev = card->socdev;
 	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_dai *codec_dai;
 	int i;
@@ -299,6 +300,7 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
@@ -340,7 +342,7 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* start delayed pop wq here for playback streams */
 		codec_dai->pop_wait = 1;
-		schedule_delayed_work(&socdev->delayed_work,
+		schedule_delayed_work(&card->delayed_work,
 			msecs_to_jiffies(pmdown_time));
 	} else {
 		/* capture streams can be powered down now */
@@ -366,6 +368,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
@@ -411,7 +414,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    codec_dai->pop_wait) {
 		codec_dai->pop_wait = 0;
-		cancel_delayed_work(&socdev->delayed_work);
+		cancel_delayed_work(&card->delayed_work);
 	}
 
 	/* do we need to power up codec */
@@ -645,7 +648,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	}
 
 	/* close any waiting streams and save state */
-	run_delayed_work(&socdev->delayed_work);
+	run_delayed_work(&card->delayed_work);
 	codec->suspend_bias_level = codec->bias_level;
 
 	for (i = 0; i < codec->num_dai; i++) {
@@ -679,10 +682,10 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
  */
 static void soc_resume_deferred(struct work_struct *work)
 {
-	struct snd_soc_device *socdev = container_of(work,
-						     struct snd_soc_device,
-						     deferred_resume_work);
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_card *card = container_of(work,
+						 struct snd_soc_card,
+						 deferred_resume_work);
+	struct snd_soc_device *socdev = card->socdev;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
@@ -746,10 +749,11 @@ static void soc_resume_deferred(struct work_struct *work)
 static int soc_resume(struct platform_device *pdev)
 {
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_card *card = socdev->card;
 
 	dev_dbg(socdev->dev, "scheduling resume work\n");
 
-	if (!schedule_work(&socdev->deferred_resume_work))
+	if (!schedule_work(&card->deferred_resume_work))
 		dev_err(socdev->dev, "resume work item may be lost\n");
 
 	return 0;
@@ -769,6 +773,9 @@ static int soc_probe(struct platform_device *pdev)
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
+	/* Bodge while we push things out of socdev */
+	card->socdev = socdev;
+
 	if (card->probe) {
 		ret = card->probe(pdev);
 		if (ret < 0)
@@ -797,10 +804,10 @@ static int soc_probe(struct platform_device *pdev)
 	}
 
 	/* DAPM stream work */
-	INIT_DELAYED_WORK(&socdev->delayed_work, close_delayed_work);
+	INIT_DELAYED_WORK(&card->delayed_work, close_delayed_work);
 #ifdef CONFIG_PM
 	/* deferred resume work */
-	INIT_WORK(&socdev->deferred_resume_work, soc_resume_deferred);
+	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
 #endif
 
 	return 0;
@@ -831,7 +838,7 @@ static int soc_remove(struct platform_device *pdev)
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
-	run_delayed_work(&socdev->delayed_work);
+	run_delayed_work(&card->delayed_work);
 
 	if (platform->remove)
 		platform->remove(pdev);

commit 7d8c16a6f728f0ee5c42d1d731923cfd0cc19971
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Nov 30 22:11:24 2008 +0000

    ASoC: Annotate core removal function
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0448708245e7..7eb2ea1fd42e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1952,7 +1952,7 @@ static int __devinit snd_soc_init(void)
 	return platform_driver_register(&soc_driver);
 }
 
-static void snd_soc_exit(void)
+static void __exit snd_soc_exit(void)
 {
 	platform_driver_unregister(&soc_driver);
 }

commit 968a6025aa9f909d487988efb542217a126023a0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Nov 28 11:49:07 2008 +0000

    ASoC: Rename snd_soc_register_card() to snd_soc_init_card()
    
    Currently ASoC card initialisation is completed by a function called
    snd_soc_register_card().  As part of the work to allow independant
    registration of cards, codecs and machines in ASoC v2 a new function of
    the same name has been added so rename the existing function to
    facilitate the merge of v2.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 13b4aaff0e9c..0448708245e7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1233,7 +1233,7 @@ int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
 
 /**
- * snd_soc_register_card - register sound card
+ * snd_soc_init_card - register sound card
  * @socdev: the SoC audio device
  *
  * Register a SoC sound card. Also registers an AC97 device if the
@@ -1241,7 +1241,7 @@ EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
  *
  * Returns 0 for success, else error.
  */
-int snd_soc_register_card(struct snd_soc_device *socdev)
+int snd_soc_init_card(struct snd_soc_device *socdev)
 {
 	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_card *card = socdev->card;
@@ -1298,7 +1298,7 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 out:
 	return ret;
 }
-EXPORT_SYMBOL_GPL(snd_soc_register_card);
+EXPORT_SYMBOL_GPL(snd_soc_init_card);
 
 /**
  * snd_soc_free_pcms - free sound card and pcms

commit 3af4182cc5be7d5505f9801ee3297373f1872446
Merge: f5d4c67e41a2 c07f62e5f181
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 1 18:02:17 2008 +0100

    Merge branch 'upstream' into topic/asoc

commit 9e0f1b7f6bc5265847e995540981642c857f15b6
Author: Qinghuang Feng <qhfeng.kernel@gmail.com>
Date:   Tue Nov 25 23:24:54 2008 +0800

    ASoC: Clean up kernel-doc for snd_soc_dai_set_fmt
    
    There is no argument named @clk_id in snd_soc_dai_set_fmt,
    remove its' comment.
    
    Signed-off-by: Qinghuang Feng <qhfeng.kernel@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index dbd92e12e860..00fccdd41bb0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1883,7 +1883,6 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
 /**
  * snd_soc_dai_set_fmt - configure DAI hardware audio format.
  * @dai: DAI
- * @clk_id: DAI specific clock ID
  * @fmt: SND_SOC_DAIFMT_ format value.
  *
  * Configures the DAI hardware format and clocking.

commit fde22f272dad4fef7ba611e3f75fa94f7b43fae6
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Nov 24 18:08:18 2008 +0000

    ASoC: Lower priority of resume work logging
    
    Now that the ASoC resume has been punted to a workqueue for a release
    cycle without attracting bug reports it should be safe to make the
    log messages associated with it debug level, reducing noise and kernel
    size in production configurations.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0d47696ccd07..dbd92e12e860 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -693,7 +693,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	 * so userspace apps are blocked from touching us
 	 */
 
-	dev_info(socdev->dev, "starting resume work\n");
+	dev_dbg(socdev->dev, "starting resume work\n");
 
 	if (card->resume_pre)
 		card->resume_pre(pdev);
@@ -736,7 +736,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	if (card->resume_post)
 		card->resume_post(pdev);
 
-	dev_info(socdev->dev, "resume work completed\n");
+	dev_dbg(socdev->dev, "resume work completed\n");
 
 	/* userspace can access us now we are back as we were before */
 	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D0);
@@ -747,10 +747,10 @@ static int soc_resume(struct platform_device *pdev)
 {
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 
-	dev_info(socdev->dev, "scheduling resume work\n");
+	dev_dbg(socdev->dev, "scheduling resume work\n");
 
 	if (!schedule_work(&socdev->deferred_resume_work))
-		dev_err(socdev->dev, "work item may be lost\n");
+		dev_err(socdev->dev, "resume work item may be lost\n");
 
 	return 0;
 }

commit 3ba9e10a6d3b6abf5f5952572cff8f8d5a35ae54
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Nov 24 18:01:05 2008 +0000

    ASoC: Remove DAI type information
    
    DAI type information is only ever used within ASoC in order to special
    case AC97 and for diagnostic purposes. Since modern CPUs and codecs
    support multi function DAIs which can be configured for several modes
    it is more trouble than it's worth to maintain anything other than a
    flag identifying AC97 DAIs so remove the type field and replace it with
    an ac97_control flag.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 43f4060dbe75..0d47696ccd07 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -100,20 +100,6 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 }
 #endif
 
-static inline const char *get_dai_name(int type)
-{
-	switch (type) {
-	case SND_SOC_DAI_AC97_BUS:
-	case SND_SOC_DAI_AC97:
-		return "AC97";
-	case SND_SOC_DAI_I2S:
-		return "I2S";
-	case SND_SOC_DAI_PCM:
-		return "PCM";
-	}
-	return NULL;
-}
-
 /*
  * Called by ALSA when a PCM substream is opened, the runtime->hw record is
  * then initialized and any private data can be allocated. This also calls
@@ -652,7 +638,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai  *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->suspend && cpu_dai->type != SND_SOC_DAI_AC97)
+		if (cpu_dai->suspend && !cpu_dai->ac97_control)
 			cpu_dai->suspend(pdev, cpu_dai);
 		if (platform->suspend)
 			platform->suspend(pdev, cpu_dai);
@@ -678,7 +664,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->suspend && cpu_dai->type == SND_SOC_DAI_AC97)
+		if (cpu_dai->suspend && cpu_dai->ac97_control)
 			cpu_dai->suspend(pdev, cpu_dai);
 	}
 
@@ -714,7 +700,7 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->resume && cpu_dai->type == SND_SOC_DAI_AC97)
+		if (cpu_dai->resume && cpu_dai->ac97_control)
 			cpu_dai->resume(pdev, cpu_dai);
 	}
 
@@ -741,7 +727,7 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	for (i = 0; i < card->num_links; i++) {
 		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->resume && cpu_dai->type != SND_SOC_DAI_AC97)
+		if (cpu_dai->resume && !cpu_dai->ac97_control)
 			cpu_dai->resume(pdev, cpu_dai);
 		if (platform->resume)
 			platform->resume(pdev, cpu_dai);
@@ -898,8 +884,8 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	codec_dai->codec = socdev->codec;
 
 	/* check client and interface hw capabilities */
-	sprintf(new_name, "%s %s-%s-%d", dai_link->stream_name, codec_dai->name,
-		get_dai_name(cpu_dai->type), num);
+	sprintf(new_name, "%s %s-%d", dai_link->stream_name, codec_dai->name,
+		num);
 
 	if (codec_dai->playback.channels_min)
 		playback = 1;
@@ -1270,8 +1256,7 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 				continue;
 			}
 		}
-		if (card->dai_link[i].codec_dai->type ==
-			SND_SOC_DAI_AC97_BUS)
+		if (card->dai_link[i].codec_dai->ac97_control)
 			ac97 = 1;
 	}
 	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
@@ -1335,7 +1320,7 @@ void snd_soc_free_pcms(struct snd_soc_device *socdev)
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];
-		if (codec_dai->type == SND_SOC_DAI_AC97_BUS && codec->ac97) {
+		if (codec_dai->ac97_control && codec->ac97) {
 			soc_ac97_dev_unregister(codec);
 			goto free_card;
 		}

commit dee89c4d94433520e4e3977ae203d4cfbfe385fb
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 18 22:11:38 2008 +0000

    ASoC: Merge snd_soc_ops into snd_soc_dai_ops
    
    Liam Girdwood's ASoC v2 work avoids having two different ops structures
    for DAIs by merging the members of struct snd_soc_ops into struct
    snd_soc_dai_ops, allowing per DAI configuration for everything.
    Backport this change.
    
    This paves the way for future work allowing any combination of DAIs to
    be connected rather than having fixed purpose CODEC and CPU DAIs and
    only allowing CODEC<->CPU interconnections.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c5cb9516fea4..43f4060dbe75 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -134,7 +134,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 
 	/* startup the audio subsystem */
 	if (cpu_dai->ops.startup) {
-		ret = cpu_dai->ops.startup(substream);
+		ret = cpu_dai->ops.startup(substream, cpu_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open interface %s\n",
 				cpu_dai->name);
@@ -151,7 +151,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	}
 
 	if (codec_dai->ops.startup) {
-		ret = codec_dai->ops.startup(substream);
+		ret = codec_dai->ops.startup(substream, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open codec %s\n",
 				codec_dai->name);
@@ -248,7 +248,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 
 platform_err:
 	if (cpu_dai->ops.shutdown)
-		cpu_dai->ops.shutdown(substream);
+		cpu_dai->ops.shutdown(substream, cpu_dai);
 out:
 	mutex_unlock(&pcm_mutex);
 	return ret;
@@ -339,10 +339,10 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 		snd_soc_dai_digital_mute(codec_dai, 1);
 
 	if (cpu_dai->ops.shutdown)
-		cpu_dai->ops.shutdown(substream);
+		cpu_dai->ops.shutdown(substream, cpu_dai);
 
 	if (codec_dai->ops.shutdown)
-		codec_dai->ops.shutdown(substream);
+		codec_dai->ops.shutdown(substream, codec_dai);
 
 	if (machine->ops && machine->ops->shutdown)
 		machine->ops->shutdown(substream);
@@ -406,7 +406,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	}
 
 	if (codec_dai->ops.prepare) {
-		ret = codec_dai->ops.prepare(substream);
+		ret = codec_dai->ops.prepare(substream, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: codec DAI prepare error\n");
 			goto out;
@@ -414,7 +414,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	}
 
 	if (cpu_dai->ops.prepare) {
-		ret = cpu_dai->ops.prepare(substream);
+		ret = cpu_dai->ops.prepare(substream, cpu_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: cpu DAI prepare error\n");
 			goto out;
@@ -491,7 +491,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	if (codec_dai->ops.hw_params) {
-		ret = codec_dai->ops.hw_params(substream, params);
+		ret = codec_dai->ops.hw_params(substream, params, codec_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
 				codec_dai->name);
@@ -500,7 +500,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	if (cpu_dai->ops.hw_params) {
-		ret = cpu_dai->ops.hw_params(substream, params);
+		ret = cpu_dai->ops.hw_params(substream, params, cpu_dai);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: interface %s hw params failed\n",
 				cpu_dai->name);
@@ -523,11 +523,11 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 
 platform_err:
 	if (cpu_dai->ops.hw_free)
-		cpu_dai->ops.hw_free(substream);
+		cpu_dai->ops.hw_free(substream, cpu_dai);
 
 interface_err:
 	if (codec_dai->ops.hw_free)
-		codec_dai->ops.hw_free(substream);
+		codec_dai->ops.hw_free(substream, codec_dai);
 
 codec_err:
 	if (machine->ops && machine->ops->hw_free)
@@ -566,10 +566,10 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 
 	/* now free hw params for the DAI's  */
 	if (codec_dai->ops.hw_free)
-		codec_dai->ops.hw_free(substream);
+		codec_dai->ops.hw_free(substream, codec_dai);
 
 	if (cpu_dai->ops.hw_free)
-		cpu_dai->ops.hw_free(substream);
+		cpu_dai->ops.hw_free(substream, cpu_dai);
 
 	mutex_unlock(&pcm_mutex);
 	return 0;
@@ -586,7 +586,7 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	int ret;
 
 	if (codec_dai->ops.trigger) {
-		ret = codec_dai->ops.trigger(substream, cmd);
+		ret = codec_dai->ops.trigger(substream, cmd, codec_dai);
 		if (ret < 0)
 			return ret;
 	}
@@ -598,7 +598,7 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	}
 
 	if (cpu_dai->ops.trigger) {
-		ret = cpu_dai->ops.trigger(substream, cmd);
+		ret = cpu_dai->ops.trigger(substream, cmd, cpu_dai);
 		if (ret < 0)
 			return ret;
 	}
@@ -637,10 +637,10 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D3hot);
 
 	/* mute any active DAC's */
-	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_dai *dai = machine->dai_link[i].codec_dai;
-		if (dai->dai_ops.digital_mute && dai->playback.active)
-			dai->dai_ops.digital_mute(dai, 1);
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
+		if (dai->ops.digital_mute && dai->playback.active)
+			dai->ops.digital_mute(dai, 1);
 	}
 
 	/* suspend all pcms */
@@ -733,10 +733,10 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	/* unmute any active DACs */
-	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_dai *dai = machine->dai_link[i].codec_dai;
-		if (dai->dai_ops.digital_mute && dai->playback.active)
-			dai->dai_ops.digital_mute(dai, 0);
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
+		if (dai->ops.digital_mute && dai->playback.active)
+			dai->ops.digital_mute(dai, 0);
 	}
 
 	for (i = 0; i < card->num_links; i++) {
@@ -1849,8 +1849,8 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 	unsigned int freq, int dir)
 {
-	if (dai->dai_ops.set_sysclk)
-		return dai->dai_ops.set_sysclk(dai, clk_id, freq, dir);
+	if (dai->ops.set_sysclk)
+		return dai->ops.set_sysclk(dai, clk_id, freq, dir);
 	else
 		return -EINVAL;
 }
@@ -1869,8 +1869,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
 	int div_id, int div)
 {
-	if (dai->dai_ops.set_clkdiv)
-		return dai->dai_ops.set_clkdiv(dai, div_id, div);
+	if (dai->ops.set_clkdiv)
+		return dai->ops.set_clkdiv(dai, div_id, div);
 	else
 		return -EINVAL;
 }
@@ -1888,8 +1888,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
 	int pll_id, unsigned int freq_in, unsigned int freq_out)
 {
-	if (dai->dai_ops.set_pll)
-		return dai->dai_ops.set_pll(dai, pll_id, freq_in, freq_out);
+	if (dai->ops.set_pll)
+		return dai->ops.set_pll(dai, pll_id, freq_in, freq_out);
 	else
 		return -EINVAL;
 }
@@ -1905,8 +1905,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
  */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	if (dai->dai_ops.set_fmt)
-		return dai->dai_ops.set_fmt(dai, fmt);
+	if (dai->ops.set_fmt)
+		return dai->ops.set_fmt(dai, fmt);
 	else
 		return -EINVAL;
 }
@@ -1924,8 +1924,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int mask, int slots)
 {
-	if (dai->dai_ops.set_sysclk)
-		return dai->dai_ops.set_tdm_slot(dai, mask, slots);
+	if (dai->ops.set_sysclk)
+		return dai->ops.set_tdm_slot(dai, mask, slots);
 	else
 		return -EINVAL;
 }
@@ -1940,8 +1940,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
  */
 int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
 {
-	if (dai->dai_ops.set_sysclk)
-		return dai->dai_ops.set_tristate(dai, tristate);
+	if (dai->ops.set_sysclk)
+		return dai->ops.set_tristate(dai, tristate);
 	else
 		return -EINVAL;
 }
@@ -1956,8 +1956,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
  */
 int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
 {
-	if (dai->dai_ops.digital_mute)
-		return dai->dai_ops.digital_mute(dai, mute);
+	if (dai->ops.digital_mute)
+		return dai->ops.digital_mute(dai, mute);
 	else
 		return -EINVAL;
 }

commit 875065491fba8eb13219f16c36e79a6fb4e15c68
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 18 20:50:34 2008 +0000

    ASoC: Rename snd_soc_card to snd_soc_machine
    
    One of the issues with the ASoC v1 API which has been addressed in the
    ASoC v2 work that Liam Girdwood has done is that the ALSA card provided
    by ASoC is distributed around the ASoC structures. For example, machine
    wide data such as the struct snd_card are maintained as part of the
    CODEC data structure, preventing the use of multiple codecs. This has
    been addressed by refactoring the data structures so that all the data
    for the ALSA card is contained in a single structure snd_soc_card which
    replaces the existing snd_soc_machine and snd_soc_device.
    
    Begin the process of backporting this by renaming struct snd_soc_machine
    to struct snd_soc_card, better reflecting its function and bringing it
    closer to standard ALSA terminology.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9feaa7b6dc34..c5cb9516fea4 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -620,7 +620,7 @@ static struct snd_pcm_ops soc_pcm_ops = {
 static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
@@ -644,14 +644,14 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	}
 
 	/* suspend all pcms */
-	for (i = 0; i < machine->num_links; i++)
-		snd_pcm_suspend_all(machine->dai_link[i].pcm);
+	for (i = 0; i < card->num_links; i++)
+		snd_pcm_suspend_all(card->dai_link[i].pcm);
 
-	if (machine->suspend_pre)
-		machine->suspend_pre(pdev, state);
+	if (card->suspend_pre)
+		card->suspend_pre(pdev, state);
 
-	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_dai  *cpu_dai = machine->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_dai  *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->suspend && cpu_dai->type != SND_SOC_DAI_AC97)
 			cpu_dai->suspend(pdev, cpu_dai);
 		if (platform->suspend)
@@ -676,14 +676,14 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	if (codec_dev->suspend)
 		codec_dev->suspend(pdev, state);
 
-	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->suspend && cpu_dai->type == SND_SOC_DAI_AC97)
 			cpu_dai->suspend(pdev, cpu_dai);
 	}
 
-	if (machine->suspend_post)
-		machine->suspend_post(pdev, state);
+	if (card->suspend_post)
+		card->suspend_post(pdev, state);
 
 	return 0;
 }
@@ -696,7 +696,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	struct snd_soc_device *socdev = container_of(work,
 						     struct snd_soc_device,
 						     deferred_resume_work);
-	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
@@ -709,11 +709,11 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	dev_info(socdev->dev, "starting resume work\n");
 
-	if (machine->resume_pre)
-		machine->resume_pre(pdev);
+	if (card->resume_pre)
+		card->resume_pre(pdev);
 
-	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->resume && cpu_dai->type == SND_SOC_DAI_AC97)
 			cpu_dai->resume(pdev, cpu_dai);
 	}
@@ -739,16 +739,16 @@ static void soc_resume_deferred(struct work_struct *work)
 			dai->dai_ops.digital_mute(dai, 0);
 	}
 
-	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->resume && cpu_dai->type != SND_SOC_DAI_AC97)
 			cpu_dai->resume(pdev, cpu_dai);
 		if (platform->resume)
 			platform->resume(pdev, cpu_dai);
 	}
 
-	if (machine->resume_post)
-		machine->resume_post(pdev);
+	if (card->resume_post)
+		card->resume_post(pdev);
 
 	dev_info(socdev->dev, "resume work completed\n");
 
@@ -779,18 +779,18 @@ static int soc_probe(struct platform_device *pdev)
 {
 	int ret = 0, i;
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
-	if (machine->probe) {
-		ret = machine->probe(pdev);
+	if (card->probe) {
+		ret = card->probe(pdev);
 		if (ret < 0)
 			return ret;
 	}
 
-	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->probe) {
 			ret = cpu_dai->probe(pdev, cpu_dai);
 			if (ret < 0)
@@ -825,13 +825,13 @@ static int soc_probe(struct platform_device *pdev)
 
 cpu_dai_err:
 	for (i--; i >= 0; i--) {
-		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->remove)
 			cpu_dai->remove(pdev, cpu_dai);
 	}
 
-	if (machine->remove)
-		machine->remove(pdev);
+	if (card->remove)
+		card->remove(pdev);
 
 	return ret;
 }
@@ -841,7 +841,7 @@ static int soc_remove(struct platform_device *pdev)
 {
 	int i;
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_card *card = socdev->card;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
@@ -853,14 +853,14 @@ static int soc_remove(struct platform_device *pdev)
 	if (codec_dev->remove)
 		codec_dev->remove(pdev);
 
-	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+	for (i = 0; i < card->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
 		if (cpu_dai->remove)
 			cpu_dai->remove(pdev, cpu_dai);
 	}
 
-	if (machine->remove)
-		machine->remove(pdev);
+	if (card->remove)
+		card->remove(pdev);
 
 	return 0;
 }
@@ -1212,7 +1212,7 @@ EXPORT_SYMBOL_GPL(snd_soc_test_bits);
 int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 {
 	struct snd_soc_codec *codec = socdev->codec;
-	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_card *card = socdev->card;
 	int ret = 0, i;
 
 	mutex_lock(&codec->mutex);
@@ -1231,11 +1231,11 @@ int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));
 
 	/* create the pcms */
-	for (i = 0; i < machine->num_links; i++) {
-		ret = soc_new_pcm(socdev, &machine->dai_link[i], i);
+	for (i = 0; i < card->num_links; i++) {
+		ret = soc_new_pcm(socdev, &card->dai_link[i], i);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't create pcm %s\n",
-				machine->dai_link[i].stream_name);
+				card->dai_link[i].stream_name);
 			mutex_unlock(&codec->mutex);
 			return ret;
 		}
@@ -1258,26 +1258,26 @@ EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
 int snd_soc_register_card(struct snd_soc_device *socdev)
 {
 	struct snd_soc_codec *codec = socdev->codec;
-	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_card *card = socdev->card;
 	int ret = 0, i, ac97 = 0, err = 0;
 
-	for (i = 0; i < machine->num_links; i++) {
-		if (socdev->machine->dai_link[i].init) {
-			err = socdev->machine->dai_link[i].init(codec);
+	for (i = 0; i < card->num_links; i++) {
+		if (card->dai_link[i].init) {
+			err = card->dai_link[i].init(codec);
 			if (err < 0) {
 				printk(KERN_ERR "asoc: failed to init %s\n",
-					socdev->machine->dai_link[i].stream_name);
+					card->dai_link[i].stream_name);
 				continue;
 			}
 		}
-		if (socdev->machine->dai_link[i].codec_dai->type ==
+		if (card->dai_link[i].codec_dai->type ==
 			SND_SOC_DAI_AC97_BUS)
 			ac97 = 1;
 	}
 	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
-		 "%s", machine->name);
+		 "%s",  card->name);
 	snprintf(codec->card->longname, sizeof(codec->card->longname),
-		 "%s (%s)", machine->name, codec->name);
+		 "%s (%s)", card->name, codec->name);
 
 	ret = snd_card_register(codec->card);
 	if (ret < 0) {

commit ea913940c39a61214c799cc7093d7b20fe11a94c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 5 11:13:21 2008 +0000

    ASoC: Remove core version number
    
    Rather than try to remember to keep the core version number updated
    (which hasn't been happening) just remove it.  It was much more useful
    when ASoC was out of tree.
    
    Signed-off-by: Mark brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1a173682965a..9feaa7b6dc34 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1965,7 +1965,6 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 
 static int __devinit snd_soc_init(void)
 {
-	printk(KERN_INFO "ASoC version %s\n", SND_SOC_VERSION);
 	return platform_driver_register(&soc_driver);
 }
 

commit 7aeb6d7d20185b7cede1ce5f6bd8d762e49bda6d
Merge: 71c21b4cf621 55e03a68d248 6b3ab21ef1ac
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 3 16:28:24 2008 +0100

    Merge branches 'topic/fix/misc' and 'topic/fix/hda' into for-linus

commit bb072bf0980abbe4fc905df91857a8ad34ca673c
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Nov 2 03:50:35 2008 +0100

    sound: struct device - replace bus_id with dev_name(), dev_set_name()
    
    [stripped sound/isa/* changes, replaced with the next patch -- tiwai]
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 462e635dfc74..0af3bbde5bbe 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -95,8 +95,8 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 	codec->ac97->dev.parent = NULL;
 	codec->ac97->dev.release = soc_ac97_device_release;
 
-	snprintf(codec->ac97->dev.bus_id, BUS_ID_SIZE, "%d-%d:%s",
-		 codec->card->number, 0, codec->name);
+	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
+		     codec->card->number, 0, codec->name);
 	err = device_register(&codec->ac97->dev);
 	if (err < 0) {
 		snd_printk(KERN_ERR "Can't register ac97 bus\n");

commit 04172c0b9ea5861e5cba7909da5297b3aedac9e1
Merge: 5b99e6ccf964 13d622b33dfb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 31 14:39:49 2008 +0100

    Merge branch 'topic/fix/asoc' into topic/asoc

commit f24368c2fb524e911b831b86b5f0acfb38c70317
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Oct 21 21:45:08 2008 +0100

    ASoC: Convert core to use standard debug print macros
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 411fd3bcf44f..8f384df941fd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -35,14 +35,6 @@
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
 
-/* debug */
-#define SOC_DEBUG 0
-#if SOC_DEBUG
-#define dbg(format, arg...) printk(format, ## arg)
-#else
-#define dbg(format, arg...)
-#endif
-
 static DEFINE_MUTEX(pcm_mutex);
 static DEFINE_MUTEX(io_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
@@ -229,12 +221,12 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		goto machine_err;
 	}
 
-	dbg("asoc: %s <-> %s info:\n", codec_dai->name, cpu_dai->name);
-	dbg("asoc: rate mask 0x%x\n", runtime->hw.rates);
-	dbg("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
-		runtime->hw.channels_max);
-	dbg("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
-		runtime->hw.rate_max);
+	pr_debug("asoc: %s <-> %s info:\n", codec_dai->name, cpu_dai->name);
+	pr_debug("asoc: rate mask 0x%x\n", runtime->hw.rates);
+	pr_debug("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
+		 runtime->hw.channels_max);
+	pr_debug("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
+		 runtime->hw.rate_max);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		cpu_dai->playback.active = codec_dai->playback.active = 1;
@@ -279,18 +271,18 @@ static void close_delayed_work(struct work_struct *work)
 	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];
 
-		dbg("pop wq checking: %s status: %s waiting: %s\n",
-			codec_dai->playback.stream_name,
-			codec_dai->playback.active ? "active" : "inactive",
-			codec_dai->pop_wait ? "yes" : "no");
+		pr_debug("pop wq checking: %s status: %s waiting: %s\n",
+			 codec_dai->playback.stream_name,
+			 codec_dai->playback.active ? "active" : "inactive",
+			 codec_dai->pop_wait ? "yes" : "no");
 
 		/* are we waiting on this codec DAI stream */
 		if (codec_dai->pop_wait == 1) {
 
 			/* Reduce power if no longer active */
 			if (codec->active == 0) {
-				dbg("pop wq D1 %s %s\n", codec->name,
-					codec_dai->playback.stream_name);
+				pr_debug("pop wq D1 %s %s\n", codec->name,
+					 codec_dai->playback.stream_name);
 				snd_soc_dapm_set_bias_level(socdev,
 					SND_SOC_BIAS_PREPARE);
 			}
@@ -302,8 +294,8 @@ static void close_delayed_work(struct work_struct *work)
 
 			/* Fall into standby if no longer active */
 			if (codec->active == 0) {
-				dbg("pop wq D3 %s %s\n", codec->name,
-					codec_dai->playback.stream_name);
+				pr_debug("pop wq D3 %s %s\n", codec->name,
+					 codec_dai->playback.stream_name);
 				snd_soc_dapm_set_bias_level(socdev,
 					SND_SOC_BIAS_STANDBY);
 			}

commit d45f6219d256b4e02f9ebee2e3911f4ea80bac70
Author: Mark Brown <broonie@sirena.org.uk>
Date:   Tue Oct 14 13:58:36 2008 +0100

    ASoC: Fix handling of DAPM suspend work
    
    Since we can query the playback stream power state directly we do not
    need to infer if it is powered up from the timer being scheduled.  Doing
    this avoids problems that previously existed with streams being
    incorrectly determined to be powered up caused when the timer is
    scheduled when streams are closed after being partially set up.
    
    Reported-by: Nobin Mathew <nobin.mathew@gmail.com>
    Reported-by: Jukka Hynninen <ext-jukka.hynninen@vaisala.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4707042b3dad..411fd3bcf44f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -429,51 +429,42 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 		}
 	}
 
-	/* we only want to start a DAPM playback stream if we are not waiting
-	 * on an existing one stopping */
-	if (codec_dai->pop_wait) {
-		/* we are waiting for the delayed work to start */
-		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-				snd_soc_dapm_stream_event(socdev->codec,
-					codec_dai->capture.stream_name,
-					SND_SOC_DAPM_STREAM_START);
-		else {
-			codec_dai->pop_wait = 0;
-			cancel_delayed_work(&socdev->delayed_work);
-			snd_soc_dai_digital_mute(codec_dai, 0);
-		}
-	} else {
-		/* no delayed work - do we need to power up codec */
-		if (codec->bias_level != SND_SOC_BIAS_ON) {
+	/* cancel any delayed stream shutdown that is pending */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+	    codec_dai->pop_wait) {
+		codec_dai->pop_wait = 0;
+		cancel_delayed_work(&socdev->delayed_work);
+	}
 
-			snd_soc_dapm_set_bias_level(socdev,
-						    SND_SOC_BIAS_PREPARE);
+	/* do we need to power up codec */
+	if (codec->bias_level != SND_SOC_BIAS_ON) {
+		snd_soc_dapm_set_bias_level(socdev,
+					    SND_SOC_BIAS_PREPARE);
 
-			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-				snd_soc_dapm_stream_event(codec,
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			snd_soc_dapm_stream_event(codec,
 					codec_dai->playback.stream_name,
 					SND_SOC_DAPM_STREAM_START);
-			else
-				snd_soc_dapm_stream_event(codec,
+		else
+			snd_soc_dapm_stream_event(codec,
 					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 
-			snd_soc_dapm_set_bias_level(socdev, SND_SOC_BIAS_ON);
-			snd_soc_dai_digital_mute(codec_dai, 0);
+		snd_soc_dapm_set_bias_level(socdev, SND_SOC_BIAS_ON);
+		snd_soc_dai_digital_mute(codec_dai, 0);
 
-		} else {
-			/* codec already powered - power on widgets */
-			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-				snd_soc_dapm_stream_event(codec,
+	} else {
+		/* codec already powered - power on widgets */
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			snd_soc_dapm_stream_event(codec,
 					codec_dai->playback.stream_name,
 					SND_SOC_DAPM_STREAM_START);
-			else
-				snd_soc_dapm_stream_event(codec,
+		else
+			snd_soc_dapm_stream_event(codec,
 					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 
-			snd_soc_dai_digital_mute(codec_dai, 0);
-		}
+		snd_soc_dai_digital_mute(codec_dai, 0);
 	}
 
 out:

commit 12ef193d5817504621e503e78d641265f6a86ac4
Author: Troy Kisky <troy.kisky@boundarydevices.com>
Date:   Mon Oct 13 17:42:14 2008 -0700

    ASoC: Allow setting codec register with debugfs filesystem
    
    i.e. echo 6 59 >/sys/kernel/debug/soc-audio.0/codec_reg
    will set register 0x06 to a value of 0x59.
    Also, pop_time debugfs interface setup is moved so that it
    is setup in the same function as codec_reg
    
    Signed-off-by: Troy Kisky <troy.kisky@boundarydevices.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 462e635dfc74..4707042b3dad 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -26,6 +26,7 @@
 #include <linux/delay.h>
 #include <linux/pm.h>
 #include <linux/bitops.h>
+#include <linux/debugfs.h>
 #include <linux/platform_device.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -961,10 +962,8 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 }
 
 /* codec register dump */
-static ssize_t codec_reg_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
+static ssize_t soc_codec_reg_show(struct snd_soc_device *devdata, char *buf)
 {
-	struct snd_soc_device *devdata = dev_get_drvdata(dev);
 	struct snd_soc_codec *codec = devdata->codec;
 	int i, step = 1, count = 0;
 
@@ -1001,8 +1000,117 @@ static ssize_t codec_reg_show(struct device *dev,
 
 	return count;
 }
+static ssize_t codec_reg_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
+	return soc_codec_reg_show(devdata, buf);
+}
+
 static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
 
+#ifdef CONFIG_DEBUG_FS
+static int codec_reg_open_file(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	struct snd_soc_device *devdata = file->private_data;
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	ret = soc_codec_reg_show(devdata, buf);
+	if (ret >= 0)
+		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+	return ret;
+}
+
+static ssize_t codec_reg_write_file(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[32];
+	int buf_size;
+	char *start = buf;
+	unsigned long reg, value;
+	int step = 1;
+	struct snd_soc_device *devdata = file->private_data;
+	struct snd_soc_codec *codec = devdata->codec;
+
+	buf_size = min(count, (sizeof(buf)-1));
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+
+	if (codec->reg_cache_step)
+		step = codec->reg_cache_step;
+
+	while (*start == ' ')
+		start++;
+	reg = simple_strtoul(start, &start, 16);
+	if ((reg >= codec->reg_cache_size) || (reg % step))
+		return -EINVAL;
+	while (*start == ' ')
+		start++;
+	if (strict_strtoul(start, 16, &value))
+		return -EINVAL;
+	codec->write(codec, reg, value);
+	return buf_size;
+}
+
+static const struct file_operations codec_reg_fops = {
+	.open = codec_reg_open_file,
+	.read = codec_reg_read_file,
+	.write = codec_reg_write_file,
+};
+
+static void soc_init_debugfs(struct snd_soc_device *socdev)
+{
+	struct dentry *root, *file;
+	struct snd_soc_codec *codec = socdev->codec;
+	root = debugfs_create_dir(dev_name(socdev->dev), NULL);
+	if (IS_ERR(root) || !root)
+		goto exit1;
+
+	file = debugfs_create_file("codec_reg", 0644,
+			root, socdev, &codec_reg_fops);
+	if (!file)
+		goto exit2;
+
+	file = debugfs_create_u32("dapm_pop_time", 0744,
+			root, &codec->pop_time);
+	if (!file)
+		goto exit2;
+	socdev->debugfs_root = root;
+	return;
+exit2:
+	debugfs_remove_recursive(root);
+exit1:
+	dev_err(socdev->dev, "debugfs is not available\n");
+}
+
+static void soc_cleanup_debugfs(struct snd_soc_device *socdev)
+{
+	debugfs_remove_recursive(socdev->debugfs_root);
+	socdev->debugfs_root = NULL;
+}
+
+#else
+
+static inline void soc_init_debugfs(struct snd_soc_device *socdev)
+{
+}
+
+static inline void soc_cleanup_debugfs(struct snd_soc_device *socdev)
+{
+}
+#endif
+
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec
@@ -1216,6 +1324,7 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 	if (err < 0)
 		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
 
+	soc_init_debugfs(socdev);
 	mutex_unlock(&codec->mutex);
 
 out:
@@ -1239,6 +1348,7 @@ void snd_soc_free_pcms(struct snd_soc_device *socdev)
 #endif
 
 	mutex_lock(&codec->mutex);
+	soc_cleanup_debugfs(socdev);
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];

commit 762b8df748d83c14070afbf0c6f8c0f4a91a13bf
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Oct 30 12:37:08 2008 +0000

    ALSA: ASoC: Fix mono controls after conversion to support full int masks
    
    When ASoC was converted to support full int width masks SOC_SINGLE_VALUE()
    omitted the assignment of rshift, causing the control operatins to report
    some mono controls as stereo. This happened to work some of the time due
    to a confusion between shift and min in snd_soc_info_volsw().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 462e635dfc74..a3adbf06b1e5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1462,7 +1462,7 @@ int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	int max = mc->max;
-	unsigned int shift = mc->min;
+	unsigned int shift = mc->shift;
 	unsigned int rshift = mc->rshift;
 
 	if (max == 1)

commit d331124dc2923ec0966a82e3428c532cee8da95f
Author: Liam Girdwood <lrg@slimlogic.co.uk>
Date:   Sun Oct 12 13:17:36 2008 +0100

    ALSA: ASoC: update email address for Liam Girdwood
    
    Update the contact information for Liam Girdwood in ASoC core and
    drivers as my old email address is no longer valid.
    
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ad381138fc2e..462e635dfc74 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4,8 +4,7 @@
  * Copyright 2005 Wolfson Microelectronics PLC.
  * Copyright 2005 Openedhand Ltd.
  *
- * Author: Liam Girdwood
- *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ * Author: Liam Girdwood <lrg@slimlogic.co.uk>
  *         with code, comments and ideas from :-
  *         Richard Purdie <richard@openedhand.com>
  *
@@ -1886,7 +1885,7 @@ module_init(snd_soc_init);
 module_exit(snd_soc_exit);
 
 /* Module information */
-MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_AUTHOR("Liam Girdwood, lrg@slimlogic.co.uk");
 MODULE_DESCRIPTION("ALSA SoC Core");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:soc-audio");

commit 6010b2da1f11752dd58191423fc9878b0ce420c8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Sep 6 18:33:24 2008 +0100

    ALSA: ASoC: Use codec digital mute when stopping playback
    
    Muting the DAC masks artefacts introduced as the digital stream shuts
    down, for example when the input stops being clocked.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 1563ceedf61a..ad381138fc2e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -340,6 +340,12 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	}
 	codec->active--;
 
+	/* Muting the DAC suppresses artifacts caused during digital
+	 * shutdown, for example from stopping clocks.
+	 */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_dai_digital_mute(codec_dai, 1);
+
 	if (cpu_dai->ops.shutdown)
 		cpu_dai->ops.shutdown(substream);
 

commit 815ecf8dec95d07e260a16ebe8409f4b7c0fdc0f
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   Tue Jul 29 10:22:24 2008 -0400

    ALSA: ASoC: convert use of uint to unsigned int
    
    ASOC: convert use of uint to unsigned int
    
    Signed-off-by: Jon Smirl <jonsmirl@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 11a881caba76..1563ceedf61a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1457,8 +1457,8 @@ int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	int max = mc->max;
-	uint shift = mc->min;
-	uint rshift = mc->rshift;
+	unsigned int shift = mc->min;
+	unsigned int rshift = mc->rshift;
 
 	if (max == 1)
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
@@ -1487,12 +1487,12 @@ int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	uint reg = mc->reg;
-	uint shift = mc->shift;
-	uint rshift = mc->rshift;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
 	int max = mc->max;
-	uint mask = (1 << fls(max)) - 1;
-	uint invert = mc->invert;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
 
 	ucontrol->value.integer.value[0] =
 		(snd_soc_read(codec, reg) >> shift) & mask;
@@ -1526,12 +1526,12 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	uint reg = mc->reg;
-	uint shift = mc->shift;
-	uint rshift = mc->rshift;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
 	int max = mc->max;
-	uint mask = (1 << fls(max)) - 1;
-	uint invert = mc->invert;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
 	unsigned short val, val2, val_mask;
 
 	val = (ucontrol->value.integer.value[0] & mask);
@@ -1594,12 +1594,12 @@ int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	uint reg = mc->reg;
-	uint reg2 = mc->rreg;
-	uint shift = mc->shift;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
 	int max = mc->max;
-	uint mask = (1<<fls(max))-1;
-	uint invert = mc->invert;
+	unsigned int mask = (1<<fls(max))-1;
+	unsigned int invert = mc->invert;
 
 	ucontrol->value.integer.value[0] =
 		(snd_soc_read(codec, reg) >> shift) & mask;
@@ -1631,12 +1631,12 @@ int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	uint reg = mc->reg;
-	uint reg2 = mc->rreg;
-	uint shift = mc->shift;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
 	int max = mc->max;
-	uint mask = (1 << fls(max)) - 1;
-	uint invert = mc->invert;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
 	int err;
 	unsigned short val, val2, val_mask;
 
@@ -1701,7 +1701,7 @@ int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	uint reg = mc->reg;
+	unsigned int reg = mc->reg;
 	int min = mc->min;
 	int val = snd_soc_read(codec, reg);
 
@@ -1728,7 +1728,7 @@ int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	uint reg = mc->reg;
+	unsigned int reg = mc->reg;
 	int min = mc->min;
 	unsigned short val;
 

commit f8ba0b7bfd06a2a5b3c49ff8d71cad31f57b0d51
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   Tue Jul 29 11:42:27 2008 +0100

    ALSA: ASoC: Rename mask to max to reflect usage
    
    Most of the ASoC controls refer to the maximum value that can be set for
    a control as mask but there is no actual requirement for all bits to be
    set at the highest possible value making the name mask misleading.
    Change the code to use max instead.
    
    Signed-off-by: Jon Smirl <jonsmirl@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4b94f1f6ee27..11a881caba76 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1316,10 +1316,10 @@ int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
-	uinfo->value.enumerated.items = e->mask;
+	uinfo->value.enumerated.items = e->max;
 
-	if (uinfo->value.enumerated.item > e->mask - 1)
-		uinfo->value.enumerated.item = e->mask - 1;
+	if (uinfo->value.enumerated.item > e->max - 1)
+		uinfo->value.enumerated.item = e->max - 1;
 	strcpy(uinfo->value.enumerated.name,
 		e->texts[uinfo->value.enumerated.item]);
 	return 0;
@@ -1342,7 +1342,7 @@ int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned short val, bitmask;
 
-	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
 		;
 	val = snd_soc_read(codec, e->reg);
 	ucontrol->value.enumerated.item[0]
@@ -1372,14 +1372,14 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 	unsigned short val;
 	unsigned short mask, bitmask;
 
-	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
 		;
-	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
+	if (ucontrol->value.enumerated.item[0] > e->max - 1)
 		return -EINVAL;
 	val = ucontrol->value.enumerated.item[0] << e->shift_l;
 	mask = (bitmask - 1) << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
+		if (ucontrol->value.enumerated.item[1] > e->max - 1)
 			return -EINVAL;
 		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
 		mask |= (bitmask - 1) << e->shift_r;
@@ -1406,10 +1406,10 @@ int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
-	uinfo->value.enumerated.items = e->mask;
+	uinfo->value.enumerated.items = e->max;
 
-	if (uinfo->value.enumerated.item > e->mask - 1)
-		uinfo->value.enumerated.item = e->mask - 1;
+	if (uinfo->value.enumerated.item > e->max - 1)
+		uinfo->value.enumerated.item = e->max - 1;
 	strcpy(uinfo->value.enumerated.name,
 		e->texts[uinfo->value.enumerated.item]);
 	return 0;

commit 4eaa9819dc08d7bfd1065ce530e31b18a119dcaf
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   Tue Jul 29 11:42:26 2008 +0100

    ALSA: ASoC: Convert bitfields in ASoC into full int width
    
    Convert bitfields in ASoC into full int width. This is a
    simple mechanical conversion. Two places in the DAPM code
    were fixed to properly use mask.
    
    Signed-off-by: Jon Smirl <jonsmirl@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5d3bf731a4b2..4b94f1f6ee27 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1454,9 +1454,11 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
 int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo)
 {
-	int max = (kcontrol->private_value >> 16) & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0x0f;
-	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int max = mc->max;
+	uint shift = mc->min;
+	uint rshift = mc->rshift;
 
 	if (max == 1)
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
@@ -1482,13 +1484,15 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
 int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0x0f;
-	int rshift = (kcontrol->private_value >> 12) & 0x0f;
-	int max = (kcontrol->private_value >> 16) & 0xff;
-	int mask = (1 << fls(max)) - 1;
-	int invert = (kcontrol->private_value >> 24) & 0x01;
+	uint reg = mc->reg;
+	uint shift = mc->shift;
+	uint rshift = mc->rshift;
+	int max = mc->max;
+	uint mask = (1 << fls(max)) - 1;
+	uint invert = mc->invert;
 
 	ucontrol->value.integer.value[0] =
 		(snd_soc_read(codec, reg) >> shift) & mask;
@@ -1519,13 +1523,15 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
 int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0x0f;
-	int rshift = (kcontrol->private_value >> 12) & 0x0f;
-	int max = (kcontrol->private_value >> 16) & 0xff;
-	int mask = (1 << fls(max)) - 1;
-	int invert = (kcontrol->private_value >> 24) & 0x01;
+	uint reg = mc->reg;
+	uint shift = mc->shift;
+	uint rshift = mc->rshift;
+	int max = mc->max;
+	uint mask = (1 << fls(max)) - 1;
+	uint invert = mc->invert;
 	unsigned short val, val2, val_mask;
 
 	val = (ucontrol->value.integer.value[0] & mask);
@@ -1557,7 +1563,9 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo)
 {
-	int max = (kcontrol->private_value >> 12) & 0xff;
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int max = mc->max;
 
 	if (max == 1)
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
@@ -1583,13 +1591,15 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
 int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int reg2 = (kcontrol->private_value >> 24) & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0x0f;
-	int max = (kcontrol->private_value >> 12) & 0xff;
-	int mask = (1<<fls(max))-1;
-	int invert = (kcontrol->private_value >> 20) & 0x01;
+	uint reg = mc->reg;
+	uint reg2 = mc->rreg;
+	uint shift = mc->shift;
+	int max = mc->max;
+	uint mask = (1<<fls(max))-1;
+	uint invert = mc->invert;
 
 	ucontrol->value.integer.value[0] =
 		(snd_soc_read(codec, reg) >> shift) & mask;
@@ -1618,13 +1628,15 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r);
 int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int reg2 = (kcontrol->private_value >> 24) & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0x0f;
-	int max = (kcontrol->private_value >> 12) & 0xff;
-	int mask = (1 << fls(max)) - 1;
-	int invert = (kcontrol->private_value >> 20) & 0x01;
+	uint reg = mc->reg;
+	uint reg2 = mc->rreg;
+	uint shift = mc->shift;
+	int max = mc->max;
+	uint mask = (1 << fls(max)) - 1;
+	uint invert = mc->invert;
 	int err;
 	unsigned short val, val2, val_mask;
 
@@ -1661,8 +1673,10 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);
 int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo)
 {
-	int max = (signed char)((kcontrol->private_value >> 16) & 0xff);
-	int min = (signed char)((kcontrol->private_value >> 24) & 0xff);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int max = mc->max;
+	int min = mc->min;
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -1684,9 +1698,11 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_s8);
 int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int min = (signed char)((kcontrol->private_value >> 24) & 0xff);
+	uint reg = mc->reg;
+	int min = mc->min;
 	int val = snd_soc_read(codec, reg);
 
 	ucontrol->value.integer.value[0] =
@@ -1709,9 +1725,11 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw_s8);
 int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int min = (signed char)((kcontrol->private_value >> 24) & 0xff);
+	uint reg = mc->reg;
+	int min = mc->min;
 	unsigned short val;
 
 	val = (ucontrol->value.integer.value[0]+min) & 0xff;

commit 58cd33c0f375578cfda25a52ed280caa888b6254
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jul 29 11:42:25 2008 +0100

    ALSA: ASoC: Allow codecs to override register display
    
    Some codecs have unusual features in their register maps such as very
    large registers representing arrays of coefficients. Support these
    codecs in the register cache sysfs file by allowing them to provide a
    function register_display() overriding the default output for register
    contents.
    
    Also ensure that we don't overflow PAGE_SIZE while writing out the
    register dump.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 83f1190293a8..5d3bf731a4b2 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -970,9 +970,29 @@ static ssize_t codec_reg_show(struct device *dev,
 		step = codec->reg_cache_step;
 
 	count += sprintf(buf, "%s registers\n", codec->name);
-	for (i = 0; i < codec->reg_cache_size; i += step)
-		count += sprintf(buf + count, "%2x: %4x\n", i,
-			codec->read(codec, i));
+	for (i = 0; i < codec->reg_cache_size; i += step) {
+		count += sprintf(buf + count, "%2x: ", i);
+		if (count >= PAGE_SIZE - 1)
+			break;
+
+		if (codec->display_register)
+			count += codec->display_register(codec, buf + count,
+							 PAGE_SIZE - count, i);
+		else
+			count += snprintf(buf + count, PAGE_SIZE - count,
+					  "%4x", codec->read(codec, i));
+
+		if (count >= PAGE_SIZE - 1)
+			break;
+
+		count += snprintf(buf + count, PAGE_SIZE - count, "\n");
+		if (count >= PAGE_SIZE - 1)
+			break;
+	}
+
+	/* Truncate count; min() would cause a warning */
+	if (count >= PAGE_SIZE)
+		count = PAGE_SIZE - 1;
 
 	return count;
 }

commit 8c6529dbf881303920a415c2d14a500218661949
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Tue Jul 8 13:19:13 2008 +0100

    ALSA: asoc: core - add Digital Audio Interface (DAI) control functions.
    
    This patch adds several functions for DAI control and config
    and replaces the current method of calling function pointers within
    the DAI struct.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 4d626b47b2ff..83f1190293a8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -434,8 +434,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 		else {
 			codec_dai->pop_wait = 0;
 			cancel_delayed_work(&socdev->delayed_work);
-			if (codec_dai->dai_ops.digital_mute)
-				codec_dai->dai_ops.digital_mute(codec_dai, 0);
+			snd_soc_dai_digital_mute(codec_dai, 0);
 		}
 	} else {
 		/* no delayed work - do we need to power up codec */
@@ -454,8 +453,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 					SND_SOC_DAPM_STREAM_START);
 
 			snd_soc_dapm_set_bias_level(socdev, SND_SOC_BIAS_ON);
-			if (codec_dai->dai_ops.digital_mute)
-				codec_dai->dai_ops.digital_mute(codec_dai, 0);
+			snd_soc_dai_digital_mute(codec_dai, 0);
 
 		} else {
 			/* codec already powered - power on widgets */
@@ -467,8 +465,8 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 				snd_soc_dapm_stream_event(codec,
 					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
-			if (codec_dai->dai_ops.digital_mute)
-				codec_dai->dai_ops.digital_mute(codec_dai, 0);
+
+			snd_soc_dai_digital_mute(codec_dai, 0);
 		}
 	}
 
@@ -566,8 +564,8 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 	mutex_lock(&pcm_mutex);
 
 	/* apply codec digital mute */
-	if (!codec->active && codec_dai->dai_ops.digital_mute)
-		codec_dai->dai_ops.digital_mute(codec_dai, 1);
+	if (!codec->active)
+		snd_soc_dai_digital_mute(codec_dai, 1);
 
 	/* free any machine hw params */
 	if (machine->ops && machine->ops->hw_free)
@@ -1703,6 +1701,132 @@ int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 
+/**
+ * snd_soc_dai_set_sysclk - configure DAI system or master clock.
+ * @dai: DAI
+ * @clk_id: DAI specific clock ID
+ * @freq: new clock frequency in Hz
+ * @dir: new clock direction - input/output.
+ *
+ * Configures the DAI master (MCLK) or system (SYSCLK) clocking.
+ */
+int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+	unsigned int freq, int dir)
+{
+	if (dai->dai_ops.set_sysclk)
+		return dai->dai_ops.set_sysclk(dai, clk_id, freq, dir);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
+
+/**
+ * snd_soc_dai_set_clkdiv - configure DAI clock dividers.
+ * @dai: DAI
+ * @clk_id: DAI specific clock divider ID
+ * @div: new clock divisor.
+ *
+ * Configures the clock dividers. This is used to derive the best DAI bit and
+ * frame clocks from the system or master clock. It's best to set the DAI bit
+ * and frame clocks as low as possible to save system power.
+ */
+int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
+	int div_id, int div)
+{
+	if (dai->dai_ops.set_clkdiv)
+		return dai->dai_ops.set_clkdiv(dai, div_id, div);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
+
+/**
+ * snd_soc_dai_set_pll - configure DAI PLL.
+ * @dai: DAI
+ * @pll_id: DAI specific PLL ID
+ * @freq_in: PLL input clock frequency in Hz
+ * @freq_out: requested PLL output clock frequency in Hz
+ *
+ * Configures and enables PLL to generate output clock based on input clock.
+ */
+int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
+	int pll_id, unsigned int freq_in, unsigned int freq_out)
+{
+	if (dai->dai_ops.set_pll)
+		return dai->dai_ops.set_pll(dai, pll_id, freq_in, freq_out);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
+
+/**
+ * snd_soc_dai_set_fmt - configure DAI hardware audio format.
+ * @dai: DAI
+ * @clk_id: DAI specific clock ID
+ * @fmt: SND_SOC_DAIFMT_ format value.
+ *
+ * Configures the DAI hardware format and clocking.
+ */
+int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	if (dai->dai_ops.set_fmt)
+		return dai->dai_ops.set_fmt(dai, fmt);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
+
+/**
+ * snd_soc_dai_set_tdm_slot - configure DAI TDM.
+ * @dai: DAI
+ * @mask: DAI specific mask representing used slots.
+ * @slots: Number of slots in use.
+ *
+ * Configures a DAI for TDM operation. Both mask and slots are codec and DAI
+ * specific.
+ */
+int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
+	unsigned int mask, int slots)
+{
+	if (dai->dai_ops.set_sysclk)
+		return dai->dai_ops.set_tdm_slot(dai, mask, slots);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
+
+/**
+ * snd_soc_dai_set_tristate - configure DAI system or master clock.
+ * @dai: DAI
+ * @tristate: tristate enable
+ *
+ * Tristates the DAI so that others can use it.
+ */
+int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
+{
+	if (dai->dai_ops.set_sysclk)
+		return dai->dai_ops.set_tristate(dai, tristate);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
+
+/**
+ * snd_soc_dai_digital_mute - configure DAI system or master clock.
+ * @dai: DAI
+ * @mute: mute enable
+ *
+ * Mutes the DAI DAC.
+ */
+int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	if (dai->dai_ops.digital_mute)
+		return dai->dai_ops.digital_mute(dai, mute);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
+
 static int __devinit snd_soc_init(void)
 {
 	printk(KERN_INFO "ASoC version %s\n", SND_SOC_VERSION);

commit 3c4b266fe642bcaebe2b95edb56c3f8802924ff9
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Mon Jul 7 16:07:17 2008 +0100

    ALSA: asoc: core - merge structs snd_soc_codec_dai and snd_soc_cpu_dai.
    
    This patch series merges struct snd_soc_codec_dai and struct
    snd_soc_cpu_dai into struct snd_soc_dai in preparation for further
    ASoC v2 patches.
    
    This merger removes duplication in both DAI structures and simplifies
    the API for other users.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bdbbc6a980fa..4d626b47b2ff 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -134,8 +134,8 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
-	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
@@ -272,7 +272,7 @@ static void close_delayed_work(struct work_struct *work)
 	struct snd_soc_device *socdev =
 		container_of(work, struct snd_soc_device, delayed_work.work);
 	struct snd_soc_codec *codec = socdev->codec;
-	struct snd_soc_codec_dai *codec_dai;
+	struct snd_soc_dai *codec_dai;
 	int i;
 
 	mutex_lock(&pcm_mutex);
@@ -323,8 +323,8 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
-	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	struct snd_soc_codec *codec = socdev->codec;
 
 	mutex_lock(&pcm_mutex);
@@ -384,8 +384,8 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
-	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	struct snd_soc_codec *codec = socdev->codec;
 	int ret = 0;
 
@@ -489,8 +489,8 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
-	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
@@ -559,8 +559,8 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
-	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	struct snd_soc_codec *codec = socdev->codec;
 
 	mutex_lock(&pcm_mutex);
@@ -594,8 +594,8 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
-	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
-	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
 	int ret;
 
 	if (codec_dai->ops.trigger) {
@@ -651,7 +651,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 
 	/* mute any active DAC's */
 	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		struct snd_soc_dai *dai = machine->dai_link[i].codec_dai;
 		if (dai->dai_ops.digital_mute && dai->playback.active)
 			dai->dai_ops.digital_mute(dai, 1);
 	}
@@ -664,7 +664,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 		machine->suspend_pre(pdev, state);
 
 	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_cpu_dai  *cpu_dai = machine->dai_link[i].cpu_dai;
+		struct snd_soc_dai  *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->suspend && cpu_dai->type != SND_SOC_DAI_AC97)
 			cpu_dai->suspend(pdev, cpu_dai);
 		if (platform->suspend)
@@ -690,7 +690,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 		codec_dev->suspend(pdev, state);
 
 	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->suspend && cpu_dai->type == SND_SOC_DAI_AC97)
 			cpu_dai->suspend(pdev, cpu_dai);
 	}
@@ -726,7 +726,7 @@ static void soc_resume_deferred(struct work_struct *work)
 		machine->resume_pre(pdev);
 
 	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->resume && cpu_dai->type == SND_SOC_DAI_AC97)
 			cpu_dai->resume(pdev, cpu_dai);
 	}
@@ -747,13 +747,13 @@ static void soc_resume_deferred(struct work_struct *work)
 
 	/* unmute any active DACs */
 	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		struct snd_soc_dai *dai = machine->dai_link[i].codec_dai;
 		if (dai->dai_ops.digital_mute && dai->playback.active)
 			dai->dai_ops.digital_mute(dai, 0);
 	}
 
 	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->resume && cpu_dai->type != SND_SOC_DAI_AC97)
 			cpu_dai->resume(pdev, cpu_dai);
 		if (platform->resume)
@@ -803,7 +803,7 @@ static int soc_probe(struct platform_device *pdev)
 	}
 
 	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->probe) {
 			ret = cpu_dai->probe(pdev, cpu_dai);
 			if (ret < 0)
@@ -838,7 +838,7 @@ static int soc_probe(struct platform_device *pdev)
 
 cpu_dai_err:
 	for (i--; i >= 0; i--) {
-		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->remove)
 			cpu_dai->remove(pdev, cpu_dai);
 	}
@@ -867,7 +867,7 @@ static int soc_remove(struct platform_device *pdev)
 		codec_dev->remove(pdev);
 
 	for (i = 0; i < machine->num_links; i++) {
-		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->remove)
 			cpu_dai->remove(pdev, cpu_dai);
 	}
@@ -895,8 +895,8 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	struct snd_soc_dai_link *dai_link, int num)
 {
 	struct snd_soc_codec *codec = socdev->codec;
-	struct snd_soc_codec_dai *codec_dai = dai_link->codec_dai;
-	struct snd_soc_cpu_dai *cpu_dai = dai_link->cpu_dai;
+	struct snd_soc_dai *codec_dai = dai_link->codec_dai;
+	struct snd_soc_dai *cpu_dai = dai_link->cpu_dai;
 	struct snd_soc_pcm_runtime *rtd;
 	struct snd_pcm *pcm;
 	char new_name[64];
@@ -1211,7 +1211,7 @@ void snd_soc_free_pcms(struct snd_soc_device *socdev)
 {
 	struct snd_soc_codec *codec = socdev->codec;
 #ifdef CONFIG_SND_SOC_AC97_BUS
-	struct snd_soc_codec_dai *codec_dai;
+	struct snd_soc_dai *codec_dai;
 	int i;
 #endif
 

commit 1301a964cef2759d46b4ce366eeeee1f869731f9
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Jun 17 19:19:34 2008 +0100

    ALSA: ASoC: fix PM=n build
    
    Fix sound/soc build failure when CONFIG_PM=n:
    
    linux-next-20080617/sound/soc/soc-core.c:829: error: 'soc_resume_deferred' undeclared (first use in this function)
    soc3.out:make[3]: *** [sound/soc/soc-core.o] Error 1
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index b931039632c5..bdbbc6a980fa 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -825,8 +825,10 @@ static int soc_probe(struct platform_device *pdev)
 
 	/* DAPM stream work */
 	INIT_DELAYED_WORK(&socdev->delayed_work, close_delayed_work);
+#ifdef CONFIG_PM
 	/* deferred resume work */
 	INIT_WORK(&socdev->deferred_resume_work, soc_resume_deferred);
+#endif
 
 	return 0;
 

commit 6ed2597883b1b03ca94f62f0cfe908314cba6d6b
Author: Andy Green <andy@openmoko.com>
Date:   Fri Jun 13 16:24:05 2008 +0100

    ALSA: ASoC: Don't block system resume
    
    On OpenMoko soc-audio resume is taking 700ms of the whole resume time of
    1.3s, dominated by writes to the codec over I2C.  This patch shunts the
    resume guts into a workqueue which then is done asynchronously.
    
    The "card" is locked using the ALSA power state APIs as suggested by
    Mark Brown.
    
    [Added fix for race with resume to suspend and fixed a couple of nits
    from checkpatch -- broonie.]
    
    Signed-off-by: Andy Green <andy@openmoko.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c96a6184d66e..b931039632c5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -639,6 +639,16 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	struct snd_soc_codec *codec = socdev->codec;
 	int i;
 
+	/* Due to the resume being scheduled into a workqueue we could
+	* suspend before that's finished - wait for it to complete.
+	 */
+	snd_power_lock(codec->card);
+	snd_power_wait(codec->card, SNDRV_CTL_POWER_D0);
+	snd_power_unlock(codec->card);
+
+	/* we're going to block userspace touching us until resume completes */
+	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D3hot);
+
 	/* mute any active DAC's */
 	for (i = 0; i < machine->num_links; i++) {
 		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
@@ -691,16 +701,27 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	return 0;
 }
 
-/* powers up audio subsystem after a suspend */
-static int soc_resume(struct platform_device *pdev)
+/* deferred resume work, so resume can complete before we finished
+ * setting our codec back up, which can be very slow on I2C
+ */
+static void soc_resume_deferred(struct work_struct *work)
 {
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_device *socdev = container_of(work,
+						     struct snd_soc_device,
+						     deferred_resume_work);
 	struct snd_soc_machine *machine = socdev->machine;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
+	struct platform_device *pdev = to_platform_device(socdev->dev);
 	int i;
 
+	/* our power state is still SNDRV_CTL_POWER_D3hot from suspend time,
+	 * so userspace apps are blocked from touching us
+	 */
+
+	dev_info(socdev->dev, "starting resume work\n");
+
 	if (machine->resume_pre)
 		machine->resume_pre(pdev);
 
@@ -742,6 +763,22 @@ static int soc_resume(struct platform_device *pdev)
 	if (machine->resume_post)
 		machine->resume_post(pdev);
 
+	dev_info(socdev->dev, "resume work completed\n");
+
+	/* userspace can access us now we are back as we were before */
+	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D0);
+}
+
+/* powers up audio subsystem after a suspend */
+static int soc_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+
+	dev_info(socdev->dev, "scheduling resume work\n");
+
+	if (!schedule_work(&socdev->deferred_resume_work))
+		dev_err(socdev->dev, "work item may be lost\n");
+
 	return 0;
 }
 
@@ -788,6 +825,9 @@ static int soc_probe(struct platform_device *pdev)
 
 	/* DAPM stream work */
 	INIT_DELAYED_WORK(&socdev->delayed_work, close_delayed_work);
+	/* deferred resume work */
+	INIT_WORK(&socdev->deferred_resume_work, soc_resume_deferred);
+
 	return 0;
 
 platform_err:

commit bdb92876f0a9d2b431199e385732ede89ff0b97d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jun 11 13:47:10 2008 +0100

    ALSA: ASoC: Pass the DAI being configured into CPU DAI probe and remove
    
    This allows per-DAI initialisation to be done by the CPU DAI drivers.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index f594ab888e17..c96a6184d66e 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -768,7 +768,7 @@ static int soc_probe(struct platform_device *pdev)
 	for (i = 0; i < machine->num_links; i++) {
 		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->probe) {
-			ret = cpu_dai->probe(pdev);
+			ret = cpu_dai->probe(pdev, cpu_dai);
 			if (ret < 0)
 				goto cpu_dai_err;
 		}
@@ -798,7 +798,7 @@ static int soc_probe(struct platform_device *pdev)
 	for (i--; i >= 0; i--) {
 		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->remove)
-			cpu_dai->remove(pdev);
+			cpu_dai->remove(pdev, cpu_dai);
 	}
 
 	if (machine->remove)
@@ -827,7 +827,7 @@ static int soc_remove(struct platform_device *pdev)
 	for (i = 0; i < machine->num_links; i++) {
 		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->remove)
-			cpu_dai->remove(pdev);
+			cpu_dai->remove(pdev, cpu_dai);
 	}
 
 	if (machine->remove)

commit e13ac2e9b18bde51cf32c69c2209df25791ab3e5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed May 28 17:58:05 2008 +0100

    [ALSA] ASoC: Add SOC_DOUBLE_S8_TLV control type
    
    The SOC_DOUBLE_S8_TLV control type was originally implemented in the
    UDA1380 driver by Philipp Zabel and was moved into the core by me.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a3f091e0843a..f594ab888e17 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1589,6 +1589,78 @@ int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);
 
+/**
+ * snd_soc_info_volsw_s8 - signed mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a signed mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int max = (signed char)((kcontrol->private_value >> 16) & 0xff);
+	int min = (signed char)((kcontrol->private_value >> 24) & 0xff);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = max-min;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_s8);
+
+/**
+ * snd_soc_get_volsw_s8 - signed mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a signed mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int min = (signed char)((kcontrol->private_value >> 24) & 0xff);
+	int val = snd_soc_read(codec, reg);
+
+	ucontrol->value.integer.value[0] =
+		((signed char)(val & 0xff))-min;
+	ucontrol->value.integer.value[1] =
+		((signed char)((val >> 8) & 0xff))-min;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_s8);
+
+/**
+ * snd_soc_put_volsw_sgn - signed mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a signed mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int min = (signed char)((kcontrol->private_value >> 24) & 0xff);
+	unsigned short val;
+
+	val = (ucontrol->value.integer.value[0]+min) & 0xff;
+	val |= ((ucontrol->value.integer.value[1]+min) & 0xff) << 8;
+
+	return snd_soc_update_bits(codec, reg, 0xffff, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
+
 static int __devinit snd_soc_init(void)
 {
 	printk(KERN_INFO "ASoC version %s\n", SND_SOC_VERSION);

commit 3ff3f64ba04b3e5a86dce5239b10268798f68ad7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 19 12:32:25 2008 +0200

    [ALSA] ASoC: core checkpatch cleanups
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index a05b3450aee8..a3f091e0843a 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -108,9 +108,9 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 }
 #endif
 
-static inline const char* get_dai_name(int type)
+static inline const char *get_dai_name(int type)
 {
-	switch(type) {
+	switch (type) {
 	case SND_SOC_DAI_AC97_BUS:
 	case SND_SOC_DAI_AC97:
 		return "AC97";
@@ -178,9 +178,11 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	/* Check that the codec and cpu DAI's are compatible */
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		runtime->hw.rate_min =
-			max(codec_dai->playback.rate_min, cpu_dai->playback.rate_min);
+			max(codec_dai->playback.rate_min,
+			    cpu_dai->playback.rate_min);
 		runtime->hw.rate_max =
-			min(codec_dai->playback.rate_max, cpu_dai->playback.rate_max);
+			min(codec_dai->playback.rate_max,
+			    cpu_dai->playback.rate_max);
 		runtime->hw.channels_min =
 			max(codec_dai->playback.channels_min,
 				cpu_dai->playback.channels_min);
@@ -193,9 +195,11 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 			codec_dai->playback.rates & cpu_dai->playback.rates;
 	} else {
 		runtime->hw.rate_min =
-			max(codec_dai->capture.rate_min, cpu_dai->capture.rate_min);
+			max(codec_dai->capture.rate_min,
+			    cpu_dai->capture.rate_min);
 		runtime->hw.rate_max =
-			min(codec_dai->capture.rate_max, cpu_dai->capture.rate_max);
+			min(codec_dai->capture.rate_max,
+			    cpu_dai->capture.rate_max);
 		runtime->hw.channels_min =
 			max(codec_dai->capture.channels_min,
 				cpu_dai->capture.channels_min);
@@ -225,7 +229,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		goto machine_err;
 	}
 
-	dbg("asoc: %s <-> %s info:\n",codec_dai->name, cpu_dai->name);
+	dbg("asoc: %s <-> %s info:\n", codec_dai->name, cpu_dai->name);
 	dbg("asoc: rate mask 0x%x\n", runtime->hw.rates);
 	dbg("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
 		runtime->hw.channels_max);
@@ -272,7 +276,7 @@ static void close_delayed_work(struct work_struct *work)
 	int i;
 
 	mutex_lock(&pcm_mutex);
-	for(i = 0; i < codec->num_dai; i++) {
+	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];
 
 		dbg("pop wq checking: %s status: %s waiting: %s\n",
@@ -511,7 +515,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	if (cpu_dai->ops.hw_params) {
 		ret = cpu_dai->ops.hw_params(substream, params);
 		if (ret < 0) {
-			printk(KERN_ERR "asoc: can't set interface %s hw params\n",
+			printk(KERN_ERR "asoc: interface %s hw params failed\n",
 				cpu_dai->name);
 			goto interface_err;
 		}
@@ -520,7 +524,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	if (platform->pcm_ops->hw_params) {
 		ret = platform->pcm_ops->hw_params(substream, params);
 		if (ret < 0) {
-			printk(KERN_ERR "asoc: can't set platform %s hw params\n",
+			printk(KERN_ERR "asoc: platform %s hw params failed\n",
 				platform->name);
 			goto platform_err;
 		}
@@ -539,7 +543,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		codec_dai->ops.hw_free(substream);
 
 codec_err:
-	if(machine->ops && machine->ops->hw_free)
+	if (machine->ops && machine->ops->hw_free)
 		machine->ops->hw_free(substream);
 
 	mutex_unlock(&pcm_mutex);
@@ -628,15 +632,15 @@ static struct snd_pcm_ops soc_pcm_ops = {
 /* powers down audio subsystem for suspend */
 static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 {
- 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
- 	struct snd_soc_machine *machine = socdev->machine;
- 	struct snd_soc_platform *platform = socdev->platform;
- 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
 	int i;
 
 	/* mute any active DAC's */
-	for(i = 0; i < machine->num_links; i++) {
+	for (i = 0; i < machine->num_links; i++) {
 		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
 		if (dai->dai_ops.digital_mute && dai->playback.active)
 			dai->dai_ops.digital_mute(dai, 1);
@@ -649,7 +653,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	if (machine->suspend_pre)
 		machine->suspend_pre(pdev, state);
 
-	for(i = 0; i < machine->num_links; i++) {
+	for (i = 0; i < machine->num_links; i++) {
 		struct snd_soc_cpu_dai  *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->suspend && cpu_dai->type != SND_SOC_DAI_AC97)
 			cpu_dai->suspend(pdev, cpu_dai);
@@ -661,7 +665,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	run_delayed_work(&socdev->delayed_work);
 	codec->suspend_bias_level = codec->bias_level;
 
-	for(i = 0; i < codec->num_dai; i++) {
+	for (i = 0; i < codec->num_dai; i++) {
 		char *stream = codec->dai[i].playback.stream_name;
 		if (stream != NULL)
 			snd_soc_dapm_stream_event(codec, stream,
@@ -675,7 +679,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	if (codec_dev->suspend)
 		codec_dev->suspend(pdev, state);
 
-	for(i = 0; i < machine->num_links; i++) {
+	for (i = 0; i < machine->num_links; i++) {
 		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->suspend && cpu_dai->type == SND_SOC_DAI_AC97)
 			cpu_dai->suspend(pdev, cpu_dai);
@@ -690,17 +694,17 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 /* powers up audio subsystem after a suspend */
 static int soc_resume(struct platform_device *pdev)
 {
- 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
- 	struct snd_soc_machine *machine = socdev->machine;
- 	struct snd_soc_platform *platform = socdev->platform;
- 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
 	int i;
 
 	if (machine->resume_pre)
 		machine->resume_pre(pdev);
 
-	for(i = 0; i < machine->num_links; i++) {
+	for (i = 0; i < machine->num_links; i++) {
 		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->resume && cpu_dai->type == SND_SOC_DAI_AC97)
 			cpu_dai->resume(pdev, cpu_dai);
@@ -709,8 +713,8 @@ static int soc_resume(struct platform_device *pdev)
 	if (codec_dev->resume)
 		codec_dev->resume(pdev);
 
-	for(i = 0; i < codec->num_dai; i++) {
-		char* stream = codec->dai[i].playback.stream_name;
+	for (i = 0; i < codec->num_dai; i++) {
+		char *stream = codec->dai[i].playback.stream_name;
 		if (stream != NULL)
 			snd_soc_dapm_stream_event(codec, stream,
 				SND_SOC_DAPM_STREAM_RESUME);
@@ -720,14 +724,14 @@ static int soc_resume(struct platform_device *pdev)
 				SND_SOC_DAPM_STREAM_RESUME);
 	}
 
-	/* unmute any active DAC's */
-	for(i = 0; i < machine->num_links; i++) {
+	/* unmute any active DACs */
+	for (i = 0; i < machine->num_links; i++) {
 		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
 		if (dai->dai_ops.digital_mute && dai->playback.active)
 			dai->dai_ops.digital_mute(dai, 0);
 	}
 
-	for(i = 0; i < machine->num_links; i++) {
+	for (i = 0; i < machine->num_links; i++) {
 		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->resume && cpu_dai->type != SND_SOC_DAI_AC97)
 			cpu_dai->resume(pdev, cpu_dai);
@@ -757,7 +761,7 @@ static int soc_probe(struct platform_device *pdev)
 
 	if (machine->probe) {
 		ret = machine->probe(pdev);
-		if(ret < 0)
+		if (ret < 0)
 			return ret;
 	}
 
@@ -765,20 +769,20 @@ static int soc_probe(struct platform_device *pdev)
 		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->probe) {
 			ret = cpu_dai->probe(pdev);
-			if(ret < 0)
+			if (ret < 0)
 				goto cpu_dai_err;
 		}
 	}
 
 	if (codec_dev->probe) {
 		ret = codec_dev->probe(pdev);
-		if(ret < 0)
+		if (ret < 0)
 			goto cpu_dai_err;
 	}
 
 	if (platform->probe) {
 		ret = platform->probe(pdev);
-		if(ret < 0)
+		if (ret < 0)
 			goto platform_err;
 	}
 
@@ -865,7 +869,7 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	codec_dai->codec = socdev->codec;
 
 	/* check client and interface hw capabilities */
-	sprintf(new_name, "%s %s-%s-%d",dai_link->stream_name, codec_dai->name,
+	sprintf(new_name, "%s %s-%s-%d", dai_link->stream_name, codec_dai->name,
 		get_dai_name(cpu_dai->type), num);
 
 	if (codec_dai->playback.channels_min)
@@ -876,7 +880,8 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	ret = snd_pcm_new(codec->card, new_name, codec->pcm_devs++, playback,
 		capture, &pcm);
 	if (ret < 0) {
-		printk(KERN_ERR "asoc: can't create pcm for codec %s\n", codec->name);
+		printk(KERN_ERR "asoc: can't create pcm for codec %s\n",
+			codec->name);
 		kfree(rtd);
 		return ret;
 	}
@@ -925,8 +930,9 @@ static ssize_t codec_reg_show(struct device *dev,
 		step = codec->reg_cache_step;
 
 	count += sprintf(buf, "%s registers\n", codec->name);
-	for(i = 0; i < codec->reg_cache_size; i += step)
-		count += sprintf(buf + count, "%2x: %4x\n", i, codec->read(codec, i));
+	for (i = 0; i < codec->reg_cache_size; i += step)
+		count += sprintf(buf + count, "%2x: %4x\n", i,
+			codec->read(codec, i));
 
 	return count;
 }
@@ -1069,7 +1075,7 @@ int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));
 
 	/* create the pcms */
-	for(i = 0; i < machine->num_links; i++) {
+	for (i = 0; i < machine->num_links; i++) {
 		ret = soc_new_pcm(socdev, &machine->dai_link[i], i);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't create pcm %s\n",
@@ -1099,7 +1105,7 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 	struct snd_soc_machine *machine = socdev->machine;
 	int ret = 0, i, ac97 = 0, err = 0;
 
-	for(i = 0; i < machine->num_links; i++) {
+	for (i = 0; i < machine->num_links; i++) {
 		if (socdev->machine->dai_link[i].init) {
 			err = socdev->machine->dai_link[i].init(codec);
 			if (err < 0) {
@@ -1108,7 +1114,7 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 				continue;
 			}
 		}
-		if (socdev->machine->dai_link[i].codec_dai->type == 
+		if (socdev->machine->dai_link[i].codec_dai->type ==
 			SND_SOC_DAI_AC97_BUS)
 			ac97 = 1;
 	}
@@ -1119,7 +1125,7 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 
 	ret = snd_card_register(codec->card);
 	if (ret < 0) {
-		printk(KERN_ERR "asoc: failed to register soundcard for codec %s\n",
+		printk(KERN_ERR "asoc: failed to register soundcard for %s\n",
 				codec->name);
 		goto out;
 	}
@@ -1143,7 +1149,7 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 
 	err = device_create_file(socdev->dev, &dev_attr_codec_reg);
 	if (err < 0)
-		printk(KERN_WARNING "asoc: failed to add codec sysfs entries\n");
+		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
 
 	mutex_unlock(&codec->mutex);
 
@@ -1169,7 +1175,7 @@ void snd_soc_free_pcms(struct snd_soc_device *socdev)
 
 	mutex_lock(&codec->mutex);
 #ifdef CONFIG_SND_SOC_AC97_BUS
-	for(i = 0; i < codec->num_dai; i++) {
+	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];
 		if (codec_dai->type == SND_SOC_DAI_AC97_BUS && codec->ac97) {
 			soc_ac97_dev_unregister(codec);
@@ -1279,7 +1285,8 @@ int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
 	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
 		;
 	val = snd_soc_read(codec, e->reg);
-	ucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);
+	ucontrol->value.enumerated.item[0]
+		= (val >> e->shift_l) & (bitmask - 1);
 	if (e->shift_l != e->shift_r)
 		ucontrol->value.enumerated.item[1] =
 			(val >> e->shift_r) & (bitmask - 1);
@@ -1573,7 +1580,8 @@ int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
 	val = val << shift;
 	val2 = val2 << shift;
 
-	if ((err = snd_soc_update_bits(codec, reg, val_mask, val)) < 0)
+	err = snd_soc_update_bits(codec, reg, val_mask, val);
+	if (err < 0)
 		return err;
 
 	err = snd_soc_update_bits(codec, reg2, val_mask, val2);
@@ -1589,7 +1597,7 @@ static int __devinit snd_soc_init(void)
 
 static void snd_soc_exit(void)
 {
- 	platform_driver_unregister(&soc_driver);
+	platform_driver_unregister(&soc_driver);
 }
 
 module_init(snd_soc_init);

commit 0be9898adb6f58fee44f0fec0bbc0eac997ea9eb
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 19 12:31:28 2008 +0200

    [ALSA] ASoC: Clarify API for bias configuration
    
    Currently the ASoC core configures the bias levels in the system using
    a callback on codecs and machines called 'dapm_event', passing it PCI
    style power levels as SNDRV_CTL_POWER_ constants. This is more obscure
    than it needs to be and has caused confusion to driver authors,
    especially given that DAPM is also performing power management.
    
    Address this by renaming the callback function to 'set_bias_level' and
    using constants explicitly representing the off, standby, pre-on and on
    states which DAPM transitions through.
    
    Also unexport the API for setting bias level: there are currently no
    in-tree users of this API other than the core itself and it is likely
    that the core would need to be extended to cater for any users.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Jarkko Nikula <jarkko.nikula@nokia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0318d8abe3e8..a05b3450aee8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -283,12 +283,12 @@ static void close_delayed_work(struct work_struct *work)
 		/* are we waiting on this codec DAI stream */
 		if (codec_dai->pop_wait == 1) {
 
-			/* power down the codec to D1 if no longer active */
+			/* Reduce power if no longer active */
 			if (codec->active == 0) {
 				dbg("pop wq D1 %s %s\n", codec->name,
 					codec_dai->playback.stream_name);
-				snd_soc_dapm_device_event(socdev,
-					SNDRV_CTL_POWER_D1);
+				snd_soc_dapm_set_bias_level(socdev,
+					SND_SOC_BIAS_PREPARE);
 			}
 
 			codec_dai->pop_wait = 0;
@@ -296,12 +296,12 @@ static void close_delayed_work(struct work_struct *work)
 				codec_dai->playback.stream_name,
 				SND_SOC_DAPM_STREAM_STOP);
 
-			/* power down the codec power domain if no longer active */
+			/* Fall into standby if no longer active */
 			if (codec->active == 0) {
 				dbg("pop wq D3 %s %s\n", codec->name,
 					codec_dai->playback.stream_name);
-				snd_soc_dapm_device_event(socdev,
-					SNDRV_CTL_POWER_D3hot);
+				snd_soc_dapm_set_bias_level(socdev,
+					SND_SOC_BIAS_STANDBY);
 			}
 		}
 	}
@@ -361,8 +361,8 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 			SND_SOC_DAPM_STREAM_STOP);
 
 		if (codec->active == 0 && codec_dai->pop_wait == 0)
-			snd_soc_dapm_device_event(socdev,
-						SNDRV_CTL_POWER_D3hot);
+			snd_soc_dapm_set_bias_level(socdev,
+						SND_SOC_BIAS_STANDBY);
 	}
 
 	mutex_unlock(&pcm_mutex);
@@ -435,9 +435,10 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 		}
 	} else {
 		/* no delayed work - do we need to power up codec */
-		if (codec->dapm_state != SNDRV_CTL_POWER_D0) {
+		if (codec->bias_level != SND_SOC_BIAS_ON) {
 
-			snd_soc_dapm_device_event(socdev,  SNDRV_CTL_POWER_D1);
+			snd_soc_dapm_set_bias_level(socdev,
+						    SND_SOC_BIAS_PREPARE);
 
 			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 				snd_soc_dapm_stream_event(codec,
@@ -448,7 +449,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 
-			snd_soc_dapm_device_event(socdev, SNDRV_CTL_POWER_D0);
+			snd_soc_dapm_set_bias_level(socdev, SND_SOC_BIAS_ON);
 			if (codec_dai->dai_ops.digital_mute)
 				codec_dai->dai_ops.digital_mute(codec_dai, 0);
 
@@ -658,7 +659,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 
 	/* close any waiting streams and save state */
 	run_delayed_work(&socdev->delayed_work);
-	codec->suspend_dapm_state = codec->dapm_state;
+	codec->suspend_bias_level = codec->bias_level;
 
 	for(i = 0; i < codec->num_dai; i++) {
 		char *stream = codec->dai[i].playback.stream_name;

commit b2efbbfba24efc8456d68d5af42d082ab1c2febc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 19 12:30:58 2008 +0200

    [ALSA] ASoC: Remove in-code changelogs
    
    The overwhelming majority just say 'initial version' anyway.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e148db940cfc..0318d8abe3e8 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -14,10 +14,6 @@
  *  Free Software Foundation;  either version 2 of the  License, or (at your
  *  option) any later version.
  *
- *  Revision history
- *    12th Aug 2005   Initial version.
- *    25th Oct 2005   Working Codec, Interface and Platform registration.
- *
  *  TODO:
  *   o Add hw rules to enforce rates, etc.
  *   o More testing with other codecs/machines.

commit 8b45a209935c4b79905182608922736ba0e5579e
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon Apr 14 13:33:36 2008 +0200

    [ALSA] sound: fix platform driver hotplug/coldplug
    
    Since 43cc71eed1250755986da4c0f9898f9a635cb3bf, the platform modalias is
    prefixed with "platform:".  Add MODULE_ALIAS() to the hotpluggable sound
    platform drivers, to re-enable auto loading.
    
    [dbrownell@users.sourceforge.net: more drivers, registration fixes]
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9eb5479787c1..e148db940cfc 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -839,6 +839,7 @@ static int soc_remove(struct platform_device *pdev)
 static struct platform_driver soc_driver = {
 	.driver		= {
 		.name		= "soc-audio",
+		.owner		= THIS_MODULE,
 	},
 	.probe		= soc_probe,
 	.remove		= soc_remove,
@@ -1601,3 +1602,4 @@ module_exit(snd_soc_exit);
 MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
 MODULE_DESCRIPTION("ALSA SoC Core");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:soc-audio");

commit 08c8efe6925ba712d65ca07877fa169b45f8d502
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jan 21 14:33:37 2008 +0100

    [ALSA] Fix lockdep warning in ASoC machine probe
    
    Don't take the codec mutex during machine probe until we have registered
    with ALSA, fixing a lockdep warning reported by Dmitry Baryshkov.
    Cc: Dmitry Baryshkov <dbaryshkov@gmail.com>
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 5f86e033098f..9eb5479787c1 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1101,7 +1101,6 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 	struct snd_soc_machine *machine = socdev->machine;
 	int ret = 0, i, ac97 = 0, err = 0;
 
-	mutex_lock(&codec->mutex);
 	for(i = 0; i < machine->num_links; i++) {
 		if (socdev->machine->dai_link[i].init) {
 			err = socdev->machine->dai_link[i].init(codec);
@@ -1127,12 +1126,14 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 		goto out;
 	}
 
+	mutex_lock(&codec->mutex);
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	if (ac97) {
 		ret = soc_ac97_dev_register(codec);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: AC97 device register failed\n");
 			snd_card_free(codec->card);
+			mutex_unlock(&codec->mutex);
 			goto out;
 		}
 	}
@@ -1145,8 +1146,10 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 	err = device_create_file(socdev->dev, &dev_attr_codec_reg);
 	if (err < 0)
 		printk(KERN_WARNING "asoc: failed to add codec sysfs entries\n");
-out:
+
 	mutex_unlock(&codec->mutex);
+
+out:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_register_card);

commit 4ccab3e72e211c40d868045c7d3216948999bcf7
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Thu Jan 10 14:39:01 2008 +0100

    [ALSA] soc - Ensure PCMs are suspended
    
    This fixes a bug whereby PCMs were not being suspended when the rest of the
    audio subsystem was suspended.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 7d51be8ee069..5f86e033098f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -645,6 +645,10 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 			dai->dai_ops.digital_mute(dai, 1);
 	}
 
+	/* suspend all pcms */
+	for (i = 0; i < machine->num_links; i++)
+		snd_pcm_suspend_all(machine->dai_link[i].pcm);
+
 	if (machine->suspend_pre)
 		machine->suspend_pre(pdev, state);
 
@@ -879,6 +883,7 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 		return ret;
 	}
 
+	dai_link->pcm = pcm;
 	pcm->private_data = rtd;
 	soc_pcm_ops.mmap = socdev->platform->pcm_ops->mmap;
 	soc_pcm_ops.pointer = socdev->platform->pcm_ops->pointer;

commit 3c1c47e0eb92264d555003ee2003f836e432615b
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Thu Jan 10 14:38:24 2008 +0100

    [ALSA] soc - Add D1 power event to power down event sequence
    
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e748b00466b7..7d51be8ee069 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -287,6 +287,14 @@ static void close_delayed_work(struct work_struct *work)
 		/* are we waiting on this codec DAI stream */
 		if (codec_dai->pop_wait == 1) {
 
+			/* power down the codec to D1 if no longer active */
+			if (codec->active == 0) {
+				dbg("pop wq D1 %s %s\n", codec->name,
+					codec_dai->playback.stream_name);
+				snd_soc_dapm_device_event(socdev,
+					SNDRV_CTL_POWER_D1);
+			}
+
 			codec_dai->pop_wait = 0;
 			snd_soc_dapm_stream_event(codec,
 				codec_dai->playback.stream_name,

commit a7a4ac86b4754f44eb06221f3087debb4775d588
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Thu Jan 10 14:37:42 2008 +0100

    [ALSA] ASoC TLV support
    
    Add TLV support to ASoC.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bd656db347ee..e748b00466b7 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1213,7 +1213,6 @@ struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
 	memcpy(&template, _template, sizeof(template));
 	if (long_name)
 		template.name = long_name;
-	template.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
 	template.index = 0;
 
 	return snd_ctl_new1(&template, data);
@@ -1348,13 +1347,16 @@ EXPORT_SYMBOL_GPL(snd_soc_info_enum_ext);
 int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo)
 {
-	int mask = kcontrol->private_value;
+	int max = kcontrol->private_value;
+
+	if (max == 1)
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 
-	uinfo->type =
-		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = mask;
+	uinfo->value.integer.max = max;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
@@ -1371,15 +1373,18 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
 int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo)
 {
-	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int max = (kcontrol->private_value >> 16) & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0x0f;
 	int rshift = (kcontrol->private_value >> 12) & 0x0f;
 
-	uinfo->type =
-		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	if (max == 1)
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
 	uinfo->count = shift == rshift ? 1 : 2;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = mask;
+	uinfo->value.integer.max = max;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
@@ -1400,7 +1405,8 @@ int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0x0f;
 	int rshift = (kcontrol->private_value >> 12) & 0x0f;
-	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int max = (kcontrol->private_value >> 16) & 0xff;
+	int mask = (1 << fls(max)) - 1;
 	int invert = (kcontrol->private_value >> 24) & 0x01;
 
 	ucontrol->value.integer.value[0] =
@@ -1410,10 +1416,10 @@ int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 			(snd_soc_read(codec, reg) >> rshift) & mask;
 	if (invert) {
 		ucontrol->value.integer.value[0] =
-			mask - ucontrol->value.integer.value[0];
+			max - ucontrol->value.integer.value[0];
 		if (shift != rshift)
 			ucontrol->value.integer.value[1] =
-				mask - ucontrol->value.integer.value[1];
+				max - ucontrol->value.integer.value[1];
 	}
 
 	return 0;
@@ -1436,25 +1442,24 @@ int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0x0f;
 	int rshift = (kcontrol->private_value >> 12) & 0x0f;
-	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int max = (kcontrol->private_value >> 16) & 0xff;
+	int mask = (1 << fls(max)) - 1;
 	int invert = (kcontrol->private_value >> 24) & 0x01;
-	int err;
 	unsigned short val, val2, val_mask;
 
 	val = (ucontrol->value.integer.value[0] & mask);
 	if (invert)
-		val = mask - val;
+		val = max - val;
 	val_mask = mask << shift;
 	val = val << shift;
 	if (shift != rshift) {
 		val2 = (ucontrol->value.integer.value[1] & mask);
 		if (invert)
-			val2 = mask - val2;
+			val2 = max - val2;
 		val_mask |= mask << rshift;
 		val |= val2 << rshift;
 	}
-	err = snd_soc_update_bits(codec, reg, val_mask, val);
-	return err;
+	return snd_soc_update_bits(codec, reg, val_mask, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 
@@ -1471,13 +1476,16 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo)
 {
-	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int max = (kcontrol->private_value >> 12) & 0xff;
+
+	if (max == 1)
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 
-	uinfo->type =
-		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = mask;
+	uinfo->value.integer.max = max;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
@@ -1498,7 +1506,8 @@ int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
 	int reg = kcontrol->private_value & 0xff;
 	int reg2 = (kcontrol->private_value >> 24) & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0x0f;
-	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int max = (kcontrol->private_value >> 12) & 0xff;
+	int mask = (1<<fls(max))-1;
 	int invert = (kcontrol->private_value >> 20) & 0x01;
 
 	ucontrol->value.integer.value[0] =
@@ -1507,9 +1516,9 @@ int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
 		(snd_soc_read(codec, reg2) >> shift) & mask;
 	if (invert) {
 		ucontrol->value.integer.value[0] =
-			mask - ucontrol->value.integer.value[0];
+			max - ucontrol->value.integer.value[0];
 		ucontrol->value.integer.value[1] =
-			mask - ucontrol->value.integer.value[1];
+			max - ucontrol->value.integer.value[1];
 	}
 
 	return 0;
@@ -1532,7 +1541,8 @@ int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
 	int reg = kcontrol->private_value & 0xff;
 	int reg2 = (kcontrol->private_value >> 24) & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0x0f;
-	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int max = (kcontrol->private_value >> 12) & 0xff;
+	int mask = (1 << fls(max)) - 1;
 	int invert = (kcontrol->private_value >> 20) & 0x01;
 	int err;
 	unsigned short val, val2, val_mask;
@@ -1542,8 +1552,8 @@ int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
 	val2 = (ucontrol->value.integer.value[1] & mask);
 
 	if (invert) {
-		val = mask - val;
-		val2 = mask - val2;
+		val = max - val;
+		val2 = max - val2;
 	}
 
 	val = val << shift;

commit 0b4d221b8d56deefca4984d01b3a010107ae1f72
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Thu Jan 10 14:36:20 2008 +0100

    [ALSA] soc - Add device level DAPM event
    
    Added a device level dapm event so that both the machine and codec are informed
    when dapm events occur.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 94075256638c..bd656db347ee 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -288,15 +288,16 @@ static void close_delayed_work(struct work_struct *work)
 		if (codec_dai->pop_wait == 1) {
 
 			codec_dai->pop_wait = 0;
-			snd_soc_dapm_stream_event(codec, codec_dai->playback.stream_name,
+			snd_soc_dapm_stream_event(codec,
+				codec_dai->playback.stream_name,
 				SND_SOC_DAPM_STREAM_STOP);
 
 			/* power down the codec power domain if no longer active */
 			if (codec->active == 0) {
 				dbg("pop wq D3 %s %s\n", codec->name,
 					codec_dai->playback.stream_name);
-		 		if (codec->dapm_event)
-					codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+				snd_soc_dapm_device_event(socdev,
+					SNDRV_CTL_POWER_D3hot);
 			}
 		}
 	}
@@ -352,12 +353,12 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	} else {
 		/* capture streams can be powered down now */
 		snd_soc_dapm_stream_event(codec,
-			codec_dai->capture.stream_name, SND_SOC_DAPM_STREAM_STOP);
+			codec_dai->capture.stream_name,
+			SND_SOC_DAPM_STREAM_STOP);
 
-		if (codec->active == 0 && codec_dai->pop_wait == 0){
-			if (codec->dapm_event)
-				codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
-		}
+		if (codec->active == 0 && codec_dai->pop_wait == 0)
+			snd_soc_dapm_device_event(socdev,
+						SNDRV_CTL_POWER_D3hot);
 	}
 
 	mutex_unlock(&pcm_mutex);
@@ -432,8 +433,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 		/* no delayed work - do we need to power up codec */
 		if (codec->dapm_state != SNDRV_CTL_POWER_D0) {
 
-			if (codec->dapm_event)
-				codec->dapm_event(codec, SNDRV_CTL_POWER_D1);
+			snd_soc_dapm_device_event(socdev,  SNDRV_CTL_POWER_D1);
 
 			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 				snd_soc_dapm_stream_event(codec,
@@ -444,8 +444,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 
-			if (codec->dapm_event)
-				codec->dapm_event(codec, SNDRV_CTL_POWER_D0);
+			snd_soc_dapm_device_event(socdev, SNDRV_CTL_POWER_D0);
 			if (codec_dai->dai_ops.digital_mute)
 				codec_dai->dai_ops.digital_mute(codec_dai, 0);
 

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e6a67b58f296..94075256638c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -32,7 +32,6 @@
 #include <linux/pm.h>
 #include <linux/bitops.h>
 #include <linux/platform_device.h>
-#include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>

commit 3a4fa0a25da81600ea0bcd75692ae8ca6050d165
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Fri Oct 19 23:10:43 2007 +0200

    Fix misspellings of "system", "controller", "interrupt" and "necessary".
    
    Fix the various misspellings of "system", controller", "interrupt" and
    "[un]necessary".
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 91651bdfa761..e6a67b58f296 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -264,7 +264,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 }
 
 /*
- * Power down the audio subsytem pmdown_time msecs after close is called.
+ * Power down the audio subsystem pmdown_time msecs after close is called.
  * This is to ensure there are no pops or clicks in between any music tracks
  * due to DAPM power cycling.
  */

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 92d5d917b73b..91651bdfa761 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1361,26 +1361,6 @@ int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
 
-/**
- * snd_soc_info_bool_ext - external single boolean mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a single boolean external mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_bool_ext(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_bool_ext);
-
 /**
  * snd_soc_info_volsw - single mixer info callback
  * @kcontrol: mixer control

commit a68660e0c63d8f7ab8725f9e771119c08e9f953b
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Thu May 10 19:27:27 2007 +0200

    [ALSA] ASoC AC97 device reg bugfix
    
    This patch fixes a bug whereby AC97 bus device data was being clobbered
    when AC97 codecs using the generic ac97_codec.c driver were being
    registered. Codecs that didn't use the generic driver were unaffected
    (e.g. WM9712, WM9713).
    Changes:-
     o Add new AC97 codec class for custom (or need bus dev registration)
    AC97 codecs.
     o Only register/deregister this custom codec device with the AC97 bus.
    The generic AC97 driver already does this for generic codec devices.
    This may be related to bug #3038 :-
    https://bugtrack.alsa-project.org/alsa-bug/view.php?id=3038
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 36519aef55d9..92d5d917b73b 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -116,6 +116,7 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 static inline const char* get_dai_name(int type)
 {
 	switch(type) {
+	case SND_SOC_DAI_AC97_BUS:
 	case SND_SOC_DAI_AC97:
 		return "AC97";
 	case SND_SOC_DAI_I2S:
@@ -1099,7 +1100,8 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 				continue;
 			}
 		}
-		if (socdev->machine->dai_link[i].cpu_dai->type == SND_SOC_DAI_AC97)
+		if (socdev->machine->dai_link[i].codec_dai->type == 
+			SND_SOC_DAI_AC97_BUS)
 			ac97 = 1;
 	}
 	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
@@ -1148,11 +1150,21 @@ EXPORT_SYMBOL_GPL(snd_soc_register_card);
 void snd_soc_free_pcms(struct snd_soc_device *socdev)
 {
 	struct snd_soc_codec *codec = socdev->codec;
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	struct snd_soc_codec_dai *codec_dai;
+	int i;
+#endif
 
 	mutex_lock(&codec->mutex);
 #ifdef CONFIG_SND_SOC_AC97_BUS
-	if (codec->ac97)
-		soc_ac97_dev_unregister(codec);
+	for(i = 0; i < codec->num_dai; i++) {
+		codec_dai = &codec->dai[i];
+		if (codec_dai->type == SND_SOC_DAI_AC97_BUS && codec->ac97) {
+			soc_ac97_dev_unregister(codec);
+			goto free_card;
+		}
+	}
+free_card:
 #endif
 
 	if (codec->card)

commit cb666e5bd865cc991c0048d6e81581019a141820
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Fri Feb 2 17:13:49 2007 +0100

    [ALSA] soc - ASoC 0.13 core changes
    
    This patch updates the ASoC core to the new DAI matching and clocking
    API in version 0.13
    Changes:-
     o Removed DAI capabilities matching code in favour of manual matching
    in the machine drivers.
     o Added DAI operations for codec and CPU interfaces.
     o Removed config_sysclk() function and struct snd_soc_clock_info. No
    longer needed as clocking is now configured manually in the machine
    drivers. Also removed other clocking data from structures.
     o Added machine driver prepare callback.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 87be938622dd..36519aef55d9 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -47,27 +47,11 @@
 #else
 #define dbg(format, arg...)
 #endif
-/* debug DAI capabilities matching */
-#define SOC_DEBUG_DAI 0
-#if SOC_DEBUG_DAI
-#define dbgc(format, arg...) printk(format, ## arg)
-#else
-#define dbgc(format, arg...)
-#endif
-
-#define CODEC_CPU(codec, cpu)	((codec << 4) | cpu)
 
 static DEFINE_MUTEX(pcm_mutex);
 static DEFINE_MUTEX(io_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 
-/* supported sample rates */
-/* ATTENTION: these values depend on the definition in pcm.h! */
-static const unsigned int rates[] = {
-	5512, 8000, 11025, 16000, 22050, 32000, 44100,
-	48000, 64000, 88200, 96000, 176400, 192000
-};
-
 /*
  * This is a timeout to do a DAPM powerdown after a stream is closed().
  * It can be used to eliminate pops between different playback streams, e.g.
@@ -142,458 +126,6 @@ static inline const char* get_dai_name(int type)
 	return NULL;
 }
 
-/* get rate format from rate */
-static inline int soc_get_rate_format(int rate)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(rates); i++) {
-		if (rates[i] == rate)
-			return 1 << i;
-	}
-	return 0;
-}
-
-/* gets the audio system mclk/sysclk for the given parameters */
-static unsigned inline int soc_get_mclk(struct snd_soc_pcm_runtime *rtd,
-	struct snd_soc_clock_info *info)
-{
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_machine *machine = socdev->machine;
-	int i;
-
-	/* find the matching machine config and get it's mclk for the given
-	 * sample rate and hardware format */
-	for(i = 0; i < machine->num_links; i++) {
-		if (machine->dai_link[i].cpu_dai == rtd->cpu_dai &&
-			machine->dai_link[i].config_sysclk)
-			return machine->dai_link[i].config_sysclk(rtd, info);
-	}
-	return 0;
-}
-
-/* changes a bitclk multiplier mask to a divider mask */
-static u64 soc_bfs_rcw_to_div(u64 bfs, int rate, unsigned int mclk,
-	unsigned int pcmfmt, unsigned int chn)
-{
-	int i, j;
-	u64 bfs_ = 0;
-	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
-
-	if (size <= 0)
-		return 0;
-
-	/* the minimum bit clock that has enough bandwidth */
-	min = size * rate * chn;
-	dbgc("rcw --> div min bclk %d with mclk %d\n", min, mclk);
-
-	for (i = 0; i < 64; i++) {
-		if ((bfs >> i) & 0x1) {
-			j = min * (i + 1);
-			bfs_ |= SND_SOC_FSBD(mclk/j);
-			dbgc("rcw --> div support mult %d\n",
-				SND_SOC_FSBD_REAL(1<<i));
-		}
-	}
-
-	return bfs_;
-}
-
-/* changes a bitclk divider mask to a multiplier mask */
-static u64 soc_bfs_div_to_rcw(u64 bfs, int rate, unsigned int mclk,
-	unsigned int pcmfmt, unsigned int chn)
-{
-	int i, j;
-	u64 bfs_ = 0;
-
-	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
-
-	if (size <= 0)
-		return 0;
-
-	/* the minimum bit clock that has enough bandwidth */
-	min = size * rate * chn;
-	dbgc("div to rcw min bclk %d with mclk %d\n", min, mclk);
-
-	for (i = 0; i < 64; i++) {
-		if ((bfs >> i) & 0x1) {
-			j = mclk / (i + 1);
-			if (j >= min) {
-				bfs_ |= SND_SOC_FSBW(j/min);
-				dbgc("div --> rcw support div %d\n",
-					SND_SOC_FSBW_REAL(1<<i));
-			}
-		}
-	}
-
-	return bfs_;
-}
-
-/* changes a constant bitclk to a multiplier mask */
-static u64 soc_bfs_rate_to_rcw(u64 bfs, int rate, unsigned int mclk,
-	unsigned int pcmfmt, unsigned int chn)
-{
-	unsigned int bfs_ = rate * bfs;
-	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
-
-	if (size <= 0)
-		return 0;
-
-	/* the minimum bit clock that has enough bandwidth */
-	min = size * rate * chn;
-	dbgc("rate --> rcw min bclk %d with mclk %d\n", min, mclk);
-
-	if (bfs_ < min)
-		return 0;
-	else {
-		bfs_ = SND_SOC_FSBW(bfs_/min);
-		dbgc("rate --> rcw support div %d\n", SND_SOC_FSBW_REAL(bfs_));
-		return bfs_;
-	}
-}
-
-/* changes a bitclk multiplier mask to a divider mask */
-static u64 soc_bfs_rate_to_div(u64 bfs, int rate, unsigned int mclk,
-	unsigned int pcmfmt, unsigned int chn)
-{
-	unsigned int bfs_ = rate * bfs;
-	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
-
-	if (size <= 0)
-		return 0;
-
-	/* the minimum bit clock that has enough bandwidth */
-	min = size * rate * chn;
-	dbgc("rate --> div min bclk %d with mclk %d\n", min, mclk);
-
-	if (bfs_ < min)
-		return 0;
-	else {
-		bfs_ = SND_SOC_FSBW(mclk/bfs_);
-		dbgc("rate --> div support div %d\n", SND_SOC_FSBD_REAL(bfs_));
-		return bfs_;
-	}
-}
-
-/* Matches codec DAI and SoC CPU DAI hardware parameters */
-static int soc_hw_match_params(struct snd_pcm_substream *substream,
-	struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai_mode *codec_dai_mode = NULL;
-	struct snd_soc_dai_mode *cpu_dai_mode = NULL;
-	struct snd_soc_clock_info clk_info;
-	unsigned int fs, mclk, rate = params_rate(params),
-		chn, j, k, cpu_bclk, codec_bclk, pcmrate;
-	u16 fmt = 0;
-	u64 codec_bfs, cpu_bfs;
-
-	dbg("asoc: match version %s\n", SND_SOC_VERSION);
-	clk_info.rate = rate;
-	pcmrate = soc_get_rate_format(rate);
-
-	/* try and find a match from the codec and cpu DAI capabilities */
-	for (j = 0; j < rtd->codec_dai->caps.num_modes; j++) {
-		for (k = 0; k < rtd->cpu_dai->caps.num_modes; k++) {
-			codec_dai_mode = &rtd->codec_dai->caps.mode[j];
-			cpu_dai_mode = &rtd->cpu_dai->caps.mode[k];
-
-			if (!(codec_dai_mode->pcmrate & cpu_dai_mode->pcmrate &
-					pcmrate)) {
-				dbgc("asoc: DAI[%d:%d] failed to match rate\n", j, k);
-				continue;
-			}
-
-			fmt = codec_dai_mode->fmt & cpu_dai_mode->fmt;
-			if (!(fmt & SND_SOC_DAIFMT_FORMAT_MASK)) {
-				dbgc("asoc: DAI[%d:%d] failed to match format\n", j, k);
-				continue;
-			}
-
-			if (!(fmt & SND_SOC_DAIFMT_CLOCK_MASK)) {
-				dbgc("asoc: DAI[%d:%d] failed to match clock masters\n",
-					 j, k);
-				continue;
-			}
-
-			if (!(fmt & SND_SOC_DAIFMT_INV_MASK)) {
-				dbgc("asoc: DAI[%d:%d] failed to match invert\n", j, k);
-				continue;
-			}
-
-			if (!(codec_dai_mode->pcmfmt & cpu_dai_mode->pcmfmt)) {
-				dbgc("asoc: DAI[%d:%d] failed to match pcm format\n", j, k);
-				continue;
-			}
-
-			if (!(codec_dai_mode->pcmdir & cpu_dai_mode->pcmdir)) {
-				dbgc("asoc: DAI[%d:%d] failed to match direction\n", j, k);
-				continue;
-			}
-
-			/* todo - still need to add tdm selection */
-			rtd->cpu_dai->dai_runtime.fmt =
-			rtd->codec_dai->dai_runtime.fmt =
-				1 << (ffs(fmt & SND_SOC_DAIFMT_FORMAT_MASK) -1) |
-				1 << (ffs(fmt & SND_SOC_DAIFMT_CLOCK_MASK) - 1) |
-				1 << (ffs(fmt & SND_SOC_DAIFMT_INV_MASK) - 1);
-			clk_info.bclk_master =
-				rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK;
-
-			/* make sure the ratio between rate and master
-			 * clock is acceptable*/
-			fs = (cpu_dai_mode->fs & codec_dai_mode->fs);
-			if (fs == 0) {
-				dbgc("asoc: DAI[%d:%d] failed to match FS\n", j, k);
-				continue;
-			}
-			clk_info.fs = rtd->cpu_dai->dai_runtime.fs =
-				rtd->codec_dai->dai_runtime.fs = fs;
-
-			/* calculate audio system clocking using slowest clocks possible*/
-			mclk = soc_get_mclk(rtd, &clk_info);
-			if (mclk == 0) {
-				dbgc("asoc: DAI[%d:%d] configuration not clockable\n", j, k);
-				dbgc("asoc: rate %d fs %d master %x\n", rate, fs,
-					clk_info.bclk_master);
-				continue;
-			}
-
-			/* calculate word size (per channel) and frame size */
-			rtd->codec_dai->dai_runtime.pcmfmt =
-				rtd->cpu_dai->dai_runtime.pcmfmt =
-				1 << params_format(params);
-
-			chn = params_channels(params);
-			/* i2s always has left and right */
-			if (params_channels(params) == 1 &&
-				rtd->cpu_dai->dai_runtime.fmt & (SND_SOC_DAIFMT_I2S |
-					SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_LEFT_J))
-				chn <<= 1;
-
-			/* Calculate bfs - the ratio between bitclock and the sample rate
-			 * We must take into consideration the dividers and multipliers
-			 * used in the codec and cpu DAI modes. We always choose the
-			 * lowest possible clocks to reduce power.
-			 */
-			switch (CODEC_CPU(codec_dai_mode->flags, cpu_dai_mode->flags)) {
-			case CODEC_CPU(SND_SOC_DAI_BFS_DIV, SND_SOC_DAI_BFS_DIV):
-				/* cpu & codec bfs dividers */
-				rtd->cpu_dai->dai_runtime.bfs =
-					rtd->codec_dai->dai_runtime.bfs =
-					1 << (fls(codec_dai_mode->bfs & cpu_dai_mode->bfs) - 1);
-				break;
-			case CODEC_CPU(SND_SOC_DAI_BFS_DIV, SND_SOC_DAI_BFS_RCW):
-				/* normalise bfs codec divider & cpu rcw mult */
-				codec_bfs = soc_bfs_div_to_rcw(codec_dai_mode->bfs, rate,
-					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
-				rtd->cpu_dai->dai_runtime.bfs =
-					1 << (ffs(codec_bfs & cpu_dai_mode->bfs) - 1);
-				cpu_bfs = soc_bfs_rcw_to_div(cpu_dai_mode->bfs, rate, mclk,
-						rtd->codec_dai->dai_runtime.pcmfmt, chn);
-				rtd->codec_dai->dai_runtime.bfs =
-					1 << (fls(codec_dai_mode->bfs & cpu_bfs) - 1);
-				break;
-			case CODEC_CPU(SND_SOC_DAI_BFS_RCW, SND_SOC_DAI_BFS_DIV):
-				/* normalise bfs codec rcw mult & cpu divider */
-				codec_bfs = soc_bfs_rcw_to_div(codec_dai_mode->bfs, rate,
-					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
-				rtd->cpu_dai->dai_runtime.bfs =
-					1 << (fls(codec_bfs & cpu_dai_mode->bfs) -1);
-				cpu_bfs = soc_bfs_div_to_rcw(cpu_dai_mode->bfs, rate, mclk,
-						rtd->codec_dai->dai_runtime.pcmfmt, chn);
-				rtd->codec_dai->dai_runtime.bfs =
-					1 << (ffs(codec_dai_mode->bfs & cpu_bfs) -1);
-				break;
-			case CODEC_CPU(SND_SOC_DAI_BFS_RCW, SND_SOC_DAI_BFS_RCW):
-				/* codec & cpu bfs rate rcw multipliers */
-				rtd->cpu_dai->dai_runtime.bfs =
-					rtd->codec_dai->dai_runtime.bfs =
-					1 << (ffs(codec_dai_mode->bfs & cpu_dai_mode->bfs) -1);
-				break;
-			case CODEC_CPU(SND_SOC_DAI_BFS_DIV, SND_SOC_DAI_BFS_RATE):
-				/* normalise cpu bfs rate const multiplier & codec div */
-				cpu_bfs = soc_bfs_rate_to_div(cpu_dai_mode->bfs, rate,
-					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
-				if(codec_dai_mode->bfs & cpu_bfs) {
-					rtd->codec_dai->dai_runtime.bfs = cpu_bfs;
-					rtd->cpu_dai->dai_runtime.bfs = cpu_dai_mode->bfs;
-				} else
-					rtd->cpu_dai->dai_runtime.bfs = 0;
-				break;
-			case CODEC_CPU(SND_SOC_DAI_BFS_RCW, SND_SOC_DAI_BFS_RATE):
-				/* normalise cpu bfs rate const multiplier & codec rcw mult */
-				cpu_bfs = soc_bfs_rate_to_rcw(cpu_dai_mode->bfs, rate,
-					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
-				if(codec_dai_mode->bfs & cpu_bfs) {
-					rtd->codec_dai->dai_runtime.bfs = cpu_bfs;
-					rtd->cpu_dai->dai_runtime.bfs = cpu_dai_mode->bfs;
-				} else
-					rtd->cpu_dai->dai_runtime.bfs = 0;
-				break;
-			case CODEC_CPU(SND_SOC_DAI_BFS_RATE, SND_SOC_DAI_BFS_RCW):
-				/* normalise cpu bfs rate rcw multiplier & codec const mult */
-				codec_bfs = soc_bfs_rate_to_rcw(codec_dai_mode->bfs, rate,
-					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
-				if(cpu_dai_mode->bfs & codec_bfs) {
-					rtd->cpu_dai->dai_runtime.bfs = codec_bfs;
-					rtd->codec_dai->dai_runtime.bfs = codec_dai_mode->bfs;
-				} else
-					rtd->cpu_dai->dai_runtime.bfs = 0;
-				break;
-			case CODEC_CPU(SND_SOC_DAI_BFS_RATE, SND_SOC_DAI_BFS_DIV):
-				/* normalise cpu bfs div & codec const mult */
-				codec_bfs = soc_bfs_rate_to_div(codec_dai_mode->bfs, rate,
-					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
-				if(cpu_dai_mode->bfs & codec_bfs) {
-					rtd->cpu_dai->dai_runtime.bfs = codec_bfs;
-					rtd->codec_dai->dai_runtime.bfs = codec_dai_mode->bfs;
-				} else
-					rtd->cpu_dai->dai_runtime.bfs = 0;
-				break;
-			case CODEC_CPU(SND_SOC_DAI_BFS_RATE, SND_SOC_DAI_BFS_RATE):
-				/* cpu & codec constant mult */
-				if(codec_dai_mode->bfs == cpu_dai_mode->bfs)
-					rtd->cpu_dai->dai_runtime.bfs =
-						rtd->codec_dai->dai_runtime.bfs =
-						codec_dai_mode->bfs;
-				else
-					rtd->cpu_dai->dai_runtime.bfs =
-						rtd->codec_dai->dai_runtime.bfs = 0;
-				break;
-			}
-
-			/* make sure the bit clock speed is acceptable */
-			if (!rtd->cpu_dai->dai_runtime.bfs ||
-				!rtd->codec_dai->dai_runtime.bfs) {
-				dbgc("asoc: DAI[%d:%d] failed to match BFS\n", j, k);
-				dbgc("asoc: cpu_dai %llu codec %llu\n",
-					rtd->cpu_dai->dai_runtime.bfs,
-					rtd->codec_dai->dai_runtime.bfs);
-				dbgc("asoc: mclk %d hwfmt %x\n", mclk, fmt);
-				continue;
-			}
-
-			goto found;
-		}
-	}
-	printk(KERN_ERR "asoc: no matching DAI found between codec and CPU\n");
-	return -EINVAL;
-
-found:
-	/* we have matching DAI's, so complete the runtime info */
-	rtd->codec_dai->dai_runtime.pcmrate =
-		rtd->cpu_dai->dai_runtime.pcmrate =
-		soc_get_rate_format(rate);
-
-	rtd->codec_dai->dai_runtime.priv = codec_dai_mode->priv;
-	rtd->cpu_dai->dai_runtime.priv = cpu_dai_mode->priv;
-	rtd->codec_dai->dai_runtime.flags = codec_dai_mode->flags;
-	rtd->cpu_dai->dai_runtime.flags = cpu_dai_mode->flags;
-
-	/* for debug atm */
-	dbg("asoc: DAI[%d:%d] Match OK\n", j, k);
-	if (rtd->codec_dai->dai_runtime.flags == SND_SOC_DAI_BFS_DIV) {
-		codec_bclk = (rtd->codec_dai->dai_runtime.fs * params_rate(params)) /
-			SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
-		dbg("asoc: codec fs %d mclk %d bfs div %d bclk %d\n",
-			rtd->codec_dai->dai_runtime.fs, mclk,
-			SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs),	codec_bclk);
-	} else if(rtd->codec_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RATE) {
-		codec_bclk = params_rate(params) * rtd->codec_dai->dai_runtime.bfs;
-		dbg("asoc: codec fs %d mclk %d bfs rate mult %llu bclk %d\n",
-			rtd->codec_dai->dai_runtime.fs, mclk,
-			rtd->codec_dai->dai_runtime.bfs, codec_bclk);
-	} else if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RCW) {
-		codec_bclk = params_rate(params) * params_channels(params) *
-			snd_pcm_format_physical_width(rtd->codec_dai->dai_runtime.pcmfmt) *
-			SND_SOC_FSBW_REAL(rtd->codec_dai->dai_runtime.bfs);
-		dbg("asoc: codec fs %d mclk %d bfs rcw mult %d bclk %d\n",
-			rtd->codec_dai->dai_runtime.fs, mclk,
-			SND_SOC_FSBW_REAL(rtd->codec_dai->dai_runtime.bfs), codec_bclk);
-	} else
-		codec_bclk = 0;
-
-	if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_DIV) {
-		cpu_bclk = (rtd->cpu_dai->dai_runtime.fs * params_rate(params)) /
-			SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs);
-		dbg("asoc: cpu fs %d mclk %d bfs div %d bclk %d\n",
-			rtd->cpu_dai->dai_runtime.fs, mclk,
-			SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs), cpu_bclk);
-	} else if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RATE) {
-		cpu_bclk = params_rate(params) * rtd->cpu_dai->dai_runtime.bfs;
-		dbg("asoc: cpu fs %d mclk %d bfs rate mult %llu bclk %d\n",
-			rtd->cpu_dai->dai_runtime.fs, mclk,
-			rtd->cpu_dai->dai_runtime.bfs, cpu_bclk);
-	} else if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RCW) {
-		cpu_bclk = params_rate(params) * params_channels(params) *
-			snd_pcm_format_physical_width(rtd->cpu_dai->dai_runtime.pcmfmt) *
-			SND_SOC_FSBW_REAL(rtd->cpu_dai->dai_runtime.bfs);
-		dbg("asoc: cpu fs %d mclk %d bfs mult rcw %d bclk %d\n",
-			rtd->cpu_dai->dai_runtime.fs, mclk,
-			SND_SOC_FSBW_REAL(rtd->cpu_dai->dai_runtime.bfs), cpu_bclk);
-	} else
-		cpu_bclk = 0;
-
-	/*
-	 * Check we have matching bitclocks. If we don't then it means the
-	 * sysclock returned by either the codec or cpu DAI (selected by the
-	 * machine sysclock function) is wrong compared with the supported DAI
-	 * modes for the codec or cpu DAI. Check  your codec or CPU DAI
-	 * config_sysclock() functions.
-	 */
-	if (cpu_bclk != codec_bclk && cpu_bclk){
-		printk(KERN_ERR
-			"asoc: codec and cpu bitclocks differ, audio may be wrong speed\n"
-			);
-		printk(KERN_ERR "asoc: codec %d != cpu %d\n", codec_bclk, cpu_bclk);
-	}
-
-	switch(rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		dbg("asoc: DAI codec BCLK master, LRC master\n");
-		break;
-	case SND_SOC_DAIFMT_CBS_CFM:
-		dbg("asoc: DAI codec BCLK slave, LRC master\n");
-		break;
-	case SND_SOC_DAIFMT_CBM_CFS:
-		dbg("asoc: DAI codec BCLK master, LRC slave\n");
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		dbg("asoc: DAI codec BCLK slave, LRC slave\n");
-		break;
-	}
-	dbg("asoc: mode %x, invert %x\n",
-		rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK,
-		rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK);
-	dbg("asoc: audio rate %d chn %d fmt %x\n", params_rate(params),
-		params_channels(params), params_format(params));
-
-	return 0;
-}
-
-static inline u32 get_rates(struct snd_soc_dai_mode *modes, int nmodes)
-{
-	int i;
-	u32 rates = 0;
-
-	for(i = 0; i < nmodes; i++)
-		rates |= modes[i].pcmrate;
-
-	return rates;
-}
-
-static inline u64 get_formats(struct snd_soc_dai_mode *modes, int nmodes)
-{
-	int i;
-	u64 formats = 0;
-
-	for(i = 0; i < nmodes; i++)
-		formats |= modes[i].pcmfmt;
-
-	return formats;
-}
-
 /*
  * Called by ALSA when a PCM substream is opened, the runtime->hw record is
  * then initialized and any private data can be allocated. This also calls
@@ -604,20 +136,20 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
-	struct snd_soc_codec_dai *codec_dai = rtd->codec_dai;
-	struct snd_soc_cpu_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
 
 	/* startup the audio subsystem */
-	if (rtd->cpu_dai->ops.startup) {
-		ret = rtd->cpu_dai->ops.startup(substream);
+	if (cpu_dai->ops.startup) {
+		ret = cpu_dai->ops.startup(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open interface %s\n",
-				rtd->cpu_dai->name);
+				cpu_dai->name);
 			goto out;
 		}
 	}
@@ -630,116 +162,101 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		}
 	}
 
-	if (machine->ops && machine->ops->startup) {
-		ret = machine->ops->startup(substream);
+	if (codec_dai->ops.startup) {
+		ret = codec_dai->ops.startup(substream);
 		if (ret < 0) {
-			printk(KERN_ERR "asoc: %s startup failed\n", machine->name);
-			goto machine_err;
+			printk(KERN_ERR "asoc: can't open codec %s\n",
+				codec_dai->name);
+			goto codec_dai_err;
 		}
 	}
 
-	if (rtd->codec_dai->ops.startup) {
-		ret = rtd->codec_dai->ops.startup(substream);
+	if (machine->ops && machine->ops->startup) {
+		ret = machine->ops->startup(substream);
 		if (ret < 0) {
-			printk(KERN_ERR "asoc: can't open codec %s\n",
-				rtd->codec_dai->name);
-			goto codec_dai_err;
+			printk(KERN_ERR "asoc: %s startup failed\n", machine->name);
+			goto machine_err;
 		}
 	}
 
-	/* create runtime params from DMA, codec and cpu DAI */
-	if (runtime->hw.rates)
-		runtime->hw.rates &=
-			get_rates(codec_dai->caps.mode, codec_dai->caps.num_modes) &
-			get_rates(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
-	else
-		runtime->hw.rates =
-			get_rates(codec_dai->caps.mode, codec_dai->caps.num_modes) &
-			get_rates(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
-	if (runtime->hw.formats)
-		runtime->hw.formats &=
-			get_formats(codec_dai->caps.mode, codec_dai->caps.num_modes) &
-			get_formats(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
-	else
-		runtime->hw.formats =
-			get_formats(codec_dai->caps.mode, codec_dai->caps.num_modes) &
-			get_formats(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
-
 	/* Check that the codec and cpu DAI's are compatible */
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		runtime->hw.rate_min =
-			max(rtd->codec_dai->playback.rate_min,
-				rtd->cpu_dai->playback.rate_min);
+			max(codec_dai->playback.rate_min, cpu_dai->playback.rate_min);
 		runtime->hw.rate_max =
-			min(rtd->codec_dai->playback.rate_max,
-				rtd->cpu_dai->playback.rate_max);
+			min(codec_dai->playback.rate_max, cpu_dai->playback.rate_max);
 		runtime->hw.channels_min =
-			max(rtd->codec_dai->playback.channels_min,
-				rtd->cpu_dai->playback.channels_min);
+			max(codec_dai->playback.channels_min,
+				cpu_dai->playback.channels_min);
 		runtime->hw.channels_max =
-			min(rtd->codec_dai->playback.channels_max,
-				rtd->cpu_dai->playback.channels_max);
+			min(codec_dai->playback.channels_max,
+				cpu_dai->playback.channels_max);
+		runtime->hw.formats =
+			codec_dai->playback.formats & cpu_dai->playback.formats;
+		runtime->hw.rates =
+			codec_dai->playback.rates & cpu_dai->playback.rates;
 	} else {
 		runtime->hw.rate_min =
-			max(rtd->codec_dai->capture.rate_min,
-				rtd->cpu_dai->capture.rate_min);
+			max(codec_dai->capture.rate_min, cpu_dai->capture.rate_min);
 		runtime->hw.rate_max =
-			min(rtd->codec_dai->capture.rate_max,
-				rtd->cpu_dai->capture.rate_max);
+			min(codec_dai->capture.rate_max, cpu_dai->capture.rate_max);
 		runtime->hw.channels_min =
-			max(rtd->codec_dai->capture.channels_min,
-				rtd->cpu_dai->capture.channels_min);
+			max(codec_dai->capture.channels_min,
+				cpu_dai->capture.channels_min);
 		runtime->hw.channels_max =
-			min(rtd->codec_dai->capture.channels_max,
-				rtd->cpu_dai->capture.channels_max);
+			min(codec_dai->capture.channels_max,
+				cpu_dai->capture.channels_max);
+		runtime->hw.formats =
+			codec_dai->capture.formats & cpu_dai->capture.formats;
+		runtime->hw.rates =
+			codec_dai->capture.rates & cpu_dai->capture.rates;
 	}
 
 	snd_pcm_limit_hw_rates(runtime);
 	if (!runtime->hw.rates) {
 		printk(KERN_ERR "asoc: %s <-> %s No matching rates\n",
-			rtd->codec_dai->name, rtd->cpu_dai->name);
-		goto codec_dai_err;
+			codec_dai->name, cpu_dai->name);
+		goto machine_err;
 	}
 	if (!runtime->hw.formats) {
 		printk(KERN_ERR "asoc: %s <-> %s No matching formats\n",
-			rtd->codec_dai->name, rtd->cpu_dai->name);
-		goto codec_dai_err;
+			codec_dai->name, cpu_dai->name);
+		goto machine_err;
 	}
 	if (!runtime->hw.channels_min || !runtime->hw.channels_max) {
 		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",
-			rtd->codec_dai->name, rtd->cpu_dai->name);
-		goto codec_dai_err;
+			codec_dai->name, cpu_dai->name);
+		goto machine_err;
 	}
 
-	dbg("asoc: %s <-> %s info:\n", rtd->codec_dai->name, rtd->cpu_dai->name);
+	dbg("asoc: %s <-> %s info:\n",codec_dai->name, cpu_dai->name);
 	dbg("asoc: rate mask 0x%x\n", runtime->hw.rates);
 	dbg("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
 		runtime->hw.channels_max);
 	dbg("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
 		runtime->hw.rate_max);
 
-
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		rtd->cpu_dai->playback.active = rtd->codec_dai->playback.active = 1;
+		cpu_dai->playback.active = codec_dai->playback.active = 1;
 	else
-		rtd->cpu_dai->capture.active = rtd->codec_dai->capture.active = 1;
-	rtd->cpu_dai->active = rtd->codec_dai->active = 1;
-	rtd->cpu_dai->runtime = runtime;
+		cpu_dai->capture.active = codec_dai->capture.active = 1;
+	cpu_dai->active = codec_dai->active = 1;
+	cpu_dai->runtime = runtime;
 	socdev->codec->active++;
 	mutex_unlock(&pcm_mutex);
 	return 0;
 
-codec_dai_err:
+machine_err:
 	if (machine->ops && machine->ops->shutdown)
 		machine->ops->shutdown(substream);
 
-machine_err:
+codec_dai_err:
 	if (platform->pcm_ops->close)
 		platform->pcm_ops->close(substream);
 
 platform_err:
-	if (rtd->cpu_dai->ops.shutdown)
-		rtd->cpu_dai->ops.shutdown(substream);
+	if (cpu_dai->ops.shutdown)
+		cpu_dai->ops.shutdown(substream);
 out:
 	mutex_unlock(&pcm_mutex);
 	return ret;
@@ -795,47 +312,49 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
 	struct snd_soc_codec *codec = socdev->codec;
 
 	mutex_lock(&pcm_mutex);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		rtd->cpu_dai->playback.active = rtd->codec_dai->playback.active = 0;
+		cpu_dai->playback.active = codec_dai->playback.active = 0;
 	else
-		rtd->cpu_dai->capture.active = rtd->codec_dai->capture.active = 0;
+		cpu_dai->capture.active = codec_dai->capture.active = 0;
 
-	if (rtd->codec_dai->playback.active == 0 &&
-		rtd->codec_dai->capture.active == 0) {
-		rtd->cpu_dai->active = rtd->codec_dai->active = 0;
+	if (codec_dai->playback.active == 0 &&
+		codec_dai->capture.active == 0) {
+		cpu_dai->active = codec_dai->active = 0;
 	}
 	codec->active--;
 
-	if (rtd->cpu_dai->ops.shutdown)
-		rtd->cpu_dai->ops.shutdown(substream);
+	if (cpu_dai->ops.shutdown)
+		cpu_dai->ops.shutdown(substream);
 
-	if (rtd->codec_dai->ops.shutdown)
-		rtd->codec_dai->ops.shutdown(substream);
+	if (codec_dai->ops.shutdown)
+		codec_dai->ops.shutdown(substream);
 
 	if (machine->ops && machine->ops->shutdown)
 		machine->ops->shutdown(substream);
 
 	if (platform->pcm_ops->close)
 		platform->pcm_ops->close(substream);
-	rtd->cpu_dai->runtime = NULL;
+	cpu_dai->runtime = NULL;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* start delayed pop wq here for playback streams */
-		rtd->codec_dai->pop_wait = 1;
+		codec_dai->pop_wait = 1;
 		schedule_delayed_work(&socdev->delayed_work,
 			msecs_to_jiffies(pmdown_time));
 	} else {
 		/* capture streams can be powered down now */
-		snd_soc_dapm_stream_event(codec, rtd->codec_dai->capture.stream_name,
-			SND_SOC_DAPM_STREAM_STOP);
+		snd_soc_dapm_stream_event(codec,
+			codec_dai->capture.stream_name, SND_SOC_DAPM_STREAM_STOP);
 
-		if (codec->active == 0 && rtd->codec_dai->pop_wait == 0){
+		if (codec->active == 0 && codec_dai->pop_wait == 0){
 			if (codec->dapm_event)
 				codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
 		}
@@ -854,11 +373,23 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
 	struct snd_soc_codec *codec = socdev->codec;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
+
+	if (machine->ops && machine->ops->prepare) {
+		ret = machine->ops->prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: machine prepare error\n");
+			goto out;
+		}
+	}
+
 	if (platform->pcm_ops->prepare) {
 		ret = platform->pcm_ops->prepare(substream);
 		if (ret < 0) {
@@ -867,30 +398,35 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 		}
 	}
 
-	if (rtd->codec_dai->ops.prepare) {
-		ret = rtd->codec_dai->ops.prepare(substream);
+	if (codec_dai->ops.prepare) {
+		ret = codec_dai->ops.prepare(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: codec DAI prepare error\n");
 			goto out;
 		}
 	}
 
-	if (rtd->cpu_dai->ops.prepare)
-		ret = rtd->cpu_dai->ops.prepare(substream);
+	if (cpu_dai->ops.prepare) {
+		ret = cpu_dai->ops.prepare(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: cpu DAI prepare error\n");
+			goto out;
+		}
+	}
 
 	/* we only want to start a DAPM playback stream if we are not waiting
 	 * on an existing one stopping */
-	if (rtd->codec_dai->pop_wait) {
+	if (codec_dai->pop_wait) {
 		/* we are waiting for the delayed work to start */
 		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-				snd_soc_dapm_stream_event(codec,
-					rtd->codec_dai->capture.stream_name,
+				snd_soc_dapm_stream_event(socdev->codec,
+					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 		else {
-			rtd->codec_dai->pop_wait = 0;
+			codec_dai->pop_wait = 0;
 			cancel_delayed_work(&socdev->delayed_work);
-			if (rtd->codec_dai->digital_mute)
-				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
+			if (codec_dai->dai_ops.digital_mute)
+				codec_dai->dai_ops.digital_mute(codec_dai, 0);
 		}
 	} else {
 		/* no delayed work - do we need to power up codec */
@@ -901,30 +437,30 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 
 			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 				snd_soc_dapm_stream_event(codec,
-					rtd->codec_dai->playback.stream_name,
+					codec_dai->playback.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 			else
 				snd_soc_dapm_stream_event(codec,
-					rtd->codec_dai->capture.stream_name,
+					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 
 			if (codec->dapm_event)
 				codec->dapm_event(codec, SNDRV_CTL_POWER_D0);
-			if (rtd->codec_dai->digital_mute)
-				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
+			if (codec_dai->dai_ops.digital_mute)
+				codec_dai->dai_ops.digital_mute(codec_dai, 0);
 
 		} else {
 			/* codec already powered - power on widgets */
 			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 				snd_soc_dapm_stream_event(codec,
-					rtd->codec_dai->playback.stream_name,
+					codec_dai->playback.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 			else
 				snd_soc_dapm_stream_event(codec,
-					rtd->codec_dai->capture.stream_name,
+					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
-			if (rtd->codec_dai->digital_mute)
-				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
+			if (codec_dai->dai_ops.digital_mute)
+				codec_dai->dai_ops.digital_mute(codec_dai, 0);
 		}
 	}
 
@@ -943,39 +479,36 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
-	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
 	int ret = 0;
 
 	mutex_lock(&pcm_mutex);
 
-	/* we don't need to match any AC97 params */
-	if (rtd->cpu_dai->type != SND_SOC_DAI_AC97) {
-		ret = soc_hw_match_params(substream, params);
-		if (ret < 0)
-			goto out;
-	} else {
-		struct snd_soc_clock_info clk_info;
-		clk_info.rate = params_rate(params);
-		ret = soc_get_mclk(rtd, &clk_info);
-		if (ret < 0)
+	if (machine->ops && machine->ops->hw_params) {
+		ret = machine->ops->hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: machine hw_params failed\n");
 			goto out;
+		}
 	}
 
-	if (rtd->codec_dai->ops.hw_params) {
-		ret = rtd->codec_dai->ops.hw_params(substream, params);
+	if (codec_dai->ops.hw_params) {
+		ret = codec_dai->ops.hw_params(substream, params);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
-				rtd->codec_dai->name);
-			goto out;
+				codec_dai->name);
+			goto codec_err;
 		}
 	}
 
-	if (rtd->cpu_dai->ops.hw_params) {
-		ret = rtd->cpu_dai->ops.hw_params(substream, params);
+	if (cpu_dai->ops.hw_params) {
+		ret = cpu_dai->ops.hw_params(substream, params);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't set interface %s hw params\n",
-				rtd->cpu_dai->name);
+				cpu_dai->name);
 			goto interface_err;
 		}
 	}
@@ -989,29 +522,21 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 		}
 	}
 
-	if (machine->ops && machine->ops->hw_params) {
-		ret = machine->ops->hw_params(substream, params);
-		if (ret < 0) {
-			printk(KERN_ERR "asoc: machine hw_params failed\n");
-			goto machine_err;
-		}
-	}
-
 out:
 	mutex_unlock(&pcm_mutex);
 	return ret;
 
-machine_err:
-	if (platform->pcm_ops->hw_free)
-		platform->pcm_ops->hw_free(substream);
-
 platform_err:
-	if (rtd->cpu_dai->ops.hw_free)
-		rtd->cpu_dai->ops.hw_free(substream);
+	if (cpu_dai->ops.hw_free)
+		cpu_dai->ops.hw_free(substream);
 
 interface_err:
-	if (rtd->codec_dai->ops.hw_free)
-		rtd->codec_dai->ops.hw_free(substream);
+	if (codec_dai->ops.hw_free)
+		codec_dai->ops.hw_free(substream);
+
+codec_err:
+	if(machine->ops && machine->ops->hw_free)
+		machine->ops->hw_free(substream);
 
 	mutex_unlock(&pcm_mutex);
 	return ret;
@@ -1024,15 +549,17 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
 	struct snd_soc_codec *codec = socdev->codec;
-	struct snd_soc_machine *machine = socdev->machine;
 
 	mutex_lock(&pcm_mutex);
 
 	/* apply codec digital mute */
-	if (!codec->active && rtd->codec_dai->digital_mute)
-		rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 1);
+	if (!codec->active && codec_dai->dai_ops.digital_mute)
+		codec_dai->dai_ops.digital_mute(codec_dai, 1);
 
 	/* free any machine hw params */
 	if (machine->ops && machine->ops->hw_free)
@@ -1043,11 +570,11 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 		platform->pcm_ops->hw_free(substream);
 
 	/* now free hw params for the DAI's  */
-	if (rtd->codec_dai->ops.hw_free)
-		rtd->codec_dai->ops.hw_free(substream);
+	if (codec_dai->ops.hw_free)
+		codec_dai->ops.hw_free(substream);
 
-	if (rtd->cpu_dai->ops.hw_free)
-		rtd->cpu_dai->ops.hw_free(substream);
+	if (cpu_dai->ops.hw_free)
+		cpu_dai->ops.hw_free(substream);
 
 	mutex_unlock(&pcm_mutex);
 	return 0;
@@ -1057,11 +584,14 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai_link *machine = rtd->dai;
 	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_cpu_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_codec_dai *codec_dai = machine->codec_dai;
 	int ret;
 
-	if (rtd->codec_dai->ops.trigger) {
-		ret = rtd->codec_dai->ops.trigger(substream, cmd);
+	if (codec_dai->ops.trigger) {
+		ret = codec_dai->ops.trigger(substream, cmd);
 		if (ret < 0)
 			return ret;
 	}
@@ -1072,8 +602,8 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 			return ret;
 	}
 
-	if (rtd->cpu_dai->ops.trigger) {
-		ret = rtd->cpu_dai->ops.trigger(substream, cmd);
+	if (cpu_dai->ops.trigger) {
+		ret = cpu_dai->ops.trigger(substream, cmd);
 		if (ret < 0)
 			return ret;
 	}
@@ -1104,8 +634,8 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	/* mute any active DAC's */
 	for(i = 0; i < machine->num_links; i++) {
 		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
-		if (dai->digital_mute && dai->playback.active)
-			dai->digital_mute(codec, dai, 1);
+		if (dai->dai_ops.digital_mute && dai->playback.active)
+			dai->dai_ops.digital_mute(dai, 1);
 	}
 
 	if (machine->suspend_pre)
@@ -1185,8 +715,8 @@ static int soc_resume(struct platform_device *pdev)
 	/* unmute any active DAC's */
 	for(i = 0; i < machine->num_links; i++) {
 		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
-		if (dai->digital_mute && dai->playback.active)
-			dai->digital_mute(codec, dai, 0);
+		if (dai->dai_ops.digital_mute && dai->playback.active)
+			dai->dai_ops.digital_mute(dai, 0);
 	}
 
 	for(i = 0; i < machine->num_links; i++) {
@@ -1320,9 +850,10 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
 	if (rtd == NULL)
 		return -ENOMEM;
-	rtd->cpu_dai = cpu_dai;
-	rtd->codec_dai = codec_dai;
+
+	rtd->dai = dai_link;
 	rtd->socdev = socdev;
+	codec_dai->codec = socdev->codec;
 
 	/* check client and interface hw capabilities */
 	sprintf(new_name, "%s %s-%s-%d",dai_link->stream_name, codec_dai->name,
@@ -1498,22 +1029,6 @@ int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
 }
 EXPORT_SYMBOL_GPL(snd_soc_test_bits);
 
-/**
- * snd_soc_get_rate - get int sample rate
- * @hwpcmrate: the hardware pcm rate
- *
- * Returns the audio rate integaer value, else 0.
- */
-int snd_soc_get_rate(int hwpcmrate)
-{
-	int rate = ffs(hwpcmrate) - 1;
-
-	if (rate > ARRAY_SIZE(rates))
-		return 0;
-	return rates[rate];
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_rate);
-
 /**
  * snd_soc_new_pcms - create new sound card and pcms
  * @socdev: the SoC audio device

commit bc7320c5c8ddeb3b50c6a24013dab9ba74bce578
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Thu Feb 1 12:26:07 2007 +0100

    [ALSA] ASoC very minor coding style fix for snd_soc_new_pcms()
    
    This very minor patch fixes the snd_soc_new_pcms() function to comply
    with the kernel coding style.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e5aa1c20dddb..87be938622dd 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1522,7 +1522,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_rate);
  *
  * Returns 0 for success, else error.
  */
-int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char * xid)
+int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 {
 	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_machine *machine = socdev->machine;

commit 965ac42ce919db225ee64678f0be02f2fdf5b5e4
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Wed Jan 31 14:14:57 2007 +0100

    [ALSA] ASoC force running of delayed PM work at suspend() and remove()
    
    This patch fixes a bug whereby the power management delayed work would
    never be run at driver suspend() or module remove(). Delayed work would
    be created (after audio had finished) with a long delay (~5 secs) and
    was sometimes never queued before flush_scheduled_work() was being
    called at suspend or module remove. This caused the delayed work to
    queued after the module had been removed or after resume.
    This patch forces any delayed work to complete by cancelling it (timer
    cannot fire and add it to queue later), scheduling it for now and
    waiting on it's completion.
    This is something I probably would like to add to workqueue.c in the
    next merge window, however it's here atm because it can oops.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 736949fbb4d5..e5aa1c20dddb 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -77,6 +77,25 @@ static int pmdown_time = 5000;
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
+/*
+ * This function forces any delayed work to be queued and run.
+ */
+static int run_delayed_work(struct delayed_work *dwork)
+{
+	int ret;
+
+	/* cancel any work waiting to be queued. */
+	ret = cancel_delayed_work(dwork);
+
+	/* if there was any work waiting then we run it now and
+	 * wait for it's completion */
+	if (ret) {
+		schedule_delayed_work(dwork, 0);
+		flush_scheduled_work();
+	}
+	return ret;
+}
+
 #ifdef CONFIG_SND_SOC_AC97_BUS
 /* unregister ac97 codec */
 static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
@@ -1101,7 +1120,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	}
 
 	/* close any waiting streams and save state */
-	flush_scheduled_work();
+	run_delayed_work(&socdev->delayed_work);
 	codec->suspend_dapm_state = codec->dapm_state;
 
 	for(i = 0; i < codec->num_dai; i++) {
@@ -1255,6 +1274,8 @@ static int soc_remove(struct platform_device *pdev)
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
+	run_delayed_work(&socdev->delayed_work);
+
 	if (platform->remove)
 		platform->remove(pdev);
 

commit 18b9b3d99677a758e77682d6849f58fc07e30bef
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Tue Jan 30 17:18:45 2007 +0100

    [ALSA] ASoC codec probe failure bug
    
    This patch fixes a bug whereby some resources were not being freed when
    codec probe() failed.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index cf84d8251715..736949fbb4d5 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1234,7 +1234,7 @@ static int soc_probe(struct platform_device *pdev)
 		codec_dev->remove(pdev);
 
 cpu_dai_err:
-	for (i--; i > 0; i--) {
+	for (i--; i >= 0; i--) {
 		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->remove)
 			cpu_dai->remove(pdev);

commit 4bb09523de50dcf1afc5d3099b9da0381f01b04c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 19 17:16:14 2006 +0100

    [ALSA] soc - Use global workqueue
    
    Use global workqueue for simplicity instead of own workqueue
    in SoC core and wm8750 codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9f23901fc85c..cf84d8251715 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -59,7 +59,6 @@
 
 static DEFINE_MUTEX(pcm_mutex);
 static DEFINE_MUTEX(io_mutex);
-static struct workqueue_struct *soc_workq;
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 
 /* supported sample rates */
@@ -810,7 +809,7 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* start delayed pop wq here for playback streams */
 		rtd->codec_dai->pop_wait = 1;
-		queue_delayed_work(soc_workq, &socdev->delayed_work,
+		schedule_delayed_work(&socdev->delayed_work,
 			msecs_to_jiffies(pmdown_time));
 	} else {
 		/* capture streams can be powered down now */
@@ -1102,7 +1101,7 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	}
 
 	/* close any waiting streams and save state */
-	flush_workqueue(soc_workq);
+	flush_scheduled_work();
 	codec->suspend_dapm_state = codec->dapm_state;
 
 	for(i = 0; i < codec->num_dai; i++) {
@@ -1227,16 +1226,9 @@ static int soc_probe(struct platform_device *pdev)
 	}
 
 	/* DAPM stream work */
-	soc_workq = create_workqueue("kdapm");
-	if (soc_workq == NULL)
-		goto work_err;
 	INIT_DELAYED_WORK(&socdev->delayed_work, close_delayed_work);
 	return 0;
 
-work_err:
-	if (platform->remove)
-		platform->remove(pdev);
-
 platform_err:
 	if (codec_dev->remove)
 		codec_dev->remove(pdev);
@@ -1263,9 +1255,6 @@ static int soc_remove(struct platform_device *pdev)
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
-	if (soc_workq)
-		destroy_workqueue(soc_workq);
-
 	if (platform->remove)
 		platform->remove(pdev);
 

commit 0664d888a55ff99c8556690a3ae7c76dc1389008
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Mon Dec 18 14:39:02 2006 +0100

    [ALSA] Additional credits to soc-core
    
    This patch adds copyright and credit for my good friend Richard Purdie
    from OpenedHand for his help and code contribution throughout the
    development of the core code. Many thanks Richard (I guess we overlooked
    this in trying to get everything working well).
    It also adds some extra comments wrt to DAI clock matching.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 0bae14145a03..9f23901fc85c 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -2,8 +2,12 @@
  * soc-core.c  --  ALSA SoC Audio Layer
  *
  * Copyright 2005 Wolfson Microelectronics PLC.
+ * Copyright 2005 Openedhand Ltd.
+ *
  * Author: Liam Girdwood
  *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *         with code, comments and ideas from :-
+ *         Richard Purdie <richard@openedhand.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -517,7 +521,8 @@ static int soc_hw_match_params(struct snd_pcm_substream *substream,
 	 * Check we have matching bitclocks. If we don't then it means the
 	 * sysclock returned by either the codec or cpu DAI (selected by the
 	 * machine sysclock function) is wrong compared with the supported DAI
-	 * modes for the codec or cpu DAI.
+	 * modes for the codec or cpu DAI. Check  your codec or CPU DAI
+	 * config_sysclock() functions.
 	 */
 	if (cpu_bclk != codec_bclk && cpu_bclk){
 		printk(KERN_ERR

commit 4484bb2e93a9ab636d149edc6515c75ea224e2b0
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Dec 15 09:30:07 2006 +0100

    [ALSA] Fix the soc code after dhowells workqueue changes.
    
    From: Andrew Morton <akpm@osdl.org>
    I converted the workqueues to per-device while I was there.  It seems
    strange to create a new kernel thread (on each CPU!) and to then only
    have a single global work to ever be queued upon it.
    Plus without this, I'd have to use the _NAR stuff, gawd help me.
    Does that workqueue really need to be per-cpu?
    Does that workqueue really need to exist?  Why not use keventd?
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: David Howells <dhowells@redhat.com>
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 90e8841e7e33..0bae14145a03 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -56,7 +56,6 @@
 static DEFINE_MUTEX(pcm_mutex);
 static DEFINE_MUTEX(io_mutex);
 static struct workqueue_struct *soc_workq;
-static struct work_struct soc_stream_work;
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
 
 /* supported sample rates */
@@ -728,9 +727,10 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
  * This is to ensure there are no pops or clicks in between any music tracks
  * due to DAPM power cycling.
  */
-static void close_delayed_work(void *data)
+static void close_delayed_work(struct work_struct *work)
 {
-	struct snd_soc_device *socdev = data;
+	struct snd_soc_device *socdev =
+		container_of(work, struct snd_soc_device, delayed_work.work);
 	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_codec_dai *codec_dai;
 	int i;
@@ -805,7 +805,7 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* start delayed pop wq here for playback streams */
 		rtd->codec_dai->pop_wait = 1;
-		queue_delayed_work(soc_workq, &soc_stream_work,
+		queue_delayed_work(soc_workq, &socdev->delayed_work,
 			msecs_to_jiffies(pmdown_time));
 	} else {
 		/* capture streams can be powered down now */
@@ -865,7 +865,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 					SND_SOC_DAPM_STREAM_START);
 		else {
 			rtd->codec_dai->pop_wait = 0;
-			cancel_delayed_work(&soc_stream_work);
+			cancel_delayed_work(&socdev->delayed_work);
 			if (rtd->codec_dai->digital_mute)
 				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
 		}
@@ -1225,7 +1225,7 @@ static int soc_probe(struct platform_device *pdev)
 	soc_workq = create_workqueue("kdapm");
 	if (soc_workq == NULL)
 		goto work_err;
-	INIT_WORK(&soc_stream_work, close_delayed_work, socdev);
+	INIT_DELAYED_WORK(&socdev->delayed_work, close_delayed_work);
 	return 0;
 
 work_err:

commit 2e26e483694059d63bda7bb89d5a464c952d1d44
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Mon Nov 27 12:05:04 2006 +0100

    [ALSA] ASoC - Bit clock matching error
    
    This patch by Philipp Zabel fixes a bug whereby the BCLK matching fails
    when the Codec BCLK is constant and the CPU BCLK is based upon a
    divider.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 6da1616bf776..90e8841e7e33 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -424,7 +424,7 @@ static int soc_hw_match_params(struct snd_pcm_substream *substream,
 				/* normalise cpu bfs div & codec const mult */
 				codec_bfs = soc_bfs_rate_to_div(codec_dai_mode->bfs, rate,
 					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
-				if(codec_dai_mode->bfs & codec_bfs) {
+				if(cpu_dai_mode->bfs & codec_bfs) {
 					rtd->cpu_dai->dai_runtime.bfs = codec_bfs;
 					rtd->codec_dai->dai_runtime.bfs = codec_dai_mode->bfs;
 				} else

commit a71a468a50f1385855e28864e26251b02df829bb
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Thu Oct 19 20:35:56 2006 +0200

    [ALSA] ASoC: Add support for BCLK based on (Rate * Chn * Word Size)
    
    This patch adds support for the DAI BCLK to be generated by multiplying
    Rate * Channels * Word Size (RCW).
    This now gives 3 options for BCLK clocking and synchronisation :-
     1. BCLK = Rate * x
     2. BCLK = MCLK / x
     3. BCLK = Rate * Chn * Word Size.  (New)
    Changes:-
     o Add support for RCW generation of BCLK
     o Update Documentation to include RCW.
     o Update DAI documentation for label = value DAI modes.
     o Add RCW support to wm8731, wm8750 and pxa2xx-i2s drivers.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 2ce0c8251dc3..6da1616bf776 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -51,6 +51,8 @@
 #define dbgc(format, arg...)
 #endif
 
+#define CODEC_CPU(codec, cpu)	((codec << 4) | cpu)
+
 static DEFINE_MUTEX(pcm_mutex);
 static DEFINE_MUTEX(io_mutex);
 static struct workqueue_struct *soc_workq;
@@ -150,11 +152,11 @@ static unsigned inline int soc_get_mclk(struct snd_soc_pcm_runtime *rtd,
 }
 
 /* changes a bitclk multiplier mask to a divider mask */
-static u16 soc_bfs_mult_to_div(u16 bfs, int rate, unsigned int mclk,
+static u64 soc_bfs_rcw_to_div(u64 bfs, int rate, unsigned int mclk,
 	unsigned int pcmfmt, unsigned int chn)
 {
 	int i, j;
-	u16 bfs_ = 0;
+	u64 bfs_ = 0;
 	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
 
 	if (size <= 0)
@@ -162,17 +164,14 @@ static u16 soc_bfs_mult_to_div(u16 bfs, int rate, unsigned int mclk,
 
 	/* the minimum bit clock that has enough bandwidth */
 	min = size * rate * chn;
-	dbgc("mult --> div min bclk %d with mclk %d\n", min, mclk);
+	dbgc("rcw --> div min bclk %d with mclk %d\n", min, mclk);
 
-	for (i = 0; i < 16; i++) {
+	for (i = 0; i < 64; i++) {
 		if ((bfs >> i) & 0x1) {
-			j = rate * SND_SOC_FSB_REAL(1<<i);
-
-			if (j >= min) {
-				bfs_ |= SND_SOC_FSBD(mclk/j);
-				dbgc("mult --> div support mult %d\n",
-					SND_SOC_FSB_REAL(1<<i));
-			}
+			j = min * (i + 1);
+			bfs_ |= SND_SOC_FSBD(mclk/j);
+			dbgc("rcw --> div support mult %d\n",
+				SND_SOC_FSBD_REAL(1<<i));
 		}
 	}
 
@@ -180,11 +179,11 @@ static u16 soc_bfs_mult_to_div(u16 bfs, int rate, unsigned int mclk,
 }
 
 /* changes a bitclk divider mask to a multiplier mask */
-static u16 soc_bfs_div_to_mult(u16 bfs, int rate, unsigned int mclk,
+static u64 soc_bfs_div_to_rcw(u64 bfs, int rate, unsigned int mclk,
 	unsigned int pcmfmt, unsigned int chn)
 {
 	int i, j;
-	u16 bfs_ = 0;
+	u64 bfs_ = 0;
 
 	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
 
@@ -193,15 +192,15 @@ static u16 soc_bfs_div_to_mult(u16 bfs, int rate, unsigned int mclk,
 
 	/* the minimum bit clock that has enough bandwidth */
 	min = size * rate * chn;
-	dbgc("div to mult min bclk %d with mclk %d\n", min, mclk);
+	dbgc("div to rcw min bclk %d with mclk %d\n", min, mclk);
 
-	for (i = 0; i < 16; i++) {
+	for (i = 0; i < 64; i++) {
 		if ((bfs >> i) & 0x1) {
-			j = mclk / (SND_SOC_FSBD_REAL(1<<i));
+			j = mclk / (i + 1);
 			if (j >= min) {
-				bfs_ |= SND_SOC_FSB(j/rate);
-				dbgc("div --> mult support div %d\n",
-					SND_SOC_FSBD_REAL(1<<i));
+				bfs_ |= SND_SOC_FSBW(j/min);
+				dbgc("div --> rcw support div %d\n",
+					SND_SOC_FSBW_REAL(1<<i));
 			}
 		}
 	}
@@ -209,6 +208,52 @@ static u16 soc_bfs_div_to_mult(u16 bfs, int rate, unsigned int mclk,
 	return bfs_;
 }
 
+/* changes a constant bitclk to a multiplier mask */
+static u64 soc_bfs_rate_to_rcw(u64 bfs, int rate, unsigned int mclk,
+	unsigned int pcmfmt, unsigned int chn)
+{
+	unsigned int bfs_ = rate * bfs;
+	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
+
+	if (size <= 0)
+		return 0;
+
+	/* the minimum bit clock that has enough bandwidth */
+	min = size * rate * chn;
+	dbgc("rate --> rcw min bclk %d with mclk %d\n", min, mclk);
+
+	if (bfs_ < min)
+		return 0;
+	else {
+		bfs_ = SND_SOC_FSBW(bfs_/min);
+		dbgc("rate --> rcw support div %d\n", SND_SOC_FSBW_REAL(bfs_));
+		return bfs_;
+	}
+}
+
+/* changes a bitclk multiplier mask to a divider mask */
+static u64 soc_bfs_rate_to_div(u64 bfs, int rate, unsigned int mclk,
+	unsigned int pcmfmt, unsigned int chn)
+{
+	unsigned int bfs_ = rate * bfs;
+	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
+
+	if (size <= 0)
+		return 0;
+
+	/* the minimum bit clock that has enough bandwidth */
+	min = size * rate * chn;
+	dbgc("rate --> div min bclk %d with mclk %d\n", min, mclk);
+
+	if (bfs_ < min)
+		return 0;
+	else {
+		bfs_ = SND_SOC_FSBW(mclk/bfs_);
+		dbgc("rate --> div support div %d\n", SND_SOC_FSBD_REAL(bfs_));
+		return bfs_;
+	}
+}
+
 /* Matches codec DAI and SoC CPU DAI hardware parameters */
 static int soc_hw_match_params(struct snd_pcm_substream *substream,
 	struct snd_pcm_hw_params *params)
@@ -217,9 +262,10 @@ static int soc_hw_match_params(struct snd_pcm_substream *substream,
 	struct snd_soc_dai_mode *codec_dai_mode = NULL;
 	struct snd_soc_dai_mode *cpu_dai_mode = NULL;
 	struct snd_soc_clock_info clk_info;
-	unsigned int fs, mclk, codec_bfs, cpu_bfs, rate = params_rate(params),
+	unsigned int fs, mclk, rate = params_rate(params),
 		chn, j, k, cpu_bclk, codec_bclk, pcmrate;
 	u16 fmt = 0;
+	u64 codec_bfs, cpu_bfs;
 
 	dbg("asoc: match version %s\n", SND_SOC_VERSION);
 	clk_info.rate = rate;
@@ -309,44 +355,98 @@ static int soc_hw_match_params(struct snd_pcm_substream *substream,
 			 * used in the codec and cpu DAI modes. We always choose the
 			 * lowest possible clocks to reduce power.
 			 */
-			if (codec_dai_mode->flags & cpu_dai_mode->flags &
-				SND_SOC_DAI_BFS_DIV) {
+			switch (CODEC_CPU(codec_dai_mode->flags, cpu_dai_mode->flags)) {
+			case CODEC_CPU(SND_SOC_DAI_BFS_DIV, SND_SOC_DAI_BFS_DIV):
 				/* cpu & codec bfs dividers */
 				rtd->cpu_dai->dai_runtime.bfs =
 					rtd->codec_dai->dai_runtime.bfs =
 					1 << (fls(codec_dai_mode->bfs & cpu_dai_mode->bfs) - 1);
-			} else if (codec_dai_mode->flags & SND_SOC_DAI_BFS_DIV) {
-				/* normalise bfs codec divider & cpu mult */
-				codec_bfs = soc_bfs_div_to_mult(codec_dai_mode->bfs, rate,
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_DIV, SND_SOC_DAI_BFS_RCW):
+				/* normalise bfs codec divider & cpu rcw mult */
+				codec_bfs = soc_bfs_div_to_rcw(codec_dai_mode->bfs, rate,
 					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
 				rtd->cpu_dai->dai_runtime.bfs =
 					1 << (ffs(codec_bfs & cpu_dai_mode->bfs) - 1);
-				cpu_bfs = soc_bfs_mult_to_div(cpu_dai_mode->bfs, rate, mclk,
+				cpu_bfs = soc_bfs_rcw_to_div(cpu_dai_mode->bfs, rate, mclk,
 						rtd->codec_dai->dai_runtime.pcmfmt, chn);
 				rtd->codec_dai->dai_runtime.bfs =
 					1 << (fls(codec_dai_mode->bfs & cpu_bfs) - 1);
-			} else if (cpu_dai_mode->flags & SND_SOC_DAI_BFS_DIV) {
-				/* normalise bfs codec mult & cpu divider */
-				codec_bfs = soc_bfs_mult_to_div(codec_dai_mode->bfs, rate,
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RCW, SND_SOC_DAI_BFS_DIV):
+				/* normalise bfs codec rcw mult & cpu divider */
+				codec_bfs = soc_bfs_rcw_to_div(codec_dai_mode->bfs, rate,
 					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
 				rtd->cpu_dai->dai_runtime.bfs =
 					1 << (fls(codec_bfs & cpu_dai_mode->bfs) -1);
-				cpu_bfs = soc_bfs_div_to_mult(cpu_dai_mode->bfs, rate, mclk,
+				cpu_bfs = soc_bfs_div_to_rcw(cpu_dai_mode->bfs, rate, mclk,
 						rtd->codec_dai->dai_runtime.pcmfmt, chn);
 				rtd->codec_dai->dai_runtime.bfs =
 					1 << (ffs(codec_dai_mode->bfs & cpu_bfs) -1);
-			} else {
-				/* codec & cpu bfs rate multipliers */
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RCW, SND_SOC_DAI_BFS_RCW):
+				/* codec & cpu bfs rate rcw multipliers */
 				rtd->cpu_dai->dai_runtime.bfs =
 					rtd->codec_dai->dai_runtime.bfs =
 					1 << (ffs(codec_dai_mode->bfs & cpu_dai_mode->bfs) -1);
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_DIV, SND_SOC_DAI_BFS_RATE):
+				/* normalise cpu bfs rate const multiplier & codec div */
+				cpu_bfs = soc_bfs_rate_to_div(cpu_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				if(codec_dai_mode->bfs & cpu_bfs) {
+					rtd->codec_dai->dai_runtime.bfs = cpu_bfs;
+					rtd->cpu_dai->dai_runtime.bfs = cpu_dai_mode->bfs;
+				} else
+					rtd->cpu_dai->dai_runtime.bfs = 0;
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RCW, SND_SOC_DAI_BFS_RATE):
+				/* normalise cpu bfs rate const multiplier & codec rcw mult */
+				cpu_bfs = soc_bfs_rate_to_rcw(cpu_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				if(codec_dai_mode->bfs & cpu_bfs) {
+					rtd->codec_dai->dai_runtime.bfs = cpu_bfs;
+					rtd->cpu_dai->dai_runtime.bfs = cpu_dai_mode->bfs;
+				} else
+					rtd->cpu_dai->dai_runtime.bfs = 0;
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RATE, SND_SOC_DAI_BFS_RCW):
+				/* normalise cpu bfs rate rcw multiplier & codec const mult */
+				codec_bfs = soc_bfs_rate_to_rcw(codec_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				if(cpu_dai_mode->bfs & codec_bfs) {
+					rtd->cpu_dai->dai_runtime.bfs = codec_bfs;
+					rtd->codec_dai->dai_runtime.bfs = codec_dai_mode->bfs;
+				} else
+					rtd->cpu_dai->dai_runtime.bfs = 0;
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RATE, SND_SOC_DAI_BFS_DIV):
+				/* normalise cpu bfs div & codec const mult */
+				codec_bfs = soc_bfs_rate_to_div(codec_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				if(codec_dai_mode->bfs & codec_bfs) {
+					rtd->cpu_dai->dai_runtime.bfs = codec_bfs;
+					rtd->codec_dai->dai_runtime.bfs = codec_dai_mode->bfs;
+				} else
+					rtd->cpu_dai->dai_runtime.bfs = 0;
+				break;
+			case CODEC_CPU(SND_SOC_DAI_BFS_RATE, SND_SOC_DAI_BFS_RATE):
+				/* cpu & codec constant mult */
+				if(codec_dai_mode->bfs == cpu_dai_mode->bfs)
+					rtd->cpu_dai->dai_runtime.bfs =
+						rtd->codec_dai->dai_runtime.bfs =
+						codec_dai_mode->bfs;
+				else
+					rtd->cpu_dai->dai_runtime.bfs =
+						rtd->codec_dai->dai_runtime.bfs = 0;
+				break;
 			}
 
 			/* make sure the bit clock speed is acceptable */
 			if (!rtd->cpu_dai->dai_runtime.bfs ||
 				!rtd->codec_dai->dai_runtime.bfs) {
 				dbgc("asoc: DAI[%d:%d] failed to match BFS\n", j, k);
-				dbgc("asoc: cpu_dai %x codec %x\n",
+				dbgc("asoc: cpu_dai %llu codec %llu\n",
 					rtd->cpu_dai->dai_runtime.bfs,
 					rtd->codec_dai->dai_runtime.bfs);
 				dbgc("asoc: mclk %d hwfmt %x\n", mclk, fmt);
@@ -378,26 +478,41 @@ static int soc_hw_match_params(struct snd_pcm_substream *substream,
 		dbg("asoc: codec fs %d mclk %d bfs div %d bclk %d\n",
 			rtd->codec_dai->dai_runtime.fs, mclk,
 			SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs),	codec_bclk);
-	} else {
-		codec_bclk = params_rate(params) *
-			SND_SOC_FSB_REAL(rtd->codec_dai->dai_runtime.bfs);
-		dbg("asoc: codec fs %d mclk %d bfs mult %d bclk %d\n",
+	} else if(rtd->codec_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RATE) {
+		codec_bclk = params_rate(params) * rtd->codec_dai->dai_runtime.bfs;
+		dbg("asoc: codec fs %d mclk %d bfs rate mult %llu bclk %d\n",
 			rtd->codec_dai->dai_runtime.fs, mclk,
-			SND_SOC_FSB_REAL(rtd->codec_dai->dai_runtime.bfs), codec_bclk);
-	}
+			rtd->codec_dai->dai_runtime.bfs, codec_bclk);
+	} else if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RCW) {
+		codec_bclk = params_rate(params) * params_channels(params) *
+			snd_pcm_format_physical_width(rtd->codec_dai->dai_runtime.pcmfmt) *
+			SND_SOC_FSBW_REAL(rtd->codec_dai->dai_runtime.bfs);
+		dbg("asoc: codec fs %d mclk %d bfs rcw mult %d bclk %d\n",
+			rtd->codec_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSBW_REAL(rtd->codec_dai->dai_runtime.bfs), codec_bclk);
+	} else
+		codec_bclk = 0;
+
 	if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_DIV) {
 		cpu_bclk = (rtd->cpu_dai->dai_runtime.fs * params_rate(params)) /
 			SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs);
 		dbg("asoc: cpu fs %d mclk %d bfs div %d bclk %d\n",
 			rtd->cpu_dai->dai_runtime.fs, mclk,
 			SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs), cpu_bclk);
-	} else {
-		cpu_bclk = params_rate(params) *
-			SND_SOC_FSB_REAL(rtd->cpu_dai->dai_runtime.bfs);
-		dbg("asoc: cpu fs %d mclk %d bfs mult %d bclk %d\n",
+	} else if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RATE) {
+		cpu_bclk = params_rate(params) * rtd->cpu_dai->dai_runtime.bfs;
+		dbg("asoc: cpu fs %d mclk %d bfs rate mult %llu bclk %d\n",
 			rtd->cpu_dai->dai_runtime.fs, mclk,
-			SND_SOC_FSB_REAL(rtd->cpu_dai->dai_runtime.bfs), cpu_bclk);
-	}
+			rtd->cpu_dai->dai_runtime.bfs, cpu_bclk);
+	} else if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_RCW) {
+		cpu_bclk = params_rate(params) * params_channels(params) *
+			snd_pcm_format_physical_width(rtd->cpu_dai->dai_runtime.pcmfmt) *
+			SND_SOC_FSBW_REAL(rtd->cpu_dai->dai_runtime.bfs);
+		dbg("asoc: cpu fs %d mclk %d bfs mult rcw %d bclk %d\n",
+			rtd->cpu_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSBW_REAL(rtd->cpu_dai->dai_runtime.bfs), cpu_bclk);
+	} else
+		cpu_bclk = 0;
 
 	/*
 	 * Check we have matching bitclocks. If we don't then it means the
@@ -405,7 +520,7 @@ static int soc_hw_match_params(struct snd_pcm_substream *substream,
 	 * machine sysclock function) is wrong compared with the supported DAI
 	 * modes for the codec or cpu DAI.
 	 */
-	if (cpu_bclk != codec_bclk){
+	if (cpu_bclk != codec_bclk && cpu_bclk){
 		printk(KERN_ERR
 			"asoc: codec and cpu bitclocks differ, audio may be wrong speed\n"
 			);
@@ -723,14 +838,18 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	mutex_lock(&pcm_mutex);
 	if (platform->pcm_ops->prepare) {
 		ret = platform->pcm_ops->prepare(substream);
-		if (ret < 0)
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: platform prepare error\n");
 			goto out;
+		}
 	}
 
 	if (rtd->codec_dai->ops.prepare) {
 		ret = rtd->codec_dai->ops.prepare(substream);
-		if (ret < 0)
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: codec DAI prepare error\n");
 			goto out;
+		}
 	}
 
 	if (rtd->cpu_dai->ops.prepare)

commit 12e74f7d430655f541b85018ea62bcd669094bd7
Author: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
Date:   Mon Oct 16 21:19:48 2006 +0200

    [ALSA] ASoC - Fix build warnings in soc-core.c
    
    This patch fixes some build warnings in soc-core.c
    Changes:-
     o Check the return value of soc_ac97_dev_register()
     o Check return value of calls to device_create_file()
    
    Signed-off-by: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 8d6ff047d7a0..2ce0c8251dc3 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1438,12 +1438,18 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 {
 	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_machine *machine = socdev->machine;
-	int ret = 0, i, ac97 = 0;
+	int ret = 0, i, ac97 = 0, err = 0;
 
 	mutex_lock(&codec->mutex);
 	for(i = 0; i < machine->num_links; i++) {
-		if (socdev->machine->dai_link[i].init)
-			socdev->machine->dai_link[i].init(codec);
+		if (socdev->machine->dai_link[i].init) {
+			err = socdev->machine->dai_link[i].init(codec);
+			if (err < 0) {
+				printk(KERN_ERR "asoc: failed to init %s\n",
+					socdev->machine->dai_link[i].stream_name);
+				continue;
+			}
+		}
 		if (socdev->machine->dai_link[i].cpu_dai->type == SND_SOC_DAI_AC97)
 			ac97 = 1;
 	}
@@ -1456,17 +1462,28 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 	if (ret < 0) {
 		printk(KERN_ERR "asoc: failed to register soundcard for codec %s\n",
 				codec->name);
-		mutex_unlock(&codec->mutex);
-		return ret;
+		goto out;
 	}
 
 #ifdef CONFIG_SND_SOC_AC97_BUS
-	if (ac97)
-		soc_ac97_dev_register(codec);
+	if (ac97) {
+		ret = soc_ac97_dev_register(codec);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: AC97 device register failed\n");
+			snd_card_free(codec->card);
+			goto out;
+		}
+	}
 #endif
 
-	snd_soc_dapm_sys_add(socdev->dev);
-	device_create_file(socdev->dev, &dev_attr_codec_reg);
+	err = snd_soc_dapm_sys_add(socdev->dev);
+	if (err < 0)
+		printk(KERN_WARNING "asoc: failed to add dapm sysfs entries\n");
+
+	err = device_create_file(socdev->dev, &dev_attr_codec_reg);
+	if (err < 0)
+		printk(KERN_WARNING "asoc: failed to add codec sysfs entries\n");
+out:
 	mutex_unlock(&codec->mutex);
 	return ret;
 }

commit b5c5fd24b9d34e4670cb339e546bfae7ad316354
Author: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
Date:   Fri Oct 13 19:13:41 2006 +0200

    [ALSA] ASoC debug output build breakage
    
    This patch fixes a build failure when ASoC debug is enabled.
    
    Signed-off-by: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index eba0a1012531..8d6ff047d7a0 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -575,10 +575,11 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	}
 
 	dbg("asoc: %s <-> %s info:\n", rtd->codec_dai->name, rtd->cpu_dai->name);
-	dbg("asoc: rate mask 0x%x \nasoc: min ch %d max ch %d\n"
-		"asoc: min rate %d max rate %d\n",
-		runtime->hw.rates, runtime->hw.channels_min,
-		runtime->hw.channels_max, runtime->hw.rate_min, runtime->hw.rate_max);
+	dbg("asoc: rate mask 0x%x\n", runtime->hw.rates);
+	dbg("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
+		runtime->hw.channels_max);
+	dbg("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
+		runtime->hw.rate_max);
 
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)

commit e117483e3e713c6411968afea825daa1133bc28d
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Oct 9 08:14:58 2006 +0200

    [ALSA] soc-core: fix multi-line string literal
    
    Properly quote a string that had an embedded newline.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e841ad46c759..eba0a1012531 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -575,8 +575,8 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	}
 
 	dbg("asoc: %s <-> %s info:\n", rtd->codec_dai->name, rtd->cpu_dai->name);
-	dbg("asoc: rate mask 0x%x \nasoc: min ch %d max ch %d\n
-		asoc: min rate %d max rate %d\n",
+	dbg("asoc: rate mask 0x%x \nasoc: min ch %d max ch %d\n"
+		"asoc: min rate %d max rate %d\n",
 		runtime->hw.rates, runtime->hw.channels_min,
 		runtime->hw.channels_max, runtime->hw.rate_min, runtime->hw.rate_max);
 

commit db2a416556af0313db028147e4a22fef6f214f2f
Author: Frank Mandarino <fmandarino@endrelia.com>
Date:   Fri Oct 6 18:31:09 2006 +0200

    [ALSA] ASoC: core code
    
    This patch is the core of ASoC functionality.
    The ASoC core is designed to provide the following features :-
    o  Codec independence. Allows reuse of codec drivers on other platforms
    and machines.
    o Platform driver code reuse. Reuse of platform specific audio DMA and
    DAI drivers on different machines.
    o Easy I2S/PCM digital audio interface configuration between codec and
    SoC. Each SoC interface and codec registers their audio interface
    capabilities with the core at initialisation. The capabilities are
    subsequently matched and configured at run time for best power and
    performance when the application hw params are known.
     o Machine specific controls/operations: Allow machines to add controls
    and operations to the audio subsystem. e.g. volume control for speaker
    amp.
    To achieve all this, ASoC splits an embedded audio system into 3
    components :-
    1. Codec driver: The codec driver is platform independent and contains
    audio controls, audio interface capabilities, codec dapm and codec IO
    functions.
    2. Platform driver: The platform driver contains the audio dma engine
    and audio interface drivers (e.g. I2S, AC97, PCM) for that platform.
    3. Machine driver: The machine driver handles any machine specific
    controls and audio events. i.e. turning on an amp at start of playback.
    
    Signed-off-by: Frank Mandarino <fmandarino@endrelia.com>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Liam Girdwood <liam.Girdwood@wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
new file mode 100644
index 000000000000..e841ad46c759
--- /dev/null
+++ b/sound/soc/soc-core.c
@@ -0,0 +1,1920 @@
+/*
+ * soc-core.c  --  ALSA SoC Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    12th Aug 2005   Initial version.
+ *    25th Oct 2005   Working Codec, Interface and Platform registration.
+ *
+ *  TODO:
+ *   o Add hw rules to enforce rates, etc.
+ *   o More testing with other codecs/machines.
+ *   o Add more codecs and platforms to ensure good API coverage.
+ *   o Support TDM on PCM and I2S
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+/* debug */
+#define SOC_DEBUG 0
+#if SOC_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+/* debug DAI capabilities matching */
+#define SOC_DEBUG_DAI 0
+#if SOC_DEBUG_DAI
+#define dbgc(format, arg...) printk(format, ## arg)
+#else
+#define dbgc(format, arg...)
+#endif
+
+static DEFINE_MUTEX(pcm_mutex);
+static DEFINE_MUTEX(io_mutex);
+static struct workqueue_struct *soc_workq;
+static struct work_struct soc_stream_work;
+static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
+
+/* supported sample rates */
+/* ATTENTION: these values depend on the definition in pcm.h! */
+static const unsigned int rates[] = {
+	5512, 8000, 11025, 16000, 22050, 32000, 44100,
+	48000, 64000, 88200, 96000, 176400, 192000
+};
+
+/*
+ * This is a timeout to do a DAPM powerdown after a stream is closed().
+ * It can be used to eliminate pops between different playback streams, e.g.
+ * between two audio tracks.
+ */
+static int pmdown_time = 5000;
+module_param(pmdown_time, int, 0);
+MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
+
+#ifdef CONFIG_SND_SOC_AC97_BUS
+/* unregister ac97 codec */
+static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
+{
+	if (codec->ac97->dev.bus)
+		device_unregister(&codec->ac97->dev);
+	return 0;
+}
+
+/* stop no dev release warning */
+static void soc_ac97_device_release(struct device *dev){}
+
+/* register ac97 codec to bus */
+static int soc_ac97_dev_register(struct snd_soc_codec *codec)
+{
+	int err;
+
+	codec->ac97->dev.bus = &ac97_bus_type;
+	codec->ac97->dev.parent = NULL;
+	codec->ac97->dev.release = soc_ac97_device_release;
+
+	snprintf(codec->ac97->dev.bus_id, BUS_ID_SIZE, "%d-%d:%s",
+		 codec->card->number, 0, codec->name);
+	err = device_register(&codec->ac97->dev);
+	if (err < 0) {
+		snd_printk(KERN_ERR "Can't register ac97 bus\n");
+		codec->ac97->dev.bus = NULL;
+		return err;
+	}
+	return 0;
+}
+#endif
+
+static inline const char* get_dai_name(int type)
+{
+	switch(type) {
+	case SND_SOC_DAI_AC97:
+		return "AC97";
+	case SND_SOC_DAI_I2S:
+		return "I2S";
+	case SND_SOC_DAI_PCM:
+		return "PCM";
+	}
+	return NULL;
+}
+
+/* get rate format from rate */
+static inline int soc_get_rate_format(int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rates); i++) {
+		if (rates[i] == rate)
+			return 1 << i;
+	}
+	return 0;
+}
+
+/* gets the audio system mclk/sysclk for the given parameters */
+static unsigned inline int soc_get_mclk(struct snd_soc_pcm_runtime *rtd,
+	struct snd_soc_clock_info *info)
+{
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_machine *machine = socdev->machine;
+	int i;
+
+	/* find the matching machine config and get it's mclk for the given
+	 * sample rate and hardware format */
+	for(i = 0; i < machine->num_links; i++) {
+		if (machine->dai_link[i].cpu_dai == rtd->cpu_dai &&
+			machine->dai_link[i].config_sysclk)
+			return machine->dai_link[i].config_sysclk(rtd, info);
+	}
+	return 0;
+}
+
+/* changes a bitclk multiplier mask to a divider mask */
+static u16 soc_bfs_mult_to_div(u16 bfs, int rate, unsigned int mclk,
+	unsigned int pcmfmt, unsigned int chn)
+{
+	int i, j;
+	u16 bfs_ = 0;
+	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
+
+	if (size <= 0)
+		return 0;
+
+	/* the minimum bit clock that has enough bandwidth */
+	min = size * rate * chn;
+	dbgc("mult --> div min bclk %d with mclk %d\n", min, mclk);
+
+	for (i = 0; i < 16; i++) {
+		if ((bfs >> i) & 0x1) {
+			j = rate * SND_SOC_FSB_REAL(1<<i);
+
+			if (j >= min) {
+				bfs_ |= SND_SOC_FSBD(mclk/j);
+				dbgc("mult --> div support mult %d\n",
+					SND_SOC_FSB_REAL(1<<i));
+			}
+		}
+	}
+
+	return bfs_;
+}
+
+/* changes a bitclk divider mask to a multiplier mask */
+static u16 soc_bfs_div_to_mult(u16 bfs, int rate, unsigned int mclk,
+	unsigned int pcmfmt, unsigned int chn)
+{
+	int i, j;
+	u16 bfs_ = 0;
+
+	int size = snd_pcm_format_physical_width(pcmfmt), min = 0;
+
+	if (size <= 0)
+		return 0;
+
+	/* the minimum bit clock that has enough bandwidth */
+	min = size * rate * chn;
+	dbgc("div to mult min bclk %d with mclk %d\n", min, mclk);
+
+	for (i = 0; i < 16; i++) {
+		if ((bfs >> i) & 0x1) {
+			j = mclk / (SND_SOC_FSBD_REAL(1<<i));
+			if (j >= min) {
+				bfs_ |= SND_SOC_FSB(j/rate);
+				dbgc("div --> mult support div %d\n",
+					SND_SOC_FSBD_REAL(1<<i));
+			}
+		}
+	}
+
+	return bfs_;
+}
+
+/* Matches codec DAI and SoC CPU DAI hardware parameters */
+static int soc_hw_match_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_mode *codec_dai_mode = NULL;
+	struct snd_soc_dai_mode *cpu_dai_mode = NULL;
+	struct snd_soc_clock_info clk_info;
+	unsigned int fs, mclk, codec_bfs, cpu_bfs, rate = params_rate(params),
+		chn, j, k, cpu_bclk, codec_bclk, pcmrate;
+	u16 fmt = 0;
+
+	dbg("asoc: match version %s\n", SND_SOC_VERSION);
+	clk_info.rate = rate;
+	pcmrate = soc_get_rate_format(rate);
+
+	/* try and find a match from the codec and cpu DAI capabilities */
+	for (j = 0; j < rtd->codec_dai->caps.num_modes; j++) {
+		for (k = 0; k < rtd->cpu_dai->caps.num_modes; k++) {
+			codec_dai_mode = &rtd->codec_dai->caps.mode[j];
+			cpu_dai_mode = &rtd->cpu_dai->caps.mode[k];
+
+			if (!(codec_dai_mode->pcmrate & cpu_dai_mode->pcmrate &
+					pcmrate)) {
+				dbgc("asoc: DAI[%d:%d] failed to match rate\n", j, k);
+				continue;
+			}
+
+			fmt = codec_dai_mode->fmt & cpu_dai_mode->fmt;
+			if (!(fmt & SND_SOC_DAIFMT_FORMAT_MASK)) {
+				dbgc("asoc: DAI[%d:%d] failed to match format\n", j, k);
+				continue;
+			}
+
+			if (!(fmt & SND_SOC_DAIFMT_CLOCK_MASK)) {
+				dbgc("asoc: DAI[%d:%d] failed to match clock masters\n",
+					 j, k);
+				continue;
+			}
+
+			if (!(fmt & SND_SOC_DAIFMT_INV_MASK)) {
+				dbgc("asoc: DAI[%d:%d] failed to match invert\n", j, k);
+				continue;
+			}
+
+			if (!(codec_dai_mode->pcmfmt & cpu_dai_mode->pcmfmt)) {
+				dbgc("asoc: DAI[%d:%d] failed to match pcm format\n", j, k);
+				continue;
+			}
+
+			if (!(codec_dai_mode->pcmdir & cpu_dai_mode->pcmdir)) {
+				dbgc("asoc: DAI[%d:%d] failed to match direction\n", j, k);
+				continue;
+			}
+
+			/* todo - still need to add tdm selection */
+			rtd->cpu_dai->dai_runtime.fmt =
+			rtd->codec_dai->dai_runtime.fmt =
+				1 << (ffs(fmt & SND_SOC_DAIFMT_FORMAT_MASK) -1) |
+				1 << (ffs(fmt & SND_SOC_DAIFMT_CLOCK_MASK) - 1) |
+				1 << (ffs(fmt & SND_SOC_DAIFMT_INV_MASK) - 1);
+			clk_info.bclk_master =
+				rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK;
+
+			/* make sure the ratio between rate and master
+			 * clock is acceptable*/
+			fs = (cpu_dai_mode->fs & codec_dai_mode->fs);
+			if (fs == 0) {
+				dbgc("asoc: DAI[%d:%d] failed to match FS\n", j, k);
+				continue;
+			}
+			clk_info.fs = rtd->cpu_dai->dai_runtime.fs =
+				rtd->codec_dai->dai_runtime.fs = fs;
+
+			/* calculate audio system clocking using slowest clocks possible*/
+			mclk = soc_get_mclk(rtd, &clk_info);
+			if (mclk == 0) {
+				dbgc("asoc: DAI[%d:%d] configuration not clockable\n", j, k);
+				dbgc("asoc: rate %d fs %d master %x\n", rate, fs,
+					clk_info.bclk_master);
+				continue;
+			}
+
+			/* calculate word size (per channel) and frame size */
+			rtd->codec_dai->dai_runtime.pcmfmt =
+				rtd->cpu_dai->dai_runtime.pcmfmt =
+				1 << params_format(params);
+
+			chn = params_channels(params);
+			/* i2s always has left and right */
+			if (params_channels(params) == 1 &&
+				rtd->cpu_dai->dai_runtime.fmt & (SND_SOC_DAIFMT_I2S |
+					SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_LEFT_J))
+				chn <<= 1;
+
+			/* Calculate bfs - the ratio between bitclock and the sample rate
+			 * We must take into consideration the dividers and multipliers
+			 * used in the codec and cpu DAI modes. We always choose the
+			 * lowest possible clocks to reduce power.
+			 */
+			if (codec_dai_mode->flags & cpu_dai_mode->flags &
+				SND_SOC_DAI_BFS_DIV) {
+				/* cpu & codec bfs dividers */
+				rtd->cpu_dai->dai_runtime.bfs =
+					rtd->codec_dai->dai_runtime.bfs =
+					1 << (fls(codec_dai_mode->bfs & cpu_dai_mode->bfs) - 1);
+			} else if (codec_dai_mode->flags & SND_SOC_DAI_BFS_DIV) {
+				/* normalise bfs codec divider & cpu mult */
+				codec_bfs = soc_bfs_div_to_mult(codec_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				rtd->cpu_dai->dai_runtime.bfs =
+					1 << (ffs(codec_bfs & cpu_dai_mode->bfs) - 1);
+				cpu_bfs = soc_bfs_mult_to_div(cpu_dai_mode->bfs, rate, mclk,
+						rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				rtd->codec_dai->dai_runtime.bfs =
+					1 << (fls(codec_dai_mode->bfs & cpu_bfs) - 1);
+			} else if (cpu_dai_mode->flags & SND_SOC_DAI_BFS_DIV) {
+				/* normalise bfs codec mult & cpu divider */
+				codec_bfs = soc_bfs_mult_to_div(codec_dai_mode->bfs, rate,
+					mclk, rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				rtd->cpu_dai->dai_runtime.bfs =
+					1 << (fls(codec_bfs & cpu_dai_mode->bfs) -1);
+				cpu_bfs = soc_bfs_div_to_mult(cpu_dai_mode->bfs, rate, mclk,
+						rtd->codec_dai->dai_runtime.pcmfmt, chn);
+				rtd->codec_dai->dai_runtime.bfs =
+					1 << (ffs(codec_dai_mode->bfs & cpu_bfs) -1);
+			} else {
+				/* codec & cpu bfs rate multipliers */
+				rtd->cpu_dai->dai_runtime.bfs =
+					rtd->codec_dai->dai_runtime.bfs =
+					1 << (ffs(codec_dai_mode->bfs & cpu_dai_mode->bfs) -1);
+			}
+
+			/* make sure the bit clock speed is acceptable */
+			if (!rtd->cpu_dai->dai_runtime.bfs ||
+				!rtd->codec_dai->dai_runtime.bfs) {
+				dbgc("asoc: DAI[%d:%d] failed to match BFS\n", j, k);
+				dbgc("asoc: cpu_dai %x codec %x\n",
+					rtd->cpu_dai->dai_runtime.bfs,
+					rtd->codec_dai->dai_runtime.bfs);
+				dbgc("asoc: mclk %d hwfmt %x\n", mclk, fmt);
+				continue;
+			}
+
+			goto found;
+		}
+	}
+	printk(KERN_ERR "asoc: no matching DAI found between codec and CPU\n");
+	return -EINVAL;
+
+found:
+	/* we have matching DAI's, so complete the runtime info */
+	rtd->codec_dai->dai_runtime.pcmrate =
+		rtd->cpu_dai->dai_runtime.pcmrate =
+		soc_get_rate_format(rate);
+
+	rtd->codec_dai->dai_runtime.priv = codec_dai_mode->priv;
+	rtd->cpu_dai->dai_runtime.priv = cpu_dai_mode->priv;
+	rtd->codec_dai->dai_runtime.flags = codec_dai_mode->flags;
+	rtd->cpu_dai->dai_runtime.flags = cpu_dai_mode->flags;
+
+	/* for debug atm */
+	dbg("asoc: DAI[%d:%d] Match OK\n", j, k);
+	if (rtd->codec_dai->dai_runtime.flags == SND_SOC_DAI_BFS_DIV) {
+		codec_bclk = (rtd->codec_dai->dai_runtime.fs * params_rate(params)) /
+			SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs);
+		dbg("asoc: codec fs %d mclk %d bfs div %d bclk %d\n",
+			rtd->codec_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSBD_REAL(rtd->codec_dai->dai_runtime.bfs),	codec_bclk);
+	} else {
+		codec_bclk = params_rate(params) *
+			SND_SOC_FSB_REAL(rtd->codec_dai->dai_runtime.bfs);
+		dbg("asoc: codec fs %d mclk %d bfs mult %d bclk %d\n",
+			rtd->codec_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSB_REAL(rtd->codec_dai->dai_runtime.bfs), codec_bclk);
+	}
+	if (rtd->cpu_dai->dai_runtime.flags == SND_SOC_DAI_BFS_DIV) {
+		cpu_bclk = (rtd->cpu_dai->dai_runtime.fs * params_rate(params)) /
+			SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs);
+		dbg("asoc: cpu fs %d mclk %d bfs div %d bclk %d\n",
+			rtd->cpu_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSBD_REAL(rtd->cpu_dai->dai_runtime.bfs), cpu_bclk);
+	} else {
+		cpu_bclk = params_rate(params) *
+			SND_SOC_FSB_REAL(rtd->cpu_dai->dai_runtime.bfs);
+		dbg("asoc: cpu fs %d mclk %d bfs mult %d bclk %d\n",
+			rtd->cpu_dai->dai_runtime.fs, mclk,
+			SND_SOC_FSB_REAL(rtd->cpu_dai->dai_runtime.bfs), cpu_bclk);
+	}
+
+	/*
+	 * Check we have matching bitclocks. If we don't then it means the
+	 * sysclock returned by either the codec or cpu DAI (selected by the
+	 * machine sysclock function) is wrong compared with the supported DAI
+	 * modes for the codec or cpu DAI.
+	 */
+	if (cpu_bclk != codec_bclk){
+		printk(KERN_ERR
+			"asoc: codec and cpu bitclocks differ, audio may be wrong speed\n"
+			);
+		printk(KERN_ERR "asoc: codec %d != cpu %d\n", codec_bclk, cpu_bclk);
+	}
+
+	switch(rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dbg("asoc: DAI codec BCLK master, LRC master\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		dbg("asoc: DAI codec BCLK slave, LRC master\n");
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		dbg("asoc: DAI codec BCLK master, LRC slave\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dbg("asoc: DAI codec BCLK slave, LRC slave\n");
+		break;
+	}
+	dbg("asoc: mode %x, invert %x\n",
+		rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_FORMAT_MASK,
+		rtd->cpu_dai->dai_runtime.fmt & SND_SOC_DAIFMT_INV_MASK);
+	dbg("asoc: audio rate %d chn %d fmt %x\n", params_rate(params),
+		params_channels(params), params_format(params));
+
+	return 0;
+}
+
+static inline u32 get_rates(struct snd_soc_dai_mode *modes, int nmodes)
+{
+	int i;
+	u32 rates = 0;
+
+	for(i = 0; i < nmodes; i++)
+		rates |= modes[i].pcmrate;
+
+	return rates;
+}
+
+static inline u64 get_formats(struct snd_soc_dai_mode *modes, int nmodes)
+{
+	int i;
+	u64 formats = 0;
+
+	for(i = 0; i < nmodes; i++)
+		formats |= modes[i].pcmfmt;
+
+	return formats;
+}
+
+/*
+ * Called by ALSA when a PCM substream is opened, the runtime->hw record is
+ * then initialized and any private data can be allocated. This also calls
+ * startup for the cpu DAI, platform, machine and codec DAI.
+ */
+static int soc_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->cpu_dai;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	/* startup the audio subsystem */
+	if (rtd->cpu_dai->ops.startup) {
+		ret = rtd->cpu_dai->ops.startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open interface %s\n",
+				rtd->cpu_dai->name);
+			goto out;
+		}
+	}
+
+	if (platform->pcm_ops->open) {
+		ret = platform->pcm_ops->open(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open platform %s\n", platform->name);
+			goto platform_err;
+		}
+	}
+
+	if (machine->ops && machine->ops->startup) {
+		ret = machine->ops->startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: %s startup failed\n", machine->name);
+			goto machine_err;
+		}
+	}
+
+	if (rtd->codec_dai->ops.startup) {
+		ret = rtd->codec_dai->ops.startup(substream);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't open codec %s\n",
+				rtd->codec_dai->name);
+			goto codec_dai_err;
+		}
+	}
+
+	/* create runtime params from DMA, codec and cpu DAI */
+	if (runtime->hw.rates)
+		runtime->hw.rates &=
+			get_rates(codec_dai->caps.mode, codec_dai->caps.num_modes) &
+			get_rates(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
+	else
+		runtime->hw.rates =
+			get_rates(codec_dai->caps.mode, codec_dai->caps.num_modes) &
+			get_rates(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
+	if (runtime->hw.formats)
+		runtime->hw.formats &=
+			get_formats(codec_dai->caps.mode, codec_dai->caps.num_modes) &
+			get_formats(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
+	else
+		runtime->hw.formats =
+			get_formats(codec_dai->caps.mode, codec_dai->caps.num_modes) &
+			get_formats(cpu_dai->caps.mode, cpu_dai->caps.num_modes);
+
+	/* Check that the codec and cpu DAI's are compatible */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		runtime->hw.rate_min =
+			max(rtd->codec_dai->playback.rate_min,
+				rtd->cpu_dai->playback.rate_min);
+		runtime->hw.rate_max =
+			min(rtd->codec_dai->playback.rate_max,
+				rtd->cpu_dai->playback.rate_max);
+		runtime->hw.channels_min =
+			max(rtd->codec_dai->playback.channels_min,
+				rtd->cpu_dai->playback.channels_min);
+		runtime->hw.channels_max =
+			min(rtd->codec_dai->playback.channels_max,
+				rtd->cpu_dai->playback.channels_max);
+	} else {
+		runtime->hw.rate_min =
+			max(rtd->codec_dai->capture.rate_min,
+				rtd->cpu_dai->capture.rate_min);
+		runtime->hw.rate_max =
+			min(rtd->codec_dai->capture.rate_max,
+				rtd->cpu_dai->capture.rate_max);
+		runtime->hw.channels_min =
+			max(rtd->codec_dai->capture.channels_min,
+				rtd->cpu_dai->capture.channels_min);
+		runtime->hw.channels_max =
+			min(rtd->codec_dai->capture.channels_max,
+				rtd->cpu_dai->capture.channels_max);
+	}
+
+	snd_pcm_limit_hw_rates(runtime);
+	if (!runtime->hw.rates) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching rates\n",
+			rtd->codec_dai->name, rtd->cpu_dai->name);
+		goto codec_dai_err;
+	}
+	if (!runtime->hw.formats) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching formats\n",
+			rtd->codec_dai->name, rtd->cpu_dai->name);
+		goto codec_dai_err;
+	}
+	if (!runtime->hw.channels_min || !runtime->hw.channels_max) {
+		printk(KERN_ERR "asoc: %s <-> %s No matching channels\n",
+			rtd->codec_dai->name, rtd->cpu_dai->name);
+		goto codec_dai_err;
+	}
+
+	dbg("asoc: %s <-> %s info:\n", rtd->codec_dai->name, rtd->cpu_dai->name);
+	dbg("asoc: rate mask 0x%x \nasoc: min ch %d max ch %d\n
+		asoc: min rate %d max rate %d\n",
+		runtime->hw.rates, runtime->hw.channels_min,
+		runtime->hw.channels_max, runtime->hw.rate_min, runtime->hw.rate_max);
+
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtd->cpu_dai->playback.active = rtd->codec_dai->playback.active = 1;
+	else
+		rtd->cpu_dai->capture.active = rtd->codec_dai->capture.active = 1;
+	rtd->cpu_dai->active = rtd->codec_dai->active = 1;
+	rtd->cpu_dai->runtime = runtime;
+	socdev->codec->active++;
+	mutex_unlock(&pcm_mutex);
+	return 0;
+
+codec_dai_err:
+	if (machine->ops && machine->ops->shutdown)
+		machine->ops->shutdown(substream);
+
+machine_err:
+	if (platform->pcm_ops->close)
+		platform->pcm_ops->close(substream);
+
+platform_err:
+	if (rtd->cpu_dai->ops.shutdown)
+		rtd->cpu_dai->ops.shutdown(substream);
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Power down the audio subsytem pmdown_time msecs after close is called.
+ * This is to ensure there are no pops or clicks in between any music tracks
+ * due to DAPM power cycling.
+ */
+static void close_delayed_work(void *data)
+{
+	struct snd_soc_device *socdev = data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *codec_dai;
+	int i;
+
+	mutex_lock(&pcm_mutex);
+	for(i = 0; i < codec->num_dai; i++) {
+		codec_dai = &codec->dai[i];
+
+		dbg("pop wq checking: %s status: %s waiting: %s\n",
+			codec_dai->playback.stream_name,
+			codec_dai->playback.active ? "active" : "inactive",
+			codec_dai->pop_wait ? "yes" : "no");
+
+		/* are we waiting on this codec DAI stream */
+		if (codec_dai->pop_wait == 1) {
+
+			codec_dai->pop_wait = 0;
+			snd_soc_dapm_stream_event(codec, codec_dai->playback.stream_name,
+				SND_SOC_DAPM_STREAM_STOP);
+
+			/* power down the codec power domain if no longer active */
+			if (codec->active == 0) {
+				dbg("pop wq D3 %s %s\n", codec->name,
+					codec_dai->playback.stream_name);
+		 		if (codec->dapm_event)
+					codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+			}
+		}
+	}
+	mutex_unlock(&pcm_mutex);
+}
+
+/*
+ * Called by ALSA when a PCM substream is closed. Private data can be
+ * freed here. The cpu DAI, codec DAI, machine and platform are also
+ * shutdown.
+ */
+static int soc_codec_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&pcm_mutex);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtd->cpu_dai->playback.active = rtd->codec_dai->playback.active = 0;
+	else
+		rtd->cpu_dai->capture.active = rtd->codec_dai->capture.active = 0;
+
+	if (rtd->codec_dai->playback.active == 0 &&
+		rtd->codec_dai->capture.active == 0) {
+		rtd->cpu_dai->active = rtd->codec_dai->active = 0;
+	}
+	codec->active--;
+
+	if (rtd->cpu_dai->ops.shutdown)
+		rtd->cpu_dai->ops.shutdown(substream);
+
+	if (rtd->codec_dai->ops.shutdown)
+		rtd->codec_dai->ops.shutdown(substream);
+
+	if (machine->ops && machine->ops->shutdown)
+		machine->ops->shutdown(substream);
+
+	if (platform->pcm_ops->close)
+		platform->pcm_ops->close(substream);
+	rtd->cpu_dai->runtime = NULL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* start delayed pop wq here for playback streams */
+		rtd->codec_dai->pop_wait = 1;
+		queue_delayed_work(soc_workq, &soc_stream_work,
+			msecs_to_jiffies(pmdown_time));
+	} else {
+		/* capture streams can be powered down now */
+		snd_soc_dapm_stream_event(codec, rtd->codec_dai->capture.stream_name,
+			SND_SOC_DAPM_STREAM_STOP);
+
+		if (codec->active == 0 && rtd->codec_dai->pop_wait == 0){
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D3hot);
+		}
+	}
+
+	mutex_unlock(&pcm_mutex);
+	return 0;
+}
+
+/*
+ * Called by ALSA when the PCM substream is prepared, can set format, sample
+ * rate, etc.  This function is non atomic and can be called multiple times,
+ * it can refer to the runtime info.
+ */
+static int soc_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+	if (platform->pcm_ops->prepare) {
+		ret = platform->pcm_ops->prepare(substream);
+		if (ret < 0)
+			goto out;
+	}
+
+	if (rtd->codec_dai->ops.prepare) {
+		ret = rtd->codec_dai->ops.prepare(substream);
+		if (ret < 0)
+			goto out;
+	}
+
+	if (rtd->cpu_dai->ops.prepare)
+		ret = rtd->cpu_dai->ops.prepare(substream);
+
+	/* we only want to start a DAPM playback stream if we are not waiting
+	 * on an existing one stopping */
+	if (rtd->codec_dai->pop_wait) {
+		/* we are waiting for the delayed work to start */
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+		else {
+			rtd->codec_dai->pop_wait = 0;
+			cancel_delayed_work(&soc_stream_work);
+			if (rtd->codec_dai->digital_mute)
+				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
+		}
+	} else {
+		/* no delayed work - do we need to power up codec */
+		if (codec->dapm_state != SNDRV_CTL_POWER_D0) {
+
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D1);
+
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->playback.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			else
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+
+			if (codec->dapm_event)
+				codec->dapm_event(codec, SNDRV_CTL_POWER_D0);
+			if (rtd->codec_dai->digital_mute)
+				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
+
+		} else {
+			/* codec already powered - power on widgets */
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->playback.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			else
+				snd_soc_dapm_stream_event(codec,
+					rtd->codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+			if (rtd->codec_dai->digital_mute)
+				rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 0);
+		}
+	}
+
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Called by ALSA when the hardware params are set by application. This
+ * function can also be called multiple times and can allocate buffers
+ * (using snd_pcm_lib_* ). It's non-atomic.
+ */
+static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0;
+
+	mutex_lock(&pcm_mutex);
+
+	/* we don't need to match any AC97 params */
+	if (rtd->cpu_dai->type != SND_SOC_DAI_AC97) {
+		ret = soc_hw_match_params(substream, params);
+		if (ret < 0)
+			goto out;
+	} else {
+		struct snd_soc_clock_info clk_info;
+		clk_info.rate = params_rate(params);
+		ret = soc_get_mclk(rtd, &clk_info);
+		if (ret < 0)
+			goto out;
+	}
+
+	if (rtd->codec_dai->ops.hw_params) {
+		ret = rtd->codec_dai->ops.hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
+				rtd->codec_dai->name);
+			goto out;
+		}
+	}
+
+	if (rtd->cpu_dai->ops.hw_params) {
+		ret = rtd->cpu_dai->ops.hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set interface %s hw params\n",
+				rtd->cpu_dai->name);
+			goto interface_err;
+		}
+	}
+
+	if (platform->pcm_ops->hw_params) {
+		ret = platform->pcm_ops->hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't set platform %s hw params\n",
+				platform->name);
+			goto platform_err;
+		}
+	}
+
+	if (machine->ops && machine->ops->hw_params) {
+		ret = machine->ops->hw_params(substream, params);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: machine hw_params failed\n");
+			goto machine_err;
+		}
+	}
+
+out:
+	mutex_unlock(&pcm_mutex);
+	return ret;
+
+machine_err:
+	if (platform->pcm_ops->hw_free)
+		platform->pcm_ops->hw_free(substream);
+
+platform_err:
+	if (rtd->cpu_dai->ops.hw_free)
+		rtd->cpu_dai->ops.hw_free(substream);
+
+interface_err:
+	if (rtd->codec_dai->ops.hw_free)
+		rtd->codec_dai->ops.hw_free(substream);
+
+	mutex_unlock(&pcm_mutex);
+	return ret;
+}
+
+/*
+ * Free's resources allocated by hw_params, can be called multiple times
+ */
+static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+
+	mutex_lock(&pcm_mutex);
+
+	/* apply codec digital mute */
+	if (!codec->active && rtd->codec_dai->digital_mute)
+		rtd->codec_dai->digital_mute(codec, rtd->codec_dai, 1);
+
+	/* free any machine hw params */
+	if (machine->ops && machine->ops->hw_free)
+		machine->ops->hw_free(substream);
+
+	/* free any DMA resources */
+	if (platform->pcm_ops->hw_free)
+		platform->pcm_ops->hw_free(substream);
+
+	/* now free hw params for the DAI's  */
+	if (rtd->codec_dai->ops.hw_free)
+		rtd->codec_dai->ops.hw_free(substream);
+
+	if (rtd->cpu_dai->ops.hw_free)
+		rtd->cpu_dai->ops.hw_free(substream);
+
+	mutex_unlock(&pcm_mutex);
+	return 0;
+}
+
+static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_platform *platform = socdev->platform;
+	int ret;
+
+	if (rtd->codec_dai->ops.trigger) {
+		ret = rtd->codec_dai->ops.trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (platform->pcm_ops->trigger) {
+		ret = platform->pcm_ops->trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (rtd->cpu_dai->ops.trigger) {
+		ret = rtd->cpu_dai->ops.trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+/* ASoC PCM operations */
+static struct snd_pcm_ops soc_pcm_ops = {
+	.open		= soc_pcm_open,
+	.close		= soc_codec_close,
+	.hw_params	= soc_pcm_hw_params,
+	.hw_free	= soc_pcm_hw_free,
+	.prepare	= soc_pcm_prepare,
+	.trigger	= soc_pcm_trigger,
+};
+
+#ifdef CONFIG_PM
+/* powers down audio subsystem for suspend */
+static int soc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+ 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+ 	struct snd_soc_machine *machine = socdev->machine;
+ 	struct snd_soc_platform *platform = socdev->platform;
+ 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+
+	/* mute any active DAC's */
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->digital_mute && dai->playback.active)
+			dai->digital_mute(codec, dai, 1);
+	}
+
+	if (machine->suspend_pre)
+		machine->suspend_pre(pdev, state);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai  *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type != SND_SOC_DAI_AC97)
+			cpu_dai->suspend(pdev, cpu_dai);
+		if (platform->suspend)
+			platform->suspend(pdev, cpu_dai);
+	}
+
+	/* close any waiting streams and save state */
+	flush_workqueue(soc_workq);
+	codec->suspend_dapm_state = codec->dapm_state;
+
+	for(i = 0; i < codec->num_dai; i++) {
+		char *stream = codec->dai[i].playback.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_SUSPEND);
+		stream = codec->dai[i].capture.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_SUSPEND);
+	}
+
+	if (codec_dev->suspend)
+		codec_dev->suspend(pdev, state);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type == SND_SOC_DAI_AC97)
+			cpu_dai->suspend(pdev, cpu_dai);
+	}
+
+	if (machine->suspend_post)
+		machine->suspend_post(pdev, state);
+
+	return 0;
+}
+
+/* powers up audio subsystem after a suspend */
+static int soc_resume(struct platform_device *pdev)
+{
+ 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+ 	struct snd_soc_machine *machine = socdev->machine;
+ 	struct snd_soc_platform *platform = socdev->platform;
+ 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+
+	if (machine->resume_pre)
+		machine->resume_pre(pdev);
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type == SND_SOC_DAI_AC97)
+			cpu_dai->resume(pdev, cpu_dai);
+	}
+
+	if (codec_dev->resume)
+		codec_dev->resume(pdev);
+
+	for(i = 0; i < codec->num_dai; i++) {
+		char* stream = codec->dai[i].playback.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_RESUME);
+		stream = codec->dai[i].capture.stream_name;
+		if (stream != NULL)
+			snd_soc_dapm_stream_event(codec, stream,
+				SND_SOC_DAPM_STREAM_RESUME);
+	}
+
+	/* unmute any active DAC's */
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_codec_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->digital_mute && dai->playback.active)
+			dai->digital_mute(codec, dai, 0);
+	}
+
+	for(i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type != SND_SOC_DAI_AC97)
+			cpu_dai->resume(pdev, cpu_dai);
+		if (platform->resume)
+			platform->resume(pdev, cpu_dai);
+	}
+
+	if (machine->resume_post)
+		machine->resume_post(pdev);
+
+	return 0;
+}
+
+#else
+#define soc_suspend	NULL
+#define soc_resume	NULL
+#endif
+
+/* probes a new socdev */
+static int soc_probe(struct platform_device *pdev)
+{
+	int ret = 0, i;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+
+	if (machine->probe) {
+		ret = machine->probe(pdev);
+		if(ret < 0)
+			return ret;
+	}
+
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->probe) {
+			ret = cpu_dai->probe(pdev);
+			if(ret < 0)
+				goto cpu_dai_err;
+		}
+	}
+
+	if (codec_dev->probe) {
+		ret = codec_dev->probe(pdev);
+		if(ret < 0)
+			goto cpu_dai_err;
+	}
+
+	if (platform->probe) {
+		ret = platform->probe(pdev);
+		if(ret < 0)
+			goto platform_err;
+	}
+
+	/* DAPM stream work */
+	soc_workq = create_workqueue("kdapm");
+	if (soc_workq == NULL)
+		goto work_err;
+	INIT_WORK(&soc_stream_work, close_delayed_work, socdev);
+	return 0;
+
+work_err:
+	if (platform->remove)
+		platform->remove(pdev);
+
+platform_err:
+	if (codec_dev->remove)
+		codec_dev->remove(pdev);
+
+cpu_dai_err:
+	for (i--; i > 0; i--) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->remove)
+			cpu_dai->remove(pdev);
+	}
+
+	if (machine->remove)
+		machine->remove(pdev);
+
+	return ret;
+}
+
+/* removes a socdev */
+static int soc_remove(struct platform_device *pdev)
+{
+	int i;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_machine *machine = socdev->machine;
+	struct snd_soc_platform *platform = socdev->platform;
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+
+	if (soc_workq)
+		destroy_workqueue(soc_workq);
+
+	if (platform->remove)
+		platform->remove(pdev);
+
+	if (codec_dev->remove)
+		codec_dev->remove(pdev);
+
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_cpu_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->remove)
+			cpu_dai->remove(pdev);
+	}
+
+	if (machine->remove)
+		machine->remove(pdev);
+
+	return 0;
+}
+
+/* ASoC platform driver */
+static struct platform_driver soc_driver = {
+	.driver		= {
+		.name		= "soc-audio",
+	},
+	.probe		= soc_probe,
+	.remove		= soc_remove,
+	.suspend	= soc_suspend,
+	.resume		= soc_resume,
+};
+
+/* create a new pcm */
+static int soc_new_pcm(struct snd_soc_device *socdev,
+	struct snd_soc_dai_link *dai_link, int num)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_codec_dai *codec_dai = dai_link->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = dai_link->cpu_dai;
+	struct snd_soc_pcm_runtime *rtd;
+	struct snd_pcm *pcm;
+	char new_name[64];
+	int ret = 0, playback = 0, capture = 0;
+
+	rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime), GFP_KERNEL);
+	if (rtd == NULL)
+		return -ENOMEM;
+	rtd->cpu_dai = cpu_dai;
+	rtd->codec_dai = codec_dai;
+	rtd->socdev = socdev;
+
+	/* check client and interface hw capabilities */
+	sprintf(new_name, "%s %s-%s-%d",dai_link->stream_name, codec_dai->name,
+		get_dai_name(cpu_dai->type), num);
+
+	if (codec_dai->playback.channels_min)
+		playback = 1;
+	if (codec_dai->capture.channels_min)
+		capture = 1;
+
+	ret = snd_pcm_new(codec->card, new_name, codec->pcm_devs++, playback,
+		capture, &pcm);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: can't create pcm for codec %s\n", codec->name);
+		kfree(rtd);
+		return ret;
+	}
+
+	pcm->private_data = rtd;
+	soc_pcm_ops.mmap = socdev->platform->pcm_ops->mmap;
+	soc_pcm_ops.pointer = socdev->platform->pcm_ops->pointer;
+	soc_pcm_ops.ioctl = socdev->platform->pcm_ops->ioctl;
+	soc_pcm_ops.copy = socdev->platform->pcm_ops->copy;
+	soc_pcm_ops.silence = socdev->platform->pcm_ops->silence;
+	soc_pcm_ops.ack = socdev->platform->pcm_ops->ack;
+	soc_pcm_ops.page = socdev->platform->pcm_ops->page;
+
+	if (playback)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &soc_pcm_ops);
+
+	if (capture)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &soc_pcm_ops);
+
+	ret = socdev->platform->pcm_new(codec->card, codec_dai, pcm);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: platform pcm constructor failed\n");
+		kfree(rtd);
+		return ret;
+	}
+
+	pcm->private_free = socdev->platform->pcm_free;
+	printk(KERN_INFO "asoc: %s <-> %s mapping ok\n", codec_dai->name,
+		cpu_dai->name);
+	return ret;
+}
+
+/* codec register dump */
+static ssize_t codec_reg_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec = devdata->codec;
+	int i, step = 1, count = 0;
+
+	if (!codec->reg_cache_size)
+		return 0;
+
+	if (codec->reg_cache_step)
+		step = codec->reg_cache_step;
+
+	count += sprintf(buf, "%s registers\n", codec->name);
+	for(i = 0; i < codec->reg_cache_size; i += step)
+		count += sprintf(buf + count, "%2x: %4x\n", i, codec->read(codec, i));
+
+	return count;
+}
+static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
+
+/**
+ * snd_soc_new_ac97_codec - initailise AC97 device
+ * @codec: audio codec
+ * @ops: AC97 bus operations
+ * @num: AC97 codec number
+ *
+ * Initialises AC97 codec resources for use by ad-hoc devices only.
+ */
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num)
+{
+	mutex_lock(&codec->mutex);
+
+	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
+	if (codec->ac97 == NULL) {
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
+	if (codec->ac97->bus == NULL) {
+		kfree(codec->ac97);
+		codec->ac97 = NULL;
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
+
+	codec->ac97->bus->ops = ops;
+	codec->ac97->num = num;
+	mutex_unlock(&codec->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
+
+/**
+ * snd_soc_free_ac97_codec - free AC97 codec device
+ * @codec: audio codec
+ *
+ * Frees AC97 codec device resources.
+ */
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
+{
+	mutex_lock(&codec->mutex);
+	kfree(codec->ac97->bus);
+	kfree(codec->ac97);
+	codec->ac97 = NULL;
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
+
+/**
+ * snd_soc_update_bits - update codec register bits
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned short old, new;
+
+	mutex_lock(&io_mutex);
+	old = snd_soc_read(codec, reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	if (change)
+		snd_soc_write(codec, reg, new);
+
+	mutex_unlock(&io_mutex);
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_update_bits);
+
+/**
+ * snd_soc_test_bits - test register for change
+ * @codec: audio codec
+ * @reg: codec register
+ * @mask: register mask
+ * @value: new value
+ *
+ * Tests a register with a new value and checks if the new value is
+ * different from the old value.
+ *
+ * Returns 1 for change else 0.
+ */
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value)
+{
+	int change;
+	unsigned short old, new;
+
+	mutex_lock(&io_mutex);
+	old = snd_soc_read(codec, reg);
+	new = (old & ~mask) | value;
+	change = old != new;
+	mutex_unlock(&io_mutex);
+
+	return change;
+}
+EXPORT_SYMBOL_GPL(snd_soc_test_bits);
+
+/**
+ * snd_soc_get_rate - get int sample rate
+ * @hwpcmrate: the hardware pcm rate
+ *
+ * Returns the audio rate integaer value, else 0.
+ */
+int snd_soc_get_rate(int hwpcmrate)
+{
+	int rate = ffs(hwpcmrate) - 1;
+
+	if (rate > ARRAY_SIZE(rates))
+		return 0;
+	return rates[rate];
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_rate);
+
+/**
+ * snd_soc_new_pcms - create new sound card and pcms
+ * @socdev: the SoC audio device
+ *
+ * Create a new sound card based upon the codec and interface pcms.
+ *
+ * Returns 0 for success, else error.
+ */
+int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char * xid)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0, i;
+
+	mutex_lock(&codec->mutex);
+
+	/* register a sound card */
+	codec->card = snd_card_new(idx, xid, codec->owner, 0);
+	if (!codec->card) {
+		printk(KERN_ERR "asoc: can't create sound card for codec %s\n",
+			codec->name);
+		mutex_unlock(&codec->mutex);
+		return -ENODEV;
+	}
+
+	codec->card->dev = socdev->dev;
+	codec->card->private_data = codec;
+	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));
+
+	/* create the pcms */
+	for(i = 0; i < machine->num_links; i++) {
+		ret = soc_new_pcm(socdev, &machine->dai_link[i], i);
+		if (ret < 0) {
+			printk(KERN_ERR "asoc: can't create pcm %s\n",
+				machine->dai_link[i].stream_name);
+			mutex_unlock(&codec->mutex);
+			return ret;
+		}
+	}
+
+	mutex_unlock(&codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
+
+/**
+ * snd_soc_register_card - register sound card
+ * @socdev: the SoC audio device
+ *
+ * Register a SoC sound card. Also registers an AC97 device if the
+ * codec is AC97 for ad hoc devices.
+ *
+ * Returns 0 for success, else error.
+ */
+int snd_soc_register_card(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct snd_soc_machine *machine = socdev->machine;
+	int ret = 0, i, ac97 = 0;
+
+	mutex_lock(&codec->mutex);
+	for(i = 0; i < machine->num_links; i++) {
+		if (socdev->machine->dai_link[i].init)
+			socdev->machine->dai_link[i].init(codec);
+		if (socdev->machine->dai_link[i].cpu_dai->type == SND_SOC_DAI_AC97)
+			ac97 = 1;
+	}
+	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
+		 "%s", machine->name);
+	snprintf(codec->card->longname, sizeof(codec->card->longname),
+		 "%s (%s)", machine->name, codec->name);
+
+	ret = snd_card_register(codec->card);
+	if (ret < 0) {
+		printk(KERN_ERR "asoc: failed to register soundcard for codec %s\n",
+				codec->name);
+		mutex_unlock(&codec->mutex);
+		return ret;
+	}
+
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	if (ac97)
+		soc_ac97_dev_register(codec);
+#endif
+
+	snd_soc_dapm_sys_add(socdev->dev);
+	device_create_file(socdev->dev, &dev_attr_codec_reg);
+	mutex_unlock(&codec->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_register_card);
+
+/**
+ * snd_soc_free_pcms - free sound card and pcms
+ * @socdev: the SoC audio device
+ *
+ * Frees sound card and pcms associated with the socdev.
+ * Also unregister the codec if it is an AC97 device.
+ */
+void snd_soc_free_pcms(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+
+	mutex_lock(&codec->mutex);
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	if (codec->ac97)
+		soc_ac97_dev_unregister(codec);
+#endif
+
+	if (codec->card)
+		snd_card_free(codec->card);
+	device_remove_file(socdev->dev, &dev_attr_codec_reg);
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_pcms);
+
+/**
+ * snd_soc_set_runtime_hwparams - set the runtime hardware parameters
+ * @substream: the pcm substream
+ * @hw: the hardware parameters
+ *
+ * Sets the substream runtime hardware parameters.
+ */
+int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,
+	const struct snd_pcm_hardware *hw)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	runtime->hw.info = hw->info;
+	runtime->hw.formats = hw->formats;
+	runtime->hw.period_bytes_min = hw->period_bytes_min;
+	runtime->hw.period_bytes_max = hw->period_bytes_max;
+	runtime->hw.periods_min = hw->periods_min;
+	runtime->hw.periods_max = hw->periods_max;
+	runtime->hw.buffer_bytes_max = hw->buffer_bytes_max;
+	runtime->hw.fifo_size = hw->fifo_size;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);
+
+/**
+ * snd_soc_cnew - create new control
+ * @_template: control template
+ * @data: control private data
+ * @lnng_name: control long name
+ *
+ * Create a new mixer control from a template control.
+ *
+ * Returns 0 for success, else error.
+ */
+struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
+	void *data, char *long_name)
+{
+	struct snd_kcontrol_new template;
+
+	memcpy(&template, _template, sizeof(template));
+	if (long_name)
+		template.name = long_name;
+	template.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
+	template.index = 0;
+
+	return snd_ctl_new1(&template, data);
+}
+EXPORT_SYMBOL_GPL(snd_soc_cnew);
+
+/**
+ * snd_soc_info_enum_double - enumerated double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double enumerated
+ * mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
+
+/**
+ * snd_soc_get_enum_double - enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	val = snd_soc_read(codec, e->reg);
+	ucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			(val >> e->shift_r) & (bitmask - 1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
+
+/**
+ * snd_soc_put_enum_double - enumerated double mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned short val;
+	unsigned short mask, bitmask;
+
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
+		;
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
+		return -EINVAL;
+	val = ucontrol->value.enumerated.item[0] << e->shift_l;
+	mask = (bitmask - 1) << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
+			return -EINVAL;
+		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		mask |= (bitmask - 1) << e->shift_r;
+	}
+
+	return snd_soc_update_bits(codec, e->reg, mask, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
+
+/**
+ * snd_soc_info_enum_ext - external enumerated single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about an external enumerated
+ * single mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = e->mask;
+
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_ext);
+
+/**
+ * snd_soc_info_volsw_ext - external single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single external mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = kcontrol->private_value;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
+
+/**
+ * snd_soc_info_bool_ext - external single boolean mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single boolean external mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_bool_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_bool_ext);
+
+/**
+ * snd_soc_info_volsw - single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = shift == rshift ? 1 : 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
+
+/**
+ * snd_soc_get_volsw - single mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(codec, reg) >> shift) & mask;
+	if (shift != rshift)
+		ucontrol->value.integer.value[1] =
+			(snd_soc_read(codec, reg) >> rshift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		if (shift != rshift)
+			ucontrol->value.integer.value[1] =
+				mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
+
+/**
+ * snd_soc_put_volsw - single mixer put callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+	int err;
+	unsigned short val, val2, val_mask;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = mask - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (shift != rshift) {
+		val2 = (ucontrol->value.integer.value[1] & mask);
+		if (invert)
+			val2 = mask - val2;
+		val_mask |= mask << rshift;
+		val |= val2 << rshift;
+	}
+	err = snd_soc_update_bits(codec, reg, val_mask, val);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
+
+/**
+ * snd_soc_info_volsw_2r - double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double mixer control that
+ * spans 2 codec registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+
+	uinfo->type =
+		mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
+
+/**
+ * snd_soc_get_volsw_2r - double mixer get callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to get the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
+
+	ucontrol->value.integer.value[0] =
+		(snd_soc_read(codec, reg) >> shift) & mask;
+	ucontrol->value.integer.value[1] =
+		(snd_soc_read(codec, reg2) >> shift) & mask;
+	if (invert) {
+		ucontrol->value.integer.value[0] =
+			mask - ucontrol->value.integer.value[0];
+		ucontrol->value.integer.value[1] =
+			mask - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r);
+
+/**
+ * snd_soc_put_volsw_2r - double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int mask = (kcontrol->private_value >> 12) & 0xff;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
+	int err;
+	unsigned short val, val2, val_mask;
+
+	val_mask = mask << shift;
+	val = (ucontrol->value.integer.value[0] & mask);
+	val2 = (ucontrol->value.integer.value[1] & mask);
+
+	if (invert) {
+		val = mask - val;
+		val2 = mask - val2;
+	}
+
+	val = val << shift;
+	val2 = val2 << shift;
+
+	if ((err = snd_soc_update_bits(codec, reg, val_mask, val)) < 0)
+		return err;
+
+	err = snd_soc_update_bits(codec, reg2, val_mask, val2);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);
+
+static int __devinit snd_soc_init(void)
+{
+	printk(KERN_INFO "ASoC version %s\n", SND_SOC_VERSION);
+	return platform_driver_register(&soc_driver);
+}
+
+static void snd_soc_exit(void)
+{
+ 	platform_driver_unregister(&soc_driver);
+}
+
+module_init(snd_soc_init);
+module_exit(snd_soc_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("ALSA SoC Core");
+MODULE_LICENSE("GPL");
