commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c
index 9fa5c34a9572..12288567b0cd 100644
--- a/sound/firewire/fireworks/fireworks_proc.c
+++ b/sound/firewire/fireworks/fireworks_proc.c
@@ -1,10 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * fireworks_proc.c - a part of driver for Fireworks based devices
  *
  * Copyright (c) 2009-2010 Clemens Ladisch
  * Copyright (c) 2013-2014 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "./fireworks.h"

commit 0c298bdc38a00b8bbbd4df21c85c57d8a9dab625
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 5 12:34:12 2019 +0100

    ALSA: firewire: Remove superfluous snd_info_register() calls
    
    The calls of snd_info_register() are superfluous and should be avoided
    at the procfs creation time.  They are called at the end of the whole
    initialization via snd_card_register().  This patch drops such
    superfluous calls.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Tested-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c
index 779ecec5af62..9fa5c34a9572 100644
--- a/sound/firewire/fireworks/fireworks_proc.c
+++ b/sound/firewire/fireworks/fireworks_proc.c
@@ -199,12 +199,8 @@ add_node(struct snd_efw *efw, struct snd_info_entry *root, const char *name,
 	struct snd_info_entry *entry;
 
 	entry = snd_info_create_card_entry(efw->card, name, root);
-	if (entry == NULL)
-		return;
-
-	snd_info_set_text_ops(entry, efw, op);
-	if (snd_info_register(entry) < 0)
-		snd_info_free_entry(entry);
+	if (entry)
+		snd_info_set_text_ops(entry, efw, op);
 }
 
 void snd_efw_proc_init(struct snd_efw *efw)
@@ -220,10 +216,6 @@ void snd_efw_proc_init(struct snd_efw *efw)
 	if (root == NULL)
 		return;
 	root->mode = S_IFDIR | 0555;
-	if (snd_info_register(root) < 0) {
-		snd_info_free_entry(root);
-		return;
-	}
 
 	add_node(efw, root, "clock", proc_read_clock);
 	add_node(efw, root, "firmware", proc_read_hwinfo);

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c
index 9c21f31b8b21..779ecec5af62 100644
--- a/sound/firewire/fireworks/fireworks_proc.c
+++ b/sound/firewire/fireworks/fireworks_proc.c
@@ -219,7 +219,7 @@ void snd_efw_proc_init(struct snd_efw *efw)
 					  efw->card->proc_root);
 	if (root == NULL)
 		return;
-	root->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	root->mode = S_IFDIR | 0555;
 	if (snd_info_register(root) < 0) {
 		snd_info_free_entry(root);
 		return;

commit 782fbec745d84fa06708e703a92a431c4344daf0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Aug 22 22:58:15 2017 +0900

    ALSA: firewire: add const qualifier to identifiers for read-only symbols
    
    Drivers in ALSA firewire stack still includes some symbols which can be
    moved to a section for read-only symbols.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c
index beb0a0ffee57..9c21f31b8b21 100644
--- a/sound/firewire/fireworks/fireworks_proc.c
+++ b/sound/firewire/fireworks/fireworks_proc.c
@@ -12,7 +12,7 @@
 static inline const char*
 get_phys_name(struct snd_efw_phys_grp *grp, bool input)
 {
-	const char *const ch_type[] = {
+	static const char *const ch_type[] = {
 		"Analog", "S/PDIF", "ADAT", "S/PDIF or ADAT", "Mirroring",
 		"Headphones", "I2S", "Guitar", "Pirzo Guitar", "Guitar String",
 	};

commit 6b1ca4bcadf9ef077cc5f03c6822ba276ed14902
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Aug 31 22:58:42 2016 +0900

    ALSA: fireworks: accessing to user space outside spinlock
    
    In hwdep interface of fireworks driver, accessing to user space is in a
    critical section with disabled local interrupt. Depending on architecture,
    accessing to user space can cause page fault exception. Then local
    processor stores machine status and handles the synchronous event. A
    handler corresponding to the event can call task scheduler to wait for
    preparing pages. In a case of usage of single core processor, the state to
    disable local interrupt is worse because it don't handle usual interrupts
    from hardware.
    
    This commit fixes this bug, performing the accessing outside spinlock. This
    commit also gives up counting the number of queued response messages to
    simplify ring-buffer management.
    
    Reported-by: Vaishali Thakkar <vaishali.thakkar@oracle.com>
    Cc: stable@vger.kernel.org
    Fixes: 555e8a8f7f14('ALSA: fireworks: Add command/response functionality into hwdep interface')
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c
index 0639dcb13f7d..beb0a0ffee57 100644
--- a/sound/firewire/fireworks/fireworks_proc.c
+++ b/sound/firewire/fireworks/fireworks_proc.c
@@ -188,8 +188,8 @@ proc_read_queues_state(struct snd_info_entry *entry,
 	else
 		consumed = (unsigned int)(efw->push_ptr - efw->pull_ptr);
 
-	snd_iprintf(buffer, "%d %d/%d\n",
-		    efw->resp_queues, consumed, snd_efw_resp_buf_size);
+	snd_iprintf(buffer, "%d/%d\n",
+		    consumed, snd_efw_resp_buf_size);
 }
 
 static void

commit 30225ed5ca9e8f713fe8e92859f698c5e82a429c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Aug 5 11:17:10 2014 +0900

    ALSA: fireworks: fix specifiers in format strings for propper output
    
    Use %d for loop counter and %X for device capabilities. This is a
    supplemental patch for Hans Wennborg's patch.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c
index 02bf394fb1b3..0639dcb13f7d 100644
--- a/sound/firewire/fireworks/fireworks_proc.c
+++ b/sound/firewire/fireworks/fireworks_proc.c
@@ -64,7 +64,7 @@ proc_read_hwinfo(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 		    hwinfo->phys_in_grp_count);
 	for (i = 0; i < hwinfo->phys_in_grp_count; i++) {
 		snd_iprintf(buffer,
-			    "phys in grp[0x%d]: type 0x%d, count 0x%x\n",
+			    "phys in grp[%d]: type 0x%X, count 0x%X\n",
 			    i, hwinfo->phys_out_grps[i].type,
 			    hwinfo->phys_out_grps[i].count);
 	}
@@ -73,7 +73,7 @@ proc_read_hwinfo(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 		    hwinfo->phys_out_grp_count);
 	for (i = 0; i < hwinfo->phys_out_grp_count; i++) {
 		snd_iprintf(buffer,
-			    "phys out grps[0x%d]: type 0x%d, count 0x%x\n",
+			    "phys out grps[%d]: type 0x%X, count 0x%X\n",
 			    i, hwinfo->phys_out_grps[i].type,
 			    hwinfo->phys_out_grps[i].count);
 	}

commit 04b9906d8c03307a15f2333a6a975fec1f67e891
Author: Hans Wennborg <hans@hanshq.net>
Date:   Sun Aug 3 17:21:16 2014 -0700

    ALSA: fireworks: fix %d confusingly prefixed with 0x in format strings
    
    Signed-off-by: Hans Wennborg <hans@hanshq.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c
index f29d4aaf56a1..02bf394fb1b3 100644
--- a/sound/firewire/fireworks/fireworks_proc.c
+++ b/sound/firewire/fireworks/fireworks_proc.c
@@ -64,7 +64,7 @@ proc_read_hwinfo(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 		    hwinfo->phys_in_grp_count);
 	for (i = 0; i < hwinfo->phys_in_grp_count; i++) {
 		snd_iprintf(buffer,
-			    "phys in grp[0x%d]: type 0x%d, count 0x%d\n",
+			    "phys in grp[0x%d]: type 0x%d, count 0x%x\n",
 			    i, hwinfo->phys_out_grps[i].type,
 			    hwinfo->phys_out_grps[i].count);
 	}
@@ -73,7 +73,7 @@ proc_read_hwinfo(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 		    hwinfo->phys_out_grp_count);
 	for (i = 0; i < hwinfo->phys_out_grp_count; i++) {
 		snd_iprintf(buffer,
-			    "phys out grps[0x%d]: type 0x%d, count 0x%d\n",
+			    "phys out grps[0x%d]: type 0x%d, count 0x%x\n",
 			    i, hwinfo->phys_out_grps[i].type,
 			    hwinfo->phys_out_grps[i].count);
 	}

commit 555e8a8f7f149544eb7d4aa3a6420bc4c3055638
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:13 2014 +0900

    ALSA: fireworks: Add command/response functionality into hwdep interface
    
    This commit adds two functionality for hwdep interface, adds two parameters for
    this driver, add a node for proc interface.
    
    To receive responses from devices, this driver already allocate own callback
    into initial memory space in host controller. This means no one can allocate
    its own callback to the address. So this driver must give a way for user
    applications to receive responses.
    
    This commit adds a functionality to receive responses via hwdep interface. The
    application can receive responses to read from this interface. To achieve this,
    this commit adds a buffer to queue responses. The default size of this buffer is
    1024 bytes. This size can be changed to give preferrable size to
    'resp_buf_size' parameter for this driver. The application should notice rest
    of space in this buffer because this driver don't push responses when this
    buffer has no space.
    
    Additionaly, this commit adds a functionality to transmit commands via hwdep
    interface. The application can transmit commands to write into this interface.
    I note that the application can transmit one command at once, but can receive
    as many responses as possible untill the user-buffer is full.
    
    When using these interfaces, the application must keep maximum number of
    sequence number in command within the number in firewire.h because this driver
    uses this number to distinguish the response is against the command by the
    application or this driver.
    
    Usually responses against commands which the application transmits are pushed
    into this buffer. But to enable 'resp_buf_debug' parameter for this driver, all
    responses are pushed into the buffer. When using this mode, I reccomend to
    expand the size of buffer.
    
    Finally this commit adds a new node into proc interface to output status of the
    buffer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c
index 631c91f64db4..f29d4aaf56a1 100644
--- a/sound/firewire/fireworks/fireworks_proc.c
+++ b/sound/firewire/fireworks/fireworks_proc.c
@@ -175,6 +175,23 @@ proc_read_phys_meters(struct snd_info_entry *entry,
 	kfree(meters);
 }
 
+static void
+proc_read_queues_state(struct snd_info_entry *entry,
+		       struct snd_info_buffer *buffer)
+{
+	struct snd_efw *efw = entry->private_data;
+	unsigned int consumed;
+
+	if (efw->pull_ptr > efw->push_ptr)
+		consumed = snd_efw_resp_buf_size -
+			   (unsigned int)(efw->pull_ptr - efw->push_ptr);
+	else
+		consumed = (unsigned int)(efw->push_ptr - efw->pull_ptr);
+
+	snd_iprintf(buffer, "%d %d/%d\n",
+		    efw->resp_queues, consumed, snd_efw_resp_buf_size);
+}
+
 static void
 add_node(struct snd_efw *efw, struct snd_info_entry *root, const char *name,
 	 void (*op)(struct snd_info_entry *e, struct snd_info_buffer *b))
@@ -211,4 +228,5 @@ void snd_efw_proc_init(struct snd_efw *efw)
 	add_node(efw, root, "clock", proc_read_clock);
 	add_node(efw, root, "firmware", proc_read_hwinfo);
 	add_node(efw, root, "meters", proc_read_phys_meters);
+	add_node(efw, root, "queues", proc_read_queues_state);
 }

commit 6a22683e89e2c851f754ebbec0f2a53f2967bc07
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:08 2014 +0900

    ALSA: fireworks: Add proc interface for debugging purpose
    
    This commit adds proc interface to output infomation for debugging.
     - firmware information
     - sampling rate and clock source
     - physical metering (linear value)
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks_proc.c b/sound/firewire/fireworks/fireworks_proc.c
new file mode 100644
index 000000000000..631c91f64db4
--- /dev/null
+++ b/sound/firewire/fireworks/fireworks_proc.c
@@ -0,0 +1,214 @@
+/*
+ * fireworks_proc.c - a part of driver for Fireworks based devices
+ *
+ * Copyright (c) 2009-2010 Clemens Ladisch
+ * Copyright (c) 2013-2014 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "./fireworks.h"
+
+static inline const char*
+get_phys_name(struct snd_efw_phys_grp *grp, bool input)
+{
+	const char *const ch_type[] = {
+		"Analog", "S/PDIF", "ADAT", "S/PDIF or ADAT", "Mirroring",
+		"Headphones", "I2S", "Guitar", "Pirzo Guitar", "Guitar String",
+	};
+
+	if (grp->type < ARRAY_SIZE(ch_type))
+		return ch_type[grp->type];
+	else if (input)
+		return "Input";
+	else
+		return "Output";
+}
+
+static void
+proc_read_hwinfo(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+{
+	struct snd_efw *efw = entry->private_data;
+	unsigned short i;
+	struct snd_efw_hwinfo *hwinfo;
+
+	hwinfo = kmalloc(sizeof(struct snd_efw_hwinfo), GFP_KERNEL);
+	if (hwinfo == NULL)
+		return;
+
+	if (snd_efw_command_get_hwinfo(efw, hwinfo) < 0)
+		goto end;
+
+	snd_iprintf(buffer, "guid_hi: 0x%X\n", hwinfo->guid_hi);
+	snd_iprintf(buffer, "guid_lo: 0x%X\n", hwinfo->guid_lo);
+	snd_iprintf(buffer, "type: 0x%X\n", hwinfo->type);
+	snd_iprintf(buffer, "version: 0x%X\n", hwinfo->version);
+	snd_iprintf(buffer, "vendor_name: %s\n", hwinfo->vendor_name);
+	snd_iprintf(buffer, "model_name: %s\n", hwinfo->model_name);
+
+	snd_iprintf(buffer, "dsp_version: 0x%X\n", hwinfo->dsp_version);
+	snd_iprintf(buffer, "arm_version: 0x%X\n", hwinfo->arm_version);
+	snd_iprintf(buffer, "fpga_version: 0x%X\n", hwinfo->fpga_version);
+
+	snd_iprintf(buffer, "flags: 0x%X\n", hwinfo->flags);
+
+	snd_iprintf(buffer, "max_sample_rate: 0x%X\n", hwinfo->max_sample_rate);
+	snd_iprintf(buffer, "min_sample_rate: 0x%X\n", hwinfo->min_sample_rate);
+	snd_iprintf(buffer, "supported_clock: 0x%X\n",
+		    hwinfo->supported_clocks);
+
+	snd_iprintf(buffer, "phys out: 0x%X\n", hwinfo->phys_out);
+	snd_iprintf(buffer, "phys in: 0x%X\n", hwinfo->phys_in);
+
+	snd_iprintf(buffer, "phys in grps: 0x%X\n",
+		    hwinfo->phys_in_grp_count);
+	for (i = 0; i < hwinfo->phys_in_grp_count; i++) {
+		snd_iprintf(buffer,
+			    "phys in grp[0x%d]: type 0x%d, count 0x%d\n",
+			    i, hwinfo->phys_out_grps[i].type,
+			    hwinfo->phys_out_grps[i].count);
+	}
+
+	snd_iprintf(buffer, "phys out grps: 0x%X\n",
+		    hwinfo->phys_out_grp_count);
+	for (i = 0; i < hwinfo->phys_out_grp_count; i++) {
+		snd_iprintf(buffer,
+			    "phys out grps[0x%d]: type 0x%d, count 0x%d\n",
+			    i, hwinfo->phys_out_grps[i].type,
+			    hwinfo->phys_out_grps[i].count);
+	}
+
+	snd_iprintf(buffer, "amdtp rx pcm channels 1x: 0x%X\n",
+		    hwinfo->amdtp_rx_pcm_channels);
+	snd_iprintf(buffer, "amdtp tx pcm channels 1x: 0x%X\n",
+		    hwinfo->amdtp_tx_pcm_channels);
+	snd_iprintf(buffer, "amdtp rx pcm channels 2x: 0x%X\n",
+		    hwinfo->amdtp_rx_pcm_channels_2x);
+	snd_iprintf(buffer, "amdtp tx pcm channels 2x: 0x%X\n",
+		    hwinfo->amdtp_tx_pcm_channels_2x);
+	snd_iprintf(buffer, "amdtp rx pcm channels 4x: 0x%X\n",
+		    hwinfo->amdtp_rx_pcm_channels_4x);
+	snd_iprintf(buffer, "amdtp tx pcm channels 4x: 0x%X\n",
+		    hwinfo->amdtp_tx_pcm_channels_4x);
+
+	snd_iprintf(buffer, "midi out ports: 0x%X\n", hwinfo->midi_out_ports);
+	snd_iprintf(buffer, "midi in ports: 0x%X\n", hwinfo->midi_in_ports);
+
+	snd_iprintf(buffer, "mixer playback channels: 0x%X\n",
+		    hwinfo->mixer_playback_channels);
+	snd_iprintf(buffer, "mixer capture channels: 0x%X\n",
+		    hwinfo->mixer_capture_channels);
+end:
+	kfree(hwinfo);
+}
+
+static void
+proc_read_clock(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+{
+	struct snd_efw *efw = entry->private_data;
+	enum snd_efw_clock_source clock_source;
+	unsigned int sampling_rate;
+
+	if (snd_efw_command_get_clock_source(efw, &clock_source) < 0)
+		return;
+
+	if (snd_efw_command_get_sampling_rate(efw, &sampling_rate) < 0)
+		return;
+
+	snd_iprintf(buffer, "Clock Source: %d\n", clock_source);
+	snd_iprintf(buffer, "Sampling Rate: %d\n", sampling_rate);
+}
+
+/*
+ * NOTE:
+ *  dB = 20 * log10(linear / 0x01000000)
+ *  -144.0 dB when linear is 0
+ */
+static void
+proc_read_phys_meters(struct snd_info_entry *entry,
+		      struct snd_info_buffer *buffer)
+{
+	struct snd_efw *efw = entry->private_data;
+	struct snd_efw_phys_meters *meters;
+	unsigned int g, c, m, max, size;
+	const char *name;
+	u32 *linear;
+	int err;
+
+	size = sizeof(struct snd_efw_phys_meters) +
+	       (efw->phys_in + efw->phys_out) * sizeof(u32);
+	meters = kzalloc(size, GFP_KERNEL);
+	if (meters == NULL)
+		return;
+
+	err = snd_efw_command_get_phys_meters(efw, meters, size);
+	if (err < 0)
+		goto end;
+
+	snd_iprintf(buffer, "Physical Meters:\n");
+
+	m = 0;
+	max = min(efw->phys_out, meters->out_meters);
+	linear = meters->values;
+	snd_iprintf(buffer, " %d Outputs:\n", max);
+	for (g = 0; g < efw->phys_out_grp_count; g++) {
+		name = get_phys_name(&efw->phys_out_grps[g], false);
+		for (c = 0; c < efw->phys_out_grps[g].count; c++) {
+			if (m < max)
+				snd_iprintf(buffer, "\t%s [%d]: %d\n",
+					    name, c, linear[m++]);
+		}
+	}
+
+	m = 0;
+	max = min(efw->phys_in, meters->in_meters);
+	linear = meters->values + meters->out_meters;
+	snd_iprintf(buffer, " %d Inputs:\n", max);
+	for (g = 0; g < efw->phys_in_grp_count; g++) {
+		name = get_phys_name(&efw->phys_in_grps[g], true);
+		for (c = 0; c < efw->phys_in_grps[g].count; c++)
+			if (m < max)
+				snd_iprintf(buffer, "\t%s [%d]: %d\n",
+					    name, c, linear[m++]);
+	}
+end:
+	kfree(meters);
+}
+
+static void
+add_node(struct snd_efw *efw, struct snd_info_entry *root, const char *name,
+	 void (*op)(struct snd_info_entry *e, struct snd_info_buffer *b))
+{
+	struct snd_info_entry *entry;
+
+	entry = snd_info_create_card_entry(efw->card, name, root);
+	if (entry == NULL)
+		return;
+
+	snd_info_set_text_ops(entry, efw, op);
+	if (snd_info_register(entry) < 0)
+		snd_info_free_entry(entry);
+}
+
+void snd_efw_proc_init(struct snd_efw *efw)
+{
+	struct snd_info_entry *root;
+
+	/*
+	 * All nodes are automatically removed at snd_card_disconnect(),
+	 * by following to link list.
+	 */
+	root = snd_info_create_card_entry(efw->card, "firewire",
+					  efw->card->proc_root);
+	if (root == NULL)
+		return;
+	root->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	if (snd_info_register(root) < 0) {
+		snd_info_free_entry(root);
+		return;
+	}
+
+	add_node(efw, root, "clock", proc_read_clock);
+	add_node(efw, root, "firmware", proc_read_hwinfo);
+	add_node(efw, root, "meters", proc_read_phys_meters);
+}
