commit 9c0d16ac059148fc7647f5f9e90df6f34d3439f0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 6 22:52:29 2020 +0900

    ALSA: firewire: use KBUILD_MODNAME for struct driver.name instead of string
    
    KBUILD_MODNAME is available to name kernel modules according to its object
    name. This commit uses the macro instead of string for name field of
    struct driver since drivers in ALSA firewire stack have the same name of
    each object name.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200306135229.11659-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 134fc9ee26b9..b1cc013a3540 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -362,7 +362,7 @@ MODULE_DEVICE_TABLE(ieee1394, efw_id_table);
 static struct fw_driver efw_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
-		.name = "snd-fireworks",
+		.name = KBUILD_MODNAME,
 		.bus = &fw_bus_type,
 	},
 	.probe    = efw_probe,

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index faf0e001c4c5..134fc9ee26b9 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -1,10 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * fireworks.c - a part of driver for Fireworks based devices
  *
  * Copyright (c) 2009-2010 Clemens Ladisch
  * Copyright (c) 2013-2014 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 /*

commit 3babca4555b20fc80aff4776662fb237257d9afd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:02 2018 +0900

    ALSA: firewire: simplify cleanup process when failing to register sound card
    
    In former commits, .private_free callback releases resources just for
    data transmission. This release function can be called without the
    resources are actually allocated in error paths.
    
    This commit applies a small refactoring to clean up codes in error
    paths.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index da0c31033821..faf0e001c4c5 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -184,8 +184,11 @@ get_hardware_info(struct snd_efw *efw)
 	return err;
 }
 
-static void efw_free(struct snd_efw *efw)
+static void
+efw_card_free(struct snd_card *card)
 {
+	struct snd_efw *efw = card->private_data;
+
 	mutex_lock(&devices_mutex);
 	clear_bit(efw->card_index, devices_used);
 	mutex_unlock(&devices_mutex);
@@ -194,18 +197,6 @@ static void efw_free(struct snd_efw *efw)
 	snd_efw_transaction_remove_instance(efw);
 }
 
-/*
- * This module releases the FireWire unit data after all ALSA character devices
- * are released by applications. This is for releasing stream data or finishing
- * transactions safely. Thus at returning from .remove(), this module still keep
- * references for the unit.
- */
-static void
-efw_card_free(struct snd_card *card)
-{
-	efw_free(card->private_data);
-}
-
 static void
 do_registration(struct work_struct *work)
 {
@@ -236,6 +227,9 @@ do_registration(struct work_struct *work)
 	set_bit(card_index, devices_used);
 	mutex_unlock(&devices_mutex);
 
+	efw->card->private_free = efw_card_free;
+	efw->card->private_data = efw;
+
 	/* prepare response buffer */
 	snd_efw_resp_buf_size = clamp(snd_efw_resp_buf_size,
 				      SND_EFW_RESPONSE_MAXIMUM_BYTES, 4096U);
@@ -276,18 +270,10 @@ do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	/*
-	 * After registered, efw instance can be released corresponding to
-	 * releasing the sound card instance.
-	 */
-	efw->card->private_free = efw_card_free;
-	efw->card->private_data = efw;
 	efw->registered = true;
 
 	return;
 error:
-	snd_efw_transaction_remove_instance(efw);
-	snd_efw_stream_destroy_duplex(efw);
 	snd_card_free(efw->card);
 	dev_info(&efw->unit->device,
 		 "Sound card registration failed: %d\n", err);

commit 873608dc6b5da7a2571419bfa10e0d088d39cee0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:01 2018 +0900

    ALSA: bebob/fireworks: simplify handling of local device entry table
    
    In drivers of ALSA firewire stack, bebob and fireworks drivers have
    local device entry table. At present, critical section to operate the
    table is from the beginning/end of 'do_registration' call. This can be
    more narrow and simplify codes.
    
    This commit applies small refactoring for the above purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 5854d2a87a18..da0c31033821 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -186,6 +186,10 @@ get_hardware_info(struct snd_efw *efw)
 
 static void efw_free(struct snd_efw *efw)
 {
+	mutex_lock(&devices_mutex);
+	clear_bit(efw->card_index, devices_used);
+	mutex_unlock(&devices_mutex);
+
 	snd_efw_stream_destroy_duplex(efw);
 	snd_efw_transaction_remove_instance(efw);
 }
@@ -199,14 +203,6 @@ static void efw_free(struct snd_efw *efw)
 static void
 efw_card_free(struct snd_card *card)
 {
-	struct snd_efw *efw = card->private_data;
-
-	if (efw->card_index >= 0) {
-		mutex_lock(&devices_mutex);
-		clear_bit(efw->card_index, devices_used);
-		mutex_unlock(&devices_mutex);
-	}
-
 	efw_free(card->private_data);
 }
 
@@ -220,9 +216,8 @@ do_registration(struct work_struct *work)
 	if (efw->registered)
 		return;
 
-	mutex_lock(&devices_mutex);
-
 	/* check registered cards */
+	mutex_lock(&devices_mutex);
 	for (card_index = 0; card_index < SNDRV_CARDS; ++card_index) {
 		if (!test_bit(card_index, devices_used) && enable[card_index])
 			break;
@@ -238,6 +233,8 @@ do_registration(struct work_struct *work)
 		mutex_unlock(&devices_mutex);
 		return;
 	}
+	set_bit(card_index, devices_used);
+	mutex_unlock(&devices_mutex);
 
 	/* prepare response buffer */
 	snd_efw_resp_buf_size = clamp(snd_efw_resp_buf_size,
@@ -279,9 +276,6 @@ do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	set_bit(card_index, devices_used);
-	mutex_unlock(&devices_mutex);
-
 	/*
 	 * After registered, efw instance can be released corresponding to
 	 * releasing the sound card instance.
@@ -292,7 +286,6 @@ do_registration(struct work_struct *work)
 
 	return;
 error:
-	mutex_unlock(&devices_mutex);
 	snd_efw_transaction_remove_instance(efw);
 	snd_efw_stream_destroy_duplex(efw);
 	snd_card_free(efw->card);

commit 5b14ec25a79bf60fc9a663fe579a500b6ac9d8ab
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:00 2018 +0900

    ALSA: firewire: release reference count of firewire unit in .remove callback of bus driver
    
    In a previous commit, drivers in ALSA firewire stack blocks .remove
    callback of bus driver. This enables to release members of private
    data in the callback after releasing device of sound card.
    
    This commit simplifies codes to release the members.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 5a17ead86e61..5854d2a87a18 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -188,9 +188,6 @@ static void efw_free(struct snd_efw *efw)
 {
 	snd_efw_stream_destroy_duplex(efw);
 	snd_efw_transaction_remove_instance(efw);
-
-	mutex_destroy(&efw->mutex);
-	fw_unit_put(efw->unit);
 }
 
 /*
@@ -360,10 +357,10 @@ static void efw_remove(struct fw_unit *unit)
 	if (efw->registered) {
 		// Block till all of ALSA character devices are released.
 		snd_card_free(efw->card);
-	} else {
-		/* Don't forget this case. */
-		efw_free(efw);
 	}
+
+	mutex_destroy(&efw->mutex);
+	fw_unit_put(efw->unit);
 }
 
 static const struct ieee1394_device_id efw_id_table[] = {

commit 61ccc6f6b27c03bb32ca38a3c580d49ce1612d43
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:34:59 2018 +0900

    ALSA: firewire: block .remove callback of bus driver till all of ALSA character devices are released
    
    At present, in .remove callback of bus driver just decrease reference
    count of device for ALSA card instance. This delegates release of the
    device to a process in which the last of ALSA character device is
    released.
    
    On the other hand, the other drivers such as for devices on PCIe are
    programmed to block .remove callback of bus driver till all of ALSA
    character devices are released.
    
    For consistency of behaviour for whole drivers, this probably confuses
    users. This commit takes drivers in ALSA firewire stack to imitate the
    above behaviour.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index f680e2f27806..5a17ead86e61 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -358,8 +358,8 @@ static void efw_remove(struct fw_unit *unit)
 	cancel_delayed_work_sync(&efw->dwork);
 
 	if (efw->registered) {
-		/* No need to wait for releasing card object in this context. */
-		snd_card_free_when_closed(efw->card);
+		// Block till all of ALSA character devices are released.
+		snd_card_free(efw->card);
 	} else {
 		/* Don't forget this case. */
 		efw_free(efw);

commit 784fffbcfe117b508ff628cf296541ab70463140
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:52 2018 +0900

    ALSA: fireworks: use managed-resource to maintain response buffer
    
    ALSA fireworks driver allocates memory object to handle response from
    target unit. The object is used to initiate transaction unique to
    Fireworks board module. This can be released as managed-resource
    of 'struct snd_card.card_dev'.
    
    This commit uses managed-resource of the sound card device for this
    purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 2ff7b9cff9b0..f680e2f27806 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -189,8 +189,6 @@ static void efw_free(struct snd_efw *efw)
 	snd_efw_stream_destroy_duplex(efw);
 	snd_efw_transaction_remove_instance(efw);
 
-	kfree(efw->resp_buf);
-
 	mutex_destroy(&efw->mutex);
 	fw_unit_put(efw->unit);
 }
@@ -247,8 +245,9 @@ do_registration(struct work_struct *work)
 	/* prepare response buffer */
 	snd_efw_resp_buf_size = clamp(snd_efw_resp_buf_size,
 				      SND_EFW_RESPONSE_MAXIMUM_BYTES, 4096U);
-	efw->resp_buf = kzalloc(snd_efw_resp_buf_size, GFP_KERNEL);
-	if (efw->resp_buf == NULL) {
+	efw->resp_buf = devm_kzalloc(&efw->card->card_dev,
+				     snd_efw_resp_buf_size, GFP_KERNEL);
+	if (!efw->resp_buf) {
 		err = -ENOMEM;
 		goto error;
 	}
@@ -300,8 +299,6 @@ do_registration(struct work_struct *work)
 	snd_efw_transaction_remove_instance(efw);
 	snd_efw_stream_destroy_duplex(efw);
 	snd_card_free(efw->card);
-	kfree(efw->resp_buf);
-	efw->resp_buf = NULL;
 	dev_info(&efw->unit->device,
 		 "Sound card registration failed: %d\n", err);
 }

commit 366a20d7a75cff7f89dede6fdfd41bd491aaf8ac
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:50 2018 +0900

    ALSA: firewire: use managed-resource of fw unit device for private data
    
    At present, private data of each driver in ALSA firewire stack is
    allocated/freed by kernel slab allocator for corresponding unit on
    IEEE 1394 bus. In this case, resource-managed slab allocator is
    available to release memory object automatically just before releasing
    device structure for the unit. This idea can prevent runtime from
    memory leak due to programming mistakes.
    
    This commit uses the allocator for the private data. These drivers
    already use reference counter to maintain lifetime of device structure
    for the unit by a pair of fw_unit_get()/fw_unit_put(). The private data
    is safely released in a callback of 'struct snd_card.private_free().
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index f2d073365cf6..2ff7b9cff9b0 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -188,12 +188,11 @@ static void efw_free(struct snd_efw *efw)
 {
 	snd_efw_stream_destroy_duplex(efw);
 	snd_efw_transaction_remove_instance(efw);
-	fw_unit_put(efw->unit);
 
 	kfree(efw->resp_buf);
 
 	mutex_destroy(&efw->mutex);
-	kfree(efw);
+	fw_unit_put(efw->unit);
 }
 
 /*
@@ -312,10 +311,9 @@ efw_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)
 {
 	struct snd_efw *efw;
 
-	efw = kzalloc(sizeof(struct snd_efw), GFP_KERNEL);
+	efw = devm_kzalloc(&unit->device, sizeof(struct snd_efw), GFP_KERNEL);
 	if (efw == NULL)
 		return -ENOMEM;
-
 	efw->unit = fw_unit_get(unit);
 	dev_set_drvdata(&unit->device, efw);
 

commit c3b55e2ec9c76e7a0de2a0b1dc851fdc9440385b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Sep 17 17:26:41 2018 +0900

    ALSA: fireworks: fix memory leak of response buffer at error path
    
    After allocating memory object for response buffer, ALSA fireworks
    driver has leak of the memory object at error path.
    
    This commit releases the object at the error path.
    
    Fixes: 7d3c1d5901aa('ALSA: fireworks: delayed registration of sound card')
    Cc: <stable@vger.kernel.org> # v4.7+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 71a0613d3da0..f2d073365cf6 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -301,6 +301,8 @@ do_registration(struct work_struct *work)
 	snd_efw_transaction_remove_instance(efw);
 	snd_efw_stream_destroy_duplex(efw);
 	snd_card_free(efw->card);
+	kfree(efw->resp_buf);
+	efw->resp_buf = NULL;
 	dev_info(&efw->unit->device,
 		 "Sound card registration failed: %d\n", err);
 }

commit 7d3c1d5901aac873d13c0a03b29ee2bda183383f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Mar 31 08:47:06 2016 +0900

    ALSA: fireworks: delayed registration of sound card
    
    When some fireworks units are connected sequentially, userspace
    applications are involved at bus-reset state on IEEE 1394 bus. In the
    state, any communications can be canceled. Therefore, sound card
    registration should be delayed till the bus gets calm.
    
    This commit achieves it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 8380fb572202..71a0613d3da0 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -184,6 +184,18 @@ get_hardware_info(struct snd_efw *efw)
 	return err;
 }
 
+static void efw_free(struct snd_efw *efw)
+{
+	snd_efw_stream_destroy_duplex(efw);
+	snd_efw_transaction_remove_instance(efw);
+	fw_unit_put(efw->unit);
+
+	kfree(efw->resp_buf);
+
+	mutex_destroy(&efw->mutex);
+	kfree(efw);
+}
+
 /*
  * This module releases the FireWire unit data after all ALSA character devices
  * are released by applications. This is for releasing stream data or finishing
@@ -195,28 +207,24 @@ efw_card_free(struct snd_card *card)
 {
 	struct snd_efw *efw = card->private_data;
 
-	snd_efw_stream_destroy_duplex(efw);
-	snd_efw_transaction_remove_instance(efw);
-	fw_unit_put(efw->unit);
-
-	kfree(efw->resp_buf);
-
 	if (efw->card_index >= 0) {
 		mutex_lock(&devices_mutex);
 		clear_bit(efw->card_index, devices_used);
 		mutex_unlock(&devices_mutex);
 	}
 
-	mutex_destroy(&efw->mutex);
+	efw_free(card->private_data);
 }
 
-static int
-efw_probe(struct fw_unit *unit,
-	  const struct ieee1394_device_id *entry)
+static void
+do_registration(struct work_struct *work)
 {
-	struct snd_card *card;
-	struct snd_efw *efw;
-	int card_index, err;
+	struct snd_efw *efw = container_of(work, struct snd_efw, dwork.work);
+	unsigned int card_index;
+	int err;
+
+	if (efw->registered)
+		return;
 
 	mutex_lock(&devices_mutex);
 
@@ -226,24 +234,16 @@ efw_probe(struct fw_unit *unit,
 			break;
 	}
 	if (card_index >= SNDRV_CARDS) {
-		err = -ENOENT;
-		goto end;
+		mutex_unlock(&devices_mutex);
+		return;
 	}
 
-	err = snd_card_new(&unit->device, index[card_index], id[card_index],
-			   THIS_MODULE, sizeof(struct snd_efw), &card);
-	if (err < 0)
-		goto end;
-	efw = card->private_data;
-	efw->card_index = card_index;
-	set_bit(card_index, devices_used);
-	card->private_free = efw_card_free;
-
-	efw->card = card;
-	efw->unit = fw_unit_get(unit);
-	mutex_init(&efw->mutex);
-	spin_lock_init(&efw->lock);
-	init_waitqueue_head(&efw->hwdep_wait);
+	err = snd_card_new(&efw->unit->device, index[card_index],
+			   id[card_index], THIS_MODULE, 0, &efw->card);
+	if (err < 0) {
+		mutex_unlock(&devices_mutex);
+		return;
+	}
 
 	/* prepare response buffer */
 	snd_efw_resp_buf_size = clamp(snd_efw_resp_buf_size,
@@ -260,6 +260,10 @@ efw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_efw_stream_init_duplex(efw);
+	if (err < 0)
+		goto error;
+
 	snd_efw_proc_init(efw);
 
 	if (efw->midi_out_ports || efw->midi_in_ports) {
@@ -276,44 +280,93 @@ efw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_efw_stream_init_duplex(efw);
+	err = snd_card_register(efw->card);
 	if (err < 0)
 		goto error;
 
-	err = snd_card_register(card);
-	if (err < 0) {
-		snd_efw_stream_destroy_duplex(efw);
-		goto error;
-	}
-
-	dev_set_drvdata(&unit->device, efw);
-end:
+	set_bit(card_index, devices_used);
 	mutex_unlock(&devices_mutex);
-	return err;
+
+	/*
+	 * After registered, efw instance can be released corresponding to
+	 * releasing the sound card instance.
+	 */
+	efw->card->private_free = efw_card_free;
+	efw->card->private_data = efw;
+	efw->registered = true;
+
+	return;
 error:
-	snd_efw_transaction_remove_instance(efw);
 	mutex_unlock(&devices_mutex);
-	snd_card_free(card);
-	return err;
+	snd_efw_transaction_remove_instance(efw);
+	snd_efw_stream_destroy_duplex(efw);
+	snd_card_free(efw->card);
+	dev_info(&efw->unit->device,
+		 "Sound card registration failed: %d\n", err);
+}
+
+static int
+efw_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)
+{
+	struct snd_efw *efw;
+
+	efw = kzalloc(sizeof(struct snd_efw), GFP_KERNEL);
+	if (efw == NULL)
+		return -ENOMEM;
+
+	efw->unit = fw_unit_get(unit);
+	dev_set_drvdata(&unit->device, efw);
+
+	mutex_init(&efw->mutex);
+	spin_lock_init(&efw->lock);
+	init_waitqueue_head(&efw->hwdep_wait);
+
+	/* Allocate and register this sound card later. */
+	INIT_DEFERRABLE_WORK(&efw->dwork, do_registration);
+	snd_fw_schedule_registration(unit, &efw->dwork);
+
+	return 0;
 }
 
 static void efw_update(struct fw_unit *unit)
 {
 	struct snd_efw *efw = dev_get_drvdata(&unit->device);
 
+	/* Postpone a workqueue for deferred registration. */
+	if (!efw->registered)
+		snd_fw_schedule_registration(unit, &efw->dwork);
+
 	snd_efw_transaction_bus_reset(efw->unit);
 
-	mutex_lock(&efw->mutex);
-	snd_efw_stream_update_duplex(efw);
-	mutex_unlock(&efw->mutex);
+	/*
+	 * After registration, userspace can start packet streaming, then this
+	 * code block works fine.
+	 */
+	if (efw->registered) {
+		mutex_lock(&efw->mutex);
+		snd_efw_stream_update_duplex(efw);
+		mutex_unlock(&efw->mutex);
+	}
 }
 
 static void efw_remove(struct fw_unit *unit)
 {
 	struct snd_efw *efw = dev_get_drvdata(&unit->device);
 
-	/* No need to wait for releasing card object in this context. */
-	snd_card_free_when_closed(efw->card);
+	/*
+	 * Confirm to stop the work for registration before the sound card is
+	 * going to be released. The work is not scheduled again because bus
+	 * reset handler is not called anymore.
+	 */
+	cancel_delayed_work_sync(&efw->dwork);
+
+	if (efw->registered) {
+		/* No need to wait for releasing card object in this context. */
+		snd_card_free_when_closed(efw->card);
+	} else {
+		/* Don't forget this case. */
+		efw_free(efw);
+	}
 }
 
 static const struct ieee1394_device_id efw_id_table[] = {

commit 0655ac2f4089321766bb9af19586900ad6cef7bc
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Mar 27 16:09:08 2016 +0900

    ALSA: fireworks: move model quirk detection code to information parser
    
    Currently, model-specific quirks are detected out of information parser,
    however it's natural to detect it in the parser.
    
    This commit applies the idea.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 8f27b67503c8..8380fb572202 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -168,6 +168,17 @@ get_hardware_info(struct snd_efw *efw)
 	       sizeof(struct snd_efw_phys_grp) * hwinfo->phys_in_grp_count);
 	memcpy(&efw->phys_out_grps, hwinfo->phys_out_grps,
 	       sizeof(struct snd_efw_phys_grp) * hwinfo->phys_out_grp_count);
+
+	/* AudioFire8 (since 2009) and AudioFirePre8 */
+	if (hwinfo->type == MODEL_ECHO_AUDIOFIRE_9)
+		efw->is_af9 = true;
+	/* These models uses the same firmware. */
+	if (hwinfo->type == MODEL_ECHO_AUDIOFIRE_2 ||
+	    hwinfo->type == MODEL_ECHO_AUDIOFIRE_4 ||
+	    hwinfo->type == MODEL_ECHO_AUDIOFIRE_9 ||
+	    hwinfo->type == MODEL_GIBSON_RIP ||
+	    hwinfo->type == MODEL_GIBSON_GOLDTOP)
+		efw->is_fireworks3 = true;
 end:
 	kfree(hwinfo);
 	return err;
@@ -248,16 +259,6 @@ efw_probe(struct fw_unit *unit,
 	err = get_hardware_info(efw);
 	if (err < 0)
 		goto error;
-	/* AudioFire8 (since 2009) and AudioFirePre8 */
-	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_9)
-		efw->is_af9 = true;
-	/* These models uses the same firmware. */
-	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_2 ||
-	    entry->model_id == MODEL_ECHO_AUDIOFIRE_4 ||
-	    entry->model_id == MODEL_ECHO_AUDIOFIRE_9 ||
-	    entry->model_id == MODEL_GIBSON_RIP ||
-	    entry->model_id == MODEL_GIBSON_GOLDTOP)
-		efw->is_fireworks3 = true;
 
 	snd_efw_proc_init(efw);
 

commit 99d7355914d3f97e4419675b938382d72aac0339
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 20 16:41:01 2016 +0900

    ALSA: fireworks: serialize transactions to update connections at bus reset
    
    In IEC 61883-1, at bus-reset, applications can continue isochronous
    streaming by updating connections. In ALSA fireworks driver, the
    operation is executed in 'update' handler for bus driver.
    
    The connection resources are also changed in process contexts of PCM/MIDI
    applications. Therefore, bus-reset handling has race condition
    against connection. Current ALSA fireworks driver has a bug for the
    condition.
    
    This commit fixes the bug, by expand critical section with mutex. As a
    result, connection updating operation in bus-reset handler and connection
    changing operation in process context are serialized.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index d5b19bc11e59..8f27b67503c8 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -301,7 +301,10 @@ static void efw_update(struct fw_unit *unit)
 	struct snd_efw *efw = dev_get_drvdata(&unit->device);
 
 	snd_efw_transaction_bus_reset(efw->unit);
+
+	mutex_lock(&efw->mutex);
 	snd_efw_stream_update_duplex(efw);
+	mutex_unlock(&efw->mutex);
 }
 
 static void efw_remove(struct fw_unit *unit)

commit 49c7b3fcd9f0a0125e8cd8212d5576382198eeb2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:22:01 2015 +0900

    ALSA: firewire-lib: rename macros with AM824 prefix
    
    This commit renames some macros just related to AM824 format. In later
    commit, they're moved to AM824 layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index c94a432f7cc6..d5b19bc11e59 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -138,12 +138,12 @@ get_hardware_info(struct snd_efw *efw)
 	efw->midi_out_ports = hwinfo->midi_out_ports;
 	efw->midi_in_ports = hwinfo->midi_in_ports;
 
-	if (hwinfo->amdtp_tx_pcm_channels    > AMDTP_MAX_CHANNELS_FOR_PCM ||
-	    hwinfo->amdtp_tx_pcm_channels_2x > AMDTP_MAX_CHANNELS_FOR_PCM ||
-	    hwinfo->amdtp_tx_pcm_channels_4x > AMDTP_MAX_CHANNELS_FOR_PCM ||
-	    hwinfo->amdtp_rx_pcm_channels    > AMDTP_MAX_CHANNELS_FOR_PCM ||
-	    hwinfo->amdtp_rx_pcm_channels_2x > AMDTP_MAX_CHANNELS_FOR_PCM ||
-	    hwinfo->amdtp_rx_pcm_channels_4x > AMDTP_MAX_CHANNELS_FOR_PCM) {
+	if (hwinfo->amdtp_tx_pcm_channels    > AM824_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_tx_pcm_channels_2x > AM824_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_tx_pcm_channels_4x > AM824_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_rx_pcm_channels    > AM824_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_rx_pcm_channels_2x > AM824_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_rx_pcm_channels_4x > AM824_MAX_CHANNELS_FOR_PCM) {
 		err = -ENOSYS;
 		goto end;
 	}

commit 18f5ed365d3f188a91149d528c853000330a4a58
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Aug 5 09:21:05 2015 +0900

    ALSA: fireworks/firewire-lib: add support for recent firmware quirk
    
    Fireworks uses TSB43CB43(IceLynx-Micro) as its IEC 61883-1/6 interface.
    This chip includes ARM7 core, and loads and runs program. The firmware
    is stored in on-board memory and loaded every powering-on from it.
    
    Echo Audio ships several versions of firmwares for each model. These
    firmwares have each quirk and the quirk changes a sequence of packets.
    
    As long as I investigated, AudioFire2/AudioFire4/AudioFirePre8 have a
    quirk to transfer a first packet with 0x02 in its dbc field. This causes
    ALSA Fireworks driver to detect discontinuity. In this case, firmware
    version 5.7.0, 5.7.3 and 5.8.0 are used.
    
    Payload  CIP      CIP
    quadlets header1  header2
    02       00050002 90ffffff <-
    42       0005000a 90013000
    42       00050012 90014400
    42       0005001a 90015800
    02       0005001a 90ffffff
    42       00050022 90019000
    42       0005002a 9001a400
    42       00050032 9001b800
    02       00050032 90ffffff
    42       0005003a 9001d000
    42       00050042 9001e400
    42       0005004a 9001f800
    02       0005004a 90ffffff
    (AudioFire2 with firmware version 5.7.)
    
    $ dmesg
    snd-fireworks fw1.0: Detect discontinuity of CIP: 00 02
    
    These models, AudioFire8 (since Jul 2009 ) and Gibson Robot Interface
    Pack series uses the same ARM binary as their firmware. Thus, this
    quirk may be observed among them.
    
    This commit adds a new member for AMDTP structure. This member represents
    the value of dbc field in a first AMDTP packet. Drivers can set it with
    a preferred value according to model's quirk.
    
    Tested-by: Johannes Oertei <johannes.oertel@uni-due.de>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 2682e7e3e5c9..c94a432f7cc6 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -248,8 +248,16 @@ efw_probe(struct fw_unit *unit,
 	err = get_hardware_info(efw);
 	if (err < 0)
 		goto error;
+	/* AudioFire8 (since 2009) and AudioFirePre8 */
 	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_9)
 		efw->is_af9 = true;
+	/* These models uses the same firmware. */
+	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_2 ||
+	    entry->model_id == MODEL_ECHO_AUDIOFIRE_4 ||
+	    entry->model_id == MODEL_ECHO_AUDIOFIRE_9 ||
+	    entry->model_id == MODEL_GIBSON_RIP ||
+	    entry->model_id == MODEL_GIBSON_GOLDTOP)
+		efw->is_fireworks3 = true;
 
 	snd_efw_proc_init(efw);
 

commit c85523d1d97cc86aadc388221aa83ae9bc1e7cca
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Aug 5 09:21:04 2015 +0900

    Revert "ALSA: fireworks: add support for AudioFire2 quirk"
    
    This reverts commit 9c6893e0be38b6ca9a56a854226e51dee0a16a5a.
    
    The fix is superseded by the next commit as a better implementation
    for supporting AudioFire2/AudioFire4/AudioFirePre8 quirks.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index c670db4eee70..2682e7e3e5c9 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -248,8 +248,6 @@ efw_probe(struct fw_unit *unit,
 	err = get_hardware_info(efw);
 	if (err < 0)
 		goto error;
-	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_2)
-		efw->is_af2 = true;
 	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_9)
 		efw->is_af9 = true;
 

commit 9c6893e0be38b6ca9a56a854226e51dee0a16a5a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jul 26 16:10:09 2015 +0900

    ALSA: fireworks: add support for AudioFire2 quirk
    
    Fireworks uses TSB43CB43(IceLynx-Micro) as its IEC 61883-1/6 interface.
    This chip includes ARM7 core, and loads and runs program. The firmware
    is stored in on-board memory and loaded every powering-on.
    
    Echo Audio ships several versions of firmwares for each model. These
    firmwares have each quirk and the quirk changes a sequence of packets.
    
    AudioFire2 has a quirk to transfer a first packet with non-zero in
    its dbc field. This causes ALSA Fireworks driver to detect discontinuity.
    As long as I investigated, firmware 5.7, 5.7.6 and 5.8 have this quirk.
    
    This commit adds a support for the quirk to handle AudioFire2 packets.
    For safe, CIP_SKIP_INIT_DBC_CHECK is applied to all versions of
    AudioFire2's firmwares.
    
    02 00050002 90ffffff <-
    42 0005000a 90013000
    42 00050012 90014400
    42 0005001a 90015800
    02 0005001a 90ffffff
    42 00050022 90019000
    42 0005002a 9001a400
    42 00050032 9001b800
    02 00050032 90ffffff
    42 0005003a 9001d000
    42 00050042 9001e400
    42 0005004a 9001f800
    02 0005004a 90ffffff
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 2682e7e3e5c9..c670db4eee70 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -248,6 +248,8 @@ efw_probe(struct fw_unit *unit,
 	err = get_hardware_info(efw);
 	if (err < 0)
 		goto error;
+	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_2)
+		efw->is_af2 = true;
 	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_9)
 		efw->is_af9 = true;
 

commit dec84316dd53c90e93b4ee849483bd4bd1e9a585
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 21 23:55:00 2015 +0900

    ALSA: fireworks/bebob/dice/oxfw: make it possible to shutdown safely
    
    A part of these drivers, especially BeBoB driver, are programmed to wait
    some events. Thus the drivers should not destroy any data in .remove()
    context.
    
    This commit moves some destructors from 'struct fw_driver.remove()' to
    'struct snd_card.private_free()' to shutdown safely.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 1e33394d8a93..2682e7e3e5c9 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -184,8 +184,12 @@ efw_card_free(struct snd_card *card)
 {
 	struct snd_efw *efw = card->private_data;
 
+	snd_efw_stream_destroy_duplex(efw);
+	snd_efw_transaction_remove_instance(efw);
 	fw_unit_put(efw->unit);
 
+	kfree(efw->resp_buf);
+
 	if (efw->card_index >= 0) {
 		mutex_lock(&devices_mutex);
 		clear_bit(efw->card_index, devices_used);
@@ -193,7 +197,6 @@ efw_card_free(struct snd_card *card)
 	}
 
 	mutex_destroy(&efw->mutex);
-	kfree(efw->resp_buf);
 }
 
 static int
@@ -297,11 +300,6 @@ static void efw_remove(struct fw_unit *unit)
 {
 	struct snd_efw *efw = dev_get_drvdata(&unit->device);
 
-	snd_efw_stream_destroy_duplex(efw);
-	snd_efw_transaction_remove_instance(efw);
-
-	snd_card_disconnect(efw->card);
-
 	/* No need to wait for releasing card object in this context. */
 	snd_card_free_when_closed(efw->card);
 }

commit 12ed719291a953d443921f9cdb0ffee41066c340
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 21 23:54:57 2015 +0900

    ALSA: fireworks/bebob/dice/oxfw: add reference-counting for FireWire unit
    
    Fireworks and Dice drivers try to touch instances of FireWire unit after
    sound card object is released, while references to the unit is decremented
    in .remove(). When unplugging during streaming, sound card object is
    released after .remove(), thus Fireworks and Dice drivers causes GPF or
    Null-pointer-dereferencing to application processes because an instance of
    FireWire unit was already released.
    
    This commit adds reference-counting for FireWire unit in drivers to allow
    them to touch an instance of FireWire unit after .remove(). In most case,
    any operations after .remove() may be failed safely.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 3e2ed8e82cbc..1e33394d8a93 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -173,11 +173,19 @@ get_hardware_info(struct snd_efw *efw)
 	return err;
 }
 
+/*
+ * This module releases the FireWire unit data after all ALSA character devices
+ * are released by applications. This is for releasing stream data or finishing
+ * transactions safely. Thus at returning from .remove(), this module still keep
+ * references for the unit.
+ */
 static void
 efw_card_free(struct snd_card *card)
 {
 	struct snd_efw *efw = card->private_data;
 
+	fw_unit_put(efw->unit);
+
 	if (efw->card_index >= 0) {
 		mutex_lock(&devices_mutex);
 		clear_bit(efw->card_index, devices_used);
@@ -218,7 +226,7 @@ efw_probe(struct fw_unit *unit,
 	card->private_free = efw_card_free;
 
 	efw->card = card;
-	efw->unit = unit;
+	efw->unit = fw_unit_get(unit);
 	mutex_init(&efw->mutex);
 	spin_lock_init(&efw->lock);
 	init_waitqueue_head(&efw->hwdep_wait);
@@ -293,6 +301,8 @@ static void efw_remove(struct fw_unit *unit)
 	snd_efw_transaction_remove_instance(efw);
 
 	snd_card_disconnect(efw->card);
+
+	/* No need to wait for releasing card object in this context. */
 	snd_card_free_when_closed(efw->card);
 }
 

commit 021fb6f27591ff3eab29278d822935fe2d504a8b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 4 15:25:36 2014 +0900

    ALSA: fireworks: Remove meaningless mutex_destroy()
    
    Currently mutex_destroy() is called in module's cleanup function. But after
    cleaned up, this mutex is automatically released. So this function call
    is meaningless.
    
    [fixed a typo in changelog by tiwai]
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 996fdc44c83c..3e2ed8e82cbc 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -346,7 +346,6 @@ static void __exit snd_efw_exit(void)
 {
 	snd_efw_transaction_unregister();
 	driver_unregister(&efw_driver.driver);
-	mutex_destroy(&devices_mutex);
 }
 
 module_init(snd_efw_init);

commit 396178370b9dc20275811dcc3b607c5af70689ba
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed May 28 19:42:46 2014 +0300

    ALSA: fireworks: small leak on error path
    
    There was a typo here so we return directly instead of freeing "hwinfo".
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewd-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Tested-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 8e856cc6630d..996fdc44c83c 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -157,7 +157,7 @@ get_hardware_info(struct snd_efw *efw)
 	/* Hardware metering. */
 	if (hwinfo->phys_in_grp_count  > HWINFO_MAX_CAPS_GROUPS ||
 	    hwinfo->phys_out_grp_count > HWINFO_MAX_CAPS_GROUPS) {
-		return -EIO;
+		err = -EIO;
 		goto end;
 	}
 	efw->phys_in = hwinfo->phys_in;

commit aeebbddda7588d25dd2c1a6180f740c67f05797d
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed May 28 19:42:02 2014 +0300

    ALSA: fireworks: remove some stray checks
    
    We checked "err" earlier.  These things seem to be left over code.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewd-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Tested-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index a354d26afe9e..8e856cc6630d 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -89,8 +89,6 @@ get_hardware_info(struct snd_efw *efw)
 	snprintf(version, sizeof(version), "%u.%u",
 		 (hwinfo->arm_version >> 24) & 0xff,
 		 (hwinfo->arm_version >> 16) & 0xff);
-	if (err < 0)
-		goto end;
 	efw->firmware_version = hwinfo->arm_version;
 
 	strcpy(efw->card->driver, "Fireworks");
@@ -101,8 +99,6 @@ get_hardware_info(struct snd_efw *efw)
 		 hwinfo->vendor_name, hwinfo->model_name, version,
 		 hwinfo->guid_hi, hwinfo->guid_lo,
 		 dev_name(&efw->unit->device), 100 << fw_dev->max_speed);
-	if (err < 0)
-		goto end;
 
 	if (hwinfo->flags & BIT(FLAG_RESP_ADDR_CHANGABLE))
 		efw->resp_addr_changable = true;

commit 555e8a8f7f149544eb7d4aa3a6420bc4c3055638
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:13 2014 +0900

    ALSA: fireworks: Add command/response functionality into hwdep interface
    
    This commit adds two functionality for hwdep interface, adds two parameters for
    this driver, add a node for proc interface.
    
    To receive responses from devices, this driver already allocate own callback
    into initial memory space in host controller. This means no one can allocate
    its own callback to the address. So this driver must give a way for user
    applications to receive responses.
    
    This commit adds a functionality to receive responses via hwdep interface. The
    application can receive responses to read from this interface. To achieve this,
    this commit adds a buffer to queue responses. The default size of this buffer is
    1024 bytes. This size can be changed to give preferrable size to
    'resp_buf_size' parameter for this driver. The application should notice rest
    of space in this buffer because this driver don't push responses when this
    buffer has no space.
    
    Additionaly, this commit adds a functionality to transmit commands via hwdep
    interface. The application can transmit commands to write into this interface.
    I note that the application can transmit one command at once, but can receive
    as many responses as possible untill the user-buffer is full.
    
    When using these interfaces, the application must keep maximum number of
    sequence number in command within the number in firewire.h because this driver
    uses this number to distinguish the response is against the command by the
    application or this driver.
    
    Usually responses against commands which the application transmits are pushed
    into this buffer. But to enable 'resp_buf_debug' parameter for this driver, all
    responses are pushed into the buffer. When using this mode, I reccomend to
    expand the size of buffer.
    
    Finally this commit adds a new node into proc interface to output status of the
    buffer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index f8d06f56618f..a354d26afe9e 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -24,6 +24,8 @@ MODULE_LICENSE("GPL v2");
 static int index[SNDRV_CARDS]	= SNDRV_DEFAULT_IDX;
 static char *id[SNDRV_CARDS]	= SNDRV_DEFAULT_STR;
 static bool enable[SNDRV_CARDS]	= SNDRV_DEFAULT_ENABLE_PNP;
+unsigned int snd_efw_resp_buf_size	= 1024;
+bool snd_efw_resp_buf_debug		= false;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "card index");
@@ -31,6 +33,11 @@ module_param_array(id, charp, NULL, 0444);
 MODULE_PARM_DESC(id, "ID string");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "enable Fireworks sound card");
+module_param_named(resp_buf_size, snd_efw_resp_buf_size, uint, 0444);
+MODULE_PARM_DESC(resp_buf_size,
+		 "response buffer size (max 4096, default 1024)");
+module_param_named(resp_buf_debug, snd_efw_resp_buf_debug, bool, 0444);
+MODULE_PARM_DESC(resp_buf_debug, "store all responses to buffer");
 
 static DEFINE_MUTEX(devices_mutex);
 static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
@@ -182,6 +189,7 @@ efw_card_free(struct snd_card *card)
 	}
 
 	mutex_destroy(&efw->mutex);
+	kfree(efw->resp_buf);
 }
 
 static int
@@ -219,6 +227,17 @@ efw_probe(struct fw_unit *unit,
 	spin_lock_init(&efw->lock);
 	init_waitqueue_head(&efw->hwdep_wait);
 
+	/* prepare response buffer */
+	snd_efw_resp_buf_size = clamp(snd_efw_resp_buf_size,
+				      SND_EFW_RESPONSE_MAXIMUM_BYTES, 4096U);
+	efw->resp_buf = kzalloc(snd_efw_resp_buf_size, GFP_KERNEL);
+	if (efw->resp_buf == NULL) {
+		err = -ENOMEM;
+		goto error;
+	}
+	efw->pull_ptr = efw->push_ptr = efw->resp_buf;
+	snd_efw_transaction_add_instance(efw);
+
 	err = get_hardware_info(efw);
 	if (err < 0)
 		goto error;
@@ -256,6 +275,7 @@ efw_probe(struct fw_unit *unit,
 	mutex_unlock(&devices_mutex);
 	return err;
 error:
+	snd_efw_transaction_remove_instance(efw);
 	mutex_unlock(&devices_mutex);
 	snd_card_free(card);
 	return err;
@@ -274,6 +294,7 @@ static void efw_remove(struct fw_unit *unit)
 	struct snd_efw *efw = dev_get_drvdata(&unit->device);
 
 	snd_efw_stream_destroy_duplex(efw);
+	snd_efw_transaction_remove_instance(efw);
 
 	snd_card_disconnect(efw->card);
 	snd_card_free_when_closed(efw->card);

commit 594ddced821dee39a548efe46d7f834bae013505
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:12 2014 +0900

    ALSA: fireworks: Add hwdep interface
    
    This interface is designed for mixer/control application. To use hwdep
    interface, the application can get information about firewire node, can
    lock/unlock kernel streaming and can get notification at starting/stopping
    kernel streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index d7877c79e32f..f8d06f56618f 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -217,6 +217,7 @@ efw_probe(struct fw_unit *unit,
 	efw->unit = unit;
 	mutex_init(&efw->mutex);
 	spin_lock_init(&efw->lock);
+	init_waitqueue_head(&efw->hwdep_wait);
 
 	err = get_hardware_info(efw);
 	if (err < 0)
@@ -236,6 +237,10 @@ efw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_efw_create_hwdep_device(efw);
+	if (err < 0)
+		goto error;
+
 	err = snd_efw_stream_init_duplex(efw);
 	if (err < 0)
 		goto error;

commit aa02bb6e60783938d61eefe38346781a646800a6
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:11 2014 +0900

    ALSA: fireworks: Add PCM interface
    
    This commit adds a functionality to capture/playback PCM samples.
    
    When AMDTP stream is already running for PCM or the source of clock is not
    internal, available sampling rate is limited at current one.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 9204c7c56513..d7877c79e32f 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -232,6 +232,10 @@ efw_probe(struct fw_unit *unit,
 			goto error;
 	}
 
+	err = snd_efw_create_pcm_devices(efw);
+	if (err < 0)
+		goto error;
+
 	err = snd_efw_stream_init_duplex(efw);
 	if (err < 0)
 		goto error;

commit a63d3ff1059a4d2236521e4fdbafabfc62b4f81a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:09 2014 +0900

    ALSA: fireworks: Add MIDI interface
    
    This commit adds a functionality to capture/playback MIDI messages.
    
    When no AMDTP streams are running, this driver starts AMDTP stream for MIDI
    stream at current sampling rate.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 311e4a6ef0a6..9204c7c56513 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -226,6 +226,12 @@ efw_probe(struct fw_unit *unit,
 
 	snd_efw_proc_init(efw);
 
+	if (efw->midi_out_ports || efw->midi_in_ports) {
+		err = snd_efw_create_midi_devices(efw);
+		if (err < 0)
+			goto error;
+	}
+
 	err = snd_efw_stream_init_duplex(efw);
 	if (err < 0)
 		goto error;

commit 6a22683e89e2c851f754ebbec0f2a53f2967bc07
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:08 2014 +0900

    ALSA: fireworks: Add proc interface for debugging purpose
    
    This commit adds proc interface to output infomation for debugging.
     - firmware information
     - sampling rate and clock source
     - physical metering (linear value)
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 25997f1ee300..311e4a6ef0a6 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -150,6 +150,21 @@ get_hardware_info(struct snd_efw *efw)
 	efw->pcm_playback_channels[0] = hwinfo->amdtp_rx_pcm_channels;
 	efw->pcm_playback_channels[1] = hwinfo->amdtp_rx_pcm_channels_2x;
 	efw->pcm_playback_channels[2] = hwinfo->amdtp_rx_pcm_channels_4x;
+
+	/* Hardware metering. */
+	if (hwinfo->phys_in_grp_count  > HWINFO_MAX_CAPS_GROUPS ||
+	    hwinfo->phys_out_grp_count > HWINFO_MAX_CAPS_GROUPS) {
+		return -EIO;
+		goto end;
+	}
+	efw->phys_in = hwinfo->phys_in;
+	efw->phys_out = hwinfo->phys_out;
+	efw->phys_in_grp_count = hwinfo->phys_in_grp_count;
+	efw->phys_out_grp_count = hwinfo->phys_out_grp_count;
+	memcpy(&efw->phys_in_grps, hwinfo->phys_in_grps,
+	       sizeof(struct snd_efw_phys_grp) * hwinfo->phys_in_grp_count);
+	memcpy(&efw->phys_out_grps, hwinfo->phys_out_grps,
+	       sizeof(struct snd_efw_phys_grp) * hwinfo->phys_out_grp_count);
 end:
 	kfree(hwinfo);
 	return err;
@@ -209,6 +224,8 @@ efw_probe(struct fw_unit *unit,
 	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_9)
 		efw->is_af9 = true;
 
+	snd_efw_proc_init(efw);
+
 	err = snd_efw_stream_init_duplex(efw);
 	if (err < 0)
 		goto error;

commit d9cd0065c8a48dd0ef61acaa9584e3e723249c57
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:06 2014 +0900

    ALSA: fireworks/firewire-lib: Add a quirk for fixed interval of reported dbc
    
    Fireworks firmware version 5.5 reports fix interval for dbc in each packet.
    
    For example, AudioFire4:
    CIP0     CIP1     Payload
    00070000 900484FF 72
    00070008 9004A8FF 72
    00070008 90FFFFFF 02
    00070010 9004D0FF 72
    00070018 9004C4FF 72
    00070020 9004E8FF 72
    00070020 90FFFFFF 02
    00070028 900410FE 72
    
    The interval of each dbc should be 16 except for empty packet but it's still 8.
    
    This commit adds a flag for this quirk and codes to refer to a fixed value.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 02b3259059f0..25997f1ee300 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -84,6 +84,7 @@ get_hardware_info(struct snd_efw *efw)
 		 (hwinfo->arm_version >> 16) & 0xff);
 	if (err < 0)
 		goto end;
+	efw->firmware_version = hwinfo->arm_version;
 
 	strcpy(efw->card->driver, "Fireworks");
 	strcpy(efw->card->shortname, hwinfo->model_name);

commit 697022391e46614184101c59e46c9671598026db
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:05 2014 +0900

    ALSA: fireworks/firewire-lib: Add a quirk for wrong dbs in tx packets
    
    One of Fireworks firmware, named  as 'AudioFire9', seems to transmit
    packets with wrong value of dbs. It's always 0x11 but actual size of
    data block is different.
    
    This commit adds a flag for this quirk and some codes to calculate
    correct size.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 307fb2f250da..02b3259059f0 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -205,6 +205,8 @@ efw_probe(struct fw_unit *unit,
 	err = get_hardware_info(efw);
 	if (err < 0)
 		goto error;
+	if (entry->model_id == MODEL_ECHO_AUDIOFIRE_9)
+		efw->is_af9 = true;
 
 	err = snd_efw_stream_init_duplex(efw);
 	if (err < 0)

commit 315fd41fe9d43838ab5afd26c58d908d18313d9a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:02 2014 +0900

    ALSA: fireworks: Add connection and stream management
    
    Fireworks manages connections by CMP and can transmit/receive AMDTP streams
    with a few quirks. This commit adds functionality to start/stop the streams.
    
    Major Fireworks products don't support 'SYT-Match' clock source mode, except
    for AudioFire12/8(till 2009 July) with firmware version 1.0. Already in
    previous commit, this driver don't support such old firmwares. So this commit
    adds support for non 'SYT-Match' clock source modes.
    
    I note that this driver has a short gap for MIDI streams when starting PCM
    stream. When AMDTP streams are running only for MIDI data and PCM data is
    going to be joined at different sampling rate, then AMDTP streams are
    stopped once and started again after changing sampling rate.
    
    Unfortunately, Fireworks is not fully compliant to IEC 61883-1/6. Some commits
    following to this commit add these quirks.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index 6fa3a5d725d5..307fb2f250da 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -98,6 +98,57 @@ get_hardware_info(struct snd_efw *efw)
 
 	if (hwinfo->flags & BIT(FLAG_RESP_ADDR_CHANGABLE))
 		efw->resp_addr_changable = true;
+
+	efw->supported_sampling_rate = 0;
+	if ((hwinfo->min_sample_rate <= 22050)
+	 && (22050 <= hwinfo->max_sample_rate))
+		efw->supported_sampling_rate |= SNDRV_PCM_RATE_22050;
+	if ((hwinfo->min_sample_rate <= 32000)
+	 && (32000 <= hwinfo->max_sample_rate))
+		efw->supported_sampling_rate |= SNDRV_PCM_RATE_32000;
+	if ((hwinfo->min_sample_rate <= 44100)
+	 && (44100 <= hwinfo->max_sample_rate))
+		efw->supported_sampling_rate |= SNDRV_PCM_RATE_44100;
+	if ((hwinfo->min_sample_rate <= 48000)
+	 && (48000 <= hwinfo->max_sample_rate))
+		efw->supported_sampling_rate |= SNDRV_PCM_RATE_48000;
+	if ((hwinfo->min_sample_rate <= 88200)
+	 && (88200 <= hwinfo->max_sample_rate))
+		efw->supported_sampling_rate |= SNDRV_PCM_RATE_88200;
+	if ((hwinfo->min_sample_rate <= 96000)
+	 && (96000 <= hwinfo->max_sample_rate))
+		efw->supported_sampling_rate |= SNDRV_PCM_RATE_96000;
+	if ((hwinfo->min_sample_rate <= 176400)
+	 && (176400 <= hwinfo->max_sample_rate))
+		efw->supported_sampling_rate |= SNDRV_PCM_RATE_176400;
+	if ((hwinfo->min_sample_rate <= 192000)
+	 && (192000 <= hwinfo->max_sample_rate))
+		efw->supported_sampling_rate |= SNDRV_PCM_RATE_192000;
+
+	/* the number of MIDI ports, not of MIDI conformant data channels */
+	if (hwinfo->midi_out_ports > SND_EFW_MAX_MIDI_OUT_PORTS ||
+	    hwinfo->midi_in_ports > SND_EFW_MAX_MIDI_IN_PORTS) {
+		err = -EIO;
+		goto end;
+	}
+	efw->midi_out_ports = hwinfo->midi_out_ports;
+	efw->midi_in_ports = hwinfo->midi_in_ports;
+
+	if (hwinfo->amdtp_tx_pcm_channels    > AMDTP_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_tx_pcm_channels_2x > AMDTP_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_tx_pcm_channels_4x > AMDTP_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_rx_pcm_channels    > AMDTP_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_rx_pcm_channels_2x > AMDTP_MAX_CHANNELS_FOR_PCM ||
+	    hwinfo->amdtp_rx_pcm_channels_4x > AMDTP_MAX_CHANNELS_FOR_PCM) {
+		err = -ENOSYS;
+		goto end;
+	}
+	efw->pcm_capture_channels[0] = hwinfo->amdtp_tx_pcm_channels;
+	efw->pcm_capture_channels[1] = hwinfo->amdtp_tx_pcm_channels_2x;
+	efw->pcm_capture_channels[2] = hwinfo->amdtp_tx_pcm_channels_4x;
+	efw->pcm_playback_channels[0] = hwinfo->amdtp_rx_pcm_channels;
+	efw->pcm_playback_channels[1] = hwinfo->amdtp_rx_pcm_channels_2x;
+	efw->pcm_playback_channels[2] = hwinfo->amdtp_rx_pcm_channels_4x;
 end:
 	kfree(hwinfo);
 	return err;
@@ -155,10 +206,16 @@ efw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_card_register(card);
+	err = snd_efw_stream_init_duplex(efw);
 	if (err < 0)
 		goto error;
 
+	err = snd_card_register(card);
+	if (err < 0) {
+		snd_efw_stream_destroy_duplex(efw);
+		goto error;
+	}
+
 	dev_set_drvdata(&unit->device, efw);
 end:
 	mutex_unlock(&devices_mutex);
@@ -172,12 +229,17 @@ efw_probe(struct fw_unit *unit,
 static void efw_update(struct fw_unit *unit)
 {
 	struct snd_efw *efw = dev_get_drvdata(&unit->device);
+
 	snd_efw_transaction_bus_reset(efw->unit);
+	snd_efw_stream_update_duplex(efw);
 }
 
 static void efw_remove(struct fw_unit *unit)
 {
 	struct snd_efw *efw = dev_get_drvdata(&unit->device);
+
+	snd_efw_stream_destroy_duplex(efw);
+
 	snd_card_disconnect(efw->card);
 	snd_card_free_when_closed(efw->card);
 }

commit bde8a8f23bbe6db51fa4e81644273af18fef3d7a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:01 2014 +0900

    ALSA: fireworks: Add transaction and some commands
    
    Fireworks uses own command and response. This commit adds functionality to
    transact and adds some commands required for sound card instance and kernel
    streaming.
    
    There are two ways to deliver substance of this transaction:
    1.AV/C vendor dependent command for command/response
    2.Async transaction to specific addresses for command/response
    
    By way 1, I confirm AudioFire12 cannot correctly response to some commands with
    firmware version 5.0 or later. This is also confirmed by FFADO. So this driver
    implement way 2.
    
    The address for response gives an issue. When this driver allocate own callback
    function into the address, then no one can allocate its own callback function.
    This situation is not good for applications in user-land. This issue is solved
    in later commit.
    
    I note there is a command to change the address for response if the device
    supports. But this driver uses default value. So users should not execute this
    command as long as hoping this driver works correctly.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
index ad719a1d5353..6fa3a5d725d5 100644
--- a/sound/firewire/fireworks/fireworks.c
+++ b/sound/firewire/fireworks/fireworks.c
@@ -59,6 +59,50 @@ static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 /* unknown as product */
 #define  MODEL_GIBSON_GOLDTOP		0x00afb9
 
+/* part of hardware capability flags */
+#define FLAG_RESP_ADDR_CHANGABLE	0
+
+static int
+get_hardware_info(struct snd_efw *efw)
+{
+	struct fw_device *fw_dev = fw_parent_device(efw->unit);
+	struct snd_efw_hwinfo *hwinfo;
+	char version[12] = {0};
+	int err;
+
+	hwinfo = kzalloc(sizeof(struct snd_efw_hwinfo), GFP_KERNEL);
+	if (hwinfo == NULL)
+		return -ENOMEM;
+
+	err = snd_efw_command_get_hwinfo(efw, hwinfo);
+	if (err < 0)
+		goto end;
+
+	/* firmware version for communication chipset */
+	snprintf(version, sizeof(version), "%u.%u",
+		 (hwinfo->arm_version >> 24) & 0xff,
+		 (hwinfo->arm_version >> 16) & 0xff);
+	if (err < 0)
+		goto end;
+
+	strcpy(efw->card->driver, "Fireworks");
+	strcpy(efw->card->shortname, hwinfo->model_name);
+	strcpy(efw->card->mixername, hwinfo->model_name);
+	snprintf(efw->card->longname, sizeof(efw->card->longname),
+		 "%s %s v%s, GUID %08x%08x at %s, S%d",
+		 hwinfo->vendor_name, hwinfo->model_name, version,
+		 hwinfo->guid_hi, hwinfo->guid_lo,
+		 dev_name(&efw->unit->device), 100 << fw_dev->max_speed);
+	if (err < 0)
+		goto end;
+
+	if (hwinfo->flags & BIT(FLAG_RESP_ADDR_CHANGABLE))
+		efw->resp_addr_changable = true;
+end:
+	kfree(hwinfo);
+	return err;
+}
+
 static void
 efw_card_free(struct snd_card *card)
 {
@@ -107,14 +151,14 @@ efw_probe(struct fw_unit *unit,
 	mutex_init(&efw->mutex);
 	spin_lock_init(&efw->lock);
 
-	strcpy(efw->card->driver, "Fireworks");
-	strcpy(efw->card->shortname, efw->card->driver);
-	strcpy(efw->card->longname, efw->card->driver);
-	strcpy(efw->card->mixername, efw->card->driver);
+	err = get_hardware_info(efw);
+	if (err < 0)
+		goto error;
 
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;
+
 	dev_set_drvdata(&unit->device, efw);
 end:
 	mutex_unlock(&devices_mutex);
@@ -127,7 +171,8 @@ efw_probe(struct fw_unit *unit,
 
 static void efw_update(struct fw_unit *unit)
 {
-	return;
+	struct snd_efw *efw = dev_get_drvdata(&unit->device);
+	snd_efw_transaction_bus_reset(efw->unit);
 }
 
 static void efw_remove(struct fw_unit *unit)
@@ -169,11 +214,23 @@ static struct fw_driver efw_driver = {
 
 static int __init snd_efw_init(void)
 {
-	return driver_register(&efw_driver.driver);
+	int err;
+
+	err = snd_efw_transaction_register();
+	if (err < 0)
+		goto end;
+
+	err = driver_register(&efw_driver.driver);
+	if (err < 0)
+		snd_efw_transaction_unregister();
+
+end:
+	return err;
 }
 
 static void __exit snd_efw_exit(void)
 {
+	snd_efw_transaction_unregister();
 	driver_unregister(&efw_driver.driver);
 	mutex_destroy(&devices_mutex);
 }

commit b5b04336015e76eb52ffc188e16c9cee01821c7c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:00 2014 +0900

    ALSA: fireworks: Add skelton for Fireworks based devices
    
    This commit adds a new driver for devices based on Fireworks. This driver
    just creates/removes card instance according to callbacks.
    
    Fireworks is a board module which Echo Audio produced. This module
    consists of three chipsets:
     - Communication chipset for IEEE1394 PHY/Link and IEC 61883-1/6
     - DSP or/and FPGA for signal processing
     - Flash Memory to store firmwares
    
    Current supported devices:
     - Mackie Onyx 400F/1200F
     - Echo AudioFire12/8(until 2009 July)
     - Echo AudioFire2/4/Pre8/8(since 2009 July)
     - Echo Fireworks 8/HDMI
     - Gibson Robot Interface pack/GoldTop
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireworks/fireworks.c b/sound/firewire/fireworks/fireworks.c
new file mode 100644
index 000000000000..ad719a1d5353
--- /dev/null
+++ b/sound/firewire/fireworks/fireworks.c
@@ -0,0 +1,182 @@
+/*
+ * fireworks.c - a part of driver for Fireworks based devices
+ *
+ * Copyright (c) 2009-2010 Clemens Ladisch
+ * Copyright (c) 2013-2014 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+/*
+ * Fireworks is a board module which Echo Audio produced. This module consists
+ * of three chipsets:
+ *  - Communication chipset for IEEE1394 PHY/Link and IEC 61883-1/6
+ *  - DSP or/and FPGA for signal processing
+ *  - Flash Memory to store firmwares
+ */
+
+#include "fireworks.h"
+
+MODULE_DESCRIPTION("Echo Fireworks driver");
+MODULE_AUTHOR("Takashi Sakamoto <o-takashi@sakamocchi.jp>");
+MODULE_LICENSE("GPL v2");
+
+static int index[SNDRV_CARDS]	= SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS]	= SNDRV_DEFAULT_STR;
+static bool enable[SNDRV_CARDS]	= SNDRV_DEFAULT_ENABLE_PNP;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "card index");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "enable Fireworks sound card");
+
+static DEFINE_MUTEX(devices_mutex);
+static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
+
+#define VENDOR_LOUD			0x000ff2
+#define  MODEL_MACKIE_400F		0x00400f
+#define  MODEL_MACKIE_1200F		0x01200f
+
+#define VENDOR_ECHO			0x001486
+#define  MODEL_ECHO_AUDIOFIRE_12	0x00af12
+#define  MODEL_ECHO_AUDIOFIRE_12HD	0x0af12d
+#define  MODEL_ECHO_AUDIOFIRE_12_APPLE	0x0af12a
+/* This is applied for AudioFire8 (until 2009 July) */
+#define  MODEL_ECHO_AUDIOFIRE_8		0x000af8
+#define  MODEL_ECHO_AUDIOFIRE_2		0x000af2
+#define  MODEL_ECHO_AUDIOFIRE_4		0x000af4
+/* AudioFire9 is applied for AudioFire8(since 2009 July) and AudioFirePre8 */
+#define  MODEL_ECHO_AUDIOFIRE_9		0x000af9
+/* unknown as product */
+#define  MODEL_ECHO_FIREWORKS_8		0x0000f8
+#define  MODEL_ECHO_FIREWORKS_HDMI	0x00afd1
+
+#define VENDOR_GIBSON			0x00075b
+/* for Robot Interface Pack of Dark Fire, Dusk Tiger, Les Paul Standard 2010 */
+#define  MODEL_GIBSON_RIP		0x00afb2
+/* unknown as product */
+#define  MODEL_GIBSON_GOLDTOP		0x00afb9
+
+static void
+efw_card_free(struct snd_card *card)
+{
+	struct snd_efw *efw = card->private_data;
+
+	if (efw->card_index >= 0) {
+		mutex_lock(&devices_mutex);
+		clear_bit(efw->card_index, devices_used);
+		mutex_unlock(&devices_mutex);
+	}
+
+	mutex_destroy(&efw->mutex);
+}
+
+static int
+efw_probe(struct fw_unit *unit,
+	  const struct ieee1394_device_id *entry)
+{
+	struct snd_card *card;
+	struct snd_efw *efw;
+	int card_index, err;
+
+	mutex_lock(&devices_mutex);
+
+	/* check registered cards */
+	for (card_index = 0; card_index < SNDRV_CARDS; ++card_index) {
+		if (!test_bit(card_index, devices_used) && enable[card_index])
+			break;
+	}
+	if (card_index >= SNDRV_CARDS) {
+		err = -ENOENT;
+		goto end;
+	}
+
+	err = snd_card_new(&unit->device, index[card_index], id[card_index],
+			   THIS_MODULE, sizeof(struct snd_efw), &card);
+	if (err < 0)
+		goto end;
+	efw = card->private_data;
+	efw->card_index = card_index;
+	set_bit(card_index, devices_used);
+	card->private_free = efw_card_free;
+
+	efw->card = card;
+	efw->unit = unit;
+	mutex_init(&efw->mutex);
+	spin_lock_init(&efw->lock);
+
+	strcpy(efw->card->driver, "Fireworks");
+	strcpy(efw->card->shortname, efw->card->driver);
+	strcpy(efw->card->longname, efw->card->driver);
+	strcpy(efw->card->mixername, efw->card->driver);
+
+	err = snd_card_register(card);
+	if (err < 0)
+		goto error;
+	dev_set_drvdata(&unit->device, efw);
+end:
+	mutex_unlock(&devices_mutex);
+	return err;
+error:
+	mutex_unlock(&devices_mutex);
+	snd_card_free(card);
+	return err;
+}
+
+static void efw_update(struct fw_unit *unit)
+{
+	return;
+}
+
+static void efw_remove(struct fw_unit *unit)
+{
+	struct snd_efw *efw = dev_get_drvdata(&unit->device);
+	snd_card_disconnect(efw->card);
+	snd_card_free_when_closed(efw->card);
+}
+
+static const struct ieee1394_device_id efw_id_table[] = {
+	SND_EFW_DEV_ENTRY(VENDOR_LOUD, MODEL_MACKIE_400F),
+	SND_EFW_DEV_ENTRY(VENDOR_LOUD, MODEL_MACKIE_1200F),
+	SND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_8),
+	SND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_12),
+	SND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_12HD),
+	SND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_12_APPLE),
+	SND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_2),
+	SND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_4),
+	SND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_AUDIOFIRE_9),
+	SND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_FIREWORKS_8),
+	SND_EFW_DEV_ENTRY(VENDOR_ECHO, MODEL_ECHO_FIREWORKS_HDMI),
+	SND_EFW_DEV_ENTRY(VENDOR_GIBSON, MODEL_GIBSON_RIP),
+	SND_EFW_DEV_ENTRY(VENDOR_GIBSON, MODEL_GIBSON_GOLDTOP),
+	{}
+};
+MODULE_DEVICE_TABLE(ieee1394, efw_id_table);
+
+static struct fw_driver efw_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "snd-fireworks",
+		.bus = &fw_bus_type,
+	},
+	.probe    = efw_probe,
+	.update   = efw_update,
+	.remove   = efw_remove,
+	.id_table = efw_id_table,
+};
+
+static int __init snd_efw_init(void)
+{
+	return driver_register(&efw_driver.driver);
+}
+
+static void __exit snd_efw_exit(void)
+{
+	driver_unregister(&efw_driver.driver);
+	mutex_destroy(&devices_mutex);
+}
+
+module_init(snd_efw_init);
+module_exit(snd_efw_exit);
