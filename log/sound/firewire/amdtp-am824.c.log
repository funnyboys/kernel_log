commit 8304cf77c92038cd1c50c27b69d30be695cc8003
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 8 13:36:26 2020 +0900

    ALSA: firewire-lib: fix invalid assignment to union data for directional parameter
    
    Although the value of FDF is used just for outgoing stream, the assignment
    to union member is done for both directions of stream. At present this
    causes no issue because the value of same position is reassigned later for
    opposite stream. However, it's better to add if statement.
    
    Fixes: d3d10a4a1b19 ("ALSA: firewire-lib: use union for directional parameters")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200508043635.349339-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 67d735e9a6a4..fea92e148790 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -82,7 +82,8 @@ int amdtp_am824_set_parameters(struct amdtp_stream *s, unsigned int rate,
 	if (err < 0)
 		return err;
 
-	s->ctx_data.rx.fdf = AMDTP_FDF_AM824 | s->sfc;
+	if (s->direction == AMDTP_OUT_STREAM)
+		s->ctx_data.rx.fdf = AMDTP_FDF_AM824 | s->sfc;
 
 	p->pcm_channels = pcm_channels;
 	p->midi_ports = midi_ports;

commit 9a738ad1b1a64ef6d8271d8d42d715b75db6eb0d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:37:09 2019 +0900

    ALSA: firewire-lib: process payload of isoc context according to packet descriptors
    
    This commit changes each of data block processing layer so that it
    receives list of packet descriptor.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 5d2952a1a9b2..67d735e9a6a4 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -345,45 +345,59 @@ static void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,
 	}
 }
 
-static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
-					   const struct pkt_desc *desc,
-					   struct snd_pcm_substream *pcm)
+static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
+					    const struct pkt_desc *descs,
+					    unsigned int packets,
+					    struct snd_pcm_substream *pcm)
 {
 	struct amdtp_am824 *p = s->protocol;
 	unsigned int pcm_frames = 0;
+	int i;
 
-	if (pcm) {
-		write_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks,
-			      pcm_frames);
-		pcm_frames = desc->data_blocks * p->frame_multiplier;
-	} else {
-		write_pcm_silence(s, desc->ctx_payload, desc->data_blocks);
-	}
+	for (i = 0; i < packets; ++i) {
+		const struct pkt_desc *desc = descs + i;
+		__be32 *buf = desc->ctx_payload;
+		unsigned int data_blocks = desc->data_blocks;
 
-	if (p->midi_ports) {
-		write_midi_messages(s, desc->ctx_payload, desc->data_blocks,
-				    desc->data_block_counter);
+		if (pcm) {
+			write_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+			pcm_frames += data_blocks * p->frame_multiplier;
+		} else {
+			write_pcm_silence(s, buf, data_blocks);
+		}
+
+		if (p->midi_ports) {
+			write_midi_messages(s, buf, data_blocks,
+					    desc->data_block_counter);
+		}
 	}
 
 	return pcm_frames;
 }
 
-static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
-					   const struct pkt_desc *desc,
-					   struct snd_pcm_substream *pcm)
+static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
+					    const struct pkt_desc *descs,
+					    unsigned int packets,
+					    struct snd_pcm_substream *pcm)
 {
 	struct amdtp_am824 *p = s->protocol;
 	unsigned int pcm_frames = 0;
+	int i;
 
-	if (pcm) {
-		read_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks,
-			     pcm_frames);
-		pcm_frames = desc->data_blocks * p->frame_multiplier;
-	}
+	for (i = 0; i < packets; ++i) {
+		const struct pkt_desc *desc = descs + i;
+		__be32 *buf = desc->ctx_payload;
+		unsigned int data_blocks = desc->data_blocks;
+
+		if (pcm) {
+			read_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+			pcm_frames += data_blocks * p->frame_multiplier;
+		}
 
-	if (p->midi_ports) {
-		read_midi_messages(s, desc->ctx_payload, desc->data_blocks,
-				   desc->data_block_counter);
+		if (p->midi_ports) {
+			read_midi_messages(s, buf, data_blocks,
+					   desc->data_block_counter);
+		}
 	}
 
 	return pcm_frames;
@@ -400,15 +414,14 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 int amdtp_am824_init(struct amdtp_stream *s, struct fw_unit *unit,
 		     enum amdtp_stream_direction dir, enum cip_flags flags)
 {
-	amdtp_stream_process_data_blocks_t process_data_blocks;
+	amdtp_stream_process_ctx_payloads_t process_ctx_payloads;
 
 	if (dir == AMDTP_IN_STREAM)
-		process_data_blocks = process_tx_data_blocks;
+		process_ctx_payloads = process_ir_ctx_payloads;
 	else
-		process_data_blocks = process_rx_data_blocks;
+		process_ctx_payloads = process_it_ctx_payloads;
 
 	return amdtp_stream_init(s, unit, dir, flags, CIP_FMT_AM,
-				 process_data_blocks,
-				 sizeof(struct amdtp_am824));
+			process_ctx_payloads, sizeof(struct amdtp_am824));
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_init);

commit 9fc90644cae9c0abfcce0576ed0a14cca67f69b9
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:37:04 2019 +0900

    ALSA: firewire-lib: code refactoring for AM824 data block processing layer
    
    This is code refactoring for AM824 data block processing layer so that
    it can receive list of packet descriptor.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index ff089ffa3374..5d2952a1a9b2 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -146,19 +146,24 @@ void amdtp_am824_set_midi_position(struct amdtp_stream *s,
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_set_midi_position);
 
-static void write_pcm_s32(struct amdtp_stream *s,
-			  struct snd_pcm_substream *pcm,
-			  __be32 *buffer, unsigned int frames)
+static void write_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,
+			  __be32 *buffer, unsigned int frames,
+			  unsigned int pcm_frames)
 {
 	struct amdtp_am824 *p = s->protocol;
+	unsigned int channels = p->pcm_channels;
 	struct snd_pcm_runtime *runtime = pcm->runtime;
-	unsigned int channels, remaining_frames, i, c;
+	unsigned int pcm_buffer_pointer;
+	int remaining_frames;
 	const u32 *src;
+	int i, c;
+
+	pcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;
+	pcm_buffer_pointer %= runtime->buffer_size;
 
-	channels = p->pcm_channels;
 	src = (void *)runtime->dma_area +
-			frames_to_bytes(runtime, s->pcm_buffer_pointer);
-	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
+				frames_to_bytes(runtime, pcm_buffer_pointer);
+	remaining_frames = runtime->buffer_size - pcm_buffer_pointer;
 
 	for (i = 0; i < frames; ++i) {
 		for (c = 0; c < channels; ++c) {
@@ -172,19 +177,24 @@ static void write_pcm_s32(struct amdtp_stream *s,
 	}
 }
 
-static void read_pcm_s32(struct amdtp_stream *s,
-			 struct snd_pcm_substream *pcm,
-			 __be32 *buffer, unsigned int frames)
+static void read_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,
+			 __be32 *buffer, unsigned int frames,
+			 unsigned int pcm_frames)
 {
 	struct amdtp_am824 *p = s->protocol;
+	unsigned int channels = p->pcm_channels;
 	struct snd_pcm_runtime *runtime = pcm->runtime;
-	unsigned int channels, remaining_frames, i, c;
+	unsigned int pcm_buffer_pointer;
+	int remaining_frames;
 	u32 *dst;
+	int i, c;
+
+	pcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;
+	pcm_buffer_pointer %= runtime->buffer_size;
 
-	channels = p->pcm_channels;
 	dst  = (void *)runtime->dma_area +
-			frames_to_bytes(runtime, s->pcm_buffer_pointer);
-	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
+				frames_to_bytes(runtime, pcm_buffer_pointer);
+	remaining_frames = runtime->buffer_size - pcm_buffer_pointer;
 
 	for (i = 0; i < frames; ++i) {
 		for (c = 0; c < channels; ++c) {
@@ -340,14 +350,14 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 					   struct snd_pcm_substream *pcm)
 {
 	struct amdtp_am824 *p = s->protocol;
-	unsigned int pcm_frames;
+	unsigned int pcm_frames = 0;
 
 	if (pcm) {
-		write_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks);
+		write_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks,
+			      pcm_frames);
 		pcm_frames = desc->data_blocks * p->frame_multiplier;
 	} else {
 		write_pcm_silence(s, desc->ctx_payload, desc->data_blocks);
-		pcm_frames = 0;
 	}
 
 	if (p->midi_ports) {
@@ -363,13 +373,12 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 					   struct snd_pcm_substream *pcm)
 {
 	struct amdtp_am824 *p = s->protocol;
-	unsigned int pcm_frames;
+	unsigned int pcm_frames = 0;
 
 	if (pcm) {
-		read_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks);
+		read_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks,
+			     pcm_frames);
 		pcm_frames = desc->data_blocks * p->frame_multiplier;
-	} else {
-		pcm_frames = 0;
 	}
 
 	if (p->midi_ports) {

commit d2c104a3426be9991b35c65f0f260a107c4b2942
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:37:03 2019 +0900

    ALSA: firewire-lib: pass packet descriptor to data block processing layer
    
    This commit changes signature of callback function to call data block
    processing layer with packet descriptor. At present, the layer is called
    per packet.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 21068b23d528..ff089ffa3374 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -336,44 +336,46 @@ static void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,
 }
 
 static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
-				__be32 *buffer, unsigned int data_blocks,
-				unsigned int data_block_counter)
+					   const struct pkt_desc *desc,
+					   struct snd_pcm_substream *pcm)
 {
 	struct amdtp_am824 *p = s->protocol;
-	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
 	unsigned int pcm_frames;
 
 	if (pcm) {
-		write_pcm_s32(s, pcm, buffer, data_blocks);
-		pcm_frames = data_blocks * p->frame_multiplier;
+		write_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks);
+		pcm_frames = desc->data_blocks * p->frame_multiplier;
 	} else {
-		write_pcm_silence(s, buffer, data_blocks);
+		write_pcm_silence(s, desc->ctx_payload, desc->data_blocks);
 		pcm_frames = 0;
 	}
 
-	if (p->midi_ports)
-		write_midi_messages(s, buffer, data_blocks, data_block_counter);
+	if (p->midi_ports) {
+		write_midi_messages(s, desc->ctx_payload, desc->data_blocks,
+				    desc->data_block_counter);
+	}
 
 	return pcm_frames;
 }
 
 static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
-				__be32 *buffer, unsigned int data_blocks,
-				unsigned int data_block_counter)
+					   const struct pkt_desc *desc,
+					   struct snd_pcm_substream *pcm)
 {
 	struct amdtp_am824 *p = s->protocol;
-	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
 	unsigned int pcm_frames;
 
 	if (pcm) {
-		read_pcm_s32(s, pcm, buffer, data_blocks);
-		pcm_frames = data_blocks * p->frame_multiplier;
+		read_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks);
+		pcm_frames = desc->data_blocks * p->frame_multiplier;
 	} else {
 		pcm_frames = 0;
 	}
 
-	if (p->midi_ports)
-		read_midi_messages(s, buffer, data_blocks, data_block_counter);
+	if (p->midi_ports) {
+		read_midi_messages(s, desc->ctx_payload, desc->data_blocks,
+				   desc->data_block_counter);
+	}
 
 	return pcm_frames;
 }

commit 600c8018df605a91575aef6811cf927e2d933d30
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:57 2019 +0900

    ALSA: firewire-lib: pass no syt information to data block processing layer
    
    In a previous commit, the variable passed from packet streaming layer
    for syt variable is useless. This commit obsoletes it.
    
    In my future work, the syt information is passed to data block processing
    layer by another way.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 03a7e0533131..21068b23d528 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -336,8 +336,8 @@ static void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,
 }
 
 static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
-			__be32 *buffer, unsigned int data_blocks,
-			unsigned int data_block_counter, unsigned int *syt)
+				__be32 *buffer, unsigned int data_blocks,
+				unsigned int data_block_counter)
 {
 	struct amdtp_am824 *p = s->protocol;
 	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
@@ -358,8 +358,8 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 }
 
 static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
-			__be32 *buffer, unsigned int data_blocks,
-			unsigned int data_block_counter, unsigned int *syt)
+				__be32 *buffer, unsigned int data_blocks,
+				unsigned int data_block_counter)
 {
 	struct amdtp_am824 *p = s->protocol;
 	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);

commit ab75481202d2925a017e4cb5407b0bb49c356de8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:53 2019 +0900

    ALSA: firewire-lib: pass data block counter to data block processing layer
    
    This is a preparation for future commit that 'struct
    amdtp_stream.data_block_count' does not represent the value of
    data block count for current data block.
    
    However, data block count is required for calculation of sequence index
    in sequence-multiplied data channel. Some of data block processing layer
    require it; e.g. for AM824 data block.
    
    This commit passes data block count to the processing layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 99c567ded7a3..03a7e0533131 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -284,7 +284,7 @@ static void midi_rate_use_one_byte(struct amdtp_stream *s, unsigned int port)
 }
 
 static void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,
-				unsigned int frames)
+			unsigned int frames, unsigned int data_block_counter)
 {
 	struct amdtp_am824 *p = s->protocol;
 	unsigned int f, port;
@@ -293,7 +293,7 @@ static void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,
 	for (f = 0; f < frames; f++) {
 		b = (u8 *)&buffer[p->midi_position];
 
-		port = (s->data_block_counter + f) % 8;
+		port = (data_block_counter + f) % 8;
 		if (f < MAX_MIDI_RX_BLOCKS &&
 		    midi_ratelimit_per_packet(s, port) &&
 		    p->midi[port] != NULL &&
@@ -311,8 +311,8 @@ static void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,
 	}
 }
 
-static void read_midi_messages(struct amdtp_stream *s,
-			       __be32 *buffer, unsigned int frames)
+static void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,
+			unsigned int frames, unsigned int data_block_counter)
 {
 	struct amdtp_am824 *p = s->protocol;
 	int len;
@@ -323,7 +323,7 @@ static void read_midi_messages(struct amdtp_stream *s,
 		unsigned int port = f;
 
 		if (!(s->flags & CIP_UNALIGHED_DBC))
-			port += s->data_block_counter;
+			port += data_block_counter;
 		port %= 8;
 		b = (u8 *)&buffer[p->midi_position];
 
@@ -335,8 +335,9 @@ static void read_midi_messages(struct amdtp_stream *s,
 	}
 }
 
-static unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
-					   unsigned int data_blocks, unsigned int *syt)
+static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
+			__be32 *buffer, unsigned int data_blocks,
+			unsigned int data_block_counter, unsigned int *syt)
 {
 	struct amdtp_am824 *p = s->protocol;
 	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
@@ -351,13 +352,14 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffe
 	}
 
 	if (p->midi_ports)
-		write_midi_messages(s, buffer, data_blocks);
+		write_midi_messages(s, buffer, data_blocks, data_block_counter);
 
 	return pcm_frames;
 }
 
-static unsigned int process_tx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
-					   unsigned int data_blocks, unsigned int *syt)
+static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
+			__be32 *buffer, unsigned int data_blocks,
+			unsigned int data_block_counter, unsigned int *syt)
 {
 	struct amdtp_am824 *p = s->protocol;
 	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
@@ -371,7 +373,7 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s, __be32 *buffe
 	}
 
 	if (p->midi_ports)
-		read_midi_messages(s, buffer, data_blocks);
+		read_midi_messages(s, buffer, data_blocks, data_block_counter);
 
 	return pcm_frames;
 }

commit 588f2e2caf6795ca29d50a45ea1e1438274e75e0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:51 2019 +0900

    ALSA: firewire-lib: obsolete ctx_data.tx.first_dbc with CIP_UNALIGHED_DBC flag
    
    Recent firmware for Fireworks board module have a quirk to start
    transmission of CIP with non-zero value for its data block counter.
    In current implementation of ALSA firewire stack, the quirk is handled
    by 'struct amdtp_stream.ctx_data.tx.first_dbc' with value 0x02. However,
    the value comes from reverse engineering. It's better to handle this
    quirk without the explicit value.
    
    In a process to parse CIP header, the quirk of data block counter
    affects decision of sequence index in sequence-multiplexed data channel;
    i.e. MIDI conformant data channel. In Fireworks, the index is decided
    by the number of data blocks from top of the same CIP, thus the value
    of data block counter is useless.
    
    This commit adds CIP_UNALIGHED_DBC flag and obsoletes the explicit
    value for this quirk.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index fd5d6b8ac557..99c567ded7a3 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -315,12 +315,16 @@ static void read_midi_messages(struct amdtp_stream *s,
 			       __be32 *buffer, unsigned int frames)
 {
 	struct amdtp_am824 *p = s->protocol;
-	unsigned int f, port;
 	int len;
 	u8 *b;
+	int f;
 
 	for (f = 0; f < frames; f++) {
-		port = (8 - s->ctx_data.tx.first_dbc + s->data_block_counter + f) % 8;
+		unsigned int port = f;
+
+		if (!(s->flags & CIP_UNALIGHED_DBC))
+			port += s->data_block_counter;
+		port %= 8;
 		b = (u8 *)&buffer[p->midi_position];
 
 		len = b[0] - 0x80;

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit b5c21c84705dbd96a0fff930d33022a17910b4f4
Merge: 7c2b3629d09d 7fbd1753b64e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 1 17:01:00 2019 +0200

    Merge branch 'for-linus' into for-next
    
    This back-merge is necessary for adjusting the latest FireWire fix
    with the recent refactoring in 5.3 development branch.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 7fbd1753b64eafe21cf842348a40a691d0dee440
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 1 23:43:53 2019 +0900

    ALSA: firewire-lib/fireworks: fix miss detection of received MIDI messages
    
    In IEC 61883-6, 8 MIDI data streams are multiplexed into single
    MIDI conformant data channel. The index of stream is calculated by
    modulo 8 of the value of data block counter.
    
    In fireworks, the value of data block counter in CIP header has a quirk
    with firmware version v5.0.0, v5.7.3 and v5.8.0. This brings ALSA
    IEC 61883-1/6 packet streaming engine to miss detection of MIDI
    messages.
    
    This commit fixes the miss detection to modify the value of data block
    counter for the modulo calculation.
    
    For maintainers, this bug exists since a commit 18f5ed365d3f ("ALSA:
    fireworks/firewire-lib: add support for recent firmware quirk") in Linux
    kernel v4.2. There're many changes since the commit.  This fix can be
    backported to Linux kernel v4.4 or later. I tagged a base commit to the
    backport for your convenience.
    
    Besides, my work for Linux kernel v5.3 brings heavy code refactoring and
    some structure members are renamed in 'sound/firewire/amdtp-stream.h'.
    The content of this patch brings conflict when merging -rc tree with
    this patch and the latest tree. I request maintainers to solve the
    conflict to replace 'tx_first_dbc' with 'ctx_data.tx.first_dbc'.
    
    Fixes: df075feefbd3 ("ALSA: firewire-lib: complete AM824 data block processing layer")
    Cc: <stable@vger.kernel.org> # v4.4+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 4210e5c6262e..d09da9dbf235 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -321,7 +321,7 @@ static void read_midi_messages(struct amdtp_stream *s,
 	u8 *b;
 
 	for (f = 0; f < frames; f++) {
-		port = (s->data_block_counter + f) % 8;
+		port = (8 - s->tx_first_dbc + s->data_block_counter + f) % 8;
 		b = (u8 *)&buffer[p->midi_position];
 
 		len = b[0] - 0x80;

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 4210e5c6262e..cc6eb30f03a2 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -1,10 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * AM824 format in Audio and Music Data Transmission Protocol (IEC 61883-6)
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  * Copyright (c) 2015 Takashi Sakamoto <o-takashi@sakamocchi.jp>
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include <linux/slab.h>

commit d3d10a4a1b1950c2d20714c2511b5f58c99bab81
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 21 23:57:34 2019 +0900

    ALSA: firewire-lib: use union for directional parameters
    
    Some parameters of struct amdtp_stream is dependent on direction.
    
    This commit uses union for such parameters to distinguish from
    common parameters.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 4210e5c6262e..7019a2143581 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -83,7 +83,7 @@ int amdtp_am824_set_parameters(struct amdtp_stream *s, unsigned int rate,
 	if (err < 0)
 		return err;
 
-	s->fdf = AMDTP_FDF_AM824 | s->sfc;
+	s->ctx_data.rx.fdf = AMDTP_FDF_AM824 | s->sfc;
 
 	p->pcm_channels = pcm_channels;
 	p->midi_ports = midi_ports;

commit 6aa7de059173a986114ac43b8f50b297a86f09a8
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Oct 23 14:07:29 2017 -0700

    locking/atomics: COCCINELLE/treewide: Convert trivial ACCESS_ONCE() patterns to READ_ONCE()/WRITE_ONCE()
    
    Please do not apply this to mainline directly, instead please re-run the
    coccinelle script shown below and apply its output.
    
    For several reasons, it is desirable to use {READ,WRITE}_ONCE() in
    preference to ACCESS_ONCE(), and new code is expected to use one of the
    former. So far, there's been no reason to change most existing uses of
    ACCESS_ONCE(), as these aren't harmful, and changing them results in
    churn.
    
    However, for some features, the read/write distinction is critical to
    correct operation. To distinguish these cases, separate read/write
    accessors must be used. This patch migrates (most) remaining
    ACCESS_ONCE() instances to {READ,WRITE}_ONCE(), using the following
    coccinelle script:
    
    ----
    // Convert trivial ACCESS_ONCE() uses to equivalent READ_ONCE() and
    // WRITE_ONCE()
    
    // $ make coccicheck COCCI=/home/mark/once.cocci SPFLAGS="--include-headers" MODE=patch
    
    virtual patch
    
    @ depends on patch @
    expression E1, E2;
    @@
    
    - ACCESS_ONCE(E1) = E2
    + WRITE_ONCE(E1, E2)
    
    @ depends on patch @
    expression E;
    @@
    
    - ACCESS_ONCE(E)
    + READ_ONCE(E)
    ----
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: davem@davemloft.net
    Cc: linux-arch@vger.kernel.org
    Cc: mpe@ellerman.id.au
    Cc: shuah@kernel.org
    Cc: snitzer@redhat.com
    Cc: thor.thayer@linux.intel.com
    Cc: tj@kernel.org
    Cc: viro@zeniv.linux.org.uk
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1508792849-3115-19-git-send-email-paulmck@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 23ccddb20de1..4210e5c6262e 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -247,7 +247,7 @@ void amdtp_am824_midi_trigger(struct amdtp_stream *s, unsigned int port,
 	struct amdtp_am824 *p = s->protocol;
 
 	if (port < p->midi_ports)
-		ACCESS_ONCE(p->midi[port]) = midi;
+		WRITE_ONCE(p->midi[port], midi);
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_midi_trigger);
 
@@ -336,7 +336,7 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffe
 					   unsigned int data_blocks, unsigned int *syt)
 {
 	struct amdtp_am824 *p = s->protocol;
-	struct snd_pcm_substream *pcm = ACCESS_ONCE(s->pcm);
+	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
 	unsigned int pcm_frames;
 
 	if (pcm) {
@@ -357,7 +357,7 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s, __be32 *buffe
 					   unsigned int data_blocks, unsigned int *syt)
 {
 	struct amdtp_am824 *p = s->protocol;
-	struct snd_pcm_substream *pcm = ACCESS_ONCE(s->pcm);
+	struct snd_pcm_substream *pcm = READ_ONCE(s->pcm);
 	unsigned int pcm_frames;
 
 	if (pcm) {

commit a02cb8f8def634159b60c3a4d6ba16e471b46e0c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon May 22 22:22:21 2017 +0900

    ALSA: firewire: remove support for 16 bit PCM samples in playback substream
    
    In IEC 61883-6, AM824 is described as format of data block. In this
    format, one data block consists of several data channels, which is aligned
    to 32 bit. One data channel has 8 bit label field and 24 bit data field.
    PCM frames are transferred in Multi Bit Linear Audio (MBLA) data channel.
    This channel can include 16/20/24 bit PCM sample.
    
    As long as I know, models which support IEC 61883-1/6 doesn't allow to
    switch bit length of PCM sample in MBLA data channel. They always
    transmit/receive PCM frames of 24 bit length. This can be seen for the
    other models which support protocols similar to IEC 61883-1/6.
    
    On the other hand, current drivers for these protocols supports 16 bit
    length PCM sample in playback substream. In this case, PCM sample is put
    into the MBLA data channel with 8 bit padding in LSB side. Although 16
    bit PCM sample is major because it's in CD format, this doesn't represent
    device capability as is.
    
    This commit removes support for 16 bit PCM samples in playback substream.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index bebddc60fde8..23ccddb20de1 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -38,10 +38,6 @@ struct amdtp_am824 {
 	u8 pcm_positions[AM824_MAX_CHANNELS_FOR_PCM];
 	u8 midi_position;
 
-	void (*transfer_samples)(struct amdtp_stream *s,
-				 struct snd_pcm_substream *pcm,
-				 __be32 *buffer, unsigned int frames);
-
 	unsigned int frame_multiplier;
 };
 
@@ -177,32 +173,6 @@ static void write_pcm_s32(struct amdtp_stream *s,
 	}
 }
 
-static void write_pcm_s16(struct amdtp_stream *s,
-			  struct snd_pcm_substream *pcm,
-			  __be32 *buffer, unsigned int frames)
-{
-	struct amdtp_am824 *p = s->protocol;
-	struct snd_pcm_runtime *runtime = pcm->runtime;
-	unsigned int channels, remaining_frames, i, c;
-	const u16 *src;
-
-	channels = p->pcm_channels;
-	src = (void *)runtime->dma_area +
-			frames_to_bytes(runtime, s->pcm_buffer_pointer);
-	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
-
-	for (i = 0; i < frames; ++i) {
-		for (c = 0; c < channels; ++c) {
-			buffer[p->pcm_positions[c]] =
-					cpu_to_be32((*src << 8) | 0x42000000);
-			src++;
-		}
-		buffer += s->data_block_quadlets;
-		if (--remaining_frames == 0)
-			src = (void *)runtime->dma_area;
-	}
-}
-
 static void read_pcm_s32(struct amdtp_stream *s,
 			 struct snd_pcm_substream *pcm,
 			 __be32 *buffer, unsigned int frames)
@@ -241,43 +211,6 @@ static void write_pcm_silence(struct amdtp_stream *s,
 	}
 }
 
-/**
- * amdtp_am824_set_pcm_format - set the PCM format
- * @s: the AMDTP stream to configure
- * @format: the format of the ALSA PCM device
- *
- * The sample format must be set after the other parameters (rate/PCM channels/
- * MIDI) and before the stream is started, and must not be changed while the
- * stream is running.
- */
-void amdtp_am824_set_pcm_format(struct amdtp_stream *s, snd_pcm_format_t format)
-{
-	struct amdtp_am824 *p = s->protocol;
-
-	if (WARN_ON(amdtp_stream_pcm_running(s)))
-		return;
-
-	switch (format) {
-	default:
-		WARN_ON(1);
-		/* fall through */
-	case SNDRV_PCM_FORMAT_S16:
-		if (s->direction == AMDTP_OUT_STREAM) {
-			p->transfer_samples = write_pcm_s16;
-			break;
-		}
-		WARN_ON(1);
-		/* fall through */
-	case SNDRV_PCM_FORMAT_S32:
-		if (s->direction == AMDTP_OUT_STREAM)
-			p->transfer_samples = write_pcm_s32;
-		else
-			p->transfer_samples = read_pcm_s32;
-		break;
-	}
-}
-EXPORT_SYMBOL_GPL(amdtp_am824_set_pcm_format);
-
 /**
  * amdtp_am824_add_pcm_hw_constraints - add hw constraints for PCM substream
  * @s:		the AMDTP stream for AM824 data block, must be initialized.
@@ -407,7 +340,7 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffe
 	unsigned int pcm_frames;
 
 	if (pcm) {
-		p->transfer_samples(s, pcm, buffer, data_blocks);
+		write_pcm_s32(s, pcm, buffer, data_blocks);
 		pcm_frames = data_blocks * p->frame_multiplier;
 	} else {
 		write_pcm_silence(s, buffer, data_blocks);
@@ -428,7 +361,7 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s, __be32 *buffe
 	unsigned int pcm_frames;
 
 	if (pcm) {
-		p->transfer_samples(s, pcm, buffer, data_blocks);
+		read_pcm_s32(s, pcm, buffer, data_blocks);
 		pcm_frames = data_blocks * p->frame_multiplier;
 	} else {
 		pcm_frames = 0;

commit 02e6ef9fba3ed85e31b13cbd6bb2185412b44c9e
Author: kbuild test robot <fengguang.wu@intel.com>
Date:   Tue Sep 29 22:46:10 2015 +0800

    ALSA: firewire-lib: process_rx_data_blocks() can be static
    
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index fe4b83f65831..bebddc60fde8 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -399,8 +399,8 @@ static void read_midi_messages(struct amdtp_stream *s,
 	}
 }
 
-unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
-				    unsigned int data_blocks, unsigned int *syt)
+static unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
+					   unsigned int data_blocks, unsigned int *syt)
 {
 	struct amdtp_am824 *p = s->protocol;
 	struct snd_pcm_substream *pcm = ACCESS_ONCE(s->pcm);
@@ -420,8 +420,8 @@ unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
 	return pcm_frames;
 }
 
-unsigned int process_tx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
-				    unsigned int data_blocks, unsigned int *syt)
+static unsigned int process_tx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
+					   unsigned int data_blocks, unsigned int *syt)
 {
 	struct amdtp_am824 *p = s->protocol;
 	struct snd_pcm_substream *pcm = ACCESS_ONCE(s->pcm);

commit df075feefbd347f13fba5198294cda619532c237
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:22:02 2015 +0900

    ALSA: firewire-lib: complete AM824 data block processing layer
    
    This commit moves the codes related to data block processing from packet
    streaming layer to AM824 layer.
    
    Each driver initializes amdtp stream structure for AM824 data block by
    calling amdtp_am824_init(). Then, a memory block is allocated for AM824
    specific structure. This memory block is released by calling
    amdtp_stream_destroy().
    
    When setting streaming parameters, it calls amdtp_am824_set_parameters().
    When starting packet streaming, it calls amdtp_stream_start(). When
    stopping packet streaming, it calls amdtp_stream_stop().
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 540a101661e2..fe4b83f65831 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -1,11 +1,14 @@
 /*
  * AM824 format in Audio and Music Data Transmission Protocol (IEC 61883-6)
  *
+ * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  * Copyright (c) 2015 Takashi Sakamoto <o-takashi@sakamocchi.jp>
  *
  * Licensed under the terms of the GNU General Public License, version 2.
  */
 
+#include <linux/slab.h>
+
 #include "amdtp-am824.h"
 
 #define CIP_FMT_AM		0x10
@@ -13,6 +16,35 @@
 /* "Clock-based rate control mode" is just supported. */
 #define AMDTP_FDF_AM824		0x00
 
+/*
+ * Nominally 3125 bytes/second, but the MIDI port's clock might be
+ * 1% too slow, and the bus clock 100 ppm too fast.
+ */
+#define MIDI_BYTES_PER_SECOND	3093
+
+/*
+ * Several devices look only at the first eight data blocks.
+ * In any case, this is more than enough for the MIDI data rate.
+ */
+#define MAX_MIDI_RX_BLOCKS	8
+
+struct amdtp_am824 {
+	struct snd_rawmidi_substream *midi[AM824_MAX_CHANNELS_FOR_MIDI * 8];
+	int midi_fifo_limit;
+	int midi_fifo_used[AM824_MAX_CHANNELS_FOR_MIDI * 8];
+	unsigned int pcm_channels;
+	unsigned int midi_ports;
+
+	u8 pcm_positions[AM824_MAX_CHANNELS_FOR_PCM];
+	u8 midi_position;
+
+	void (*transfer_samples)(struct amdtp_stream *s,
+				 struct snd_pcm_substream *pcm,
+				 __be32 *buffer, unsigned int frames);
+
+	unsigned int frame_multiplier;
+};
+
 /**
  * amdtp_am824_set_parameters - set stream parameters
  * @s: the AMDTP stream to configure
@@ -30,23 +62,58 @@ int amdtp_am824_set_parameters(struct amdtp_stream *s, unsigned int rate,
 			       unsigned int midi_ports,
 			       bool double_pcm_frames)
 {
+	struct amdtp_am824 *p = s->protocol;
+	unsigned int midi_channels;
+	unsigned int i;
 	int err;
 
-	err = amdtp_stream_set_parameters(s, rate, pcm_channels, midi_ports);
+	if (amdtp_stream_running(s))
+		return -EINVAL;
+
+	if (pcm_channels > AM824_MAX_CHANNELS_FOR_PCM)
+		return -EINVAL;
+
+	midi_channels = DIV_ROUND_UP(midi_ports, 8);
+	if (midi_channels > AM824_MAX_CHANNELS_FOR_MIDI)
+		return -EINVAL;
+
+	if (WARN_ON(amdtp_stream_running(s)) ||
+	    WARN_ON(pcm_channels > AM824_MAX_CHANNELS_FOR_PCM) ||
+	    WARN_ON(midi_channels > AM824_MAX_CHANNELS_FOR_MIDI))
+		return -EINVAL;
+
+	err = amdtp_stream_set_parameters(s, rate,
+					  pcm_channels + midi_channels);
 	if (err < 0)
 		return err;
 
 	s->fdf = AMDTP_FDF_AM824 | s->sfc;
 
+	p->pcm_channels = pcm_channels;
+	p->midi_ports = midi_ports;
+
 	/*
 	 * In IEC 61883-6, one data block represents one event. In ALSA, one
 	 * event equals to one PCM frame. But Dice has a quirk at higher
 	 * sampling rate to transfer two PCM frames in one data block.
 	 */
 	if (double_pcm_frames)
-		s->frame_multiplier = 2;
+		p->frame_multiplier = 2;
 	else
-		s->frame_multiplier = 1;
+		p->frame_multiplier = 1;
+
+	/* init the position map for PCM and MIDI channels */
+	for (i = 0; i < pcm_channels; i++)
+		p->pcm_positions[i] = i;
+	p->midi_position = p->pcm_channels;
+
+	/*
+	 * We do not know the actual MIDI FIFO size of most devices.  Just
+	 * assume two bytes, i.e., one byte can be received over the bus while
+	 * the previous one is transmitted over MIDI.
+	 * (The value here is adjusted for midi_ratelimit_per_packet().)
+	 */
+	p->midi_fifo_limit = rate - MIDI_BYTES_PER_SECOND * s->syt_interval + 1;
 
 	return 0;
 }
@@ -62,8 +129,10 @@ EXPORT_SYMBOL_GPL(amdtp_am824_set_parameters);
 void amdtp_am824_set_pcm_position(struct amdtp_stream *s, unsigned int index,
 				 unsigned int position)
 {
-	if (index < s->pcm_channels)
-		s->pcm_positions[index] = position;
+	struct amdtp_am824 *p = s->protocol;
+
+	if (index < p->pcm_channels)
+		p->pcm_positions[index] = position;
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_set_pcm_position);
 
@@ -76,10 +145,139 @@ EXPORT_SYMBOL_GPL(amdtp_am824_set_pcm_position);
 void amdtp_am824_set_midi_position(struct amdtp_stream *s,
 				   unsigned int position)
 {
-	s->midi_position = position;
+	struct amdtp_am824 *p = s->protocol;
+
+	p->midi_position = position;
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_set_midi_position);
 
+static void write_pcm_s32(struct amdtp_stream *s,
+			  struct snd_pcm_substream *pcm,
+			  __be32 *buffer, unsigned int frames)
+{
+	struct amdtp_am824 *p = s->protocol;
+	struct snd_pcm_runtime *runtime = pcm->runtime;
+	unsigned int channels, remaining_frames, i, c;
+	const u32 *src;
+
+	channels = p->pcm_channels;
+	src = (void *)runtime->dma_area +
+			frames_to_bytes(runtime, s->pcm_buffer_pointer);
+	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
+
+	for (i = 0; i < frames; ++i) {
+		for (c = 0; c < channels; ++c) {
+			buffer[p->pcm_positions[c]] =
+					cpu_to_be32((*src >> 8) | 0x40000000);
+			src++;
+		}
+		buffer += s->data_block_quadlets;
+		if (--remaining_frames == 0)
+			src = (void *)runtime->dma_area;
+	}
+}
+
+static void write_pcm_s16(struct amdtp_stream *s,
+			  struct snd_pcm_substream *pcm,
+			  __be32 *buffer, unsigned int frames)
+{
+	struct amdtp_am824 *p = s->protocol;
+	struct snd_pcm_runtime *runtime = pcm->runtime;
+	unsigned int channels, remaining_frames, i, c;
+	const u16 *src;
+
+	channels = p->pcm_channels;
+	src = (void *)runtime->dma_area +
+			frames_to_bytes(runtime, s->pcm_buffer_pointer);
+	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
+
+	for (i = 0; i < frames; ++i) {
+		for (c = 0; c < channels; ++c) {
+			buffer[p->pcm_positions[c]] =
+					cpu_to_be32((*src << 8) | 0x42000000);
+			src++;
+		}
+		buffer += s->data_block_quadlets;
+		if (--remaining_frames == 0)
+			src = (void *)runtime->dma_area;
+	}
+}
+
+static void read_pcm_s32(struct amdtp_stream *s,
+			 struct snd_pcm_substream *pcm,
+			 __be32 *buffer, unsigned int frames)
+{
+	struct amdtp_am824 *p = s->protocol;
+	struct snd_pcm_runtime *runtime = pcm->runtime;
+	unsigned int channels, remaining_frames, i, c;
+	u32 *dst;
+
+	channels = p->pcm_channels;
+	dst  = (void *)runtime->dma_area +
+			frames_to_bytes(runtime, s->pcm_buffer_pointer);
+	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
+
+	for (i = 0; i < frames; ++i) {
+		for (c = 0; c < channels; ++c) {
+			*dst = be32_to_cpu(buffer[p->pcm_positions[c]]) << 8;
+			dst++;
+		}
+		buffer += s->data_block_quadlets;
+		if (--remaining_frames == 0)
+			dst = (void *)runtime->dma_area;
+	}
+}
+
+static void write_pcm_silence(struct amdtp_stream *s,
+			      __be32 *buffer, unsigned int frames)
+{
+	struct amdtp_am824 *p = s->protocol;
+	unsigned int i, c, channels = p->pcm_channels;
+
+	for (i = 0; i < frames; ++i) {
+		for (c = 0; c < channels; ++c)
+			buffer[p->pcm_positions[c]] = cpu_to_be32(0x40000000);
+		buffer += s->data_block_quadlets;
+	}
+}
+
+/**
+ * amdtp_am824_set_pcm_format - set the PCM format
+ * @s: the AMDTP stream to configure
+ * @format: the format of the ALSA PCM device
+ *
+ * The sample format must be set after the other parameters (rate/PCM channels/
+ * MIDI) and before the stream is started, and must not be changed while the
+ * stream is running.
+ */
+void amdtp_am824_set_pcm_format(struct amdtp_stream *s, snd_pcm_format_t format)
+{
+	struct amdtp_am824 *p = s->protocol;
+
+	if (WARN_ON(amdtp_stream_pcm_running(s)))
+		return;
+
+	switch (format) {
+	default:
+		WARN_ON(1);
+		/* fall through */
+	case SNDRV_PCM_FORMAT_S16:
+		if (s->direction == AMDTP_OUT_STREAM) {
+			p->transfer_samples = write_pcm_s16;
+			break;
+		}
+		WARN_ON(1);
+		/* fall through */
+	case SNDRV_PCM_FORMAT_S32:
+		if (s->direction == AMDTP_OUT_STREAM)
+			p->transfer_samples = write_pcm_s32;
+		else
+			p->transfer_samples = read_pcm_s32;
+		break;
+	}
+}
+EXPORT_SYMBOL_GPL(amdtp_am824_set_pcm_format);
+
 /**
  * amdtp_am824_add_pcm_hw_constraints - add hw constraints for PCM substream
  * @s:		the AMDTP stream for AM824 data block, must be initialized.
@@ -113,11 +311,135 @@ EXPORT_SYMBOL_GPL(amdtp_am824_add_pcm_hw_constraints);
 void amdtp_am824_midi_trigger(struct amdtp_stream *s, unsigned int port,
 			      struct snd_rawmidi_substream *midi)
 {
-	if (port < s->midi_ports)
-		ACCESS_ONCE(s->midi[port]) = midi;
+	struct amdtp_am824 *p = s->protocol;
+
+	if (port < p->midi_ports)
+		ACCESS_ONCE(p->midi[port]) = midi;
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_midi_trigger);
 
+/*
+ * To avoid sending MIDI bytes at too high a rate, assume that the receiving
+ * device has a FIFO, and track how much it is filled.  This values increases
+ * by one whenever we send one byte in a packet, but the FIFO empties at
+ * a constant rate independent of our packet rate.  One packet has syt_interval
+ * samples, so the number of bytes that empty out of the FIFO, per packet(!),
+ * is MIDI_BYTES_PER_SECOND * syt_interval / sample_rate.  To avoid storing
+ * fractional values, the values in midi_fifo_used[] are measured in bytes
+ * multiplied by the sample rate.
+ */
+static bool midi_ratelimit_per_packet(struct amdtp_stream *s, unsigned int port)
+{
+	struct amdtp_am824 *p = s->protocol;
+	int used;
+
+	used = p->midi_fifo_used[port];
+	if (used == 0) /* common shortcut */
+		return true;
+
+	used -= MIDI_BYTES_PER_SECOND * s->syt_interval;
+	used = max(used, 0);
+	p->midi_fifo_used[port] = used;
+
+	return used < p->midi_fifo_limit;
+}
+
+static void midi_rate_use_one_byte(struct amdtp_stream *s, unsigned int port)
+{
+	struct amdtp_am824 *p = s->protocol;
+
+	p->midi_fifo_used[port] += amdtp_rate_table[s->sfc];
+}
+
+static void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,
+				unsigned int frames)
+{
+	struct amdtp_am824 *p = s->protocol;
+	unsigned int f, port;
+	u8 *b;
+
+	for (f = 0; f < frames; f++) {
+		b = (u8 *)&buffer[p->midi_position];
+
+		port = (s->data_block_counter + f) % 8;
+		if (f < MAX_MIDI_RX_BLOCKS &&
+		    midi_ratelimit_per_packet(s, port) &&
+		    p->midi[port] != NULL &&
+		    snd_rawmidi_transmit(p->midi[port], &b[1], 1) == 1) {
+			midi_rate_use_one_byte(s, port);
+			b[0] = 0x81;
+		} else {
+			b[0] = 0x80;
+			b[1] = 0;
+		}
+		b[2] = 0;
+		b[3] = 0;
+
+		buffer += s->data_block_quadlets;
+	}
+}
+
+static void read_midi_messages(struct amdtp_stream *s,
+			       __be32 *buffer, unsigned int frames)
+{
+	struct amdtp_am824 *p = s->protocol;
+	unsigned int f, port;
+	int len;
+	u8 *b;
+
+	for (f = 0; f < frames; f++) {
+		port = (s->data_block_counter + f) % 8;
+		b = (u8 *)&buffer[p->midi_position];
+
+		len = b[0] - 0x80;
+		if ((1 <= len) &&  (len <= 3) && (p->midi[port]))
+			snd_rawmidi_receive(p->midi[port], b + 1, len);
+
+		buffer += s->data_block_quadlets;
+	}
+}
+
+unsigned int process_rx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
+				    unsigned int data_blocks, unsigned int *syt)
+{
+	struct amdtp_am824 *p = s->protocol;
+	struct snd_pcm_substream *pcm = ACCESS_ONCE(s->pcm);
+	unsigned int pcm_frames;
+
+	if (pcm) {
+		p->transfer_samples(s, pcm, buffer, data_blocks);
+		pcm_frames = data_blocks * p->frame_multiplier;
+	} else {
+		write_pcm_silence(s, buffer, data_blocks);
+		pcm_frames = 0;
+	}
+
+	if (p->midi_ports)
+		write_midi_messages(s, buffer, data_blocks);
+
+	return pcm_frames;
+}
+
+unsigned int process_tx_data_blocks(struct amdtp_stream *s, __be32 *buffer,
+				    unsigned int data_blocks, unsigned int *syt)
+{
+	struct amdtp_am824 *p = s->protocol;
+	struct snd_pcm_substream *pcm = ACCESS_ONCE(s->pcm);
+	unsigned int pcm_frames;
+
+	if (pcm) {
+		p->transfer_samples(s, pcm, buffer, data_blocks);
+		pcm_frames = data_blocks * p->frame_multiplier;
+	} else {
+		pcm_frames = 0;
+	}
+
+	if (p->midi_ports)
+		read_midi_messages(s, buffer, data_blocks);
+
+	return pcm_frames;
+}
+
 /**
  * amdtp_am824_init - initialize an AMDTP stream structure to handle AM824
  *		      data block
@@ -129,6 +451,15 @@ EXPORT_SYMBOL_GPL(amdtp_am824_midi_trigger);
 int amdtp_am824_init(struct amdtp_stream *s, struct fw_unit *unit,
 		     enum amdtp_stream_direction dir, enum cip_flags flags)
 {
-	return amdtp_stream_init(s, unit, dir, flags, CIP_FMT_AM);
+	amdtp_stream_process_data_blocks_t process_data_blocks;
+
+	if (dir == AMDTP_IN_STREAM)
+		process_data_blocks = process_tx_data_blocks;
+	else
+		process_data_blocks = process_rx_data_blocks;
+
+	return amdtp_stream_init(s, unit, dir, flags, CIP_FMT_AM,
+				 process_data_blocks,
+				 sizeof(struct amdtp_am824));
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_init);

commit 03e2a67eed7bf2e4c701587080bc8d60dd45209c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:59 2015 +0900

    ALSA: firewire-lib: move MIDI trigger helper function to AM824 layer
    
    In IEC 61883-6, MIDI messages are transferred in MIDI conformant data
    channel. Essentially, packet streaming layer is not responsible for MIDI
    functionality.
    
    This commit moves MIDI trigger helper function from the layer to AM824
    layer. The rest of codes related to MIDI functionality will be moved in
    later commits.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 5d99a9921d50..540a101661e2 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -100,6 +100,24 @@ int amdtp_am824_add_pcm_hw_constraints(struct amdtp_stream *s,
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_add_pcm_hw_constraints);
 
+/**
+ * amdtp_am824_midi_trigger - start/stop playback/capture with a MIDI device
+ * @s: the AMDTP stream
+ * @port: index of MIDI port
+ * @midi: the MIDI device to be started, or %NULL to stop the current device
+ *
+ * Call this function on a running isochronous stream to enable the actual
+ * transmission of MIDI data.  This function should be called from the MIDI
+ * device's .trigger callback.
+ */
+void amdtp_am824_midi_trigger(struct amdtp_stream *s, unsigned int port,
+			      struct snd_rawmidi_substream *midi)
+{
+	if (port < s->midi_ports)
+		ACCESS_ONCE(s->midi[port]) = midi;
+}
+EXPORT_SYMBOL_GPL(amdtp_am824_midi_trigger);
+
 /**
  * amdtp_am824_init - initialize an AMDTP stream structure to handle AM824
  *		      data block

commit f65be911c0e13fab28919e17c9fa00c38dc4ff2f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:58 2015 +0900

    ALSA: firewire-lib: add helper functions to set positions of data channels
    
    In IEC 61883-6, several types of data are available in AM824 format. The
    data is transferred in each data channel. The position of data channel in
    data block differs depending on model.
    
    Current implementation has an array to map the index of data channel in an
    data block to the position of actual data channel. The implementation
    allows each driver to access the mapping directly.
    
    In later commit, the mapping is in specific structure pushed into an
    opaque pointer. Helper functions are required.
    
    This commit adds the helper functions for this purpose. In IEC 61883-6,
    AM824 format supports many data types, while this specification easily
    causes over-engineering. Current AM824 implementation is allowed to handle
    two types of data, Multi Bit Linear Audio data (=PCM samples) and MIDI
    conformant data (=MIDI messages).
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index 7adaba356579..5d99a9921d50 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -52,6 +52,34 @@ int amdtp_am824_set_parameters(struct amdtp_stream *s, unsigned int rate,
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_set_parameters);
 
+/**
+ * amdtp_am824_set_pcm_position - set an index of data channel for a channel
+ *				  of PCM frame
+ * @s: the AMDTP stream
+ * @index: the index of data channel in an data block
+ * @position: the channel of PCM frame
+ */
+void amdtp_am824_set_pcm_position(struct amdtp_stream *s, unsigned int index,
+				 unsigned int position)
+{
+	if (index < s->pcm_channels)
+		s->pcm_positions[index] = position;
+}
+EXPORT_SYMBOL_GPL(amdtp_am824_set_pcm_position);
+
+/**
+ * amdtp_am824_set_midi_position - set a index of data channel for MIDI
+ *				   conformant data channel
+ * @s: the AMDTP stream
+ * @position: the index of data channel in an data block
+ */
+void amdtp_am824_set_midi_position(struct amdtp_stream *s,
+				   unsigned int position)
+{
+	s->midi_position = position;
+}
+EXPORT_SYMBOL_GPL(amdtp_am824_set_midi_position);
+
 /**
  * amdtp_am824_add_pcm_hw_constraints - add hw constraints for PCM substream
  * @s:		the AMDTP stream for AM824 data block, must be initialized.

commit bc8500da3e62cd6a896407a1b330a2eb21817c22
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:57 2015 +0900

    ALSA: firewire-lib: move PCM substream constraint to AM824 layer
    
    In IEC 61883-6, PCM frames are transferred in Multi Bit Linear Audio data
    channel. The data channel transfers 16/20/24 bit PCM samples. Thus, PCM
    substream has a constrain about it.
    
    This commit moves codes related to the constraint from packet streaming
    layer to AM824 data block processing layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index f5edcbfa3157..7adaba356579 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -52,6 +52,26 @@ int amdtp_am824_set_parameters(struct amdtp_stream *s, unsigned int rate,
 }
 EXPORT_SYMBOL_GPL(amdtp_am824_set_parameters);
 
+/**
+ * amdtp_am824_add_pcm_hw_constraints - add hw constraints for PCM substream
+ * @s:		the AMDTP stream for AM824 data block, must be initialized.
+ * @runtime:	the PCM substream runtime
+ *
+ */
+int amdtp_am824_add_pcm_hw_constraints(struct amdtp_stream *s,
+				       struct snd_pcm_runtime *runtime)
+{
+	int err;
+
+	err = amdtp_stream_add_pcm_hw_constraints(s, runtime);
+	if (err < 0)
+		return err;
+
+	/* AM824 in IEC 61883-6 can deliver 24bit data. */
+	return snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+}
+EXPORT_SYMBOL_GPL(amdtp_am824_add_pcm_hw_constraints);
+
 /**
  * amdtp_am824_init - initialize an AMDTP stream structure to handle AM824
  *		      data block

commit 51c29fd21389d9995a8a18a91eeb8dd1220a2119
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:56 2015 +0900

    ALSA: firewire-lib: rename parameter setting function for AM824 with FDF field
    
    The value of FDF field in CIP header is protocol-dependent. Thus, it's
    better to allow data block processing layer to decide the value in any
    timing.
    
    In AM824 data format, the value of FDF field in CIP header indicates
    N-flag and Nominal Sampling Frequency Code (sfc). The N-flag is for
    switching 'Clock-based rate control mode' and 'Command-based rate control
    mode'. In our implementation, 'Clock-based rate control mode' is just
    supported. Therefore, When sampling transfer frequency is decided, then
    the FDF can be set.
    
    This commit replaces 'amdtp_stream_set_parameters' with
    'amdtp_am824_set_parameters' to set the FDF. This is the same timing
    to decide the ration between the number of data blocks and the number of
    PCM frames.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
index da4b643eff40..f5edcbfa3157 100644
--- a/sound/firewire/amdtp-am824.c
+++ b/sound/firewire/amdtp-am824.c
@@ -10,6 +10,48 @@
 
 #define CIP_FMT_AM		0x10
 
+/* "Clock-based rate control mode" is just supported. */
+#define AMDTP_FDF_AM824		0x00
+
+/**
+ * amdtp_am824_set_parameters - set stream parameters
+ * @s: the AMDTP stream to configure
+ * @rate: the sample rate
+ * @pcm_channels: the number of PCM samples in each data block, to be encoded
+ *                as AM824 multi-bit linear audio
+ * @midi_ports: the number of MIDI ports (i.e., MPX-MIDI Data Channels)
+ * @double_pcm_frames: one data block transfers two PCM frames
+ *
+ * The parameters must be set before the stream is started, and must not be
+ * changed while the stream is running.
+ */
+int amdtp_am824_set_parameters(struct amdtp_stream *s, unsigned int rate,
+			       unsigned int pcm_channels,
+			       unsigned int midi_ports,
+			       bool double_pcm_frames)
+{
+	int err;
+
+	err = amdtp_stream_set_parameters(s, rate, pcm_channels, midi_ports);
+	if (err < 0)
+		return err;
+
+	s->fdf = AMDTP_FDF_AM824 | s->sfc;
+
+	/*
+	 * In IEC 61883-6, one data block represents one event. In ALSA, one
+	 * event equals to one PCM frame. But Dice has a quirk at higher
+	 * sampling rate to transfer two PCM frames in one data block.
+	 */
+	if (double_pcm_frames)
+		s->frame_multiplier = 2;
+	else
+		s->frame_multiplier = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(amdtp_am824_set_parameters);
+
 /**
  * amdtp_am824_init - initialize an AMDTP stream structure to handle AM824
  *		      data block

commit 5955815e71ff9c773b156680c781c87728e37bea
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:55 2015 +0900

    ALSA: firewire-lib: add data block processing layer for AM824 format
    
    This commit adds data block processing layer for AM824 format. The new
    layer initializes streaming layer with its value for fmt field.
    
    Currently, most implementation of data block processing still remains
    streaming layer. In later commits, these codes will be moved to the layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-am824.c b/sound/firewire/amdtp-am824.c
new file mode 100644
index 000000000000..da4b643eff40
--- /dev/null
+++ b/sound/firewire/amdtp-am824.c
@@ -0,0 +1,26 @@
+/*
+ * AM824 format in Audio and Music Data Transmission Protocol (IEC 61883-6)
+ *
+ * Copyright (c) 2015 Takashi Sakamoto <o-takashi@sakamocchi.jp>
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "amdtp-am824.h"
+
+#define CIP_FMT_AM		0x10
+
+/**
+ * amdtp_am824_init - initialize an AMDTP stream structure to handle AM824
+ *		      data block
+ * @s: the AMDTP stream to initialize
+ * @unit: the target of the stream
+ * @dir: the direction of stream
+ * @flags: the packet transmission method to use
+ */
+int amdtp_am824_init(struct amdtp_stream *s, struct fw_unit *unit,
+		     enum amdtp_stream_direction dir, enum cip_flags flags)
+{
+	return amdtp_stream_init(s, unit, dir, flags, CIP_FMT_AM);
+}
+EXPORT_SYMBOL_GPL(amdtp_am824_init);
