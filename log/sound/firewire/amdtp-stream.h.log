commit 69efd5c4bd4c0e5e0d5388aa21d71d1313714a0e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 8 13:36:35 2020 +0900

    ALSA: firewire-lib: use sequence of syt offset and data block on pool in AMDTP domain
    
    In previous commit, the sequence of syt offset and the number of data
    blocks per packet is calculated for pool in AMDTP domain structure in
    advance of processing outgoing packets.
    
    This commit uses the sequence for outgoing packet processing to obsolete
    per-stream processing of the sequence.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200508043635.349339-11-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 11cff4cafd90..703b710aaf7f 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -140,10 +140,6 @@ struct amdtp_stream {
 			unsigned int transfer_delay;
 			unsigned int seq_index;
 
-			unsigned int data_block_state;
-			unsigned int last_syt_offset;
-			unsigned int syt_offset_state;
-
 			// To generate CIP header.
 			unsigned int fdf;
 			int syt_override;

commit 1a4be183b3fc9eca6ef0cca68b6698f4484f6b5f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 8 13:36:34 2020 +0900

    ALSA: firewire-lib: pool ideal sequence of syt offset and data block
    
    In current implementation, sequence of syt offset and the number of data
    blocks is generated when packets for outgoing stream are going to be
    queued.
    
    This commit generates and pools the sequence independently of the
    processing of outgoing packets for future extension.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200508043635.349339-10-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 84a01efa5a85..11cff4cafd90 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -138,6 +138,8 @@ struct amdtp_stream {
 		struct {
 			// To calculate CIP data blocks and tstamp.
 			unsigned int transfer_delay;
+			unsigned int seq_index;
+
 			unsigned int data_block_state;
 			unsigned int last_syt_offset;
 			unsigned int syt_offset_state;
@@ -292,6 +294,10 @@ struct amdtp_domain {
 	struct seq_desc *seq_descs;
 	unsigned int seq_size;
 	unsigned int seq_tail;
+
+	unsigned int data_block_state;
+	unsigned int syt_offset_state;
+	unsigned int last_syt_offset;
 };
 
 int amdtp_domain_init(struct amdtp_domain *d);

commit 25babf297c570ecec28451a580987fa08b49fa92
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 8 13:36:33 2020 +0900

    ALSA: firewire-lib: add cache for packet sequence to AMDTP domain structure
    
    For future extension, storage is required to store packet sequence in
    incoming AMDTP stream to recover media clock for outgoing AMDTP stream.
    
    This commit adds the storage to AMDTP domain for this purpose. The
    packet sequence is represented by 'struct seq_desc' which has two
    members; syt_offset and the number of data blocks. The size of storage
    is decided according to the size of packet queue.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200508043635.349339-9-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 477fbfe713e5..84a01efa5a85 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -276,6 +276,11 @@ static inline bool amdtp_stream_wait_callback(struct amdtp_stream *s,
 				  msecs_to_jiffies(timeout)) > 0;
 }
 
+struct seq_desc {
+	unsigned int syt_offset;
+	unsigned int data_blocks;
+};
+
 struct amdtp_domain {
 	struct list_head streams;
 
@@ -283,6 +288,10 @@ struct amdtp_domain {
 	unsigned int events_per_buffer;
 
 	struct amdtp_stream *irq_target;
+
+	struct seq_desc *seq_descs;
+	unsigned int seq_size;
+	unsigned int seq_tail;
 };
 
 int amdtp_domain_init(struct amdtp_domain *d);

commit 2472cfb3232caf8f68e4d93ae830c569b0bbc25b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 8 13:36:28 2020 +0900

    ALSA: firewire-lib: add reference to domain structure from stream structure
    
    In current implementation, AMDTP domain structure and AMDTP stream
    structure has one way of reference from the former to the latter. For
    future extension, bidirectional reference is needed.
    
    This commit adds a member into stream structure to refer to domain
    structure to which the stream belongs.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200508043635.349339-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index f2d44e2dc3c8..477fbfe713e5 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -108,6 +108,8 @@ typedef unsigned int (*amdtp_stream_process_ctx_payloads_t)(
 						const struct pkt_desc *desc,
 						unsigned int packets,
 						struct snd_pcm_substream *pcm);
+
+struct amdtp_domain;
 struct amdtp_stream {
 	struct fw_unit *unit;
 	enum cip_flags flags;
@@ -180,6 +182,7 @@ struct amdtp_stream {
 	int channel;
 	int speed;
 	struct list_head list;
+	struct amdtp_domain *domain;
 };
 
 int amdtp_stream_init(struct amdtp_stream *s, struct fw_unit *unit,

commit acfedcbe1ce4c69e1da914f39c02d945c80198d4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 15:19:11 2019 +0900

    ALSA: firewire-lib: postpone to start IR context
    
    Some devices have a quirk to postpone transmission of isoc packet for
    several dozen or hundred isoc cycles since configured to transmit.
    Furthermore, some devices have a quirk to transmit isoc packet with
    discontinued data of its header.
    
    In 1394 OHCI specification, software allows to start isoc context with
    certain isoc cycle. Linux firewire subsystem has kernel API to use it
    as well.
    
    This commit uses the functionality of 1394 OHCI controller to handle
    the quirks. At present, this feature is convenient to ALSA bebob and
    fireface driver. As a result, some devices can be safely handled, as
    long as I know:
     - MAudio FireWire solo
     - MAudio ProFire Lightbridge
     - MAudio FireWire 410
     - Roland FA-66
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191018061911.24909-7-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index c4bde69c2d4f..f2d44e2dc3c8 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -288,7 +288,7 @@ void amdtp_domain_destroy(struct amdtp_domain *d);
 int amdtp_domain_add_stream(struct amdtp_domain *d, struct amdtp_stream *s,
 			    int channel, int speed);
 
-int amdtp_domain_start(struct amdtp_domain *d);
+int amdtp_domain_start(struct amdtp_domain *d, unsigned int ir_delay_cycle);
 void amdtp_domain_stop(struct amdtp_domain *d);
 
 static inline int amdtp_domain_set_events_per_period(struct amdtp_domain *d,

commit 60dd49298ec5803ca423836d5a724c3fe402cc3f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 15:19:10 2019 +0900

    ALSA: firewire-lib: handle several AMDTP streams in callback handler of IRQ target
    
    This commit changes AMDTP domain to run on an IT context of 1394 OHCI as
    IRQ target. No hardware interrupt is scheduled for the other isoc
    contexts. All of the isoc context are processed in a callback for an isoc
    context of IRQ target.
    
    The IRQ target is automatically selected from a list of AMDTP streams,
    thus users of AMDTP domain should add an AMDTP stream for IT context
    at least.
    
    The reason to select IT context as IRQ target is that the IT context
    runs on local 1394 OHCI controller and it can be used as reliable,
    constant IRQ generator. On the other hand, IR context can include skip
    cycle according to isoc packet transferred by device.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191018061911.24909-6-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 470e77ca0061..c4bde69c2d4f 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -143,11 +143,12 @@ struct amdtp_stream {
 			// To generate CIP header.
 			unsigned int fdf;
 			int syt_override;
+
+			// To generate constant hardware IRQ.
+			unsigned int event_count;
+			unsigned int events_per_period;
 		} rx;
 	} ctx_data;
-	unsigned int event_count;
-	unsigned int events_per_period;
-	unsigned int idle_irq_interval;
 
 	/* For CIP headers. */
 	unsigned int source_node_id_field;

commit e6dcc92fcea07f23c13996b7bb6a2a32ed4c6ed5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 15:19:08 2019 +0900

    ALSA: firewire-lib: replace ack callback to flush isoc contexts in AMDTP domain
    
    An isoc context for AMDTP stream is flushed to queue packet
    by a call of pcm.ack. This commit extends this for AMDTP
    domain.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191018061911.24909-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index ba0bbeddfdcb..470e77ca0061 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -198,7 +198,6 @@ int amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,
 					struct snd_pcm_runtime *runtime);
 
 void amdtp_stream_pcm_prepare(struct amdtp_stream *s);
-int amdtp_stream_pcm_ack(struct amdtp_stream *s);
 void amdtp_stream_pcm_abort(struct amdtp_stream *s);
 
 extern const unsigned int amdtp_syt_intervals[CIP_SFC_COUNT];
@@ -303,4 +302,6 @@ static inline int amdtp_domain_set_events_per_period(struct amdtp_domain *d,
 
 unsigned long amdtp_domain_stream_pcm_pointer(struct amdtp_domain *d,
 					      struct amdtp_stream *s);
+int amdtp_domain_stream_pcm_ack(struct amdtp_domain *d, struct amdtp_stream *s);
+
 #endif

commit f890f9a04b361b2209c38e3317e6290a98e6ff6e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 15:19:07 2019 +0900

    ALSA: firewire-lib: replace pointer callback to flush isoc contexts in AMDTP domain
    
    An isoc context for AMDTP stream is flushed to queue packet
    by a call of pcm.pointer. This commit extends this for AMDTP
    domain.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191018061911.24909-3-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index f92397a2f35f..ba0bbeddfdcb 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -198,7 +198,6 @@ int amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,
 					struct snd_pcm_runtime *runtime);
 
 void amdtp_stream_pcm_prepare(struct amdtp_stream *s);
-unsigned long amdtp_stream_pcm_pointer(struct amdtp_stream *s);
 int amdtp_stream_pcm_ack(struct amdtp_stream *s);
 void amdtp_stream_pcm_abort(struct amdtp_stream *s);
 
@@ -302,4 +301,6 @@ static inline int amdtp_domain_set_events_per_period(struct amdtp_domain *d,
 	return 0;
 }
 
+unsigned long amdtp_domain_stream_pcm_pointer(struct amdtp_domain *d,
+					      struct amdtp_stream *s);
 #endif

commit 03b4816dcb6ee348edf248f7ba9f04f1e90c2fc7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 15:19:06 2019 +0900

    ALSA: firewire-lib: add irq_target member into amdtp_domain struct
    
    This commit is a preparation to handle several IR/IT contexts in the same
    domain by tasklet context for one of the IT context. Such IT context is
    stored to AMDTP domain structure as 'irq_target'.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191018061911.24909-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 344818e936df..f92397a2f35f 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -279,6 +279,8 @@ struct amdtp_domain {
 
 	unsigned int events_per_period;
 	unsigned int events_per_buffer;
+
+	struct amdtp_stream *irq_target;
 };
 
 int amdtp_domain_init(struct amdtp_domain *d);

commit e229853d505d7ab77e9b68b0ac91d19f48fe6d80
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 00:54:22 2019 +0900

    ALSA: firewire-lib: schedule hardware IRQ according to the size of PCM period
    
    ALSA IEC 61883-1/6 packet streaming engine controls 1394 OHCI controller
    to generate hardware IRQ for fixed number of isochronous packets (=16)
    since its first commit.
    
    This commit allow the engine to generate it for variable period according
    to the number of event to handle. For outgoing stream, internal
    calculator is used to check the accumulated events. For incoming stream,
    the number of data block in the packet of stream is used to check the
    accumulated events. When it's unavailable, fixed number of packet
    roughly calculated in advance is used instead of event counting.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191017155424.885-11-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 8d541727e437..344818e936df 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -145,6 +145,9 @@ struct amdtp_stream {
 			int syt_override;
 		} rx;
 	} ctx_data;
+	unsigned int event_count;
+	unsigned int events_per_period;
+	unsigned int idle_irq_interval;
 
 	/* For CIP headers. */
 	unsigned int source_node_id_field;

commit a0e023317e2d55c6b2fbf342c12d8a59797e1cff
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 00:54:13 2019 +0900

    ALSA: firewire-lib: use variable size of queue for isoc packets instead of fixed size
    
    The number of packets in packet buffer has been fixed number (=48) since
    first commit of ALSA IEC 61883-1/6 packet streaming engine.
    
    This commit allows the engine to use variable number of packets in the
    buffer. The size is calculated by a parameter in AMDTP domain structure
    surely to store the number of events in the packets of buffer. Although
    the value of parameter is expected to come from 'period size' parameter
    of PCM substream, at present 48 is still used.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191017155424.885-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index d95a4ed15f20..8d541727e437 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -117,6 +117,7 @@ struct amdtp_stream {
 	/* For packet processing. */
 	struct fw_iso_context *context;
 	struct iso_packets_buffer buffer;
+	unsigned int queue_size;
 	int packet_index;
 	struct pkt_desc *pkt_descs;
 	int tag;
@@ -274,6 +275,7 @@ struct amdtp_domain {
 	struct list_head streams;
 
 	unsigned int events_per_period;
+	unsigned int events_per_buffer;
 };
 
 int amdtp_domain_init(struct amdtp_domain *d);
@@ -286,9 +288,11 @@ int amdtp_domain_start(struct amdtp_domain *d);
 void amdtp_domain_stop(struct amdtp_domain *d);
 
 static inline int amdtp_domain_set_events_per_period(struct amdtp_domain *d,
-						unsigned int events_per_period)
+						unsigned int events_per_period,
+						unsigned int events_per_buffer)
 {
 	d->events_per_period = events_per_period;
+	d->events_per_buffer = events_per_buffer;
 
 	return 0;
 }

commit d68c3123ba88dcd6692c90e698473d57856578e1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 7 20:05:16 2019 +0900

    ALSA: firewire-lib: add a member into AMDTP domain for events per period
    
    In IEC 61883-6, it's called as 'event' what has presentation time
    represented by timestamp in CIP header. Although the ratio of the number
    of event against the number of data block is different depending on
    event data type represented by the specific field in CIP header, it's
    just one in the most cases supported by ALSA IEC 61883-1/6 engine.
    
    In 1394 OHCI specification, applications can schedule hardware IRQ
    by configuring descriptor with IRQ flag for packet against each
    isochronous cycle. For future commit, I use the hardware IRQ for
    isoc IT context to acknowledge the elapse of PCM period for both
    playback/capture directions on AMDTP streams in the same domain.
    
    This commit is a preparation for the above idea. This commit adds
    a member into AMDTP domain structure to record the number of PCM frames.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191007110532.30270-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index bbbca964b9b4..d95a4ed15f20 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -272,6 +272,8 @@ static inline bool amdtp_stream_wait_callback(struct amdtp_stream *s,
 
 struct amdtp_domain {
 	struct list_head streams;
+
+	unsigned int events_per_period;
 };
 
 int amdtp_domain_init(struct amdtp_domain *d);
@@ -283,4 +285,12 @@ int amdtp_domain_add_stream(struct amdtp_domain *d, struct amdtp_stream *s,
 int amdtp_domain_start(struct amdtp_domain *d);
 void amdtp_domain_stop(struct amdtp_domain *d);
 
+static inline int amdtp_domain_set_events_per_period(struct amdtp_domain *d,
+						unsigned int events_per_period)
+{
+	d->events_per_period = events_per_period;
+
+	return 0;
+}
+
 #endif

commit 74f94e41825549638a5b24410c1f62d5ea57134e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 4 15:21:38 2019 +0900

    ALSA: firewire-lib: localize kernel APIs to start/stop each AMDTP stream
    
    As a result to support AMDTP domain, no drivers call kernel APIs to
    start/stop each AMDTP stream. This commit localize these APIs.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 15d471660a43..bbbca964b9b4 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -188,9 +188,7 @@ int amdtp_stream_set_parameters(struct amdtp_stream *s, unsigned int rate,
 				unsigned int data_block_quadlets);
 unsigned int amdtp_stream_get_max_payload(struct amdtp_stream *s);
 
-int amdtp_stream_start(struct amdtp_stream *s, int channel, int speed);
 void amdtp_stream_update(struct amdtp_stream *s);
-void amdtp_stream_stop(struct amdtp_stream *s);
 
 int amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,
 					struct snd_pcm_runtime *runtime);

commit 9b4702b06c0e25abc612e6f02f3e25a51c684a01
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 4 15:21:23 2019 +0900

    ALSA: firewire-lib: add a kernel API to start AMDTP streams in AMDTP domain
    
    This commit adds a kernel API to start a couple of isochronous contexts
    for some AMDTP streams.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 4b102fd7529d..15d471660a43 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -282,6 +282,7 @@ void amdtp_domain_destroy(struct amdtp_domain *d);
 int amdtp_domain_add_stream(struct amdtp_domain *d, struct amdtp_stream *s,
 			    int channel, int speed);
 
+int amdtp_domain_start(struct amdtp_domain *d);
 void amdtp_domain_stop(struct amdtp_domain *d);
 
 #endif

commit 157a53eef6a016e6938d9fd266b85221fcd4eaa3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 4 15:21:22 2019 +0900

    ALSA: firewire-lib: add a kernel API to add AMDTP stream into AMDTP domain
    
    This commit adds a kernel API to insert AMDTP stream to list in AMDTP
    domain.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index ab2a69180240..4b102fd7529d 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -172,6 +172,8 @@ struct amdtp_stream {
 	amdtp_stream_process_ctx_payloads_t process_ctx_payloads;
 
 	// For domain.
+	int channel;
+	int speed;
 	struct list_head list;
 };
 
@@ -277,6 +279,9 @@ struct amdtp_domain {
 int amdtp_domain_init(struct amdtp_domain *d);
 void amdtp_domain_destroy(struct amdtp_domain *d);
 
+int amdtp_domain_add_stream(struct amdtp_domain *d, struct amdtp_stream *s,
+			    int channel, int speed);
+
 void amdtp_domain_stop(struct amdtp_domain *d);
 
 #endif

commit 6261f90bdb0b605ffb158717ec7a03b1753aded5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 4 15:21:21 2019 +0900

    ALSA: firewire-lib: add a kernel API to stop a couple of AMDTP streams in AMDTP domain
    
    This commit adds a kernel API to stop a couple of isochronous contexts
    for AMDTP streams. The API is not protected with any lock primitive.
    Callers should use this with enough lock against concurrent access.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 2378db4b4195..ab2a69180240 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -170,6 +170,9 @@ struct amdtp_stream {
 	/* For backends to process data blocks. */
 	void *protocol;
 	amdtp_stream_process_ctx_payloads_t process_ctx_payloads;
+
+	// For domain.
+	struct list_head list;
 };
 
 int amdtp_stream_init(struct amdtp_stream *s, struct fw_unit *unit,
@@ -274,4 +277,6 @@ struct amdtp_domain {
 int amdtp_domain_init(struct amdtp_domain *d);
 void amdtp_domain_destroy(struct amdtp_domain *d);
 
+void amdtp_domain_stop(struct amdtp_domain *d);
+
 #endif

commit 3ec3d7a3ff10692d4f8a2baa0ff18fe10a9b6ad4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 4 15:21:20 2019 +0900

    ALSA: firewire-lib: add AMDTP domain structure to handle several isoc contexts
    
    This commit adds 'struct amdtp_domain' structure. This structure
    has list of instance of AMDTP stream to handle a couple of
    isochronous contexts.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 50041fa884d9..2378db4b4195 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -267,4 +267,11 @@ static inline bool amdtp_stream_wait_callback(struct amdtp_stream *s,
 				  msecs_to_jiffies(timeout)) > 0;
 }
 
+struct amdtp_domain {
+	struct list_head streams;
+};
+
+int amdtp_domain_init(struct amdtp_domain *d);
+void amdtp_domain_destroy(struct amdtp_domain *d);
+
 #endif

commit 9a738ad1b1a64ef6d8271d8d42d715b75db6eb0d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:37:09 2019 +0900

    ALSA: firewire-lib: process payload of isoc context according to packet descriptors
    
    This commit changes each of data block processing layer so that it
    receives list of packet descriptor.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 0e5b85100a04..50041fa884d9 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -103,9 +103,10 @@ struct pkt_desc {
 };
 
 struct amdtp_stream;
-typedef unsigned int (*amdtp_stream_process_data_blocks_t)(
+typedef unsigned int (*amdtp_stream_process_ctx_payloads_t)(
 						struct amdtp_stream *s,
 						const struct pkt_desc *desc,
+						unsigned int packets,
 						struct snd_pcm_substream *pcm);
 struct amdtp_stream {
 	struct fw_unit *unit;
@@ -168,13 +169,13 @@ struct amdtp_stream {
 
 	/* For backends to process data blocks. */
 	void *protocol;
-	amdtp_stream_process_data_blocks_t process_data_blocks;
+	amdtp_stream_process_ctx_payloads_t process_ctx_payloads;
 };
 
 int amdtp_stream_init(struct amdtp_stream *s, struct fw_unit *unit,
 		      enum amdtp_stream_direction dir, enum cip_flags flags,
 		      unsigned int fmt,
-		      amdtp_stream_process_data_blocks_t process_data_blocks,
+		      amdtp_stream_process_ctx_payloads_t process_ctx_payloads,
 		      unsigned int protocol_size);
 void amdtp_stream_destroy(struct amdtp_stream *s);
 

commit d2c104a3426be9991b35c65f0f260a107c4b2942
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:37:03 2019 +0900

    ALSA: firewire-lib: pass packet descriptor to data block processing layer
    
    This commit changes signature of callback function to call data block
    processing layer with packet descriptor. At present, the layer is called
    per packet.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 73c492c9a5d5..0e5b85100a04 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -105,9 +105,8 @@ struct pkt_desc {
 struct amdtp_stream;
 typedef unsigned int (*amdtp_stream_process_data_blocks_t)(
 						struct amdtp_stream *s,
-						__be32 *buffer,
-						unsigned int data_blocks,
-						unsigned int data_block_counter);
+						const struct pkt_desc *desc,
+						struct snd_pcm_substream *pcm);
 struct amdtp_stream {
 	struct fw_unit *unit;
 	enum cip_flags flags;

commit 04130cf8e296bfbd65d2673a5975bd0f200b941d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:58 2019 +0900

    ALSA: firewire-lib: add list of packet descriptor
    
    In current implementation of ALSA IEC 61883-1/6 packet streaming engine,
    16 packets are handled in one interrupt of isochronous context of OHCI
    1394.
    
    Overall packet processing runs for each. However, this is not better in
    a point to split the processing into several parts.
    
    This commit is an attempt to add intermediate representation for
    parameters required for the parts.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 5996cc60f166..73c492c9a5d5 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -94,6 +94,14 @@ enum amdtp_stream_direction {
 	AMDTP_IN_STREAM
 };
 
+struct pkt_desc {
+	u32 cycle;
+	u32 syt;
+	unsigned int data_blocks;
+	unsigned int data_block_counter;
+	__be32 *ctx_payload;
+};
+
 struct amdtp_stream;
 typedef unsigned int (*amdtp_stream_process_data_blocks_t)(
 						struct amdtp_stream *s,
@@ -110,6 +118,7 @@ struct amdtp_stream {
 	struct fw_iso_context *context;
 	struct iso_packets_buffer buffer;
 	int packet_index;
+	struct pkt_desc *pkt_descs;
 	int tag;
 	union {
 		struct {

commit 600c8018df605a91575aef6811cf927e2d933d30
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:57 2019 +0900

    ALSA: firewire-lib: pass no syt information to data block processing layer
    
    In a previous commit, the variable passed from packet streaming layer
    for syt variable is useless. This commit obsoletes it.
    
    In my future work, the syt information is passed to data block processing
    layer by another way.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 5b9d4212e202..5996cc60f166 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -99,8 +99,7 @@ typedef unsigned int (*amdtp_stream_process_data_blocks_t)(
 						struct amdtp_stream *s,
 						__be32 *buffer,
 						unsigned int data_blocks,
-						unsigned int data_block_counter,
-						unsigned int *syt);
+						unsigned int data_block_counter);
 struct amdtp_stream {
 	struct fw_unit *unit;
 	enum cip_flags flags;

commit 3baf30532f94030244a31a275b546d042656c535
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:56 2019 +0900

    ALSA: firewire-lib: add syt_override member for some protocols
    
    Some protocols don't use syt field of CIP header to represent
    presentation timestamp. For such protocol, ALSA IEC 61883-1/6
    packet streaming engine uses a pointer into local variable for
    the value of syt to call data block processing layer. However,
    it can decide the value when initializing packet streaming
    layer.
    
    This commit adds 'syt_override' member for packet streaming
    layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 762ac3c7e902..5b9d4212e202 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -133,6 +133,7 @@ struct amdtp_stream {
 
 			// To generate CIP header.
 			unsigned int fdf;
+			int syt_override;
 		} rx;
 	} ctx_data;
 

commit ab75481202d2925a017e4cb5407b0bb49c356de8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:53 2019 +0900

    ALSA: firewire-lib: pass data block counter to data block processing layer
    
    This is a preparation for future commit that 'struct
    amdtp_stream.data_block_count' does not represent the value of
    data block count for current data block.
    
    However, data block count is required for calculation of sequence index
    in sequence-multiplied data channel. Some of data block processing layer
    require it; e.g. for AM824 data block.
    
    This commit passes data block count to the processing layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 5d611122312b..762ac3c7e902 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -99,6 +99,7 @@ typedef unsigned int (*amdtp_stream_process_data_blocks_t)(
 						struct amdtp_stream *s,
 						__be32 *buffer,
 						unsigned int data_blocks,
+						unsigned int data_block_counter,
 						unsigned int *syt);
 struct amdtp_stream {
 	struct fw_unit *unit;

commit 588f2e2caf6795ca29d50a45ea1e1438274e75e0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:51 2019 +0900

    ALSA: firewire-lib: obsolete ctx_data.tx.first_dbc with CIP_UNALIGHED_DBC flag
    
    Recent firmware for Fireworks board module have a quirk to start
    transmission of CIP with non-zero value for its data block counter.
    In current implementation of ALSA firewire stack, the quirk is handled
    by 'struct amdtp_stream.ctx_data.tx.first_dbc' with value 0x02. However,
    the value comes from reverse engineering. It's better to handle this
    quirk without the explicit value.
    
    In a process to parse CIP header, the quirk of data block counter
    affects decision of sequence index in sequence-multiplexed data channel;
    i.e. MIDI conformant data channel. In Fireworks, the index is decided
    by the number of data blocks from top of the same CIP, thus the value
    of data block counter is useless.
    
    This commit adds CIP_UNALIGHED_DBC flag and obsoletes the explicit
    value for this quirk.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 3942894c11ac..5d611122312b 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -33,6 +33,8 @@
  * @CIP_HEADER_WITHOUT_EOH: Only for in-stream. CIP Header doesn't include
  *	valid EOH.
  * @CIP_NO_HEADERS: a lack of headers in packets
+ * @CIP_UNALIGHED_DBC: Only for in-stream. The value of dbc is not alighed to
+ *	the value of current SYT_INTERVAL; e.g. initial value is not zero.
  */
 enum cip_flags {
 	CIP_NONBLOCKING		= 0x00,
@@ -45,6 +47,7 @@ enum cip_flags {
 	CIP_JUMBO_PAYLOAD	= 0x40,
 	CIP_HEADER_WITHOUT_EOH	= 0x80,
 	CIP_NO_HEADER		= 0x100,
+	CIP_UNALIGHED_DBC	= 0x200,
 };
 
 /**
@@ -119,8 +122,6 @@ struct amdtp_stream {
 			// Fixed interval of dbc between previos/current
 			// packets.
 			unsigned int dbc_interval;
-			// Indicate the value of dbc field in a first packet.
-			unsigned int first_dbc;
 		} tx;
 		struct {
 			// To calculate CIP data blocks and tstamp.

commit 16be458993be75ca255cee176df47955608b4df8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 24 00:14:38 2019 +0900

    ALSA: firewire-lib: unify packet handler for IT context
    
    The handlers for packet with CIP and without CIP include common codes.
    This commit unifies them and remove an member for pointer to callback
    function from data structure.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 234483a31df5..3942894c11ac 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -108,9 +108,6 @@ struct amdtp_stream {
 	struct iso_packets_buffer buffer;
 	int packet_index;
 	int tag;
-	int (*handle_packet)(struct amdtp_stream *s, unsigned int cycle,
-			     const __be32 *ctx_header, __be32 *buffer,
-			     unsigned int index);
 	union {
 		struct {
 			unsigned int ctx_header_size;

commit f11453c7cc010d4052f630d541c39301b54cee3c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 22 23:17:07 2019 +0900

    ALSA: firewire-lib: use 16 bytes IR context header to separate CIP header
    
    In IR context, some quadlets of packet payload can be included into
    context header. This is good for packet with CIP header because the
    context payload buffer can includes data blocks only for with-CIP and
    without-CIP pakets.
    
    This commit uses 16 bytes IR context header for this purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 5aa9683593d2..234483a31df5 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -116,7 +116,7 @@ struct amdtp_stream {
 			unsigned int ctx_header_size;
 
 			// limit for payload of iso packet.
-			unsigned int max_payload_length;
+			unsigned int max_ctx_payload_length;
 
 			// For quirks of CIP headers.
 			// Fixed interval of dbc between previos/current

commit 8a400b999678996af6ca9434376b2260ec2ea9eb
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 22 23:17:05 2019 +0900

    ALSA: firewire-lib: compute pointer to payload buffer in context handler
    
    The value of pointer to payload buffer is computed in each packet
    handler, however the pointer can be decided before call of packet
    handler.
    
    This commit adds an argument for the pointer to the packet handler to
    reduce codes to compute for the pointer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index d317fdc6ab5f..5aa9683593d2 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -109,7 +109,8 @@ struct amdtp_stream {
 	int packet_index;
 	int tag;
 	int (*handle_packet)(struct amdtp_stream *s, unsigned int cycle,
-			     const __be32 *ctx_header, unsigned int index);
+			     const __be32 *ctx_header, __be32 *buffer,
+			     unsigned int index);
 	union {
 		struct {
 			unsigned int ctx_header_size;

commit 6f3c07d03c6bc84d2da6ce0e24e9a1feece42c47
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 22 23:17:04 2019 +0900

    ALSA: firewire-lib: calculate the length of packet payload in packet handler
    
    In current packet handler, the length of payload is given as an argument
    of callback function, however this value is just required to process
    payload of transferred isoc packet, thus just for IR context.
    
    This commit replaces the argument for payload of packet with the
    argument of context header. As a result, the length of payload is
    computed in packet handler for IR context.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 1945ef59ab92..d317fdc6ab5f 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -108,9 +108,8 @@ struct amdtp_stream {
 	struct iso_packets_buffer buffer;
 	int packet_index;
 	int tag;
-	int (*handle_packet)(struct amdtp_stream *s,
-			unsigned int payload_quadlets, unsigned int cycle,
-			unsigned int index);
+	int (*handle_packet)(struct amdtp_stream *s, unsigned int cycle,
+			     const __be32 *ctx_header, unsigned int index);
 	union {
 		struct {
 			unsigned int ctx_header_size;

commit d3d10a4a1b1950c2d20714c2511b5f58c99bab81
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 21 23:57:34 2019 +0900

    ALSA: firewire-lib: use union for directional parameters
    
    Some parameters of struct amdtp_stream is dependent on direction.
    
    This commit uses union for such parameters to distinguish from
    common parameters.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index e45de3eecfe3..1945ef59ab92 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -111,7 +111,31 @@ struct amdtp_stream {
 	int (*handle_packet)(struct amdtp_stream *s,
 			unsigned int payload_quadlets, unsigned int cycle,
 			unsigned int index);
-	unsigned int max_payload_length;
+	union {
+		struct {
+			unsigned int ctx_header_size;
+
+			// limit for payload of iso packet.
+			unsigned int max_payload_length;
+
+			// For quirks of CIP headers.
+			// Fixed interval of dbc between previos/current
+			// packets.
+			unsigned int dbc_interval;
+			// Indicate the value of dbc field in a first packet.
+			unsigned int first_dbc;
+		} tx;
+		struct {
+			// To calculate CIP data blocks and tstamp.
+			unsigned int transfer_delay;
+			unsigned int data_block_state;
+			unsigned int last_syt_offset;
+			unsigned int syt_offset_state;
+
+			// To generate CIP header.
+			unsigned int fdf;
+		} rx;
+	} ctx_data;
 
 	/* For CIP headers. */
 	unsigned int source_node_id_field;
@@ -119,19 +143,10 @@ struct amdtp_stream {
 	unsigned int data_block_counter;
 	unsigned int sph;
 	unsigned int fmt;
-	unsigned int fdf;
-	/* quirk: fixed interval of dbc between previos/current packets. */
-	unsigned int tx_dbc_interval;
-	/* quirk: indicate the value of dbc field in a first packet. */
-	unsigned int tx_first_dbc;
 
 	/* Internal flags. */
 	enum cip_sfc sfc;
 	unsigned int syt_interval;
-	unsigned int transfer_delay;
-	unsigned int data_block_state;
-	unsigned int last_syt_offset;
-	unsigned int syt_offset_state;
 
 	/* For a PCM substream processing. */
 	struct snd_pcm_substream *pcm;

commit 8c5db92a705d9e2c986adec475980d1120fa07b4
Merge: ca5d376e1707 e4880bc5dfb1
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Nov 7 10:32:44 2017 +0100

    Merge branch 'linus' into locking/core, to resolve conflicts
    
    Conflicts:
            include/linux/compiler-clang.h
            include/linux/compiler-gcc.h
            include/linux/compiler-intel.h
            include/uapi/linux/stddef.h
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index ed6eafd10992..a608dae83348 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef SOUND_FIREWIRE_AMDTP_H_INCLUDED
 #define SOUND_FIREWIRE_AMDTP_H_INCLUDED
 

commit 6aa7de059173a986114ac43b8f50b297a86f09a8
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Oct 23 14:07:29 2017 -0700

    locking/atomics: COCCINELLE/treewide: Convert trivial ACCESS_ONCE() patterns to READ_ONCE()/WRITE_ONCE()
    
    Please do not apply this to mainline directly, instead please re-run the
    coccinelle script shown below and apply its output.
    
    For several reasons, it is desirable to use {READ,WRITE}_ONCE() in
    preference to ACCESS_ONCE(), and new code is expected to use one of the
    former. So far, there's been no reason to change most existing uses of
    ACCESS_ONCE(), as these aren't harmful, and changing them results in
    churn.
    
    However, for some features, the read/write distinction is critical to
    correct operation. To distinguish these cases, separate read/write
    accessors must be used. This patch migrates (most) remaining
    ACCESS_ONCE() instances to {READ,WRITE}_ONCE(), using the following
    coccinelle script:
    
    ----
    // Convert trivial ACCESS_ONCE() uses to equivalent READ_ONCE() and
    // WRITE_ONCE()
    
    // $ make coccicheck COCCI=/home/mark/once.cocci SPFLAGS="--include-headers" MODE=patch
    
    virtual patch
    
    @ depends on patch @
    expression E1, E2;
    @@
    
    - ACCESS_ONCE(E1) = E2
    + WRITE_ONCE(E1, E2)
    
    @ depends on patch @
    expression E;
    @@
    
    - ACCESS_ONCE(E)
    + READ_ONCE(E)
    ----
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: davem@davemloft.net
    Cc: linux-arch@vger.kernel.org
    Cc: mpe@ellerman.id.au
    Cc: shuah@kernel.org
    Cc: snitzer@redhat.com
    Cc: thor.thayer@linux.intel.com
    Cc: tj@kernel.org
    Cc: viro@zeniv.linux.org.uk
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1508792849-3115-19-git-send-email-paulmck@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index ed6eafd10992..f9abd8b07ce6 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -220,7 +220,7 @@ static inline bool amdtp_stream_pcm_running(struct amdtp_stream *s)
 static inline void amdtp_stream_pcm_trigger(struct amdtp_stream *s,
 					    struct snd_pcm_substream *pcm)
 {
-	ACCESS_ONCE(s->pcm) = pcm;
+	WRITE_ONCE(s->pcm, pcm);
 }
 
 static inline bool cip_sfc_is_base_44100(enum cip_sfc sfc)

commit 7fc8e7c1d9787ab8cb0f91adb3bc9c2c64c00ef8
Merge: 8cad7a3db658 c7ecb9068e67
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 20 07:53:07 2017 +0200

    Merge branch 'for-linus' into for-next

commit 4a9bfafc64f44ef83de4e00ca1b57352af6cd8c2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 11 16:08:21 2017 +0900

    ALSA: firewire-lib: Fix stall of process context at packet error
    
    At Linux v3.5, packet processing can be done in process context of ALSA
    PCM application as well as software IRQ context for OHCI 1394. Below is
    an example of the callgraph (some calls are omitted).
    
    ioctl(2) with e.g. HWSYNC
    (sound/core/pcm_native.c)
    ->snd_pcm_common_ioctl1()
      ->snd_pcm_hwsync()
        ->snd_pcm_stream_lock_irq
        (sound/core/pcm_lib.c)
        ->snd_pcm_update_hw_ptr()
          ->snd_pcm_udpate_hw_ptr0()
            ->struct snd_pcm_ops.pointer()
            (sound/firewire/*)
            = Each handler on drivers in ALSA firewire stack
              (sound/firewire/amdtp-stream.c)
              ->amdtp_stream_pcm_pointer()
                (drivers/firewire/core-iso.c)
                ->fw_iso_context_flush_completions()
                  ->struct fw_card_driver.flush_iso_completion()
                  (drivers/firewire/ohci.c)
                  = flush_iso_completions()
                    ->struct fw_iso_context.callback.sc
                    (sound/firewire/amdtp-stream.c)
                    = in_stream_callback() or out_stream_callback()
                      ->...
        ->snd_pcm_stream_unlock_irq
    
    When packet queueing error occurs or detecting invalid packets in
    'in_stream_callback()' or 'out_stream_callback()', 'snd_pcm_stop_xrun()'
    is called on local CPU with disabled IRQ.
    
    (sound/firewire/amdtp-stream.c)
    in_stream_callback() or out_stream_callback()
    ->amdtp_stream_pcm_abort()
      ->snd_pcm_stop_xrun()
        ->snd_pcm_stream_lock_irqsave()
        ->snd_pcm_stop()
        ->snd_pcm_stream_unlock_irqrestore()
    
    The process is stalled on the CPU due to attempt to acquire recursive lock.
    
    [  562.630853] INFO: rcu_sched detected stalls on CPUs/tasks:
    [  562.630861]      2-...: (1 GPs behind) idle=37d/140000000000000/0 softirq=38323/38323 fqs=7140
    [  562.630862]      (detected by 3, t=15002 jiffies, g=21036, c=21035, q=5933)
    [  562.630866] Task dump for CPU 2:
    [  562.630867] alsa-source-OXF R  running task        0  6619      1 0x00000008
    [  562.630870] Call Trace:
    [  562.630876]  ? vt_console_print+0x79/0x3e0
    [  562.630880]  ? msg_print_text+0x9d/0x100
    [  562.630883]  ? up+0x32/0x50
    [  562.630885]  ? irq_work_queue+0x8d/0xa0
    [  562.630886]  ? console_unlock+0x2b6/0x4b0
    [  562.630888]  ? vprintk_emit+0x312/0x4a0
    [  562.630892]  ? dev_vprintk_emit+0xbf/0x230
    [  562.630895]  ? do_sys_poll+0x37a/0x550
    [  562.630897]  ? dev_printk_emit+0x4e/0x70
    [  562.630900]  ? __dev_printk+0x3c/0x80
    [  562.630903]  ? _raw_spin_lock+0x20/0x30
    [  562.630909]  ? snd_pcm_stream_lock+0x31/0x50 [snd_pcm]
    [  562.630914]  ? _snd_pcm_stream_lock_irqsave+0x2e/0x40 [snd_pcm]
    [  562.630918]  ? snd_pcm_stop_xrun+0x16/0x70 [snd_pcm]
    [  562.630922]  ? in_stream_callback+0x3e6/0x450 [snd_firewire_lib]
    [  562.630925]  ? handle_ir_packet_per_buffer+0x8e/0x1a0 [firewire_ohci]
    [  562.630928]  ? ohci_flush_iso_completions+0xa3/0x130 [firewire_ohci]
    [  562.630932]  ? fw_iso_context_flush_completions+0x15/0x20 [firewire_core]
    [  562.630935]  ? amdtp_stream_pcm_pointer+0x2d/0x40 [snd_firewire_lib]
    [  562.630938]  ? pcm_capture_pointer+0x19/0x20 [snd_oxfw]
    [  562.630943]  ? snd_pcm_update_hw_ptr0+0x47/0x3d0 [snd_pcm]
    [  562.630945]  ? poll_select_copy_remaining+0x150/0x150
    [  562.630947]  ? poll_select_copy_remaining+0x150/0x150
    [  562.630952]  ? snd_pcm_update_hw_ptr+0x10/0x20 [snd_pcm]
    [  562.630956]  ? snd_pcm_hwsync+0x45/0xb0 [snd_pcm]
    [  562.630960]  ? snd_pcm_common_ioctl1+0x1ff/0xc90 [snd_pcm]
    [  562.630962]  ? futex_wake+0x90/0x170
    [  562.630966]  ? snd_pcm_capture_ioctl1+0x136/0x260 [snd_pcm]
    [  562.630970]  ? snd_pcm_capture_ioctl+0x27/0x40 [snd_pcm]
    [  562.630972]  ? do_vfs_ioctl+0xa3/0x610
    [  562.630974]  ? vfs_read+0x11b/0x130
    [  562.630976]  ? SyS_ioctl+0x79/0x90
    [  562.630978]  ? entry_SYSCALL_64_fastpath+0x1e/0xad
    
    This commit fixes the above bug. This assumes two cases:
    1. Any error is detected in software IRQ context of OHCI 1394 context.
    In this case, PCM substream should be aborted in packet handler. On the
    other hand, it should not be done in any process context. TO distinguish
    these two context, use 'in_interrupt()' macro.
    2. Any error is detect in process context of ALSA PCM application.
    In this case, PCM substream should not be aborted in packet handler
    because PCM substream lock is acquired. The task to abort PCM substream
    should be done in ALSA PCM core. For this purpose, SNDRV_PCM_POS_XRUN is
    returned at 'struct snd_pcm_ops.pointer()'.
    
    Suggested-by: Clemens Ladisch <clemens@ladisch.de>
    Fixes: e9148dddc3c7("ALSA: firewire-lib: flush completed packets when reading PCM position")
    Cc: <stable@vger.kernel.org> # 4.9+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 7e8831722821..ea1a91e99875 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -135,7 +135,7 @@ struct amdtp_stream {
 	/* For a PCM substream processing. */
 	struct snd_pcm_substream *pcm;
 	struct tasklet_struct period_tasklet;
-	unsigned int pcm_buffer_pointer;
+	snd_pcm_uframes_t pcm_buffer_pointer;
 	unsigned int pcm_period_pointer;
 
 	/* To wait for first packet. */

commit 875becf8412c60ffae93c5f69e95a4d023f0e8ee
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 7 09:38:05 2017 +0900

    ALSA: firewire: process packets in 'struct snd_pcm_ops.ack' callback
    
    In recent commit for ALSA PCM core, some arrangement is done for
    'struct snd_pcm_ops.ack' callback. This is called when appl_ptr is
    explicitly moved in intermediate buffer for PCM frames, except for
    some cases described later.
    
    For drivers in ALSA firewire stack, usage of this callback has a merit to
    reduce latency between time of PCM frame queueing and handling actual
    packets in recent isochronous cycle, because no need to wait for software
    IRQ context from isochronous context of OHCI 1394.
    
    If this works well in a case that mapped page frame is used for the
    intermediate buffer, user process should execute some commands for ioctl(2)
    to tell the number of handled PCM frames in the intermediate buffer just
    after handling them. Therefore, at present, with a combination of below
    conditions, this doesn't work as expected and user process should wait for
    the software IRQ context as usual:
     - when ALSA PCM core judges page frame mapping is available for status
       data (struct snd_pcm_mmap_status) and control data
       (struct snd_pcm_mmap_control).
     - user process handles PCM frames by loop just with 'snd_pcm_mmap_begin()'
       and 'snd_pcm_mmap_commit()'.
     - user process uses PCM hw plugin in alsa-lib to operate I/O without
       'sync_ptr_ioctl' option.
    
    Unfortunately, major use case include these three conditions.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 7e8831722821..6d613f2eb612 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -168,6 +168,7 @@ int amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,
 
 void amdtp_stream_pcm_prepare(struct amdtp_stream *s);
 unsigned long amdtp_stream_pcm_pointer(struct amdtp_stream *s);
+int amdtp_stream_pcm_ack(struct amdtp_stream *s);
 void amdtp_stream_pcm_abort(struct amdtp_stream *s);
 
 extern const unsigned int amdtp_syt_intervals[CIP_SFC_COUNT];

commit f91c9d7610a2fe306273a83e2fd5351bceb85d28
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Apr 11 20:33:18 2017 +0900

    ALSA: firewire-lib: cache maximum length of payload to reduce function calls
    
    During packet streaming, maximum length of payload for isochronous packet
    is invariable, therefore no need to recalculate. Current ALSA IEC 61883-1/6
    engine calls a function to calculate it 8,000 or more times per second
    for incoming packet processing.
    
    This commit adds a member to have maximum length of payload into 'struct
    amdtp_stream', to reduces the function calls. At first callback from
    isochronous context, the length is calculated and stored for later
    processing.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 2bd4de4c7bb7..7e8831722821 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -110,6 +110,7 @@ struct amdtp_stream {
 	int (*handle_packet)(struct amdtp_stream *s,
 			unsigned int payload_quadlets, unsigned int cycle,
 			unsigned int index);
+	unsigned int max_payload_length;
 
 	/* For CIP headers. */
 	unsigned int source_node_id_field;

commit 3b196c394dd9f8f34064f5814bb287757c80ee35
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:07 2017 +0900

    ALSA: firewire-lib: add no-header packet processing
    
    As long as investigating Fireface 400, IEC 61883-1/6 is not applied to
    its packet streaming protocol. Remarks of the specific protocol are:
     * Each packet doesn't include CIP headers.
     * 64,0 and 128,0 kHz are supported.
     * The device doesn't necessarily transmit 8,000 packets per second.
     * 0, 1, 2, 3 are used as tag for rx isochronous packets, however 0 is
       used for tx isochronous packets.
    
    On the other hand, there's a common feature. The number of data blocks
    transferred in a second is the same as sampling transmission frequency.
    Current ALSA IEC 61883-1/6 engine already has a method to calculate it and
    this driver can utilize it for rx packets, as well as tx packets.
    
    This commit adds support for the transferring protocol. CIP_NO_HEADERS
    flag is newly added. When this flag is set:
     * Both of 0 (without CIP header) and 1 (with CIP header) are used as tag
       to handle incoming isochronous packet.
     * 0 (without CIP header) is used as tag to transfer outgoing isochronous
       packet.
     * Skip CIP header evaluation.
     * Use unique way to calculate the quadlets of isochronous packet payload.
    
    In ALSA PCM interface, 128.0 kHz is not supported, and the ALSA
    IEC 61883-1/6 engine doesn't support 64.0 kHz. These modes are dropped.
    
    The sequence of rx packet has a remarkable quirk about tag. This will be
    described in later commits.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index a31dfd849821..2bd4de4c7bb7 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -31,6 +31,7 @@
  *	allows 5 times as large as IEC 61883-6 defines.
  * @CIP_HEADER_WITHOUT_EOH: Only for in-stream. CIP Header doesn't include
  *	valid EOH.
+ * @CIP_NO_HEADERS: a lack of headers in packets
  */
 enum cip_flags {
 	CIP_NONBLOCKING		= 0x00,
@@ -42,6 +43,7 @@ enum cip_flags {
 	CIP_EMPTY_HAS_WRONG_DBC	= 0x20,
 	CIP_JUMBO_PAYLOAD	= 0x40,
 	CIP_HEADER_WITHOUT_EOH	= 0x80,
+	CIP_NO_HEADER		= 0x100,
 };
 
 /**
@@ -104,6 +106,10 @@ struct amdtp_stream {
 	struct fw_iso_context *context;
 	struct iso_packets_buffer buffer;
 	int packet_index;
+	int tag;
+	int (*handle_packet)(struct amdtp_stream *s,
+			unsigned int payload_quadlets, unsigned int cycle,
+			unsigned int index);
 
 	/* For CIP headers. */
 	unsigned int source_node_id_field;

commit 2128f78f75a36a34dfef0e127273c2f820c5c904
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:27 2017 +0900

    ALSA: firewire-lib: add a quirk of packet without valid EOH in CIP format
    
    In IEC 61883-1, when two quadlets CIP header is used, the most significant
    bit in second CIP header stands. However, packets from units with MOTU
    protocol version 3 have a quirk without this flag. Current packet streaming
    layer handles this as protocol error.
    
    This commit adds a new enumeration constant for this quirk, to handle MOTU
    protocol version 3.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index d2a316309704..a31dfd849821 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -29,6 +29,8 @@
  * @CIP_JUMBO_PAYLOAD: Only for in-stream. The number of data blocks in an
  *	packet is larger than IEC 61883-6 defines. Current implementation
  *	allows 5 times as large as IEC 61883-6 defines.
+ * @CIP_HEADER_WITHOUT_EOH: Only for in-stream. CIP Header doesn't include
+ *	valid EOH.
  */
 enum cip_flags {
 	CIP_NONBLOCKING		= 0x00,
@@ -39,6 +41,7 @@ enum cip_flags {
 	CIP_SKIP_DBC_ZERO_CHECK	= 0x10,
 	CIP_EMPTY_HAS_WRONG_DBC	= 0x20,
 	CIP_JUMBO_PAYLOAD	= 0x40,
+	CIP_HEADER_WITHOUT_EOH	= 0x80,
 };
 
 /**

commit 9dae017bf69b1c5aacba7be18cb734b66df30a37
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:17 2017 +0900

    ALSA: firewire-lib: enable CIP_DBC_IS_END_EVENT for both directions of stream
    
    Commit c8bdf49b9935("ALSA: fireworks/firewire-lib: Add a quirk for the
    meaning of dbc") adds CIP_DBC_IS_END_EVENT flag just for tx packets.
    However, MOTU FireWire series has this quirk for rx packets.
    
    This commit allows both directions with the flag.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 679053d9c28f..d2a316309704 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -18,8 +18,8 @@
  *	SYT_INTERVAL samples, with these two types alternating so that
  *	the overall sample rate comes out right.
  * @CIP_EMPTY_WITH_TAG0: Only for in-stream. Empty in-packets have TAG0.
- * @CIP_DBC_IS_END_EVENT: Only for in-stream. The value of dbc in an in-packet
- *	corresponds to the end of event in the packet. Out of IEC 61883.
+ * @CIP_DBC_IS_END_EVENT: The value of dbc in an packet corresponds to the end
+ * of event in the packet. Out of IEC 61883.
  * @CIP_WRONG_DBS: Only for in-stream. The value of dbs is wrong in in-packets.
  *	The value of data_block_quadlets is used instead of reported value.
  * @CIP_SKIP_DBC_ZERO_CHECK: Only for in-stream.  Packets with zero in dbc is

commit 9863874f02e1cca65bdb112336250890b2ded64a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:16 2017 +0900

    ALSA: firewire-lib: add support for source packet header field in CIP header
    
    In IEC 61883-1, CIP headers can have a SPH field. When a packet has 1 in
    SPH field of its CIP header, the packet has a source packet headers. A
    source packet header consists of 32 bit field (= 1 quadlet) and it
    transfers time stamp, which is the same value as the lower 25 bits of the
    IEEE 1394 CYCLE_TIMER register and the rest is zero.
    
    This commit just supports source packet header field because IEC 61883-1
    includes ambiguity the position of this header and its count. Each
    protocol layer is allowed to have actual implementation according its
    requirements.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index edf5646b3708..679053d9c28f 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -106,6 +106,7 @@ struct amdtp_stream {
 	unsigned int source_node_id_field;
 	unsigned int data_block_quadlets;
 	unsigned int data_block_counter;
+	unsigned int sph;
 	unsigned int fmt;
 	unsigned int fdf;
 	/* quirk: fixed interval of dbc between previos/current packets. */

commit a04513f8b1980e7ddd9082461aceaf8b3e8f4981
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:15 2017 +0900

    ALSA: firewire-lib: record cycle count for the first packet
    
    Currently, packet streaming layer passes generated SYT value to data block
    processing layer. However, this is not enough in a case that the data block
    processing layer generates time stamps by its own ways.
    
    For out-packet stream, the packet streaming layer guarantees 8,000 times
    calls of data block processing layers per sec. Therefore, when cycle count
    of the first packet is recorded, data block processing layers can calculate
    own time stamps with the recorded value.
    
    For the reason, this commit allows packet streaming layer to record the
    first cycle count. Each data block processing layer can read the count by
    accessing a member of structure for packet streaming layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index c1bc7fad056e..edf5646b3708 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -130,6 +130,7 @@ struct amdtp_stream {
 	/* To wait for first packet. */
 	bool callbacked;
 	wait_queue_head_t callback_wait;
+	u32 start_cycle;
 
 	/* For backends to process data blocks. */
 	void *protocol;

commit 1dba9db0eaa64d362d9d9afb5eeaececdaef948d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu May 12 02:17:39 2016 +0900

    ALSA: firewire-lib: permit to flush queued packets only in process context for better PCM period granularity
    
    These three commits were merged to improve PCM pointer granularity.
    commit 76fb87894828 ("ALSA: firewire-lib: taskletize the snd_pcm_period_elapsed() call")
    commit e9148dddc3c7 ("ALSA: firewire-lib: flush completed packets when reading PCM position")
    commit 92b862c7d685 ("ALSA: firewire-lib: optimize packet flushing")
    
    The point of them is to handle queued packets not only in software IRQ
    context of IR/IT contexts, but also in process context. As a result of
    handling packets, period tasklet is scheduled when acrossing PCM period
    boundary. This is to prevent recursive call of
    'struct snd_pcm_ops.pointer()' in the same context.
    
    When the pointer callback is executed in the process context, it's
    better to avoid the second callback in the software IRQ context. The
    software IRQ context runs immediately after scheduled in the process
    context because few packets are queued yet.
    
    For the aim, 'pointer_flush' is used, however it causes a race condition
    between the process context and software IRQ context of IR/IT contexts.
    
    Practically, this race is not so critical because it influences process
    context to skip flushing queued packet and to get worse granularity of
    PCM pointer. The race condition is quite rare but it should be improved
    for stable service.
    
    The similar effect can be achieved by using 'in_interrupt()' macro. This
    commit obsoletes 'pointer_flush' with it.
    
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 349c405f3d99..c1bc7fad056e 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -126,7 +126,6 @@ struct amdtp_stream {
 	struct tasklet_struct period_tasklet;
 	unsigned int pcm_buffer_pointer;
 	unsigned int pcm_period_pointer;
-	bool pointer_flush;
 
 	/* To wait for first packet. */
 	bool callbacked;

commit 62f00e40b0718ebd8bd54fc7a9e89e873524d495
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon May 9 23:15:56 2016 +0900

    ALSA: firewire-lib: enable the same feature as CIP_SKIP_INIT_DBC_CHECK flag
    
    In former commit, drivers in ALSA firewire stack always starts IT context
    before IR context. If IR context starts after packets are transmitted by
    peer unit, packet discontinuity may be detected because the context starts
    in the middle of packet streaming. This situation is rare because IT
    context usually starts immediately. However, it's better to solve this
    issue. This is suppressed with CIP_SKIP_INIT_DBC_CHECK flag.
    
    This commit enables the same feature as CIP_SKIP_INIT_DBC_CHECK.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index da028b0afb48..349c405f3d99 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -24,8 +24,6 @@
  *	The value of data_block_quadlets is used instead of reported value.
  * @CIP_SKIP_DBC_ZERO_CHECK: Only for in-stream.  Packets with zero in dbc is
  *	skipped for detecting discontinuity.
- * @CIP_SKIP_INIT_DBC_CHECK: Only for in-stream. The value of dbc in first
- *	packet is not continuous from an initial value.
  * @CIP_EMPTY_HAS_WRONG_DBC: Only for in-stream. The value of dbc in empty
  *	packet is wrong but the others are correct.
  * @CIP_JUMBO_PAYLOAD: Only for in-stream. The number of data blocks in an
@@ -39,9 +37,8 @@ enum cip_flags {
 	CIP_DBC_IS_END_EVENT	= 0x04,
 	CIP_WRONG_DBS		= 0x08,
 	CIP_SKIP_DBC_ZERO_CHECK	= 0x10,
-	CIP_SKIP_INIT_DBC_CHECK	= 0x20,
-	CIP_EMPTY_HAS_WRONG_DBC	= 0x40,
-	CIP_JUMBO_PAYLOAD	= 0x80,
+	CIP_EMPTY_HAS_WRONG_DBC	= 0x20,
+	CIP_JUMBO_PAYLOAD	= 0x40,
 };
 
 /**

commit dec63cc8b65b04c0ebb5d82b6b399665d6d44dca
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon May 9 23:15:53 2016 +0900

    ALSA: firewire-lib: handle IT/IR contexts in each software interrupt context
    
    In clause 6.3 of IEC 61883-6:2000, there's an explanation about processing
    of presentation timestamp. In the clause, we can see "If a function block
    receives a CIP, processes it and subsequently re-transmits it, then the
    SYT of the outgoing CIP shall be the sum of the incoming SYT and the
    processing delay." ALSA firewire stack has an implementation to partly
    satisfy this specification. Developers assumed the stack to perform as an
    Audio function block[1].
    
    Following to the assumption, current implementation of ALSA firewire stack
    use one software interrupt context to handle both of in/out packets. In
    most case, this is processed in 1394 OHCI IR context independently of the
    opposite context. Thus, this implementation uses longer CPU time in the
    software interrupt context. This is not better for whole system.
    
    Against the assumption, I confirmed that each ASIC for IEC 61883-1/6
    doesn't necessarily expect it to the stack. Thus, current implementation
    of ALSA firewire stack includes over-engineering.
    
    This commit purges the implementation. As a result, packets of one
    direction are handled in one software interrupt context and spends
    minimum CPU time.
    
    [1] [alsa-devel] [PATCH 0/8] [RFC] new driver for Echo Audio's Fireworks based devices
    http://mailman.alsa-project.org/pipermail/alsa-devel/2013-June/062660.html
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 8775704a3665..da028b0afb48 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -17,8 +17,6 @@
  * @CIP_BLOCKING: In blocking mode, each packet contains either zero or
  *	SYT_INTERVAL samples, with these two types alternating so that
  *	the overall sample rate comes out right.
- * @CIP_SYNC_TO_DEVICE: In sync to device mode, time stamp in out packets is
- *	generated by in packets. Defaultly this driver generates timestamp.
  * @CIP_EMPTY_WITH_TAG0: Only for in-stream. Empty in-packets have TAG0.
  * @CIP_DBC_IS_END_EVENT: Only for in-stream. The value of dbc in an in-packet
  *	corresponds to the end of event in the packet. Out of IEC 61883.
@@ -37,14 +35,13 @@
 enum cip_flags {
 	CIP_NONBLOCKING		= 0x00,
 	CIP_BLOCKING		= 0x01,
-	CIP_SYNC_TO_DEVICE	= 0x02,
-	CIP_EMPTY_WITH_TAG0	= 0x04,
-	CIP_DBC_IS_END_EVENT	= 0x08,
-	CIP_WRONG_DBS		= 0x10,
-	CIP_SKIP_DBC_ZERO_CHECK	= 0x20,
-	CIP_SKIP_INIT_DBC_CHECK	= 0x40,
-	CIP_EMPTY_HAS_WRONG_DBC	= 0x80,
-	CIP_JUMBO_PAYLOAD	= 0x100,
+	CIP_EMPTY_WITH_TAG0	= 0x02,
+	CIP_DBC_IS_END_EVENT	= 0x04,
+	CIP_WRONG_DBS		= 0x08,
+	CIP_SKIP_DBC_ZERO_CHECK	= 0x10,
+	CIP_SKIP_INIT_DBC_CHECK	= 0x20,
+	CIP_EMPTY_HAS_WRONG_DBC	= 0x40,
+	CIP_JUMBO_PAYLOAD	= 0x80,
 };
 
 /**
@@ -137,7 +134,6 @@ struct amdtp_stream {
 	/* To wait for first packet. */
 	bool callbacked;
 	wait_queue_head_t callback_wait;
-	struct amdtp_stream *sync_slave;
 
 	/* For backends to process data blocks. */
 	void *protocol;
@@ -223,23 +219,6 @@ static inline bool cip_sfc_is_base_44100(enum cip_sfc sfc)
 	return sfc & 1;
 }
 
-static inline void amdtp_stream_set_sync(enum cip_flags sync_mode,
-					 struct amdtp_stream *master,
-					 struct amdtp_stream *slave)
-{
-	if (sync_mode == CIP_SYNC_TO_DEVICE) {
-		master->flags |= CIP_SYNC_TO_DEVICE;
-		slave->flags |= CIP_SYNC_TO_DEVICE;
-		master->sync_slave = slave;
-	} else {
-		master->flags &= ~CIP_SYNC_TO_DEVICE;
-		slave->flags &= ~CIP_SYNC_TO_DEVICE;
-		master->sync_slave = NULL;
-	}
-
-	slave->sync_slave = NULL;
-}
-
 /**
  * amdtp_stream_wait_callback - sleep till callbacked or timeout
  * @s: the AMDTP stream

commit df075feefbd347f13fba5198294cda619532c237
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:22:02 2015 +0900

    ALSA: firewire-lib: complete AM824 data block processing layer
    
    This commit moves the codes related to data block processing from packet
    streaming layer to AM824 layer.
    
    Each driver initializes amdtp stream structure for AM824 data block by
    calling amdtp_am824_init(). Then, a memory block is allocated for AM824
    specific structure. This memory block is released by calling
    amdtp_stream_destroy().
    
    When setting streaming parameters, it calls amdtp_am824_set_parameters().
    When starting packet streaming, it calls amdtp_stream_start(). When
    stopping packet streaming, it calls amdtp_stream_stop().
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 71f4f751fabc..8775704a3665 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -81,39 +81,22 @@ enum cip_sfc {
 	CIP_SFC_COUNT
 };
 
-#define AM824_IN_PCM_FORMAT_BITS	SNDRV_PCM_FMTBIT_S32
-
-#define AM824_OUT_PCM_FORMAT_BITS	(SNDRV_PCM_FMTBIT_S16 | \
-					 SNDRV_PCM_FMTBIT_S32)
-
-
-/*
- * This module supports maximum 64 PCM channels for one PCM stream
- * This is for our convenience.
- */
-#define AM824_MAX_CHANNELS_FOR_PCM	64
-
-/*
- * AMDTP packet can include channels for MIDI conformant data.
- * Each MIDI conformant data channel includes 8 MPX-MIDI data stream.
- * Each MPX-MIDI data stream includes one data stream from/to MIDI ports.
- *
- * This module supports maximum 1 MIDI conformant data channels.
- * Then this AMDTP packets can transfer maximum 8 MIDI data streams.
- */
-#define AM824_MAX_CHANNELS_FOR_MIDI	1
-
 struct fw_unit;
 struct fw_iso_context;
 struct snd_pcm_substream;
 struct snd_pcm_runtime;
-struct snd_rawmidi_substream;
 
 enum amdtp_stream_direction {
 	AMDTP_OUT_STREAM = 0,
 	AMDTP_IN_STREAM
 };
 
+struct amdtp_stream;
+typedef unsigned int (*amdtp_stream_process_data_blocks_t)(
+						struct amdtp_stream *s,
+						__be32 *buffer,
+						unsigned int data_blocks,
+						unsigned int *syt);
 struct amdtp_stream {
 	struct fw_unit *unit;
 	enum cip_flags flags;
@@ -156,32 +139,20 @@ struct amdtp_stream {
 	wait_queue_head_t callback_wait;
 	struct amdtp_stream *sync_slave;
 
-	/* For AM824 processing. */
-	struct snd_rawmidi_substream *midi[AM824_MAX_CHANNELS_FOR_MIDI * 8];
-	int midi_fifo_limit;
-	int midi_fifo_used[AM824_MAX_CHANNELS_FOR_MIDI * 8];
-	unsigned int pcm_channels;
-	unsigned int midi_ports;
-
-	u8 pcm_positions[AM824_MAX_CHANNELS_FOR_PCM];
-	u8 midi_position;
-
-	void (*transfer_samples)(struct amdtp_stream *s,
-				 struct snd_pcm_substream *pcm,
-				 __be32 *buffer, unsigned int frames);
-
-	unsigned int frame_multiplier;
+	/* For backends to process data blocks. */
+	void *protocol;
+	amdtp_stream_process_data_blocks_t process_data_blocks;
 };
 
 int amdtp_stream_init(struct amdtp_stream *s, struct fw_unit *unit,
-		      enum amdtp_stream_direction dir,
-		      enum cip_flags flags, unsigned int fmt);
+		      enum amdtp_stream_direction dir, enum cip_flags flags,
+		      unsigned int fmt,
+		      amdtp_stream_process_data_blocks_t process_data_blocks,
+		      unsigned int protocol_size);
 void amdtp_stream_destroy(struct amdtp_stream *s);
 
-int amdtp_stream_set_parameters(struct amdtp_stream *s,
-				unsigned int rate,
-				unsigned int pcm_channels,
-				unsigned int midi_ports);
+int amdtp_stream_set_parameters(struct amdtp_stream *s, unsigned int rate,
+				unsigned int data_block_quadlets);
 unsigned int amdtp_stream_get_max_payload(struct amdtp_stream *s);
 
 int amdtp_stream_start(struct amdtp_stream *s, int channel, int speed);
@@ -190,8 +161,7 @@ void amdtp_stream_stop(struct amdtp_stream *s);
 
 int amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,
 					struct snd_pcm_runtime *runtime);
-void amdtp_am824_set_pcm_format(struct amdtp_stream *s,
-				snd_pcm_format_t format);
+
 void amdtp_stream_pcm_prepare(struct amdtp_stream *s);
 unsigned long amdtp_stream_pcm_pointer(struct amdtp_stream *s);
 void amdtp_stream_pcm_abort(struct amdtp_stream *s);

commit 49c7b3fcd9f0a0125e8cd8212d5576382198eeb2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:22:01 2015 +0900

    ALSA: firewire-lib: rename macros with AM824 prefix
    
    This commit renames some macros just related to AM824 format. In later
    commit, they're moved to AM824 layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 3fb82c753f7b..71f4f751fabc 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -81,9 +81,9 @@ enum cip_sfc {
 	CIP_SFC_COUNT
 };
 
-#define AMDTP_IN_PCM_FORMAT_BITS	SNDRV_PCM_FMTBIT_S32
+#define AM824_IN_PCM_FORMAT_BITS	SNDRV_PCM_FMTBIT_S32
 
-#define AMDTP_OUT_PCM_FORMAT_BITS	(SNDRV_PCM_FMTBIT_S16 | \
+#define AM824_OUT_PCM_FORMAT_BITS	(SNDRV_PCM_FMTBIT_S16 | \
 					 SNDRV_PCM_FMTBIT_S32)
 
 
@@ -91,7 +91,7 @@ enum cip_sfc {
  * This module supports maximum 64 PCM channels for one PCM stream
  * This is for our convenience.
  */
-#define AMDTP_MAX_CHANNELS_FOR_PCM	64
+#define AM824_MAX_CHANNELS_FOR_PCM	64
 
 /*
  * AMDTP packet can include channels for MIDI conformant data.
@@ -101,7 +101,7 @@ enum cip_sfc {
  * This module supports maximum 1 MIDI conformant data channels.
  * Then this AMDTP packets can transfer maximum 8 MIDI data streams.
  */
-#define AMDTP_MAX_CHANNELS_FOR_MIDI	1
+#define AM824_MAX_CHANNELS_FOR_MIDI	1
 
 struct fw_unit;
 struct fw_iso_context;
@@ -157,13 +157,13 @@ struct amdtp_stream {
 	struct amdtp_stream *sync_slave;
 
 	/* For AM824 processing. */
-	struct snd_rawmidi_substream *midi[AMDTP_MAX_CHANNELS_FOR_MIDI * 8];
+	struct snd_rawmidi_substream *midi[AM824_MAX_CHANNELS_FOR_MIDI * 8];
 	int midi_fifo_limit;
-	int midi_fifo_used[AMDTP_MAX_CHANNELS_FOR_MIDI * 8];
+	int midi_fifo_used[AM824_MAX_CHANNELS_FOR_MIDI * 8];
 	unsigned int pcm_channels;
 	unsigned int midi_ports;
 
-	u8 pcm_positions[AMDTP_MAX_CHANNELS_FOR_PCM];
+	u8 pcm_positions[AM824_MAX_CHANNELS_FOR_PCM];
 	u8 midi_position;
 
 	void (*transfer_samples)(struct amdtp_stream *s,

commit 85130cb43e78a7bdb2ade10131563d89fbbddf9d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:22:00 2015 +0900

    ALSA: firewire-lib: rename PCM format helper function
    
    Setting the format of PCM substream to AMDTP stream structure is important
    to set a handler to copy actual PCM samples between buffers. The
    processing should be in data block processing layer because essentially
    it has no relationship to packet streaming.
    
    This commit renames PCM format setting function to prepare for integrating
    AM824 layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 984f02ac2aed..3fb82c753f7b 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -190,8 +190,8 @@ void amdtp_stream_stop(struct amdtp_stream *s);
 
 int amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,
 					struct snd_pcm_runtime *runtime);
-void amdtp_stream_set_pcm_format(struct amdtp_stream *s,
-				 snd_pcm_format_t format);
+void amdtp_am824_set_pcm_format(struct amdtp_stream *s,
+				snd_pcm_format_t format);
 void amdtp_stream_pcm_prepare(struct amdtp_stream *s);
 unsigned long amdtp_stream_pcm_pointer(struct amdtp_stream *s);
 void amdtp_stream_pcm_abort(struct amdtp_stream *s);

commit 03e2a67eed7bf2e4c701587080bc8d60dd45209c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:59 2015 +0900

    ALSA: firewire-lib: move MIDI trigger helper function to AM824 layer
    
    In IEC 61883-6, MIDI messages are transferred in MIDI conformant data
    channel. Essentially, packet streaming layer is not responsible for MIDI
    functionality.
    
    This commit moves MIDI trigger helper function from the layer to AM824
    layer. The rest of codes related to MIDI functionality will be moved in
    later commits.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index d915940a14c9..984f02ac2aed 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -248,24 +248,6 @@ static inline void amdtp_stream_pcm_trigger(struct amdtp_stream *s,
 	ACCESS_ONCE(s->pcm) = pcm;
 }
 
-/**
- * amdtp_stream_midi_trigger - start/stop playback/capture with a MIDI device
- * @s: the AMDTP stream
- * @port: index of MIDI port
- * @midi: the MIDI device to be started, or %NULL to stop the current device
- *
- * Call this function on a running isochronous stream to enable the actual
- * transmission of MIDI data.  This function should be called from the MIDI
- * device's .trigger callback.
- */
-static inline void amdtp_stream_midi_trigger(struct amdtp_stream *s,
-					     unsigned int port,
-					     struct snd_rawmidi_substream *midi)
-{
-	if (port < s->midi_ports)
-		ACCESS_ONCE(s->midi[port]) = midi;
-}
-
 static inline bool cip_sfc_is_base_44100(enum cip_sfc sfc)
 {
 	return sfc & 1;

commit 51c29fd21389d9995a8a18a91eeb8dd1220a2119
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:56 2015 +0900

    ALSA: firewire-lib: rename parameter setting function for AM824 with FDF field
    
    The value of FDF field in CIP header is protocol-dependent. Thus, it's
    better to allow data block processing layer to decide the value in any
    timing.
    
    In AM824 data format, the value of FDF field in CIP header indicates
    N-flag and Nominal Sampling Frequency Code (sfc). The N-flag is for
    switching 'Clock-based rate control mode' and 'Command-based rate control
    mode'. In our implementation, 'Clock-based rate control mode' is just
    supported. Therefore, When sampling transfer frequency is decided, then
    the FDF can be set.
    
    This commit replaces 'amdtp_stream_set_parameters' with
    'amdtp_am824_set_parameters' to set the FDF. This is the same timing
    to decide the ration between the number of data blocks and the number of
    PCM frames.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 5f96affe37b7..d915940a14c9 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -181,8 +181,7 @@ void amdtp_stream_destroy(struct amdtp_stream *s);
 int amdtp_stream_set_parameters(struct amdtp_stream *s,
 				unsigned int rate,
 				unsigned int pcm_channels,
-				unsigned int midi_ports,
-				bool double_pcm_frames);
+				unsigned int midi_ports);
 unsigned int amdtp_stream_get_max_payload(struct amdtp_stream *s);
 
 int amdtp_stream_start(struct amdtp_stream *s, int channel, int speed);

commit 5955815e71ff9c773b156680c781c87728e37bea
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:55 2015 +0900

    ALSA: firewire-lib: add data block processing layer for AM824 format
    
    This commit adds data block processing layer for AM824 format. The new
    layer initializes streaming layer with its value for fmt field.
    
    Currently, most implementation of data block processing still remains
    streaming layer. In later commits, these codes will be moved to the layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
index 883bb1a7e25f..5f96affe37b7 100644
--- a/sound/firewire/amdtp-stream.h
+++ b/sound/firewire/amdtp-stream.h
@@ -4,6 +4,7 @@
 #include <linux/err.h>
 #include <linux/interrupt.h>
 #include <linux/mutex.h>
+#include <linux/sched.h>
 #include <sound/asound.h>
 #include "packets-buffer.h"
 
@@ -174,7 +175,7 @@ struct amdtp_stream {
 
 int amdtp_stream_init(struct amdtp_stream *s, struct fw_unit *unit,
 		      enum amdtp_stream_direction dir,
-		      enum cip_flags flags);
+		      enum cip_flags flags, unsigned int fmt);
 void amdtp_stream_destroy(struct amdtp_stream *s);
 
 int amdtp_stream_set_parameters(struct amdtp_stream *s,

commit d67c46b953749aef223496ec95b7bf93e40887dc
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:54 2015 +0900

    ALSA: firewire-lib: rename 'amdtp' to 'amdtp-stream' to prepare for functional separation
    
    In later commit, data block processing layer will be newly added. This
    layer will be named as 'amdtp-am824'.
    
    This commit renames current amdtp file to amdtp-stream, to distinguish it
    from the new layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h
new file mode 100644
index 000000000000..883bb1a7e25f
--- /dev/null
+++ b/sound/firewire/amdtp-stream.h
@@ -0,0 +1,306 @@
+#ifndef SOUND_FIREWIRE_AMDTP_H_INCLUDED
+#define SOUND_FIREWIRE_AMDTP_H_INCLUDED
+
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <sound/asound.h>
+#include "packets-buffer.h"
+
+/**
+ * enum cip_flags - describes details of the streaming protocol
+ * @CIP_NONBLOCKING: In non-blocking mode, each packet contains
+ *	sample_rate/8000 samples, with rounding up or down to adjust
+ *	for clock skew and left-over fractional samples.  This should
+ *	be used if supported by the device.
+ * @CIP_BLOCKING: In blocking mode, each packet contains either zero or
+ *	SYT_INTERVAL samples, with these two types alternating so that
+ *	the overall sample rate comes out right.
+ * @CIP_SYNC_TO_DEVICE: In sync to device mode, time stamp in out packets is
+ *	generated by in packets. Defaultly this driver generates timestamp.
+ * @CIP_EMPTY_WITH_TAG0: Only for in-stream. Empty in-packets have TAG0.
+ * @CIP_DBC_IS_END_EVENT: Only for in-stream. The value of dbc in an in-packet
+ *	corresponds to the end of event in the packet. Out of IEC 61883.
+ * @CIP_WRONG_DBS: Only for in-stream. The value of dbs is wrong in in-packets.
+ *	The value of data_block_quadlets is used instead of reported value.
+ * @CIP_SKIP_DBC_ZERO_CHECK: Only for in-stream.  Packets with zero in dbc is
+ *	skipped for detecting discontinuity.
+ * @CIP_SKIP_INIT_DBC_CHECK: Only for in-stream. The value of dbc in first
+ *	packet is not continuous from an initial value.
+ * @CIP_EMPTY_HAS_WRONG_DBC: Only for in-stream. The value of dbc in empty
+ *	packet is wrong but the others are correct.
+ * @CIP_JUMBO_PAYLOAD: Only for in-stream. The number of data blocks in an
+ *	packet is larger than IEC 61883-6 defines. Current implementation
+ *	allows 5 times as large as IEC 61883-6 defines.
+ */
+enum cip_flags {
+	CIP_NONBLOCKING		= 0x00,
+	CIP_BLOCKING		= 0x01,
+	CIP_SYNC_TO_DEVICE	= 0x02,
+	CIP_EMPTY_WITH_TAG0	= 0x04,
+	CIP_DBC_IS_END_EVENT	= 0x08,
+	CIP_WRONG_DBS		= 0x10,
+	CIP_SKIP_DBC_ZERO_CHECK	= 0x20,
+	CIP_SKIP_INIT_DBC_CHECK	= 0x40,
+	CIP_EMPTY_HAS_WRONG_DBC	= 0x80,
+	CIP_JUMBO_PAYLOAD	= 0x100,
+};
+
+/**
+ * enum cip_sfc - supported Sampling Frequency Codes (SFCs)
+ * @CIP_SFC_32000:   32,000 data blocks
+ * @CIP_SFC_44100:   44,100 data blocks
+ * @CIP_SFC_48000:   48,000 data blocks
+ * @CIP_SFC_88200:   88,200 data blocks
+ * @CIP_SFC_96000:   96,000 data blocks
+ * @CIP_SFC_176400: 176,400 data blocks
+ * @CIP_SFC_192000: 192,000 data blocks
+ * @CIP_SFC_COUNT: the number of supported SFCs
+ *
+ * These values are used to show nominal Sampling Frequency Code in
+ * Format Dependent Field (FDF) of AMDTP packet header. In IEC 61883-6:2002,
+ * this code means the number of events per second. Actually the code
+ * represents the number of data blocks transferred per second in an AMDTP
+ * stream.
+ *
+ * In IEC 61883-6:2005, some extensions were added to support more types of
+ * data such as 'One Bit LInear Audio', therefore the meaning of SFC became
+ * different depending on the types.
+ *
+ * Currently our implementation is compatible with IEC 61883-6:2002.
+ */
+enum cip_sfc {
+	CIP_SFC_32000  = 0,
+	CIP_SFC_44100  = 1,
+	CIP_SFC_48000  = 2,
+	CIP_SFC_88200  = 3,
+	CIP_SFC_96000  = 4,
+	CIP_SFC_176400 = 5,
+	CIP_SFC_192000 = 6,
+	CIP_SFC_COUNT
+};
+
+#define AMDTP_IN_PCM_FORMAT_BITS	SNDRV_PCM_FMTBIT_S32
+
+#define AMDTP_OUT_PCM_FORMAT_BITS	(SNDRV_PCM_FMTBIT_S16 | \
+					 SNDRV_PCM_FMTBIT_S32)
+
+
+/*
+ * This module supports maximum 64 PCM channels for one PCM stream
+ * This is for our convenience.
+ */
+#define AMDTP_MAX_CHANNELS_FOR_PCM	64
+
+/*
+ * AMDTP packet can include channels for MIDI conformant data.
+ * Each MIDI conformant data channel includes 8 MPX-MIDI data stream.
+ * Each MPX-MIDI data stream includes one data stream from/to MIDI ports.
+ *
+ * This module supports maximum 1 MIDI conformant data channels.
+ * Then this AMDTP packets can transfer maximum 8 MIDI data streams.
+ */
+#define AMDTP_MAX_CHANNELS_FOR_MIDI	1
+
+struct fw_unit;
+struct fw_iso_context;
+struct snd_pcm_substream;
+struct snd_pcm_runtime;
+struct snd_rawmidi_substream;
+
+enum amdtp_stream_direction {
+	AMDTP_OUT_STREAM = 0,
+	AMDTP_IN_STREAM
+};
+
+struct amdtp_stream {
+	struct fw_unit *unit;
+	enum cip_flags flags;
+	enum amdtp_stream_direction direction;
+	struct mutex mutex;
+
+	/* For packet processing. */
+	struct fw_iso_context *context;
+	struct iso_packets_buffer buffer;
+	int packet_index;
+
+	/* For CIP headers. */
+	unsigned int source_node_id_field;
+	unsigned int data_block_quadlets;
+	unsigned int data_block_counter;
+	unsigned int fmt;
+	unsigned int fdf;
+	/* quirk: fixed interval of dbc between previos/current packets. */
+	unsigned int tx_dbc_interval;
+	/* quirk: indicate the value of dbc field in a first packet. */
+	unsigned int tx_first_dbc;
+
+	/* Internal flags. */
+	enum cip_sfc sfc;
+	unsigned int syt_interval;
+	unsigned int transfer_delay;
+	unsigned int data_block_state;
+	unsigned int last_syt_offset;
+	unsigned int syt_offset_state;
+
+	/* For a PCM substream processing. */
+	struct snd_pcm_substream *pcm;
+	struct tasklet_struct period_tasklet;
+	unsigned int pcm_buffer_pointer;
+	unsigned int pcm_period_pointer;
+	bool pointer_flush;
+
+	/* To wait for first packet. */
+	bool callbacked;
+	wait_queue_head_t callback_wait;
+	struct amdtp_stream *sync_slave;
+
+	/* For AM824 processing. */
+	struct snd_rawmidi_substream *midi[AMDTP_MAX_CHANNELS_FOR_MIDI * 8];
+	int midi_fifo_limit;
+	int midi_fifo_used[AMDTP_MAX_CHANNELS_FOR_MIDI * 8];
+	unsigned int pcm_channels;
+	unsigned int midi_ports;
+
+	u8 pcm_positions[AMDTP_MAX_CHANNELS_FOR_PCM];
+	u8 midi_position;
+
+	void (*transfer_samples)(struct amdtp_stream *s,
+				 struct snd_pcm_substream *pcm,
+				 __be32 *buffer, unsigned int frames);
+
+	unsigned int frame_multiplier;
+};
+
+int amdtp_stream_init(struct amdtp_stream *s, struct fw_unit *unit,
+		      enum amdtp_stream_direction dir,
+		      enum cip_flags flags);
+void amdtp_stream_destroy(struct amdtp_stream *s);
+
+int amdtp_stream_set_parameters(struct amdtp_stream *s,
+				unsigned int rate,
+				unsigned int pcm_channels,
+				unsigned int midi_ports,
+				bool double_pcm_frames);
+unsigned int amdtp_stream_get_max_payload(struct amdtp_stream *s);
+
+int amdtp_stream_start(struct amdtp_stream *s, int channel, int speed);
+void amdtp_stream_update(struct amdtp_stream *s);
+void amdtp_stream_stop(struct amdtp_stream *s);
+
+int amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,
+					struct snd_pcm_runtime *runtime);
+void amdtp_stream_set_pcm_format(struct amdtp_stream *s,
+				 snd_pcm_format_t format);
+void amdtp_stream_pcm_prepare(struct amdtp_stream *s);
+unsigned long amdtp_stream_pcm_pointer(struct amdtp_stream *s);
+void amdtp_stream_pcm_abort(struct amdtp_stream *s);
+
+extern const unsigned int amdtp_syt_intervals[CIP_SFC_COUNT];
+extern const unsigned int amdtp_rate_table[CIP_SFC_COUNT];
+
+/**
+ * amdtp_stream_running - check stream is running or not
+ * @s: the AMDTP stream
+ *
+ * If this function returns true, the stream is running.
+ */
+static inline bool amdtp_stream_running(struct amdtp_stream *s)
+{
+	return !IS_ERR(s->context);
+}
+
+/**
+ * amdtp_streaming_error - check for streaming error
+ * @s: the AMDTP stream
+ *
+ * If this function returns true, the stream's packet queue has stopped due to
+ * an asynchronous error.
+ */
+static inline bool amdtp_streaming_error(struct amdtp_stream *s)
+{
+	return s->packet_index < 0;
+}
+
+/**
+ * amdtp_stream_pcm_running - check PCM substream is running or not
+ * @s: the AMDTP stream
+ *
+ * If this function returns true, PCM substream in the AMDTP stream is running.
+ */
+static inline bool amdtp_stream_pcm_running(struct amdtp_stream *s)
+{
+	return !!s->pcm;
+}
+
+/**
+ * amdtp_stream_pcm_trigger - start/stop playback from a PCM device
+ * @s: the AMDTP stream
+ * @pcm: the PCM device to be started, or %NULL to stop the current device
+ *
+ * Call this function on a running isochronous stream to enable the actual
+ * transmission of PCM data.  This function should be called from the PCM
+ * device's .trigger callback.
+ */
+static inline void amdtp_stream_pcm_trigger(struct amdtp_stream *s,
+					    struct snd_pcm_substream *pcm)
+{
+	ACCESS_ONCE(s->pcm) = pcm;
+}
+
+/**
+ * amdtp_stream_midi_trigger - start/stop playback/capture with a MIDI device
+ * @s: the AMDTP stream
+ * @port: index of MIDI port
+ * @midi: the MIDI device to be started, or %NULL to stop the current device
+ *
+ * Call this function on a running isochronous stream to enable the actual
+ * transmission of MIDI data.  This function should be called from the MIDI
+ * device's .trigger callback.
+ */
+static inline void amdtp_stream_midi_trigger(struct amdtp_stream *s,
+					     unsigned int port,
+					     struct snd_rawmidi_substream *midi)
+{
+	if (port < s->midi_ports)
+		ACCESS_ONCE(s->midi[port]) = midi;
+}
+
+static inline bool cip_sfc_is_base_44100(enum cip_sfc sfc)
+{
+	return sfc & 1;
+}
+
+static inline void amdtp_stream_set_sync(enum cip_flags sync_mode,
+					 struct amdtp_stream *master,
+					 struct amdtp_stream *slave)
+{
+	if (sync_mode == CIP_SYNC_TO_DEVICE) {
+		master->flags |= CIP_SYNC_TO_DEVICE;
+		slave->flags |= CIP_SYNC_TO_DEVICE;
+		master->sync_slave = slave;
+	} else {
+		master->flags &= ~CIP_SYNC_TO_DEVICE;
+		slave->flags &= ~CIP_SYNC_TO_DEVICE;
+		master->sync_slave = NULL;
+	}
+
+	slave->sync_slave = NULL;
+}
+
+/**
+ * amdtp_stream_wait_callback - sleep till callbacked or timeout
+ * @s: the AMDTP stream
+ * @timeout: msec till timeout
+ *
+ * If this function return false, the AMDTP stream should be stopped.
+ */
+static inline bool amdtp_stream_wait_callback(struct amdtp_stream *s,
+					      unsigned int timeout)
+{
+	return wait_event_timeout(s->callback_wait,
+				  s->callbacked == true,
+				  msecs_to_jiffies(timeout)) > 0;
+}
+
+#endif
