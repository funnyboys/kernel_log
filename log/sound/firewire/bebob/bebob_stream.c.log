commit 6c94f380c6c1d0206da55b0342557926052f2b3e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Nov 1 22:13:23 2019 +0900

    ALSA: bebob: link the order of establishing connections and Syt-match clock mode
    
    Originally BeBeB ASICs and firmware supports clock mode to synchronizing
    to syt field of received isoc packet. This mode is known as 'SYT Match'
    slightly described in IEC 61883-6 (but no detail mechanisms). In this
    mode, drivers can control sampling clock in device. Driver for Windows
    and macOS uses this feature to perform synchronization for devices
    on the same bus.
    
    In this mode, a plug of Music subunit for synchronization is connected
    to a plug of isoc unit for incoming packet streaming, then the order to
    establish connections is INPUT_PLUG first, OUTPUT_PLUG second.
    
    This commit implements the above.
    
    Actually each device works with its own clock for sampling, therefore
    the original design is hardly implemented to vendor's products.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191101131323.17300-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 895a113635af..bbae04793c50 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -398,23 +398,6 @@ check_connection_used_by_others(struct snd_bebob *bebob, struct amdtp_stream *s)
 	return err;
 }
 
-static int make_both_connections(struct snd_bebob *bebob)
-{
-	int err = 0;
-
-	err = cmp_connection_establish(&bebob->out_conn);
-	if (err < 0)
-		return err;
-
-	err = cmp_connection_establish(&bebob->in_conn);
-	if (err < 0) {
-		cmp_connection_break(&bebob->out_conn);
-		return err;
-	}
-
-	return 0;
-}
-
 static void break_both_connections(struct snd_bebob *bebob)
 {
 	cmp_connection_break(&bebob->in_conn);
@@ -427,8 +410,7 @@ static void break_both_connections(struct snd_bebob *bebob)
 		msleep(600);
 }
 
-static int
-start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
+static int start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
 {
 	struct cmp_connection *conn;
 	int err = 0;
@@ -438,18 +420,19 @@ start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
 	else
 		conn = &bebob->out_conn;
 
-	/* channel mapping */
+	// channel mapping.
 	if (bebob->maudio_special_quirk == NULL) {
 		err = map_data_channels(bebob, stream);
 		if (err < 0)
-			goto end;
+			return err;
 	}
 
-	// start amdtp stream.
-	err = amdtp_domain_add_stream(&bebob->domain, stream,
-				      conn->resources.channel, conn->speed);
-end:
-	return err;
+	err = cmp_connection_establish(conn);
+	if (err < 0)
+		return err;
+
+	return amdtp_domain_add_stream(&bebob->domain, stream,
+				       conn->resources.channel, conn->speed);
 }
 
 static int init_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
@@ -638,6 +621,8 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 	}
 
 	if (!amdtp_stream_running(&bebob->rx_stream)) {
+		enum snd_bebob_clock_type src;
+		struct amdtp_stream *master, *slave;
 		unsigned int curr_rate;
 		unsigned int ir_delay_cycle;
 
@@ -647,15 +632,23 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 				return err;
 		}
 
-		err = make_both_connections(bebob);
+		err = snd_bebob_stream_get_clock_src(bebob, &src);
 		if (err < 0)
 			return err;
 
-		err = start_stream(bebob, &bebob->rx_stream);
+		if (src != SND_BEBOB_CLOCK_TYPE_SYT) {
+			master = &bebob->tx_stream;
+			slave = &bebob->rx_stream;
+		} else {
+			master = &bebob->rx_stream;
+			slave = &bebob->tx_stream;
+		}
+
+		err = start_stream(bebob, master);
 		if (err < 0)
 			goto error;
 
-		err = start_stream(bebob, &bebob->tx_stream);
+		err = start_stream(bebob, slave);
 		if (err < 0)
 			goto error;
 

commit da5e83374f463a4dd91321428d5ea5230b6d87b4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Nov 1 22:13:22 2019 +0900

    ALSA: bebob: expand delay of start for IR context just for version 3 firmware
    
    As long as I investigated, there's some cases about the delay for device
    between establishing OUTPUT_PLUG and transmitting first isoc packet. For
    devices which support BeBoB protocol version 1 can transmit the packet
    within several hundred milliseconds, while for devices which support
    BeBoB protocol version 3 can transmit the packet within 2 seconds.
    
    Devices with protocol version 1:
     * Edirol FA-66
     * Yamaha GO46
     * Terratec Phase x24 FW
     * M-Audio FireWire AudioPhile
     * M-Audio FireWire Solo
     * M-Audio FireWire 1814
     * M-Audio FireWire 410
     * Focusrite Saffire Pro 26 I/O
    
    Devices with protocol version 3:
     * M-Audio Profire Lightbridge
     * Behringer FCA610
     * Phonic Firefly 202
    
    At present ALSA bebob driver postpones starting IR context during
    1.5 sec for all of supported devices. The delay is too long for
    devices with protocol version 1, while it's not enough for devices with
    protocol version 3.
    
    This commit improves the delay for these protocols.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191101131323.17300-3-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 1b264d0d63eb..895a113635af 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -7,7 +7,7 @@
 
 #include "./bebob.h"
 
-#define CALLBACK_TIMEOUT	2000
+#define CALLBACK_TIMEOUT	2500
 #define FW_ISO_RESOURCE_DELAY	1000
 
 /*
@@ -639,6 +639,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 
 	if (!amdtp_stream_running(&bebob->rx_stream)) {
 		unsigned int curr_rate;
+		unsigned int ir_delay_cycle;
 
 		if (bebob->maudio_special_quirk) {
 			err = bebob->spec->rate->get(bebob, &curr_rate);
@@ -660,13 +661,18 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 
 		// The device postpones start of transmission mostly for 1 sec
 		// after receives packets firstly. For safe, IR context starts
-		// 1.5 sec (=12000 cycles) later. This is within 2.0 sec
-		// (=CALLBACK_TIMEOUT).
+		// 0.4 sec (=3200 cycles) later to version 1 or 2 firmware,
+		// 2.0 sec (=16000 cycles) for version 3 firmware. This is
+		// within 2.5 sec (=CALLBACK_TIMEOUT).
 		// Furthermore, some devices transfer isoc packets with
 		// discontinuous counter in the beginning of packet streaming.
 		// The delay has an effect to avoid detection of this
 		// discontinuity.
-		err = amdtp_domain_start(&bebob->domain, 12000);
+		if (bebob->version < 2)
+			ir_delay_cycle = 3200;
+		else
+			ir_delay_cycle = 16000;
+		err = amdtp_domain_start(&bebob->domain, ir_delay_cycle);
 		if (err < 0)
 			goto error;
 

commit d3eabe939aee3ffd5b133766a932629a9746298c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Nov 1 22:13:21 2019 +0900

    ALSA: bebob: expand sleep just after breaking connections for protocol version 1
    
    As long as I investigated, some devices with BeBoB protocol version 1
    can be freezed during several hundreds milliseconds after breaking
    connections. When accessing during the freezed time, any transaction
    is corrupted. In the worst case, the device is going to reboot.
    
    I can see this issue in:
     * Roland FA-66
     * M-Audio FireWire Solo
    
    This commit expands sleep just after breaking connections to avoid
    the freezed time as much as possible. I note that the freeze/reboot
    behaviour is similar to below models:
     * Focusrite Saffire Pro 10 I/O
     * Focusrite Saffire Pro 26 I/O
    
    The above models certainly reboot after breaking connections.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191101131323.17300-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index f7f0db5aa811..1b264d0d63eb 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -415,15 +415,16 @@ static int make_both_connections(struct snd_bebob *bebob)
 	return 0;
 }
 
-static void
-break_both_connections(struct snd_bebob *bebob)
+static void break_both_connections(struct snd_bebob *bebob)
 {
 	cmp_connection_break(&bebob->in_conn);
 	cmp_connection_break(&bebob->out_conn);
 
-	/* These models seems to be in transition state for a longer time. */
-	if (bebob->maudio_special_quirk != NULL)
-		msleep(200);
+	// These models seem to be in transition state for a longer time. When
+	// accessing in the state, any transactions is corrupted. In the worst
+	// case, the device is going to reboot.
+	if (bebob->version < 2)
+		msleep(600);
 }
 
 static int

commit e2e556a9549eebde9797a04729efdfc54f37e5cc
Merge: 0a671dc50055 1a7f60b9df61
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 28 12:43:29 2019 +0100

    Merge branch 'for-linus' into for-next
    
    Back-merge the development process for catching up the HD-audio fix
    (and apply a new one on top of that).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit f2bbdbcb075f3977a53da3bdcb7cd460bc8ae5f2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Oct 26 12:06:20 2019 +0900

    ALSA: bebob: Fix prototype of helper function to return negative value
    
    A helper function of ALSA bebob driver returns negative value in a
    function which has a prototype to return unsigned value.
    
    This commit fixes it by changing the prototype.
    
    Fixes: eb7b3a056cd8 ("ALSA: bebob: Add commands and connections/streams management")
    Cc: <stable@vger.kernel.org> # v3.16+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191026030620.12077-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 73fee991bd75..6c1497d9f52b 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -252,8 +252,7 @@ int snd_bebob_stream_get_clock_src(struct snd_bebob *bebob,
 	return err;
 }
 
-static unsigned int
-map_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)
+static int map_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)
 {
 	unsigned int sec, sections, ch, channels;
 	unsigned int pcm, midi, location;

commit acfedcbe1ce4c69e1da914f39c02d945c80198d4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 15:19:11 2019 +0900

    ALSA: firewire-lib: postpone to start IR context
    
    Some devices have a quirk to postpone transmission of isoc packet for
    several dozen or hundred isoc cycles since configured to transmit.
    Furthermore, some devices have a quirk to transmit isoc packet with
    discontinued data of its header.
    
    In 1394 OHCI specification, software allows to start isoc context with
    certain isoc cycle. Linux firewire subsystem has kernel API to use it
    as well.
    
    This commit uses the functionality of 1394 OHCI controller to handle
    the quirks. At present, this feature is convenient to ALSA bebob and
    fireface driver. As a result, some devices can be safely handled, as
    long as I know:
     - MAudio FireWire solo
     - MAudio ProFire Lightbridge
     - MAudio FireWire 410
     - Roland FA-66
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191018061911.24909-7-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 5e4a61458be2..7ac0d9f495c4 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -658,7 +658,15 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 		if (err < 0)
 			goto error;
 
-		err = amdtp_domain_start(&bebob->domain);
+		// The device postpones start of transmission mostly for 1 sec
+		// after receives packets firstly. For safe, IR context starts
+		// 1.5 sec (=12000 cycles) later. This is within 2.0 sec
+		// (=CALLBACK_TIMEOUT).
+		// Furthermore, some devices transfer isoc packets with
+		// discontinuous counter in the beginning of packet streaming.
+		// The delay has an effect to avoid detection of this
+		// discontinuity.
+		err = amdtp_domain_start(&bebob->domain, 12000);
 		if (err < 0)
 			goto error;
 

commit 1fde7a447a7f423b893ac3fcac0ba65893924189
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 00:54:14 2019 +0900

    ALSA: bebob: share PCM buffer size for both direction
    
    This commit allows ALSA bebob driver to share PCM buffer size for both
    capture and playback PCM substream. When AMDTP domain starts for one
    of the PCM substream, buffer size of the PCM substream is stores to
    AMDTP domain structure. Some AMDTP streams have already run with the
    buffer size when another PCM substream starts, therefore the PCM
    substream has a constraint to its buffer size.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191017155424.885-3-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index e8e9eca6f116..5e4a61458be2 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -555,7 +555,8 @@ static int keep_resources(struct snd_bebob *bebob, struct amdtp_stream *stream,
 }
 
 int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate,
-				    unsigned int frames_per_period)
+				    unsigned int frames_per_period,
+				    unsigned int frames_per_buffer)
 {
 	unsigned int curr_rate;
 	int err;
@@ -610,7 +611,7 @@ int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate,
 		}
 
 		err = amdtp_domain_set_events_per_period(&bebob->domain,
-							 frames_per_period, 0);
+					frames_per_period, frames_per_buffer);
 		if (err < 0) {
 			cmp_connection_release(&bebob->out_conn);
 			cmp_connection_release(&bebob->in_conn);

commit a0e023317e2d55c6b2fbf342c12d8a59797e1cff
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 00:54:13 2019 +0900

    ALSA: firewire-lib: use variable size of queue for isoc packets instead of fixed size
    
    The number of packets in packet buffer has been fixed number (=48) since
    first commit of ALSA IEC 61883-1/6 packet streaming engine.
    
    This commit allows the engine to use variable number of packets in the
    buffer. The size is calculated by a parameter in AMDTP domain structure
    surely to store the number of events in the packets of buffer. Although
    the value of parameter is expected to come from 'period size' parameter
    of PCM substream, at present 48 is still used.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191017155424.885-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index f1db3ddc3e00..e8e9eca6f116 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -610,7 +610,7 @@ int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate,
 		}
 
 		err = amdtp_domain_set_events_per_period(&bebob->domain,
-							 frames_per_period);
+							 frames_per_period, 0);
 		if (err < 0) {
 			cmp_connection_release(&bebob->out_conn);
 			cmp_connection_release(&bebob->in_conn);

commit 8737209fe4a251a7d1de8f77c126ce7b69d926e7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 7 20:05:17 2019 +0900

    ALSA: bebob: register the size of PCM period to AMDTP domain
    
    This commit is a preparation to share the size of PCM period between
    PCM substreams on AMDTP streams in the same domain. At this time,
    the size of PCM period in PCM substream which starts AMDTP streams in the
    same domain is recorded.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191007110532.30270-3-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 73fee991bd75..f1db3ddc3e00 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -554,7 +554,8 @@ static int keep_resources(struct snd_bebob *bebob, struct amdtp_stream *stream,
 	return cmp_connection_reserve(conn, amdtp_stream_get_max_payload(stream));
 }
 
-int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate)
+int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate,
+				    unsigned int frames_per_period)
 {
 	unsigned int curr_rate;
 	int err;
@@ -607,6 +608,14 @@ int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate)
 			cmp_connection_release(&bebob->out_conn);
 			return err;
 		}
+
+		err = amdtp_domain_set_events_per_period(&bebob->domain,
+							 frames_per_period);
+		if (err < 0) {
+			cmp_connection_release(&bebob->out_conn);
+			cmp_connection_release(&bebob->in_conn);
+			return err;
+		}
 	}
 
 	return 0;

commit b0db4d512941455894e7a13f71594b7d4638b94b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 4 15:21:30 2019 +0900

    ALSA: bebob: support AMDTP domain
    
    This commit adds AMDTP domain support for ALSA bebob driver.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 334dc7c96e1d..73fee991bd75 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -445,10 +445,9 @@ start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
 			goto end;
 	}
 
-	/* start amdtp stream */
-	err = amdtp_stream_start(stream,
-				 conn->resources.channel,
-				 conn->speed);
+	// start amdtp stream.
+	err = amdtp_domain_add_stream(&bebob->domain, stream,
+				      conn->resources.channel, conn->speed);
 end:
 	return err;
 }
@@ -523,7 +522,13 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 		return err;
 	}
 
-	return 0;
+	err = amdtp_domain_init(&bebob->domain);
+	if (err < 0) {
+		destroy_stream(bebob, &bebob->tx_stream);
+		destroy_stream(bebob, &bebob->rx_stream);
+	}
+
+	return err;
 }
 
 static int keep_resources(struct snd_bebob *bebob, struct amdtp_stream *stream,
@@ -566,9 +571,7 @@ int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate)
 	if (rate == 0)
 		rate = curr_rate;
 	if (curr_rate != rate) {
-		amdtp_stream_stop(&bebob->tx_stream);
-		amdtp_stream_stop(&bebob->rx_stream);
-
+		amdtp_domain_stop(&bebob->domain);
 		break_both_connections(bebob);
 
 		cmp_connection_release(&bebob->out_conn);
@@ -620,9 +623,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 	// packet queueing error or detecting discontinuity
 	if (amdtp_streaming_error(&bebob->rx_stream) ||
 	    amdtp_streaming_error(&bebob->tx_stream)) {
-		amdtp_stream_stop(&bebob->rx_stream);
-		amdtp_stream_stop(&bebob->tx_stream);
-
+		amdtp_domain_stop(&bebob->domain);
 		break_both_connections(bebob);
 	}
 
@@ -640,11 +641,16 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 			return err;
 
 		err = start_stream(bebob, &bebob->rx_stream);
-		if (err < 0) {
-			dev_err(&bebob->unit->device,
-				"fail to run AMDTP master stream:%d\n", err);
+		if (err < 0)
+			goto error;
+
+		err = start_stream(bebob, &bebob->tx_stream);
+		if (err < 0)
+			goto error;
+
+		err = amdtp_domain_start(&bebob->domain);
+		if (err < 0)
 			goto error;
-		}
 
 		// NOTE:
 		// The firmware customized by M-Audio uses these commands to
@@ -660,21 +666,8 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 		}
 
 		if (!amdtp_stream_wait_callback(&bebob->rx_stream,
-						CALLBACK_TIMEOUT)) {
-			err = -ETIMEDOUT;
-			goto error;
-		}
-	}
-
-	if (!amdtp_stream_running(&bebob->tx_stream)) {
-		err = start_stream(bebob, &bebob->tx_stream);
-		if (err < 0) {
-			dev_err(&bebob->unit->device,
-				"fail to run AMDTP slave stream:%d\n", err);
-			goto error;
-		}
-
-		if (!amdtp_stream_wait_callback(&bebob->tx_stream,
+						CALLBACK_TIMEOUT) ||
+		    !amdtp_stream_wait_callback(&bebob->tx_stream,
 						CALLBACK_TIMEOUT)) {
 			err = -ETIMEDOUT;
 			goto error;
@@ -683,8 +676,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 
 	return 0;
 error:
-	amdtp_stream_stop(&bebob->tx_stream);
-	amdtp_stream_stop(&bebob->rx_stream);
+	amdtp_domain_stop(&bebob->domain);
 	break_both_connections(bebob);
 	return err;
 }
@@ -692,9 +684,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 {
 	if (bebob->substreams_counter == 0) {
-		amdtp_stream_stop(&bebob->rx_stream);
-		amdtp_stream_stop(&bebob->tx_stream);
-
+		amdtp_domain_stop(&bebob->domain);
 		break_both_connections(bebob);
 
 		cmp_connection_release(&bebob->out_conn);
@@ -708,6 +698,8 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
  */
 void snd_bebob_stream_destroy_duplex(struct snd_bebob *bebob)
 {
+	amdtp_domain_destroy(&bebob->domain);
+
 	destroy_stream(bebob, &bebob->tx_stream);
 	destroy_stream(bebob, &bebob->rx_stream);
 }

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 7599e279c04511731e2aba4a6dc7b98e5c2a2d25
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jun 18 22:26:20 2019 +0900

    ALSA: bebob: ensure to release isochronous resources in pcm.hw_params callback
    
    When stopping packet streaming in reserve function for duplex streams,
    isochronous resources should be released.
    
    Fixes: 7bc93821a70a ("ALSA: firewire-lib: split allocation of isochronous resources from establishment of connection")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 1070a675179d..63e78fc8711d 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -571,6 +571,9 @@ int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate)
 		amdtp_stream_stop(&bebob->rx_stream);
 
 		break_both_connections(bebob);
+
+		cmp_connection_release(&bebob->out_conn);
+		cmp_connection_release(&bebob->in_conn);
 	}
 
 	if (bebob->substreams_counter == 0 || curr_rate != rate) {

commit 7bc93821a70adc621df443c8b7a4745023c36e7c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Jun 15 18:11:01 2019 +0900

    ALSA: firewire-lib: split allocation of isochronous resources from establishment of connection
    
    In current implementation, establishment connection corresponds to
    allocation of isochronous resources. Although this is an ideal
    implementation of CMP described in IEC 61883-1, it's not enough
    efficient to recover PCM substream multiplexed in packet streaming.
    The packet streaming can always restart on the same allocated
    isochronous resources even if the previous packet streaming
    corrupted.
    
    This commit splits allocation of isochronous resources from
    establishment of connection so that CMP runs with allocated
    isochronous resources.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 9ef4663d13e5..1070a675179d 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -404,13 +404,11 @@ static int make_both_connections(struct snd_bebob *bebob)
 {
 	int err = 0;
 
-	err = cmp_connection_establish(&bebob->out_conn,
-			amdtp_stream_get_max_payload(&bebob->tx_stream));
+	err = cmp_connection_establish(&bebob->out_conn);
 	if (err < 0)
 		return err;
 
-	err = cmp_connection_establish(&bebob->in_conn,
-			amdtp_stream_get_max_payload(&bebob->rx_stream));
+	err = cmp_connection_establish(&bebob->in_conn);
 	if (err < 0) {
 		cmp_connection_break(&bebob->out_conn);
 		return err;
@@ -533,14 +531,23 @@ static int keep_resources(struct snd_bebob *bebob, struct amdtp_stream *stream,
 			  unsigned int rate, unsigned int index)
 {
 	struct snd_bebob_stream_formation *formation;
+	struct cmp_connection *conn;
+	int err;
 
-	if (stream == &bebob->tx_stream)
+	if (stream == &bebob->tx_stream) {
 		formation = bebob->tx_stream_formations + index;
-	else
+		conn = &bebob->out_conn;
+	} else {
 		formation = bebob->rx_stream_formations + index;
+		conn = &bebob->in_conn;
+	}
+
+	err = amdtp_am824_set_parameters(stream, rate, formation->pcm,
+					 formation->midi, false);
+	if (err < 0)
+		return err;
 
-	return amdtp_am824_set_parameters(stream, rate, formation->pcm,
-					  formation->midi, false);
+	return cmp_connection_reserve(conn, amdtp_stream_get_max_payload(stream));
 }
 
 int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate)
@@ -591,8 +598,10 @@ int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate)
 			return err;
 
 		err = keep_resources(bebob, &bebob->rx_stream, rate, index);
-		if (err < 0)
+		if (err < 0) {
+			cmp_connection_release(&bebob->out_conn);
 			return err;
+		}
 	}
 
 	return 0;
@@ -685,6 +694,9 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 		amdtp_stream_stop(&bebob->tx_stream);
 
 		break_both_connections(bebob);
+
+		cmp_connection_release(&bebob->out_conn);
+		cmp_connection_release(&bebob->in_conn);
 	}
 }
 

commit d173265ae36f8f6f76a507e2f529c351671269c0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Jun 15 18:10:59 2019 +0900

    ALSA: bebob: code refactoring for error path to start duplex stream
    
    This commit removes useless procedures to stop packet streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 6aab3dc99bef..9ef4663d13e5 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -650,8 +650,6 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 
 		if (!amdtp_stream_wait_callback(&bebob->rx_stream,
 						CALLBACK_TIMEOUT)) {
-			amdtp_stream_stop(&bebob->rx_stream);
-			break_both_connections(bebob);
 			err = -ETIMEDOUT;
 			goto error;
 		}

commit 33e41a5ce59ad34c822228d3811ba3785f1a97a2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:07 2019 +0900

    ALSA: bebob: code refactoring to initialize/destroy stream data
    
    This commit changes helper functions to initialize/destroy stream
    data so that it has an argument for direction.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index c3cc31df49e0..6aab3dc99bef 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -376,24 +376,6 @@ map_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)
 	return err;
 }
 
-static int
-init_both_connections(struct snd_bebob *bebob)
-{
-	int err;
-
-	err = cmp_connection_init(&bebob->in_conn,
-				  bebob->unit, CMP_INPUT, 0);
-	if (err < 0)
-		goto end;
-
-	err = cmp_connection_init(&bebob->out_conn,
-				  bebob->unit, CMP_OUTPUT, 0);
-	if (err < 0)
-		cmp_connection_destroy(&bebob->in_conn);
-end:
-	return err;
-}
-
 static int
 check_connection_used_by_others(struct snd_bebob *bebob, struct amdtp_stream *s)
 {
@@ -448,13 +430,6 @@ break_both_connections(struct snd_bebob *bebob)
 		msleep(200);
 }
 
-static void
-destroy_both_connections(struct snd_bebob *bebob)
-{
-	cmp_connection_destroy(&bebob->in_conn);
-	cmp_connection_destroy(&bebob->out_conn);
-}
-
 static int
 start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
 {
@@ -481,49 +456,77 @@ start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
 	return err;
 }
 
-int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
+static int init_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
 {
+	enum amdtp_stream_direction dir_stream;
+	struct cmp_connection *conn;
+	enum cmp_direction dir_conn;
 	int err;
 
-	err = init_both_connections(bebob);
+	if (stream == &bebob->tx_stream) {
+		dir_stream = AMDTP_IN_STREAM;
+		conn = &bebob->out_conn;
+		dir_conn = CMP_OUTPUT;
+	} else {
+		dir_stream = AMDTP_OUT_STREAM;
+		conn = &bebob->in_conn;
+		dir_conn = CMP_INPUT;
+	}
+
+	err = cmp_connection_init(conn, bebob->unit, dir_conn, 0);
 	if (err < 0)
-		goto end;
+		return err;
 
-	err = amdtp_am824_init(&bebob->tx_stream, bebob->unit,
-			       AMDTP_IN_STREAM, CIP_BLOCKING);
+	err = amdtp_am824_init(stream, bebob->unit, dir_stream, CIP_BLOCKING);
 	if (err < 0) {
-		amdtp_stream_destroy(&bebob->tx_stream);
-		destroy_both_connections(bebob);
-		goto end;
+		cmp_connection_destroy(conn);
+		return err;
 	}
 
-	/*
-	 * BeBoB v3 transfers packets with these qurks:
-	 *  - In the beginning of streaming, the value of dbc is incremented
-	 *    even if no data blocks are transferred.
-	 *  - The value of dbc is reset suddenly.
-	 */
-	if (bebob->version > 2)
-		bebob->tx_stream.flags |= CIP_EMPTY_HAS_WRONG_DBC |
-					  CIP_SKIP_DBC_ZERO_CHECK;
+	if (stream == &bebob->tx_stream) {
+		// BeBoB v3 transfers packets with these qurks:
+		//  - In the beginning of streaming, the value of dbc is
+		//    incremented even if no data blocks are transferred.
+		//  - The value of dbc is reset suddenly.
+		if (bebob->version > 2)
+			bebob->tx_stream.flags |= CIP_EMPTY_HAS_WRONG_DBC |
+						  CIP_SKIP_DBC_ZERO_CHECK;
+
+		// At high sampling rate, M-Audio special firmware transmits
+		// empty packet with the value of dbc incremented by 8 but the
+		// others are valid to IEC 61883-1.
+		if (bebob->maudio_special_quirk)
+			bebob->tx_stream.flags |= CIP_EMPTY_HAS_WRONG_DBC;
+	}
 
-	/*
-	 * At high sampling rate, M-Audio special firmware transmits empty
-	 * packet with the value of dbc incremented by 8 but the others are
-	 * valid to IEC 61883-1.
-	 */
-	if (bebob->maudio_special_quirk)
-		bebob->tx_stream.flags |= CIP_EMPTY_HAS_WRONG_DBC;
+	return 0;
+}
+
+static void destroy_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
+{
+	amdtp_stream_destroy(stream);
+
+	if (stream == &bebob->tx_stream)
+		cmp_connection_destroy(&bebob->out_conn);
+	else
+		cmp_connection_destroy(&bebob->in_conn);
+}
 
-	err = amdtp_am824_init(&bebob->rx_stream, bebob->unit,
-			       AMDTP_OUT_STREAM, CIP_BLOCKING);
+int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
+{
+	int err;
+
+	err = init_stream(bebob, &bebob->tx_stream);
+	if (err < 0)
+		return err;
+
+	err = init_stream(bebob, &bebob->rx_stream);
 	if (err < 0) {
-		amdtp_stream_destroy(&bebob->tx_stream);
-		amdtp_stream_destroy(&bebob->rx_stream);
-		destroy_both_connections(bebob);
+		destroy_stream(bebob, &bebob->tx_stream);
+		return err;
 	}
-end:
-	return err;
+
+	return 0;
 }
 
 static int keep_resources(struct snd_bebob *bebob, struct amdtp_stream *stream,
@@ -693,10 +696,8 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
  */
 void snd_bebob_stream_destroy_duplex(struct snd_bebob *bebob)
 {
-	amdtp_stream_destroy(&bebob->rx_stream);
-	amdtp_stream_destroy(&bebob->tx_stream);
-
-	destroy_both_connections(bebob);
+	destroy_stream(bebob, &bebob->tx_stream);
+	destroy_stream(bebob, &bebob->rx_stream);
 }
 
 /*

commit 87a23092dd971b960f9065dbc0cc48be31400326
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:06 2019 +0900

    ALSA: bebob: obsolete useless member of private structure
    
    The private structure of this driver has 'connected' member but nowadays
    it's useless. This commit removes it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index d6e7f13ef42d..c3cc31df49e0 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -422,9 +422,6 @@ static int make_both_connections(struct snd_bebob *bebob)
 {
 	int err = 0;
 
-	if (bebob->connected)
-		return 0;
-
 	err = cmp_connection_establish(&bebob->out_conn,
 			amdtp_stream_get_max_payload(&bebob->tx_stream));
 	if (err < 0)
@@ -437,8 +434,6 @@ static int make_both_connections(struct snd_bebob *bebob)
 		return err;
 	}
 
-	bebob->connected = true;
-
 	return 0;
 }
 
@@ -448,8 +443,6 @@ break_both_connections(struct snd_bebob *bebob)
 	cmp_connection_break(&bebob->in_conn);
 	cmp_connection_break(&bebob->out_conn);
 
-	bebob->connected = false;
-
 	/* These models seems to be in transition state for a longer time. */
 	if (bebob->maudio_special_quirk != NULL)
 		msleep(200);

commit 83122f85d4d87885a379a7f71cd6688b1a38d4e1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:05 2019 +0900

    ALSA: bebob: don't set XRUN in stop streaming
    
    When stopping packet streaming, no need to stop PCM substream with XRUN
    state. This commit suppresses it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index fcc93156d0b7..d6e7f13ef42d 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -687,10 +687,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
 void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 {
 	if (bebob->substreams_counter == 0) {
-		amdtp_stream_pcm_abort(&bebob->rx_stream);
 		amdtp_stream_stop(&bebob->rx_stream);
-
-		amdtp_stream_pcm_abort(&bebob->tx_stream);
 		amdtp_stream_stop(&bebob->tx_stream);
 
 		break_both_connections(bebob);

commit ac2888b958f217be15d6afb966df48a313f2d87a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:04 2019 +0900

    ALSA: bebob: configure sampling transfer frequency in pcm.hw_params callback
    
    This commit is a part of preparation to perform allocation/release
    of isochronous resources in pcm.hw_params/hw_free callbacks.
    
    At present, several operations are done in pcm.prepare callback. To
    reduce load of the callback, This commit splits out an operation to
    set sampling transfer frequency in pcm.hw_params callback.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 4d3034a68bdf..fcc93156d0b7 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -418,49 +418,28 @@ check_connection_used_by_others(struct snd_bebob *bebob, struct amdtp_stream *s)
 	return err;
 }
 
-static int
-make_both_connections(struct snd_bebob *bebob, unsigned int rate)
+static int make_both_connections(struct snd_bebob *bebob)
 {
-	int index, pcm_channels, midi_channels, err = 0;
+	int err = 0;
 
 	if (bebob->connected)
-		goto end;
-
-	/* confirm params for both streams */
-	err = get_formation_index(rate, &index);
-	if (err < 0)
-		goto end;
-	pcm_channels = bebob->tx_stream_formations[index].pcm;
-	midi_channels = bebob->tx_stream_formations[index].midi;
-	err = amdtp_am824_set_parameters(&bebob->tx_stream, rate,
-					 pcm_channels, midi_channels * 8,
-					 false);
-	if (err < 0)
-		goto end;
-
-	pcm_channels = bebob->rx_stream_formations[index].pcm;
-	midi_channels = bebob->rx_stream_formations[index].midi;
-	err = amdtp_am824_set_parameters(&bebob->rx_stream, rate,
-					 pcm_channels, midi_channels * 8,
-					 false);
-	if (err < 0)
-		goto end;
+		return 0;
 
-	/* establish connections for both streams */
 	err = cmp_connection_establish(&bebob->out_conn,
 			amdtp_stream_get_max_payload(&bebob->tx_stream));
 	if (err < 0)
-		goto end;
+		return err;
+
 	err = cmp_connection_establish(&bebob->in_conn,
 			amdtp_stream_get_max_payload(&bebob->rx_stream));
 	if (err < 0) {
 		cmp_connection_break(&bebob->out_conn);
-		goto end;
+		return err;
 	}
 
 	bebob->connected = true;
-end:
-	return err;
+
+	return 0;
 }
 
 static void
@@ -484,8 +463,7 @@ destroy_both_connections(struct snd_bebob *bebob)
 }
 
 static int
-start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream,
-	     unsigned int rate)
+start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream)
 {
 	struct cmp_connection *conn;
 	int err = 0;
@@ -555,132 +533,154 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 	return err;
 }
 
-int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
+static int keep_resources(struct snd_bebob *bebob, struct amdtp_stream *stream,
+			  unsigned int rate, unsigned int index)
 {
-	const struct snd_bebob_rate_spec *rate_spec = bebob->spec->rate;
-	unsigned int curr_rate;
-	int err = 0;
+	struct snd_bebob_stream_formation *formation;
 
-	/* Need no substreams */
-	if (bebob->substreams_counter == 0)
-		goto end;
+	if (stream == &bebob->tx_stream)
+		formation = bebob->tx_stream_formations + index;
+	else
+		formation = bebob->rx_stream_formations + index;
 
-	/*
-	 * Considering JACK/FFADO streaming:
-	 * TODO: This can be removed hwdep functionality becomes popular.
-	 */
+	return amdtp_am824_set_parameters(stream, rate, formation->pcm,
+					  formation->midi, false);
+}
+
+int snd_bebob_stream_reserve_duplex(struct snd_bebob *bebob, unsigned int rate)
+{
+	unsigned int curr_rate;
+	int err;
+
+	// Considering JACK/FFADO streaming:
+	// TODO: This can be removed hwdep functionality becomes popular.
 	err = check_connection_used_by_others(bebob, &bebob->rx_stream);
 	if (err < 0)
-		goto end;
+		return err;
 
-	/*
-	 * packet queueing error or detecting discontinuity
-	 *
-	 * At bus reset, connections should not be broken here. So streams need
-	 * to be re-started. This is a reason to use SKIP_INIT_DBC_CHECK flag.
-	 */
-	if (amdtp_streaming_error(&bebob->rx_stream))
-		amdtp_stream_stop(&bebob->rx_stream);
-	if (amdtp_streaming_error(&bebob->tx_stream))
+	err = bebob->spec->rate->get(bebob, &curr_rate);
+	if (err < 0)
+		return err;
+	if (rate == 0)
+		rate = curr_rate;
+	if (curr_rate != rate) {
 		amdtp_stream_stop(&bebob->tx_stream);
-	if (!amdtp_stream_running(&bebob->rx_stream) &&
-	    !amdtp_stream_running(&bebob->tx_stream))
+		amdtp_stream_stop(&bebob->rx_stream);
+
 		break_both_connections(bebob);
+	}
 
-	/* stop streams if rate is different */
-	err = rate_spec->get(bebob, &curr_rate);
-	if (err < 0) {
-		dev_err(&bebob->unit->device,
-			"fail to get sampling rate: %d\n", err);
-		goto end;
+	if (bebob->substreams_counter == 0 || curr_rate != rate) {
+		unsigned int index;
+
+		// NOTE:
+		// If establishing connections at first, Yamaha GO46
+		// (and maybe Terratec X24) don't generate sound.
+		//
+		// For firmware customized by M-Audio, refer to next NOTE.
+		err = bebob->spec->rate->set(bebob, rate);
+		if (err < 0) {
+			dev_err(&bebob->unit->device,
+				"fail to set sampling rate: %d\n",
+				err);
+			return err;
+		}
+
+		err = get_formation_index(rate, &index);
+		if (err < 0)
+			return err;
+
+		err = keep_resources(bebob, &bebob->tx_stream, rate, index);
+		if (err < 0)
+			return err;
+
+		err = keep_resources(bebob, &bebob->rx_stream, rate, index);
+		if (err < 0)
+			return err;
 	}
-	if (rate == 0)
-		rate = curr_rate;
-	if (rate != curr_rate) {
+
+	return 0;
+}
+
+int snd_bebob_stream_start_duplex(struct snd_bebob *bebob)
+{
+	int err;
+
+	// Need no substreams.
+	if (bebob->substreams_counter == 0)
+		return -EIO;
+
+	// packet queueing error or detecting discontinuity
+	if (amdtp_streaming_error(&bebob->rx_stream) ||
+	    amdtp_streaming_error(&bebob->tx_stream)) {
 		amdtp_stream_stop(&bebob->rx_stream);
 		amdtp_stream_stop(&bebob->tx_stream);
+
 		break_both_connections(bebob);
 	}
 
-	/* master should be always running */
 	if (!amdtp_stream_running(&bebob->rx_stream)) {
-		/*
-		 * NOTE:
-		 * If establishing connections at first, Yamaha GO46
-		 * (and maybe Terratec X24) don't generate sound.
-		 *
-		 * For firmware customized by M-Audio, refer to next NOTE.
-		 */
-		if (bebob->maudio_special_quirk == NULL) {
-			err = rate_spec->set(bebob, rate);
-			if (err < 0) {
-				dev_err(&bebob->unit->device,
-					"fail to set sampling rate: %d\n",
-					err);
-				goto end;
-			}
+		unsigned int curr_rate;
+
+		if (bebob->maudio_special_quirk) {
+			err = bebob->spec->rate->get(bebob, &curr_rate);
+			if (err < 0)
+				return err;
 		}
 
-		err = make_both_connections(bebob, rate);
+		err = make_both_connections(bebob);
 		if (err < 0)
-			goto end;
+			return err;
 
-		err = start_stream(bebob, &bebob->rx_stream, rate);
+		err = start_stream(bebob, &bebob->rx_stream);
 		if (err < 0) {
 			dev_err(&bebob->unit->device,
 				"fail to run AMDTP master stream:%d\n", err);
-			break_both_connections(bebob);
-			goto end;
+			goto error;
 		}
 
-		/*
-		 * NOTE:
-		 * The firmware customized by M-Audio uses these commands to
-		 * start transmitting stream. This is not usual way.
-		 */
-		if (bebob->maudio_special_quirk != NULL) {
-			err = rate_spec->set(bebob, rate);
+		// NOTE:
+		// The firmware customized by M-Audio uses these commands to
+		// start transmitting stream. This is not usual way.
+		if (bebob->maudio_special_quirk) {
+			err = bebob->spec->rate->set(bebob, curr_rate);
 			if (err < 0) {
 				dev_err(&bebob->unit->device,
 					"fail to ensure sampling rate: %d\n",
 					err);
-				amdtp_stream_stop(&bebob->rx_stream);
-				break_both_connections(bebob);
-				goto end;
+				goto error;
 			}
 		}
 
-		/* wait first callback */
 		if (!amdtp_stream_wait_callback(&bebob->rx_stream,
 						CALLBACK_TIMEOUT)) {
 			amdtp_stream_stop(&bebob->rx_stream);
 			break_both_connections(bebob);
 			err = -ETIMEDOUT;
-			goto end;
+			goto error;
 		}
 	}
 
-	/* start slave if needed */
 	if (!amdtp_stream_running(&bebob->tx_stream)) {
-		err = start_stream(bebob, &bebob->tx_stream, rate);
+		err = start_stream(bebob, &bebob->tx_stream);
 		if (err < 0) {
 			dev_err(&bebob->unit->device,
 				"fail to run AMDTP slave stream:%d\n", err);
-			amdtp_stream_stop(&bebob->rx_stream);
-			break_both_connections(bebob);
-			goto end;
+			goto error;
 		}
 
-		/* wait first callback */
 		if (!amdtp_stream_wait_callback(&bebob->tx_stream,
 						CALLBACK_TIMEOUT)) {
-			amdtp_stream_stop(&bebob->tx_stream);
-			amdtp_stream_stop(&bebob->rx_stream);
-			break_both_connections(bebob);
 			err = -ETIMEDOUT;
+			goto error;
 		}
 	}
-end:
+
+	return 0;
+error:
+	amdtp_stream_stop(&bebob->tx_stream);
+	amdtp_stream_stop(&bebob->rx_stream);
+	break_both_connections(bebob);
 	return err;
 }
 

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 4d3034a68bdf..0c93a825cb98 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * bebob_stream.c - a part of driver for BeBoB based devices
  *
  * Copyright (c) 2013-2014 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "./bebob.h"

commit 62f00e40b0718ebd8bd54fc7a9e89e873524d495
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon May 9 23:15:56 2016 +0900

    ALSA: firewire-lib: enable the same feature as CIP_SKIP_INIT_DBC_CHECK flag
    
    In former commit, drivers in ALSA firewire stack always starts IT context
    before IR context. If IR context starts after packets are transmitted by
    peer unit, packet discontinuity may be detected because the context starts
    in the middle of packet streaming. This situation is rare because IT
    context usually starts immediately. However, it's better to solve this
    issue. This is suppressed with CIP_SKIP_INIT_DBC_CHECK flag.
    
    This commit enables the same feature as CIP_SKIP_INIT_DBC_CHECK.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 0141813815b3..4d3034a68bdf 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -526,8 +526,6 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 		goto end;
 	}
 
-	bebob->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK;
-
 	/*
 	 * BeBoB v3 transfers packets with these qurks:
 	 *  - In the beginning of streaming, the value of dbc is incremented

commit c71283cb682c28085125bea35e4c6149b538f5db
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon May 9 23:15:50 2016 +0900

    ALSA: bebob: drop reuse of incoming packet parameter for outgoing packet parameter
    
    Windows driver for BeBoB-based models mostly wait for transmitted packets,
    then transfer packets to the models. This looks for the relationship
    between incoming packets and outgoing packets to synchronize the sequence
    of presentation timestamp.
    
    However, the sequence between packets of both direction has no
    relationship. Even if receiving NO-DATA packets, the drivers transfer
    packets with meaningful value in SYT field. Additionally, the order of
    starting packets is always the same, independently of the source of clock.
    The corresponding driver is expected as a generator of presentation
    timestamp and these models can select it as a source of sampling clock.
    
    This commit drops reusing SYT sequence from ALSA bebob driver. The driver
    always transfer packets with presentation timestamp generated by ALSA
    firewire stack, without re-using the sequence of value in SYT field in
    incoming packets to outgoing packets.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 77cbb02bff34..0141813815b3 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -483,30 +483,6 @@ destroy_both_connections(struct snd_bebob *bebob)
 	cmp_connection_destroy(&bebob->out_conn);
 }
 
-static int
-get_sync_mode(struct snd_bebob *bebob, enum cip_flags *sync_mode)
-{
-	enum snd_bebob_clock_type src;
-	int err;
-
-	err = snd_bebob_stream_get_clock_src(bebob, &src);
-	if (err < 0)
-		return err;
-
-	switch (src) {
-	case SND_BEBOB_CLOCK_TYPE_INTERNAL:
-	case SND_BEBOB_CLOCK_TYPE_EXTERNAL:
-		*sync_mode = CIP_SYNC_TO_DEVICE;
-		break;
-	default:
-	case SND_BEBOB_CLOCK_TYPE_SYT:
-		*sync_mode = 0;
-		break;
-	}
-
-	return 0;
-}
-
 static int
 start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream,
 	     unsigned int rate)
@@ -584,8 +560,6 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 {
 	const struct snd_bebob_rate_spec *rate_spec = bebob->spec->rate;
-	struct amdtp_stream *master, *slave;
-	enum cip_flags sync_mode;
 	unsigned int curr_rate;
 	int err = 0;
 
@@ -593,22 +567,11 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	if (bebob->substreams_counter == 0)
 		goto end;
 
-	err = get_sync_mode(bebob, &sync_mode);
-	if (err < 0)
-		goto end;
-	if (sync_mode == CIP_SYNC_TO_DEVICE) {
-		master = &bebob->tx_stream;
-		slave  = &bebob->rx_stream;
-	} else {
-		master = &bebob->rx_stream;
-		slave  = &bebob->tx_stream;
-	}
-
 	/*
 	 * Considering JACK/FFADO streaming:
 	 * TODO: This can be removed hwdep functionality becomes popular.
 	 */
-	err = check_connection_used_by_others(bebob, master);
+	err = check_connection_used_by_others(bebob, &bebob->rx_stream);
 	if (err < 0)
 		goto end;
 
@@ -618,11 +581,12 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	 * At bus reset, connections should not be broken here. So streams need
 	 * to be re-started. This is a reason to use SKIP_INIT_DBC_CHECK flag.
 	 */
-	if (amdtp_streaming_error(master))
-		amdtp_stream_stop(master);
-	if (amdtp_streaming_error(slave))
-		amdtp_stream_stop(slave);
-	if (!amdtp_stream_running(master) && !amdtp_stream_running(slave))
+	if (amdtp_streaming_error(&bebob->rx_stream))
+		amdtp_stream_stop(&bebob->rx_stream);
+	if (amdtp_streaming_error(&bebob->tx_stream))
+		amdtp_stream_stop(&bebob->tx_stream);
+	if (!amdtp_stream_running(&bebob->rx_stream) &&
+	    !amdtp_stream_running(&bebob->tx_stream))
 		break_both_connections(bebob);
 
 	/* stop streams if rate is different */
@@ -635,16 +599,13 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	if (rate == 0)
 		rate = curr_rate;
 	if (rate != curr_rate) {
-		amdtp_stream_stop(master);
-		amdtp_stream_stop(slave);
+		amdtp_stream_stop(&bebob->rx_stream);
+		amdtp_stream_stop(&bebob->tx_stream);
 		break_both_connections(bebob);
 	}
 
 	/* master should be always running */
-	if (!amdtp_stream_running(master)) {
-		amdtp_stream_set_sync(sync_mode, master, slave);
-		bebob->master = master;
-
+	if (!amdtp_stream_running(&bebob->rx_stream)) {
 		/*
 		 * NOTE:
 		 * If establishing connections at first, Yamaha GO46
@@ -666,7 +627,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 		if (err < 0)
 			goto end;
 
-		err = start_stream(bebob, master, rate);
+		err = start_stream(bebob, &bebob->rx_stream, rate);
 		if (err < 0) {
 			dev_err(&bebob->unit->device,
 				"fail to run AMDTP master stream:%d\n", err);
@@ -685,15 +646,16 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 				dev_err(&bebob->unit->device,
 					"fail to ensure sampling rate: %d\n",
 					err);
-				amdtp_stream_stop(master);
+				amdtp_stream_stop(&bebob->rx_stream);
 				break_both_connections(bebob);
 				goto end;
 			}
 		}
 
 		/* wait first callback */
-		if (!amdtp_stream_wait_callback(master, CALLBACK_TIMEOUT)) {
-			amdtp_stream_stop(master);
+		if (!amdtp_stream_wait_callback(&bebob->rx_stream,
+						CALLBACK_TIMEOUT)) {
+			amdtp_stream_stop(&bebob->rx_stream);
 			break_both_connections(bebob);
 			err = -ETIMEDOUT;
 			goto end;
@@ -701,20 +663,21 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	}
 
 	/* start slave if needed */
-	if (!amdtp_stream_running(slave)) {
-		err = start_stream(bebob, slave, rate);
+	if (!amdtp_stream_running(&bebob->tx_stream)) {
+		err = start_stream(bebob, &bebob->tx_stream, rate);
 		if (err < 0) {
 			dev_err(&bebob->unit->device,
 				"fail to run AMDTP slave stream:%d\n", err);
-			amdtp_stream_stop(master);
+			amdtp_stream_stop(&bebob->rx_stream);
 			break_both_connections(bebob);
 			goto end;
 		}
 
 		/* wait first callback */
-		if (!amdtp_stream_wait_callback(slave, CALLBACK_TIMEOUT)) {
-			amdtp_stream_stop(slave);
-			amdtp_stream_stop(master);
+		if (!amdtp_stream_wait_callback(&bebob->tx_stream,
+						CALLBACK_TIMEOUT)) {
+			amdtp_stream_stop(&bebob->tx_stream);
+			amdtp_stream_stop(&bebob->rx_stream);
 			break_both_connections(bebob);
 			err = -ETIMEDOUT;
 		}
@@ -725,22 +688,12 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 
 void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 {
-	struct amdtp_stream *master, *slave;
-
-	if (bebob->master == &bebob->rx_stream) {
-		slave  = &bebob->tx_stream;
-		master = &bebob->rx_stream;
-	} else {
-		slave  = &bebob->rx_stream;
-		master = &bebob->tx_stream;
-	}
-
 	if (bebob->substreams_counter == 0) {
-		amdtp_stream_pcm_abort(master);
-		amdtp_stream_stop(master);
+		amdtp_stream_pcm_abort(&bebob->rx_stream);
+		amdtp_stream_stop(&bebob->rx_stream);
 
-		amdtp_stream_pcm_abort(slave);
-		amdtp_stream_stop(slave);
+		amdtp_stream_pcm_abort(&bebob->tx_stream);
+		amdtp_stream_stop(&bebob->tx_stream);
 
 		break_both_connections(bebob);
 	}

commit 3800e6f944e929ddfcd9320a51e13a67fd1956ff
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 20 16:18:59 2016 +0900

    ALSA: bebob: give up updating streams at bus reset handler
    
    DM1000/DM1100/DM1500 chipsets transfer packets with discontinue value in
    'dbc' field of CIP header. For ALSA bebob driver, this makes its bus-reset
    handler meaningless, because the discontinuity is detected quite earlier
    than executing the handler.
    
    This commit gives up updating streams at the bus reset handler.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 8c687456a0e6..77cbb02bff34 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -746,21 +746,6 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 	}
 }
 
-void snd_bebob_stream_update_duplex(struct snd_bebob *bebob)
-{
-	if ((cmp_connection_update(&bebob->in_conn) < 0) ||
-	    (cmp_connection_update(&bebob->out_conn) < 0)) {
-		amdtp_stream_pcm_abort(&bebob->rx_stream);
-		amdtp_stream_pcm_abort(&bebob->tx_stream);
-		amdtp_stream_stop(&bebob->rx_stream);
-		amdtp_stream_stop(&bebob->tx_stream);
-		break_both_connections(bebob);
-	} else {
-		amdtp_stream_update(&bebob->rx_stream);
-		amdtp_stream_update(&bebob->tx_stream);
-	}
-}
-
 /*
  * This function should be called before starting streams or after stopping
  * streams.

commit 4fd6c6c7295a50aa9390a3131623456e0c05d8f9
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 20 16:18:58 2016 +0900

    ALSA: bebob: change type of substream counter from atomic_t to unsigned int
    
    The counter is incremented/decremented in critical section protected with
    mutex. Therefore, no need to use atomic_t.
    
    This commit changes the type to unsigned int.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 6809913110f4..8c687456a0e6 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -590,7 +590,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	int err = 0;
 
 	/* Need no substreams */
-	if (atomic_read(&bebob->substreams_counter) == 0)
+	if (bebob->substreams_counter == 0)
 		goto end;
 
 	err = get_sync_mode(bebob, &sync_mode);
@@ -735,7 +735,7 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 		master = &bebob->tx_stream;
 	}
 
-	if (atomic_read(&bebob->substreams_counter) == 0) {
+	if (bebob->substreams_counter == 0) {
 		amdtp_stream_pcm_abort(master);
 		amdtp_stream_stop(master);
 

commit 2a71e701660d7aa9ce1a740588dbf13b975deb10
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 20 16:18:57 2016 +0900

    ALSA: bebob: move mutex from function callee to callers
    
    Currently, critical section is protected by mutex in functions of
    fireworks_stream.c. Callers increments/decrements substreams counter
    before calling the functions. Moving mutex to the callers code allows
    to change type of the substream counter from atomic_t to unsigned int.
    
    This commit is a preparation for obsoleting usage of atomic_t for
    substream counter.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 073ad6d8a76e..6809913110f4 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -589,8 +589,6 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	unsigned int curr_rate;
 	int err = 0;
 
-	mutex_lock(&bebob->mutex);
-
 	/* Need no substreams */
 	if (atomic_read(&bebob->substreams_counter) == 0)
 		goto end;
@@ -722,7 +720,6 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 		}
 	}
 end:
-	mutex_unlock(&bebob->mutex);
 	return err;
 }
 
@@ -738,8 +735,6 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 		master = &bebob->tx_stream;
 	}
 
-	mutex_lock(&bebob->mutex);
-
 	if (atomic_read(&bebob->substreams_counter) == 0) {
 		amdtp_stream_pcm_abort(master);
 		amdtp_stream_stop(master);
@@ -749,8 +744,6 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 
 		break_both_connections(bebob);
 	}
-
-	mutex_unlock(&bebob->mutex);
 }
 
 void snd_bebob_stream_update_duplex(struct snd_bebob *bebob)

commit 14a37ac1bf8a2ba9b19032195c371c7b0857ca87
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 20 16:18:56 2016 +0900

    ALSA: bebob: simplify bus-reset handling
    
    At bus-reset, DM1000/DM1100/DM1500 chipsets transfer packets with
    discontinuous value in 'dbc' field of CIP header. In this case, packet
    streaming layer in firewire-lib module stops streaming and set XRUN to PCM
    substream.
    
    In ALSA, PCM applications are notified the XRUN status by the return value
    of ALSA PCM interface. They can recover this state by executing
    snd_pcm_prepare(), then PCM drivers' prepare handler is called, and start
    new PCM substream. For ALSA BeBoB driver, the handler establishes new
    connections and start new AMDTP streaming.
    
    Unfortunately, neither the PCM applications nor the driver know the reason
    of XRUN. The driver gets to know the reason when update handler is called
    by IEEE 1394 bus driver. As long as I tested, the order of below events are
    not fixed:
     * Detecting packet discontinuity in tasklet context of OHCI 1394 driver
     * Calling prepare handler in process context of ALSA PCM application
     * Calling update handler in kthread context of IEEE 1394 bus driver
    
    The unpredictable order is disadvantage for the driver to be compliant to
    CMP. In IEC 61883-1, new CMP establish operations should be done 1 sec
    (isoc_resource_delay) after bus-reset. Within 1 sec, CMP restore
    operations are allowed. For this reason, in former commit ('b6bc812327aa:
    ALSA: bebob/firewire-lib: Add a quirk for discontinuity at bus reset'),
    the process context is forced to wait for executing update handler. The
    process context wait for bus-reset up to 1 sec. This commit solves the
    issue, while causes more disadvantages. For PCM applications, calling
    snd_pcm_prepare() for recovering XRUN state takes more time and the driver
    got a bit complicated code, while the recovery is not always successful.
    
    As long as I tested, DM1000/DM1100/DM1500 and BeBoB firmware can allow
    drivers to establish new connections just after bus reset. Furthermore,
    any FCP transactions are handled correctly. Therefore, the driver don't
    need to wait for bus reset handler for starting new streaming.
    
    This commit removes the codes to reduce maintenance cost.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 5022c9b97ddf..073ad6d8a76e 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -549,8 +549,7 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 		destroy_both_connections(bebob);
 		goto end;
 	}
-	/* See comments in next function */
-	init_completion(&bebob->bus_reset);
+
 	bebob->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK;
 
 	/*
@@ -588,25 +587,8 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	struct amdtp_stream *master, *slave;
 	enum cip_flags sync_mode;
 	unsigned int curr_rate;
-	bool updated = false;
 	int err = 0;
 
-	/*
-	 * Normal BeBoB firmware has a quirk at bus reset to transmits packets
-	 * with discontinuous value in dbc field.
-	 *
-	 * This 'struct completion' is used to call .update() at first to update
-	 * connections/streams. Next following codes handle streaming error.
-	 */
-	if (amdtp_streaming_error(&bebob->tx_stream)) {
-		if (completion_done(&bebob->bus_reset))
-			reinit_completion(&bebob->bus_reset);
-
-		updated = (wait_for_completion_interruptible_timeout(
-				&bebob->bus_reset,
-				msecs_to_jiffies(FW_ISO_RESOURCE_DELAY)) > 0);
-	}
-
 	mutex_lock(&bebob->mutex);
 
 	/* Need no substreams */
@@ -642,8 +624,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 		amdtp_stream_stop(master);
 	if (amdtp_streaming_error(slave))
 		amdtp_stream_stop(slave);
-	if (!updated &&
-	    !amdtp_stream_running(master) && !amdtp_stream_running(slave))
+	if (!amdtp_stream_running(master) && !amdtp_stream_running(slave))
 		break_both_connections(bebob);
 
 	/* stop streams if rate is different */
@@ -774,9 +755,6 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 
 void snd_bebob_stream_update_duplex(struct snd_bebob *bebob)
 {
-	/* vs. XRUN recovery due to discontinuity at bus reset */
-	mutex_lock(&bebob->mutex);
-
 	if ((cmp_connection_update(&bebob->in_conn) < 0) ||
 	    (cmp_connection_update(&bebob->out_conn) < 0)) {
 		amdtp_stream_pcm_abort(&bebob->rx_stream);
@@ -788,12 +766,6 @@ void snd_bebob_stream_update_duplex(struct snd_bebob *bebob)
 		amdtp_stream_update(&bebob->rx_stream);
 		amdtp_stream_update(&bebob->tx_stream);
 	}
-
-	/* wake up stream_start_duplex() */
-	if (!completion_done(&bebob->bus_reset))
-		complete_all(&bebob->bus_reset);
-
-	mutex_unlock(&bebob->mutex);
 }
 
 /*

commit 07905298e4d5777eb58516cdc242f7ac1ca387a2
Author: Lucas Tanure <tanure@linux.com>
Date:   Mon Jan 25 19:30:23 2016 -0200

    ALSA: bebob: Use a signed return type for get_formation_index
    
    The return type "unsigned int" was used by the get_formation_index function
    despite of the aspect that it will eventually return a negative error code.
    So, change to signed int and get index by reference in the parameters.
    
    Done with the help of Coccinelle.
    
    [Fix the missing braces suggested by Julia Lawall -- tiwai]
    
    Signed-off-by: Lucas Tanure <tanure@linux.com>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Tested-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 926e5dcbb66a..5022c9b97ddf 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -47,14 +47,16 @@ static const unsigned int bridgeco_freq_table[] = {
 	[6] = 0x07,
 };
 
-static unsigned int
-get_formation_index(unsigned int rate)
+static int
+get_formation_index(unsigned int rate, unsigned int *index)
 {
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(snd_bebob_rate_table); i++) {
-		if (snd_bebob_rate_table[i] == rate)
-			return i;
+		if (snd_bebob_rate_table[i] == rate) {
+			*index = i;
+			return 0;
+		}
 	}
 	return -EINVAL;
 }
@@ -425,7 +427,9 @@ make_both_connections(struct snd_bebob *bebob, unsigned int rate)
 		goto end;
 
 	/* confirm params for both streams */
-	index = get_formation_index(rate);
+	err = get_formation_index(rate, &index);
+	if (err < 0)
+		goto end;
 	pcm_channels = bebob->tx_stream_formations[index].pcm;
 	midi_channels = bebob->tx_stream_formations[index].midi;
 	err = amdtp_am824_set_parameters(&bebob->tx_stream, rate,

commit 6b9866c893fc6a51e74df65fd9d9f851a3c2872e
Author: Julia Lawall <julia.lawall@lip6.fr>
Date:   Sun Oct 11 08:10:55 2015 +0200

    ALSA: bebob: constify various snd_bebob structures
    
    The structures of type snd_bebob_clock_spec, snd_bebob_rate_spec,
    snd_bebob_meter_spec, and snd_bebob_spec are never modified after they are
    initialized.  Make them all const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Tested-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index a2baa478d4ba..926e5dcbb66a 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -119,7 +119,7 @@ snd_bebob_stream_set_rate(struct snd_bebob *bebob, unsigned int rate)
 int snd_bebob_stream_get_clock_src(struct snd_bebob *bebob,
 				   enum snd_bebob_clock_type *src)
 {
-	struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;
+	const struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;
 	u8 addr[AVC_BRIDGECO_ADDR_BYTES], input[7];
 	unsigned int id;
 	enum avc_bridgeco_plug_type type;
@@ -580,7 +580,7 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 
 int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 {
-	struct snd_bebob_rate_spec *rate_spec = bebob->spec->rate;
+	const struct snd_bebob_rate_spec *rate_spec = bebob->spec->rate;
 	struct amdtp_stream *master, *slave;
 	enum cip_flags sync_mode;
 	unsigned int curr_rate;
@@ -967,7 +967,7 @@ seek_msu_sync_input_plug(struct snd_bebob *bebob)
 
 int snd_bebob_stream_discover(struct snd_bebob *bebob)
 {
-	struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;
+	const struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;
 	u8 plugs[AVC_PLUG_INFO_BUF_BYTES], addr[AVC_BRIDGECO_ADDR_BYTES];
 	enum avc_bridgeco_plug_type type;
 	unsigned int i;

commit 49c7b3fcd9f0a0125e8cd8212d5576382198eeb2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:22:01 2015 +0900

    ALSA: firewire-lib: rename macros with AM824 prefix
    
    This commit renames some macros just related to AM824 format. In later
    commit, they're moved to AM824 layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index cf6402d371e7..a2baa478d4ba 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -354,7 +354,7 @@ map_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)
 			case 0x09:	/* Digital */
 			default:
 				location = pcm + sec_loc;
-				if (location >= AMDTP_MAX_CHANNELS_FOR_PCM) {
+				if (location >= AM824_MAX_CHANNELS_FOR_PCM) {
 					err = -ENOSYS;
 					goto end;
 				}
@@ -872,8 +872,8 @@ parse_stream_formation(u8 *buf, unsigned int len,
 		}
 	}
 
-	if (formation[i].pcm  > AMDTP_MAX_CHANNELS_FOR_PCM ||
-	    formation[i].midi > AMDTP_MAX_CHANNELS_FOR_MIDI)
+	if (formation[i].pcm  > AM824_MAX_CHANNELS_FOR_PCM ||
+	    formation[i].midi > AM824_MAX_CHANNELS_FOR_MIDI)
 		return -ENOSYS;
 
 	return 0;

commit f65be911c0e13fab28919e17c9fa00c38dc4ff2f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:58 2015 +0900

    ALSA: firewire-lib: add helper functions to set positions of data channels
    
    In IEC 61883-6, several types of data are available in AM824 format. The
    data is transferred in each data channel. The position of data channel in
    data block differs depending on model.
    
    Current implementation has an array to map the index of data channel in an
    data block to the position of actual data channel. The implementation
    allows each driver to access the mapping directly.
    
    In later commit, the mapping is in specific structure pushed into an
    opaque pointer. Helper functions are required.
    
    This commit adds the helper functions for this purpose. In IEC 61883-6,
    AM824 format supports many data types, while this specification easily
    causes over-engineering. Current AM824 implementation is allowed to handle
    two types of data, Multi Bit Linear Audio data (=PCM samples) and MIDI
    conformant data (=MIDI messages).
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index fa510f30cf8f..cf6402d371e7 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -338,7 +338,7 @@ map_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)
 					err = -ENOSYS;
 					goto end;
 				}
-				s->midi_position = stm_pos;
+				amdtp_am824_set_midi_position(s, stm_pos);
 				midi = stm_pos;
 				break;
 			/* for PCM data channel */
@@ -358,7 +358,8 @@ map_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)
 					err = -ENOSYS;
 					goto end;
 				}
-				s->pcm_positions[location] = stm_pos;
+				amdtp_am824_set_pcm_position(s, location,
+							     stm_pos);
 				break;
 			}
 		}

commit 51c29fd21389d9995a8a18a91eeb8dd1220a2119
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:56 2015 +0900

    ALSA: firewire-lib: rename parameter setting function for AM824 with FDF field
    
    The value of FDF field in CIP header is protocol-dependent. Thus, it's
    better to allow data block processing layer to decide the value in any
    timing.
    
    In AM824 data format, the value of FDF field in CIP header indicates
    N-flag and Nominal Sampling Frequency Code (sfc). The N-flag is for
    switching 'Clock-based rate control mode' and 'Command-based rate control
    mode'. In our implementation, 'Clock-based rate control mode' is just
    supported. Therefore, When sampling transfer frequency is decided, then
    the FDF can be set.
    
    This commit replaces 'amdtp_stream_set_parameters' with
    'amdtp_am824_set_parameters' to set the FDF. This is the same timing
    to decide the ration between the number of data blocks and the number of
    PCM frames.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 34bc3a419993..fa510f30cf8f 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -427,17 +427,17 @@ make_both_connections(struct snd_bebob *bebob, unsigned int rate)
 	index = get_formation_index(rate);
 	pcm_channels = bebob->tx_stream_formations[index].pcm;
 	midi_channels = bebob->tx_stream_formations[index].midi;
-	err = amdtp_stream_set_parameters(&bebob->tx_stream, rate,
-					  pcm_channels, midi_channels * 8,
-					  false);
+	err = amdtp_am824_set_parameters(&bebob->tx_stream, rate,
+					 pcm_channels, midi_channels * 8,
+					 false);
 	if (err < 0)
 		goto end;
 
 	pcm_channels = bebob->rx_stream_formations[index].pcm;
 	midi_channels = bebob->rx_stream_formations[index].midi;
-	err = amdtp_stream_set_parameters(&bebob->rx_stream, rate,
-					  pcm_channels, midi_channels * 8,
-					  false);
+	err = amdtp_am824_set_parameters(&bebob->rx_stream, rate,
+					 pcm_channels, midi_channels * 8,
+					 false);
 	if (err < 0)
 		goto end;
 

commit 5955815e71ff9c773b156680c781c87728e37bea
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:55 2015 +0900

    ALSA: firewire-lib: add data block processing layer for AM824 format
    
    This commit adds data block processing layer for AM824 format. The new
    layer initializes streaming layer with its value for fmt field.
    
    Currently, most implementation of data block processing still remains
    streaming layer. In later commits, these codes will be moved to the layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 920a3b8844ee..34bc3a419993 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -537,8 +537,8 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 	if (err < 0)
 		goto end;
 
-	err = amdtp_stream_init(&bebob->tx_stream, bebob->unit,
-				AMDTP_IN_STREAM, CIP_BLOCKING);
+	err = amdtp_am824_init(&bebob->tx_stream, bebob->unit,
+			       AMDTP_IN_STREAM, CIP_BLOCKING);
 	if (err < 0) {
 		amdtp_stream_destroy(&bebob->tx_stream);
 		destroy_both_connections(bebob);
@@ -566,8 +566,8 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 	if (bebob->maudio_special_quirk)
 		bebob->tx_stream.flags |= CIP_EMPTY_HAS_WRONG_DBC;
 
-	err = amdtp_stream_init(&bebob->rx_stream, bebob->unit,
-				AMDTP_OUT_STREAM, CIP_BLOCKING);
+	err = amdtp_am824_init(&bebob->rx_stream, bebob->unit,
+			       AMDTP_OUT_STREAM, CIP_BLOCKING);
 	if (err < 0) {
 		amdtp_stream_destroy(&bebob->tx_stream);
 		amdtp_stream_destroy(&bebob->rx_stream);

commit 27ec83b5c6ac08599240ec9a95286e79d6ea9e51
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:50 2015 +0900

    ALSA: firewire-lib: add an argument for Dice's dual wire mode
    
    In IEC 61883-6, one data block represents one event. In ALSA, the event is
    one PCM frame. Therefore, when processing one data block, current
    implementation counts one PCM frame.
    
    On the other hand, Dice platform has a quirk called as 'dual wire' at
    higher sampling rate. In detail, see comment of commit 6eb6c81eee2a
    ("ALSA: dice: Split stream functionality into a file").
    
    Currently, to handle this quirk, AMDTP stream structure has a
    'double_pcm_frames' member. When this is enabled, two PCM frames are
    counted. Each driver set this flag by accessing the structure member
    directly.
    
    In future commit, some members related to AM824 data block will be moved
    to specific structure, to separate packet streaming layer and data block
    processing layer. The access will be limited by opaque pointer.
    
    For this reason, this commit adds an argument into
    amdtp_stream_set_parameter() to set the flag.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index c642b79e7ed4..920a3b8844ee 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -428,14 +428,16 @@ make_both_connections(struct snd_bebob *bebob, unsigned int rate)
 	pcm_channels = bebob->tx_stream_formations[index].pcm;
 	midi_channels = bebob->tx_stream_formations[index].midi;
 	err = amdtp_stream_set_parameters(&bebob->tx_stream, rate,
-					  pcm_channels, midi_channels * 8);
+					  pcm_channels, midi_channels * 8,
+					  false);
 	if (err < 0)
 		goto end;
 
 	pcm_channels = bebob->rx_stream_formations[index].pcm;
 	midi_channels = bebob->rx_stream_formations[index].midi;
 	err = amdtp_stream_set_parameters(&bebob->rx_stream, rate,
-					  pcm_channels, midi_channels * 8);
+					  pcm_channels, midi_channels * 8,
+					  false);
 	if (err < 0)
 		goto end;
 

commit 547e631ce3886175a33b5ccf67729bdd18e9b7e0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:49 2015 +0900

    ALSA: firewire-lib: return error code when amdtp_stream_set_parameters() detects error
    
    Currently, amdtp_stream_set_parameters() returns no error even if wrong
    arguments are given. This is not good for streaming layer because drivers
    can continue processing ignoring capability of streaming layer.
    
    This commit changes this function to return error code.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 5be5242e1ed8..c642b79e7ed4 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -427,12 +427,17 @@ make_both_connections(struct snd_bebob *bebob, unsigned int rate)
 	index = get_formation_index(rate);
 	pcm_channels = bebob->tx_stream_formations[index].pcm;
 	midi_channels = bebob->tx_stream_formations[index].midi;
-	amdtp_stream_set_parameters(&bebob->tx_stream,
-				    rate, pcm_channels, midi_channels * 8);
+	err = amdtp_stream_set_parameters(&bebob->tx_stream, rate,
+					  pcm_channels, midi_channels * 8);
+	if (err < 0)
+		goto end;
+
 	pcm_channels = bebob->rx_stream_formations[index].pcm;
 	midi_channels = bebob->rx_stream_formations[index].midi;
-	amdtp_stream_set_parameters(&bebob->rx_stream,
-				    rate, pcm_channels, midi_channels * 8);
+	err = amdtp_stream_set_parameters(&bebob->rx_stream, rate,
+					  pcm_channels, midi_channels * 8);
+	if (err < 0)
+		goto end;
 
 	/* establish connections for both streams */
 	err = cmp_connection_establish(&bebob->out_conn,

commit 8d1c2694e45bd5a1b7e79734952e8dfb6f2974a6
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 14 12:49:36 2015 +0900

    ALSA: bebob: keep duplex streams always to keep internal multiplexer properly
    
    Behringer FCA610 transmits packets with periodic noisy PCM samples
    when receiving no streams, and generates a bit noisy sound.
    
    ALSA BeBoB driver is programmed to establish both in/out connections
    when starting streaming, then transfers packets as userspace applications
    requested. This means that there's a case that one of incoming/outgoing
    streams is running, to save CPU and bandwidth usage. Although, it's natural
    to start transferring packets in both direction.
    
    This commit makes this driver to keeps duplex streams always.
    
    Tested-by: Kim Tore Jensen <kim@incendio.no>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index d0df6c17f7f7..5be5242e1ed8 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -574,7 +574,6 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 {
 	struct snd_bebob_rate_spec *rate_spec = bebob->spec->rate;
 	struct amdtp_stream *master, *slave;
-	atomic_t *slave_substreams;
 	enum cip_flags sync_mode;
 	unsigned int curr_rate;
 	bool updated = false;
@@ -599,8 +598,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	mutex_lock(&bebob->mutex);
 
 	/* Need no substreams */
-	if (atomic_read(&bebob->playback_substreams) == 0 &&
-	    atomic_read(&bebob->capture_substreams)  == 0)
+	if (atomic_read(&bebob->substreams_counter) == 0)
 		goto end;
 
 	err = get_sync_mode(bebob, &sync_mode);
@@ -609,11 +607,9 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	if (sync_mode == CIP_SYNC_TO_DEVICE) {
 		master = &bebob->tx_stream;
 		slave  = &bebob->rx_stream;
-		slave_substreams = &bebob->playback_substreams;
 	} else {
 		master = &bebob->rx_stream;
 		slave  = &bebob->tx_stream;
-		slave_substreams = &bebob->capture_substreams;
 	}
 
 	/*
@@ -714,7 +710,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 	}
 
 	/* start slave if needed */
-	if (atomic_read(slave_substreams) > 0 && !amdtp_stream_running(slave)) {
+	if (!amdtp_stream_running(slave)) {
 		err = start_stream(bebob, slave, rate);
 		if (err < 0) {
 			dev_err(&bebob->unit->device,
@@ -740,31 +736,25 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 {
 	struct amdtp_stream *master, *slave;
-	atomic_t *master_substreams, *slave_substreams;
 
 	if (bebob->master == &bebob->rx_stream) {
 		slave  = &bebob->tx_stream;
 		master = &bebob->rx_stream;
-		slave_substreams  = &bebob->capture_substreams;
-		master_substreams = &bebob->playback_substreams;
 	} else {
 		slave  = &bebob->rx_stream;
 		master = &bebob->tx_stream;
-		slave_substreams  = &bebob->playback_substreams;
-		master_substreams = &bebob->capture_substreams;
 	}
 
 	mutex_lock(&bebob->mutex);
 
-	if (atomic_read(slave_substreams) == 0) {
+	if (atomic_read(&bebob->substreams_counter) == 0) {
+		amdtp_stream_pcm_abort(master);
+		amdtp_stream_stop(master);
+
 		amdtp_stream_pcm_abort(slave);
 		amdtp_stream_stop(slave);
 
-		if (atomic_read(master_substreams) == 0) {
-			amdtp_stream_pcm_abort(master);
-			amdtp_stream_stop(master);
-			break_both_connections(bebob);
-		}
+		break_both_connections(bebob);
 	}
 
 	mutex_unlock(&bebob->mutex);

commit c4d860a0d256663937b51468ea13de3c2cd2a09d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 14 12:49:35 2015 +0900

    ALSA: bebob: loosen up severity of checking continuity for BeBoB v3 quirk
    
    PrismSound Orpheus, Behringer UFX1604 and FCA610 work with BeBoB v3, and
    they're confirmed to transmit discontinuous packets in the beginning of
    streaming.
    
    payload    CIP headers
      8        0x00070000 0x9002FFFF
      8        0x00070000 0x9002FFFF
      8        0x00070000 0x9002FFFF
      8        0x00070008 0x9002FFFF <-
      8        0x00070008 0x9002FFFF
      8        0x00070008 0x9002FFFF
      8        0x00070008 0x9002FFFF
      8        0x00070008 0x9002FFFF
      8        0x00070008 0x9002FFFF
    232        0x00070000 0x9002E798 <-
    232        0x00070008 0x9002FB99
    232        0x00070010 0x90021398
      8        0x00070018 0x9002FFFF
    (This sample was got with Behringer FCA610 and FFADO library.)
    
    This commit sets CIP_EMPTY_HAS_WRONG_DBC and CIP_SKIP_DBC_ZERO_CHECK to
    ignore these discontinuities.
    
    Tested-by: Kim Tore Jensen <kim@incendio.no>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 9c810f9ec8d6..d0df6c17f7f7 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -540,6 +540,17 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 	/* See comments in next function */
 	init_completion(&bebob->bus_reset);
 	bebob->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK;
+
+	/*
+	 * BeBoB v3 transfers packets with these qurks:
+	 *  - In the beginning of streaming, the value of dbc is incremented
+	 *    even if no data blocks are transferred.
+	 *  - The value of dbc is reset suddenly.
+	 */
+	if (bebob->version > 2)
+		bebob->tx_stream.flags |= CIP_EMPTY_HAS_WRONG_DBC |
+					  CIP_SKIP_DBC_ZERO_CHECK;
+
 	/*
 	 * At high sampling rate, M-Audio special firmware transmits empty
 	 * packet with the value of dbc incremented by 8 but the others are

commit 9a73195e614bf01722331c820c260b9cb77e634e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 14 12:49:34 2015 +0900

    ALSA: bebob: expand timeout for DM1500 quirk
    
    Behringer FCA610 and UFX1604 is confirmed to require more time till
    transmitting packets after establishing connections. This seems to
    be a quirk of DM1500 ASIC which ArchWave produced.
    
    For this quirk, this commit extends the time to wait up to 2 seconds.
    As a result, in worst cases, below userspace functions require 2 seconds
    to return.
     - snd_pcm_prepare()
     - snd_pcm_hw_params()
     - snd_pcm_recover()
    
    Tested-by: Kim Tore Jensen <kim@incendio.no>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 5335c300728c..9c810f9ec8d6 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -8,7 +8,7 @@
 
 #include "./bebob.h"
 
-#define CALLBACK_TIMEOUT	1000
+#define CALLBACK_TIMEOUT	2000
 #define FW_ISO_RESOURCE_DELAY	1000
 
 /*

commit 05773792716e5a75b0f4bf4edcdc1e9c3b199ab8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 14 12:49:32 2015 +0900

    ALSA: bebob: add SYT-Match support
    
    In previous commits, this driver can detect the source of clock as mush
    as possible. SYT-Match mode is also available.
    
    This commit purge the restriction.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index c8af8ffe2d53..5335c300728c 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -474,8 +474,24 @@ destroy_both_connections(struct snd_bebob *bebob)
 static int
 get_sync_mode(struct snd_bebob *bebob, enum cip_flags *sync_mode)
 {
-	/* currently this module doesn't support SYT-Match mode */
-	*sync_mode = CIP_SYNC_TO_DEVICE;
+	enum snd_bebob_clock_type src;
+	int err;
+
+	err = snd_bebob_stream_get_clock_src(bebob, &src);
+	if (err < 0)
+		return err;
+
+	switch (src) {
+	case SND_BEBOB_CLOCK_TYPE_INTERNAL:
+	case SND_BEBOB_CLOCK_TYPE_EXTERNAL:
+		*sync_mode = CIP_SYNC_TO_DEVICE;
+		break;
+	default:
+	case SND_BEBOB_CLOCK_TYPE_SYT:
+		*sync_mode = 0;
+		break;
+	}
+
 	return 0;
 }
 

commit 3e254b16b65dbbcc2528781070e1be0f7945f220
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 14 12:49:30 2015 +0900

    ALSA: bebob: use normalized representation for the type of clock source
    
    This commit changes function prototype and its processing. As a result,
    function caller can execute additional processing according to detected
    clock source.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 2ccef4ce050d..c8af8ffe2d53 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -116,8 +116,8 @@ snd_bebob_stream_set_rate(struct snd_bebob *bebob, unsigned int rate)
 	return err;
 }
 
-int
-snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
+int snd_bebob_stream_get_clock_src(struct snd_bebob *bebob,
+				   enum snd_bebob_clock_type *src)
 {
 	struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;
 	u8 addr[AVC_BRIDGECO_ADDR_BYTES], input[7];
@@ -125,8 +125,6 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 	enum avc_bridgeco_plug_type type;
 	int err = 0;
 
-	*internal = false;
-
 	/* 1.The device has its own operation to switch source of clock */
 	if (clk_spec) {
 		err = clk_spec->get(bebob, &id);
@@ -144,10 +142,7 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 			goto end;
 		}
 
-		if (strncmp(clk_spec->labels[id], SND_BEBOB_CLOCK_INTERNAL,
-			    strlen(SND_BEBOB_CLOCK_INTERNAL)) == 0)
-			*internal = true;
-
+		*src = clk_spec->types[id];
 		goto end;
 	}
 
@@ -156,7 +151,7 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 	 *   to use internal clock always
 	 */
 	if (bebob->sync_input_plug < 0) {
-		*internal = true;
+		*src = SND_BEBOB_CLOCK_TYPE_INTERNAL;
 		goto end;
 	}
 
@@ -179,7 +174,7 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 	 * Here check the first field. This field is used for direction.
 	 */
 	if (input[0] == 0xff) {
-		*internal = true;
+		*src = SND_BEBOB_CLOCK_TYPE_INTERNAL;
 		goto end;
 	}
 
@@ -192,7 +187,7 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 		 */
 		if (input[1] == AVC_BRIDGECO_PLUG_MODE_SUBUNIT &&
 		    input[2] == 0x0c) {
-			*internal = true;
+			*src = SND_BEBOB_CLOCK_TYPE_INTERNAL;
 			goto end;
 		}
 	/* The source from any input units is for several purposes. */
@@ -206,7 +201,7 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 				 * short, this driver is the master of
 				 * synchronization.
 				 */
-				err = -EIO;
+				*src = SND_BEBOB_CLOCK_TYPE_SYT;
 				goto end;
 			} else {
 				/*
@@ -214,7 +209,7 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 				 * means that the synchronization stream is not
 				 * the Audio/MIDI compound stream.
 				 */
-				*internal = false;
+				*src = SND_BEBOB_CLOCK_TYPE_EXTERNAL;
 				goto end;
 			}
 		} else if (input[2] == AVC_BRIDGECO_PLUG_UNIT_EXT) {
@@ -233,18 +228,18 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 				 * SPDIF/ADAT or sometimes (not always) word
 				 * clock.
 				 */
-				*internal = false;
+				*src = SND_BEBOB_CLOCK_TYPE_EXTERNAL;
 				goto end;
 			} else if (type == AVC_BRIDGECO_PLUG_TYPE_SYNC) {
 				/* Often word clock. */
-				*internal = false;
+				*src = SND_BEBOB_CLOCK_TYPE_EXTERNAL;
 				goto end;
 			} else if (type == AVC_BRIDGECO_PLUG_TYPE_ADDITION) {
 				/*
 				 * Not standard.
 				 * Mostly, additional internal clock.
 				 */
-				*internal = true;
+				*src = SND_BEBOB_CLOCK_TYPE_INTERNAL;
 				goto end;
 			}
 		}

commit 5a6688127082683f8c343da7d326dc22e45f4e4b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 14 12:49:27 2015 +0900

    ALSA: bebob: improve signal mode detection for clock source
    
    With BeBoB version 3, current ALSA BeBoB driver detects the type of
    current clock signal source wrongly. This is due to a lack of proper
    implementation to parse the information.
    
    This commit renews the parser. As a result, this driver detects
    SYT-Match clock signal, thus it can start streams with two modes;
    SYT-Match mode and the others. SYT-Match mode will be supported in future
    commits.
    
    There's a constrain about detected internal/external clock source.
    When detecting external clock source, this driver allows userspace
    applications to use current sampling rate only. This is due to consider
    abour synchronization to external clock sources such as S/PDIF, ADAT or
    word-clock.
    
    According to several information from some devices, I guesss that the
    internal clock of most devices synchronize to IEEE 1394 cycle start
    packet. In this case, by a usual way, it's detect as 'Sync type
    of output Music Sub-Unit' connected to 'Sync type of PCR output Unit
    (oPCR)', and this driver judges it as internal clock. Therefore,
    userspace applications is allowed to request arbitrary supported sampling
    rates.
    
    On the other hand, several devices based on BeBoB version 3 have
    additional internal clock. In this case, by a usual way, it's detect as
    'Sync/Additional type of External input Unit'. Unfortunately, there's no
    way to distinguish this sync type from the other external clock sources
    such as word-clock. In this case, this driver handles it as external and
    userspace applications is forced to use current sampling rate.
    
    I note that when the source of clock is detected as 'Isochronous stream
    type of input PCR[0]', it's under 'SYT-Match' mode. In this mode, the
    synchronization clock is generated according to SYT-series in received
    packets. In this case, this driver generates the series by myself. I
    experienced this mode often make the device silent suddenly during
    playbacking. This means that the mode is easy to lost synchronization.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 98e4fc8121a1..2ccef4ce050d 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -122,6 +122,7 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 	struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;
 	u8 addr[AVC_BRIDGECO_ADDR_BYTES], input[7];
 	unsigned int id;
+	enum avc_bridgeco_plug_type type;
 	int err = 0;
 
 	*internal = false;
@@ -182,14 +183,75 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 		goto end;
 	}
 
-	/*
-	 * If source of clock is internal CSR, Music Sub Unit Sync Input is
-	 * a destination of Music Sub Unit Sync Output.
-	 */
-	*internal = ((input[0] == AVC_BRIDGECO_PLUG_DIR_OUT) &&
-		     (input[1] == AVC_BRIDGECO_PLUG_MODE_SUBUNIT) &&
-		     (input[2] == 0x0c) &&
-		     (input[3] == 0x00));
+	/* The source from any output plugs is for one purpose only. */
+	if (input[0] == AVC_BRIDGECO_PLUG_DIR_OUT) {
+		/*
+		 * In BeBoB architecture, the source from music subunit may
+		 * bypass from oPCR[0]. This means that this source gives
+		 * synchronization to IEEE 1394 cycle start packet.
+		 */
+		if (input[1] == AVC_BRIDGECO_PLUG_MODE_SUBUNIT &&
+		    input[2] == 0x0c) {
+			*internal = true;
+			goto end;
+		}
+	/* The source from any input units is for several purposes. */
+	} else if (input[1] == AVC_BRIDGECO_PLUG_MODE_UNIT) {
+		if (input[2] == AVC_BRIDGECO_PLUG_UNIT_ISOC) {
+			if (input[3] == 0x00) {
+				/*
+				 * This source comes from iPCR[0]. This means
+				 * that presentation timestamp calculated by
+				 * SYT series of the received packets. In
+				 * short, this driver is the master of
+				 * synchronization.
+				 */
+				err = -EIO;
+				goto end;
+			} else {
+				/*
+				 * This source comes from iPCR[1-29]. This
+				 * means that the synchronization stream is not
+				 * the Audio/MIDI compound stream.
+				 */
+				*internal = false;
+				goto end;
+			}
+		} else if (input[2] == AVC_BRIDGECO_PLUG_UNIT_EXT) {
+			/* Check type of this plug.  */
+			avc_bridgeco_fill_unit_addr(addr,
+						    AVC_BRIDGECO_PLUG_DIR_IN,
+						    AVC_BRIDGECO_PLUG_UNIT_EXT,
+						    input[3]);
+			err = avc_bridgeco_get_plug_type(bebob->unit, addr,
+							 &type);
+			if (err < 0)
+				goto end;
+
+			if (type == AVC_BRIDGECO_PLUG_TYPE_DIG) {
+				/*
+				 * SPDIF/ADAT or sometimes (not always) word
+				 * clock.
+				 */
+				*internal = false;
+				goto end;
+			} else if (type == AVC_BRIDGECO_PLUG_TYPE_SYNC) {
+				/* Often word clock. */
+				*internal = false;
+				goto end;
+			} else if (type == AVC_BRIDGECO_PLUG_TYPE_ADDITION) {
+				/*
+				 * Not standard.
+				 * Mostly, additional internal clock.
+				 */
+				*internal = true;
+				goto end;
+			}
+		}
+	}
+
+	/* Not supported. */
+	err = -EIO;
 end:
 	return err;
 }

commit dec84316dd53c90e93b4ee849483bd4bd1e9a585
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 21 23:55:00 2015 +0900

    ALSA: fireworks/bebob/dice/oxfw: make it possible to shutdown safely
    
    A part of these drivers, especially BeBoB driver, are programmed to wait
    some events. Thus the drivers should not destroy any data in .remove()
    context.
    
    This commit moves some destructors from 'struct fw_driver.remove()' to
    'struct snd_card.private_free()' to shutdown safely.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index fcca3eebc91f..98e4fc8121a1 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -716,14 +716,10 @@ void snd_bebob_stream_update_duplex(struct snd_bebob *bebob)
  */
 void snd_bebob_stream_destroy_duplex(struct snd_bebob *bebob)
 {
-	mutex_lock(&bebob->mutex);
-
 	amdtp_stream_destroy(&bebob->rx_stream);
 	amdtp_stream_destroy(&bebob->tx_stream);
 
 	destroy_both_connections(bebob);
-
-	mutex_unlock(&bebob->mutex);
 }
 
 /*

commit d23c2cc4485d10f0cedfef99dd2961d9652b1b3f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 21 23:54:59 2015 +0900

    ALSA: fireworks/bebob/dice/oxfw: allow stream destructor after releasing runtime
    
    Currently stream destructor in each driver has a problem to be called in
    a context in which sound card object is released, because the destructors
    call amdtp_stream_pcm_abort() and touch PCM runtime data.
    
    The PCM runtime data is destroyed in application's context with
    snd_pcm_close(), on the other hand PCM substream data is destroyed after
    sound card object is released, in most case after all of ALSA character
    devices are released. When PCM runtime is destroyed and PCM substream is
    remained, amdtp_stream_pcm_abort() touches PCM runtime data and causes
    Null-pointer-dereference.
    
    This commit changes stream destructors and allows each driver to call
    it after releasing runtime.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 0ebcabfdc7ce..fcca3eebc91f 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -410,8 +410,6 @@ break_both_connections(struct snd_bebob *bebob)
 static void
 destroy_both_connections(struct snd_bebob *bebob)
 {
-	break_both_connections(bebob);
-
 	cmp_connection_destroy(&bebob->in_conn);
 	cmp_connection_destroy(&bebob->out_conn);
 }
@@ -712,16 +710,14 @@ void snd_bebob_stream_update_duplex(struct snd_bebob *bebob)
 	mutex_unlock(&bebob->mutex);
 }
 
+/*
+ * This function should be called before starting streams or after stopping
+ * streams.
+ */
 void snd_bebob_stream_destroy_duplex(struct snd_bebob *bebob)
 {
 	mutex_lock(&bebob->mutex);
 
-	amdtp_stream_pcm_abort(&bebob->rx_stream);
-	amdtp_stream_pcm_abort(&bebob->tx_stream);
-
-	amdtp_stream_stop(&bebob->rx_stream);
-	amdtp_stream_stop(&bebob->tx_stream);
-
 	amdtp_stream_destroy(&bebob->rx_stream);
 	amdtp_stream_destroy(&bebob->tx_stream);
 

commit 5c697e5b46efea2c0a5da55208bc71db46698fd1
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Nov 25 22:52:24 2014 +0100

    ALSA: firewire-lib: remove rx_blocks_for_midi quirk
    
    There are several devices that expect to receive MIDI data only in the
    first eight data blocks of a packet.  If the driver restricts the data
    rate to the allowed rate (as mandated by the specification, but not yet
    implemented by this driver), this happens naturally.  Therefore, there
    is no reason to ever try to use more data packets with any device.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Tested-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 1aab0a32870c..0ebcabfdc7ce 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -484,13 +484,6 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 		amdtp_stream_destroy(&bebob->rx_stream);
 		destroy_both_connections(bebob);
 	}
-	/*
-	 * The firmware for these devices ignore MIDI messages in more than
-	 * first 8 data blocks of an received AMDTP packet.
-	 */
-	if (bebob->spec == &maudio_fw410_spec ||
-	    bebob->spec == &maudio_special_spec)
-		bebob->rx_stream.rx_blocks_for_midi = 8;
 end:
 	return err;
 }

commit d1d0b6b668818571122d30d68a0b3f768bd83a52
Author: Christian Vogel <vogelchr@vogel.cx>
Date:   Sat Oct 25 13:40:41 2014 +0200

    ALSA: bebob: Uninitialized id returned by saffirepro_both_clk_src_get
    
    snd_bebob_stream_check_internal_clock() may get an id from
    saffirepro_both_clk_src_get (via clk_src->get()) that was uninitialized.
    
    a) make logic in saffirepro_both_clk_src_get explicit
    b) test if id used in snd_bebob_stream_check_internal_clock matches array size
    
    [fixed missing signed prefix to *_maps[] by tiwai]
    
    Signed-off-by: Christian Vogel <vogelchr@vogel.cx>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index ef4d0c9f6578..1aab0a32870c 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -129,12 +129,24 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 	/* 1.The device has its own operation to switch source of clock */
 	if (clk_spec) {
 		err = clk_spec->get(bebob, &id);
-		if (err < 0)
+		if (err < 0) {
 			dev_err(&bebob->unit->device,
 				"fail to get clock source: %d\n", err);
-		else if (strncmp(clk_spec->labels[id], SND_BEBOB_CLOCK_INTERNAL,
-				 strlen(SND_BEBOB_CLOCK_INTERNAL)) == 0)
+			goto end;
+		}
+
+		if (id >= clk_spec->num) {
+			dev_err(&bebob->unit->device,
+				"clock source %d out of range 0..%d\n",
+				id, clk_spec->num - 1);
+			err = -EIO;
+			goto end;
+		}
+
+		if (strncmp(clk_spec->labels[id], SND_BEBOB_CLOCK_INTERNAL,
+			    strlen(SND_BEBOB_CLOCK_INTERNAL)) == 0)
 			*internal = true;
+
 		goto end;
 	}
 

commit c6e5e741c6dc8e13a47721f419e26e6ac19ecaf4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 4 15:25:32 2014 +0900

    ALSA: fireworks/bebob: Shorten critical section for stream_stop_duplex()
    
    All assignment for local variables in these functions are not related to
    critical section.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index bc4f82776fda..ef4d0c9f6578 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -655,8 +655,6 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 	struct amdtp_stream *master, *slave;
 	atomic_t *master_substreams, *slave_substreams;
 
-	mutex_lock(&bebob->mutex);
-
 	if (bebob->master == &bebob->rx_stream) {
 		slave  = &bebob->tx_stream;
 		master = &bebob->rx_stream;
@@ -669,6 +667,8 @@ void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
 		master_substreams = &bebob->capture_substreams;
 	}
 
+	mutex_lock(&bebob->mutex);
+
 	if (atomic_read(slave_substreams) == 0) {
 		amdtp_stream_pcm_abort(slave);
 		amdtp_stream_stop(slave);

commit 33a5f989de41622ae691b12f008390309b59ad74
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed May 28 19:43:30 2014 +0300

    ALSA: bebob: sizeof() vs ARRAY_SIZE() typo
    
    ARRAY_SIZE() was intended here instead of sizeof().  The
    "bridgeco_freq_table" array holds integers so the original condition is
    never true.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewd-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Tested-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 514c7c9fa1cd..bc4f82776fda 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -749,7 +749,7 @@ parse_stream_formation(u8 *buf, unsigned int len,
 		if (buf[2] == bridgeco_freq_table[i])
 			break;
 	}
-	if (i == sizeof(bridgeco_freq_table))
+	if (i == ARRAY_SIZE(bridgeco_freq_table))
 		return -ENOSYS;
 
 	/* Avoid double count by different entries for the same rate. */

commit 51fa31d462f32e1ffdf957802dcab1dc20d2f243
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 28 00:14:47 2014 +0900

    ALSA: bebob: Improve comments about stream format
    
    Currently bebob driver apply Raw Audio Data channel (in IEC 61883-1:2002,
    Multi Bit Linear Audio Data channel in IEC 61883-6:20005) to IEC 60958
    Conformant Data channel because both fireworks and bebob based devices
    can handle it by ignoring each label.
    
    This patch improves a comment about this.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 38aee3344a5d..514c7c9fa1cd 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -760,7 +760,7 @@ parse_stream_formation(u8 *buf, unsigned int len,
 		format = buf[6 + e * 2];
 
 		switch (format) {
-		/* IEC 60958-3, currently handle as MBLA */
+		/* IEC 60958 Conformant, currently handled as MBLA */
 		case 0x00:
 		/* Multi bit linear audio */
 		case 0x06:	/* Raw */

commit a6b598bf4b4117597479cc0d6204df6d4d8f2635
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 28 00:14:41 2014 +0900

    ALSA: fireworks/bebob: Use the same type of variables as function parameters
    
    The second argument of snd_efw_command_get_sampling_rate() means sampling
    rate and its type is 'unsigned int'. But 'int' variable is passed as parameter.
    It's better to apply the same type for the variable as its argument.
    
    Similally, the type of variable for snd_efw_command_get_clock_source() and
    avc_bridgeco_get_plug_type() should be the same type as each argument.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index fbe938c79e3a..38aee3344a5d 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -852,7 +852,8 @@ static int
 seek_msu_sync_input_plug(struct snd_bebob *bebob)
 {
 	u8 plugs[AVC_PLUG_INFO_BUF_BYTES], addr[AVC_BRIDGECO_ADDR_BYTES];
-	unsigned int i, type;
+	unsigned int i;
+	enum avc_bridgeco_plug_type type;
 	int err;
 
 	/* Get the number of Music Sub Unit for both direction. */

commit 4a286d55285fa865df3810f632bd5747dc6e8475
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 28 00:14:40 2014 +0900

    ALSA: fireworks/bebob: Change type of argument for sampling rate
    
    Originally, I intent to this argument given with 'struct snd_pcm_runtime.rate'
    or params_rate(). They return value of 'unsigned int'. So 'unsigned int' is
    better for the type of this argument.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 452e93684e49..fbe938c79e3a 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -483,7 +483,7 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 	return err;
 }
 
-int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, int rate)
+int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, unsigned int rate)
 {
 	struct snd_bebob_rate_spec *rate_spec = bebob->spec->rate;
 	struct amdtp_stream *master, *slave;

commit c495a4a36e763de3eb164280fd7445f1bf666a52
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:28 2014 +0900

    ALSA: bebob: Add a quirk of data blocks for MIDI messages for some M-Audio devices
    
    The firmwares for M-Audio Firewire 410/1814 and ProjectMix I/O has a quirk to
    ignore MIDI messages in data blocks more than 8. This commit uses a flag which
    Fireworks uses for a similar quirk.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 3e74d9b1e357..452e93684e49 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -472,6 +472,13 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 		amdtp_stream_destroy(&bebob->rx_stream);
 		destroy_both_connections(bebob);
 	}
+	/*
+	 * The firmware for these devices ignore MIDI messages in more than
+	 * first 8 data blocks of an received AMDTP packet.
+	 */
+	if (bebob->spec == &maudio_fw410_spec ||
+	    bebob->spec == &maudio_special_spec)
+		bebob->rx_stream.rx_blocks_for_midi = 8;
 end:
 	return err;
 }

commit 9d59124cacf5d0a1e89aee83de6233bdf97afdb1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:27 2014 +0900

    ALSA: bebob/firewire-lib: Add a quirk of wrong dbc in empty packet for M-Audio special Firewire series
    
    M-Audio Firewire 1814 has a quirk, ProjectMix I/O also has. They transmit
    empty packet with wrong value of dbc incremented by 8 at high sampling rate.
    According to IEC 61883-1, this value should be the same as the one in
    previous packet.
    
    This commit adds a flag named as CIP_EMPTY_HAS_WRONG_DBC. With flag, the value
    of dbc in empty packet is overwittern by an expected value.
    
    This is an example of this quirk:
    CIP Header 0    CIP Header 1    Payload size
    010D0000        9004F759        210
    010D0010        90040B59        210
    010D0020        90042359        210
    01020028        9004FFFF        2  <-
    010D0030        90043759        210
    010D0040        90044B59        210
    010D0050        90046359        210
    01020058        9004FFFF        2  <-
    010D0060        90047759        210
    010D0070        90048B59        210
    010D0080        9004A359        210
    01020088        9004FFFF        2  <-
    010D0090        9004B759        210
    010D00A0        9004CB59        210
    010D00B0        9004E359        210
    010200B8        9004FFFF        2  <-
    010D00C0        9004F759        210
    010D00D0        90040B59        210
    010D00E0        90042359        210
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 2695b7899410..3e74d9b1e357 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -457,6 +457,13 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 	/* See comments in next function */
 	init_completion(&bebob->bus_reset);
 	bebob->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK;
+	/*
+	 * At high sampling rate, M-Audio special firmware transmits empty
+	 * packet with the value of dbc incremented by 8 but the others are
+	 * valid to IEC 61883-1.
+	 */
+	if (bebob->maudio_special_quirk)
+		bebob->tx_stream.flags |= CIP_EMPTY_HAS_WRONG_DBC;
 
 	err = amdtp_stream_init(&bebob->rx_stream, bebob->unit,
 				AMDTP_OUT_STREAM, CIP_BLOCKING);

commit 3149ac489ff8dea0c305c7f97ac2a1b4ad54f5be
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:26 2014 +0900

    ALSA: bebob: Add support for M-Audio special Firewire series
    
    This commit allows this driver to support some models which M-Audio produces
    with DM1000 but its firmware is special. They are:
     - Firewire 1814
     - ProjectMix I/O
    
    They have heavily customized firmware. The usual operations can't be applied to
    them. For this reason, this commit adds a model specific member to 'struct
    snd_bebob' and some model specific functions. Some parameters are write-only so
    this commit also adds control interface for applications to set them.
    
    M-Audio special firmware quirks:
     - Just after powering on, they wait to download firmware. This state is
       changed when receiving cue. Then bus reset is generated and the device is
       recognized as a different model with the uploaded firmware.
     - They don't respond against BridgeCo AV/C extension commands. So drivers
       can't get their stream formations and so on.
     - They do not start to transmit packets only by establishing connection but
       also by receiving SIGNAL FORMAT command.
     - After booting up, they often fail to send response against driver's request
       due to mismatch of gap_count.
    
    This module don't support to upload firmware.
    
    Tested-by: Darren Anderson <darrena092@gmail.com> (ProjectMix I/O)
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 5fc52706f7c5..2695b7899410 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -389,6 +389,10 @@ break_both_connections(struct snd_bebob *bebob)
 	cmp_connection_break(&bebob->out_conn);
 
 	bebob->connected = false;
+
+	/* These models seems to be in transition state for a longer time. */
+	if (bebob->maudio_special_quirk != NULL)
+		msleep(200);
 }
 
 static void
@@ -421,9 +425,11 @@ start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream,
 		conn = &bebob->out_conn;
 
 	/* channel mapping */
-	err = map_data_channels(bebob, stream);
-	if (err < 0)
-		goto end;
+	if (bebob->maudio_special_quirk == NULL) {
+		err = map_data_channels(bebob, stream);
+		if (err < 0)
+			goto end;
+	}
 
 	/* start amdtp stream */
 	err = amdtp_stream_start(stream,
@@ -555,13 +561,17 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, int rate)
 		 * NOTE:
 		 * If establishing connections at first, Yamaha GO46
 		 * (and maybe Terratec X24) don't generate sound.
+		 *
+		 * For firmware customized by M-Audio, refer to next NOTE.
 		 */
-		err = rate_spec->set(bebob, rate);
-		if (err < 0) {
-			dev_err(&bebob->unit->device,
-				"fail to set sampling rate: %d\n",
-				err);
-			goto end;
+		if (bebob->maudio_special_quirk == NULL) {
+			err = rate_spec->set(bebob, rate);
+			if (err < 0) {
+				dev_err(&bebob->unit->device,
+					"fail to set sampling rate: %d\n",
+					err);
+				goto end;
+			}
 		}
 
 		err = make_both_connections(bebob, rate);
@@ -576,6 +586,23 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, int rate)
 			goto end;
 		}
 
+		/*
+		 * NOTE:
+		 * The firmware customized by M-Audio uses these commands to
+		 * start transmitting stream. This is not usual way.
+		 */
+		if (bebob->maudio_special_quirk != NULL) {
+			err = rate_spec->set(bebob, rate);
+			if (err < 0) {
+				dev_err(&bebob->unit->device,
+					"fail to ensure sampling rate: %d\n",
+					err);
+				amdtp_stream_stop(master);
+				break_both_connections(bebob);
+				goto end;
+			}
+		}
+
 		/* wait first callback */
 		if (!amdtp_stream_wait_callback(master, CALLBACK_TIMEOUT)) {
 			amdtp_stream_stop(master);

commit 9076c22ddd9d29a30426f0367dec2b40e12536de
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:25 2014 +0900

    ALSA: bebob: Add support for M-Audio usual Firewire series
    
    This commit allows this driver to support some models which M-Audio produces
    with DM1000/DM1000E with usual firmware. They are:
     - Firewire 410
     - Firewire AudioPhile
     - Firewire Solo
     - Ozonic
     - NRV10
     - FirewireLightBridge
    
    According to a person who worked in BridgeCo, some models are produced with
    'Pre-BeBoB'. This means that these products were released before BeBoB was
    officially produced, and later BeBoB specification was formed. So these models
    have some quirks.
    
    M-Audio usual firmware quirks:
     - Just after powering on, 'Firewire 410' waits to download firmware. This
       state is changed when receiving cue. Then bus reset is generated and the
       device is recognized as a different model with the uploaded firmware.
     - 'Firewire Audiophile' also waits to download firmware but its
       vendor id/model id is the same as the one after loading firmware.
     - The information of channel mapping for MIDI conformant data channel is
       invalid against BridgeCo specification.
    
    This commit adds some codes for these quirks but don't support to upload
    firmware.
    
    This commit also adds specific operations to get metering information. The
    metering information also includes status of clock synchronization if the model
    supports to switch source of clock.
    
    The specification of FirewireLightBridge is unknown. So in this time, normal
    operations are applied for this model.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 4a21dcf95d95..5fc52706f7c5 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -252,6 +252,15 @@ map_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)
 			/* location of this channel in this section */
 			sec_loc = buf[pos++] - 1;
 
+			/*
+			 * Basically the number of location is within the
+			 * number of channels in this section. But some models
+			 * of M-Audio don't follow this. Its location for MIDI
+			 * is the position of MIDI channels in AMDTP packet.
+			 */
+			if (sec_loc >= channels)
+				sec_loc = ch;
+
 			switch (type) {
 			/* for MIDI conformant data channel */
 			case 0x0a:

commit 1fc9522a084f36d042298ef15893cf07d66a54bc
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:21 2014 +0900

    ALSA: bebob: Prepare for device specific operations
    
    This commit is for some devices which have its own operations or quirks.
    
    Many functionality should be implemented in user land. Then this commit adds
    functionality related to stream such as sampling frequency or clock source. For
    help to debug, this commit adds the functionality to get metering information
    if it's available.
    
    To help these functionalities, this commit adds some AV/C commands defined in
    'AV/C Audio Subunit Specification (1394TA).
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 85b4fd661787..4a21dcf95d95 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -119,13 +119,27 @@ snd_bebob_stream_set_rate(struct snd_bebob *bebob, unsigned int rate)
 int
 snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 {
+	struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;
 	u8 addr[AVC_BRIDGECO_ADDR_BYTES], input[7];
+	unsigned int id;
 	int err = 0;
 
 	*internal = false;
 
+	/* 1.The device has its own operation to switch source of clock */
+	if (clk_spec) {
+		err = clk_spec->get(bebob, &id);
+		if (err < 0)
+			dev_err(&bebob->unit->device,
+				"fail to get clock source: %d\n", err);
+		else if (strncmp(clk_spec->labels[id], SND_BEBOB_CLOCK_INTERNAL,
+				 strlen(SND_BEBOB_CLOCK_INTERNAL)) == 0)
+			*internal = true;
+		goto end;
+	}
+
 	/*
-	 * 1.The device don't support to switch source of clock then assumed
+	 * 2.The device don't support to switch source of clock then assumed
 	 *   to use internal clock always
 	 */
 	if (bebob->sync_input_plug < 0) {
@@ -134,7 +148,7 @@ snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
 	}
 
 	/*
-	 * 2.The device supports to switch source of clock by an usual way.
+	 * 3.The device supports to switch source of clock by an usual way.
 	 *   Let's check input for 'Music Sub Unit Sync Input' plug.
 	 */
 	avc_bridgeco_fill_msu_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN,
@@ -442,6 +456,7 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 
 int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, int rate)
 {
+	struct snd_bebob_rate_spec *rate_spec = bebob->spec->rate;
 	struct amdtp_stream *master, *slave;
 	atomic_t *slave_substreams;
 	enum cip_flags sync_mode;
@@ -508,7 +523,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, int rate)
 		break_both_connections(bebob);
 
 	/* stop streams if rate is different */
-	err = snd_bebob_stream_get_rate(bebob, &curr_rate);
+	err = rate_spec->get(bebob, &curr_rate);
 	if (err < 0) {
 		dev_err(&bebob->unit->device,
 			"fail to get sampling rate: %d\n", err);
@@ -532,7 +547,7 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, int rate)
 		 * If establishing connections at first, Yamaha GO46
 		 * (and maybe Terratec X24) don't generate sound.
 		 */
-		err = snd_bebob_stream_set_rate(bebob, rate);
+		err = rate_spec->set(bebob, rate);
 		if (err < 0) {
 			dev_err(&bebob->unit->device,
 				"fail to set sampling rate: %d\n",
@@ -822,6 +837,7 @@ seek_msu_sync_input_plug(struct snd_bebob *bebob)
 
 int snd_bebob_stream_discover(struct snd_bebob *bebob)
 {
+	struct snd_bebob_clock_spec *clk_spec = bebob->spec->clock;
 	u8 plugs[AVC_PLUG_INFO_BUF_BYTES], addr[AVC_BRIDGECO_ADDR_BYTES];
 	enum avc_bridgeco_plug_type type;
 	unsigned int i;
@@ -908,7 +924,8 @@ int snd_bebob_stream_discover(struct snd_bebob *bebob)
 	}
 
 	/* for check source of clock later */
-	err = seek_msu_sync_input_plug(bebob);
+	if (!clk_spec)
+		err = seek_msu_sync_input_plug(bebob);
 end:
 	return err;
 }

commit 618eabeae711c56d376daa147c6a684116d68705
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:20 2014 +0900

    ALSA: bebob: Add hwdep interface
    
    This interface is designed for mixer/control application. By using hwdep
    interface, the application can get information about firewire node, can
    lock/unlock kernel streaming and can get notification at starting/stopping
    kernel streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index 46b056c8f2a8..85b4fd661787 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -912,3 +912,42 @@ int snd_bebob_stream_discover(struct snd_bebob *bebob)
 end:
 	return err;
 }
+
+void snd_bebob_stream_lock_changed(struct snd_bebob *bebob)
+{
+	bebob->dev_lock_changed = true;
+	wake_up(&bebob->hwdep_wait);
+}
+
+int snd_bebob_stream_lock_try(struct snd_bebob *bebob)
+{
+	int err;
+
+	spin_lock_irq(&bebob->lock);
+
+	/* user land lock this */
+	if (bebob->dev_lock_count < 0) {
+		err = -EBUSY;
+		goto end;
+	}
+
+	/* this is the first time */
+	if (bebob->dev_lock_count++ == 0)
+		snd_bebob_stream_lock_changed(bebob);
+	err = 0;
+end:
+	spin_unlock_irq(&bebob->lock);
+	return err;
+}
+
+void snd_bebob_stream_lock_release(struct snd_bebob *bebob)
+{
+	spin_lock_irq(&bebob->lock);
+
+	if (WARN_ON(bebob->dev_lock_count <= 0))
+		goto end;
+	if (--bebob->dev_lock_count == 0)
+		snd_bebob_stream_lock_changed(bebob);
+end:
+	spin_unlock_irq(&bebob->lock);
+}

commit b6bc812327aa6961d783e81961273ebf2a304964
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:16 2014 +0900

    ALSA: bebob/firewire-lib: Add a quirk for discontinuity at bus reset
    
    Normal BeBoB firmware has a quirk. When receiving bus reset, it transmits
    packets with discontinuous value in dbc field.
    
    This causes two situation, one is to abort streaming by firewire-lib as a
    result of detecting the discontinuity. Another is to call driver's .update()
    because of bus reset. These two is generated independently. (The former
    depends on isochronous stream and the latter depends on IEEE1394 bus driver.)
    
    When BeBoB driver works with XRUN-recoverable applications, this situation
    looks like stream_start_duplex() call followed by stream_update_duplex() call
    because applications will call snd_pcm_prepare() immediately at XRUN.
    
    To update connections and streams at first, this commit use completion. When
    queueing error occurs, stream_start_duplex() is forced to wait maximum
    1000msec. During this, when .update() is called, the completion is waken and
    stream_start_duplex() is processed without breaking connections.
    
    At bus reset, stream_start_duplex() shouldn't break/establish connections and
    stream_update_duplex() should update connections because a caller of
    fw_iso_resources_allocate() is responsible for calling
    fw_iso_resources_update() on bus reset.
    
    This commit also adds a flag, which has an effect to skip checking continuity
    for first packet. This flag is useful for BeBoB quirk to start handling packets
    during streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
index c868c17c6fc4..46b056c8f2a8 100644
--- a/sound/firewire/bebob/bebob_stream.c
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -9,6 +9,7 @@
 #include "./bebob.h"
 
 #define CALLBACK_TIMEOUT	1000
+#define FW_ISO_RESOURCE_DELAY	1000
 
 /*
  * NOTE;
@@ -325,7 +326,10 @@ check_connection_used_by_others(struct snd_bebob *bebob, struct amdtp_stream *s)
 static int
 make_both_connections(struct snd_bebob *bebob, unsigned int rate)
 {
-	int index, pcm_channels, midi_channels, err;
+	int index, pcm_channels, midi_channels, err = 0;
+
+	if (bebob->connected)
+		goto end;
 
 	/* confirm params for both streams */
 	index = get_formation_index(rate);
@@ -345,8 +349,12 @@ make_both_connections(struct snd_bebob *bebob, unsigned int rate)
 		goto end;
 	err = cmp_connection_establish(&bebob->in_conn,
 			amdtp_stream_get_max_payload(&bebob->rx_stream));
-	if (err < 0)
+	if (err < 0) {
 		cmp_connection_break(&bebob->out_conn);
+		goto end;
+	}
+
+	bebob->connected = true;
 end:
 	return err;
 }
@@ -356,6 +364,8 @@ break_both_connections(struct snd_bebob *bebob)
 {
 	cmp_connection_break(&bebob->in_conn);
 	cmp_connection_break(&bebob->out_conn);
+
+	bebob->connected = false;
 }
 
 static void
@@ -415,6 +425,9 @@ int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
 		destroy_both_connections(bebob);
 		goto end;
 	}
+	/* See comments in next function */
+	init_completion(&bebob->bus_reset);
+	bebob->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK;
 
 	err = amdtp_stream_init(&bebob->rx_stream, bebob->unit,
 				AMDTP_OUT_STREAM, CIP_BLOCKING);
@@ -433,8 +446,25 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, int rate)
 	atomic_t *slave_substreams;
 	enum cip_flags sync_mode;
 	unsigned int curr_rate;
+	bool updated = false;
 	int err = 0;
 
+	/*
+	 * Normal BeBoB firmware has a quirk at bus reset to transmits packets
+	 * with discontinuous value in dbc field.
+	 *
+	 * This 'struct completion' is used to call .update() at first to update
+	 * connections/streams. Next following codes handle streaming error.
+	 */
+	if (amdtp_streaming_error(&bebob->tx_stream)) {
+		if (completion_done(&bebob->bus_reset))
+			reinit_completion(&bebob->bus_reset);
+
+		updated = (wait_for_completion_interruptible_timeout(
+				&bebob->bus_reset,
+				msecs_to_jiffies(FW_ISO_RESOURCE_DELAY)) > 0);
+	}
+
 	mutex_lock(&bebob->mutex);
 
 	/* Need no substreams */
@@ -463,13 +493,19 @@ int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, int rate)
 	if (err < 0)
 		goto end;
 
-	/* packet queueing error */
-	if (amdtp_streaming_error(master)) {
+	/*
+	 * packet queueing error or detecting discontinuity
+	 *
+	 * At bus reset, connections should not be broken here. So streams need
+	 * to be re-started. This is a reason to use SKIP_INIT_DBC_CHECK flag.
+	 */
+	if (amdtp_streaming_error(master))
 		amdtp_stream_stop(master);
-		amdtp_stream_stop(slave);
-	}
 	if (amdtp_streaming_error(slave))
 		amdtp_stream_stop(slave);
+	if (!updated &&
+	    !amdtp_stream_running(master) && !amdtp_stream_running(slave))
+		break_both_connections(bebob);
 
 	/* stop streams if rate is different */
 	err = snd_bebob_stream_get_rate(bebob, &curr_rate);
@@ -599,6 +635,10 @@ void snd_bebob_stream_update_duplex(struct snd_bebob *bebob)
 		amdtp_stream_update(&bebob->tx_stream);
 	}
 
+	/* wake up stream_start_duplex() */
+	if (!completion_done(&bebob->bus_reset))
+		complete_all(&bebob->bus_reset);
+
 	mutex_unlock(&bebob->mutex);
 }
 

commit eb7b3a056cd8130e45c4494fb27de54d53ce9f31
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:15 2014 +0900

    ALSA: bebob: Add commands and connections/streams management
    
    This commit adds management functionality for connections and streams.
    BeBoB uses CMP to manage connections and uses AMDTP for streams.
    
    This commit also adds some BridgeCo's AV/C extension commands. There are some
    BridgeCo's AV/C extension commands but this commit just uses below commands
    to get device's capability and status:
    
     1.Extended Plug Info commands
      - Plug Channel Position Specific Data
      - Plug Type Specific Data
      - Cluster(Section) Info Specific Data
      - Plug Input Specific Data
     2.Extended Stream Format Information commands
      - Extended Stream Format Information Command - List Request
    
    For Extended Plug Info commands for Cluster Info Specific Data, I pick up
    'section' instead of 'cluster' from document to prevent from misunderstanding
    because 'cluster' is also used in IEC 61883-6.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c
new file mode 100644
index 000000000000..c868c17c6fc4
--- /dev/null
+++ b/sound/firewire/bebob/bebob_stream.c
@@ -0,0 +1,874 @@
+/*
+ * bebob_stream.c - a part of driver for BeBoB based devices
+ *
+ * Copyright (c) 2013-2014 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "./bebob.h"
+
+#define CALLBACK_TIMEOUT	1000
+
+/*
+ * NOTE;
+ * For BeBoB streams, Both of input and output CMP connection are important.
+ *
+ * For most devices, each CMP connection starts to transmit/receive a
+ * corresponding stream. But for a few devices, both of CMP connection needs
+ * to start transmitting stream. An example is 'M-Audio Firewire 410'.
+ */
+
+/* 128 is an arbitrary length but it seems to be enough */
+#define FORMAT_MAXIMUM_LENGTH 128
+
+const unsigned int snd_bebob_rate_table[SND_BEBOB_STRM_FMT_ENTRIES] = {
+	[0] = 32000,
+	[1] = 44100,
+	[2] = 48000,
+	[3] = 88200,
+	[4] = 96000,
+	[5] = 176400,
+	[6] = 192000,
+};
+
+/*
+ * See: Table 51: Extended Stream Format Info Sampling Frequency
+ * in Additional AVC commands (Nov 2003, BridgeCo)
+ */
+static const unsigned int bridgeco_freq_table[] = {
+	[0] = 0x02,
+	[1] = 0x03,
+	[2] = 0x04,
+	[3] = 0x0a,
+	[4] = 0x05,
+	[5] = 0x06,
+	[6] = 0x07,
+};
+
+static unsigned int
+get_formation_index(unsigned int rate)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(snd_bebob_rate_table); i++) {
+		if (snd_bebob_rate_table[i] == rate)
+			return i;
+	}
+	return -EINVAL;
+}
+
+int
+snd_bebob_stream_get_rate(struct snd_bebob *bebob, unsigned int *curr_rate)
+{
+	unsigned int tx_rate, rx_rate, trials;
+	int err;
+
+	trials = 0;
+	do {
+		err = avc_general_get_sig_fmt(bebob->unit, &tx_rate,
+					      AVC_GENERAL_PLUG_DIR_OUT, 0);
+	} while (err == -EAGAIN && ++trials < 3);
+	if (err < 0)
+		goto end;
+
+	trials = 0;
+	do {
+		err = avc_general_get_sig_fmt(bebob->unit, &rx_rate,
+					      AVC_GENERAL_PLUG_DIR_IN, 0);
+	} while (err == -EAGAIN && ++trials < 3);
+	if (err < 0)
+		goto end;
+
+	*curr_rate = rx_rate;
+	if (rx_rate == tx_rate)
+		goto end;
+
+	/* synchronize receive stream rate to transmit stream rate */
+	err = avc_general_set_sig_fmt(bebob->unit, rx_rate,
+				      AVC_GENERAL_PLUG_DIR_IN, 0);
+end:
+	return err;
+}
+
+int
+snd_bebob_stream_set_rate(struct snd_bebob *bebob, unsigned int rate)
+{
+	int err;
+
+	err = avc_general_set_sig_fmt(bebob->unit, rate,
+				      AVC_GENERAL_PLUG_DIR_OUT, 0);
+	if (err < 0)
+		goto end;
+
+	err = avc_general_set_sig_fmt(bebob->unit, rate,
+				      AVC_GENERAL_PLUG_DIR_IN, 0);
+	if (err < 0)
+		goto end;
+
+	/*
+	 * Some devices need a bit time for transition.
+	 * 300msec is got by some experiments.
+	 */
+	msleep(300);
+end:
+	return err;
+}
+
+int
+snd_bebob_stream_check_internal_clock(struct snd_bebob *bebob, bool *internal)
+{
+	u8 addr[AVC_BRIDGECO_ADDR_BYTES], input[7];
+	int err = 0;
+
+	*internal = false;
+
+	/*
+	 * 1.The device don't support to switch source of clock then assumed
+	 *   to use internal clock always
+	 */
+	if (bebob->sync_input_plug < 0) {
+		*internal = true;
+		goto end;
+	}
+
+	/*
+	 * 2.The device supports to switch source of clock by an usual way.
+	 *   Let's check input for 'Music Sub Unit Sync Input' plug.
+	 */
+	avc_bridgeco_fill_msu_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN,
+				   bebob->sync_input_plug);
+	err = avc_bridgeco_get_plug_input(bebob->unit, addr, input);
+	if (err < 0) {
+		dev_err(&bebob->unit->device,
+			"fail to get an input for MSU in plug %d: %d\n",
+			bebob->sync_input_plug, err);
+		goto end;
+	}
+
+	/*
+	 * If there are no input plugs, all of fields are 0xff.
+	 * Here check the first field. This field is used for direction.
+	 */
+	if (input[0] == 0xff) {
+		*internal = true;
+		goto end;
+	}
+
+	/*
+	 * If source of clock is internal CSR, Music Sub Unit Sync Input is
+	 * a destination of Music Sub Unit Sync Output.
+	 */
+	*internal = ((input[0] == AVC_BRIDGECO_PLUG_DIR_OUT) &&
+		     (input[1] == AVC_BRIDGECO_PLUG_MODE_SUBUNIT) &&
+		     (input[2] == 0x0c) &&
+		     (input[3] == 0x00));
+end:
+	return err;
+}
+
+static unsigned int
+map_data_channels(struct snd_bebob *bebob, struct amdtp_stream *s)
+{
+	unsigned int sec, sections, ch, channels;
+	unsigned int pcm, midi, location;
+	unsigned int stm_pos, sec_loc, pos;
+	u8 *buf, addr[AVC_BRIDGECO_ADDR_BYTES], type;
+	enum avc_bridgeco_plug_dir dir;
+	int err;
+
+	/*
+	 * The length of return value of this command cannot be expected. Here
+	 * use the maximum length of FCP.
+	 */
+	buf = kzalloc(256, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	if (s == &bebob->tx_stream)
+		dir = AVC_BRIDGECO_PLUG_DIR_OUT;
+	else
+		dir = AVC_BRIDGECO_PLUG_DIR_IN;
+
+	avc_bridgeco_fill_unit_addr(addr, dir, AVC_BRIDGECO_PLUG_UNIT_ISOC, 0);
+	err = avc_bridgeco_get_plug_ch_pos(bebob->unit, addr, buf, 256);
+	if (err < 0) {
+		dev_err(&bebob->unit->device,
+			"fail to get channel position for isoc %s plug 0: %d\n",
+			(dir == AVC_BRIDGECO_PLUG_DIR_IN) ? "in" : "out",
+			err);
+		goto end;
+	}
+	pos = 0;
+
+	/* positions in I/O buffer */
+	pcm = 0;
+	midi = 0;
+
+	/* the number of sections in AMDTP packet */
+	sections = buf[pos++];
+
+	for (sec = 0; sec < sections; sec++) {
+		/* type of this section */
+		avc_bridgeco_fill_unit_addr(addr, dir,
+					    AVC_BRIDGECO_PLUG_UNIT_ISOC, 0);
+		err = avc_bridgeco_get_plug_section_type(bebob->unit, addr,
+							 sec, &type);
+		if (err < 0) {
+			dev_err(&bebob->unit->device,
+			"fail to get section type for isoc %s plug 0: %d\n",
+				(dir == AVC_BRIDGECO_PLUG_DIR_IN) ? "in" :
+								    "out",
+				err);
+			goto end;
+		}
+		/* NoType */
+		if (type == 0xff) {
+			err = -ENOSYS;
+			goto end;
+		}
+
+		/* the number of channels in this section */
+		channels = buf[pos++];
+
+		for (ch = 0; ch < channels; ch++) {
+			/* position of this channel in AMDTP packet */
+			stm_pos = buf[pos++] - 1;
+			/* location of this channel in this section */
+			sec_loc = buf[pos++] - 1;
+
+			switch (type) {
+			/* for MIDI conformant data channel */
+			case 0x0a:
+				/* AMDTP_MAX_CHANNELS_FOR_MIDI is 1. */
+				if ((midi > 0) && (stm_pos != midi)) {
+					err = -ENOSYS;
+					goto end;
+				}
+				s->midi_position = stm_pos;
+				midi = stm_pos;
+				break;
+			/* for PCM data channel */
+			case 0x01:	/* Headphone */
+			case 0x02:	/* Microphone */
+			case 0x03:	/* Line */
+			case 0x04:	/* SPDIF */
+			case 0x05:	/* ADAT */
+			case 0x06:	/* TDIF */
+			case 0x07:	/* MADI */
+			/* for undefined/changeable signal  */
+			case 0x08:	/* Analog */
+			case 0x09:	/* Digital */
+			default:
+				location = pcm + sec_loc;
+				if (location >= AMDTP_MAX_CHANNELS_FOR_PCM) {
+					err = -ENOSYS;
+					goto end;
+				}
+				s->pcm_positions[location] = stm_pos;
+				break;
+			}
+		}
+
+		if (type != 0x0a)
+			pcm += channels;
+		else
+			midi += channels;
+	}
+end:
+	kfree(buf);
+	return err;
+}
+
+static int
+init_both_connections(struct snd_bebob *bebob)
+{
+	int err;
+
+	err = cmp_connection_init(&bebob->in_conn,
+				  bebob->unit, CMP_INPUT, 0);
+	if (err < 0)
+		goto end;
+
+	err = cmp_connection_init(&bebob->out_conn,
+				  bebob->unit, CMP_OUTPUT, 0);
+	if (err < 0)
+		cmp_connection_destroy(&bebob->in_conn);
+end:
+	return err;
+}
+
+static int
+check_connection_used_by_others(struct snd_bebob *bebob, struct amdtp_stream *s)
+{
+	struct cmp_connection *conn;
+	bool used;
+	int err;
+
+	if (s == &bebob->tx_stream)
+		conn = &bebob->out_conn;
+	else
+		conn = &bebob->in_conn;
+
+	err = cmp_connection_check_used(conn, &used);
+	if ((err >= 0) && used && !amdtp_stream_running(s)) {
+		dev_err(&bebob->unit->device,
+			"Connection established by others: %cPCR[%d]\n",
+			(conn->direction == CMP_OUTPUT) ? 'o' : 'i',
+			conn->pcr_index);
+		err = -EBUSY;
+	}
+
+	return err;
+}
+
+static int
+make_both_connections(struct snd_bebob *bebob, unsigned int rate)
+{
+	int index, pcm_channels, midi_channels, err;
+
+	/* confirm params for both streams */
+	index = get_formation_index(rate);
+	pcm_channels = bebob->tx_stream_formations[index].pcm;
+	midi_channels = bebob->tx_stream_formations[index].midi;
+	amdtp_stream_set_parameters(&bebob->tx_stream,
+				    rate, pcm_channels, midi_channels * 8);
+	pcm_channels = bebob->rx_stream_formations[index].pcm;
+	midi_channels = bebob->rx_stream_formations[index].midi;
+	amdtp_stream_set_parameters(&bebob->rx_stream,
+				    rate, pcm_channels, midi_channels * 8);
+
+	/* establish connections for both streams */
+	err = cmp_connection_establish(&bebob->out_conn,
+			amdtp_stream_get_max_payload(&bebob->tx_stream));
+	if (err < 0)
+		goto end;
+	err = cmp_connection_establish(&bebob->in_conn,
+			amdtp_stream_get_max_payload(&bebob->rx_stream));
+	if (err < 0)
+		cmp_connection_break(&bebob->out_conn);
+end:
+	return err;
+}
+
+static void
+break_both_connections(struct snd_bebob *bebob)
+{
+	cmp_connection_break(&bebob->in_conn);
+	cmp_connection_break(&bebob->out_conn);
+}
+
+static void
+destroy_both_connections(struct snd_bebob *bebob)
+{
+	break_both_connections(bebob);
+
+	cmp_connection_destroy(&bebob->in_conn);
+	cmp_connection_destroy(&bebob->out_conn);
+}
+
+static int
+get_sync_mode(struct snd_bebob *bebob, enum cip_flags *sync_mode)
+{
+	/* currently this module doesn't support SYT-Match mode */
+	*sync_mode = CIP_SYNC_TO_DEVICE;
+	return 0;
+}
+
+static int
+start_stream(struct snd_bebob *bebob, struct amdtp_stream *stream,
+	     unsigned int rate)
+{
+	struct cmp_connection *conn;
+	int err = 0;
+
+	if (stream == &bebob->rx_stream)
+		conn = &bebob->in_conn;
+	else
+		conn = &bebob->out_conn;
+
+	/* channel mapping */
+	err = map_data_channels(bebob, stream);
+	if (err < 0)
+		goto end;
+
+	/* start amdtp stream */
+	err = amdtp_stream_start(stream,
+				 conn->resources.channel,
+				 conn->speed);
+end:
+	return err;
+}
+
+int snd_bebob_stream_init_duplex(struct snd_bebob *bebob)
+{
+	int err;
+
+	err = init_both_connections(bebob);
+	if (err < 0)
+		goto end;
+
+	err = amdtp_stream_init(&bebob->tx_stream, bebob->unit,
+				AMDTP_IN_STREAM, CIP_BLOCKING);
+	if (err < 0) {
+		amdtp_stream_destroy(&bebob->tx_stream);
+		destroy_both_connections(bebob);
+		goto end;
+	}
+
+	err = amdtp_stream_init(&bebob->rx_stream, bebob->unit,
+				AMDTP_OUT_STREAM, CIP_BLOCKING);
+	if (err < 0) {
+		amdtp_stream_destroy(&bebob->tx_stream);
+		amdtp_stream_destroy(&bebob->rx_stream);
+		destroy_both_connections(bebob);
+	}
+end:
+	return err;
+}
+
+int snd_bebob_stream_start_duplex(struct snd_bebob *bebob, int rate)
+{
+	struct amdtp_stream *master, *slave;
+	atomic_t *slave_substreams;
+	enum cip_flags sync_mode;
+	unsigned int curr_rate;
+	int err = 0;
+
+	mutex_lock(&bebob->mutex);
+
+	/* Need no substreams */
+	if (atomic_read(&bebob->playback_substreams) == 0 &&
+	    atomic_read(&bebob->capture_substreams)  == 0)
+		goto end;
+
+	err = get_sync_mode(bebob, &sync_mode);
+	if (err < 0)
+		goto end;
+	if (sync_mode == CIP_SYNC_TO_DEVICE) {
+		master = &bebob->tx_stream;
+		slave  = &bebob->rx_stream;
+		slave_substreams = &bebob->playback_substreams;
+	} else {
+		master = &bebob->rx_stream;
+		slave  = &bebob->tx_stream;
+		slave_substreams = &bebob->capture_substreams;
+	}
+
+	/*
+	 * Considering JACK/FFADO streaming:
+	 * TODO: This can be removed hwdep functionality becomes popular.
+	 */
+	err = check_connection_used_by_others(bebob, master);
+	if (err < 0)
+		goto end;
+
+	/* packet queueing error */
+	if (amdtp_streaming_error(master)) {
+		amdtp_stream_stop(master);
+		amdtp_stream_stop(slave);
+	}
+	if (amdtp_streaming_error(slave))
+		amdtp_stream_stop(slave);
+
+	/* stop streams if rate is different */
+	err = snd_bebob_stream_get_rate(bebob, &curr_rate);
+	if (err < 0) {
+		dev_err(&bebob->unit->device,
+			"fail to get sampling rate: %d\n", err);
+		goto end;
+	}
+	if (rate == 0)
+		rate = curr_rate;
+	if (rate != curr_rate) {
+		amdtp_stream_stop(master);
+		amdtp_stream_stop(slave);
+		break_both_connections(bebob);
+	}
+
+	/* master should be always running */
+	if (!amdtp_stream_running(master)) {
+		amdtp_stream_set_sync(sync_mode, master, slave);
+		bebob->master = master;
+
+		/*
+		 * NOTE:
+		 * If establishing connections at first, Yamaha GO46
+		 * (and maybe Terratec X24) don't generate sound.
+		 */
+		err = snd_bebob_stream_set_rate(bebob, rate);
+		if (err < 0) {
+			dev_err(&bebob->unit->device,
+				"fail to set sampling rate: %d\n",
+				err);
+			goto end;
+		}
+
+		err = make_both_connections(bebob, rate);
+		if (err < 0)
+			goto end;
+
+		err = start_stream(bebob, master, rate);
+		if (err < 0) {
+			dev_err(&bebob->unit->device,
+				"fail to run AMDTP master stream:%d\n", err);
+			break_both_connections(bebob);
+			goto end;
+		}
+
+		/* wait first callback */
+		if (!amdtp_stream_wait_callback(master, CALLBACK_TIMEOUT)) {
+			amdtp_stream_stop(master);
+			break_both_connections(bebob);
+			err = -ETIMEDOUT;
+			goto end;
+		}
+	}
+
+	/* start slave if needed */
+	if (atomic_read(slave_substreams) > 0 && !amdtp_stream_running(slave)) {
+		err = start_stream(bebob, slave, rate);
+		if (err < 0) {
+			dev_err(&bebob->unit->device,
+				"fail to run AMDTP slave stream:%d\n", err);
+			amdtp_stream_stop(master);
+			break_both_connections(bebob);
+			goto end;
+		}
+
+		/* wait first callback */
+		if (!amdtp_stream_wait_callback(slave, CALLBACK_TIMEOUT)) {
+			amdtp_stream_stop(slave);
+			amdtp_stream_stop(master);
+			break_both_connections(bebob);
+			err = -ETIMEDOUT;
+		}
+	}
+end:
+	mutex_unlock(&bebob->mutex);
+	return err;
+}
+
+void snd_bebob_stream_stop_duplex(struct snd_bebob *bebob)
+{
+	struct amdtp_stream *master, *slave;
+	atomic_t *master_substreams, *slave_substreams;
+
+	mutex_lock(&bebob->mutex);
+
+	if (bebob->master == &bebob->rx_stream) {
+		slave  = &bebob->tx_stream;
+		master = &bebob->rx_stream;
+		slave_substreams  = &bebob->capture_substreams;
+		master_substreams = &bebob->playback_substreams;
+	} else {
+		slave  = &bebob->rx_stream;
+		master = &bebob->tx_stream;
+		slave_substreams  = &bebob->playback_substreams;
+		master_substreams = &bebob->capture_substreams;
+	}
+
+	if (atomic_read(slave_substreams) == 0) {
+		amdtp_stream_pcm_abort(slave);
+		amdtp_stream_stop(slave);
+
+		if (atomic_read(master_substreams) == 0) {
+			amdtp_stream_pcm_abort(master);
+			amdtp_stream_stop(master);
+			break_both_connections(bebob);
+		}
+	}
+
+	mutex_unlock(&bebob->mutex);
+}
+
+void snd_bebob_stream_update_duplex(struct snd_bebob *bebob)
+{
+	/* vs. XRUN recovery due to discontinuity at bus reset */
+	mutex_lock(&bebob->mutex);
+
+	if ((cmp_connection_update(&bebob->in_conn) < 0) ||
+	    (cmp_connection_update(&bebob->out_conn) < 0)) {
+		amdtp_stream_pcm_abort(&bebob->rx_stream);
+		amdtp_stream_pcm_abort(&bebob->tx_stream);
+		amdtp_stream_stop(&bebob->rx_stream);
+		amdtp_stream_stop(&bebob->tx_stream);
+		break_both_connections(bebob);
+	} else {
+		amdtp_stream_update(&bebob->rx_stream);
+		amdtp_stream_update(&bebob->tx_stream);
+	}
+
+	mutex_unlock(&bebob->mutex);
+}
+
+void snd_bebob_stream_destroy_duplex(struct snd_bebob *bebob)
+{
+	mutex_lock(&bebob->mutex);
+
+	amdtp_stream_pcm_abort(&bebob->rx_stream);
+	amdtp_stream_pcm_abort(&bebob->tx_stream);
+
+	amdtp_stream_stop(&bebob->rx_stream);
+	amdtp_stream_stop(&bebob->tx_stream);
+
+	amdtp_stream_destroy(&bebob->rx_stream);
+	amdtp_stream_destroy(&bebob->tx_stream);
+
+	destroy_both_connections(bebob);
+
+	mutex_unlock(&bebob->mutex);
+}
+
+/*
+ * See: Table 50: Extended Stream Format Info Format Hierarchy Level 2
+ * in Additional AVC commands (Nov 2003, BridgeCo)
+ * Also 'Clause 12 AM824 sequence adaption layers' in IEC 61883-6:2005
+ */
+static int
+parse_stream_formation(u8 *buf, unsigned int len,
+		       struct snd_bebob_stream_formation *formation)
+{
+	unsigned int i, e, channels, format;
+
+	/*
+	 * this module can support a hierarchy combination that:
+	 *  Root:	Audio and Music (0x90)
+	 *  Level 1:	AM824 Compound  (0x40)
+	 */
+	if ((buf[0] != 0x90) || (buf[1] != 0x40))
+		return -ENOSYS;
+
+	/* check sampling rate */
+	for (i = 0; i < ARRAY_SIZE(bridgeco_freq_table); i++) {
+		if (buf[2] == bridgeco_freq_table[i])
+			break;
+	}
+	if (i == sizeof(bridgeco_freq_table))
+		return -ENOSYS;
+
+	/* Avoid double count by different entries for the same rate. */
+	memset(&formation[i], 0, sizeof(struct snd_bebob_stream_formation));
+
+	for (e = 0; e < buf[4]; e++) {
+		channels = buf[5 + e * 2];
+		format = buf[6 + e * 2];
+
+		switch (format) {
+		/* IEC 60958-3, currently handle as MBLA */
+		case 0x00:
+		/* Multi bit linear audio */
+		case 0x06:	/* Raw */
+			formation[i].pcm += channels;
+			break;
+		/* MIDI Conformant */
+		case 0x0d:
+			formation[i].midi += channels;
+			break;
+		/* IEC 61937-3 to 7 */
+		case 0x01:
+		case 0x02:
+		case 0x03:
+		case 0x04:
+		case 0x05:
+		/* Multi bit linear audio */
+		case 0x07:	/* DVD-Audio */
+		case 0x0c:	/* High Precision */
+		/* One Bit Audio */
+		case 0x08:	/* (Plain) Raw */
+		case 0x09:	/* (Plain) SACD */
+		case 0x0a:	/* (Encoded) Raw */
+		case 0x0b:	/* (Encoded) SACD */
+		/* Synchronization Stream (Stereo Raw audio) */
+		case 0x40:
+		/* Don't care */
+		case 0xff:
+		default:
+			return -ENOSYS;	/* not supported */
+		}
+	}
+
+	if (formation[i].pcm  > AMDTP_MAX_CHANNELS_FOR_PCM ||
+	    formation[i].midi > AMDTP_MAX_CHANNELS_FOR_MIDI)
+		return -ENOSYS;
+
+	return 0;
+}
+
+static int
+fill_stream_formations(struct snd_bebob *bebob, enum avc_bridgeco_plug_dir dir,
+		       unsigned short pid)
+{
+	u8 *buf;
+	struct snd_bebob_stream_formation *formations;
+	unsigned int len, eid;
+	u8 addr[AVC_BRIDGECO_ADDR_BYTES];
+	int err;
+
+	buf = kmalloc(FORMAT_MAXIMUM_LENGTH, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	if (dir == AVC_BRIDGECO_PLUG_DIR_IN)
+		formations = bebob->rx_stream_formations;
+	else
+		formations = bebob->tx_stream_formations;
+
+	for (eid = 0; eid < SND_BEBOB_STRM_FMT_ENTRIES; eid++) {
+		len = FORMAT_MAXIMUM_LENGTH;
+		avc_bridgeco_fill_unit_addr(addr, dir,
+					    AVC_BRIDGECO_PLUG_UNIT_ISOC, pid);
+		err = avc_bridgeco_get_plug_strm_fmt(bebob->unit, addr, buf,
+						     &len, eid);
+		/* No entries remained. */
+		if (err == -EINVAL && eid > 0) {
+			err = 0;
+			break;
+		} else if (err < 0) {
+			dev_err(&bebob->unit->device,
+			"fail to get stream format %d for isoc %s plug %d:%d\n",
+				eid,
+				(dir == AVC_BRIDGECO_PLUG_DIR_IN) ? "in" :
+								    "out",
+				pid, err);
+			break;
+		}
+
+		err = parse_stream_formation(buf, len, formations);
+		if (err < 0)
+			break;
+	}
+
+	kfree(buf);
+	return err;
+}
+
+static int
+seek_msu_sync_input_plug(struct snd_bebob *bebob)
+{
+	u8 plugs[AVC_PLUG_INFO_BUF_BYTES], addr[AVC_BRIDGECO_ADDR_BYTES];
+	unsigned int i, type;
+	int err;
+
+	/* Get the number of Music Sub Unit for both direction. */
+	err = avc_general_get_plug_info(bebob->unit, 0x0c, 0x00, 0x00, plugs);
+	if (err < 0) {
+		dev_err(&bebob->unit->device,
+			"fail to get info for MSU in/out plugs: %d\n",
+			err);
+		goto end;
+	}
+
+	/* seek destination plugs for 'MSU sync input' */
+	bebob->sync_input_plug = -1;
+	for (i = 0; i < plugs[0]; i++) {
+		avc_bridgeco_fill_msu_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN, i);
+		err = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);
+		if (err < 0) {
+			dev_err(&bebob->unit->device,
+				"fail to get type for MSU in plug %d: %d\n",
+				i, err);
+			goto end;
+		}
+
+		if (type == AVC_BRIDGECO_PLUG_TYPE_SYNC) {
+			bebob->sync_input_plug = i;
+			break;
+		}
+	}
+end:
+	return err;
+}
+
+int snd_bebob_stream_discover(struct snd_bebob *bebob)
+{
+	u8 plugs[AVC_PLUG_INFO_BUF_BYTES], addr[AVC_BRIDGECO_ADDR_BYTES];
+	enum avc_bridgeco_plug_type type;
+	unsigned int i;
+	int err;
+
+	/* the number of plugs for isoc in/out, ext in/out  */
+	err = avc_general_get_plug_info(bebob->unit, 0x1f, 0x07, 0x00, plugs);
+	if (err < 0) {
+		dev_err(&bebob->unit->device,
+		"fail to get info for isoc/external in/out plugs: %d\n",
+			err);
+		goto end;
+	}
+
+	/*
+	 * This module supports at least one isoc input plug and one isoc
+	 * output plug.
+	 */
+	if ((plugs[0] == 0) || (plugs[1] == 0)) {
+		err = -ENOSYS;
+		goto end;
+	}
+
+	avc_bridgeco_fill_unit_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN,
+				    AVC_BRIDGECO_PLUG_UNIT_ISOC, 0);
+	err = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);
+	if (err < 0) {
+		dev_err(&bebob->unit->device,
+			"fail to get type for isoc in plug 0: %d\n", err);
+		goto end;
+	} else if (type != AVC_BRIDGECO_PLUG_TYPE_ISOC) {
+		err = -ENOSYS;
+		goto end;
+	}
+	err = fill_stream_formations(bebob, AVC_BRIDGECO_PLUG_DIR_IN, 0);
+	if (err < 0)
+		goto end;
+
+	avc_bridgeco_fill_unit_addr(addr, AVC_BRIDGECO_PLUG_DIR_OUT,
+				    AVC_BRIDGECO_PLUG_UNIT_ISOC, 0);
+	err = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);
+	if (err < 0) {
+		dev_err(&bebob->unit->device,
+			"fail to get type for isoc out plug 0: %d\n", err);
+		goto end;
+	} else if (type != AVC_BRIDGECO_PLUG_TYPE_ISOC) {
+		err = -ENOSYS;
+		goto end;
+	}
+	err = fill_stream_formations(bebob, AVC_BRIDGECO_PLUG_DIR_OUT, 0);
+	if (err < 0)
+		goto end;
+
+	/* count external input plugs for MIDI */
+	bebob->midi_input_ports = 0;
+	for (i = 0; i < plugs[2]; i++) {
+		avc_bridgeco_fill_unit_addr(addr, AVC_BRIDGECO_PLUG_DIR_IN,
+					    AVC_BRIDGECO_PLUG_UNIT_EXT, i);
+		err = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);
+		if (err < 0) {
+			dev_err(&bebob->unit->device,
+			"fail to get type for external in plug %d: %d\n",
+				i, err);
+			goto end;
+		} else if (type == AVC_BRIDGECO_PLUG_TYPE_MIDI) {
+			bebob->midi_input_ports++;
+		}
+	}
+
+	/* count external output plugs for MIDI */
+	bebob->midi_output_ports = 0;
+	for (i = 0; i < plugs[3]; i++) {
+		avc_bridgeco_fill_unit_addr(addr, AVC_BRIDGECO_PLUG_DIR_OUT,
+					    AVC_BRIDGECO_PLUG_UNIT_EXT, i);
+		err = avc_bridgeco_get_plug_type(bebob->unit, addr, &type);
+		if (err < 0) {
+			dev_err(&bebob->unit->device,
+			"fail to get type for external out plug %d: %d\n",
+				i, err);
+			goto end;
+		} else if (type == AVC_BRIDGECO_PLUG_TYPE_MIDI) {
+			bebob->midi_output_ports++;
+		}
+	}
+
+	/* for check source of clock later */
+	err = seek_msu_sync_input_plug(bebob);
+end:
+	return err;
+}
