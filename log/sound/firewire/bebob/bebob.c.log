commit 9c0d16ac059148fc7647f5f9e90df6f34d3439f0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 6 22:52:29 2020 +0900

    ALSA: firewire: use KBUILD_MODNAME for struct driver.name instead of string
    
    KBUILD_MODNAME is available to name kernel modules according to its object
    name. This commit uses the macro instead of string for name field of
    struct driver since drivers in ALSA firewire stack have the same name of
    each object name.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200306135229.11659-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 976d8cb9a34f..2c8e3392a490 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -509,7 +509,7 @@ MODULE_DEVICE_TABLE(ieee1394, bebob_id_table);
 static struct fw_driver bebob_driver = {
 	.driver = {
 		.owner	= THIS_MODULE,
-		.name	= "snd-bebob",
+		.name	= KBUILD_MODNAME,
 		.bus	= &fw_bus_type,
 	},
 	.probe    = bebob_probe,

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 5b46e8dcc2dd..976d8cb9a34f 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * bebob.c - a part of driver for BeBoB based devices
  *
  * Copyright (c) 2013-2014 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 /*

commit 7dc661bd8d3261053b69e4e2d0050cd1ee540fc1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Feb 26 13:38:16 2019 +0900

    ALSA: bebob: use more identical mod_alias for Saffire Pro 10 I/O against Liquid Saffire 56
    
    ALSA bebob driver has an entry for Focusrite Saffire Pro 10 I/O. The
    entry matches vendor_id in root directory and model_id in unit
    directory of configuration ROM for IEEE 1394 bus.
    
    On the other hand, configuration ROM of Focusrite Liquid Saffire 56
    has the same vendor_id and model_id. This device is an application of
    TCAT Dice (TCD2220 a.k.a Dice Jr.) however ALSA bebob driver can be
    bound to it randomly instead of ALSA dice driver. At present, drivers
    in ALSA firewire stack can not handle this situation appropriately.
    
    This commit uses more identical mod_alias for Focusrite Saffire Pro 10
    I/O in ALSA bebob driver.
    
    $ python2 crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  042a829d  bus_info_length 4, crc_length 42, crc 33437
    404  31333934  bus_name "1394"
    408  f0649222  irmc 1, cmc 1, isc 1, bmc 1, pmc 0, cyc_clk_acc 100,
                   max_rec 9 (1024), max_rom 2, gen 2, spd 2 (S400)
    40c  00130e01  company_id 00130e     |
    410  000606e0  device_id 01000606e0  | EUI-64 00130e01000606e0
    
                   root directory
                   -----------------------------------------------------------------
    414  0009d31c  directory_length 9, crc 54044
    418  04000014  hardware version
    41c  0c0083c0  node capabilities per IEEE 1394
    420  0300130e  vendor
    424  81000012  --> descriptor leaf at 46c
    428  17000006  model
    42c  81000016  --> descriptor leaf at 484
    430  130120c2  version
    434  d1000002  --> unit directory at 43c
    438  d4000006  --> dependent info directory at 450
    
                   unit directory at 43c
                   -----------------------------------------------------------------
    43c  0004707c  directory_length 4, crc 28796
    440  1200a02d  specifier id: 1394 TA
    444  13010001  version: AV/C
    448  17000006  model
    44c  81000013  --> descriptor leaf at 498
    
                   dependent info directory at 450
                   -----------------------------------------------------------------
    450  000637c7  directory_length 6, crc 14279
    454  120007f5  specifier id
    458  13000001  version
    45c  3affffc7  (immediate value)
    460  3b100000  (immediate value)
    464  3cffffc7  (immediate value)
    468  3d600000  (immediate value)
    
                   descriptor leaf at 46c
                   -----------------------------------------------------------------
    46c  00056f3b  leaf_length 5, crc 28475
    470  00000000  textual descriptor
    474  00000000  minimal ASCII
    478  466f6375  "Focu"
    47c  73726974  "srit"
    480  65000000  "e"
    
                   descriptor leaf at 484
                   -----------------------------------------------------------------
    484  0004a165  leaf_length 4, crc 41317
    488  00000000  textual descriptor
    48c  00000000  minimal ASCII
    490  50726f31  "Pro1"
    494  30494f00  "0IO"
    
                   descriptor leaf at 498
                   -----------------------------------------------------------------
    498  0004a165  leaf_length 4, crc 41317
    49c  00000000  textual descriptor
    4a0  00000000  minimal ASCII
    4a4  50726f31  "Pro1"
    4a8  30494f00  "0IO"
    
    $ python2 crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  040442e4  bus_info_length 4, crc_length 4, crc 17124
    404  31333934  bus_name "1394"
    408  e0ff8112  irmc 1, cmc 1, isc 1, bmc 0, pmc 0, cyc_clk_acc 255,
                   max_rec 8 (512), max_rom 1, gen 1, spd 2 (S400)
    40c  00130e04  company_id 00130e     |
    410  018001e9  device_id 04018001e9  | EUI-64 00130e04018001e9
    
                   root directory
                   -----------------------------------------------------------------
    414  00065612  directory_length 6, crc 22034
    418  0300130e  vendor
    41c  8100000a  --> descriptor leaf at 444
    420  17000006  model
    424  8100000e  --> descriptor leaf at 45c
    428  0c0087c0  node capabilities per IEEE 1394
    42c  d1000001  --> unit directory at 430
    
                   unit directory at 430
                   -----------------------------------------------------------------
    430  000418a0  directory_length 4, crc 6304
    434  1200130e  specifier id
    438  13000001  version
    43c  17000006  model
    440  8100000f  --> descriptor leaf at 47c
    
                   descriptor leaf at 444
                   -----------------------------------------------------------------
    444  00056f3b  leaf_length 5, crc 28475
    448  00000000  textual descriptor
    44c  00000000  minimal ASCII
    450  466f6375  "Focu"
    454  73726974  "srit"
    458  65000000  "e"
    
                   descriptor leaf at 45c
                   -----------------------------------------------------------------
    45c  000762c6  leaf_length 7, crc 25286
    460  00000000  textual descriptor
    464  00000000  minimal ASCII
    468  4c495155  "LIQU"
    46c  49445f53  "ID_S"
    470  41464649  "AFFI"
    474  52455f35  "RE_5"
    478  36000000  "6"
    
                   descriptor leaf at 47c
                   -----------------------------------------------------------------
    47c  000762c6  leaf_length 7, crc 25286
    480  00000000  textual descriptor
    484  00000000  minimal ASCII
    488  4c495155  "LIQU"
    48c  49445f53  "ID_S"
    490  41464649  "AFFI"
    494  52455f35  "RE_5"
    498  36000000  "6"
    
    Cc: <stable@vger.kernel.org> # v3.16+
    Fixes: 25784ec2d034 ("ALSA: bebob: Add support for Focusrite Saffire/SaffirePro series")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index d91874275d2c..5b46e8dcc2dd 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -448,7 +448,19 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	/* Focusrite, SaffirePro 26 I/O */
 	SND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, 0x00000003, &saffirepro_26_spec),
 	/* Focusrite, SaffirePro 10 I/O */
-	SND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, 0x00000006, &saffirepro_10_spec),
+	{
+		// The combination of vendor_id and model_id is the same as the
+		// same as the one of Liquid Saffire 56.
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_MODEL_ID |
+				  IEEE1394_MATCH_SPECIFIER_ID |
+				  IEEE1394_MATCH_VERSION,
+		.vendor_id	= VEN_FOCUSRITE,
+		.model_id	= 0x000006,
+		.specifier_id	= 0x00a02d,
+		.version	= 0x010001,
+		.driver_data	= (kernel_ulong_t)&saffirepro_10_spec,
+	},
 	/* Focusrite, Saffire(no label and LE) */
 	SND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, MODEL_FOCUSRITE_SAFFIRE_BOTH,
 			    &saffire_spec),

commit 644b2e97405b0b74845e1d3c2b4fe4c34858062b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Dec 19 20:00:42 2018 +0900

    ALSA: bebob: fix model-id of unit for Apogee Ensemble
    
    This commit fixes hard-coded model-id for an unit of Apogee Ensemble with
    a correct value. This unit uses DM1500 ASIC produced ArchWave AG (formerly
    known as BridgeCo AG).
    
    I note that this model supports three modes in the number of data channels
    in tx/rx streams; 8 ch pairs, 10 ch pairs, 18 ch pairs. The mode is
    switched by Vendor-dependent AV/C command, like:
    
    $ cd linux-firewire-utils
    $ ./firewire-request /dev/fw1 fcp 0x00ff000003dbeb0600000000 (8ch pairs)
    $ ./firewire-request /dev/fw1 fcp 0x00ff000003dbeb0601000000 (10ch pairs)
    $ ./firewire-request /dev/fw1 fcp 0x00ff000003dbeb0602000000 (18ch pairs)
    
    When switching between different mode, the unit disappears from IEEE 1394
    bus, then appears on the bus with different combination of stream formats.
    In a mode of 18 ch pairs, available sampling rate is up to 96.0 kHz, else
    up to 192.0 kHz.
    
    $ ./hinawa-config-rom-printer /dev/fw1
    { 'bus-info': { 'adj': False,
                    'bmc': True,
                    'chip_ID': 21474898341,
                    'cmc': True,
                    'cyc_clk_acc': 100,
                    'generation': 2,
                    'imc': True,
                    'isc': True,
                    'link_spd': 2,
                    'max_ROM': 1,
                    'max_rec': 512,
                    'name': '1394',
                    'node_vendor_ID': 987,
                    'pmc': False},
      'root-directory': [ ['HARDWARE_VERSION', 19],
                          [ 'NODE_CAPABILITIES',
                            { 'addressing': {'64': True, 'fix': True, 'prv': False},
                              'misc': {'int': False, 'ms': False, 'spt': True},
                              'state': { 'atn': False,
                                         'ded': False,
                                         'drq': True,
                                         'elo': False,
                                         'init': False,
                                         'lst': True,
                                         'off': False},
                              'testing': {'bas': False, 'ext': False}}],
                          ['VENDOR', 987],
                          ['DESCRIPTOR', 'Apogee Electronics'],
                          ['MODEL', 126702],
                          ['DESCRIPTOR', 'Ensemble'],
                          ['VERSION', 5297],
                          [ 'UNIT',
                            [ ['SPECIFIER_ID', 41005],
                              ['VERSION', 65537],
                              ['MODEL', 126702],
                              ['DESCRIPTOR', 'Ensemble']]],
                          [ 'DEPENDENT_INFO',
                            [ ['SPECIFIER_ID', 2037],
                              ['VERSION', 1],
                              [(58, 'IMMEDIATE'), 16777159],
                              [(59, 'IMMEDIATE'), 1048576],
                              [(60, 'IMMEDIATE'), 16777159],
                              [(61, 'IMMEDIATE'), 6291456]]]]}
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 672d13488454..d91874275d2c 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -408,7 +408,7 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	/* Apogee Electronics, DA/AD/DD-16X (X-FireWire card) */
 	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00010048, &spec_normal),
 	/* Apogee Electronics, Ensemble */
-	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00001eee, &spec_normal),
+	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x01eeee, &spec_normal),
 	/* ESI, Quatafire610 */
 	SND_BEBOB_DEV_ENTRY(VEN_ESI, 0x00010064, &spec_normal),
 	/* AcousticReality, eARMasterOne */

commit 3babca4555b20fc80aff4776662fb237257d9afd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:02 2018 +0900

    ALSA: firewire: simplify cleanup process when failing to register sound card
    
    In former commits, .private_free callback releases resources just for
    data transmission. This release function can be called without the
    resources are actually allocated in error paths.
    
    This commit applies a small refactoring to clean up codes in error
    paths.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 3bc68499974a..672d13488454 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -126,8 +126,11 @@ name_device(struct snd_bebob *bebob)
 	return err;
 }
 
-static void bebob_free(struct snd_bebob *bebob)
+static void
+bebob_card_free(struct snd_card *card)
 {
+	struct snd_bebob *bebob = card->private_data;
+
 	mutex_lock(&devices_mutex);
 	clear_bit(bebob->card_index, devices_used);
 	mutex_unlock(&devices_mutex);
@@ -135,18 +138,6 @@ static void bebob_free(struct snd_bebob *bebob)
 	snd_bebob_stream_destroy_duplex(bebob);
 }
 
-/*
- * This module releases the FireWire unit data after all ALSA character devices
- * are released by applications. This is for releasing stream data or finishing
- * transactions safely. Thus at returning from .remove(), this module still keep
- * references for the unit.
- */
-static void
-bebob_card_free(struct snd_card *card)
-{
-	bebob_free(card->private_data);
-}
-
 static const struct snd_bebob_spec *
 get_saffire_spec(struct fw_unit *unit)
 {
@@ -202,6 +193,9 @@ do_registration(struct work_struct *work)
 	set_bit(card_index, devices_used);
 	mutex_unlock(&devices_mutex);
 
+	bebob->card->private_free = bebob_card_free;
+	bebob->card->private_data = bebob;
+
 	err = name_device(bebob);
 	if (err < 0)
 		goto error;
@@ -241,17 +235,10 @@ do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	/*
-	 * After registered, bebob instance can be released corresponding to
-	 * releasing the sound card instance.
-	 */
-	bebob->card->private_free = bebob_card_free;
-	bebob->card->private_data = bebob;
 	bebob->registered = true;
 
 	return;
 error:
-	snd_bebob_stream_destroy_duplex(bebob);
 	snd_card_free(bebob->card);
 	dev_info(&bebob->unit->device,
 		 "Sound card registration failed: %d\n", err);

commit 873608dc6b5da7a2571419bfa10e0d088d39cee0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:01 2018 +0900

    ALSA: bebob/fireworks: simplify handling of local device entry table
    
    In drivers of ALSA firewire stack, bebob and fireworks drivers have
    local device entry table. At present, critical section to operate the
    table is from the beginning/end of 'do_registration' call. This can be
    more narrow and simplify codes.
    
    This commit applies small refactoring for the above purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 34ed8afbb30c..3bc68499974a 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -128,6 +128,10 @@ name_device(struct snd_bebob *bebob)
 
 static void bebob_free(struct snd_bebob *bebob)
 {
+	mutex_lock(&devices_mutex);
+	clear_bit(bebob->card_index, devices_used);
+	mutex_unlock(&devices_mutex);
+
 	snd_bebob_stream_destroy_duplex(bebob);
 }
 
@@ -140,12 +144,6 @@ static void bebob_free(struct snd_bebob *bebob)
 static void
 bebob_card_free(struct snd_card *card)
 {
-	struct snd_bebob *bebob = card->private_data;
-
-	mutex_lock(&devices_mutex);
-	clear_bit(bebob->card_index, devices_used);
-	mutex_unlock(&devices_mutex);
-
 	bebob_free(card->private_data);
 }
 
@@ -186,7 +184,6 @@ do_registration(struct work_struct *work)
 		return;
 
 	mutex_lock(&devices_mutex);
-
 	for (card_index = 0; card_index < SNDRV_CARDS; card_index++) {
 		if (!test_bit(card_index, devices_used) && enable[card_index])
 			break;
@@ -202,6 +199,8 @@ do_registration(struct work_struct *work)
 		mutex_unlock(&devices_mutex);
 		return;
 	}
+	set_bit(card_index, devices_used);
+	mutex_unlock(&devices_mutex);
 
 	err = name_device(bebob);
 	if (err < 0)
@@ -242,9 +241,6 @@ do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	set_bit(card_index, devices_used);
-	mutex_unlock(&devices_mutex);
-
 	/*
 	 * After registered, bebob instance can be released corresponding to
 	 * releasing the sound card instance.
@@ -255,7 +251,6 @@ do_registration(struct work_struct *work)
 
 	return;
 error:
-	mutex_unlock(&devices_mutex);
 	snd_bebob_stream_destroy_duplex(bebob);
 	snd_card_free(bebob->card);
 	dev_info(&bebob->unit->device,

commit 5b14ec25a79bf60fc9a663fe579a500b6ac9d8ab
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:00 2018 +0900

    ALSA: firewire: release reference count of firewire unit in .remove callback of bus driver
    
    In a previous commit, drivers in ALSA firewire stack blocks .remove
    callback of bus driver. This enables to release members of private
    data in the callback after releasing device of sound card.
    
    This commit simplifies codes to release the members.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 3a5579cb3aa8..34ed8afbb30c 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -129,9 +129,6 @@ name_device(struct snd_bebob *bebob)
 static void bebob_free(struct snd_bebob *bebob)
 {
 	snd_bebob_stream_destroy_duplex(bebob);
-
-	mutex_destroy(&bebob->mutex);
-	fw_unit_put(bebob->unit);
 }
 
 /*
@@ -376,10 +373,10 @@ static void bebob_remove(struct fw_unit *unit)
 	if (bebob->registered) {
 		// Block till all of ALSA character devices are released.
 		snd_card_free(bebob->card);
-	} else {
-		/* Don't forget this case. */
-		bebob_free(bebob);
 	}
+
+	mutex_destroy(&bebob->mutex);
+	fw_unit_put(bebob->unit);
 }
 
 static const struct snd_bebob_rate_spec normal_rate_spec = {

commit 61ccc6f6b27c03bb32ca38a3c580d49ce1612d43
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:34:59 2018 +0900

    ALSA: firewire: block .remove callback of bus driver till all of ALSA character devices are released
    
    At present, in .remove callback of bus driver just decrease reference
    count of device for ALSA card instance. This delegates release of the
    device to a process in which the last of ALSA character device is
    released.
    
    On the other hand, the other drivers such as for devices on PCIe are
    programmed to block .remove callback of bus driver till all of ALSA
    character devices are released.
    
    For consistency of behaviour for whole drivers, this probably confuses
    users. This commit takes drivers in ALSA firewire stack to imitate the
    above behaviour.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 72b04214a3b5..3a5579cb3aa8 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -374,8 +374,8 @@ static void bebob_remove(struct fw_unit *unit)
 	cancel_delayed_work_sync(&bebob->dwork);
 
 	if (bebob->registered) {
-		/* No need to wait for releasing card object in this context. */
-		snd_card_free_when_closed(bebob->card);
+		// Block till all of ALSA character devices are released.
+		snd_card_free(bebob->card);
 	} else {
 		/* Don't forget this case. */
 		bebob_free(bebob);

commit a3aaf7d2bd388caea2bd0fba266b815ac708c49d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:51 2018 +0900

    ALSA: bebob: use managed-resource to maintain data specific to M-Audio FW-1814/ProjectMix I/O
    
    ALSA bebob driver allocates memory object for data specific to M-Audio
    FW-1884/ProjectMix I/O. The object is to maintain format of isochronous
    packet payload for packet streaming by components for ALSA rawMIDI/PCM
    interfaces. The object can be released as managed-resource of
    'struct snd_card.card_dev'.
    
    This commit uses managed-resource of the sound card device for this
    purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index fb05f2c1b60b..72b04214a3b5 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -130,8 +130,6 @@ static void bebob_free(struct snd_bebob *bebob)
 {
 	snd_bebob_stream_destroy_duplex(bebob);
 
-	kfree(bebob->maudio_special_quirk);
-
 	mutex_destroy(&bebob->mutex);
 	fw_unit_put(bebob->unit);
 }
@@ -262,8 +260,6 @@ do_registration(struct work_struct *work)
 error:
 	mutex_unlock(&devices_mutex);
 	snd_bebob_stream_destroy_duplex(bebob);
-	kfree(bebob->maudio_special_quirk);
-	bebob->maudio_special_quirk = NULL;
 	snd_card_free(bebob->card);
 	dev_info(&bebob->unit->device,
 		 "Sound card registration failed: %d\n", err);

commit 366a20d7a75cff7f89dede6fdfd41bd491aaf8ac
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:50 2018 +0900

    ALSA: firewire: use managed-resource of fw unit device for private data
    
    At present, private data of each driver in ALSA firewire stack is
    allocated/freed by kernel slab allocator for corresponding unit on
    IEEE 1394 bus. In this case, resource-managed slab allocator is
    available to release memory object automatically just before releasing
    device structure for the unit. This idea can prevent runtime from
    memory leak due to programming mistakes.
    
    This commit uses the allocator for the private data. These drivers
    already use reference counter to maintain lifetime of device structure
    for the unit by a pair of fw_unit_get()/fw_unit_put(). The private data
    is safely released in a callback of 'struct snd_card.private_free().
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 93676354f87f..fb05f2c1b60b 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -129,12 +129,11 @@ name_device(struct snd_bebob *bebob)
 static void bebob_free(struct snd_bebob *bebob)
 {
 	snd_bebob_stream_destroy_duplex(bebob);
-	fw_unit_put(bebob->unit);
 
 	kfree(bebob->maudio_special_quirk);
 
 	mutex_destroy(&bebob->mutex);
-	kfree(bebob);
+	fw_unit_put(bebob->unit);
 }
 
 /*
@@ -295,15 +294,15 @@ bebob_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)
 	}
 
 	/* Allocate this independent of sound card instance. */
-	bebob = kzalloc(sizeof(struct snd_bebob), GFP_KERNEL);
-	if (bebob == NULL)
+	bebob = devm_kzalloc(&unit->device, sizeof(struct snd_bebob),
+			     GFP_KERNEL);
+	if (!bebob)
 		return -ENOMEM;
-
 	bebob->unit = fw_unit_get(unit);
-	bebob->entry = entry;
-	bebob->spec = spec;
 	dev_set_drvdata(&unit->device, bebob);
 
+	bebob->entry = entry;
+	bebob->spec = spec;
 	mutex_init(&bebob->mutex);
 	spin_lock_init(&bebob->lock);
 	init_waitqueue_head(&bebob->hwdep_wait);

commit b1fbebd4164b3d170ad916dcd692cf843c9c065d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Sep 17 17:25:24 2018 +0900

    ALSA: bebob: fix memory leak for M-Audio FW1814 and ProjectMix I/O at error path
    
    After allocating model-dependent data for M-Audio FW1814 and ProjectMix
    I/O, ALSA bebob driver has memory leak at error path.
    
    This commit releases the allocated data at the error path.
    
    Fixes: 04a2c73c97eb('ALSA: bebob: delayed registration of sound card')
    Cc: <stable@vger.kernel.org> # v4.7+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 730ea91d9be8..93676354f87f 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -263,6 +263,8 @@ do_registration(struct work_struct *work)
 error:
 	mutex_unlock(&devices_mutex);
 	snd_bebob_stream_destroy_duplex(bebob);
+	kfree(bebob->maudio_special_quirk);
+	bebob->maudio_special_quirk = NULL;
 	snd_card_free(bebob->card);
 	dev_info(&bebob->unit->device,
 		 "Sound card registration failed: %d\n", err);

commit 2e57069c869f3009ae70a429d6719a545de43522
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Nov 18 06:11:24 2016 +0900

    ALSA: bebob: compare whole string for model name so that readers are not confused
    
    A modalias of 'ieee1394:ven00000D6Cmo00010060sp' hits units for M-Audio
    FireWire Audiophile only. However the unit has two states relevant to
    loaded firmware. Initial firmware returns 'FW Audiophile Bootloader',
    while functional firmware returns 'FW Audiophile'.
    
    ALSA bebob driver compares the units' model name to strings of 24 characters
    by the first 15 characters. This is shorter way to differentiate these two
    states but confusing to readers.
    
    This commit improves the code for this point. Kernel stack is consumed more in
    call of check_audiophile_booted() by a bit.
    
    With initial firmware:
    $ ./linux-firewire-utils/src/crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  04276da6  bus_info_length 4, crc_length 39, crc 28070
    404  31333934  bus_name "1394"
    408  006481f2  irmc 0, cmc 0, isc 0, bmc 0, pmc 0, cyc_clk_acc 100,
                   max_rec 8 (512), max_rom 1, gen 15, spd 2 (S400)
    40c  000d6c03  company_id 000d6c     |
    410  102b7e2e  device_id 03102b7e2e  | EUI-64 000d6c03102b7e2e
    
                   root directory
                   -----------------------------------------------------------------
    414  00067414  directory_length 6, crc 29716
    418  0c0083c0  node capabilities per IEEE 1394
    41c  03000d6c  vendor
    420  81000009  --> descriptor leaf at 444
    424  17010060  model
    428  8100000c  --> descriptor leaf at 458
    42c  d1000001  --> unit directory at 430
    
                   unit directory at 430
                   -----------------------------------------------------------------
    430  00049da1  directory_length 4, crc 40353 (should be 48611)
    434  1200a02d  specifier id: 1394 TA
    438  13014001  version: Vender Unique and AV/C
    43c  17010060  model
    440  8100000f  --> descriptor leaf at 47c
    
                   descriptor leaf at 444
                   -----------------------------------------------------------------
    444  0004073e  leaf_length 4, crc 1854
    448  00000000  textual descriptor
    44c  00000000  minimal ASCII
    450  4d2d4155  "M-AU"
    454  44494f00  "DIO"
    
                   descriptor leaf at 458
                   -----------------------------------------------------------------
    458  00086f21  leaf_length 8, crc 28449
    45c  00000000  textual descriptor
    460  00000000  minimal ASCII
    464  46572041  "FW A"
    468  7564696f  "udio"
    46c  7068696c  "phil"
    470  6520426f  "e Bo"
    474  6f746c6f  "otlo"
    478  61646572  "ader"
    
                   descriptor leaf at 47c
                   -----------------------------------------------------------------
    47c  00086f21  leaf_length 8, crc 28449
    480  00000000  textual descriptor
    484  00000000  minimal ASCII
    488  46572041  "FW A"
    48c  7564696f  "udio"
    490  7068696c  "phil"
    494  6520426f  "e Bo"
    498  6f746c6f  "otlo"
    49c  61646572  "ader"
    
    With functional firmware:
    $ ./linux-firewire-utils/src/crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  042de16f  bus_info_length 4, crc_length 45, crc 57711
    404  31333934  bus_name "1394"
    408  f0648122  irmc 1, cmc 1, isc 1, bmc 1, pmc 0, cyc_clk_acc 100,
                   max_rec 8 (512), max_rom 1, gen 2, spd 2 (S400)
    40c  000d6c03  company_id 000d6c     |
    410  002b7e2e  device_id 03002b7e2e  | EUI-64 000d6c03002b7e2e
    
                   root directory
                   -----------------------------------------------------------------
    414  0009dac4  directory_length 9, crc 56004
    418  0400000d  hardware version
    41c  0c0083c0  node capabilities per IEEE 1394
    420  03000d6c  vendor
    424  81000012  --> descriptor leaf at 46c
    428  17010060  model
    42c  81000015  --> descriptor leaf at 480
    430  13ffffff  version
    434  d1000002  --> unit directory at 43c
    438  d4000006  --> dependent info directory at 450
    
                   unit directory at 43c
                   -----------------------------------------------------------------
    43c  00041eb9  directory_length 4, crc 7865
    440  1200a02d  specifier id: 1394 TA
    444  13014001  version: Vender Unique and AV/C
    448  17010060  model
    44c  81000014  --> descriptor leaf at 49c
    
                   dependent info directory at 450
                   -----------------------------------------------------------------
    450  000637c7  directory_length 6, crc 14279
    454  120007f5  specifier id
    458  13000001  version
    45c  3affffc7  (immediate value)
    460  3b100000  (immediate value)
    464  3cffffc7  (immediate value)
    468  3d600000  (immediate value)
    
                   descriptor leaf at 46c
                   -----------------------------------------------------------------
    46c  0004b8e4  leaf_length 4, crc 47332
    470  00000000  textual descriptor
    474  00000000  minimal ASCII
    478  4d2d4175  "M-Au"
    47c  64696f00  "dio"
    
                   descriptor leaf at 480
                   -----------------------------------------------------------------
    480  0006194b  leaf_length 6, crc 6475
    484  00000000  textual descriptor
    488  00000000  minimal ASCII
    48c  46572041  "FW A"
    490  7564696f  "udio"
    494  7068696c  "phil"
    498  65000000  "e"
    
                   descriptor leaf at 49c
                   -----------------------------------------------------------------
    49c  0006194b  leaf_length 6, crc 6475
    4a0  00000000  textual descriptor
    4a4  00000000  minimal ASCII
    4a8  46572041  "FW A"
    4ac  7564696f  "udio"
    4b0  7068696c  "phil"
    4b4  65000000  "e"
    
    Reported-by: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
    Reported-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 3469ac14c89c..730ea91d9be8 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -172,12 +172,12 @@ get_saffire_spec(struct fw_unit *unit)
 static bool
 check_audiophile_booted(struct fw_unit *unit)
 {
-	char name[24] = {0};
+	char name[28] = {0};
 
 	if (fw_csr_string(unit->directory, CSR_MODEL, name, sizeof(name)) < 0)
 		return false;
 
-	return strncmp(name, "FW Audiophile Bootloader", 15) != 0;
+	return strncmp(name, "FW Audiophile Bootloader", 24) != 0;
 }
 
 static void

commit e15c282eff54aaf4c5ed72d492da7060d14f7be8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Aug 24 21:42:43 2016 +0900

    ALSA: bebob: unify configurations for some models produced by Yamaha/Terratec
    
    The below models were developed with a cooperation by Yamaha and Terratec.
     - Yamaha GO 44/Terratec PHASE 24 FW
     - Yamaha GO 46/Terratec PHASE X24 FW
    
    They have the same configurations, thus it's better to unify corresponding
    codes.
    
    This commit merges them to reduce the amount of maintained codes.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index f7e2cbd2a313..3469ac14c89c 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -458,17 +458,17 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	/* TerraTec Electronic GmbH, PHASE 88 Rack FW */
 	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000003, &phase88_rack_spec),
 	/* TerraTec Electronic GmbH, PHASE 24 FW */
-	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000004, &phase24_series_spec),
+	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000004, &yamaha_terratec_spec),
 	/* TerraTec Electronic GmbH, Phase X24 FW */
-	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000007, &phase24_series_spec),
+	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000007, &yamaha_terratec_spec),
 	/* TerraTec Electronic GmbH, EWS MIC2/MIC8 */
 	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000005, &spec_normal),
 	/* Terratec Electronic GmbH, Aureon 7.1 Firewire */
 	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000002, &spec_normal),
 	/* Yamaha, GO44 */
-	SND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000b, &yamaha_go_spec),
+	SND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000b, &yamaha_terratec_spec),
 	/* YAMAHA, GO46 */
-	SND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000c, &yamaha_go_spec),
+	SND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000c, &yamaha_terratec_spec),
 	/* Focusrite, SaffirePro 26 I/O */
 	SND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, 0x00000003, &saffirepro_26_spec),
 	/* Focusrite, SaffirePro 10 I/O */

commit 04a2c73c97ebb224dfb411ab35bb18d7b8245e39
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Mar 31 08:47:05 2016 +0900

    ALSA: bebob: delayed registration of sound card
    
    Some bebob based units tends to fail asynchronous communication when
    IEEE 1394 bus is under bus-reset state. When registering sound card
    instance at unit probe callback, userspace applications can be involved
    to the state.
    
    This commit postpones the registration till the bus is calm.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 932901de255f..f7e2cbd2a313 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -126,6 +126,17 @@ name_device(struct snd_bebob *bebob)
 	return err;
 }
 
+static void bebob_free(struct snd_bebob *bebob)
+{
+	snd_bebob_stream_destroy_duplex(bebob);
+	fw_unit_put(bebob->unit);
+
+	kfree(bebob->maudio_special_quirk);
+
+	mutex_destroy(&bebob->mutex);
+	kfree(bebob);
+}
+
 /*
  * This module releases the FireWire unit data after all ALSA character devices
  * are released by applications. This is for releasing stream data or finishing
@@ -137,18 +148,11 @@ bebob_card_free(struct snd_card *card)
 {
 	struct snd_bebob *bebob = card->private_data;
 
-	snd_bebob_stream_destroy_duplex(bebob);
-	fw_unit_put(bebob->unit);
-
-	kfree(bebob->maudio_special_quirk);
-
-	if (bebob->card_index >= 0) {
-		mutex_lock(&devices_mutex);
-		clear_bit(bebob->card_index, devices_used);
-		mutex_unlock(&devices_mutex);
-	}
+	mutex_lock(&devices_mutex);
+	clear_bit(bebob->card_index, devices_used);
+	mutex_unlock(&devices_mutex);
 
-	mutex_destroy(&bebob->mutex);
+	bebob_free(card->private_data);
 }
 
 static const struct snd_bebob_spec *
@@ -176,16 +180,17 @@ check_audiophile_booted(struct fw_unit *unit)
 	return strncmp(name, "FW Audiophile Bootloader", 15) != 0;
 }
 
-static int
-bebob_probe(struct fw_unit *unit,
-	    const struct ieee1394_device_id *entry)
+static void
+do_registration(struct work_struct *work)
 {
-	struct snd_card *card;
-	struct snd_bebob *bebob;
-	const struct snd_bebob_spec *spec;
+	struct snd_bebob *bebob =
+			container_of(work, struct snd_bebob, dwork.work);
 	unsigned int card_index;
 	int err;
 
+	if (bebob->registered)
+		return;
+
 	mutex_lock(&devices_mutex);
 
 	for (card_index = 0; card_index < SNDRV_CARDS; card_index++) {
@@ -193,64 +198,39 @@ bebob_probe(struct fw_unit *unit,
 			break;
 	}
 	if (card_index >= SNDRV_CARDS) {
-		err = -ENOENT;
-		goto end;
+		mutex_unlock(&devices_mutex);
+		return;
 	}
 
-	if ((entry->vendor_id == VEN_FOCUSRITE) &&
-	    (entry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH))
-		spec = get_saffire_spec(unit);
-	else if ((entry->vendor_id == VEN_MAUDIO1) &&
-		 (entry->model_id == MODEL_MAUDIO_AUDIOPHILE_BOTH) &&
-		 !check_audiophile_booted(unit))
-		spec = NULL;
-	else
-		spec = (const struct snd_bebob_spec *)entry->driver_data;
-
-	if (spec == NULL) {
-		if ((entry->vendor_id == VEN_MAUDIO1) ||
-		    (entry->vendor_id == VEN_MAUDIO2))
-			err = snd_bebob_maudio_load_firmware(unit);
-		else
-			err = -ENOSYS;
-		goto end;
+	err = snd_card_new(&bebob->unit->device, index[card_index],
+			   id[card_index], THIS_MODULE, 0, &bebob->card);
+	if (err < 0) {
+		mutex_unlock(&devices_mutex);
+		return;
 	}
 
-	err = snd_card_new(&unit->device, index[card_index], id[card_index],
-			   THIS_MODULE, sizeof(struct snd_bebob), &card);
-	if (err < 0)
-		goto end;
-	bebob = card->private_data;
-	bebob->card_index = card_index;
-	set_bit(card_index, devices_used);
-	card->private_free = bebob_card_free;
-
-	bebob->card = card;
-	bebob->unit = fw_unit_get(unit);
-	bebob->spec = spec;
-	mutex_init(&bebob->mutex);
-	spin_lock_init(&bebob->lock);
-	init_waitqueue_head(&bebob->hwdep_wait);
-
 	err = name_device(bebob);
 	if (err < 0)
 		goto error;
 
-	if ((entry->vendor_id == VEN_MAUDIO1) &&
-	    (entry->model_id == MODEL_MAUDIO_FW1814))
-		err = snd_bebob_maudio_special_discover(bebob, true);
-	else if ((entry->vendor_id == VEN_MAUDIO1) &&
-		 (entry->model_id == MODEL_MAUDIO_PROJECTMIX))
-		err = snd_bebob_maudio_special_discover(bebob, false);
-	else
+	if (bebob->spec == &maudio_special_spec) {
+		if (bebob->entry->model_id == MODEL_MAUDIO_FW1814)
+			err = snd_bebob_maudio_special_discover(bebob, true);
+		else
+			err = snd_bebob_maudio_special_discover(bebob, false);
+	} else {
 		err = snd_bebob_stream_discover(bebob);
+	}
+	if (err < 0)
+		goto error;
+
+	err = snd_bebob_stream_init_duplex(bebob);
 	if (err < 0)
 		goto error;
 
 	snd_bebob_proc_init(bebob);
 
-	if ((bebob->midi_input_ports > 0) ||
-	    (bebob->midi_output_ports > 0)) {
+	if (bebob->midi_input_ports > 0 || bebob->midi_output_ports > 0) {
 		err = snd_bebob_create_midi_devices(bebob);
 		if (err < 0)
 			goto error;
@@ -264,16 +244,75 @@ bebob_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_bebob_stream_init_duplex(bebob);
+	err = snd_card_register(bebob->card);
 	if (err < 0)
 		goto error;
 
-	if (!bebob->maudio_special_quirk) {
-		err = snd_card_register(card);
-		if (err < 0) {
-			snd_bebob_stream_destroy_duplex(bebob);
-			goto error;
-		}
+	set_bit(card_index, devices_used);
+	mutex_unlock(&devices_mutex);
+
+	/*
+	 * After registered, bebob instance can be released corresponding to
+	 * releasing the sound card instance.
+	 */
+	bebob->card->private_free = bebob_card_free;
+	bebob->card->private_data = bebob;
+	bebob->registered = true;
+
+	return;
+error:
+	mutex_unlock(&devices_mutex);
+	snd_bebob_stream_destroy_duplex(bebob);
+	snd_card_free(bebob->card);
+	dev_info(&bebob->unit->device,
+		 "Sound card registration failed: %d\n", err);
+}
+
+static int
+bebob_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)
+{
+	struct snd_bebob *bebob;
+	const struct snd_bebob_spec *spec;
+
+	if (entry->vendor_id == VEN_FOCUSRITE &&
+	    entry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH)
+		spec = get_saffire_spec(unit);
+	else if (entry->vendor_id == VEN_MAUDIO1 &&
+		 entry->model_id == MODEL_MAUDIO_AUDIOPHILE_BOTH &&
+		 !check_audiophile_booted(unit))
+		spec = NULL;
+	else
+		spec = (const struct snd_bebob_spec *)entry->driver_data;
+
+	if (spec == NULL) {
+		if (entry->vendor_id == VEN_MAUDIO1 ||
+		    entry->vendor_id == VEN_MAUDIO2)
+			return snd_bebob_maudio_load_firmware(unit);
+		else
+			return -ENODEV;
+	}
+
+	/* Allocate this independent of sound card instance. */
+	bebob = kzalloc(sizeof(struct snd_bebob), GFP_KERNEL);
+	if (bebob == NULL)
+		return -ENOMEM;
+
+	bebob->unit = fw_unit_get(unit);
+	bebob->entry = entry;
+	bebob->spec = spec;
+	dev_set_drvdata(&unit->device, bebob);
+
+	mutex_init(&bebob->mutex);
+	spin_lock_init(&bebob->lock);
+	init_waitqueue_head(&bebob->hwdep_wait);
+
+	/* Allocate and register this sound card later. */
+	INIT_DEFERRABLE_WORK(&bebob->dwork, do_registration);
+
+	if (entry->vendor_id != VEN_MAUDIO1 ||
+	    (entry->model_id != MODEL_MAUDIO_FW1814 &&
+	     entry->model_id != MODEL_MAUDIO_PROJECTMIX)) {
+		snd_fw_schedule_registration(unit, &bebob->dwork);
 	} else {
 		/*
 		 * This is a workaround. This bus reset seems to have an effect
@@ -285,19 +324,11 @@ bebob_probe(struct fw_unit *unit,
 		 * signals from dbus and starts I/Os. To avoid I/Os till the
 		 * future bus reset, registration is done in next update().
 		 */
-		bebob->deferred_registration = true;
 		fw_schedule_bus_reset(fw_parent_device(bebob->unit)->card,
 				      false, true);
 	}
 
-	dev_set_drvdata(&unit->device, bebob);
-end:
-	mutex_unlock(&devices_mutex);
-	return err;
-error:
-	mutex_unlock(&devices_mutex);
-	snd_card_free(card);
-	return err;
+	return 0;
 }
 
 /*
@@ -324,15 +355,11 @@ bebob_update(struct fw_unit *unit)
 	if (bebob == NULL)
 		return;
 
-	fcp_bus_reset(bebob->unit);
-
-	if (bebob->deferred_registration) {
-		if (snd_card_register(bebob->card) < 0) {
-			snd_bebob_stream_destroy_duplex(bebob);
-			snd_card_free(bebob->card);
-		}
-		bebob->deferred_registration = false;
-	}
+	/* Postpone a workqueue for deferred registration. */
+	if (!bebob->registered)
+		snd_fw_schedule_registration(unit, &bebob->dwork);
+	else
+		fcp_bus_reset(bebob->unit);
 }
 
 static void bebob_remove(struct fw_unit *unit)
@@ -342,8 +369,20 @@ static void bebob_remove(struct fw_unit *unit)
 	if (bebob == NULL)
 		return;
 
-	/* No need to wait for releasing card object in this context. */
-	snd_card_free_when_closed(bebob->card);
+	/*
+	 * Confirm to stop the work for registration before the sound card is
+	 * going to be released. The work is not scheduled again because bus
+	 * reset handler is not called anymore.
+	 */
+	cancel_delayed_work_sync(&bebob->dwork);
+
+	if (bebob->registered) {
+		/* No need to wait for releasing card object in this context. */
+		snd_card_free_when_closed(bebob->card);
+	} else {
+		/* Don't forget this case. */
+		bebob_free(bebob);
+	}
 }
 
 static const struct snd_bebob_rate_spec normal_rate_spec = {

commit 093dd449782737b50f8e1ee1608720dfd46d8ed2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Mar 27 16:09:06 2016 +0900

    ALSA: bebob: remove needless argument from local function
    
    The 'vendor_id' argument is not used in the local function. Let's remove
    it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 3e4e0756e3fe..932901de255f 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -67,7 +67,7 @@ static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 #define MODEL_MAUDIO_PROJECTMIX		0x00010091
 
 static int
-name_device(struct snd_bebob *bebob, unsigned int vendor_id)
+name_device(struct snd_bebob *bebob)
 {
 	struct fw_device *fw_dev = fw_parent_device(bebob->unit);
 	char vendor[24] = {0};
@@ -232,7 +232,7 @@ bebob_probe(struct fw_unit *unit,
 	spin_lock_init(&bebob->lock);
 	init_waitqueue_head(&bebob->hwdep_wait);
 
-	err = name_device(bebob, entry->vendor_id);
+	err = name_device(bebob);
 	if (err < 0)
 		goto error;
 

commit 3800e6f944e929ddfcd9320a51e13a67fd1956ff
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 20 16:18:59 2016 +0900

    ALSA: bebob: give up updating streams at bus reset handler
    
    DM1000/DM1100/DM1500 chipsets transfer packets with discontinue value in
    'dbc' field of CIP header. For ALSA bebob driver, this makes its bus-reset
    handler meaningless, because the discontinuity is detected quite earlier
    than executing the handler.
    
    This commit gives up updating streams at the bus reset handler.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 671179eaff1e..3e4e0756e3fe 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -300,6 +300,22 @@ bebob_probe(struct fw_unit *unit,
 	return err;
 }
 
+/*
+ * This driver doesn't update streams in bus reset handler.
+ *
+ * DM1000/ DM1100/DM1500 chipsets with BeBoB firmware transfer packets with
+ * discontinued counter at bus reset. This discontinuity is immediately
+ * detected in packet streaming layer, then it sets XRUN to PCM substream.
+ *
+ * ALSA PCM applications can know the XRUN by getting -EPIPE from PCM operation.
+ * Then, they can recover the PCM substream by executing ioctl(2) with
+ * SNDRV_PCM_IOCTL_PREPARE. 'struct snd_pcm_ops.prepare' is called and drivers
+ * restart packet streaming.
+ *
+ * The above processing may be executed before this bus-reset handler is
+ * executed. When this handler updates streams with current isochronous
+ * channels, the streams already have the current ones.
+ */
 static void
 bebob_update(struct fw_unit *unit)
 {
@@ -310,10 +326,6 @@ bebob_update(struct fw_unit *unit)
 
 	fcp_bus_reset(bebob->unit);
 
-	mutex_lock(&bebob->mutex);
-	snd_bebob_stream_update_duplex(bebob);
-	mutex_unlock(&bebob->mutex);
-
 	if (bebob->deferred_registration) {
 		if (snd_card_register(bebob->card) < 0) {
 			snd_bebob_stream_destroy_duplex(bebob);

commit 14a37ac1bf8a2ba9b19032195c371c7b0857ca87
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 20 16:18:56 2016 +0900

    ALSA: bebob: simplify bus-reset handling
    
    At bus-reset, DM1000/DM1100/DM1500 chipsets transfer packets with
    discontinuous value in 'dbc' field of CIP header. In this case, packet
    streaming layer in firewire-lib module stops streaming and set XRUN to PCM
    substream.
    
    In ALSA, PCM applications are notified the XRUN status by the return value
    of ALSA PCM interface. They can recover this state by executing
    snd_pcm_prepare(), then PCM drivers' prepare handler is called, and start
    new PCM substream. For ALSA BeBoB driver, the handler establishes new
    connections and start new AMDTP streaming.
    
    Unfortunately, neither the PCM applications nor the driver know the reason
    of XRUN. The driver gets to know the reason when update handler is called
    by IEEE 1394 bus driver. As long as I tested, the order of below events are
    not fixed:
     * Detecting packet discontinuity in tasklet context of OHCI 1394 driver
     * Calling prepare handler in process context of ALSA PCM application
     * Calling update handler in kthread context of IEEE 1394 bus driver
    
    The unpredictable order is disadvantage for the driver to be compliant to
    CMP. In IEC 61883-1, new CMP establish operations should be done 1 sec
    (isoc_resource_delay) after bus-reset. Within 1 sec, CMP restore
    operations are allowed. For this reason, in former commit ('b6bc812327aa:
    ALSA: bebob/firewire-lib: Add a quirk for discontinuity at bus reset'),
    the process context is forced to wait for executing update handler. The
    process context wait for bus-reset up to 1 sec. This commit solves the
    issue, while causes more disadvantages. For PCM applications, calling
    snd_pcm_prepare() for recovering XRUN state takes more time and the driver
    got a bit complicated code, while the recovery is not always successful.
    
    As long as I tested, DM1000/DM1100/DM1500 and BeBoB firmware can allow
    drivers to establish new connections just after bus reset. Furthermore,
    any FCP transactions are handled correctly. Therefore, the driver don't
    need to wait for bus reset handler for starting new streaming.
    
    This commit removes the codes to reduce maintenance cost.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 091290d1f3ea..671179eaff1e 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -309,7 +309,10 @@ bebob_update(struct fw_unit *unit)
 		return;
 
 	fcp_bus_reset(bebob->unit);
+
+	mutex_lock(&bebob->mutex);
 	snd_bebob_stream_update_duplex(bebob);
+	mutex_unlock(&bebob->mutex);
 
 	if (bebob->deferred_registration) {
 		if (snd_card_register(bebob->card) < 0) {
@@ -327,10 +330,6 @@ static void bebob_remove(struct fw_unit *unit)
 	if (bebob == NULL)
 		return;
 
-	/* Awake bus-reset waiters. */
-	if (!completion_done(&bebob->bus_reset))
-		complete_all(&bebob->bus_reset);
-
 	/* No need to wait for releasing card object in this context. */
 	snd_card_free_when_closed(bebob->card);
 }

commit 6b9866c893fc6a51e74df65fd9d9f851a3c2872e
Author: Julia Lawall <julia.lawall@lip6.fr>
Date:   Sun Oct 11 08:10:55 2015 +0200

    ALSA: bebob: constify various snd_bebob structures
    
    The structures of type snd_bebob_clock_spec, snd_bebob_rate_spec,
    snd_bebob_meter_spec, and snd_bebob_spec are never modified after they are
    initialized.  Make them all const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Tested-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 0ed5e5ff9346..091290d1f3ea 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -335,7 +335,7 @@ static void bebob_remove(struct fw_unit *unit)
 	snd_card_free_when_closed(bebob->card);
 }
 
-static struct snd_bebob_rate_spec normal_rate_spec = {
+static const struct snd_bebob_rate_spec normal_rate_spec = {
 	.get	= &snd_bebob_stream_get_rate,
 	.set	= &snd_bebob_stream_set_rate
 };

commit 425a570e1bfaeadaf6558df1e14e1735d5a76c10
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 4 09:17:03 2015 +0900

    ALSA: bebob: support Firewire I/O card of Mackie Onyx 1220/1620/1640
    
    Current ALSA BeBoB drivers has an entry for this model, while the value of
    vendor ID seems to be wrong according to an user's report.
    
    The vendor had released no updated firmware, thus we can judge that this
    model had not changed the content of its config ROM. It's reasonable to fix
    the ID according to the report.
    
    $ ./linux-firewire-utils/src/crpp < /sys/bus/firewire/devices/fw1/config_rom
    
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  0425720f  bus_info_length 4, crc_length 37, crc 29199
    404  31333934  bus_name "1394"
    408  f0646122  irmc 1, cmc 1, isc 1, bmc 1, pmc 0, cyc_clk_acc 100,
                   max_rec 6 (128), max_rom 1, gen 2, spd 2 (S400)
    40c  00000ff2  company_id 00000f     |
    410  00004697  device_id f200004697  | EUI-64 00000ff200004697
    
                   root directory
                   -----------------------------------------------------------------
    414  000859be  directory_length 8, crc 22974
    418  04000082  hardware version
    41c  0c0083c0  node capabilities per IEEE 1394
    420  03000ff2  vendor
    424  8100000a  --> descriptor leaf at 44c
    428  17010065  model
    42c  8100000d  --> descriptor leaf at 460
    430  13000910  version
    434  d1000001  --> unit directory at 438
    
                   unit directory at 438
                   -----------------------------------------------------------------
    438  0004ccec  directory_length 4, crc 52460
    43c  1200a02d  specifier id: 1394 TA
    440  13010001  version: AV/C
    444  17010065  model
    448  8100000d  --> descriptor leaf at 47c
    
                   descriptor leaf at 44c
                   -----------------------------------------------------------------
    44c  0004152a  leaf_length 4, crc 5418
    450  00000000  textual descriptor
    454  00000000  minimal ASCII
    458  4d61636b  "Mack"
    45c  69650000  "ie"
    
                   descriptor leaf at 460
                   -----------------------------------------------------------------
    460  000612b5  leaf_length 6, crc 4789
    464  00000000  textual descriptor
    468  00000000  minimal ASCII
    46c  4f6e7978  "Onyx"
    470  20466972  " Fir"
    474  65776972  "ewir"
    478  65000000  "e"
    
                   descriptor leaf at 47c
                   -----------------------------------------------------------------
    47c  000612b5  leaf_length 6, crc 4789
    480  00000000  textual descriptor
    484  00000000  minimal ASCII
    488  4f6e7978  "Onyx"
    48c  20466972  " Fir"
    490  65776972  "ewir"
    494  65000000  "e"
    
    $ cat /proc/asound/card3/firewire/firmware
    Manufacturer:   bridgeCo
    Protocol Ver:   1
    Build Ver:      0
    GUID:           0x00000FF200004697
    Model ID:       0x82
    Model Rev:      1
    Firmware Date:  20040430
    Firmware Time:  131527
    Firmware ID:    0x10065
    Firmware Ver:   2320
    Base Addr:      0x20080000
    Max Size:       1572864
    Loader Date:    20040430
    Loader Time:    112036
    
    Reported-by: Andrzej Gansiniec <andrzej@gansiniec.pl>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 27a04ac8ffee..0ed5e5ff9346 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -41,7 +41,8 @@ static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 #define VEN_EDIROL	0x000040ab
 #define VEN_PRESONUS	0x00000a92
 #define VEN_BRIDGECO	0x000007f5
-#define VEN_MACKIE	0x0000000f
+#define VEN_MACKIE1	0x0000000f
+#define VEN_MACKIE2	0x00000ff2
 #define VEN_STANTON	0x00001260
 #define VEN_TASCAM	0x0000022e
 #define VEN_BEHRINGER	0x00001564
@@ -360,9 +361,9 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	/* BridgeCo, Audio5 */
 	SND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010049, &spec_normal),
 	/* Mackie, Onyx 1220/1620/1640 (Firewire I/O Card) */
-	SND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010065, &spec_normal),
+	SND_BEBOB_DEV_ENTRY(VEN_MACKIE2, 0x00010065, &spec_normal),
 	/* Mackie, d.2 (Firewire Option) */
-	SND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010067, &spec_normal),
+	SND_BEBOB_DEV_ENTRY(VEN_MACKIE1, 0x00010067, &spec_normal),
 	/* Stanton, ScratchAmp */
 	SND_BEBOB_DEV_ENTRY(VEN_STANTON, 0x00000001, &spec_normal),
 	/* Tascam, IF-FW DM */

commit cf8a471909dd6a0df3efe2586cab5323184b4a7d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 14 12:49:37 2015 +0900

    ALSA: bebob: add support for Behringer FCA 610/1616
    
    They're based on DM1500 (ArchWave produced), and BeBoB version 3 is
    installed.
    
    $ cat /proc/asound/FCA610/firewire/firmware
    Manufacturer:   bridgeCo
    Protocol Ver:   3
    Build Ver:              0
    GUID:           0x001564000002AD73
    Model ID:               0x03
    Model Rev:              0
    Firmware Date:  20121102
    Firmware Time:  153431
    Firmware ID:    0x610
    Firmware Ver:   8348
    Base Addr:              0x400C0080
    Max Size:               1422624
    Loader Date:    20121015
    Loader Time:    104710
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 920571bc3c60..27a04ac8ffee 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -373,6 +373,10 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00001604, &spec_normal),
 	/* Behringer, Digital Mixer X32 series (X-UF Card) */
 	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00000006, &spec_normal),
+	/*  Behringer, F-Control Audio 1616 */
+	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x001616, &spec_normal),
+	/*  Behringer, F-Control Audio 610 */
+	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x000610, &spec_normal),
 	/* Apogee Electronics, Rosetta 200/400 (X-FireWire card) */
 	/* Apogee Electronics, DA/AD/DD-16X (X-FireWire card) */
 	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00010048, &spec_normal),
@@ -447,8 +451,6 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	/* IDs are unknown but able to be supported */
 	/*  Apogee, Mini-ME Firewire */
 	/*  Apogee, Mini-DAC Firewire */
-	/*  Behringer, F-Control Audio 1616 */
-	/*  Behringer, F-Control Audio 610 */
 	/*  Cakawalk, Sonar Power Studio 66 */
 	/*  CME, UF400e */
 	/*  ESI, Quotafire XL */

commit 7b4d7dcfa89e75f69547fbacfbf09a1d6c242a6b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 14 12:49:33 2015 +0900

    ALSA: bebob: add 'version' member for BeBoB protocol version
    
    BeBoB installed devices have BeBoB register area. This area stores
    basic information about its firmware. A register has its protocol
    version.
    
    This commit adds 'version' member and store the device's protocol
    version to handle v3 quirks in following commits.
    
    Tested-by: Kim Tore Jensen <kim@incendio.no>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index e71bd353f4e7..920571bc3c60 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -33,6 +33,7 @@ static DEFINE_MUTEX(devices_mutex);
 static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 
 /* Offsets from information register. */
+#define INFO_OFFSET_BEBOB_VERSION	0x08
 #define INFO_OFFSET_GUID		0x10
 #define INFO_OFFSET_HW_MODEL_ID		0x18
 #define INFO_OFFSET_HW_MODEL_REVISION	0x1c
@@ -73,6 +74,7 @@ name_device(struct snd_bebob *bebob, unsigned int vendor_id)
 	u32 hw_id;
 	u32 data[2] = {0};
 	u32 revision;
+	u32 version;
 	int err;
 
 	/* get vendor name from root directory */
@@ -105,6 +107,12 @@ name_device(struct snd_bebob *bebob, unsigned int vendor_id)
 	if (err < 0)
 		goto end;
 
+	err = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_BEBOB_VERSION,
+				  &version);
+	if (err < 0)
+		goto end;
+	bebob->version = version;
+
 	strcpy(bebob->card->driver, "BeBoB");
 	strcpy(bebob->card->shortname, model);
 	strcpy(bebob->card->mixername, model);

commit 146a5e3c1ef999f1b1ec841fd86db421f4ca8d6a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun May 24 20:51:45 2015 +0900

    ALSA: bebob: add Digidesign Mbox 2 Pro support
    
    This device is based on DM1000E, and BeBoB version 1 firmware is
    installed.
    
    $ cat /proc/asound/cards
     0 [Pro            ]: BeBoB - Mbox 2 Pro
                          DIGIDESIGN Mbox 2 Pro (id:1, rev:1),
                          GUID 00a07e0100a90000 at fw1.0, S400
    
    $ cat /proc/asound/Pro/firewire/firmware
    Manufacturer:   bridgeCo
    Protocol Ver:   1
    Build Ver:              0
    GUID:           0x00A07E0100A90000
    Model ID:               0x01
    Model Rev:              1
    Firmware Date:  20071031
    Firmware Time:  034402
    Firmware ID:    0xA9
    Firmware Ver:   16777215
    Base Addr:              0x20080000
    Max Size:               1572864
    Loader Date:    20051207
    Loader Time:    205554
    
    With this patch, ALSA BeBoB driver can start packet streaming to/from
    this model, while as a default, internal multiplexer of this model is
    not initialized and generates no sound even if the driver transfers
    any packets with PCM samples. To hear any sounds from this model,
    userspace applications should be developed to set parameters to the
    internal multiplexer. You can see raw information in FFADO website:
    http://subversion.ffado.org/wiki/AvcModels/DigiDesignMboxPro2
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 611b7dae7ee5..e71bd353f4e7 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -57,6 +57,7 @@ static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 #define VEN_FOCUSRITE	0x0000130e
 #define VEN_MAUDIO1	0x00000d6c
 #define VEN_MAUDIO2	0x000007f5
+#define VEN_DIGIDESIGN	0x00a07e
 
 #define MODEL_FOCUSRITE_SAFFIRE_BOTH	0x00000000
 #define MODEL_MAUDIO_AUDIOPHILE_BOTH	0x00010060
@@ -433,6 +434,8 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	/* M-Audio ProjectMix */
 	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, MODEL_MAUDIO_PROJECTMIX,
 			    &maudio_special_spec),
+	/* Digidesign Mbox 2 Pro */
+	SND_BEBOB_DEV_ENTRY(VEN_DIGIDESIGN, 0x0000a9, &spec_normal),
 	/* IDs are unknown but able to be supported */
 	/*  Apogee, Mini-ME Firewire */
 	/*  Apogee, Mini-DAC Firewire */

commit dec84316dd53c90e93b4ee849483bd4bd1e9a585
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 21 23:55:00 2015 +0900

    ALSA: fireworks/bebob/dice/oxfw: make it possible to shutdown safely
    
    A part of these drivers, especially BeBoB driver, are programmed to wait
    some events. Thus the drivers should not destroy any data in .remove()
    context.
    
    This commit moves some destructors from 'struct fw_driver.remove()' to
    'struct snd_card.private_free()' to shutdown safely.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index b612599fb543..611b7dae7ee5 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -127,8 +127,11 @@ bebob_card_free(struct snd_card *card)
 {
 	struct snd_bebob *bebob = card->private_data;
 
+	snd_bebob_stream_destroy_duplex(bebob);
 	fw_unit_put(bebob->unit);
 
+	kfree(bebob->maudio_special_quirk);
+
 	if (bebob->card_index >= 0) {
 		mutex_lock(&devices_mutex);
 		clear_bit(bebob->card_index, devices_used);
@@ -314,10 +317,9 @@ static void bebob_remove(struct fw_unit *unit)
 	if (bebob == NULL)
 		return;
 
-	kfree(bebob->maudio_special_quirk);
-
-	snd_bebob_stream_destroy_duplex(bebob);
-	snd_card_disconnect(bebob->card);
+	/* Awake bus-reset waiters. */
+	if (!completion_done(&bebob->bus_reset))
+		complete_all(&bebob->bus_reset);
 
 	/* No need to wait for releasing card object in this context. */
 	snd_card_free_when_closed(bebob->card);

commit 12ed719291a953d443921f9cdb0ffee41066c340
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 21 23:54:57 2015 +0900

    ALSA: fireworks/bebob/dice/oxfw: add reference-counting for FireWire unit
    
    Fireworks and Dice drivers try to touch instances of FireWire unit after
    sound card object is released, while references to the unit is decremented
    in .remove(). When unplugging during streaming, sound card object is
    released after .remove(), thus Fireworks and Dice drivers causes GPF or
    Null-pointer-dereferencing to application processes because an instance of
    FireWire unit was already released.
    
    This commit adds reference-counting for FireWire unit in drivers to allow
    them to touch an instance of FireWire unit after .remove(). In most case,
    any operations after .remove() may be failed safely.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index fc19c99654aa..b612599fb543 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -116,11 +116,19 @@ name_device(struct snd_bebob *bebob, unsigned int vendor_id)
 	return err;
 }
 
+/*
+ * This module releases the FireWire unit data after all ALSA character devices
+ * are released by applications. This is for releasing stream data or finishing
+ * transactions safely. Thus at returning from .remove(), this module still keep
+ * references for the unit.
+ */
 static void
 bebob_card_free(struct snd_card *card)
 {
 	struct snd_bebob *bebob = card->private_data;
 
+	fw_unit_put(bebob->unit);
+
 	if (bebob->card_index >= 0) {
 		mutex_lock(&devices_mutex);
 		clear_bit(bebob->card_index, devices_used);
@@ -205,7 +213,7 @@ bebob_probe(struct fw_unit *unit,
 	card->private_free = bebob_card_free;
 
 	bebob->card = card;
-	bebob->unit = unit;
+	bebob->unit = fw_unit_get(unit);
 	bebob->spec = spec;
 	mutex_init(&bebob->mutex);
 	spin_lock_init(&bebob->lock);
@@ -310,6 +318,8 @@ static void bebob_remove(struct fw_unit *unit)
 
 	snd_bebob_stream_destroy_duplex(bebob);
 	snd_card_disconnect(bebob->card);
+
+	/* No need to wait for releasing card object in this context. */
 	snd_card_free_when_closed(bebob->card);
 }
 

commit 7862126a4f0604610bf0159145447c76f67f3db8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 28 00:14:46 2014 +0900

    ALSA: bebob: Remove meaningless mutex_unlock()
    
    Currently mutex_unlock() is called in module's cleanup function. But after
    cleaned up, this mutex is automatically released. So this function call
    is meaningless.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 0e9d625128cf..fc19c99654aa 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -465,7 +465,6 @@ static void __exit
 snd_bebob_exit(void)
 {
 	driver_unregister(&bebob_driver.driver);
-	mutex_destroy(&devices_mutex);
 }
 
 module_init(snd_bebob_init);

commit 9fb01cdb38e0a72f40befdeba68ce7022468b7c8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 28 00:14:45 2014 +0900

    ALSA: bebob: Add static specifier to identifier with file scope
    
    Some variables were declared without static even if they're not referred
    to from external files. This commit make them local symbols for better
    information-hiding by file unit.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index b5e8f99c15a5..0e9d625128cf 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -313,7 +313,7 @@ static void bebob_remove(struct fw_unit *unit)
 	snd_card_free_when_closed(bebob->card);
 }
 
-struct snd_bebob_rate_spec normal_rate_spec = {
+static struct snd_bebob_rate_spec normal_rate_spec = {
 	.get	= &snd_bebob_stream_get_rate,
 	.set	= &snd_bebob_stream_set_rate
 };

commit 791c67b427dfebfd930228ce33a42e70d6d7a7d3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 28 00:14:44 2014 +0900

    ALSA: bebob: Use different names for identifiers in the same file
    
    To suppress 'sparse' warning.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 31b96b7264cf..b5e8f99c15a5 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -69,7 +69,7 @@ name_device(struct snd_bebob *bebob, unsigned int vendor_id)
 	struct fw_device *fw_dev = fw_parent_device(bebob->unit);
 	char vendor[24] = {0};
 	char model[32] = {0};
-	u32 id;
+	u32 hw_id;
 	u32 data[2] = {0};
 	u32 revision;
 	int err;
@@ -88,7 +88,7 @@ name_device(struct snd_bebob *bebob, unsigned int vendor_id)
 
 	/* get hardware id */
 	err = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_HW_MODEL_ID,
-				  &id);
+				  &hw_id);
 	if (err < 0)
 		goto end;
 
@@ -109,7 +109,7 @@ name_device(struct snd_bebob *bebob, unsigned int vendor_id)
 	strcpy(bebob->card->mixername, model);
 	snprintf(bebob->card->longname, sizeof(bebob->card->longname),
 		 "%s %s (id:%d, rev:%d), GUID %08x%08x at %s, S%d",
-		 vendor, model, id, revision,
+		 vendor, model, hw_id, revision,
 		 data[0], data[1], dev_name(&bebob->unit->device),
 		 100 << fw_dev->max_speed);
 end:

commit 9b1ee0b2cb8bffdbb3003b1d5205f3ae0592c15a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:30 2014 +0900

    ALSA: firewire/bebob: Add a workaround for M-Audio special Firewire series
    
    In post commit, a quirk of this firmware about transactions is reported.
    This commit apply a workaround for this quirk.
    
    They often fail transactions due to gap_count mismatch. This state is changed
    by generating bus reset.
    
    The fw_schedule_bus_reset() is an exported symbol in firewire-core. But there
    are no header for public. This commit moves its prototype from
    drivers/firewire/core.h to include/linux/firewire.h.
    
    This mismatch still affects bus management before generating this bus reset.
    It still takes a time to call driver's probe() because transactions are still
    often failed.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index e1dd4219ea6c..31b96b7264cf 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -247,10 +247,26 @@ bebob_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_card_register(card);
-	if (err < 0) {
-		snd_bebob_stream_destroy_duplex(bebob);
-		goto error;
+	if (!bebob->maudio_special_quirk) {
+		err = snd_card_register(card);
+		if (err < 0) {
+			snd_bebob_stream_destroy_duplex(bebob);
+			goto error;
+		}
+	} else {
+		/*
+		 * This is a workaround. This bus reset seems to have an effect
+		 * to make devices correctly handling transactions. Without
+		 * this, the devices have gap_count mismatch. This causes much
+		 * failure of transaction.
+		 *
+		 * Just after registration, user-land application receive
+		 * signals from dbus and starts I/Os. To avoid I/Os till the
+		 * future bus reset, registration is done in next update().
+		 */
+		bebob->deferred_registration = true;
+		fw_schedule_bus_reset(fw_parent_device(bebob->unit)->card,
+				      false, true);
 	}
 
 	dev_set_drvdata(&unit->device, bebob);
@@ -273,6 +289,14 @@ bebob_update(struct fw_unit *unit)
 
 	fcp_bus_reset(bebob->unit);
 	snd_bebob_stream_update_duplex(bebob);
+
+	if (bebob->deferred_registration) {
+		if (snd_card_register(bebob->card) < 0) {
+			snd_bebob_stream_destroy_duplex(bebob);
+			snd_card_free(bebob->card);
+		}
+		bebob->deferred_registration = false;
+	}
 }
 
 static void bebob_remove(struct fw_unit *unit)

commit a2b2a7798fb6a5c639189e5c8f608a56fdc7a222
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:29 2014 +0900

    ALSA: bebob: Send a cue to load firmware for M-Audio Firewire series
    
    Just powering on, these devices below wait to download firmware.
     - Firewire Audiophile
     - Firewire 410
     - Firewire 1814
     - ProjectMix I/O
    
    But firmware version 5058 or later, flash memory in the device stores the
    firmware. So this driver can enable these devices by sending a certain cue to
    load the firmware.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index ffb042b1f19f..e1dd4219ea6c 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -177,18 +177,21 @@ bebob_probe(struct fw_unit *unit,
 	}
 
 	if ((entry->vendor_id == VEN_FOCUSRITE) &&
-	    (entry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH)) {
+	    (entry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH))
 		spec = get_saffire_spec(unit);
-	} else if ((entry->vendor_id == VEN_MAUDIO1) &&
-		   (entry->model_id == MODEL_MAUDIO_AUDIOPHILE_BOTH) &&
-		   !check_audiophile_booted(unit)) {
-			err = 0;
-			goto end;
-	} else {
+	else if ((entry->vendor_id == VEN_MAUDIO1) &&
+		 (entry->model_id == MODEL_MAUDIO_AUDIOPHILE_BOTH) &&
+		 !check_audiophile_booted(unit))
+		spec = NULL;
+	else
 		spec = (const struct snd_bebob_spec *)entry->driver_data;
-	}
+
 	if (spec == NULL) {
-		err = -ENOSYS;
+		if ((entry->vendor_id == VEN_MAUDIO1) ||
+		    (entry->vendor_id == VEN_MAUDIO2))
+			err = snd_bebob_maudio_load_firmware(unit);
+		else
+			err = -ENOSYS;
 		goto end;
 	}
 
@@ -374,6 +377,7 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	SND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, MODEL_FOCUSRITE_SAFFIRE_BOTH,
 			    &saffire_spec),
 	/* M-Audio, Firewire 410 */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO2, 0x00010058, NULL),	/* bootloader */
 	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO2, 0x00010046, &maudio_fw410_spec),
 	/* M-Audio, Firewire Audiophile */
 	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, MODEL_MAUDIO_AUDIOPHILE_BOTH,
@@ -387,6 +391,7 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	/* M-Audio, ProFireLightbridge */
 	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, 0x000100a1, &spec_normal),
 	/* Firewire 1814 */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, 0x00010070, NULL),	/* bootloader */
 	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, MODEL_MAUDIO_FW1814,
 			    &maudio_special_spec),
 	/* M-Audio ProjectMix */

commit 3149ac489ff8dea0c305c7f97ac2a1b4ad54f5be
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:26 2014 +0900

    ALSA: bebob: Add support for M-Audio special Firewire series
    
    This commit allows this driver to support some models which M-Audio produces
    with DM1000 but its firmware is special. They are:
     - Firewire 1814
     - ProjectMix I/O
    
    They have heavily customized firmware. The usual operations can't be applied to
    them. For this reason, this commit adds a model specific member to 'struct
    snd_bebob' and some model specific functions. Some parameters are write-only so
    this commit also adds control interface for applications to set them.
    
    M-Audio special firmware quirks:
     - Just after powering on, they wait to download firmware. This state is
       changed when receiving cue. Then bus reset is generated and the device is
       recognized as a different model with the uploaded firmware.
     - They don't respond against BridgeCo AV/C extension commands. So drivers
       can't get their stream formations and so on.
     - They do not start to transmit packets only by establishing connection but
       also by receiving SIGNAL FORMAT command.
     - After booting up, they often fail to send response against driver's request
       due to mismatch of gap_count.
    
    This module don't support to upload firmware.
    
    Tested-by: Darren Anderson <darrena092@gmail.com> (ProjectMix I/O)
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 9bf9149194df..ffb042b1f19f 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -60,6 +60,8 @@ static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 
 #define MODEL_FOCUSRITE_SAFFIRE_BOTH	0x00000000
 #define MODEL_MAUDIO_AUDIOPHILE_BOTH	0x00010060
+#define MODEL_MAUDIO_FW1814		0x00010071
+#define MODEL_MAUDIO_PROJECTMIX		0x00010091
 
 static int
 name_device(struct snd_bebob *bebob, unsigned int vendor_id)
@@ -210,7 +212,14 @@ bebob_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_bebob_stream_discover(bebob);
+	if ((entry->vendor_id == VEN_MAUDIO1) &&
+	    (entry->model_id == MODEL_MAUDIO_FW1814))
+		err = snd_bebob_maudio_special_discover(bebob, true);
+	else if ((entry->vendor_id == VEN_MAUDIO1) &&
+		 (entry->model_id == MODEL_MAUDIO_PROJECTMIX))
+		err = snd_bebob_maudio_special_discover(bebob, false);
+	else
+		err = snd_bebob_stream_discover(bebob);
 	if (err < 0)
 		goto error;
 
@@ -270,6 +279,8 @@ static void bebob_remove(struct fw_unit *unit)
 	if (bebob == NULL)
 		return;
 
+	kfree(bebob->maudio_special_quirk);
+
 	snd_bebob_stream_destroy_duplex(bebob);
 	snd_card_disconnect(bebob->card);
 	snd_card_free_when_closed(bebob->card);
@@ -375,6 +386,12 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, 0x00010081, &maudio_nrv10_spec),
 	/* M-Audio, ProFireLightbridge */
 	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, 0x000100a1, &spec_normal),
+	/* Firewire 1814 */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, MODEL_MAUDIO_FW1814,
+			    &maudio_special_spec),
+	/* M-Audio ProjectMix */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, MODEL_MAUDIO_PROJECTMIX,
+			    &maudio_special_spec),
 	/* IDs are unknown but able to be supported */
 	/*  Apogee, Mini-ME Firewire */
 	/*  Apogee, Mini-DAC Firewire */

commit 9076c22ddd9d29a30426f0367dec2b40e12536de
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:25 2014 +0900

    ALSA: bebob: Add support for M-Audio usual Firewire series
    
    This commit allows this driver to support some models which M-Audio produces
    with DM1000/DM1000E with usual firmware. They are:
     - Firewire 410
     - Firewire AudioPhile
     - Firewire Solo
     - Ozonic
     - NRV10
     - FirewireLightBridge
    
    According to a person who worked in BridgeCo, some models are produced with
    'Pre-BeBoB'. This means that these products were released before BeBoB was
    officially produced, and later BeBoB specification was formed. So these models
    have some quirks.
    
    M-Audio usual firmware quirks:
     - Just after powering on, 'Firewire 410' waits to download firmware. This
       state is changed when receiving cue. Then bus reset is generated and the
       device is recognized as a different model with the uploaded firmware.
     - 'Firewire Audiophile' also waits to download firmware but its
       vendor id/model id is the same as the one after loading firmware.
     - The information of channel mapping for MIDI conformant data channel is
       invalid against BridgeCo specification.
    
    This commit adds some codes for these quirks but don't support to upload
    firmware.
    
    This commit also adds specific operations to get metering information. The
    metering information also includes status of clock synchronization if the model
    supports to switch source of clock.
    
    The specification of FirewireLightBridge is unknown. So in this time, normal
    operations are applied for this model.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 6d23e44e635b..9bf9149194df 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -55,8 +55,11 @@ static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 #define VEN_TERRATEC	0x00000aac
 #define VEN_YAMAHA	0x0000a0de
 #define VEN_FOCUSRITE	0x0000130e
+#define VEN_MAUDIO1	0x00000d6c
+#define VEN_MAUDIO2	0x000007f5
 
 #define MODEL_FOCUSRITE_SAFFIRE_BOTH	0x00000000
+#define MODEL_MAUDIO_AUDIOPHILE_BOTH	0x00010060
 
 static int
 name_device(struct snd_bebob *bebob, unsigned int vendor_id)
@@ -139,6 +142,17 @@ get_saffire_spec(struct fw_unit *unit)
 		return &saffire_spec;
 }
 
+static bool
+check_audiophile_booted(struct fw_unit *unit)
+{
+	char name[24] = {0};
+
+	if (fw_csr_string(unit->directory, CSR_MODEL, name, sizeof(name)) < 0)
+		return false;
+
+	return strncmp(name, "FW Audiophile Bootloader", 15) != 0;
+}
+
 static int
 bebob_probe(struct fw_unit *unit,
 	    const struct ieee1394_device_id *entry)
@@ -161,10 +175,16 @@ bebob_probe(struct fw_unit *unit,
 	}
 
 	if ((entry->vendor_id == VEN_FOCUSRITE) &&
-	    (entry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH))
+	    (entry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH)) {
 		spec = get_saffire_spec(unit);
-	else
+	} else if ((entry->vendor_id == VEN_MAUDIO1) &&
+		   (entry->model_id == MODEL_MAUDIO_AUDIOPHILE_BOTH) &&
+		   !check_audiophile_booted(unit)) {
+			err = 0;
+			goto end;
+	} else {
 		spec = (const struct snd_bebob_spec *)entry->driver_data;
+	}
 	if (spec == NULL) {
 		err = -ENOSYS;
 		goto end;
@@ -235,6 +255,10 @@ static void
 bebob_update(struct fw_unit *unit)
 {
 	struct snd_bebob *bebob = dev_get_drvdata(&unit->device);
+
+	if (bebob == NULL)
+		return;
+
 	fcp_bus_reset(bebob->unit);
 	snd_bebob_stream_update_duplex(bebob);
 }
@@ -242,6 +266,10 @@ bebob_update(struct fw_unit *unit)
 static void bebob_remove(struct fw_unit *unit)
 {
 	struct snd_bebob *bebob = dev_get_drvdata(&unit->device);
+
+	if (bebob == NULL)
+		return;
+
 	snd_bebob_stream_destroy_duplex(bebob);
 	snd_card_disconnect(bebob->card);
 	snd_card_free_when_closed(bebob->card);
@@ -334,6 +362,19 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	/* Focusrite, Saffire(no label and LE) */
 	SND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, MODEL_FOCUSRITE_SAFFIRE_BOTH,
 			    &saffire_spec),
+	/* M-Audio, Firewire 410 */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO2, 0x00010046, &maudio_fw410_spec),
+	/* M-Audio, Firewire Audiophile */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, MODEL_MAUDIO_AUDIOPHILE_BOTH,
+			    &maudio_audiophile_spec),
+	/* M-Audio, Firewire Solo */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, 0x00010062, &maudio_solo_spec),
+	/* M-Audio, Ozonic */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, 0x0000000a, &maudio_ozonic_spec),
+	/* M-Audio NRV10 */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, 0x00010081, &maudio_nrv10_spec),
+	/* M-Audio, ProFireLightbridge */
+	SND_BEBOB_DEV_ENTRY(VEN_MAUDIO1, 0x000100a1, &spec_normal),
 	/* IDs are unknown but able to be supported */
 	/*  Apogee, Mini-ME Firewire */
 	/*  Apogee, Mini-DAC Firewire */

commit 25784ec2d0347b715e354d92151734afe1296f02
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:24 2014 +0900

    ALSA: bebob: Add support for Focusrite Saffire/SaffirePro series
    
    This commit allows this driver to support all of models which Focusrite
    produces with DM1000/BeBoB. They are:
     - Saffire
     - Saffire LE
     - SaffirePro 10 I/O
     - SaffirePro 26 I/O
    
    This commit adds Focusrite specific operations:
    1. Get source of clock
    2. Get/Set sampling frequency
    3. Get metering information
    
    The driver uses these functionalities to read/write specific address by async
    transaction.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 6a6350466fd4..6d23e44e635b 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -54,6 +54,9 @@ static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 #define VEN_PRISMSOUND	0x00001198
 #define VEN_TERRATEC	0x00000aac
 #define VEN_YAMAHA	0x0000a0de
+#define VEN_FOCUSRITE	0x0000130e
+
+#define MODEL_FOCUSRITE_SAFFIRE_BOTH	0x00000000
 
 static int
 name_device(struct snd_bebob *bebob, unsigned int vendor_id)
@@ -122,6 +125,20 @@ bebob_card_free(struct snd_card *card)
 	mutex_destroy(&bebob->mutex);
 }
 
+static const struct snd_bebob_spec *
+get_saffire_spec(struct fw_unit *unit)
+{
+	char name[24] = {0};
+
+	if (fw_csr_string(unit->directory, CSR_MODEL, name, sizeof(name)) < 0)
+		return NULL;
+
+	if (strcmp(name, "SaffireLE") == 0)
+		return &saffire_le_spec;
+	else
+		return &saffire_spec;
+}
+
 static int
 bebob_probe(struct fw_unit *unit,
 	    const struct ieee1394_device_id *entry)
@@ -143,7 +160,11 @@ bebob_probe(struct fw_unit *unit,
 		goto end;
 	}
 
-	spec = (const struct snd_bebob_spec *)entry->driver_data;
+	if ((entry->vendor_id == VEN_FOCUSRITE) &&
+	    (entry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH))
+		spec = get_saffire_spec(unit);
+	else
+		spec = (const struct snd_bebob_spec *)entry->driver_data;
 	if (spec == NULL) {
 		err = -ENOSYS;
 		goto end;
@@ -306,6 +327,13 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	SND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000b, &yamaha_go_spec),
 	/* YAMAHA, GO46 */
 	SND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000c, &yamaha_go_spec),
+	/* Focusrite, SaffirePro 26 I/O */
+	SND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, 0x00000003, &saffirepro_26_spec),
+	/* Focusrite, SaffirePro 10 I/O */
+	SND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, 0x00000006, &saffirepro_10_spec),
+	/* Focusrite, Saffire(no label and LE) */
+	SND_BEBOB_DEV_ENTRY(VEN_FOCUSRITE, MODEL_FOCUSRITE_SAFFIRE_BOTH,
+			    &saffire_spec),
 	/* IDs are unknown but able to be supported */
 	/*  Apogee, Mini-ME Firewire */
 	/*  Apogee, Mini-DAC Firewire */

commit 8ac98a3585ee7ad0c1bd03b098784a10e13bee21
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:23 2014 +0900

    ALSA: bebob: Add support for Yamaha GO series
    
    This commit allows this driver to support all of models which Yamaha produced
    with DM1000/BeBoB. They are:
     - GO44
     - GO46
    
    This commit adds Yamaha specific operations. To get source of clock, AV/C Audio
    Subunit command is used.
    
    I note that their appearances are similar to some models of TerraTec; 'Go44' is
    similar to 'PHASE 24 FW' and 'GO46' is similar to 'PHASE X24 FW'. But their
    combination of Audio/Music subunits is a bit different.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 262677ef30f1..6a6350466fd4 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -53,6 +53,7 @@ static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 #define VEN_ICON	0x00001a9e
 #define VEN_PRISMSOUND	0x00001198
 #define VEN_TERRATEC	0x00000aac
+#define VEN_YAMAHA	0x0000a0de
 
 static int
 name_device(struct snd_bebob *bebob, unsigned int vendor_id)
@@ -301,6 +302,10 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000005, &spec_normal),
 	/* Terratec Electronic GmbH, Aureon 7.1 Firewire */
 	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000002, &spec_normal),
+	/* Yamaha, GO44 */
+	SND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000b, &yamaha_go_spec),
+	/* YAMAHA, GO46 */
+	SND_BEBOB_DEV_ENTRY(VEN_YAMAHA, 0x0010000c, &yamaha_go_spec),
 	/* IDs are unknown but able to be supported */
 	/*  Apogee, Mini-ME Firewire */
 	/*  Apogee, Mini-DAC Firewire */

commit 326b9cacf4932588156a920d67aab8b7b69d7a40
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:22 2014 +0900

    ALSA: bebob: Add support for Terratec PHASE, EWS series and Aureon
    
    This commit allows this driver to support all of models which Terratec produced
    with DM1000/BeBoB. They are:
     - PHASE 24 FW
     - PHASE X24 FW
     - PHASE 88 Rack FW
     - EWS MIC2
     - EWS MIC4
     - Aureon 7.1 Firewire
    
    For Phase series, this commit adds a Terratec specific operation. To get source
    of clock. AV/C Audio Subunit command is used.
    
    For EWS series and Aureon, this module uses normal operations.
    
    Tested-by: Maximilian Engelhardt <maxi@daemonizer.de> (PHASE 24 FW)
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 3d7909036a3c..262677ef30f1 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -52,6 +52,7 @@ static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
 #define VEN_LYNX	0x000019e5
 #define VEN_ICON	0x00001a9e
 #define VEN_PRISMSOUND	0x00001198
+#define VEN_TERRATEC	0x00000aac
 
 static int
 name_device(struct snd_bebob *bebob, unsigned int vendor_id)
@@ -290,6 +291,16 @@ static const struct ieee1394_device_id bebob_id_table[] = {
 	SND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x00010048, &spec_normal),
 	/* PrismSound, ADA-8XR */
 	SND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x0000ada8, &spec_normal),
+	/* TerraTec Electronic GmbH, PHASE 88 Rack FW */
+	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000003, &phase88_rack_spec),
+	/* TerraTec Electronic GmbH, PHASE 24 FW */
+	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000004, &phase24_series_spec),
+	/* TerraTec Electronic GmbH, Phase X24 FW */
+	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000007, &phase24_series_spec),
+	/* TerraTec Electronic GmbH, EWS MIC2/MIC8 */
+	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000005, &spec_normal),
+	/* Terratec Electronic GmbH, Aureon 7.1 Firewire */
+	SND_BEBOB_DEV_ENTRY(VEN_TERRATEC, 0x00000002, &spec_normal),
 	/* IDs are unknown but able to be supported */
 	/*  Apogee, Mini-ME Firewire */
 	/*  Apogee, Mini-DAC Firewire */

commit 1fc9522a084f36d042298ef15893cf07d66a54bc
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:21 2014 +0900

    ALSA: bebob: Prepare for device specific operations
    
    This commit is for some devices which have its own operations or quirks.
    
    Many functionality should be implemented in user land. Then this commit adds
    functionality related to stream such as sampling frequency or clock source. For
    help to debug, this commit adds the functionality to get metering information
    if it's available.
    
    To help these functionalities, this commit adds some AV/C commands defined in
    'AV/C Audio Subunit Specification (1394TA).
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index b7d70c2e4e87..3d7909036a3c 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -126,6 +126,7 @@ bebob_probe(struct fw_unit *unit,
 {
 	struct snd_card *card;
 	struct snd_bebob *bebob;
+	const struct snd_bebob_spec *spec;
 	unsigned int card_index;
 	int err;
 
@@ -140,6 +141,12 @@ bebob_probe(struct fw_unit *unit,
 		goto end;
 	}
 
+	spec = (const struct snd_bebob_spec *)entry->driver_data;
+	if (spec == NULL) {
+		err = -ENOSYS;
+		goto end;
+	}
+
 	err = snd_card_new(&unit->device, index[card_index], id[card_index],
 			   THIS_MODULE, sizeof(struct snd_bebob), &card);
 	if (err < 0)
@@ -151,6 +158,7 @@ bebob_probe(struct fw_unit *unit,
 
 	bebob->card = card;
 	bebob->unit = unit;
+	bebob->spec = spec;
 	mutex_init(&bebob->mutex);
 	spin_lock_init(&bebob->lock);
 	init_waitqueue_head(&bebob->hwdep_wait);
@@ -216,62 +224,72 @@ static void bebob_remove(struct fw_unit *unit)
 	snd_card_free_when_closed(bebob->card);
 }
 
+struct snd_bebob_rate_spec normal_rate_spec = {
+	.get	= &snd_bebob_stream_get_rate,
+	.set	= &snd_bebob_stream_set_rate
+};
+static const struct snd_bebob_spec spec_normal = {
+	.clock	= NULL,
+	.rate	= &normal_rate_spec,
+	.meter	= NULL
+};
+
 static const struct ieee1394_device_id bebob_id_table[] = {
 	/* Edirol, FA-66 */
-	SND_BEBOB_DEV_ENTRY(VEN_EDIROL, 0x00010049),
+	SND_BEBOB_DEV_ENTRY(VEN_EDIROL, 0x00010049, &spec_normal),
 	/* Edirol, FA-101 */
-	SND_BEBOB_DEV_ENTRY(VEN_EDIROL, 0x00010048),
+	SND_BEBOB_DEV_ENTRY(VEN_EDIROL, 0x00010048, &spec_normal),
 	/* Presonus, FIREBOX */
-	SND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010000),
+	SND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010000, &spec_normal),
 	/* PreSonus, FIREPOD/FP10 */
-	SND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010066),
+	SND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010066, &spec_normal),
 	/* PreSonus, Inspire1394 */
-	SND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010001),
+	SND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010001, &spec_normal),
 	/* BridgeCo, RDAudio1 */
-	SND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010048),
+	SND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010048, &spec_normal),
 	/* BridgeCo, Audio5 */
-	SND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010049),
+	SND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010049, &spec_normal),
 	/* Mackie, Onyx 1220/1620/1640 (Firewire I/O Card) */
-	SND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010065),
+	SND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010065, &spec_normal),
 	/* Mackie, d.2 (Firewire Option) */
-	SND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010067),
+	SND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010067, &spec_normal),
 	/* Stanton, ScratchAmp */
-	SND_BEBOB_DEV_ENTRY(VEN_STANTON, 0x00000001),
+	SND_BEBOB_DEV_ENTRY(VEN_STANTON, 0x00000001, &spec_normal),
 	/* Tascam, IF-FW DM */
-	SND_BEBOB_DEV_ENTRY(VEN_TASCAM, 0x00010067),
+	SND_BEBOB_DEV_ENTRY(VEN_TASCAM, 0x00010067, &spec_normal),
 	/* Behringer, XENIX UFX 1204 */
-	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00001204),
+	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00001204, &spec_normal),
 	/* Behringer, XENIX UFX 1604 */
-	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00001604),
+	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00001604, &spec_normal),
 	/* Behringer, Digital Mixer X32 series (X-UF Card) */
-	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00000006),
+	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00000006, &spec_normal),
 	/* Apogee Electronics, Rosetta 200/400 (X-FireWire card) */
 	/* Apogee Electronics, DA/AD/DD-16X (X-FireWire card) */
-	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00010048),
+	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00010048, &spec_normal),
 	/* Apogee Electronics, Ensemble */
-	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00001eee),
+	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00001eee, &spec_normal),
 	/* ESI, Quatafire610 */
-	SND_BEBOB_DEV_ENTRY(VEN_ESI, 0x00010064),
+	SND_BEBOB_DEV_ENTRY(VEN_ESI, 0x00010064, &spec_normal),
 	/* AcousticReality, eARMasterOne */
-	SND_BEBOB_DEV_ENTRY(VEN_ACOUSTIC, 0x00000002),
+	SND_BEBOB_DEV_ENTRY(VEN_ACOUSTIC, 0x00000002, &spec_normal),
 	/* CME, MatrixKFW */
-	SND_BEBOB_DEV_ENTRY(VEN_CME, 0x00030000),
+	SND_BEBOB_DEV_ENTRY(VEN_CME, 0x00030000, &spec_normal),
 	/* Phonic, Helix Board 12 MkII */
-	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00050000),
+	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00050000, &spec_normal),
 	/* Phonic, Helix Board 18 MkII */
-	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00060000),
+	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00060000, &spec_normal),
 	/* Phonic, Helix Board 24 MkII */
-	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00070000),
+	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00070000, &spec_normal),
 	/* Phonic, Helix Board 12 Universal/18 Universal/24 Universal */
-	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00000000),
+	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00000000, &spec_normal),
 	/* Lynx, Aurora 8/16 (LT-FW) */
-	SND_BEBOB_DEV_ENTRY(VEN_LYNX, 0x00000001),
+	SND_BEBOB_DEV_ENTRY(VEN_LYNX, 0x00000001, &spec_normal),
 	/* ICON, FireXon */
-	SND_BEBOB_DEV_ENTRY(VEN_ICON, 0x00000001),
+	SND_BEBOB_DEV_ENTRY(VEN_ICON, 0x00000001, &spec_normal),
 	/* PrismSound, Orpheus */
-	SND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x00010048),
+	SND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x00010048, &spec_normal),
 	/* PrismSound, ADA-8XR */
-	SND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x0000ada8),
+	SND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x0000ada8, &spec_normal),
 	/* IDs are unknown but able to be supported */
 	/*  Apogee, Mini-ME Firewire */
 	/*  Apogee, Mini-DAC Firewire */

commit 618eabeae711c56d376daa147c6a684116d68705
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:20 2014 +0900

    ALSA: bebob: Add hwdep interface
    
    This interface is designed for mixer/control application. By using hwdep
    interface, the application can get information about firewire node, can
    lock/unlock kernel streaming and can get notification at starting/stopping
    kernel streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index dbd12c360046..b7d70c2e4e87 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -153,6 +153,7 @@ bebob_probe(struct fw_unit *unit,
 	bebob->unit = unit;
 	mutex_init(&bebob->mutex);
 	spin_lock_init(&bebob->lock);
+	init_waitqueue_head(&bebob->hwdep_wait);
 
 	err = name_device(bebob, entry->vendor_id);
 	if (err < 0)
@@ -175,6 +176,10 @@ bebob_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_bebob_create_hwdep_device(bebob);
+	if (err < 0)
+		goto error;
+
 	err = snd_bebob_stream_init_duplex(bebob);
 	if (err < 0)
 		goto error;

commit fbbebd2c40795e87f1280ca4d963f7cbe1c83168
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:19 2014 +0900

    ALSA: bebob: Add PCM interface
    
    This commit adds a functionality to capture/playback PCM samples.
    
    When AMDTP stream is already running for PCM or the source of clock is not
    internal, available sampling rate is limited at current one.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 383df9a22004..dbd12c360046 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -171,6 +171,10 @@ bebob_probe(struct fw_unit *unit,
 			goto error;
 	}
 
+	err = snd_bebob_create_pcm_devices(bebob);
+	if (err < 0)
+		goto error;
+
 	err = snd_bebob_stream_init_duplex(bebob);
 	if (err < 0)
 		goto error;

commit 248b78027d26735eb22f5ee91a400e5eabfea77d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:18 2014 +0900

    ALSA: bebob: Add MIDI interface
    
    This commit adds a functionality to capture/playback MIDI messages.
    
    When no AMDTP streams are running, this module starts AMDTP stream at current
    sampling rate for MIDI substream.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 0c3f1f6ab670..383df9a22004 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -164,6 +164,13 @@ bebob_probe(struct fw_unit *unit,
 
 	snd_bebob_proc_init(bebob);
 
+	if ((bebob->midi_input_ports > 0) ||
+	    (bebob->midi_output_ports > 0)) {
+		err = snd_bebob_create_midi_devices(bebob);
+		if (err < 0)
+			goto error;
+	}
+
 	err = snd_bebob_stream_init_duplex(bebob);
 	if (err < 0)
 		goto error;

commit ad9697bad78fab4665d93e61c702892e289e1764
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:17 2014 +0900

    ALSA: bebob: Add proc interface for debugging purpose
    
    This commit adds proc interface to get these information for debugging:
     - firmware information
     - stream formation
     - current clock source and sampling rate
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index 180284db84c9..0c3f1f6ab670 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -162,6 +162,8 @@ bebob_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	snd_bebob_proc_init(bebob);
+
 	err = snd_bebob_stream_init_duplex(bebob);
 	if (err < 0)
 		goto error;

commit eb7b3a056cd8130e45c4494fb27de54d53ce9f31
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:15 2014 +0900

    ALSA: bebob: Add commands and connections/streams management
    
    This commit adds management functionality for connections and streams.
    BeBoB uses CMP to manage connections and uses AMDTP for streams.
    
    This commit also adds some BridgeCo's AV/C extension commands. There are some
    BridgeCo's AV/C extension commands but this commit just uses below commands
    to get device's capability and status:
    
     1.Extended Plug Info commands
      - Plug Channel Position Specific Data
      - Plug Type Specific Data
      - Cluster(Section) Info Specific Data
      - Plug Input Specific Data
     2.Extended Stream Format Information commands
      - Extended Stream Format Information Command - List Request
    
    For Extended Plug Info commands for Cluster Info Specific Data, I pick up
    'section' instead of 'cluster' from document to prevent from misunderstanding
    because 'cluster' is also used in IEC 61883-6.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
index b5644ab473c6..180284db84c9 100644
--- a/sound/firewire/bebob/bebob.c
+++ b/sound/firewire/bebob/bebob.c
@@ -158,9 +158,20 @@ bebob_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_card_register(card);
+	err = snd_bebob_stream_discover(bebob);
 	if (err < 0)
 		goto error;
+
+	err = snd_bebob_stream_init_duplex(bebob);
+	if (err < 0)
+		goto error;
+
+	err = snd_card_register(card);
+	if (err < 0) {
+		snd_bebob_stream_destroy_duplex(bebob);
+		goto error;
+	}
+
 	dev_set_drvdata(&unit->device, bebob);
 end:
 	mutex_unlock(&devices_mutex);
@@ -176,11 +187,13 @@ bebob_update(struct fw_unit *unit)
 {
 	struct snd_bebob *bebob = dev_get_drvdata(&unit->device);
 	fcp_bus_reset(bebob->unit);
+	snd_bebob_stream_update_duplex(bebob);
 }
 
 static void bebob_remove(struct fw_unit *unit)
 {
 	struct snd_bebob *bebob = dev_get_drvdata(&unit->device);
+	snd_bebob_stream_destroy_duplex(bebob);
 	snd_card_disconnect(bebob->card);
 	snd_card_free_when_closed(bebob->card);
 }

commit fd6f4b0dc167c6329a153ceeeb95bc41307156f3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:14 2014 +0900

    ALSA: bebob: Add skelton for BeBoB based devices
    
    This commit adds a new driver for BeBoB based devices with no specific
    operations. Currently this driver just create/remove card instance according
    to callbacks.
    
    BeBoB is 'BridgeCo enhanced Breakout Box'. This is installed to firewire
    devices with DM1000/DM1100/DM1500 chipset. It gives common way for host
    system to handle BeBoB based devices.
    
    Current supported devices:
     - Edirol FA-66/FA-101
     - PreSonus FIREBOX/FIREPOD/FP10/Inspire1394
     - BridgeCo RDAudio1/Audio5
     - Mackie Onyx 1220/1620/1640 (Firewire I/O Card)
     - Mackie d.2 (Firewire Option)
     - Stanton FinalScratch 2 (ScratchAmp)
     - Tascam IF-FW DM
     - Behringer XENIX UFX 1204/1604
     - Behringer Digital Mixer X32 series (X-UF Card)
     - Apogee Rosetta 200/Rosetta 400 (X-FireWire card)
     - Apogee DA-16X/AD-16X/DD-16X (X-FireWire card)
     - Apogee Ensemble
     - ESI Quotafire610
     - AcousticReality eARMasterOne
     - CME MatrixKFW
     - Phonix Helix Board 12 MkII/18 MkII/24 MkII
     - Phonic Helix Board 12 Universal/18 Universal/24 Universal
     - Lynx Aurora 8/16 (LT-FW)
     - ICON FireXon
     - PrismSound Orpheus/ADA-8XR
    
    Devices possible to be supported if identifying IDs:
     - Apogee Mini-Me Firewire/Mini-DAC Firewire
     - Behringer F-Control Audio 610/1616
     - Cakewalk Sonar Power Studio 66
     - CME UF400e
     - ESI Quotafire XL
     - Infrasonic DewX/Windy6
     - Mackie Digital X Bus x.200/400
     - Phonic Helix Board 12/18/24
     - Phonic FireFly 202/302
     - Rolf Spuler Firewire Guitar
    
    Tested-by: David Henningsson <david.henningsson@canonical.com>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/bebob/bebob.c b/sound/firewire/bebob/bebob.c
new file mode 100644
index 000000000000..b5644ab473c6
--- /dev/null
+++ b/sound/firewire/bebob/bebob.c
@@ -0,0 +1,292 @@
+/*
+ * bebob.c - a part of driver for BeBoB based devices
+ *
+ * Copyright (c) 2013-2014 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+/*
+ * BeBoB is 'BridgeCo enhanced Breakout Box'. This is installed to firewire
+ * devices with DM1000/DM1100/DM1500 chipset. It gives common way for host
+ * system to handle BeBoB based devices.
+ */
+
+#include "bebob.h"
+
+MODULE_DESCRIPTION("BridgeCo BeBoB driver");
+MODULE_AUTHOR("Takashi Sakamoto <o-takashi@sakamocchi.jp>");
+MODULE_LICENSE("GPL v2");
+
+static int index[SNDRV_CARDS]	= SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS]	= SNDRV_DEFAULT_STR;
+static bool enable[SNDRV_CARDS]	= SNDRV_DEFAULT_ENABLE_PNP;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "card index");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "enable BeBoB sound card");
+
+static DEFINE_MUTEX(devices_mutex);
+static DECLARE_BITMAP(devices_used, SNDRV_CARDS);
+
+/* Offsets from information register. */
+#define INFO_OFFSET_GUID		0x10
+#define INFO_OFFSET_HW_MODEL_ID		0x18
+#define INFO_OFFSET_HW_MODEL_REVISION	0x1c
+
+#define VEN_EDIROL	0x000040ab
+#define VEN_PRESONUS	0x00000a92
+#define VEN_BRIDGECO	0x000007f5
+#define VEN_MACKIE	0x0000000f
+#define VEN_STANTON	0x00001260
+#define VEN_TASCAM	0x0000022e
+#define VEN_BEHRINGER	0x00001564
+#define VEN_APOGEE	0x000003db
+#define VEN_ESI		0x00000f1b
+#define VEN_ACOUSTIC	0x00000002
+#define VEN_CME		0x0000000a
+#define VEN_PHONIC	0x00001496
+#define VEN_LYNX	0x000019e5
+#define VEN_ICON	0x00001a9e
+#define VEN_PRISMSOUND	0x00001198
+
+static int
+name_device(struct snd_bebob *bebob, unsigned int vendor_id)
+{
+	struct fw_device *fw_dev = fw_parent_device(bebob->unit);
+	char vendor[24] = {0};
+	char model[32] = {0};
+	u32 id;
+	u32 data[2] = {0};
+	u32 revision;
+	int err;
+
+	/* get vendor name from root directory */
+	err = fw_csr_string(fw_dev->config_rom + 5, CSR_VENDOR,
+			    vendor, sizeof(vendor));
+	if (err < 0)
+		goto end;
+
+	/* get model name from unit directory */
+	err = fw_csr_string(bebob->unit->directory, CSR_MODEL,
+			    model, sizeof(model));
+	if (err < 0)
+		goto end;
+
+	/* get hardware id */
+	err = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_HW_MODEL_ID,
+				  &id);
+	if (err < 0)
+		goto end;
+
+	/* get hardware revision */
+	err = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_HW_MODEL_REVISION,
+				  &revision);
+	if (err < 0)
+		goto end;
+
+	/* get GUID */
+	err = snd_bebob_read_block(bebob->unit, INFO_OFFSET_GUID,
+				   data, sizeof(data));
+	if (err < 0)
+		goto end;
+
+	strcpy(bebob->card->driver, "BeBoB");
+	strcpy(bebob->card->shortname, model);
+	strcpy(bebob->card->mixername, model);
+	snprintf(bebob->card->longname, sizeof(bebob->card->longname),
+		 "%s %s (id:%d, rev:%d), GUID %08x%08x at %s, S%d",
+		 vendor, model, id, revision,
+		 data[0], data[1], dev_name(&bebob->unit->device),
+		 100 << fw_dev->max_speed);
+end:
+	return err;
+}
+
+static void
+bebob_card_free(struct snd_card *card)
+{
+	struct snd_bebob *bebob = card->private_data;
+
+	if (bebob->card_index >= 0) {
+		mutex_lock(&devices_mutex);
+		clear_bit(bebob->card_index, devices_used);
+		mutex_unlock(&devices_mutex);
+	}
+
+	mutex_destroy(&bebob->mutex);
+}
+
+static int
+bebob_probe(struct fw_unit *unit,
+	    const struct ieee1394_device_id *entry)
+{
+	struct snd_card *card;
+	struct snd_bebob *bebob;
+	unsigned int card_index;
+	int err;
+
+	mutex_lock(&devices_mutex);
+
+	for (card_index = 0; card_index < SNDRV_CARDS; card_index++) {
+		if (!test_bit(card_index, devices_used) && enable[card_index])
+			break;
+	}
+	if (card_index >= SNDRV_CARDS) {
+		err = -ENOENT;
+		goto end;
+	}
+
+	err = snd_card_new(&unit->device, index[card_index], id[card_index],
+			   THIS_MODULE, sizeof(struct snd_bebob), &card);
+	if (err < 0)
+		goto end;
+	bebob = card->private_data;
+	bebob->card_index = card_index;
+	set_bit(card_index, devices_used);
+	card->private_free = bebob_card_free;
+
+	bebob->card = card;
+	bebob->unit = unit;
+	mutex_init(&bebob->mutex);
+	spin_lock_init(&bebob->lock);
+
+	err = name_device(bebob, entry->vendor_id);
+	if (err < 0)
+		goto error;
+
+	err = snd_card_register(card);
+	if (err < 0)
+		goto error;
+	dev_set_drvdata(&unit->device, bebob);
+end:
+	mutex_unlock(&devices_mutex);
+	return err;
+error:
+	mutex_unlock(&devices_mutex);
+	snd_card_free(card);
+	return err;
+}
+
+static void
+bebob_update(struct fw_unit *unit)
+{
+	struct snd_bebob *bebob = dev_get_drvdata(&unit->device);
+	fcp_bus_reset(bebob->unit);
+}
+
+static void bebob_remove(struct fw_unit *unit)
+{
+	struct snd_bebob *bebob = dev_get_drvdata(&unit->device);
+	snd_card_disconnect(bebob->card);
+	snd_card_free_when_closed(bebob->card);
+}
+
+static const struct ieee1394_device_id bebob_id_table[] = {
+	/* Edirol, FA-66 */
+	SND_BEBOB_DEV_ENTRY(VEN_EDIROL, 0x00010049),
+	/* Edirol, FA-101 */
+	SND_BEBOB_DEV_ENTRY(VEN_EDIROL, 0x00010048),
+	/* Presonus, FIREBOX */
+	SND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010000),
+	/* PreSonus, FIREPOD/FP10 */
+	SND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010066),
+	/* PreSonus, Inspire1394 */
+	SND_BEBOB_DEV_ENTRY(VEN_PRESONUS, 0x00010001),
+	/* BridgeCo, RDAudio1 */
+	SND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010048),
+	/* BridgeCo, Audio5 */
+	SND_BEBOB_DEV_ENTRY(VEN_BRIDGECO, 0x00010049),
+	/* Mackie, Onyx 1220/1620/1640 (Firewire I/O Card) */
+	SND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010065),
+	/* Mackie, d.2 (Firewire Option) */
+	SND_BEBOB_DEV_ENTRY(VEN_MACKIE, 0x00010067),
+	/* Stanton, ScratchAmp */
+	SND_BEBOB_DEV_ENTRY(VEN_STANTON, 0x00000001),
+	/* Tascam, IF-FW DM */
+	SND_BEBOB_DEV_ENTRY(VEN_TASCAM, 0x00010067),
+	/* Behringer, XENIX UFX 1204 */
+	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00001204),
+	/* Behringer, XENIX UFX 1604 */
+	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00001604),
+	/* Behringer, Digital Mixer X32 series (X-UF Card) */
+	SND_BEBOB_DEV_ENTRY(VEN_BEHRINGER, 0x00000006),
+	/* Apogee Electronics, Rosetta 200/400 (X-FireWire card) */
+	/* Apogee Electronics, DA/AD/DD-16X (X-FireWire card) */
+	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00010048),
+	/* Apogee Electronics, Ensemble */
+	SND_BEBOB_DEV_ENTRY(VEN_APOGEE, 0x00001eee),
+	/* ESI, Quatafire610 */
+	SND_BEBOB_DEV_ENTRY(VEN_ESI, 0x00010064),
+	/* AcousticReality, eARMasterOne */
+	SND_BEBOB_DEV_ENTRY(VEN_ACOUSTIC, 0x00000002),
+	/* CME, MatrixKFW */
+	SND_BEBOB_DEV_ENTRY(VEN_CME, 0x00030000),
+	/* Phonic, Helix Board 12 MkII */
+	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00050000),
+	/* Phonic, Helix Board 18 MkII */
+	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00060000),
+	/* Phonic, Helix Board 24 MkII */
+	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00070000),
+	/* Phonic, Helix Board 12 Universal/18 Universal/24 Universal */
+	SND_BEBOB_DEV_ENTRY(VEN_PHONIC, 0x00000000),
+	/* Lynx, Aurora 8/16 (LT-FW) */
+	SND_BEBOB_DEV_ENTRY(VEN_LYNX, 0x00000001),
+	/* ICON, FireXon */
+	SND_BEBOB_DEV_ENTRY(VEN_ICON, 0x00000001),
+	/* PrismSound, Orpheus */
+	SND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x00010048),
+	/* PrismSound, ADA-8XR */
+	SND_BEBOB_DEV_ENTRY(VEN_PRISMSOUND, 0x0000ada8),
+	/* IDs are unknown but able to be supported */
+	/*  Apogee, Mini-ME Firewire */
+	/*  Apogee, Mini-DAC Firewire */
+	/*  Behringer, F-Control Audio 1616 */
+	/*  Behringer, F-Control Audio 610 */
+	/*  Cakawalk, Sonar Power Studio 66 */
+	/*  CME, UF400e */
+	/*  ESI, Quotafire XL */
+	/*  Infrasonic, DewX */
+	/*  Infrasonic, Windy6 */
+	/*  Mackie, Digital X Bus x.200 */
+	/*  Mackie, Digital X Bus x.400 */
+	/*  Phonic, HB 12 */
+	/*  Phonic, HB 24 */
+	/*  Phonic, HB 18 */
+	/*  Phonic, FireFly 202 */
+	/*  Phonic, FireFly 302 */
+	/*  Rolf Spuler, Firewire Guitar */
+	{}
+};
+MODULE_DEVICE_TABLE(ieee1394, bebob_id_table);
+
+static struct fw_driver bebob_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "snd-bebob",
+		.bus	= &fw_bus_type,
+	},
+	.probe    = bebob_probe,
+	.update	  = bebob_update,
+	.remove   = bebob_remove,
+	.id_table = bebob_id_table,
+};
+
+static int __init
+snd_bebob_init(void)
+{
+	return driver_register(&bebob_driver.driver);
+}
+
+static void __exit
+snd_bebob_exit(void)
+{
+	driver_unregister(&bebob_driver.driver);
+	mutex_destroy(&devices_mutex);
+}
+
+module_init(snd_bebob_init);
+module_exit(snd_bebob_exit);
