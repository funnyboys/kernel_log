commit 9c0d16ac059148fc7647f5f9e90df6f34d3439f0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 6 22:52:29 2020 +0900

    ALSA: firewire: use KBUILD_MODNAME for struct driver.name instead of string
    
    KBUILD_MODNAME is available to name kernel modules according to its object
    name. This commit uses the macro instead of string for name field of
    struct driver since drivers in ALSA firewire stack have the same name of
    each object name.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200306135229.11659-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 1f5fc0e7c024..c84b913a9fe0 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -192,7 +192,7 @@ MODULE_DEVICE_TABLE(ieee1394, snd_dg00x_id_table);
 static struct fw_driver dg00x_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
-		.name = "snd-firewire-digi00x",
+		.name = KBUILD_MODNAME,
 		.bus = &fw_bus_type,
 	},
 	.probe    = snd_dg00x_probe,

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 6c6ea149ef6b..1f5fc0e7c024 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * digi00x.c - a part of driver for Digidesign Digi 002/003 family
  *
  * Copyright (c) 2014-2015 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "digi00x.h"

commit 3babca4555b20fc80aff4776662fb237257d9afd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:02 2018 +0900

    ALSA: firewire: simplify cleanup process when failing to register sound card
    
    In former commits, .private_free callback releases resources just for
    data transmission. This release function can be called without the
    resources are actually allocated in error paths.
    
    This commit applies a small refactoring to clean up codes in error
    paths.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 7a24348968b9..6c6ea149ef6b 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -41,17 +41,14 @@ static int name_card(struct snd_dg00x *dg00x)
 	return 0;
 }
 
-static void dg00x_free(struct snd_dg00x *dg00x)
+static void dg00x_card_free(struct snd_card *card)
 {
+	struct snd_dg00x *dg00x = card->private_data;
+
 	snd_dg00x_stream_destroy_duplex(dg00x);
 	snd_dg00x_transaction_unregister(dg00x);
 }
 
-static void dg00x_card_free(struct snd_card *card)
-{
-	dg00x_free(card->private_data);
-}
-
 static void do_registration(struct work_struct *work)
 {
 	struct snd_dg00x *dg00x =
@@ -65,6 +62,8 @@ static void do_registration(struct work_struct *work)
 			   &dg00x->card);
 	if (err < 0)
 		return;
+	dg00x->card->private_free = dg00x_card_free;
+	dg00x->card->private_data = dg00x;
 
 	err = name_card(dg00x);
 	if (err < 0)
@@ -96,14 +95,10 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	dg00x->card->private_free = dg00x_card_free;
-	dg00x->card->private_data = dg00x;
 	dg00x->registered = true;
 
 	return;
 error:
-	snd_dg00x_transaction_unregister(dg00x);
-	snd_dg00x_stream_destroy_duplex(dg00x);
 	snd_card_free(dg00x->card);
 	dev_info(&dg00x->unit->device,
 		 "Sound card registration failed: %d\n", err);

commit 5b14ec25a79bf60fc9a663fe579a500b6ac9d8ab
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:00 2018 +0900

    ALSA: firewire: release reference count of firewire unit in .remove callback of bus driver
    
    In a previous commit, drivers in ALSA firewire stack blocks .remove
    callback of bus driver. This enables to release members of private
    data in the callback after releasing device of sound card.
    
    This commit simplifies codes to release the members.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 554d7ff737a2..7a24348968b9 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -45,9 +45,6 @@ static void dg00x_free(struct snd_dg00x *dg00x)
 {
 	snd_dg00x_stream_destroy_duplex(dg00x);
 	snd_dg00x_transaction_unregister(dg00x);
-
-	mutex_destroy(&dg00x->mutex);
-	fw_unit_put(dg00x->unit);
 }
 
 static void dg00x_card_free(struct snd_card *card)
@@ -174,10 +171,10 @@ static void snd_dg00x_remove(struct fw_unit *unit)
 	if (dg00x->registered) {
 		// Block till all of ALSA character devices are released.
 		snd_card_free(dg00x->card);
-	} else {
-		/* Don't forget this case. */
-		dg00x_free(dg00x);
 	}
+
+	mutex_destroy(&dg00x->mutex);
+	fw_unit_put(dg00x->unit);
 }
 
 static const struct ieee1394_device_id snd_dg00x_id_table[] = {

commit 61ccc6f6b27c03bb32ca38a3c580d49ce1612d43
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:34:59 2018 +0900

    ALSA: firewire: block .remove callback of bus driver till all of ALSA character devices are released
    
    At present, in .remove callback of bus driver just decrease reference
    count of device for ALSA card instance. This delegates release of the
    device to a process in which the last of ALSA character device is
    released.
    
    On the other hand, the other drivers such as for devices on PCIe are
    programmed to block .remove callback of bus driver till all of ALSA
    character devices are released.
    
    For consistency of behaviour for whole drivers, this probably confuses
    users. This commit takes drivers in ALSA firewire stack to imitate the
    above behaviour.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 654420f1c9bd..554d7ff737a2 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -172,8 +172,8 @@ static void snd_dg00x_remove(struct fw_unit *unit)
 	cancel_delayed_work_sync(&dg00x->dwork);
 
 	if (dg00x->registered) {
-		/* No need to wait for releasing card object in this context. */
-		snd_card_free_when_closed(dg00x->card);
+		// Block till all of ALSA character devices are released.
+		snd_card_free(dg00x->card);
 	} else {
 		/* Don't forget this case. */
 		dg00x_free(dg00x);

commit 366a20d7a75cff7f89dede6fdfd41bd491aaf8ac
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:50 2018 +0900

    ALSA: firewire: use managed-resource of fw unit device for private data
    
    At present, private data of each driver in ALSA firewire stack is
    allocated/freed by kernel slab allocator for corresponding unit on
    IEEE 1394 bus. In this case, resource-managed slab allocator is
    available to release memory object automatically just before releasing
    device structure for the unit. This idea can prevent runtime from
    memory leak due to programming mistakes.
    
    This commit uses the allocator for the private data. These drivers
    already use reference counter to maintain lifetime of device structure
    for the unit by a pair of fw_unit_get()/fw_unit_put(). The private data
    is safely released in a callback of 'struct snd_card.private_free().
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index ef689997d6a5..654420f1c9bd 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -46,10 +46,8 @@ static void dg00x_free(struct snd_dg00x *dg00x)
 	snd_dg00x_stream_destroy_duplex(dg00x);
 	snd_dg00x_transaction_unregister(dg00x);
 
-	fw_unit_put(dg00x->unit);
-
 	mutex_destroy(&dg00x->mutex);
-	kfree(dg00x);
+	fw_unit_put(dg00x->unit);
 }
 
 static void dg00x_card_free(struct snd_card *card)
@@ -120,8 +118,9 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 	struct snd_dg00x *dg00x;
 
 	/* Allocate this independent of sound card instance. */
-	dg00x = kzalloc(sizeof(struct snd_dg00x), GFP_KERNEL);
-	if (dg00x == NULL)
+	dg00x = devm_kzalloc(&unit->device, sizeof(struct snd_dg00x),
+			     GFP_KERNEL);
+	if (!dg00x)
 		return -ENOMEM;
 
 	dg00x->unit = fw_unit_get(unit);

commit a49a83ab05e34edd6c71a4fbd062c9a7ba6d18aa
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Sep 13 21:30:34 2018 +0900

    ALSA: firewire-digi00x: fix memory leak of private data
    
    Although private data of sound card instance is usually allocated in the
    tail of the instance, drivers in ALSA firewire stack allocate the private
    data before allocating the instance. In this case, the private data
    should be released explicitly at .private_free callback of the instance.
    
    This commit fixes memory leak following to the above design.
    
    Fixes: 86c8dd7f4da3 ('ALSA: firewire-digi00x: delayed registration of sound card')
    Cc: <stable@vger.kernel.org> # v4.7+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 1f5e1d23f31a..ef689997d6a5 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -49,6 +49,7 @@ static void dg00x_free(struct snd_dg00x *dg00x)
 	fw_unit_put(dg00x->unit);
 
 	mutex_destroy(&dg00x->mutex);
+	kfree(dg00x);
 }
 
 static void dg00x_card_free(struct snd_card *card)

commit 13e005f9f933a35b5e55c9d36f151efe2a8383ec
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Apr 2 23:48:24 2017 +0900

    ALSA: firewire-digi00x: add support for console models of Digi00x series
    
    Digi00x series includes two types of unit; rack and console. As long as
    reading information on config rom of Digi 002 console, 'MODEL_ID' field
    has a different value from the one on Digi 002 rack.
    
    We've already got a test report from users with Digi 003 rack. We can
    assume that console type and rack type has different value in the field.
    
    This commit adds a device entry for console type. For following commits,
    this commit also adds a member to 'struct snd_digi00x' to identify console
    type.
    
    $ cd linux-firewire-utils/src
    $ python2 ./crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  0404f9d0  bus_info_length 4, crc_length 4, crc 63952
    404  31333934  bus_name "1394"
    408  60647002  irmc 0, cmc 1, isc 1, bmc 0, cyc_clk_acc 100, max_rec 7 (256)
    40c  00a07e00  company_id 00a07e     |
    410  00a30000  device_id 0000a30000  | EUI-64 00a07e0000a30000
    
                   root directory
                   -----------------------------------------------------------------
    414  00058a39  directory_length 5, crc 35385
    418  0c0043a0  node capabilities
    41c  04000001  hardware version
    420  0300a07e  vendor
    424  81000007  --> descriptor leaf at 440
    428  d1000001  --> unit directory at 42c
    
                   unit directory at 42c
                   -----------------------------------------------------------------
    42c  00046674  directory_length 4, crc 26228
    430  120000a3  specifier id
    434  13000001  version
    438  17000001  model
    43c  81000007  --> descriptor leaf at 458
    
                   descriptor leaf at 440
                   -----------------------------------------------------------------
    440  00055913  leaf_length 5, crc 22803
    444  000050f2  descriptor_type 00, specifier_ID 50f2
    448  80000000
    44c  44696769
    450  64657369
    454  676e0000
    
                   descriptor leaf at 458
                   -----------------------------------------------------------------
    458  0004a6fd  leaf_length 4, crc 42749
    45c  00000000  textual descriptor
    460  00000000  minimal ASCII
    464  44696769  "Digi"
    468  20303032  " 002"
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index cc4776c6ded3..1f5e1d23f31a 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -13,7 +13,8 @@ MODULE_AUTHOR("Takashi Sakamoto <o-takashi@sakamocchi.jp>");
 MODULE_LICENSE("GPL v2");
 
 #define VENDOR_DIGIDESIGN	0x00a07e
-#define MODEL_DIGI00X		0x000002
+#define MODEL_CONSOLE		0x000001
+#define MODEL_RACK		0x000002
 
 static int name_card(struct snd_dg00x *dg00x)
 {
@@ -129,6 +130,8 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 	spin_lock_init(&dg00x->lock);
 	init_waitqueue_head(&dg00x->hwdep_wait);
 
+	dg00x->is_console = entry->model_id == MODEL_CONSOLE;
+
 	/* Allocate and register this sound card later. */
 	INIT_DEFERRABLE_WORK(&dg00x->dwork, do_registration);
 	snd_fw_schedule_registration(unit, &dg00x->dwork);
@@ -183,7 +186,13 @@ static const struct ieee1394_device_id snd_dg00x_id_table[] = {
 		.match_flags = IEEE1394_MATCH_VENDOR_ID |
 			       IEEE1394_MATCH_MODEL_ID,
 		.vendor_id = VENDOR_DIGIDESIGN,
-		.model_id = MODEL_DIGI00X,
+		.model_id = MODEL_CONSOLE,
+	},
+	{
+		.match_flags = IEEE1394_MATCH_VENDOR_ID |
+			       IEEE1394_MATCH_MODEL_ID,
+		.vendor_id = VENDOR_DIGIDESIGN,
+		.model_id = MODEL_RACK,
 	},
 	{}
 };

commit 86c8dd7f4da3fb3f92fc5ab5144c971639d39745
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Mar 31 08:47:08 2016 +0900

    ALSA: firewire-digi00x: delayed registration of sound card
    
    When some digi00x units are connected sequentially, userspace
    applications are involved at bus-reset state on IEEE 1394 bus. In the
    state, any communications can be canceled. Therefore, sound card
    registration should be delayed till the bus gets calm.
    
    This commit achieves it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 1f33b7a1fca4..cc4776c6ded3 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -40,10 +40,8 @@ static int name_card(struct snd_dg00x *dg00x)
 	return 0;
 }
 
-static void dg00x_card_free(struct snd_card *card)
+static void dg00x_free(struct snd_dg00x *dg00x)
 {
-	struct snd_dg00x *dg00x = card->private_data;
-
 	snd_dg00x_stream_destroy_duplex(dg00x);
 	snd_dg00x_transaction_unregister(dg00x);
 
@@ -52,28 +50,24 @@ static void dg00x_card_free(struct snd_card *card)
 	mutex_destroy(&dg00x->mutex);
 }
 
-static int snd_dg00x_probe(struct fw_unit *unit,
-			   const struct ieee1394_device_id *entry)
+static void dg00x_card_free(struct snd_card *card)
 {
-	struct snd_card *card;
-	struct snd_dg00x *dg00x;
-	int err;
+	dg00x_free(card->private_data);
+}
 
-	/* create card */
-	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
-			   sizeof(struct snd_dg00x), &card);
-	if (err < 0)
-		return err;
-	card->private_free = dg00x_card_free;
+static void do_registration(struct work_struct *work)
+{
+	struct snd_dg00x *dg00x =
+			container_of(work, struct snd_dg00x, dwork.work);
+	int err;
 
-	/* initialize myself */
-	dg00x = card->private_data;
-	dg00x->card = card;
-	dg00x->unit = fw_unit_get(unit);
+	if (dg00x->registered)
+		return;
 
-	mutex_init(&dg00x->mutex);
-	spin_lock_init(&dg00x->lock);
-	init_waitqueue_head(&dg00x->hwdep_wait);
+	err = snd_card_new(&dg00x->unit->device, -1, NULL, THIS_MODULE, 0,
+			   &dg00x->card);
+	if (err < 0)
+		return;
 
 	err = name_card(dg00x);
 	if (err < 0)
@@ -101,35 +95,86 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_card_register(card);
+	err = snd_card_register(dg00x->card);
 	if (err < 0)
 		goto error;
 
-	dev_set_drvdata(&unit->device, dg00x);
+	dg00x->card->private_free = dg00x_card_free;
+	dg00x->card->private_data = dg00x;
+	dg00x->registered = true;
 
-	return err;
+	return;
 error:
-	snd_card_free(card);
-	return err;
+	snd_dg00x_transaction_unregister(dg00x);
+	snd_dg00x_stream_destroy_duplex(dg00x);
+	snd_card_free(dg00x->card);
+	dev_info(&dg00x->unit->device,
+		 "Sound card registration failed: %d\n", err);
+}
+
+static int snd_dg00x_probe(struct fw_unit *unit,
+			   const struct ieee1394_device_id *entry)
+{
+	struct snd_dg00x *dg00x;
+
+	/* Allocate this independent of sound card instance. */
+	dg00x = kzalloc(sizeof(struct snd_dg00x), GFP_KERNEL);
+	if (dg00x == NULL)
+		return -ENOMEM;
+
+	dg00x->unit = fw_unit_get(unit);
+	dev_set_drvdata(&unit->device, dg00x);
+
+	mutex_init(&dg00x->mutex);
+	spin_lock_init(&dg00x->lock);
+	init_waitqueue_head(&dg00x->hwdep_wait);
+
+	/* Allocate and register this sound card later. */
+	INIT_DEFERRABLE_WORK(&dg00x->dwork, do_registration);
+	snd_fw_schedule_registration(unit, &dg00x->dwork);
+
+	return 0;
 }
 
 static void snd_dg00x_update(struct fw_unit *unit)
 {
 	struct snd_dg00x *dg00x = dev_get_drvdata(&unit->device);
 
+	/* Postpone a workqueue for deferred registration. */
+	if (!dg00x->registered)
+		snd_fw_schedule_registration(unit, &dg00x->dwork);
+
 	snd_dg00x_transaction_reregister(dg00x);
 
-	mutex_lock(&dg00x->mutex);
-	snd_dg00x_stream_update_duplex(dg00x);
-	mutex_unlock(&dg00x->mutex);
+	/*
+	 * After registration, userspace can start packet streaming, then this
+	 * code block works fine.
+	 */
+	if (dg00x->registered) {
+		mutex_lock(&dg00x->mutex);
+		snd_dg00x_stream_update_duplex(dg00x);
+		mutex_unlock(&dg00x->mutex);
+	}
 }
 
 static void snd_dg00x_remove(struct fw_unit *unit)
 {
 	struct snd_dg00x *dg00x = dev_get_drvdata(&unit->device);
 
-	/* No need to wait for releasing card object in this context. */
-	snd_card_free_when_closed(dg00x->card);
+	/*
+	 * Confirm to stop the work for registration before the sound card is
+	 * going to be released. The work is not scheduled again because bus
+	 * reset handler is not called anymore.
+	 */
+	cancel_delayed_work_sync(&dg00x->dwork);
+
+	if (dg00x->registered) {
+		/* No need to wait for releasing card object in this context. */
+		snd_card_free_when_closed(dg00x->card);
+	} else {
+		/* Don't forget this case. */
+		dg00x_free(dg00x);
+	}
 }
 
 static const struct ieee1394_device_id snd_dg00x_id_table[] = {

commit bd04809bbe4c1f749650bb990c969112a5e10aef
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 18 22:39:53 2015 +0900

    ALSA: firewire-digi00x/firewire-tascam: remove wrong conversion for Config ROM
    
    The contents of Config ROM in firewire device structure are already
    aligned to CPU-endianness. Thus, no need to convert it again.
    
    This commit removes needless conversions
    
    Fixes: 9edf723fd858('ALSA: firewire-digi00x: add skeleton for Digi 002/003 family')
    Fixes: c0949b278515('ALSA: firewire-tascam: add skeleton for TASCAM FireWire series')
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index bbe3be7fea9b..1f33b7a1fca4 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -34,8 +34,7 @@ static int name_card(struct snd_dg00x *dg00x)
 	strcpy(dg00x->card->mixername, model);
 	snprintf(dg00x->card->longname, sizeof(dg00x->card->longname),
 		 "Digidesign %s, GUID %08x%08x at %s, S%d", model,
-		 cpu_to_be32(fw_dev->config_rom[3]),
-		 cpu_to_be32(fw_dev->config_rom[4]),
+		 fw_dev->config_rom[3], fw_dev->config_rom[4],
 		 dev_name(&dg00x->unit->device), 100 << fw_dev->max_speed);
 
 	return 0;

commit 9fbfd38b204a3f04272183c0258a3ded03a5aae8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 11 12:30:16 2015 +0900

    ALSA: firewire-digi00x: add support for MIDI ports corresponding to isochronous packet streaming
    
    This commit adds MIDI functionality to capture/playback MIDI messages
    from/to physical MIDI ports. These messages are transferred in isochronous
    packets.
    
    When no substreams request AMDTP streams to run, this driver starts the
    streams at current sampling rate. When other substreams start at different
    sampling rate, the streams are stopped temporarily, then start again at
    requested sampling rate. This operation can generate missing MIDI bytes,
    thus it's preferable to start PCM substreams at favorite sampling rate in
    advance.
    
    Digi 002/003 console also has a set of MIDI port for physical controls.
    These ports are added in later commits.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 34937a26c198..bbe3be7fea9b 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -90,6 +90,10 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_dg00x_create_midi_devices(dg00x);
+	if (err < 0)
+		goto error;
+
 	err = snd_dg00x_create_hwdep_device(dg00x);
 	if (err < 0)
 		goto error;

commit 44b7308871ac6fd85fc840bfa3ddb466fe7aff23
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Sep 30 09:39:22 2015 +0900

    ALSA: firewire-digi00x: add support for asynchronous messaging
    
    Digi 002/003 family uses asynchronous transaction for messaging.
    The address to transmit this message is stored on a certain register.
    
    This commit allocates a range of address on OHCI 1394 host controller
    to handle the messaging. As long as I know, the purpose of this message
    seems to notify lost of synchronization. While, the meaning of content
    of the message is not clear.
    
    Actual examples of this messaging:
     * When clock source is set as internal:
     - 0x00007051
     - 0x00007052
     - 0x00007054
     - 0x00007057
     - 0x00007058
     * When clock source is set as somewhat external:
     - 0x00009000
     - 0x00009010
     - 0x00009020
     - 0x00009021
     - 0x00009022
    
    The lost often occurs when using internal clock source. In this case,
    users hear sounds with quite short gap every several minutes. In fact,
    the lost is recovered temporarily.
    
    When using with external clock source, the lost seems not to occur. The
    mechanism is not clear yet.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index cd93030df1cd..34937a26c198 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -46,6 +46,7 @@ static void dg00x_card_free(struct snd_card *card)
 	struct snd_dg00x *dg00x = card->private_data;
 
 	snd_dg00x_stream_destroy_duplex(dg00x);
+	snd_dg00x_transaction_unregister(dg00x);
 
 	fw_unit_put(dg00x->unit);
 
@@ -93,6 +94,10 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_dg00x_transaction_register(dg00x);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;
@@ -109,6 +114,8 @@ static void snd_dg00x_update(struct fw_unit *unit)
 {
 	struct snd_dg00x *dg00x = dev_get_drvdata(&unit->device);
 
+	snd_dg00x_transaction_reregister(dg00x);
+
 	mutex_lock(&dg00x->mutex);
 	snd_dg00x_stream_update_duplex(dg00x);
 	mutex_unlock(&dg00x->mutex);

commit 660dd3d52ead45b8e60dcf966daf304de2121a28
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Sep 30 09:39:21 2015 +0900

    ALSA: firewire-digi00x: add hwdep interface
    
    This commit adds hwdep interface so as the other sound drivers for units
    on IEEE 1394 bus have.
    
    This interface is designed for mixer/control applications. By using this
    interface, an application can get information about firewire node, can
    lock/unlock kernel streaming and can get notification at starting/stopping
    kernel streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 166c1d43123f..cd93030df1cd 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -72,6 +72,8 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 	dg00x->unit = fw_unit_get(unit);
 
 	mutex_init(&dg00x->mutex);
+	spin_lock_init(&dg00x->lock);
+	init_waitqueue_head(&dg00x->hwdep_wait);
 
 	err = name_card(dg00x);
 	if (err < 0)
@@ -87,6 +89,10 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_dg00x_create_hwdep_device(dg00x);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;

commit 0120d0f1fe3bbf6c6a450056be56a70c409cf7a3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Sep 30 09:39:20 2015 +0900

    ALSA: firewire-digi00x: add PCM functionality
    
    This commit adds PCM functionality to transmit/receive PCM samples.
    
    Any PCM substreams are jointed because incoming/outgoing AMDTP streams
    are bound. When one of PCM substream is running or external clock source
    is selected, current sampling rate is used. Else, the sampling rate is
    changed as an userspace application requests.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index a5f66fd1fb18..166c1d43123f 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -83,6 +83,10 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 
 	snd_dg00x_proc_init(dg00x);
 
+	err = snd_dg00x_create_pcm_devices(dg00x);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;

commit 927f17dc3a517128f07bbc1634fb25ce2587dc6f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Sep 30 09:39:19 2015 +0900

    ALSA: firewire-digi00x: add proc node to show clock status
    
    This commit adds proc node to show current clock status for debugging.
    
    As long as testing Digi 002 rack, registers can show local clock rate,
    local clock source. When external clock input such as S/PDIF is
    connected, the registers show the detection and external clock rate.
    
    Additionally, the registers show the mode of optical digital input
    interface. Although, a tester with Digi 003 rack reports this makes no
    sense. Further investigation is required for Digi 003 series.
    
    Besides, in Digi 002 rack, the S/PDIF format must be IEC 60958-4,
    so-called professional.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 5bda4c4c87f0..a5f66fd1fb18 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -81,6 +81,8 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	snd_dg00x_proc_init(dg00x);
+
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;

commit 3a2a17974eef10766ffbd7d3e9f5191fbb3c9f33
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Sep 30 09:39:18 2015 +0900

    ALSA: firewire-digi00x: add stream functionality
    
    This commit adds a functionality to manage streaming.
    
    The streaming is not controlled by CMP in IEC 61883-6. It's controlled by
    IEEE 1394 write transaction to certain addresses.
    
    Several clock sources are available, while there're no differences about
    packet transmission. The value of SYT field in transmitted packets is
    always zero. Thus, streams in both direction don't build synchronization.
    
    And the device always requires received packets to transmit packets. This
    driver keeps to transfer outgoing stream even if they're not required.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
index 260967e54519..5bda4c4c87f0 100644
--- a/sound/firewire/digi00x/digi00x.c
+++ b/sound/firewire/digi00x/digi00x.c
@@ -45,6 +45,8 @@ static void dg00x_card_free(struct snd_card *card)
 {
 	struct snd_dg00x *dg00x = card->private_data;
 
+	snd_dg00x_stream_destroy_duplex(dg00x);
+
 	fw_unit_put(dg00x->unit);
 
 	mutex_destroy(&dg00x->mutex);
@@ -75,6 +77,10 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_dg00x_stream_init_duplex(dg00x);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;
@@ -89,7 +95,11 @@ static int snd_dg00x_probe(struct fw_unit *unit,
 
 static void snd_dg00x_update(struct fw_unit *unit)
 {
-	return;
+	struct snd_dg00x *dg00x = dev_get_drvdata(&unit->device);
+
+	mutex_lock(&dg00x->mutex);
+	snd_dg00x_stream_update_duplex(dg00x);
+	mutex_unlock(&dg00x->mutex);
 }
 
 static void snd_dg00x_remove(struct fw_unit *unit)

commit 9edf723fd85822c7b7d8ef4f41a74c5a33eeca0c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Sep 30 09:39:16 2015 +0900

    ALSA: firewire-digi00x: add skeleton for Digi 002/003 family
    
    This commit adds a new driver for Digidesign 002/003 family. This commit
    just creates/removes card instance according to bus event. More functions
    will be added in following commits.
    
    Digidesign 002/003 family consists of:
     * Agere FW802B for IEEE 1394 PHY layer
     * PDI 1394L40 for IEEE 1394 LINK layer and IEC 61883 interface
     * ALTERA ACEX EP1K50 for IEC 61883 layer and DSP controller
     * ADSP-21065L for signal processing
    
    [minor cleanup using skip_spaces() by tiwai]
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x.c b/sound/firewire/digi00x/digi00x.c
new file mode 100644
index 000000000000..260967e54519
--- /dev/null
+++ b/sound/firewire/digi00x/digi00x.c
@@ -0,0 +1,138 @@
+/*
+ * digi00x.c - a part of driver for Digidesign Digi 002/003 family
+ *
+ * Copyright (c) 2014-2015 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "digi00x.h"
+
+MODULE_DESCRIPTION("Digidesign Digi 002/003 family Driver");
+MODULE_AUTHOR("Takashi Sakamoto <o-takashi@sakamocchi.jp>");
+MODULE_LICENSE("GPL v2");
+
+#define VENDOR_DIGIDESIGN	0x00a07e
+#define MODEL_DIGI00X		0x000002
+
+static int name_card(struct snd_dg00x *dg00x)
+{
+	struct fw_device *fw_dev = fw_parent_device(dg00x->unit);
+	char name[32] = {0};
+	char *model;
+	int err;
+
+	err = fw_csr_string(dg00x->unit->directory, CSR_MODEL, name,
+			    sizeof(name));
+	if (err < 0)
+		return err;
+
+	model = skip_spaces(name);
+
+	strcpy(dg00x->card->driver, "Digi00x");
+	strcpy(dg00x->card->shortname, model);
+	strcpy(dg00x->card->mixername, model);
+	snprintf(dg00x->card->longname, sizeof(dg00x->card->longname),
+		 "Digidesign %s, GUID %08x%08x at %s, S%d", model,
+		 cpu_to_be32(fw_dev->config_rom[3]),
+		 cpu_to_be32(fw_dev->config_rom[4]),
+		 dev_name(&dg00x->unit->device), 100 << fw_dev->max_speed);
+
+	return 0;
+}
+
+static void dg00x_card_free(struct snd_card *card)
+{
+	struct snd_dg00x *dg00x = card->private_data;
+
+	fw_unit_put(dg00x->unit);
+
+	mutex_destroy(&dg00x->mutex);
+}
+
+static int snd_dg00x_probe(struct fw_unit *unit,
+			   const struct ieee1394_device_id *entry)
+{
+	struct snd_card *card;
+	struct snd_dg00x *dg00x;
+	int err;
+
+	/* create card */
+	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
+			   sizeof(struct snd_dg00x), &card);
+	if (err < 0)
+		return err;
+	card->private_free = dg00x_card_free;
+
+	/* initialize myself */
+	dg00x = card->private_data;
+	dg00x->card = card;
+	dg00x->unit = fw_unit_get(unit);
+
+	mutex_init(&dg00x->mutex);
+
+	err = name_card(dg00x);
+	if (err < 0)
+		goto error;
+
+	err = snd_card_register(card);
+	if (err < 0)
+		goto error;
+
+	dev_set_drvdata(&unit->device, dg00x);
+
+	return err;
+error:
+	snd_card_free(card);
+	return err;
+}
+
+static void snd_dg00x_update(struct fw_unit *unit)
+{
+	return;
+}
+
+static void snd_dg00x_remove(struct fw_unit *unit)
+{
+	struct snd_dg00x *dg00x = dev_get_drvdata(&unit->device);
+
+	/* No need to wait for releasing card object in this context. */
+	snd_card_free_when_closed(dg00x->card);
+}
+
+static const struct ieee1394_device_id snd_dg00x_id_table[] = {
+	/* Both of 002/003 use the same ID. */
+	{
+		.match_flags = IEEE1394_MATCH_VENDOR_ID |
+			       IEEE1394_MATCH_MODEL_ID,
+		.vendor_id = VENDOR_DIGIDESIGN,
+		.model_id = MODEL_DIGI00X,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(ieee1394, snd_dg00x_id_table);
+
+static struct fw_driver dg00x_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "snd-firewire-digi00x",
+		.bus = &fw_bus_type,
+	},
+	.probe    = snd_dg00x_probe,
+	.update   = snd_dg00x_update,
+	.remove   = snd_dg00x_remove,
+	.id_table = snd_dg00x_id_table,
+};
+
+static int __init snd_dg00x_init(void)
+{
+	return driver_register(&dg00x_driver.driver);
+}
+
+static void __exit snd_dg00x_exit(void)
+{
+	driver_unregister(&dg00x_driver.driver);
+}
+
+module_init(snd_dg00x_init);
+module_exit(snd_dg00x_exit);
