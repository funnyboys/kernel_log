commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/digi00x/digi00x-transaction.c b/sound/firewire/digi00x/digi00x-transaction.c
index af9bc8504781..cf0bcf1c5956 100644
--- a/sound/firewire/digi00x/digi00x-transaction.c
+++ b/sound/firewire/digi00x/digi00x-transaction.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * digi00x-transaction.c - a part of driver for Digidesign Digi 002/003 family
  *
  * Copyright (c) 2014-2015 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include <sound/asound.h>

commit fdb2b2eee6bc33f4dcb1b05176e3008a4e494612
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Apr 2 23:48:27 2017 +0900

    ALSA: firewire-digi00x: remove transaction handler for unknown purpose
    
    For digi00x series, asynchronous transaction is not used to transfer MIDI
    messages to/from control surface. One of transction handlers in my previous
    work loses its practical meaning.
    
    This commit removes the handler. I note that unit of console type
    transfers 0x00001000 to registered address of host space when switching
    to 'standalone' mode. Then the unit generates bus reset.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-transaction.c b/sound/firewire/digi00x/digi00x-transaction.c
index 735d35640807..af9bc8504781 100644
--- a/sound/firewire/digi00x/digi00x-transaction.c
+++ b/sound/firewire/digi00x/digi00x-transaction.c
@@ -9,40 +9,6 @@
 #include <sound/asound.h>
 #include "digi00x.h"
 
-static int fill_midi_message(struct snd_rawmidi_substream *substream, u8 *buf)
-{
-	int bytes;
-
-	buf[0] = 0x80;
-	bytes = snd_rawmidi_transmit_peek(substream, buf + 1, 2);
-	if (bytes >= 0)
-		buf[3] = 0xc0 | bytes;
-
-	return bytes;
-}
-
-static void handle_midi_control(struct snd_dg00x *dg00x, __be32 *buf,
-				unsigned int length)
-{
-	struct snd_rawmidi_substream *substream;
-	unsigned int i;
-	unsigned int len;
-	u8 *b;
-
-	substream = ACCESS_ONCE(dg00x->in_control);
-	if (substream == NULL)
-		return;
-
-	length /= 4;
-
-	for (i = 0; i < length; i++) {
-		b = (u8 *)&buf[i];
-		len = b[3] & 0xf;
-		if (len > 0)
-			snd_rawmidi_receive(dg00x->in_control, b + 1, len);
-	}
-}
-
 static void handle_unknown_message(struct snd_dg00x *dg00x,
 				   unsigned long long offset, __be32 *buf)
 {
@@ -63,39 +29,36 @@ static void handle_message(struct fw_card *card, struct fw_request *request,
 	struct snd_dg00x *dg00x = callback_data;
 	__be32 *buf = (__be32 *)data;
 
+	fw_send_response(card, request, RCODE_COMPLETE);
+
 	if (offset == dg00x->async_handler.offset)
 		handle_unknown_message(dg00x, offset, buf);
-	else if (offset == dg00x->async_handler.offset + 4)
-		handle_midi_control(dg00x, buf, length);
-
-	fw_send_response(card, request, RCODE_COMPLETE);
 }
 
 int snd_dg00x_transaction_reregister(struct snd_dg00x *dg00x)
 {
 	struct fw_device *device = fw_parent_device(dg00x->unit);
 	__be32 data[2];
-	int err;
 
 	/* Unknown. 4bytes. */
 	data[0] = cpu_to_be32((device->card->node_id << 16) |
 			      (dg00x->async_handler.offset >> 32));
 	data[1] = cpu_to_be32(dg00x->async_handler.offset);
-	err = snd_fw_transaction(dg00x->unit, TCODE_WRITE_BLOCK_REQUEST,
-				 DG00X_ADDR_BASE + DG00X_OFFSET_MESSAGE_ADDR,
-				 &data, sizeof(data), 0);
-	if (err < 0)
-		return err;
-
-	/* Asynchronous transactions for MIDI control message. */
-	data[0] = cpu_to_be32((device->card->node_id << 16) |
-			      (dg00x->async_handler.offset >> 32));
-	data[1] = cpu_to_be32(dg00x->async_handler.offset + 4);
 	return snd_fw_transaction(dg00x->unit, TCODE_WRITE_BLOCK_REQUEST,
-				  DG00X_ADDR_BASE + DG00X_OFFSET_MIDI_CTL_ADDR,
+				  DG00X_ADDR_BASE + DG00X_OFFSET_MESSAGE_ADDR,
 				  &data, sizeof(data), 0);
 }
 
+void snd_dg00x_transaction_unregister(struct snd_dg00x *dg00x)
+{
+	if (dg00x->async_handler.callback_data == NULL)
+		return;
+
+	fw_core_remove_address_handler(&dg00x->async_handler);
+
+	dg00x->async_handler.callback_data = NULL;
+}
+
 int snd_dg00x_transaction_register(struct snd_dg00x *dg00x)
 {
 	static const struct fw_address_region resp_register_region = {
@@ -104,7 +67,7 @@ int snd_dg00x_transaction_register(struct snd_dg00x *dg00x)
 	};
 	int err;
 
-	dg00x->async_handler.length = 12;
+	dg00x->async_handler.length = 4;
 	dg00x->async_handler.address_callback = handle_message;
 	dg00x->async_handler.callback_data = dg00x;
 
@@ -115,28 +78,7 @@ int snd_dg00x_transaction_register(struct snd_dg00x *dg00x)
 
 	err = snd_dg00x_transaction_reregister(dg00x);
 	if (err < 0)
-		goto error;
-
-	err = snd_fw_async_midi_port_init(&dg00x->out_control, dg00x->unit,
-					  DG00X_ADDR_BASE + DG00X_OFFSET_MMC,
-					  4, fill_midi_message);
-	if (err < 0)
-		goto error;
+		snd_dg00x_transaction_unregister(dg00x);
 
 	return err;
-error:
-	fw_core_remove_address_handler(&dg00x->async_handler);
-	dg00x->async_handler.callback_data = NULL;
-	return err;
-}
-
-void snd_dg00x_transaction_unregister(struct snd_dg00x *dg00x)
-{
-	if (dg00x->async_handler.callback_data == NULL)
-		return;
-
-	snd_fw_async_midi_port_destroy(&dg00x->out_control);
-	fw_core_remove_address_handler(&dg00x->async_handler);
-
-	dg00x->async_handler.callback_data = NULL;
 }

commit 86c8dd7f4da3fb3f92fc5ab5144c971639d39745
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Mar 31 08:47:08 2016 +0900

    ALSA: firewire-digi00x: delayed registration of sound card
    
    When some digi00x units are connected sequentially, userspace
    applications are involved at bus-reset state on IEEE 1394 bus. In the
    state, any communications can be canceled. Therefore, sound card
    registration should be delayed till the bus gets calm.
    
    This commit achieves it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-transaction.c b/sound/firewire/digi00x/digi00x-transaction.c
index 554324d8c602..735d35640807 100644
--- a/sound/firewire/digi00x/digi00x-transaction.c
+++ b/sound/firewire/digi00x/digi00x-transaction.c
@@ -126,12 +126,17 @@ int snd_dg00x_transaction_register(struct snd_dg00x *dg00x)
 	return err;
 error:
 	fw_core_remove_address_handler(&dg00x->async_handler);
-	dg00x->async_handler.address_callback = NULL;
+	dg00x->async_handler.callback_data = NULL;
 	return err;
 }
 
 void snd_dg00x_transaction_unregister(struct snd_dg00x *dg00x)
 {
+	if (dg00x->async_handler.callback_data == NULL)
+		return;
+
 	snd_fw_async_midi_port_destroy(&dg00x->out_control);
 	fw_core_remove_address_handler(&dg00x->async_handler);
+
+	dg00x->async_handler.callback_data = NULL;
 }

commit b47f525f760f29c4689a7d9bf768c28fcaac2281
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 11 12:30:18 2015 +0900

    ALSA: firewire-digi00x: add support of asynchronous transaction for outgoing MIDI messages to physical controls
    
    In previous commit, asynchronous transaction for incoming MIDI messages
    from physical controls is supported. The physical controls may be
    controlled by receiving MIDI messages at a certain address.
    
    This commit supports asynchronous transaction for this purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-transaction.c b/sound/firewire/digi00x/digi00x-transaction.c
index 8bf5ed5e5f3e..554324d8c602 100644
--- a/sound/firewire/digi00x/digi00x-transaction.c
+++ b/sound/firewire/digi00x/digi00x-transaction.c
@@ -9,6 +9,18 @@
 #include <sound/asound.h>
 #include "digi00x.h"
 
+static int fill_midi_message(struct snd_rawmidi_substream *substream, u8 *buf)
+{
+	int bytes;
+
+	buf[0] = 0x80;
+	bytes = snd_rawmidi_transmit_peek(substream, buf + 1, 2);
+	if (bytes >= 0)
+		buf[3] = 0xc0 | bytes;
+
+	return bytes;
+}
+
 static void handle_midi_control(struct snd_dg00x *dg00x, __be32 *buf,
 				unsigned int length)
 {
@@ -102,15 +114,24 @@ int snd_dg00x_transaction_register(struct snd_dg00x *dg00x)
 		return err;
 
 	err = snd_dg00x_transaction_reregister(dg00x);
-	if (err < 0) {
-		fw_core_remove_address_handler(&dg00x->async_handler);
-		dg00x->async_handler.address_callback = NULL;
-	}
+	if (err < 0)
+		goto error;
+
+	err = snd_fw_async_midi_port_init(&dg00x->out_control, dg00x->unit,
+					  DG00X_ADDR_BASE + DG00X_OFFSET_MMC,
+					  4, fill_midi_message);
+	if (err < 0)
+		goto error;
 
 	return err;
+error:
+	fw_core_remove_address_handler(&dg00x->async_handler);
+	dg00x->async_handler.address_callback = NULL;
+	return err;
 }
 
 void snd_dg00x_transaction_unregister(struct snd_dg00x *dg00x)
 {
+	snd_fw_async_midi_port_destroy(&dg00x->out_control);
 	fw_core_remove_address_handler(&dg00x->async_handler);
 }

commit 3646a54acda65afdd76737d40c0994b991742e01
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 11 12:30:17 2015 +0900

    ALSA: firewire-digi00x: add support of asynchronous transaction for incoming MIDI messages from physical controls
    
    Digi 00x series has two types of model; rack and console. The console
    models have physical controls. The model can transmit control messages.
    These control messages are transferred by asynchronous transactions to
    registered address.
    
    This commit supports the asynchronous transaction.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-transaction.c b/sound/firewire/digi00x/digi00x-transaction.c
index 49372901a1e1..8bf5ed5e5f3e 100644
--- a/sound/firewire/digi00x/digi00x-transaction.c
+++ b/sound/firewire/digi00x/digi00x-transaction.c
@@ -9,6 +9,28 @@
 #include <sound/asound.h>
 #include "digi00x.h"
 
+static void handle_midi_control(struct snd_dg00x *dg00x, __be32 *buf,
+				unsigned int length)
+{
+	struct snd_rawmidi_substream *substream;
+	unsigned int i;
+	unsigned int len;
+	u8 *b;
+
+	substream = ACCESS_ONCE(dg00x->in_control);
+	if (substream == NULL)
+		return;
+
+	length /= 4;
+
+	for (i = 0; i < length; i++) {
+		b = (u8 *)&buf[i];
+		len = b[3] & 0xf;
+		if (len > 0)
+			snd_rawmidi_receive(dg00x->in_control, b + 1, len);
+	}
+}
+
 static void handle_unknown_message(struct snd_dg00x *dg00x,
 				   unsigned long long offset, __be32 *buf)
 {
@@ -31,6 +53,8 @@ static void handle_message(struct fw_card *card, struct fw_request *request,
 
 	if (offset == dg00x->async_handler.offset)
 		handle_unknown_message(dg00x, offset, buf);
+	else if (offset == dg00x->async_handler.offset + 4)
+		handle_midi_control(dg00x, buf, length);
 
 	fw_send_response(card, request, RCODE_COMPLETE);
 }
@@ -39,14 +63,25 @@ int snd_dg00x_transaction_reregister(struct snd_dg00x *dg00x)
 {
 	struct fw_device *device = fw_parent_device(dg00x->unit);
 	__be32 data[2];
+	int err;
 
 	/* Unknown. 4bytes. */
 	data[0] = cpu_to_be32((device->card->node_id << 16) |
 			      (dg00x->async_handler.offset >> 32));
 	data[1] = cpu_to_be32(dg00x->async_handler.offset);
+	err = snd_fw_transaction(dg00x->unit, TCODE_WRITE_BLOCK_REQUEST,
+				 DG00X_ADDR_BASE + DG00X_OFFSET_MESSAGE_ADDR,
+				 &data, sizeof(data), 0);
+	if (err < 0)
+		return err;
+
+	/* Asynchronous transactions for MIDI control message. */
+	data[0] = cpu_to_be32((device->card->node_id << 16) |
+			      (dg00x->async_handler.offset >> 32));
+	data[1] = cpu_to_be32(dg00x->async_handler.offset + 4);
 	return snd_fw_transaction(dg00x->unit, TCODE_WRITE_BLOCK_REQUEST,
-				   DG00X_ADDR_BASE + DG00X_OFFSET_MESSAGE_ADDR,
-				   &data, sizeof(data), 0);
+				  DG00X_ADDR_BASE + DG00X_OFFSET_MIDI_CTL_ADDR,
+				  &data, sizeof(data), 0);
 }
 
 int snd_dg00x_transaction_register(struct snd_dg00x *dg00x)
@@ -57,7 +92,7 @@ int snd_dg00x_transaction_register(struct snd_dg00x *dg00x)
 	};
 	int err;
 
-	dg00x->async_handler.length = 4;
+	dg00x->async_handler.length = 12;
 	dg00x->async_handler.address_callback = handle_message;
 	dg00x->async_handler.callback_data = dg00x;
 

commit 44b7308871ac6fd85fc840bfa3ddb466fe7aff23
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Sep 30 09:39:22 2015 +0900

    ALSA: firewire-digi00x: add support for asynchronous messaging
    
    Digi 002/003 family uses asynchronous transaction for messaging.
    The address to transmit this message is stored on a certain register.
    
    This commit allocates a range of address on OHCI 1394 host controller
    to handle the messaging. As long as I know, the purpose of this message
    seems to notify lost of synchronization. While, the meaning of content
    of the message is not clear.
    
    Actual examples of this messaging:
     * When clock source is set as internal:
     - 0x00007051
     - 0x00007052
     - 0x00007054
     - 0x00007057
     - 0x00007058
     * When clock source is set as somewhat external:
     - 0x00009000
     - 0x00009010
     - 0x00009020
     - 0x00009021
     - 0x00009022
    
    The lost often occurs when using internal clock source. In this case,
    users hear sounds with quite short gap every several minutes. In fact,
    the lost is recovered temporarily.
    
    When using with external clock source, the lost seems not to occur. The
    mechanism is not clear yet.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-transaction.c b/sound/firewire/digi00x/digi00x-transaction.c
new file mode 100644
index 000000000000..49372901a1e1
--- /dev/null
+++ b/sound/firewire/digi00x/digi00x-transaction.c
@@ -0,0 +1,81 @@
+/*
+ * digi00x-transaction.c - a part of driver for Digidesign Digi 002/003 family
+ *
+ * Copyright (c) 2014-2015 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include <sound/asound.h>
+#include "digi00x.h"
+
+static void handle_unknown_message(struct snd_dg00x *dg00x,
+				   unsigned long long offset, __be32 *buf)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dg00x->lock, flags);
+	dg00x->msg = be32_to_cpu(*buf);
+	spin_unlock_irqrestore(&dg00x->lock, flags);
+
+	wake_up(&dg00x->hwdep_wait);
+}
+
+static void handle_message(struct fw_card *card, struct fw_request *request,
+			   int tcode, int destination, int source,
+			   int generation, unsigned long long offset,
+			   void *data, size_t length, void *callback_data)
+{
+	struct snd_dg00x *dg00x = callback_data;
+	__be32 *buf = (__be32 *)data;
+
+	if (offset == dg00x->async_handler.offset)
+		handle_unknown_message(dg00x, offset, buf);
+
+	fw_send_response(card, request, RCODE_COMPLETE);
+}
+
+int snd_dg00x_transaction_reregister(struct snd_dg00x *dg00x)
+{
+	struct fw_device *device = fw_parent_device(dg00x->unit);
+	__be32 data[2];
+
+	/* Unknown. 4bytes. */
+	data[0] = cpu_to_be32((device->card->node_id << 16) |
+			      (dg00x->async_handler.offset >> 32));
+	data[1] = cpu_to_be32(dg00x->async_handler.offset);
+	return snd_fw_transaction(dg00x->unit, TCODE_WRITE_BLOCK_REQUEST,
+				   DG00X_ADDR_BASE + DG00X_OFFSET_MESSAGE_ADDR,
+				   &data, sizeof(data), 0);
+}
+
+int snd_dg00x_transaction_register(struct snd_dg00x *dg00x)
+{
+	static const struct fw_address_region resp_register_region = {
+		.start	= 0xffffe0000000ull,
+		.end	= 0xffffe000ffffull,
+	};
+	int err;
+
+	dg00x->async_handler.length = 4;
+	dg00x->async_handler.address_callback = handle_message;
+	dg00x->async_handler.callback_data = dg00x;
+
+	err = fw_core_add_address_handler(&dg00x->async_handler,
+					  &resp_register_region);
+	if (err < 0)
+		return err;
+
+	err = snd_dg00x_transaction_reregister(dg00x);
+	if (err < 0) {
+		fw_core_remove_address_handler(&dg00x->async_handler);
+		dg00x->async_handler.address_callback = NULL;
+	}
+
+	return err;
+}
+
+void snd_dg00x_transaction_unregister(struct snd_dg00x *dg00x)
+{
+	fw_core_remove_address_handler(&dg00x->async_handler);
+}
