commit 76c4ecbe4b07c0d1b1aba31bf2a7f20cccbdbb4e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 00:54:18 2019 +0900

    ALSA: firewire-digi00x: share PCM buffer size for both direction
    
    This commit allows ALSA firewire-digi00x driver to share PCM buffer
    size for both capture and playback PCM substream. When AMDTP domain
    starts for one of the PCM substream, buffer size of the PCM substream
    is stores to AMDTP domain structure. Some AMDTP streams have already
    run with the buffer size when another PCM substream starts, therefore
    the PCM substream has a constraint to its buffer size.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191017155424.885-7-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index a407e795d8e7..68eb8c39afa6 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -17,7 +17,7 @@ static int midi_open(struct snd_rawmidi_substream *substream)
 		return err;
 
 	mutex_lock(&dg00x->mutex);
-	err = snd_dg00x_stream_reserve_duplex(dg00x, 0, 0);
+	err = snd_dg00x_stream_reserve_duplex(dg00x, 0, 0, 0);
 	if (err >= 0) {
 		++dg00x->substreams_counter;
 		err = snd_dg00x_stream_start_duplex(dg00x);

commit 18b7f18ff694983c69523e8136f9a256596edd59
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 7 20:05:21 2019 +0900

    ALSA: firewire-digi00x: register the size of PCM period to AMDTP domain
    
    This commit is a preparation to share the size of PCM period between
    PCM substreams on AMDTP streams in the same domain. At this time,
    the size of PCM period in PCM substream which starts AMDTP streams in the
    same domain is recorded.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191007110532.30270-7-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 2b57ece89101..a407e795d8e7 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -17,7 +17,7 @@ static int midi_open(struct snd_rawmidi_substream *substream)
 		return err;
 
 	mutex_lock(&dg00x->mutex);
-	err = snd_dg00x_stream_reserve_duplex(dg00x, 0);
+	err = snd_dg00x_stream_reserve_duplex(dg00x, 0, 0);
 	if (err >= 0) {
 		++dg00x->substreams_counter;
 		err = snd_dg00x_stream_start_duplex(dg00x);

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 64582c56a9156ce88297a89a3b8ba03754e7149a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jul 7 14:20:10 2019 +0900

    ALSA: firewire-digi00x: fix wrong reference count for stream functionality at error path of rawmidi interface
    
    In IEC 61883-6, several types of sampling data can be multiplexed into
    payload of common isochronous packet (CIP). For typical audio and music
    units, PCM samples and MIDI messages are multiplexed into one packet
    streaming.
    
    ALSA firewire-digi00x driver allows applications of rawmidi interface to
    start packet streaming for transmission of MIDI messages. However at
    error path, the reference count of stream functionality is not operated
    correctly. This can brings a bug that packet streaming is not stopped
    when all referrers release the count.
    
    This commit fixes the bug.
    
    Fixes: ae8ffbb26512 ("ALSA: firewire-digi00x: reserve/release isochronous resources in pcm.hw_params/hw_free callbacks")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index ca06ad318ed6..0563701141b8 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -22,6 +22,8 @@ static int midi_open(struct snd_rawmidi_substream *substream)
 	if (err >= 0) {
 		++dg00x->substreams_counter;
 		err = snd_dg00x_stream_start_duplex(dg00x);
+		if (err < 0)
+			--dg00x->substreams_counter;
 	}
 	mutex_unlock(&dg00x->mutex);
 	if (err < 0)

commit b9434540dd8f702c2cf33b82674e027cb779146e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jun 18 22:26:18 2019 +0900

    ALSA: firewire-digi00x: unify stop and release method for duplex streams
    
    >From callbacks for pcm and rawmidi interfaces, the functions to stop
    and release duplex streams are called at the same time. This commit
    merges the two functions.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index cca888cce0d3..ca06ad318ed6 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -37,7 +37,6 @@ static int midi_close(struct snd_rawmidi_substream *substream)
 	mutex_lock(&dg00x->mutex);
 	--dg00x->substreams_counter;
 	snd_dg00x_stream_stop_duplex(dg00x);
-	snd_dg00x_stream_release_duplex(dg00x);
 	mutex_unlock(&dg00x->mutex);
 
 	snd_dg00x_stream_lock_release(dg00x);

commit ae8ffbb26512bbfd3f929e34c85880f620ecb6eb
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jun 11 22:21:11 2019 +0900

    ALSA: firewire-digi00x: reserve/release isochronous resources in pcm.hw_params/hw_free callbacks
    
    Once allocated, isochronous resources are available for packet
    streaming, even if the streaming is cancelled. For this reason,
    current implementation handles allocation of the resources and
    starting packet streaming at the same time. However, this brings
    complicated procedure to start packet streaming.
    
    This commit separates the allocation and starting. The allocation is
    done in pcm.hw_params callback and available till pcm.hw_free callback.
    Even if any XRUN occurs, pcm.prepare callback is done to restart
    packet streaming without releasing/allocating the resources.
    
    There are two points to stop packet streaming; in pcm.hw_params and
    pcm.prepare callbacks. The former point is a case that packet streaming
    is already started for any MIDI substream then packet streaming is
    requested with different sampling transfer frequency for any PCM
    substream. The latter point is cases of any XRUN or packet queueing
    error.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 7ab3d0810f6b..cca888cce0d3 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -18,8 +18,11 @@ static int midi_open(struct snd_rawmidi_substream *substream)
 		return err;
 
 	mutex_lock(&dg00x->mutex);
-	dg00x->substreams_counter++;
-	err = snd_dg00x_stream_start_duplex(dg00x, 0);
+	err = snd_dg00x_stream_reserve_duplex(dg00x, 0);
+	if (err >= 0) {
+		++dg00x->substreams_counter;
+		err = snd_dg00x_stream_start_duplex(dg00x);
+	}
 	mutex_unlock(&dg00x->mutex);
 	if (err < 0)
 		snd_dg00x_stream_lock_release(dg00x);
@@ -32,8 +35,9 @@ static int midi_close(struct snd_rawmidi_substream *substream)
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 
 	mutex_lock(&dg00x->mutex);
-	dg00x->substreams_counter--;
+	--dg00x->substreams_counter;
 	snd_dg00x_stream_stop_duplex(dg00x);
+	snd_dg00x_stream_release_duplex(dg00x);
 	mutex_unlock(&dg00x->mutex);
 
 	snd_dg00x_stream_lock_release(dg00x);

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 7ab3d0810f6b..bf50a168087f 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * digi00x-midi.h - a part of driver for Digidesign Digi 002/003 family
  *
  * Copyright (c) 2014-2015 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "digi00x.h"

commit 0c3f15f39cfd7697e0c4979a85fef1a3c3d17248
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Apr 2 23:48:26 2017 +0900

    ALSA: firewire-digi00x: allow user space applications to read/write MIDI messages for all ports
    
    At a commit c5fcee0373b3 ("ALSA: firewire-digi00x: add MIDI operations for
    MIDI control port"), I described that MIDI messages for control surface is
    transferred by a different way from the messages for physical ports.
    However, this is wrong. MIDI messages to/from all of MIDI ports are
    transferred by isochronous packets.
    
    This commit removes codes to transfer MIDI messages via asynchronous
    transaction, from MIDI handling layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 915d2a21223e..7ab3d0810f6b 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -8,7 +8,7 @@
 
 #include "digi00x.h"
 
-static int midi_phys_open(struct snd_rawmidi_substream *substream)
+static int midi_open(struct snd_rawmidi_substream *substream)
 {
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 	int err;
@@ -27,7 +27,7 @@ static int midi_phys_open(struct snd_rawmidi_substream *substream)
 	return err;
 }
 
-static int midi_phys_close(struct snd_rawmidi_substream *substream)
+static int midi_close(struct snd_rawmidi_substream *substream)
 {
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 
@@ -40,180 +40,130 @@ static int midi_phys_close(struct snd_rawmidi_substream *substream)
 	return 0;
 }
 
-static void midi_phys_capture_trigger(struct snd_rawmidi_substream *substream,
-				      int up)
+static void midi_capture_trigger(struct snd_rawmidi_substream *substream,
+				 int up)
 {
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
+	unsigned int port;
 	unsigned long flags;
 
-	spin_lock_irqsave(&dg00x->lock, flags);
-
-	if (up)
-		amdtp_dot_midi_trigger(&dg00x->tx_stream, substream->number,
-				       substream);
+	if (substream->rmidi->device == 0)
+		port = substream->number;
 	else
-		amdtp_dot_midi_trigger(&dg00x->tx_stream, substream->number,
-				       NULL);
-
-	spin_unlock_irqrestore(&dg00x->lock, flags);
-}
-
-static void midi_phys_playback_trigger(struct snd_rawmidi_substream *substream,
-				       int up)
-{
-	struct snd_dg00x *dg00x = substream->rmidi->private_data;
-	unsigned long flags;
+		port = 2;
 
 	spin_lock_irqsave(&dg00x->lock, flags);
 
 	if (up)
-		amdtp_dot_midi_trigger(&dg00x->rx_stream, substream->number,
-				       substream);
+		amdtp_dot_midi_trigger(&dg00x->tx_stream, port, substream);
 	else
-		amdtp_dot_midi_trigger(&dg00x->rx_stream, substream->number,
-				       NULL);
+		amdtp_dot_midi_trigger(&dg00x->tx_stream, port, NULL);
 
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
 
-static int midi_ctl_open(struct snd_rawmidi_substream *substream)
-{
-	/* Do nothing. */
-	return 0;
-}
-
-static int midi_ctl_capture_close(struct snd_rawmidi_substream *substream)
-{
-	/* Do nothing. */
-	return 0;
-}
-
-static int midi_ctl_playback_close(struct snd_rawmidi_substream *substream)
-{
-	struct snd_dg00x *dg00x = substream->rmidi->private_data;
-
-	snd_fw_async_midi_port_finish(&dg00x->out_control);
-
-	return 0;
-}
-
-static void midi_ctl_capture_trigger(struct snd_rawmidi_substream *substream,
-				     int up)
+static void midi_playback_trigger(struct snd_rawmidi_substream *substream,
+				  int up)
 {
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
+	unsigned int port;
 	unsigned long flags;
 
-	spin_lock_irqsave(&dg00x->lock, flags);
-
-	if (up)
-		dg00x->in_control = substream;
+	if (substream->rmidi->device == 0)
+		port = substream->number;
 	else
-		dg00x->in_control = NULL;
-
-	spin_unlock_irqrestore(&dg00x->lock, flags);
-}
-
-static void midi_ctl_playback_trigger(struct snd_rawmidi_substream *substream,
-				      int up)
-{
-	struct snd_dg00x *dg00x = substream->rmidi->private_data;
-	unsigned long flags;
+		port = 2;
 
 	spin_lock_irqsave(&dg00x->lock, flags);
 
 	if (up)
-		snd_fw_async_midi_port_run(&dg00x->out_control, substream);
+		amdtp_dot_midi_trigger(&dg00x->rx_stream, port, substream);
+	else
+		amdtp_dot_midi_trigger(&dg00x->rx_stream, port, NULL);
 
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
 
-static void set_midi_substream_names(struct snd_dg00x *dg00x,
-				     struct snd_rawmidi_str *str,
-				     bool is_ctl)
+static void set_substream_names(struct snd_dg00x *dg00x,
+				struct snd_rawmidi *rmidi, bool is_console)
 {
 	struct snd_rawmidi_substream *subs;
-
-	list_for_each_entry(subs, &str->substreams, list) {
-		if (!is_ctl)
-			snprintf(subs->name, sizeof(subs->name),
-				 "%s MIDI %d",
-				 dg00x->card->shortname, subs->number + 1);
-		else
-			/* This port is for asynchronous transaction. */
-			snprintf(subs->name, sizeof(subs->name),
-				 "%s control",
-				 dg00x->card->shortname);
+	struct snd_rawmidi_str *str;
+	int i;
+
+	for (i = 0; i < 2; ++i) {
+		str = &rmidi->streams[i];
+
+		list_for_each_entry(subs, &str->substreams, list) {
+			if (!is_console) {
+				snprintf(subs->name, sizeof(subs->name),
+					 "%s MIDI %d",
+					 dg00x->card->shortname,
+					 subs->number + 1);
+			} else {
+				snprintf(subs->name, sizeof(subs->name),
+					 "%s control",
+					 dg00x->card->shortname);
+			}
+		}
 	}
 }
 
-int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
+static int add_substream_pair(struct snd_dg00x *dg00x, unsigned int out_ports,
+			      unsigned int in_ports, bool is_console)
 {
-	static const struct snd_rawmidi_ops phys_capture_ops = {
-		.open		= midi_phys_open,
-		.close		= midi_phys_close,
-		.trigger	= midi_phys_capture_trigger,
-	};
-	static const struct snd_rawmidi_ops phys_playback_ops = {
-		.open		= midi_phys_open,
-		.close		= midi_phys_close,
-		.trigger	= midi_phys_playback_trigger,
+	static const struct snd_rawmidi_ops capture_ops = {
+		.open = midi_open,
+		.close = midi_close,
+		.trigger = midi_capture_trigger,
 	};
-	static const struct snd_rawmidi_ops ctl_capture_ops = {
-		.open		= midi_ctl_open,
-		.close		= midi_ctl_capture_close,
-		.trigger	= midi_ctl_capture_trigger,
+	static const struct snd_rawmidi_ops playback_ops = {
+		.open = midi_open,
+		.close = midi_close,
+		.trigger = midi_playback_trigger,
 	};
-	static const struct snd_rawmidi_ops ctl_playback_ops = {
-		.open		= midi_ctl_open,
-		.close		= midi_ctl_playback_close,
-		.trigger	= midi_ctl_playback_trigger,
-	};
-	struct snd_rawmidi *rmidi[2];
-	struct snd_rawmidi_str *str;
-	unsigned int i;
+	const char *label;
+	struct snd_rawmidi *rmidi;
 	int err;
 
 	/* Add physical midi ports. */
-	err = snd_rawmidi_new(dg00x->card, dg00x->card->driver, 0,
-			DOT_MIDI_OUT_PORTS, DOT_MIDI_IN_PORTS, &rmidi[0]);
+	err = snd_rawmidi_new(dg00x->card, dg00x->card->driver, is_console,
+			      out_ports, in_ports, &rmidi);
 	if (err < 0)
 		return err;
+	rmidi->private_data = dg00x;
 
-	snprintf(rmidi[0]->name, sizeof(rmidi[0]->name),
-		 "%s MIDI", dg00x->card->shortname);
-
-	snd_rawmidi_set_ops(rmidi[0], SNDRV_RAWMIDI_STREAM_INPUT,
-			    &phys_capture_ops);
-	snd_rawmidi_set_ops(rmidi[0], SNDRV_RAWMIDI_STREAM_OUTPUT,
-			    &phys_playback_ops);
+	if (!is_console)
+		label = "%s control";
+	else
+		label = "%s MIDI";
+	snprintf(rmidi->name, sizeof(rmidi->name), label,
+		 dg00x->card->shortname);
 
-	/* Add a pair of control midi ports. */
-	err = snd_rawmidi_new(dg00x->card, dg00x->card->driver, 1,
-			      1, 1, &rmidi[1]);
-	if (err < 0)
-		return err;
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &playback_ops);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &capture_ops);
 
-	snprintf(rmidi[1]->name, sizeof(rmidi[1]->name),
-		 "%s control", dg00x->card->shortname);
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT |
+			     SNDRV_RAWMIDI_INFO_OUTPUT |
+			     SNDRV_RAWMIDI_INFO_DUPLEX;
 
-	snd_rawmidi_set_ops(rmidi[1], SNDRV_RAWMIDI_STREAM_INPUT,
-			    &ctl_capture_ops);
-	snd_rawmidi_set_ops(rmidi[1], SNDRV_RAWMIDI_STREAM_OUTPUT,
-			    &ctl_playback_ops);
+	set_substream_names(dg00x, rmidi, is_console);
 
-	for (i = 0; i < ARRAY_SIZE(rmidi); i++) {
-		rmidi[i]->private_data = dg00x;
+	return 0;
+}
 
-		rmidi[i]->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;
-		str = &rmidi[i]->streams[SNDRV_RAWMIDI_STREAM_INPUT];
-		set_midi_substream_names(dg00x, str, i);
+int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
+{
+	int err;
 
-		rmidi[i]->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;
-		str = &rmidi[i]->streams[SNDRV_RAWMIDI_STREAM_OUTPUT];
-		set_midi_substream_names(dg00x, str, i);
+	/* Add physical midi ports. */
+	err = add_substream_pair(dg00x, DOT_MIDI_OUT_PORTS, DOT_MIDI_IN_PORTS,
+				 false);
+	if (err < 0)
+		return err;
 
-		rmidi[i]->info_flags |= SNDRV_RAWMIDI_INFO_DUPLEX;
-	}
+	if (dg00x->is_console)
+		err = add_substream_pair(dg00x, 1, 1, true);
 
-	return 0;
+	return err;
 }

commit 57eb67994a9d117ea81d1580a9163733e26a1fc3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 5 17:29:54 2017 +0100

    ALSA: firewire: Constify snd_rawmidi_ops
    
    Now snd_rawmidi_ops is maintained as a const pointer in snd_rawmidi,
    we can constify the definitions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 8689c3bb4c6a..915d2a21223e 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -148,22 +148,22 @@ static void set_midi_substream_names(struct snd_dg00x *dg00x,
 
 int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
 {
-	static struct snd_rawmidi_ops phys_capture_ops = {
+	static const struct snd_rawmidi_ops phys_capture_ops = {
 		.open		= midi_phys_open,
 		.close		= midi_phys_close,
 		.trigger	= midi_phys_capture_trigger,
 	};
-	static struct snd_rawmidi_ops phys_playback_ops = {
+	static const struct snd_rawmidi_ops phys_playback_ops = {
 		.open		= midi_phys_open,
 		.close		= midi_phys_close,
 		.trigger	= midi_phys_playback_trigger,
 	};
-	static struct snd_rawmidi_ops ctl_capture_ops = {
+	static const struct snd_rawmidi_ops ctl_capture_ops = {
 		.open		= midi_ctl_open,
 		.close		= midi_ctl_capture_close,
 		.trigger	= midi_ctl_capture_trigger,
 	};
-	static struct snd_rawmidi_ops ctl_playback_ops = {
+	static const struct snd_rawmidi_ops ctl_playback_ops = {
 		.open		= midi_ctl_open,
 		.close		= midi_ctl_playback_close,
 		.trigger	= midi_ctl_playback_trigger,

commit a4e86cba09c9e2bb64af018544a7aed4a6a1b538
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Jan 5 21:48:11 2017 +0900

    ALSA: firewire-digi00x: enclose identifiers referred by single function
    
    Some identifiers are referred just by one functions. In this case, they
    can be put into the function definition. This brings two merits; readers
    can easily follow codes related to the identifiers, developers are free
    from name conflict.
    
    This commit moves such identifiers to each function definition.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 1a72a382b384..8689c3bb4c6a 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -76,18 +76,6 @@ static void midi_phys_playback_trigger(struct snd_rawmidi_substream *substream,
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
 
-static struct snd_rawmidi_ops midi_phys_capture_ops = {
-	.open		= midi_phys_open,
-	.close		= midi_phys_close,
-	.trigger	= midi_phys_capture_trigger,
-};
-
-static struct snd_rawmidi_ops midi_phys_playback_ops = {
-	.open		= midi_phys_open,
-	.close		= midi_phys_close,
-	.trigger	= midi_phys_playback_trigger,
-};
-
 static int midi_ctl_open(struct snd_rawmidi_substream *substream)
 {
 	/* Do nothing. */
@@ -139,18 +127,6 @@ static void midi_ctl_playback_trigger(struct snd_rawmidi_substream *substream,
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
 
-static struct snd_rawmidi_ops midi_ctl_capture_ops = {
-	.open		= midi_ctl_open,
-	.close		= midi_ctl_capture_close,
-	.trigger	= midi_ctl_capture_trigger,
-};
-
-static struct snd_rawmidi_ops midi_ctl_playback_ops = {
-	.open		= midi_ctl_open,
-	.close		= midi_ctl_playback_close,
-	.trigger	= midi_ctl_playback_trigger,
-};
-
 static void set_midi_substream_names(struct snd_dg00x *dg00x,
 				     struct snd_rawmidi_str *str,
 				     bool is_ctl)
@@ -172,6 +148,26 @@ static void set_midi_substream_names(struct snd_dg00x *dg00x,
 
 int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
 {
+	static struct snd_rawmidi_ops phys_capture_ops = {
+		.open		= midi_phys_open,
+		.close		= midi_phys_close,
+		.trigger	= midi_phys_capture_trigger,
+	};
+	static struct snd_rawmidi_ops phys_playback_ops = {
+		.open		= midi_phys_open,
+		.close		= midi_phys_close,
+		.trigger	= midi_phys_playback_trigger,
+	};
+	static struct snd_rawmidi_ops ctl_capture_ops = {
+		.open		= midi_ctl_open,
+		.close		= midi_ctl_capture_close,
+		.trigger	= midi_ctl_capture_trigger,
+	};
+	static struct snd_rawmidi_ops ctl_playback_ops = {
+		.open		= midi_ctl_open,
+		.close		= midi_ctl_playback_close,
+		.trigger	= midi_ctl_playback_trigger,
+	};
 	struct snd_rawmidi *rmidi[2];
 	struct snd_rawmidi_str *str;
 	unsigned int i;
@@ -187,9 +183,9 @@ int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
 		 "%s MIDI", dg00x->card->shortname);
 
 	snd_rawmidi_set_ops(rmidi[0], SNDRV_RAWMIDI_STREAM_INPUT,
-			    &midi_phys_capture_ops);
+			    &phys_capture_ops);
 	snd_rawmidi_set_ops(rmidi[0], SNDRV_RAWMIDI_STREAM_OUTPUT,
-			    &midi_phys_playback_ops);
+			    &phys_playback_ops);
 
 	/* Add a pair of control midi ports. */
 	err = snd_rawmidi_new(dg00x->card, dg00x->card->driver, 1,
@@ -201,9 +197,9 @@ int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
 		 "%s control", dg00x->card->shortname);
 
 	snd_rawmidi_set_ops(rmidi[1], SNDRV_RAWMIDI_STREAM_INPUT,
-			    &midi_ctl_capture_ops);
+			    &ctl_capture_ops);
 	snd_rawmidi_set_ops(rmidi[1], SNDRV_RAWMIDI_STREAM_OUTPUT,
-			    &midi_ctl_playback_ops);
+			    &ctl_playback_ops);
 
 	for (i = 0; i < ARRAY_SIZE(rmidi); i++) {
 		rmidi[i]->private_data = dg00x;

commit d1482fb335b8f3f5e667df72b043c5b3d9d03106
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Oct 31 02:43:16 2015 +0900

    ALSA: firewire-digi00x: add another rawmidi character device for MIDI control ports
    
    Digi 002/003 family uses two ways to transfer MIDI messages. They're
    different mechanisms, while it's better to handle the ways in different
    ALSA rawmidi character devices because one character device has just a
    set of operations.
    
    This commit adds another rawmidi character device for control MIDI port. As
    a result, first rawmidi character device is just for MIDI messages
    transferred by isochronous packets.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 527f4b31f5c6..1a72a382b384 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -13,10 +13,6 @@ static int midi_phys_open(struct snd_rawmidi_substream *substream)
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 	int err;
 
-	/* This port is for asynchronous transaction. */
-	if (substream->number == 0)
-		return 0;
-
 	err = snd_dg00x_stream_lock_try(dg00x);
 	if (err < 0)
 		return err;
@@ -35,10 +31,6 @@ static int midi_phys_close(struct snd_rawmidi_substream *substream)
 {
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 
-	/* This port is for asynchronous transaction. */
-	if (substream->number == 0)
-		return 0;
-
 	mutex_lock(&dg00x->mutex);
 	dg00x->substreams_counter--;
 	snd_dg00x_stream_stop_duplex(dg00x);
@@ -56,21 +48,12 @@ static void midi_phys_capture_trigger(struct snd_rawmidi_substream *substream,
 
 	spin_lock_irqsave(&dg00x->lock, flags);
 
-	/* This port is for asynchronous transaction. */
-	if (substream->number == 0) {
-		if (up)
-			dg00x->in_control = substream;
-		else
-			dg00x->in_control = NULL;
-	} else {
-		if (up)
-			amdtp_dot_midi_trigger(&dg00x->tx_stream,
-					       substream->number - 1,
-					       substream);
-		else
-			amdtp_dot_midi_trigger(&dg00x->tx_stream,
-					       substream->number - 1, NULL);
-	}
+	if (up)
+		amdtp_dot_midi_trigger(&dg00x->tx_stream, substream->number,
+				       substream);
+	else
+		amdtp_dot_midi_trigger(&dg00x->tx_stream, substream->number,
+				       NULL);
 
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
@@ -83,20 +66,12 @@ static void midi_phys_playback_trigger(struct snd_rawmidi_substream *substream,
 
 	spin_lock_irqsave(&dg00x->lock, flags);
 
-	/* This port is for asynchronous transaction. */
-	if (substream->number == 0) {
-		if (up)
-			snd_fw_async_midi_port_run(&dg00x->out_control,
-						   substream);
-	} else {
-		if (up)
-			amdtp_dot_midi_trigger(&dg00x->rx_stream,
-					       substream->number - 1,
-					       substream);
-		else
-			amdtp_dot_midi_trigger(&dg00x->rx_stream,
-					       substream->number - 1, NULL);
-	}
+	if (up)
+		amdtp_dot_midi_trigger(&dg00x->rx_stream, substream->number,
+				       substream);
+	else
+		amdtp_dot_midi_trigger(&dg00x->rx_stream, substream->number,
+				       NULL);
 
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
@@ -177,15 +152,16 @@ static struct snd_rawmidi_ops midi_ctl_playback_ops = {
 };
 
 static void set_midi_substream_names(struct snd_dg00x *dg00x,
-				     struct snd_rawmidi_str *str)
+				     struct snd_rawmidi_str *str,
+				     bool is_ctl)
 {
 	struct snd_rawmidi_substream *subs;
 
 	list_for_each_entry(subs, &str->substreams, list) {
-		if (subs->number > 0)
+		if (!is_ctl)
 			snprintf(subs->name, sizeof(subs->name),
 				 "%s MIDI %d",
-				 dg00x->card->shortname, subs->number);
+				 dg00x->card->shortname, subs->number + 1);
 		else
 			/* This port is for asynchronous transaction. */
 			snprintf(subs->name, sizeof(subs->name),
@@ -196,32 +172,52 @@ static void set_midi_substream_names(struct snd_dg00x *dg00x,
 
 int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
 {
-	struct snd_rawmidi *rmidi;
+	struct snd_rawmidi *rmidi[2];
 	struct snd_rawmidi_str *str;
+	unsigned int i;
 	int err;
 
+	/* Add physical midi ports. */
 	err = snd_rawmidi_new(dg00x->card, dg00x->card->driver, 0,
-			DOT_MIDI_OUT_PORTS + 1, DOT_MIDI_IN_PORTS + 1, &rmidi);
+			DOT_MIDI_OUT_PORTS, DOT_MIDI_IN_PORTS, &rmidi[0]);
 	if (err < 0)
 		return err;
 
-	snprintf(rmidi->name, sizeof(rmidi->name),
+	snprintf(rmidi[0]->name, sizeof(rmidi[0]->name),
 		 "%s MIDI", dg00x->card->shortname);
-	rmidi->private_data = dg00x;
 
-	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;
-	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
+	snd_rawmidi_set_ops(rmidi[0], SNDRV_RAWMIDI_STREAM_INPUT,
 			    &midi_phys_capture_ops);
-	str = &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT];
-	set_midi_substream_names(dg00x, str);
-
-	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;
-	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
+	snd_rawmidi_set_ops(rmidi[0], SNDRV_RAWMIDI_STREAM_OUTPUT,
 			    &midi_phys_playback_ops);
-	str = &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT];
-	set_midi_substream_names(dg00x, str);
 
-	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_DUPLEX;
+	/* Add a pair of control midi ports. */
+	err = snd_rawmidi_new(dg00x->card, dg00x->card->driver, 1,
+			      1, 1, &rmidi[1]);
+	if (err < 0)
+		return err;
+
+	snprintf(rmidi[1]->name, sizeof(rmidi[1]->name),
+		 "%s control", dg00x->card->shortname);
+
+	snd_rawmidi_set_ops(rmidi[1], SNDRV_RAWMIDI_STREAM_INPUT,
+			    &midi_ctl_capture_ops);
+	snd_rawmidi_set_ops(rmidi[1], SNDRV_RAWMIDI_STREAM_OUTPUT,
+			    &midi_ctl_playback_ops);
+
+	for (i = 0; i < ARRAY_SIZE(rmidi); i++) {
+		rmidi[i]->private_data = dg00x;
+
+		rmidi[i]->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;
+		str = &rmidi[i]->streams[SNDRV_RAWMIDI_STREAM_INPUT];
+		set_midi_substream_names(dg00x, str, i);
+
+		rmidi[i]->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;
+		str = &rmidi[i]->streams[SNDRV_RAWMIDI_STREAM_OUTPUT];
+		set_midi_substream_names(dg00x, str, i);
+
+		rmidi[i]->info_flags |= SNDRV_RAWMIDI_INFO_DUPLEX;
+	}
 
 	return 0;
 }

commit c5fcee0373b390ab8508022951eabd0bd0e06a48
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Oct 31 02:43:15 2015 +0900

    ALSA: firewire-digi00x: add MIDI operations for MIDI control port
    
    Digi 002/003 family has two types of MIDI port; one is for physical MIDI
    port and another is for MIDI control message. The former is transferred in
    isochronous packet, and the latter is transferred by asynchronous
    transaction. These transmission mechanisms are completely different, while
    current ALSA digi00x driver defines a set of operations for them with
    several condition statements. As a result, codes for the operation are
    messy.
    
    This commit adds a set of MIDI operation for control MIDI ports. In later
    commit, it's applied as an operation for ALSA rawmidi character device.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 1d649e3975a0..527f4b31f5c6 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -113,6 +113,69 @@ static struct snd_rawmidi_ops midi_phys_playback_ops = {
 	.trigger	= midi_phys_playback_trigger,
 };
 
+static int midi_ctl_open(struct snd_rawmidi_substream *substream)
+{
+	/* Do nothing. */
+	return 0;
+}
+
+static int midi_ctl_capture_close(struct snd_rawmidi_substream *substream)
+{
+	/* Do nothing. */
+	return 0;
+}
+
+static int midi_ctl_playback_close(struct snd_rawmidi_substream *substream)
+{
+	struct snd_dg00x *dg00x = substream->rmidi->private_data;
+
+	snd_fw_async_midi_port_finish(&dg00x->out_control);
+
+	return 0;
+}
+
+static void midi_ctl_capture_trigger(struct snd_rawmidi_substream *substream,
+				     int up)
+{
+	struct snd_dg00x *dg00x = substream->rmidi->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dg00x->lock, flags);
+
+	if (up)
+		dg00x->in_control = substream;
+	else
+		dg00x->in_control = NULL;
+
+	spin_unlock_irqrestore(&dg00x->lock, flags);
+}
+
+static void midi_ctl_playback_trigger(struct snd_rawmidi_substream *substream,
+				      int up)
+{
+	struct snd_dg00x *dg00x = substream->rmidi->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dg00x->lock, flags);
+
+	if (up)
+		snd_fw_async_midi_port_run(&dg00x->out_control, substream);
+
+	spin_unlock_irqrestore(&dg00x->lock, flags);
+}
+
+static struct snd_rawmidi_ops midi_ctl_capture_ops = {
+	.open		= midi_ctl_open,
+	.close		= midi_ctl_capture_close,
+	.trigger	= midi_ctl_capture_trigger,
+};
+
+static struct snd_rawmidi_ops midi_ctl_playback_ops = {
+	.open		= midi_ctl_open,
+	.close		= midi_ctl_playback_close,
+	.trigger	= midi_ctl_playback_trigger,
+};
+
 static void set_midi_substream_names(struct snd_dg00x *dg00x,
 				     struct snd_rawmidi_str *str)
 {

commit 5918f962207329089371d87adbd033830d3f5cf5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Oct 31 02:43:14 2015 +0900

    ALSA: firewire-digi00x: rename identifiers of MIDI operation for physical ports
    
    In following commit, new functions and variables are added for operations
    of MIDI control port.
    
    This commit is a preparation. Current identifiers are renamed so that they
    mean physical MIDI ports.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 9aa8b4623108..1d649e3975a0 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -8,7 +8,7 @@
 
 #include "digi00x.h"
 
-static int midi_open(struct snd_rawmidi_substream *substream)
+static int midi_phys_open(struct snd_rawmidi_substream *substream)
 {
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 	int err;
@@ -31,7 +31,7 @@ static int midi_open(struct snd_rawmidi_substream *substream)
 	return err;
 }
 
-static int midi_close(struct snd_rawmidi_substream *substream)
+static int midi_phys_close(struct snd_rawmidi_substream *substream)
 {
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 
@@ -48,65 +48,69 @@ static int midi_close(struct snd_rawmidi_substream *substream)
 	return 0;
 }
 
-static void midi_capture_trigger(struct snd_rawmidi_substream *substrm, int up)
+static void midi_phys_capture_trigger(struct snd_rawmidi_substream *substream,
+				      int up)
 {
-	struct snd_dg00x *dg00x = substrm->rmidi->private_data;
+	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dg00x->lock, flags);
 
 	/* This port is for asynchronous transaction. */
-	if (substrm->number == 0) {
+	if (substream->number == 0) {
 		if (up)
-			dg00x->in_control = substrm;
+			dg00x->in_control = substream;
 		else
 			dg00x->in_control = NULL;
 	} else {
 		if (up)
 			amdtp_dot_midi_trigger(&dg00x->tx_stream,
-					       substrm->number - 1, substrm);
+					       substream->number - 1,
+					       substream);
 		else
 			amdtp_dot_midi_trigger(&dg00x->tx_stream,
-					       substrm->number - 1, NULL);
+					       substream->number - 1, NULL);
 	}
 
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
 
-static void midi_playback_trigger(struct snd_rawmidi_substream *substrm, int up)
+static void midi_phys_playback_trigger(struct snd_rawmidi_substream *substream,
+				       int up)
 {
-	struct snd_dg00x *dg00x = substrm->rmidi->private_data;
+	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&dg00x->lock, flags);
 
 	/* This port is for asynchronous transaction. */
-	if (substrm->number == 0) {
+	if (substream->number == 0) {
 		if (up)
 			snd_fw_async_midi_port_run(&dg00x->out_control,
-						   substrm);
+						   substream);
 	} else {
 		if (up)
 			amdtp_dot_midi_trigger(&dg00x->rx_stream,
-					       substrm->number - 1, substrm);
+					       substream->number - 1,
+					       substream);
 		else
 			amdtp_dot_midi_trigger(&dg00x->rx_stream,
-					       substrm->number - 1, NULL);
+					       substream->number - 1, NULL);
 	}
 
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
 
-static struct snd_rawmidi_ops midi_capture_ops = {
-	.open		= midi_open,
-	.close		= midi_close,
-	.trigger	= midi_capture_trigger,
+static struct snd_rawmidi_ops midi_phys_capture_ops = {
+	.open		= midi_phys_open,
+	.close		= midi_phys_close,
+	.trigger	= midi_phys_capture_trigger,
 };
 
-static struct snd_rawmidi_ops midi_playback_ops = {
-	.open		= midi_open,
-	.close		= midi_close,
-	.trigger	= midi_playback_trigger,
+static struct snd_rawmidi_ops midi_phys_playback_ops = {
+	.open		= midi_phys_open,
+	.close		= midi_phys_close,
+	.trigger	= midi_phys_playback_trigger,
 };
 
 static void set_midi_substream_names(struct snd_dg00x *dg00x,
@@ -144,13 +148,13 @@ int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
 
 	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;
 	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
-			    &midi_capture_ops);
+			    &midi_phys_capture_ops);
 	str = &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT];
 	set_midi_substream_names(dg00x, str);
 
 	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;
 	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
-			    &midi_playback_ops);
+			    &midi_phys_playback_ops);
 	str = &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT];
 	set_midi_substream_names(dg00x, str);
 

commit e8bd577ae6df59160cd6fd82b8d3562bbbdd3c1d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 11 12:30:19 2015 +0900

    ALSA: firewire-digi00x: add support for MIDI ports for physical controls
    
    In former commits, asynchronous transactions are supported for physical
    controls. This commit adds a pair of MIDI ports for them.
    
    This driver already adds diferrent number of ALSA MIDI ports for physical
    MIDI ports, and the number of in/out ports are different. As seeing as
    'amidi' program in alsa-utils package, a pair of in/out MIDI ports is
    expected with the same name. Therefore, this commit adds a pair of new
    ports to the first.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
index 4e258ac8438b..9aa8b4623108 100644
--- a/sound/firewire/digi00x/digi00x-midi.c
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -13,6 +13,10 @@ static int midi_open(struct snd_rawmidi_substream *substream)
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 	int err;
 
+	/* This port is for asynchronous transaction. */
+	if (substream->number == 0)
+		return 0;
+
 	err = snd_dg00x_stream_lock_try(dg00x);
 	if (err < 0)
 		return err;
@@ -31,6 +35,10 @@ static int midi_close(struct snd_rawmidi_substream *substream)
 {
 	struct snd_dg00x *dg00x = substream->rmidi->private_data;
 
+	/* This port is for asynchronous transaction. */
+	if (substream->number == 0)
+		return 0;
+
 	mutex_lock(&dg00x->mutex);
 	dg00x->substreams_counter--;
 	snd_dg00x_stream_stop_duplex(dg00x);
@@ -47,12 +55,20 @@ static void midi_capture_trigger(struct snd_rawmidi_substream *substrm, int up)
 
 	spin_lock_irqsave(&dg00x->lock, flags);
 
-	if (up)
-		amdtp_dot_midi_trigger(&dg00x->tx_stream,
-				       substrm->number, substrm);
-	else
-		amdtp_dot_midi_trigger(&dg00x->tx_stream,
-				       substrm->number, NULL);
+	/* This port is for asynchronous transaction. */
+	if (substrm->number == 0) {
+		if (up)
+			dg00x->in_control = substrm;
+		else
+			dg00x->in_control = NULL;
+	} else {
+		if (up)
+			amdtp_dot_midi_trigger(&dg00x->tx_stream,
+					       substrm->number - 1, substrm);
+		else
+			amdtp_dot_midi_trigger(&dg00x->tx_stream,
+					       substrm->number - 1, NULL);
+	}
 
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
@@ -64,12 +80,19 @@ static void midi_playback_trigger(struct snd_rawmidi_substream *substrm, int up)
 
 	spin_lock_irqsave(&dg00x->lock, flags);
 
-	if (up)
-		amdtp_dot_midi_trigger(&dg00x->rx_stream,
-				       substrm->number, substrm);
-	else
-		amdtp_dot_midi_trigger(&dg00x->rx_stream,
-				       substrm->number, NULL);
+	/* This port is for asynchronous transaction. */
+	if (substrm->number == 0) {
+		if (up)
+			snd_fw_async_midi_port_run(&dg00x->out_control,
+						   substrm);
+	} else {
+		if (up)
+			amdtp_dot_midi_trigger(&dg00x->rx_stream,
+					       substrm->number - 1, substrm);
+		else
+			amdtp_dot_midi_trigger(&dg00x->rx_stream,
+					       substrm->number - 1, NULL);
+	}
 
 	spin_unlock_irqrestore(&dg00x->lock, flags);
 }
@@ -92,9 +115,15 @@ static void set_midi_substream_names(struct snd_dg00x *dg00x,
 	struct snd_rawmidi_substream *subs;
 
 	list_for_each_entry(subs, &str->substreams, list) {
-		snprintf(subs->name, sizeof(subs->name),
-			 "%s MIDI %d",
-			 dg00x->card->shortname, subs->number + 1);
+		if (subs->number > 0)
+			snprintf(subs->name, sizeof(subs->name),
+				 "%s MIDI %d",
+				 dg00x->card->shortname, subs->number);
+		else
+			/* This port is for asynchronous transaction. */
+			snprintf(subs->name, sizeof(subs->name),
+				 "%s control",
+				 dg00x->card->shortname);
 	}
 }
 
@@ -105,7 +134,7 @@ int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
 	int err;
 
 	err = snd_rawmidi_new(dg00x->card, dg00x->card->driver, 0,
-			      DOT_MIDI_OUT_PORTS, DOT_MIDI_IN_PORTS, &rmidi);
+			DOT_MIDI_OUT_PORTS + 1, DOT_MIDI_IN_PORTS + 1, &rmidi);
 	if (err < 0)
 		return err;
 

commit 9fbfd38b204a3f04272183c0258a3ded03a5aae8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 11 12:30:16 2015 +0900

    ALSA: firewire-digi00x: add support for MIDI ports corresponding to isochronous packet streaming
    
    This commit adds MIDI functionality to capture/playback MIDI messages
    from/to physical MIDI ports. These messages are transferred in isochronous
    packets.
    
    When no substreams request AMDTP streams to run, this driver starts the
    streams at current sampling rate. When other substreams start at different
    sampling rate, the streams are stopped temporarily, then start again at
    requested sampling rate. This operation can generate missing MIDI bytes,
    thus it's preferable to start PCM substreams at favorite sampling rate in
    advance.
    
    Digi 002/003 console also has a set of MIDI port for physical controls.
    These ports are added in later commits.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/digi00x/digi00x-midi.c b/sound/firewire/digi00x/digi00x-midi.c
new file mode 100644
index 000000000000..4e258ac8438b
--- /dev/null
+++ b/sound/firewire/digi00x/digi00x-midi.c
@@ -0,0 +1,131 @@
+/*
+ * digi00x-midi.h - a part of driver for Digidesign Digi 002/003 family
+ *
+ * Copyright (c) 2014-2015 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "digi00x.h"
+
+static int midi_open(struct snd_rawmidi_substream *substream)
+{
+	struct snd_dg00x *dg00x = substream->rmidi->private_data;
+	int err;
+
+	err = snd_dg00x_stream_lock_try(dg00x);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&dg00x->mutex);
+	dg00x->substreams_counter++;
+	err = snd_dg00x_stream_start_duplex(dg00x, 0);
+	mutex_unlock(&dg00x->mutex);
+	if (err < 0)
+		snd_dg00x_stream_lock_release(dg00x);
+
+	return err;
+}
+
+static int midi_close(struct snd_rawmidi_substream *substream)
+{
+	struct snd_dg00x *dg00x = substream->rmidi->private_data;
+
+	mutex_lock(&dg00x->mutex);
+	dg00x->substreams_counter--;
+	snd_dg00x_stream_stop_duplex(dg00x);
+	mutex_unlock(&dg00x->mutex);
+
+	snd_dg00x_stream_lock_release(dg00x);
+	return 0;
+}
+
+static void midi_capture_trigger(struct snd_rawmidi_substream *substrm, int up)
+{
+	struct snd_dg00x *dg00x = substrm->rmidi->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dg00x->lock, flags);
+
+	if (up)
+		amdtp_dot_midi_trigger(&dg00x->tx_stream,
+				       substrm->number, substrm);
+	else
+		amdtp_dot_midi_trigger(&dg00x->tx_stream,
+				       substrm->number, NULL);
+
+	spin_unlock_irqrestore(&dg00x->lock, flags);
+}
+
+static void midi_playback_trigger(struct snd_rawmidi_substream *substrm, int up)
+{
+	struct snd_dg00x *dg00x = substrm->rmidi->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dg00x->lock, flags);
+
+	if (up)
+		amdtp_dot_midi_trigger(&dg00x->rx_stream,
+				       substrm->number, substrm);
+	else
+		amdtp_dot_midi_trigger(&dg00x->rx_stream,
+				       substrm->number, NULL);
+
+	spin_unlock_irqrestore(&dg00x->lock, flags);
+}
+
+static struct snd_rawmidi_ops midi_capture_ops = {
+	.open		= midi_open,
+	.close		= midi_close,
+	.trigger	= midi_capture_trigger,
+};
+
+static struct snd_rawmidi_ops midi_playback_ops = {
+	.open		= midi_open,
+	.close		= midi_close,
+	.trigger	= midi_playback_trigger,
+};
+
+static void set_midi_substream_names(struct snd_dg00x *dg00x,
+				     struct snd_rawmidi_str *str)
+{
+	struct snd_rawmidi_substream *subs;
+
+	list_for_each_entry(subs, &str->substreams, list) {
+		snprintf(subs->name, sizeof(subs->name),
+			 "%s MIDI %d",
+			 dg00x->card->shortname, subs->number + 1);
+	}
+}
+
+int snd_dg00x_create_midi_devices(struct snd_dg00x *dg00x)
+{
+	struct snd_rawmidi *rmidi;
+	struct snd_rawmidi_str *str;
+	int err;
+
+	err = snd_rawmidi_new(dg00x->card, dg00x->card->driver, 0,
+			      DOT_MIDI_OUT_PORTS, DOT_MIDI_IN_PORTS, &rmidi);
+	if (err < 0)
+		return err;
+
+	snprintf(rmidi->name, sizeof(rmidi->name),
+		 "%s MIDI", dg00x->card->shortname);
+	rmidi->private_data = dg00x;
+
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
+			    &midi_capture_ops);
+	str = &rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT];
+	set_midi_substream_names(dg00x, str);
+
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
+			    &midi_playback_ops);
+	str = &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT];
+	set_midi_substream_names(dg00x, str);
+
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_DUPLEX;
+
+	return 0;
+}
