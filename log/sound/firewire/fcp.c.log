commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/fcp.c b/sound/firewire/fcp.c
index 61dda828f767..bbfbebf4affb 100644
--- a/sound/firewire/fcp.c
+++ b/sound/firewire/fcp.c
@@ -1,8 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Function Control Protocol (IEC 61883-1) helper functions
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include <linux/device.h>

commit 7e1621de146fbed6172252f14a6a41b2c5999a93
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Apr 3 21:13:55 2017 +0900

    ALSA: firewire-lib/bebob/oxfw: improve response evaluation for AV/C commands
    
    In ALSA firewire stack, some AV/C commands are supported, including
    vendor's extensions. Drivers includes response parser of each command,
    according to its requirements, while the parser is written with loose
    fashion in two points; error check and length check. This doesn't cause
    any issues such as kernel corruption, but should be improved.
    
    This commit modifies evaluations of return value on each parsers.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fcp.c b/sound/firewire/fcp.c
index cce19768f43d..61dda828f767 100644
--- a/sound/firewire/fcp.c
+++ b/sound/firewire/fcp.c
@@ -63,7 +63,9 @@ int avc_general_set_sig_fmt(struct fw_unit *unit, unsigned int rate,
 	/* do transaction and check buf[1-5] are the same against command */
 	err = fcp_avc_transaction(unit, buf, 8, buf, 8,
 				  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5));
-	if (err >= 0 && err < 8)
+	if (err < 0)
+		;
+	else if (err < 8)
 		err = -EIO;
 	else if (buf[0] == 0x08) /* NOT IMPLEMENTED */
 		err = -ENOSYS;
@@ -106,7 +108,9 @@ int avc_general_get_sig_fmt(struct fw_unit *unit, unsigned int *rate,
 	/* do transaction and check buf[1-4] are the same against command */
 	err = fcp_avc_transaction(unit, buf, 8, buf, 8,
 				  BIT(1) | BIT(2) | BIT(3) | BIT(4));
-	if (err >= 0 && err < 8)
+	if (err < 0)
+		;
+	else if (err < 8)
 		err = -EIO;
 	else if (buf[0] == 0x08) /* NOT IMPLEMENTED */
 		err = -ENOSYS;
@@ -154,7 +158,9 @@ int avc_general_get_plug_info(struct fw_unit *unit, unsigned int subunit_type,
 	buf[3] = 0xff & subfunction;
 
 	err = fcp_avc_transaction(unit, buf, 8, buf, 8, BIT(1) | BIT(2));
-	if (err >= 0 && err < 8)
+	if (err < 0)
+		;
+	else if (err < 8)
 		err = -EIO;
 	else if (buf[0] == 0x08) /* NOT IMPLEMENTED */
 		err = -ENOSYS;

commit d67c46b953749aef223496ec95b7bf93e40887dc
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:54 2015 +0900

    ALSA: firewire-lib: rename 'amdtp' to 'amdtp-stream' to prepare for functional separation
    
    In later commit, data block processing layer will be newly added. This
    layer will be named as 'amdtp-am824'.
    
    This commit renames current amdtp file to amdtp-stream, to distinguish it
    from the new layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fcp.c b/sound/firewire/fcp.c
index 0619597e3a3f..cce19768f43d 100644
--- a/sound/firewire/fcp.c
+++ b/sound/firewire/fcp.c
@@ -17,7 +17,7 @@
 #include <linux/delay.h>
 #include "fcp.h"
 #include "lib.h"
-#include "amdtp.h"
+#include "amdtp-stream.h"
 
 #define CTS_AVC 0x00
 

commit c8109b573b4b761c548a13bc257ca68efa300b03
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jun 3 14:45:37 2014 +0900

    ALSA: firewire-lib: Remove a comment about restriction of asynchronous operation
    
    The comment for fcp_avc_transaction() describes it doesn't support this type
    of operation. But it was already supported by this commit.
    
    00a7bb81c20f3e81711e28e0f6c08cee8fd18514
    ALSA: firewire-lib: Add support for deferred transaction
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fcp.c b/sound/firewire/fcp.c
index d48e326567c8..0619597e3a3f 100644
--- a/sound/firewire/fcp.c
+++ b/sound/firewire/fcp.c
@@ -218,8 +218,6 @@ struct fcp_transaction {
  *
  * @command and @response can point to the same buffer.
  *
- * Asynchronous operation (INTERIM, NOTIFY) is not supported at the moment.
- *
  * Returns the actual size of the response frame, or a negative error code.
  */
 int fcp_avc_transaction(struct fw_unit *unit,

commit 1017abed18ae7087e7f3e256c48421d09d83176e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:44:59 2014 +0900

    ALSA: firewire-lib: Add some AV/C general commands
    
    This commit adds three commands, which may be used by some firewire device
    drivers. These commands are defined in 'AV/C Digital Interface Command Set
    General Specification Version 4.2 (2004006, 1394TA)'.
    
    1. PLUG INFO command (clause 10.1)
    2. INPUT PLUG SIGNAL FORMAT command (clause 10.10)
    3. OUTPUT PLUG SIGNAL FORMAT command (clause 10.11)
    
    By the command 1, the drivers can get the number of plugs for AV/C unit or
    subunit.
    By the command 2 and 3, the drivers can get/set sampling frequency.
    
    The 'firewire-speakers' already uses INPUT PLUG SIGNAL FORMAT command to set
    sampling rate. So this commit also affects the driver.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fcp.c b/sound/firewire/fcp.c
index 6876bfa9f27d..d48e326567c8 100644
--- a/sound/firewire/fcp.c
+++ b/sound/firewire/fcp.c
@@ -10,12 +10,14 @@
 #include <linux/firewire-constants.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
 #include <linux/wait.h>
 #include <linux/delay.h>
 #include "fcp.h"
 #include "lib.h"
+#include "amdtp.h"
 
 #define CTS_AVC 0x00
 
@@ -23,6 +25,158 @@
 #define ERROR_DELAY_MS	5
 #define FCP_TIMEOUT_MS	125
 
+int avc_general_set_sig_fmt(struct fw_unit *unit, unsigned int rate,
+			    enum avc_general_plug_dir dir,
+			    unsigned short pid)
+{
+	unsigned int sfc;
+	u8 *buf;
+	bool flag;
+	int err;
+
+	flag = false;
+	for (sfc = 0; sfc < CIP_SFC_COUNT; sfc++) {
+		if (amdtp_rate_table[sfc] == rate) {
+			flag = true;
+			break;
+		}
+	}
+	if (!flag)
+		return -EINVAL;
+
+	buf = kzalloc(8, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	buf[0] = 0x00;		/* AV/C CONTROL */
+	buf[1] = 0xff;		/* UNIT */
+	if (dir == AVC_GENERAL_PLUG_DIR_IN)
+		buf[2] = 0x19;	/* INPUT PLUG SIGNAL FORMAT */
+	else
+		buf[2] = 0x18;	/* OUTPUT PLUG SIGNAL FORMAT */
+	buf[3] = 0xff & pid;	/* plug id */
+	buf[4] = 0x90;		/* EOH_1, Form_1, FMT. AM824 */
+	buf[5] = 0x07 & sfc;	/* FDF-hi. AM824, frequency */
+	buf[6] = 0xff;		/* FDF-mid. AM824, SYT hi (not used)*/
+	buf[7] = 0xff;		/* FDF-low. AM824, SYT lo (not used) */
+
+	/* do transaction and check buf[1-5] are the same against command */
+	err = fcp_avc_transaction(unit, buf, 8, buf, 8,
+				  BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5));
+	if (err >= 0 && err < 8)
+		err = -EIO;
+	else if (buf[0] == 0x08) /* NOT IMPLEMENTED */
+		err = -ENOSYS;
+	else if (buf[0] == 0x0a) /* REJECTED */
+		err = -EINVAL;
+	if (err < 0)
+		goto end;
+
+	err = 0;
+end:
+	kfree(buf);
+	return err;
+}
+EXPORT_SYMBOL(avc_general_set_sig_fmt);
+
+int avc_general_get_sig_fmt(struct fw_unit *unit, unsigned int *rate,
+			    enum avc_general_plug_dir dir,
+			    unsigned short pid)
+{
+	unsigned int sfc;
+	u8 *buf;
+	int err;
+
+	buf = kzalloc(8, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	buf[0] = 0x01;		/* AV/C STATUS */
+	buf[1] = 0xff;		/* Unit */
+	if (dir == AVC_GENERAL_PLUG_DIR_IN)
+		buf[2] = 0x19;	/* INPUT PLUG SIGNAL FORMAT */
+	else
+		buf[2] = 0x18;	/* OUTPUT PLUG SIGNAL FORMAT */
+	buf[3] = 0xff & pid;	/* plug id */
+	buf[4] = 0x90;		/* EOH_1, Form_1, FMT. AM824 */
+	buf[5] = 0xff;		/* FDF-hi. AM824, frequency */
+	buf[6] = 0xff;		/* FDF-mid. AM824, SYT hi (not used) */
+	buf[7] = 0xff;		/* FDF-low. AM824, SYT lo (not used) */
+
+	/* do transaction and check buf[1-4] are the same against command */
+	err = fcp_avc_transaction(unit, buf, 8, buf, 8,
+				  BIT(1) | BIT(2) | BIT(3) | BIT(4));
+	if (err >= 0 && err < 8)
+		err = -EIO;
+	else if (buf[0] == 0x08) /* NOT IMPLEMENTED */
+		err = -ENOSYS;
+	else if (buf[0] == 0x0a) /* REJECTED */
+		err = -EINVAL;
+	else if (buf[0] == 0x0b) /* IN TRANSITION */
+		err = -EAGAIN;
+	if (err < 0)
+		goto end;
+
+	/* check sfc field and pick up rate */
+	sfc = 0x07 & buf[5];
+	if (sfc >= CIP_SFC_COUNT) {
+		err = -EAGAIN;	/* also in transition */
+		goto end;
+	}
+
+	*rate = amdtp_rate_table[sfc];
+	err = 0;
+end:
+	kfree(buf);
+	return err;
+}
+EXPORT_SYMBOL(avc_general_get_sig_fmt);
+
+int avc_general_get_plug_info(struct fw_unit *unit, unsigned int subunit_type,
+			      unsigned int subunit_id, unsigned int subfunction,
+			      u8 info[AVC_PLUG_INFO_BUF_BYTES])
+{
+	u8 *buf;
+	int err;
+
+	/* extended subunit in spec.4.2 is not supported */
+	if ((subunit_type == 0x1E) || (subunit_id == 5))
+		return -EINVAL;
+
+	buf = kzalloc(8, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	buf[0] = 0x01;	/* AV/C STATUS */
+	/* UNIT or Subunit, Functionblock */
+	buf[1] = ((subunit_type & 0x1f) << 3) | (subunit_id & 0x7);
+	buf[2] = 0x02;	/* PLUG INFO */
+	buf[3] = 0xff & subfunction;
+
+	err = fcp_avc_transaction(unit, buf, 8, buf, 8, BIT(1) | BIT(2));
+	if (err >= 0 && err < 8)
+		err = -EIO;
+	else if (buf[0] == 0x08) /* NOT IMPLEMENTED */
+		err = -ENOSYS;
+	else if (buf[0] == 0x0a) /* REJECTED */
+		err = -EINVAL;
+	else if (buf[0] == 0x0b) /* IN TRANSITION */
+		err = -EAGAIN;
+	if (err < 0)
+		goto end;
+
+	info[0] = buf[4];
+	info[1] = buf[5];
+	info[2] = buf[6];
+	info[3] = buf[7];
+
+	err = 0;
+end:
+	kfree(buf);
+	return err;
+}
+EXPORT_SYMBOL(avc_general_get_plug_info);
+
 static DEFINE_SPINLOCK(transactions_lock);
 static LIST_HEAD(transactions);
 

commit 00a7bb81c20f3e81711e28e0f6c08cee8fd18514
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:44:58 2014 +0900

    ALSA: firewire-lib: Add support for deferred transaction
    
    Some devices based on BeBoB use this type of AV/C transaction.
    
    'Deferred Transaction' is defined in 'AV/C Digital Interface Command Set
    General Specification' and is used by targets to make a response deferred
    during processing it.
    
    If a target may not be able to complete a command within 100msec since
    receiving the command, then the target shall return INTERIM response,
    to which final response will follow later. CONTROL/NOTIFY commands are
    allowed for deferred transaction.
    
    In the specification, devices allow to send INTERIM response just one time.
    But this commit allows to handle several INTERIM response with two reasons.
    One reason is to simplify codes, and another reason is to prepare for
    devices which is out of specification.
    
    There is an issue. In the specification, the interval between INTERIM
    response and final response is 'Unspecified interval'. The specification
    depends on each subunit specification for this interval.
    
    But we promise to finish this function for caller. In this reason, I use
    FCP_TIMEOUT_MS for this interval. Currently it's 125msec. When we find
    devices which needs more time for this interval, then let us add some codes
    to apply more interval for 'Unspecified interval'.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fcp.c b/sound/firewire/fcp.c
index 860c08073c59..6876bfa9f27d 100644
--- a/sound/firewire/fcp.c
+++ b/sound/firewire/fcp.c
@@ -30,6 +30,7 @@ enum fcp_state {
 	STATE_PENDING,
 	STATE_BUS_RESET,
 	STATE_COMPLETE,
+	STATE_DEFERRED,
 };
 
 struct fcp_transaction {
@@ -40,6 +41,7 @@ struct fcp_transaction {
 	unsigned int response_match_bytes;
 	enum fcp_state state;
 	wait_queue_head_t wait;
+	bool deferrable;
 };
 
 /**
@@ -81,6 +83,9 @@ int fcp_avc_transaction(struct fw_unit *unit,
 	t.state = STATE_PENDING;
 	init_waitqueue_head(&t.wait);
 
+	if (*(const u8 *)command == 0x00 || *(const u8 *)command == 0x03)
+		t.deferrable = true;
+
 	spin_lock_irq(&transactions_lock);
 	list_add_tail(&t.list, &transactions);
 	spin_unlock_irq(&transactions_lock);
@@ -93,11 +98,21 @@ int fcp_avc_transaction(struct fw_unit *unit,
 					 (void *)command, command_size, 0);
 		if (ret < 0)
 			break;
-
+deferred:
 		wait_event_timeout(t.wait, t.state != STATE_PENDING,
 				   msecs_to_jiffies(FCP_TIMEOUT_MS));
 
-		if (t.state == STATE_COMPLETE) {
+		if (t.state == STATE_DEFERRED) {
+			/*
+			 * 'AV/C General Specification' define no time limit
+			 * on command completion once an INTERIM response has
+			 * been sent. but we promise to finish this function
+			 * for a caller. Here we use FCP_TIMEOUT_MS for next
+			 * interval. This is not in the specification.
+			 */
+			t.state = STATE_PENDING;
+			goto deferred;
+		} else if (t.state == STATE_COMPLETE) {
 			ret = t.response_size;
 			break;
 		} else if (t.state == STATE_BUS_RESET) {
@@ -132,7 +147,8 @@ void fcp_bus_reset(struct fw_unit *unit)
 	spin_lock_irq(&transactions_lock);
 	list_for_each_entry(t, &transactions, list) {
 		if (t->unit == unit &&
-		    t->state == STATE_PENDING) {
+		    (t->state == STATE_PENDING ||
+		     t->state == STATE_DEFERRED)) {
 			t->state = STATE_BUS_RESET;
 			wake_up(&t->wait);
 		}
@@ -186,10 +202,15 @@ static void fcp_response(struct fw_card *card, struct fw_request *request,
 
 		if (t->state == STATE_PENDING &&
 		    is_matching_response(t, data, length)) {
-			t->state = STATE_COMPLETE;
-			t->response_size = min((unsigned int)length,
-					       t->response_size);
-			memcpy(t->response_buffer, data, t->response_size);
+			if (t->deferrable && *(const u8 *)data == 0x0f) {
+				t->state = STATE_DEFERRED;
+			} else {
+				t->state = STATE_COMPLETE;
+				t->response_size = min_t(unsigned int, length,
+							 t->response_size);
+				memcpy(t->response_buffer, data,
+				       t->response_size);
+			}
 			wake_up(&t->wait);
 		}
 	}

commit 1b70485f135a39d5f2d8c392a16817456fa3a5cd
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Sep 4 22:17:38 2011 +0200

    ALSA: firewire: extend snd_fw_transaction()
    
    Add a flag to snd_fw_transaction() to allow it to abort when a bus reset
    happens.  This removes most of the duplicated error handling loops that
    were required around calls to the low-level fw_run_transaction().
    
    Also add a flag to suppress error messages; errors are expected when we
    attempt to clean up after the device was unplugged.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/firewire/fcp.c b/sound/firewire/fcp.c
index ec578b5ad8da..860c08073c59 100644
--- a/sound/firewire/fcp.c
+++ b/sound/firewire/fcp.c
@@ -90,7 +90,7 @@ int fcp_avc_transaction(struct fw_unit *unit,
 					  : TCODE_WRITE_BLOCK_REQUEST;
 		ret = snd_fw_transaction(t.unit, tcode,
 					 CSR_REGISTER_BASE + CSR_FCP_COMMAND,
-					 (void *)command, command_size);
+					 (void *)command, command_size, 0);
 		if (ret < 0)
 			break;
 

commit 5de0ee574be8f6922a6c33f2fbc7e9b130a2f626
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Mar 16 17:39:28 2011 +1100

    ALSA: firewire - msleep needs delay.h
    
    fixes this error:
    
    sound/firewire/fcp.c: In function 'fcp_avc_transaction':
    sound/firewire/fcp.c:103: error: implicit declaration of function 'msleep'
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fcp.c b/sound/firewire/fcp.c
index c20bd9c8f5ab..ec578b5ad8da 100644
--- a/sound/firewire/fcp.c
+++ b/sound/firewire/fcp.c
@@ -13,6 +13,7 @@
 #include <linux/sched.h>
 #include <linux/spinlock.h>
 #include <linux/wait.h>
+#include <linux/delay.h>
 #include "fcp.h"
 #include "lib.h"
 

commit 31ef9134eb52636d383a7d0626cbbd345cb94f2f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Mar 15 07:53:21 2011 +0100

    ALSA: add LaCie FireWire Speakers/Griffin FireWave Surround driver
    
    Add a driver for two playback-only FireWire devices based on the OXFW970
    chip.
    
    v2: better AMDTP API abstraction; fix fw_unit leak; small fixes
    v3: cache the iPCR value
    v4: FireWave constraints; fix fw_device reference counting;
        fix PCR caching; small changes and fixes
    v5: volume/mute support; fix crashing due to pcm stop races
    v6: fix build; one-channel volume for LaCie
    v7: use signed values to make volume (range checks) work; fix function
        block IDs for volume/mute; always use channel 0 for LaCie volume
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Tested-by: Jay Fenlason <fenlason@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fcp.c b/sound/firewire/fcp.c
new file mode 100644
index 000000000000..c20bd9c8f5ab
--- /dev/null
+++ b/sound/firewire/fcp.c
@@ -0,0 +1,223 @@
+/*
+ * Function Control Protocol (IEC 61883-1) helper functions
+ *
+ * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include <linux/device.h>
+#include <linux/firewire.h>
+#include <linux/firewire-constants.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include "fcp.h"
+#include "lib.h"
+
+#define CTS_AVC 0x00
+
+#define ERROR_RETRIES	3
+#define ERROR_DELAY_MS	5
+#define FCP_TIMEOUT_MS	125
+
+static DEFINE_SPINLOCK(transactions_lock);
+static LIST_HEAD(transactions);
+
+enum fcp_state {
+	STATE_PENDING,
+	STATE_BUS_RESET,
+	STATE_COMPLETE,
+};
+
+struct fcp_transaction {
+	struct list_head list;
+	struct fw_unit *unit;
+	void *response_buffer;
+	unsigned int response_size;
+	unsigned int response_match_bytes;
+	enum fcp_state state;
+	wait_queue_head_t wait;
+};
+
+/**
+ * fcp_avc_transaction - send an AV/C command and wait for its response
+ * @unit: a unit on the target device
+ * @command: a buffer containing the command frame; must be DMA-able
+ * @command_size: the size of @command
+ * @response: a buffer for the response frame
+ * @response_size: the maximum size of @response
+ * @response_match_bytes: a bitmap specifying the bytes used to detect the
+ *                        correct response frame
+ *
+ * This function sends a FCP command frame to the target and waits for the
+ * corresponding response frame to be returned.
+ *
+ * Because it is possible for multiple FCP transactions to be active at the
+ * same time, the correct response frame is detected by the value of certain
+ * bytes.  These bytes must be set in @response before calling this function,
+ * and the corresponding bits must be set in @response_match_bytes.
+ *
+ * @command and @response can point to the same buffer.
+ *
+ * Asynchronous operation (INTERIM, NOTIFY) is not supported at the moment.
+ *
+ * Returns the actual size of the response frame, or a negative error code.
+ */
+int fcp_avc_transaction(struct fw_unit *unit,
+			const void *command, unsigned int command_size,
+			void *response, unsigned int response_size,
+			unsigned int response_match_bytes)
+{
+	struct fcp_transaction t;
+	int tcode, ret, tries = 0;
+
+	t.unit = unit;
+	t.response_buffer = response;
+	t.response_size = response_size;
+	t.response_match_bytes = response_match_bytes;
+	t.state = STATE_PENDING;
+	init_waitqueue_head(&t.wait);
+
+	spin_lock_irq(&transactions_lock);
+	list_add_tail(&t.list, &transactions);
+	spin_unlock_irq(&transactions_lock);
+
+	for (;;) {
+		tcode = command_size == 4 ? TCODE_WRITE_QUADLET_REQUEST
+					  : TCODE_WRITE_BLOCK_REQUEST;
+		ret = snd_fw_transaction(t.unit, tcode,
+					 CSR_REGISTER_BASE + CSR_FCP_COMMAND,
+					 (void *)command, command_size);
+		if (ret < 0)
+			break;
+
+		wait_event_timeout(t.wait, t.state != STATE_PENDING,
+				   msecs_to_jiffies(FCP_TIMEOUT_MS));
+
+		if (t.state == STATE_COMPLETE) {
+			ret = t.response_size;
+			break;
+		} else if (t.state == STATE_BUS_RESET) {
+			msleep(ERROR_DELAY_MS);
+		} else if (++tries >= ERROR_RETRIES) {
+			dev_err(&t.unit->device, "FCP command timed out\n");
+			ret = -EIO;
+			break;
+		}
+	}
+
+	spin_lock_irq(&transactions_lock);
+	list_del(&t.list);
+	spin_unlock_irq(&transactions_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(fcp_avc_transaction);
+
+/**
+ * fcp_bus_reset - inform the target handler about a bus reset
+ * @unit: the unit that might be used by fcp_avc_transaction()
+ *
+ * This function must be called from the driver's .update handler to inform
+ * the FCP transaction handler that a bus reset has happened.  Any pending FCP
+ * transactions are retried.
+ */
+void fcp_bus_reset(struct fw_unit *unit)
+{
+	struct fcp_transaction *t;
+
+	spin_lock_irq(&transactions_lock);
+	list_for_each_entry(t, &transactions, list) {
+		if (t->unit == unit &&
+		    t->state == STATE_PENDING) {
+			t->state = STATE_BUS_RESET;
+			wake_up(&t->wait);
+		}
+	}
+	spin_unlock_irq(&transactions_lock);
+}
+EXPORT_SYMBOL(fcp_bus_reset);
+
+/* checks whether the response matches the masked bytes in response_buffer */
+static bool is_matching_response(struct fcp_transaction *transaction,
+				 const void *response, size_t length)
+{
+	const u8 *p1, *p2;
+	unsigned int mask, i;
+
+	p1 = response;
+	p2 = transaction->response_buffer;
+	mask = transaction->response_match_bytes;
+
+	for (i = 0; ; ++i) {
+		if ((mask & 1) && p1[i] != p2[i])
+			return false;
+		mask >>= 1;
+		if (!mask)
+			return true;
+		if (--length == 0)
+			return false;
+	}
+}
+
+static void fcp_response(struct fw_card *card, struct fw_request *request,
+			 int tcode, int destination, int source,
+			 int generation, unsigned long long offset,
+			 void *data, size_t length, void *callback_data)
+{
+	struct fcp_transaction *t;
+	unsigned long flags;
+
+	if (length < 1 || (*(const u8 *)data & 0xf0) != CTS_AVC)
+		return;
+
+	spin_lock_irqsave(&transactions_lock, flags);
+	list_for_each_entry(t, &transactions, list) {
+		struct fw_device *device = fw_parent_device(t->unit);
+		if (device->card != card ||
+		    device->generation != generation)
+			continue;
+		smp_rmb(); /* node_id vs. generation */
+		if (device->node_id != source)
+			continue;
+
+		if (t->state == STATE_PENDING &&
+		    is_matching_response(t, data, length)) {
+			t->state = STATE_COMPLETE;
+			t->response_size = min((unsigned int)length,
+					       t->response_size);
+			memcpy(t->response_buffer, data, t->response_size);
+			wake_up(&t->wait);
+		}
+	}
+	spin_unlock_irqrestore(&transactions_lock, flags);
+}
+
+static struct fw_address_handler response_register_handler = {
+	.length = 0x200,
+	.address_callback = fcp_response,
+};
+
+static int __init fcp_module_init(void)
+{
+	static const struct fw_address_region response_register_region = {
+		.start = CSR_REGISTER_BASE + CSR_FCP_RESPONSE,
+		.end = CSR_REGISTER_BASE + CSR_FCP_END,
+	};
+
+	fw_core_add_address_handler(&response_register_handler,
+				    &response_register_region);
+
+	return 0;
+}
+
+static void __exit fcp_module_exit(void)
+{
+	WARN_ON(!list_empty(&transactions));
+	fw_core_remove_address_handler(&response_register_handler);
+}
+
+module_init(fcp_module_init);
+module_exit(fcp_module_exit);
