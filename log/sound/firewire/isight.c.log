commit d45b3aaea26c8bc43ca5bc8cba05cb399096d631
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:27 2019 +0100

    ALSA: firewire: Drop superfluous ioctl PCM ops
    
    All the PCM ioctl ops of ALSA FireWire drivers do nothing but calling
    the default handler.
    
    Now PCM core accepts NULL as the default ioctl ops(*), so let's drop
    altogether.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Acked-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191210061145.24641-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 214f77b0e8b7..6655af53b367 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -441,7 +441,6 @@ static int isight_create_pcm(struct isight *isight)
 	static const struct snd_pcm_ops ops = {
 		.open      = isight_open,
 		.close     = isight_close,
-		.ioctl     = snd_pcm_lib_ioctl,
 		.hw_params = isight_hw_params,
 		.hw_free   = isight_hw_free,
 		.prepare   = isight_prepare,

commit 7641d549b13bbb1dcc6c7759c010c1ca288c90be
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:48:41 2019 +0100

    ALSA: firewire: Use managed buffer allocation
    
    Clean up the drivers with the new managed buffer allocation API.
    The superfluous snd_pcm_lib_malloc_pages() and
    snd_pcm_lib_free_pages() calls are dropped.
    
    Acked-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191209192422.23902-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index d9f1b962bfef..214f77b0e8b7 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -286,11 +286,6 @@ static int isight_hw_params(struct snd_pcm_substream *substream,
 			    struct snd_pcm_hw_params *hw_params)
 {
 	struct isight *isight = substream->private_data;
-	int err;
-
-	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-	if (err < 0)
-		return err;
 
 	WRITE_ONCE(isight->pcm_active, true);
 
@@ -336,7 +331,7 @@ static int isight_hw_free(struct snd_pcm_substream *substream)
 	isight_stop_streaming(isight);
 	mutex_unlock(&isight->mutex);
 
-	return snd_pcm_lib_free_pages(substream);
+	return 0;
 }
 
 static int isight_start_streaming(struct isight *isight)
@@ -463,8 +458,7 @@ static int isight_create_pcm(struct isight *isight)
 	strcpy(pcm->name, "iSight");
 	isight->pcm = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;
 	isight->pcm->ops = &ops;
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
-					      NULL, 0, 0);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);
 
 	return 0;
 }

commit a3f4f2d5d02095d098ff03c4d0bdbae2e53a5bba
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:42 2019 +0100

    ALSA: firewire: Convert to the common vmalloc memalloc
    
    The recent change (*) in the ALSA memalloc core allows us to drop the
    special vmalloc-specific allocation and page handling.  This patch
    coverts to the common code.
    (*) 1fe7f397cfe2: ALSA: memalloc: Add vmalloc buffer allocation
                      support
        7e8edae39fd1: ALSA: pcm: Handle special page mapping in the
                      default mmap handler
    
    Link: https://lore.kernel.org/r/20191105151856.10785-11-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index a16beda7c530..d9f1b962bfef 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -288,8 +288,7 @@ static int isight_hw_params(struct snd_pcm_substream *substream,
 	struct isight *isight = substream->private_data;
 	int err;
 
-	err = snd_pcm_lib_alloc_vmalloc_buffer(substream,
-					       params_buffer_bytes(hw_params));
+	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 	if (err < 0)
 		return err;
 
@@ -337,7 +336,7 @@ static int isight_hw_free(struct snd_pcm_substream *substream)
 	isight_stop_streaming(isight);
 	mutex_unlock(&isight->mutex);
 
-	return snd_pcm_lib_free_vmalloc_buffer(substream);
+	return snd_pcm_lib_free_pages(substream);
 }
 
 static int isight_start_streaming(struct isight *isight)
@@ -453,7 +452,6 @@ static int isight_create_pcm(struct isight *isight)
 		.prepare   = isight_prepare,
 		.trigger   = isight_trigger,
 		.pointer   = isight_pointer,
-		.page      = snd_pcm_lib_get_vmalloc_page,
 	};
 	struct snd_pcm *pcm;
 	int err;
@@ -465,6 +463,8 @@ static int isight_create_pcm(struct isight *isight)
 	strcpy(pcm->name, "iSight");
 	isight->pcm = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;
 	isight->pcm->ops = &ops;
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
+					      NULL, 0, 0);
 
 	return 0;
 }

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 9ebe510ea26b..a16beda7c530 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -1,8 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Apple iSight audio driver
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include <asm/byteorder.h>

commit 51e68fb0929c29e47e9074ca3e99ffd6021a1c5a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 12 14:25:22 2018 +0900

    ALSA: isight: fix leak of reference to firewire unit in error path of .probe callback
    
    In some error paths, reference count of firewire unit is not decreased.
    This commit fixes the bug.
    
    Fixes: 5b14ec25a79b('ALSA: firewire: release reference count of firewire unit in .remove callback of bus driver')
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index de4decfb74d5..9ebe510ea26b 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -638,7 +638,7 @@ static int isight_probe(struct fw_unit *unit,
 	if (!isight->audio_base) {
 		dev_err(&unit->device, "audio unit base not found\n");
 		err = -ENXIO;
-		goto err_unit;
+		goto error;
 	}
 	fw_iso_resources_init(&isight->resources, unit);
 
@@ -667,12 +667,12 @@ static int isight_probe(struct fw_unit *unit,
 	dev_set_drvdata(&unit->device, isight);
 
 	return 0;
-
-err_unit:
-	fw_unit_put(isight->unit);
-	mutex_destroy(&isight->mutex);
 error:
 	snd_card_free(card);
+
+	mutex_destroy(&isight->mutex);
+	fw_unit_put(isight->unit);
+
 	return err;
 }
 

commit 5b14ec25a79bf60fc9a663fe579a500b6ac9d8ab
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:00 2018 +0900

    ALSA: firewire: release reference count of firewire unit in .remove callback of bus driver
    
    In a previous commit, drivers in ALSA firewire stack blocks .remove
    callback of bus driver. This enables to release members of private
    data in the callback after releasing device of sound card.
    
    This commit simplifies codes to release the members.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 1f591c8805ea..de4decfb74d5 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -602,8 +602,6 @@ static void isight_card_free(struct snd_card *card)
 	struct isight *isight = card->private_data;
 
 	fw_iso_resources_destroy(&isight->resources);
-	fw_unit_put(isight->unit);
-	mutex_destroy(&isight->mutex);
 }
 
 static u64 get_unit_base(struct fw_unit *unit)
@@ -705,6 +703,9 @@ static void isight_remove(struct fw_unit *unit)
 
 	// Block till all of ALSA character devices are released.
 	snd_card_free(isight->card);
+
+	mutex_destroy(&isight->mutex);
+	fw_unit_put(isight->unit);
 }
 
 static const struct ieee1394_device_id isight_id_table[] = {

commit 61ccc6f6b27c03bb32ca38a3c580d49ce1612d43
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:34:59 2018 +0900

    ALSA: firewire: block .remove callback of bus driver till all of ALSA character devices are released
    
    At present, in .remove callback of bus driver just decrease reference
    count of device for ALSA card instance. This delegates release of the
    device to a process in which the last of ALSA character device is
    released.
    
    On the other hand, the other drivers such as for devices on PCIe are
    programmed to block .remove callback of bus driver till all of ALSA
    character devices are released.
    
    For consistency of behaviour for whole drivers, this probably confuses
    users. This commit takes drivers in ALSA firewire stack to imitate the
    above behaviour.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 30957477e005..1f591c8805ea 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -703,7 +703,8 @@ static void isight_remove(struct fw_unit *unit)
 	isight_stop_streaming(isight);
 	mutex_unlock(&isight->mutex);
 
-	snd_card_free_when_closed(isight->card);
+	// Block till all of ALSA character devices are released.
+	snd_card_free(isight->card);
 }
 
 static const struct ieee1394_device_id isight_id_table[] = {

commit fa84cf094ef9667e2b91c104b0a788fd1896f482
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 18 07:40:53 2018 +0200

    ALSA: pcm: Nuke snd_pcm_lib_mmap_vmalloc()
    
    snd_pcm_lib_mmap_vmalloc() was supposed to be implemented with
    somewhat special for vmalloc handling, but in the end, this turned to
    just the default handler, i.e. NULL.  As the situation has never
    changed over decades, let's rip it off.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 3919e186a30b..30957477e005 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -454,7 +454,6 @@ static int isight_create_pcm(struct isight *isight)
 		.trigger   = isight_trigger,
 		.pointer   = isight_pointer,
 		.page      = snd_pcm_lib_get_vmalloc_page,
-		.mmap      = snd_pcm_lib_mmap_vmalloc,
 	};
 	struct snd_pcm *pcm;
 	int err;

commit 4844f51282b60f8a96b05d422f452a785df308b9
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon May 14 07:09:53 2018 +0900

    ALSA: isight: use position offset macro of TLV data
    
    A series of SNDRV_CTL_TLVO_XXX macro was introduced for position offset
    of TLV data. This commit applies a code optimization.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 46092fa3ff9b..3919e186a30b 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -569,18 +569,20 @@ static int isight_create_mixer(struct isight *isight)
 		return err;
 	isight->gain_max = be32_to_cpu(value);
 
-	isight->gain_tlv[0] = SNDRV_CTL_TLVT_DB_MINMAX;
-	isight->gain_tlv[1] = 2 * sizeof(unsigned int);
+	isight->gain_tlv[SNDRV_CTL_TLVO_TYPE] = SNDRV_CTL_TLVT_DB_MINMAX;
+	isight->gain_tlv[SNDRV_CTL_TLVO_LEN] = 2 * sizeof(unsigned int);
 
 	err = reg_read(isight, REG_GAIN_DB_START, &value);
 	if (err < 0)
 		return err;
-	isight->gain_tlv[2] = (s32)be32_to_cpu(value) * 100;
+	isight->gain_tlv[SNDRV_CTL_TLVO_DB_MINMAX_MIN] =
+						(s32)be32_to_cpu(value) * 100;
 
 	err = reg_read(isight, REG_GAIN_DB_END, &value);
 	if (err < 0)
 		return err;
-	isight->gain_tlv[3] = (s32)be32_to_cpu(value) * 100;
+	isight->gain_tlv[SNDRV_CTL_TLVO_DB_MINMAX_MAX] =
+						(s32)be32_to_cpu(value) * 100;
 
 	ctl = snd_ctl_new1(&gain_control, isight);
 	if (ctl)

commit 6aa7de059173a986114ac43b8f50b297a86f09a8
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Oct 23 14:07:29 2017 -0700

    locking/atomics: COCCINELLE/treewide: Convert trivial ACCESS_ONCE() patterns to READ_ONCE()/WRITE_ONCE()
    
    Please do not apply this to mainline directly, instead please re-run the
    coccinelle script shown below and apply its output.
    
    For several reasons, it is desirable to use {READ,WRITE}_ONCE() in
    preference to ACCESS_ONCE(), and new code is expected to use one of the
    former. So far, there's been no reason to change most existing uses of
    ACCESS_ONCE(), as these aren't harmful, and changing them results in
    churn.
    
    However, for some features, the read/write distinction is critical to
    correct operation. To distinguish these cases, separate read/write
    accessors must be used. This patch migrates (most) remaining
    ACCESS_ONCE() instances to {READ,WRITE}_ONCE(), using the following
    coccinelle script:
    
    ----
    // Convert trivial ACCESS_ONCE() uses to equivalent READ_ONCE() and
    // WRITE_ONCE()
    
    // $ make coccicheck COCCI=/home/mark/once.cocci SPFLAGS="--include-headers" MODE=patch
    
    virtual patch
    
    @ depends on patch @
    expression E1, E2;
    @@
    
    - ACCESS_ONCE(E1) = E2
    + WRITE_ONCE(E1, E2)
    
    @ depends on patch @
    expression E;
    @@
    
    - ACCESS_ONCE(E)
    + READ_ONCE(E)
    ----
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: davem@davemloft.net
    Cc: linux-arch@vger.kernel.org
    Cc: mpe@ellerman.id.au
    Cc: shuah@kernel.org
    Cc: snitzer@redhat.com
    Cc: thor.thayer@linux.intel.com
    Cc: tj@kernel.org
    Cc: viro@zeniv.linux.org.uk
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1508792849-3115-19-git-send-email-paulmck@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 5826aa8362f1..46092fa3ff9b 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -96,7 +96,7 @@ static void isight_update_pointers(struct isight *isight, unsigned int count)
 	ptr += count;
 	if (ptr >= runtime->buffer_size)
 		ptr -= runtime->buffer_size;
-	ACCESS_ONCE(isight->buffer_pointer) = ptr;
+	WRITE_ONCE(isight->buffer_pointer, ptr);
 
 	isight->period_counter += count;
 	if (isight->period_counter >= runtime->period_size) {
@@ -111,7 +111,7 @@ static void isight_samples(struct isight *isight,
 	struct snd_pcm_runtime *runtime;
 	unsigned int count1;
 
-	if (!ACCESS_ONCE(isight->pcm_running))
+	if (!READ_ONCE(isight->pcm_running))
 		return;
 
 	runtime = isight->pcm->runtime;
@@ -131,7 +131,7 @@ static void isight_samples(struct isight *isight,
 
 static void isight_pcm_abort(struct isight *isight)
 {
-	if (ACCESS_ONCE(isight->pcm_active))
+	if (READ_ONCE(isight->pcm_active))
 		snd_pcm_stop_xrun(isight->pcm);
 }
 
@@ -141,7 +141,7 @@ static void isight_dropped_samples(struct isight *isight, unsigned int total)
 	u32 dropped;
 	unsigned int count1;
 
-	if (!ACCESS_ONCE(isight->pcm_running))
+	if (!READ_ONCE(isight->pcm_running))
 		return;
 
 	runtime = isight->pcm->runtime;
@@ -293,7 +293,7 @@ static int isight_hw_params(struct snd_pcm_substream *substream,
 	if (err < 0)
 		return err;
 
-	ACCESS_ONCE(isight->pcm_active) = true;
+	WRITE_ONCE(isight->pcm_active, true);
 
 	return 0;
 }
@@ -331,7 +331,7 @@ static int isight_hw_free(struct snd_pcm_substream *substream)
 {
 	struct isight *isight = substream->private_data;
 
-	ACCESS_ONCE(isight->pcm_active) = false;
+	WRITE_ONCE(isight->pcm_active, false);
 
 	mutex_lock(&isight->mutex);
 	isight_stop_streaming(isight);
@@ -424,10 +424,10 @@ static int isight_trigger(struct snd_pcm_substream *substream, int cmd)
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		ACCESS_ONCE(isight->pcm_running) = true;
+		WRITE_ONCE(isight->pcm_running, true);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-		ACCESS_ONCE(isight->pcm_running) = false;
+		WRITE_ONCE(isight->pcm_running, false);
 		break;
 	default:
 		return -EINVAL;
@@ -439,7 +439,7 @@ static snd_pcm_uframes_t isight_pointer(struct snd_pcm_substream *substream)
 {
 	struct isight *isight = substream->private_data;
 
-	return ACCESS_ONCE(isight->buffer_pointer);
+	return READ_ONCE(isight->buffer_pointer);
 }
 
 static int isight_create_pcm(struct isight *isight)

commit b2165f3889ace44ee21a41ca72467be3119121db
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 18 13:15:13 2017 +0530

    ALSA: firewire: constify snd_pcm_ops structures
    
    snd_pcm_ops are not supposed to change at runtime. All functions
    working with snd_pcm_ops provided by <sound/pcm.h> work with
    const snd_pcm_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 48d6dca471c6..5826aa8362f1 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -444,7 +444,7 @@ static snd_pcm_uframes_t isight_pointer(struct snd_pcm_substream *substream)
 
 static int isight_create_pcm(struct isight *isight)
 {
-	static struct snd_pcm_ops ops = {
+	static const struct snd_pcm_ops ops = {
 		.open      = isight_open,
 		.close     = isight_close,
 		.ioctl     = snd_pcm_lib_ioctl,

commit 1fb8510cdb5b7befe8a59f533c7fc12ef0dac73e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 7 17:08:28 2014 +0100

    ALSA: pcm: Add snd_pcm_stop_xrun() helper
    
    Add a new helper function snd_pcm_stop_xrun() to the standard sequnce
    lock/snd_pcm_stop(XRUN)/unlock by a single call, and replace the
    existing open codes with this helper.
    
    The function checks the PCM running state to prevent setting the wrong
    state, too, for more safety.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 7ac94439e758..48d6dca471c6 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -131,14 +131,8 @@ static void isight_samples(struct isight *isight,
 
 static void isight_pcm_abort(struct isight *isight)
 {
-	unsigned long flags;
-
-	if (ACCESS_ONCE(isight->pcm_active)) {
-		snd_pcm_stream_lock_irqsave(isight->pcm, flags);
-		if (snd_pcm_running(isight->pcm))
-			snd_pcm_stop(isight->pcm, SNDRV_PCM_STATE_XRUN);
-		snd_pcm_stream_unlock_irqrestore(isight->pcm, flags);
-	}
+	if (ACCESS_ONCE(isight->pcm_active))
+		snd_pcm_stop_xrun(isight->pcm);
 }
 
 static void isight_dropped_samples(struct isight *isight, unsigned int total)

commit 06b45f00a46621e0766e37a02a9676b9143261a2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:23:55 2014 +0100

    ALSA: firewire: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index fd42e6b315e6..7ac94439e758 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -631,10 +631,10 @@ static int isight_probe(struct fw_unit *unit,
 	struct isight *isight;
 	int err;
 
-	err = snd_card_create(-1, NULL, THIS_MODULE, sizeof(*isight), &card);
+	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
+			   sizeof(*isight), &card);
 	if (err < 0)
 		return err;
-	snd_card_set_dev(card, &unit->device);
 
 	isight = card->private_data;
 	isight->card = card;

commit 1b70485f135a39d5f2d8c392a16817456fa3a5cd
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Sep 4 22:17:38 2011 +0200

    ALSA: firewire: extend snd_fw_transaction()
    
    Add a flag to snd_fw_transaction() to allow it to abort when a bus reset
    happens.  This removes most of the duplicated error handling loops that
    were required around calls to the low-level fw_run_transaction().
    
    Also add a flag to suppress error messages; errors are expected when we
    attempt to clean up after the device was unplugged.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 58a5afefdc69..fd42e6b315e6 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -217,7 +217,7 @@ static void isight_packet(struct fw_iso_context *context, u32 cycle,
 
 static int isight_connect(struct isight *isight)
 {
-	int ch, err, rcode, errors = 0;
+	int ch, err;
 	__be32 value;
 
 retry_after_bus_reset:
@@ -230,27 +230,19 @@ static int isight_connect(struct isight *isight)
 	}
 
 	value = cpu_to_be32(ch | (isight->device->max_speed << SPEED_SHIFT));
-	for (;;) {
-		rcode = fw_run_transaction(
-				isight->device->card,
-				TCODE_WRITE_QUADLET_REQUEST,
-				isight->device->node_id,
-				isight->resources.generation,
-				isight->device->max_speed,
-				isight->audio_base + REG_ISO_TX_CONFIG,
-				&value, 4);
-		if (rcode == RCODE_COMPLETE) {
-			return 0;
-		} else if (rcode == RCODE_GENERATION) {
-			fw_iso_resources_free(&isight->resources);
-			goto retry_after_bus_reset;
-		} else if (rcode_is_permanent_error(rcode) || ++errors >= 3) {
-			err = -EIO;
-			goto err_resources;
-		}
-		msleep(5);
+	err = snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
+				 isight->audio_base + REG_ISO_TX_CONFIG,
+				 &value, 4, FW_FIXED_GENERATION |
+				 isight->resources.generation);
+	if (err == -EAGAIN) {
+		fw_iso_resources_free(&isight->resources);
+		goto retry_after_bus_reset;
+	} else if (err < 0) {
+		goto err_resources;
 	}
 
+	return 0;
+
 err_resources:
 	fw_iso_resources_free(&isight->resources);
 error:
@@ -315,17 +307,19 @@ static int isight_hw_params(struct snd_pcm_substream *substream,
 static int reg_read(struct isight *isight, int offset, __be32 *value)
 {
 	return snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
-				  isight->audio_base + offset, value, 4);
+				  isight->audio_base + offset, value, 4, 0);
 }
 
 static int reg_write(struct isight *isight, int offset, __be32 value)
 {
 	return snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
-				  isight->audio_base + offset, &value, 4);
+				  isight->audio_base + offset, &value, 4, 0);
 }
 
 static void isight_stop_streaming(struct isight *isight)
 {
+	__be32 value;
+
 	if (!isight->context)
 		return;
 
@@ -333,7 +327,10 @@ static void isight_stop_streaming(struct isight *isight)
 	fw_iso_context_destroy(isight->context);
 	isight->context = NULL;
 	fw_iso_resources_free(&isight->resources);
-	reg_write(isight, REG_AUDIO_ENABLE, 0);
+	value = 0;
+	snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
+			   isight->audio_base + REG_AUDIO_ENABLE,
+			   &value, 4, FW_QUIET);
 }
 
 static int isight_hw_free(struct snd_pcm_substream *substream)

commit 94a87157cde95d38b9cdf1116e4f0fd93f6d25df
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 9 18:15:00 2013 +0200

    firewire: introduce fw_driver.probe and .remove methods
    
    FireWire upper layer drivers are converted from generic
        struct driver.probe() and .remove()
    to bus-specific
        struct fw_driver.probe() and .remove().
    
    The new .probe() adds a const struct ieee1394_device_id *id argument,
    indicating the entry in the driver's device identifiers table which
    matched the fw_unit to be probed.  This new argument is used by the
    snd-firewire-speakers driver to look up device-specific parameters and
    methods.  There is at least one other FireWire audio driver currently in
    development in which this will be useful too.
    
    The new .remove() drops the unused error return code.
    
    Although all in-tree drivers are being converted to the new methods,
    support for the old methods is left in place in this commit.  This
    allows public developer trees to merge this commit and then move to the
    new fw_driver methods.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Acked-by: Clemens Ladisch <clemens@ladisch.de> (for sound/firewire/)
    Cc: Peter Hurley <peter@hurleysoftware.com> (for drivers/staging/fwserial/)

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index d428ffede4f3..58a5afefdc69 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -626,9 +626,9 @@ static u64 get_unit_base(struct fw_unit *unit)
 	return 0;
 }
 
-static int isight_probe(struct device *unit_dev)
+static int isight_probe(struct fw_unit *unit,
+			const struct ieee1394_device_id *id)
 {
-	struct fw_unit *unit = fw_unit(unit_dev);
 	struct fw_device *fw_dev = fw_parent_device(unit);
 	struct snd_card *card;
 	struct isight *isight;
@@ -637,7 +637,7 @@ static int isight_probe(struct device *unit_dev)
 	err = snd_card_create(-1, NULL, THIS_MODULE, sizeof(*isight), &card);
 	if (err < 0)
 		return err;
-	snd_card_set_dev(card, unit_dev);
+	snd_card_set_dev(card, &unit->device);
 
 	isight = card->private_data;
 	isight->card = card;
@@ -674,7 +674,7 @@ static int isight_probe(struct device *unit_dev)
 	if (err < 0)
 		goto error;
 
-	dev_set_drvdata(unit_dev, isight);
+	dev_set_drvdata(&unit->device, isight);
 
 	return 0;
 
@@ -686,23 +686,6 @@ static int isight_probe(struct device *unit_dev)
 	return err;
 }
 
-static int isight_remove(struct device *dev)
-{
-	struct isight *isight = dev_get_drvdata(dev);
-
-	isight_pcm_abort(isight);
-
-	snd_card_disconnect(isight->card);
-
-	mutex_lock(&isight->mutex);
-	isight_stop_streaming(isight);
-	mutex_unlock(&isight->mutex);
-
-	snd_card_free_when_closed(isight->card);
-
-	return 0;
-}
-
 static void isight_bus_reset(struct fw_unit *unit)
 {
 	struct isight *isight = dev_get_drvdata(&unit->device);
@@ -716,6 +699,21 @@ static void isight_bus_reset(struct fw_unit *unit)
 	}
 }
 
+static void isight_remove(struct fw_unit *unit)
+{
+	struct isight *isight = dev_get_drvdata(&unit->device);
+
+	isight_pcm_abort(isight);
+
+	snd_card_disconnect(isight->card);
+
+	mutex_lock(&isight->mutex);
+	isight_stop_streaming(isight);
+	mutex_unlock(&isight->mutex);
+
+	snd_card_free_when_closed(isight->card);
+}
+
 static const struct ieee1394_device_id isight_id_table[] = {
 	{
 		.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |
@@ -732,10 +730,10 @@ static struct fw_driver isight_driver = {
 		.owner	= THIS_MODULE,
 		.name	= KBUILD_MODNAME,
 		.bus	= &fw_bus_type,
-		.probe	= isight_probe,
-		.remove	= isight_remove,
 	},
+	.probe    = isight_probe,
 	.update   = isight_bus_reset,
+	.remove   = isight_remove,
 	.id_table = isight_id_table,
 };
 

commit 34699403e9916060af8ae23f5e4705a6c078e79d
Merge: 7fc86a7908a4 d1bbd2097293
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 22 20:31:15 2012 -0700

    Merge tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394
    
    Pull IEEE 1394 (FireWire) subsystem updates post v3.3 from Stefan Richter:
    
     - Some SBP-2 initiator fixes, side product from ongoing work on a target.
    
     - Reintroduction of an isochronous I/O feature of the older ieee1394 driver
       stack (flush buffer completions); it was evidently rarely used but not
       actually unused.  Matching libraw1394 code is already available.
    
     - Be sure to prefix all kernel log messages with device name or card name,
       and other logging related cleanups.
    
     - Misc other small cleanups, among them a small API change that affects
       sound/firewire/ too. Clemens Ladisch is aware of it.
    
    * tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394: (26 commits)
      firewire: allow explicit flushing of iso packet completions
      firewire: prevent dropping of completed iso packet header data
      firewire: ohci: factor out iso completion flushing code
      firewire: ohci: simplify iso header pointer arithmetic
      firewire: ohci: optimize control bit checks
      firewire: ohci: remove unused excess_bytes field
      firewire: ohci: copy_iso_headers(): make comment match the code
      firewire: cdev: fix IR multichannel event documentation
      firewire: ohci: fix too-early completion of IR multichannel buffers
      firewire: ohci: move runtime debug facility out of #ifdef
      firewire: tone down some diagnostic log messages
      firewire: sbp2: replace a GFP_ATOMIC allocation
      firewire: sbp2: Fix SCSI sense data mangling
      firewire: sbp2: Ignore SBP-2 targets on the local node
      firewire: sbp2: Take into account Unit_Unique_ID
      firewire: nosy: Use the macro DMA_BIT_MASK().
      firewire: core: convert AR-req handler lock from _irqsave to _bh
      firewire: core: fix race at address_handler unregistration
      firewire: core: remove obsolete comment
      firewire: core: prefix log messages with card name
      ...

commit 210762268466634ddbfaddb48fdf5181ce4b5f2d
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 27 18:53:03 2011 +0200

    firewire: move fw_device reference counting from drivers to core
    
    fw_unit device drivers invariably need to talk to the fw_unit's parent
    (an fw_device) and grandparent (an fw_card).  firewire-core already
    maintains an fw_card reference for the entire lifetime of an fw_device.
    Likewise, let firewire-core maintain an fw_device reference for the
    entire lifetime of an fw_unit so that fw_unit drivers don't have to.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 440030818db7..412b65f740d9 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -612,7 +612,6 @@ static void isight_card_free(struct snd_card *card)
 
 	fw_iso_resources_destroy(&isight->resources);
 	fw_unit_put(isight->unit);
-	fw_device_put(isight->device);
 	mutex_destroy(&isight->mutex);
 }
 
@@ -645,7 +644,7 @@ static int isight_probe(struct device *unit_dev)
 	isight->card = card;
 	mutex_init(&isight->mutex);
 	isight->unit = fw_unit_get(unit);
-	isight->device = fw_device_get(fw_dev);
+	isight->device = fw_dev;
 	isight->audio_base = get_unit_base(unit);
 	if (!isight->audio_base) {
 		dev_err(&unit->device, "audio unit base not found\n");
@@ -682,7 +681,6 @@ static int isight_probe(struct device *unit_dev)
 
 err_unit:
 	fw_unit_put(isight->unit);
-	fw_device_put(isight->device);
 	mutex_destroy(&isight->mutex);
 error:
 	snd_card_free(card);

commit f39d5a88badb22139cca99b06fc4fe729450ba5c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Jun 19 12:10:43 2011 +0200

    ALSA: isight: remove superfluous field
    
    Remove a field that is not used at all.  This remained from
    earlier tests, but the current driver has decided not to handle
    iris notifications.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 440030818db7..cd094ecaca3b 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -51,7 +51,6 @@ struct isight {
 	struct fw_unit *unit;
 	struct fw_device *device;
 	u64 audio_base;
-	struct fw_address_handler iris_handler;
 	struct snd_pcm_substream *pcm;
 	struct mutex mutex;
 	struct iso_packets_buffer buffer;

commit cf6f1ff17f56c275424c5a341fc4d27ccbbfa71c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Jun 17 08:18:35 2011 +0200

    ALSA: isight: adjust for new queueing API
    
    Since commit 13882a82ee16 (optimize iso queueing by setting
    wake only after the last packet), drivers are required to call
    fw_iso_context_queue_flush() after queueing a batch of packets.
    The missing call would have an effect only if the controller
    queue underruns, but then the DMA would stop completely.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 86ee16ca365e..440030818db7 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -209,6 +209,7 @@ static void isight_packet(struct fw_iso_context *context, u32 cycle,
 		isight->packet_index = -1;
 		return;
 	}
+	fw_iso_context_queue_flush(isight->context);
 
 	if (++index >= QUEUE_LENGTH)
 		index = 0;

commit f3f7c1837f6bcae3601fc535b339426868bf1549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed May 11 11:07:09 2011 +0200

    ALSA: isight: fix locking
    
    Lockdep complains about conflicts between isight->mutex,
    ALSA's register_mutex, mm->mmap_sem, and pcm->open_mutex.
    
    This can be fixed by moving the calls to isight_pcm_abort(),
    snd_card_disconnect(), and fw_iso_resources_update() out of
    isight->mutex.  These functions are designed to be called
    asynchronously; the mutex needs to protect only the device
    streaming state modified by isight_start/stop_streaming().
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 96267437d373..86ee16ca365e 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -692,9 +692,11 @@ static int isight_remove(struct device *dev)
 {
 	struct isight *isight = dev_get_drvdata(dev);
 
-	mutex_lock(&isight->mutex);
 	isight_pcm_abort(isight);
+
 	snd_card_disconnect(isight->card);
+
+	mutex_lock(&isight->mutex);
 	isight_stop_streaming(isight);
 	mutex_unlock(&isight->mutex);
 
@@ -707,12 +709,13 @@ static void isight_bus_reset(struct fw_unit *unit)
 {
 	struct isight *isight = dev_get_drvdata(&unit->device);
 
-	mutex_lock(&isight->mutex);
 	if (fw_iso_resources_update(&isight->resources) < 0) {
 		isight_pcm_abort(isight);
+
+		mutex_lock(&isight->mutex);
 		isight_stop_streaming(isight);
+		mutex_unlock(&isight->mutex);
 	}
-	mutex_unlock(&isight->mutex);
 }
 
 static const struct ieee1394_device_id isight_id_table[] = {

commit aee70400184b6a8d39243b02c244aed61259a46b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed May 11 10:53:12 2011 +0200

    ALSA: isight: fix hang when unplugging a running device
    
    When aborting a PCM stream, the xrun is signaled only if the stream is
    running.  When disconnecting a PCM stream, calling snd_card_disconnect()
    too early would change the stream into a non-running state and thus
    prevent the xrun from being noticed by user space.
    
    To prevent this, move the snd_card_disconnect() call after the xrun.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 4d2edcfdbbca..96267437d373 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -692,10 +692,9 @@ static int isight_remove(struct device *dev)
 {
 	struct isight *isight = dev_get_drvdata(dev);
 
-	snd_card_disconnect(isight->card);
-
 	mutex_lock(&isight->mutex);
 	isight_pcm_abort(isight);
+	snd_card_disconnect(isight->card);
 	isight_stop_streaming(isight);
 	mutex_unlock(&isight->mutex);
 

commit ac34dad26e6786257ef54d8df4f883825bea02eb
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Wed May 11 10:52:21 2011 +0200

    ALSA: isight: wrap up register accesses
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    [cl: removed superfluous variable]
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 1a8da2614db6..4d2edcfdbbca 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -5,6 +5,7 @@
  * Licensed under the terms of the GNU General Public License, version 2.
  */
 
+#include <asm/byteorder.h>
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/firewire.h>
@@ -311,23 +312,28 @@ static int isight_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static void isight_stop_streaming(struct isight *isight)
+static int reg_read(struct isight *isight, int offset, __be32 *value)
 {
-	__be32 value;
+	return snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
+				  isight->audio_base + offset, value, 4);
+}
+
+static int reg_write(struct isight *isight, int offset, __be32 value)
+{
+	return snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
+				  isight->audio_base + offset, &value, 4);
+}
 
+static void isight_stop_streaming(struct isight *isight)
+{
 	if (!isight->context)
 		return;
 
 	fw_iso_context_stop(isight->context);
 	fw_iso_context_destroy(isight->context);
 	isight->context = NULL;
-
-	value = 0;
-	snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
-			   isight->audio_base + REG_AUDIO_ENABLE,
-			   &value, 4);
-
 	fw_iso_resources_free(&isight->resources);
+	reg_write(isight, REG_AUDIO_ENABLE, 0);
 }
 
 static int isight_hw_free(struct snd_pcm_substream *substream)
@@ -345,7 +351,6 @@ static int isight_hw_free(struct snd_pcm_substream *substream)
 
 static int isight_start_streaming(struct isight *isight)
 {
-	__be32 value;
 	unsigned int i;
 	int err;
 
@@ -356,21 +361,15 @@ static int isight_start_streaming(struct isight *isight)
 			return 0;
 	}
 
-	value = cpu_to_be32(RATE_48000);
-	err = snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
-				 isight->audio_base + REG_SAMPLE_RATE,
-				 &value, 4);
+	err = reg_write(isight, REG_SAMPLE_RATE, cpu_to_be32(RATE_48000));
 	if (err < 0)
-		return err;
+		goto error;
 
 	err = isight_connect(isight);
 	if (err < 0)
 		goto error;
 
-	value = cpu_to_be32(AUDIO_ENABLE);
-	err = snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
-				 isight->audio_base + REG_AUDIO_ENABLE,
-				 &value, 4);
+	err = reg_write(isight, REG_AUDIO_ENABLE, cpu_to_be32(AUDIO_ENABLE));
 	if (err < 0)
 		goto err_resources;
 
@@ -407,11 +406,8 @@ static int isight_start_streaming(struct isight *isight)
 	fw_iso_context_destroy(isight->context);
 	isight->context = NULL;
 err_resources:
-	value = 0;
-	snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
-			   isight->audio_base + REG_AUDIO_ENABLE,
-			   &value, 4);
 	fw_iso_resources_free(&isight->resources);
+	reg_write(isight, REG_AUDIO_ENABLE, 0);
 error:
 	return err;
 }
@@ -503,8 +499,7 @@ static int isight_gain_get(struct snd_kcontrol *ctl,
 	__be32 gain;
 	int err;
 
-	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
-				 isight->audio_base + REG_GAIN, &gain, 4);
+	err = reg_read(isight, REG_GAIN, &gain);
 	if (err < 0)
 		return err;
 
@@ -517,15 +512,13 @@ static int isight_gain_put(struct snd_kcontrol *ctl,
 			   struct snd_ctl_elem_value *value)
 {
 	struct isight *isight = ctl->private_data;
-	__be32 gain;
 
 	if (value->value.integer.value[0] < isight->gain_min ||
 	    value->value.integer.value[0] > isight->gain_max)
 		return -EINVAL;
 
-	gain = cpu_to_be32(value->value.integer.value[0]);
-	return snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
-				  isight->audio_base + REG_GAIN, &gain, 4);
+	return reg_write(isight, REG_GAIN,
+			 cpu_to_be32(value->value.integer.value[0]));
 }
 
 static int isight_mute_get(struct snd_kcontrol *ctl,
@@ -535,8 +528,7 @@ static int isight_mute_get(struct snd_kcontrol *ctl,
 	__be32 mute;
 	int err;
 
-	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
-				 isight->audio_base + REG_MUTE, &mute, 4);
+	err = reg_read(isight, REG_MUTE, &mute);
 	if (err < 0)
 		return err;
 
@@ -549,11 +541,9 @@ static int isight_mute_put(struct snd_kcontrol *ctl,
 			   struct snd_ctl_elem_value *value)
 {
 	struct isight *isight = ctl->private_data;
-	__be32 mute;
 
-	mute = (__force __be32)!value->value.integer.value[0];
-	return snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
-				  isight->audio_base + REG_MUTE, &mute, 4);
+	return reg_write(isight, REG_MUTE,
+			 (__force __be32)!value->value.integer.value[0]);
 }
 
 static int isight_create_mixer(struct isight *isight)
@@ -578,31 +568,25 @@ static int isight_create_mixer(struct isight *isight)
 	struct snd_kcontrol *ctl;
 	int err;
 
-	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
-				 isight->audio_base + REG_GAIN_RAW_START,
-				 &value, 4);
+	err = reg_read(isight, REG_GAIN_RAW_START, &value);
 	if (err < 0)
 		return err;
 	isight->gain_min = be32_to_cpu(value);
 
-	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
-				 isight->audio_base + REG_GAIN_RAW_END,
-				 &value, 4);
+	err = reg_read(isight, REG_GAIN_RAW_END, &value);
 	if (err < 0)
 		return err;
 	isight->gain_max = be32_to_cpu(value);
 
 	isight->gain_tlv[0] = SNDRV_CTL_TLVT_DB_MINMAX;
 	isight->gain_tlv[1] = 2 * sizeof(unsigned int);
-	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
-				 isight->audio_base + REG_GAIN_DB_START,
-				 &value, 4);
+
+	err = reg_read(isight, REG_GAIN_DB_START, &value);
 	if (err < 0)
 		return err;
 	isight->gain_tlv[2] = (s32)be32_to_cpu(value) * 100;
-	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
-				 isight->audio_base + REG_GAIN_DB_END,
-				 &value, 4);
+
+	err = reg_read(isight, REG_GAIN_DB_END, &value);
 	if (err < 0)
 		return err;
 	isight->gain_tlv[3] = (s32)be32_to_cpu(value) * 100;

commit 8839eedafd2e91e5b124730825e9b39b1ff493dd
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Wed May 11 10:49:58 2011 +0200

    ALSA: isight: add AudioEnable register write
    
    which is needed to get the iSight to talk.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 10a9b9b0b2c2..1a8da2614db6 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -345,7 +345,7 @@ static int isight_hw_free(struct snd_pcm_substream *substream)
 
 static int isight_start_streaming(struct isight *isight)
 {
-	__be32 sample_rate;
+	__be32 value;
 	unsigned int i;
 	int err;
 
@@ -356,10 +356,10 @@ static int isight_start_streaming(struct isight *isight)
 			return 0;
 	}
 
-	sample_rate = cpu_to_be32(RATE_48000);
+	value = cpu_to_be32(RATE_48000);
 	err = snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
 				 isight->audio_base + REG_SAMPLE_RATE,
-				 &sample_rate, 4);
+				 &value, 4);
 	if (err < 0)
 		return err;
 
@@ -367,6 +367,13 @@ static int isight_start_streaming(struct isight *isight)
 	if (err < 0)
 		goto error;
 
+	value = cpu_to_be32(AUDIO_ENABLE);
+	err = snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
+				 isight->audio_base + REG_AUDIO_ENABLE,
+				 &value, 4);
+	if (err < 0)
+		goto err_resources;
+
 	isight->context = fw_iso_context_create(isight->device->card,
 						FW_ISO_CONTEXT_RECEIVE,
 						isight->resources.channel,
@@ -400,6 +407,10 @@ static int isight_start_streaming(struct isight *isight)
 	fw_iso_context_destroy(isight->context);
 	isight->context = NULL;
 err_resources:
+	value = 0;
+	snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
+			   isight->audio_base + REG_AUDIO_ENABLE,
+			   &value, 4);
 	fw_iso_resources_free(&isight->resources);
 error:
 	return err;

commit f2934cd499ba2c7f605787508b4cfcfa3a45b0a4
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed May 11 10:49:02 2011 +0200

    ALSA: isight: fix divide error when queueing packets
    
    Set the .header_size field when queueing packets to avoid a division by
    zero.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 4e334919a70f..10a9b9b0b2c2 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -82,6 +82,7 @@ MODULE_LICENSE("GPL v2");
 static struct fw_iso_packet audio_packet = {
 	.payload_length = sizeof(struct audio_payload),
 	.interrupt = 1,
+	.header_length = 4,
 };
 
 static void isight_update_pointers(struct isight *isight, unsigned int count)

commit 898732d1f1c7181fd3e94e7d7a784edb48d09d95
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed May 11 10:48:24 2011 +0200

    ALSA: isight: fix packet requeueing
    
    After handling a received packet, we want to resubmit the same packet,
    so do not increase the packet index too early.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index 0230605c917e..4e334919a70f 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -198,9 +198,6 @@ static void isight_packet(struct fw_iso_context *context, u32 cycle,
 		}
 	}
 
-	if (++index >= QUEUE_LENGTH)
-		index = 0;
-
 	err = fw_iso_context_queue(isight->context, &audio_packet,
 				   &isight->buffer.iso_buffer,
 				   isight->buffer.packets[index].offset);
@@ -211,6 +208,8 @@ static void isight_packet(struct fw_iso_context *context, u32 cycle,
 		return;
 	}
 
+	if (++index >= QUEUE_LENGTH)
+		index = 0;
 	isight->packet_index = index;
 }
 

commit 03c29680d49662859d14d64f8673550fa3fb2ed1
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed May 11 10:47:30 2011 +0200

    ALSA: isight: fix isight_pcm_abort() crashes
    
    Fix crashes in isight_pcm_abort() that happen when the driver tries to
    access isight->pcm->runtime which does not exist when the device is not
    open.  Introduce a new field pcm_active to track this state.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
index a6f19f57a1c3..0230605c917e 100644
--- a/sound/firewire/isight.c
+++ b/sound/firewire/isight.c
@@ -56,6 +56,7 @@ struct isight {
 	struct iso_packets_buffer buffer;
 	struct fw_iso_resources resources;
 	struct fw_iso_context *context;
+	bool pcm_active;
 	bool pcm_running;
 	bool first_packet;
 	int packet_index;
@@ -131,10 +132,12 @@ static void isight_pcm_abort(struct isight *isight)
 {
 	unsigned long flags;
 
-	snd_pcm_stream_lock_irqsave(isight->pcm, flags);
-	if (snd_pcm_running(isight->pcm))
-		snd_pcm_stop(isight->pcm, SNDRV_PCM_STATE_XRUN);
-	snd_pcm_stream_unlock_irqrestore(isight->pcm, flags);
+	if (ACCESS_ONCE(isight->pcm_active)) {
+		snd_pcm_stream_lock_irqsave(isight->pcm, flags);
+		if (snd_pcm_running(isight->pcm))
+			snd_pcm_stop(isight->pcm, SNDRV_PCM_STATE_XRUN);
+		snd_pcm_stream_unlock_irqrestore(isight->pcm, flags);
+	}
 }
 
 static void isight_dropped_samples(struct isight *isight, unsigned int total)
@@ -295,8 +298,17 @@ static int isight_close(struct snd_pcm_substream *substream)
 static int isight_hw_params(struct snd_pcm_substream *substream,
 			    struct snd_pcm_hw_params *hw_params)
 {
-	return snd_pcm_lib_alloc_vmalloc_buffer(substream,
-						params_buffer_bytes(hw_params));
+	struct isight *isight = substream->private_data;
+	int err;
+
+	err = snd_pcm_lib_alloc_vmalloc_buffer(substream,
+					       params_buffer_bytes(hw_params));
+	if (err < 0)
+		return err;
+
+	ACCESS_ONCE(isight->pcm_active) = true;
+
+	return 0;
 }
 
 static void isight_stop_streaming(struct isight *isight)
@@ -322,6 +334,8 @@ static int isight_hw_free(struct snd_pcm_substream *substream)
 {
 	struct isight *isight = substream->private_data;
 
+	ACCESS_ONCE(isight->pcm_active) = false;
+
 	mutex_lock(&isight->mutex);
 	isight_stop_streaming(isight);
 	mutex_unlock(&isight->mutex);

commit 3a691b28a0ca3cf4d9010c6158318159e0275d2c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed May 11 10:44:51 2011 +0200

    ALSA: add Apple iSight microphone driver
    
    This adds an experimental driver for the front and rear microphones of
    the Apple iSight web camera.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/isight.c b/sound/firewire/isight.c
new file mode 100644
index 000000000000..a6f19f57a1c3
--- /dev/null
+++ b/sound/firewire/isight.c
@@ -0,0 +1,744 @@
+/*
+ * Apple iSight audio driver
+ *
+ * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firewire.h>
+#include <linux/firewire-constants.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/mutex.h>
+#include <linux/string.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/tlv.h>
+#include "lib.h"
+#include "iso-resources.h"
+#include "packets-buffer.h"
+
+#define OUI_APPLE		0x000a27
+#define MODEL_APPLE_ISIGHT	0x000008
+#define SW_ISIGHT_AUDIO		0x000010
+
+#define REG_AUDIO_ENABLE	0x000
+#define  AUDIO_ENABLE		0x80000000
+#define REG_DEF_AUDIO_GAIN	0x204
+#define REG_GAIN_RAW_START	0x210
+#define REG_GAIN_RAW_END	0x214
+#define REG_GAIN_DB_START	0x218
+#define REG_GAIN_DB_END		0x21c
+#define REG_SAMPLE_RATE_INQUIRY	0x280
+#define REG_ISO_TX_CONFIG	0x300
+#define  SPEED_SHIFT		16
+#define REG_SAMPLE_RATE		0x400
+#define  RATE_48000		0x80000000
+#define REG_GAIN		0x500
+#define REG_MUTE		0x504
+
+#define MAX_FRAMES_PER_PACKET	475
+
+#define QUEUE_LENGTH		20
+
+struct isight {
+	struct snd_card *card;
+	struct fw_unit *unit;
+	struct fw_device *device;
+	u64 audio_base;
+	struct fw_address_handler iris_handler;
+	struct snd_pcm_substream *pcm;
+	struct mutex mutex;
+	struct iso_packets_buffer buffer;
+	struct fw_iso_resources resources;
+	struct fw_iso_context *context;
+	bool pcm_running;
+	bool first_packet;
+	int packet_index;
+	u32 total_samples;
+	unsigned int buffer_pointer;
+	unsigned int period_counter;
+	s32 gain_min, gain_max;
+	unsigned int gain_tlv[4];
+};
+
+struct audio_payload {
+	__be32 sample_count;
+	__be32 signature;
+	__be32 sample_total;
+	__be32 reserved;
+	__be16 samples[2 * MAX_FRAMES_PER_PACKET];
+};
+
+MODULE_DESCRIPTION("iSight audio driver");
+MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
+MODULE_LICENSE("GPL v2");
+
+static struct fw_iso_packet audio_packet = {
+	.payload_length = sizeof(struct audio_payload),
+	.interrupt = 1,
+};
+
+static void isight_update_pointers(struct isight *isight, unsigned int count)
+{
+	struct snd_pcm_runtime *runtime = isight->pcm->runtime;
+	unsigned int ptr;
+
+	smp_wmb(); /* update buffer data before buffer pointer */
+
+	ptr = isight->buffer_pointer;
+	ptr += count;
+	if (ptr >= runtime->buffer_size)
+		ptr -= runtime->buffer_size;
+	ACCESS_ONCE(isight->buffer_pointer) = ptr;
+
+	isight->period_counter += count;
+	if (isight->period_counter >= runtime->period_size) {
+		isight->period_counter -= runtime->period_size;
+		snd_pcm_period_elapsed(isight->pcm);
+	}
+}
+
+static void isight_samples(struct isight *isight,
+			   const __be16 *samples, unsigned int count)
+{
+	struct snd_pcm_runtime *runtime;
+	unsigned int count1;
+
+	if (!ACCESS_ONCE(isight->pcm_running))
+		return;
+
+	runtime = isight->pcm->runtime;
+	if (isight->buffer_pointer + count <= runtime->buffer_size) {
+		memcpy(runtime->dma_area + isight->buffer_pointer * 4,
+		       samples, count * 4);
+	} else {
+		count1 = runtime->buffer_size - isight->buffer_pointer;
+		memcpy(runtime->dma_area + isight->buffer_pointer * 4,
+		       samples, count1 * 4);
+		samples += count1 * 2;
+		memcpy(runtime->dma_area, samples, (count - count1) * 4);
+	}
+
+	isight_update_pointers(isight, count);
+}
+
+static void isight_pcm_abort(struct isight *isight)
+{
+	unsigned long flags;
+
+	snd_pcm_stream_lock_irqsave(isight->pcm, flags);
+	if (snd_pcm_running(isight->pcm))
+		snd_pcm_stop(isight->pcm, SNDRV_PCM_STATE_XRUN);
+	snd_pcm_stream_unlock_irqrestore(isight->pcm, flags);
+}
+
+static void isight_dropped_samples(struct isight *isight, unsigned int total)
+{
+	struct snd_pcm_runtime *runtime;
+	u32 dropped;
+	unsigned int count1;
+
+	if (!ACCESS_ONCE(isight->pcm_running))
+		return;
+
+	runtime = isight->pcm->runtime;
+	dropped = total - isight->total_samples;
+	if (dropped < runtime->buffer_size) {
+		if (isight->buffer_pointer + dropped <= runtime->buffer_size) {
+			memset(runtime->dma_area + isight->buffer_pointer * 4,
+			       0, dropped * 4);
+		} else {
+			count1 = runtime->buffer_size - isight->buffer_pointer;
+			memset(runtime->dma_area + isight->buffer_pointer * 4,
+			       0, count1 * 4);
+			memset(runtime->dma_area, 0, (dropped - count1) * 4);
+		}
+		isight_update_pointers(isight, dropped);
+	} else {
+		isight_pcm_abort(isight);
+	}
+}
+
+static void isight_packet(struct fw_iso_context *context, u32 cycle,
+			  size_t header_length, void *header, void *data)
+{
+	struct isight *isight = data;
+	const struct audio_payload *payload;
+	unsigned int index, length, count, total;
+	int err;
+
+	if (isight->packet_index < 0)
+		return;
+	index = isight->packet_index;
+	payload = isight->buffer.packets[index].buffer;
+	length = be32_to_cpup(header) >> 16;
+
+	if (likely(length >= 16 &&
+		   payload->signature == cpu_to_be32(0x73676874/*"sght"*/))) {
+		count = be32_to_cpu(payload->sample_count);
+		if (likely(count <= (length - 16) / 4)) {
+			total = be32_to_cpu(payload->sample_total);
+			if (unlikely(total != isight->total_samples)) {
+				if (!isight->first_packet)
+					isight_dropped_samples(isight, total);
+				isight->first_packet = false;
+				isight->total_samples = total;
+			}
+
+			isight_samples(isight, payload->samples, count);
+			isight->total_samples += count;
+		}
+	}
+
+	if (++index >= QUEUE_LENGTH)
+		index = 0;
+
+	err = fw_iso_context_queue(isight->context, &audio_packet,
+				   &isight->buffer.iso_buffer,
+				   isight->buffer.packets[index].offset);
+	if (err < 0) {
+		dev_err(&isight->unit->device, "queueing error: %d\n", err);
+		isight_pcm_abort(isight);
+		isight->packet_index = -1;
+		return;
+	}
+
+	isight->packet_index = index;
+}
+
+static int isight_connect(struct isight *isight)
+{
+	int ch, err, rcode, errors = 0;
+	__be32 value;
+
+retry_after_bus_reset:
+	ch = fw_iso_resources_allocate(&isight->resources,
+				       sizeof(struct audio_payload),
+				       isight->device->max_speed);
+	if (ch < 0) {
+		err = ch;
+		goto error;
+	}
+
+	value = cpu_to_be32(ch | (isight->device->max_speed << SPEED_SHIFT));
+	for (;;) {
+		rcode = fw_run_transaction(
+				isight->device->card,
+				TCODE_WRITE_QUADLET_REQUEST,
+				isight->device->node_id,
+				isight->resources.generation,
+				isight->device->max_speed,
+				isight->audio_base + REG_ISO_TX_CONFIG,
+				&value, 4);
+		if (rcode == RCODE_COMPLETE) {
+			return 0;
+		} else if (rcode == RCODE_GENERATION) {
+			fw_iso_resources_free(&isight->resources);
+			goto retry_after_bus_reset;
+		} else if (rcode_is_permanent_error(rcode) || ++errors >= 3) {
+			err = -EIO;
+			goto err_resources;
+		}
+		msleep(5);
+	}
+
+err_resources:
+	fw_iso_resources_free(&isight->resources);
+error:
+	return err;
+}
+
+static int isight_open(struct snd_pcm_substream *substream)
+{
+	static const struct snd_pcm_hardware hardware = {
+		.info = SNDRV_PCM_INFO_MMAP |
+			SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_BATCH |
+			SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER,
+		.formats = SNDRV_PCM_FMTBIT_S16_BE,
+		.rates = SNDRV_PCM_RATE_48000,
+		.rate_min = 48000,
+		.rate_max = 48000,
+		.channels_min = 2,
+		.channels_max = 2,
+		.buffer_bytes_max = 4 * 1024 * 1024,
+		.period_bytes_min = MAX_FRAMES_PER_PACKET * 4,
+		.period_bytes_max = 1024 * 1024,
+		.periods_min = 2,
+		.periods_max = UINT_MAX,
+	};
+	struct isight *isight = substream->private_data;
+
+	substream->runtime->hw = hardware;
+
+	return iso_packets_buffer_init(&isight->buffer, isight->unit,
+				       QUEUE_LENGTH,
+				       sizeof(struct audio_payload),
+				       DMA_FROM_DEVICE);
+}
+
+static int isight_close(struct snd_pcm_substream *substream)
+{
+	struct isight *isight = substream->private_data;
+
+	iso_packets_buffer_destroy(&isight->buffer, isight->unit);
+
+	return 0;
+}
+
+static int isight_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *hw_params)
+{
+	return snd_pcm_lib_alloc_vmalloc_buffer(substream,
+						params_buffer_bytes(hw_params));
+}
+
+static void isight_stop_streaming(struct isight *isight)
+{
+	__be32 value;
+
+	if (!isight->context)
+		return;
+
+	fw_iso_context_stop(isight->context);
+	fw_iso_context_destroy(isight->context);
+	isight->context = NULL;
+
+	value = 0;
+	snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
+			   isight->audio_base + REG_AUDIO_ENABLE,
+			   &value, 4);
+
+	fw_iso_resources_free(&isight->resources);
+}
+
+static int isight_hw_free(struct snd_pcm_substream *substream)
+{
+	struct isight *isight = substream->private_data;
+
+	mutex_lock(&isight->mutex);
+	isight_stop_streaming(isight);
+	mutex_unlock(&isight->mutex);
+
+	return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int isight_start_streaming(struct isight *isight)
+{
+	__be32 sample_rate;
+	unsigned int i;
+	int err;
+
+	if (isight->context) {
+		if (isight->packet_index < 0)
+			isight_stop_streaming(isight);
+		else
+			return 0;
+	}
+
+	sample_rate = cpu_to_be32(RATE_48000);
+	err = snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
+				 isight->audio_base + REG_SAMPLE_RATE,
+				 &sample_rate, 4);
+	if (err < 0)
+		return err;
+
+	err = isight_connect(isight);
+	if (err < 0)
+		goto error;
+
+	isight->context = fw_iso_context_create(isight->device->card,
+						FW_ISO_CONTEXT_RECEIVE,
+						isight->resources.channel,
+						isight->device->max_speed,
+						4, isight_packet, isight);
+	if (IS_ERR(isight->context)) {
+		err = PTR_ERR(isight->context);
+		isight->context = NULL;
+		goto err_resources;
+	}
+
+	for (i = 0; i < QUEUE_LENGTH; ++i) {
+		err = fw_iso_context_queue(isight->context, &audio_packet,
+					   &isight->buffer.iso_buffer,
+					   isight->buffer.packets[i].offset);
+		if (err < 0)
+			goto err_context;
+	}
+
+	isight->first_packet = true;
+	isight->packet_index = 0;
+
+	err = fw_iso_context_start(isight->context, -1, 0,
+				   FW_ISO_CONTEXT_MATCH_ALL_TAGS/*?*/);
+	if (err < 0)
+		goto err_context;
+
+	return 0;
+
+err_context:
+	fw_iso_context_destroy(isight->context);
+	isight->context = NULL;
+err_resources:
+	fw_iso_resources_free(&isight->resources);
+error:
+	return err;
+}
+
+static int isight_prepare(struct snd_pcm_substream *substream)
+{
+	struct isight *isight = substream->private_data;
+	int err;
+
+	isight->buffer_pointer = 0;
+	isight->period_counter = 0;
+
+	mutex_lock(&isight->mutex);
+	err = isight_start_streaming(isight);
+	mutex_unlock(&isight->mutex);
+
+	return err;
+}
+
+static int isight_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct isight *isight = substream->private_data;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		ACCESS_ONCE(isight->pcm_running) = true;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		ACCESS_ONCE(isight->pcm_running) = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static snd_pcm_uframes_t isight_pointer(struct snd_pcm_substream *substream)
+{
+	struct isight *isight = substream->private_data;
+
+	return ACCESS_ONCE(isight->buffer_pointer);
+}
+
+static int isight_create_pcm(struct isight *isight)
+{
+	static struct snd_pcm_ops ops = {
+		.open      = isight_open,
+		.close     = isight_close,
+		.ioctl     = snd_pcm_lib_ioctl,
+		.hw_params = isight_hw_params,
+		.hw_free   = isight_hw_free,
+		.prepare   = isight_prepare,
+		.trigger   = isight_trigger,
+		.pointer   = isight_pointer,
+		.page      = snd_pcm_lib_get_vmalloc_page,
+		.mmap      = snd_pcm_lib_mmap_vmalloc,
+	};
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_pcm_new(isight->card, "iSight", 0, 0, 1, &pcm);
+	if (err < 0)
+		return err;
+	pcm->private_data = isight;
+	strcpy(pcm->name, "iSight");
+	isight->pcm = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;
+	isight->pcm->ops = &ops;
+
+	return 0;
+}
+
+static int isight_gain_info(struct snd_kcontrol *ctl,
+			    struct snd_ctl_elem_info *info)
+{
+	struct isight *isight = ctl->private_data;
+
+	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	info->count = 1;
+	info->value.integer.min = isight->gain_min;
+	info->value.integer.max = isight->gain_max;
+
+	return 0;
+}
+
+static int isight_gain_get(struct snd_kcontrol *ctl,
+			   struct snd_ctl_elem_value *value)
+{
+	struct isight *isight = ctl->private_data;
+	__be32 gain;
+	int err;
+
+	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
+				 isight->audio_base + REG_GAIN, &gain, 4);
+	if (err < 0)
+		return err;
+
+	value->value.integer.value[0] = (s32)be32_to_cpu(gain);
+
+	return 0;
+}
+
+static int isight_gain_put(struct snd_kcontrol *ctl,
+			   struct snd_ctl_elem_value *value)
+{
+	struct isight *isight = ctl->private_data;
+	__be32 gain;
+
+	if (value->value.integer.value[0] < isight->gain_min ||
+	    value->value.integer.value[0] > isight->gain_max)
+		return -EINVAL;
+
+	gain = cpu_to_be32(value->value.integer.value[0]);
+	return snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
+				  isight->audio_base + REG_GAIN, &gain, 4);
+}
+
+static int isight_mute_get(struct snd_kcontrol *ctl,
+			   struct snd_ctl_elem_value *value)
+{
+	struct isight *isight = ctl->private_data;
+	__be32 mute;
+	int err;
+
+	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
+				 isight->audio_base + REG_MUTE, &mute, 4);
+	if (err < 0)
+		return err;
+
+	value->value.integer.value[0] = !mute;
+
+	return 0;
+}
+
+static int isight_mute_put(struct snd_kcontrol *ctl,
+			   struct snd_ctl_elem_value *value)
+{
+	struct isight *isight = ctl->private_data;
+	__be32 mute;
+
+	mute = (__force __be32)!value->value.integer.value[0];
+	return snd_fw_transaction(isight->unit, TCODE_WRITE_QUADLET_REQUEST,
+				  isight->audio_base + REG_MUTE, &mute, 4);
+}
+
+static int isight_create_mixer(struct isight *isight)
+{
+	static const struct snd_kcontrol_new gain_control = {
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Mic Capture Volume",
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
+		.info = isight_gain_info,
+		.get = isight_gain_get,
+		.put = isight_gain_put,
+	};
+	static const struct snd_kcontrol_new mute_control = {
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Mic Capture Switch",
+		.info = snd_ctl_boolean_mono_info,
+		.get = isight_mute_get,
+		.put = isight_mute_put,
+	};
+	__be32 value;
+	struct snd_kcontrol *ctl;
+	int err;
+
+	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
+				 isight->audio_base + REG_GAIN_RAW_START,
+				 &value, 4);
+	if (err < 0)
+		return err;
+	isight->gain_min = be32_to_cpu(value);
+
+	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
+				 isight->audio_base + REG_GAIN_RAW_END,
+				 &value, 4);
+	if (err < 0)
+		return err;
+	isight->gain_max = be32_to_cpu(value);
+
+	isight->gain_tlv[0] = SNDRV_CTL_TLVT_DB_MINMAX;
+	isight->gain_tlv[1] = 2 * sizeof(unsigned int);
+	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
+				 isight->audio_base + REG_GAIN_DB_START,
+				 &value, 4);
+	if (err < 0)
+		return err;
+	isight->gain_tlv[2] = (s32)be32_to_cpu(value) * 100;
+	err = snd_fw_transaction(isight->unit, TCODE_READ_QUADLET_REQUEST,
+				 isight->audio_base + REG_GAIN_DB_END,
+				 &value, 4);
+	if (err < 0)
+		return err;
+	isight->gain_tlv[3] = (s32)be32_to_cpu(value) * 100;
+
+	ctl = snd_ctl_new1(&gain_control, isight);
+	if (ctl)
+		ctl->tlv.p = isight->gain_tlv;
+	err = snd_ctl_add(isight->card, ctl);
+	if (err < 0)
+		return err;
+
+	err = snd_ctl_add(isight->card, snd_ctl_new1(&mute_control, isight));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static void isight_card_free(struct snd_card *card)
+{
+	struct isight *isight = card->private_data;
+
+	fw_iso_resources_destroy(&isight->resources);
+	fw_unit_put(isight->unit);
+	fw_device_put(isight->device);
+	mutex_destroy(&isight->mutex);
+}
+
+static u64 get_unit_base(struct fw_unit *unit)
+{
+	struct fw_csr_iterator i;
+	int key, value;
+
+	fw_csr_iterator_init(&i, unit->directory);
+	while (fw_csr_iterator_next(&i, &key, &value))
+		if (key == CSR_OFFSET)
+			return CSR_REGISTER_BASE + value * 4;
+	return 0;
+}
+
+static int isight_probe(struct device *unit_dev)
+{
+	struct fw_unit *unit = fw_unit(unit_dev);
+	struct fw_device *fw_dev = fw_parent_device(unit);
+	struct snd_card *card;
+	struct isight *isight;
+	int err;
+
+	err = snd_card_create(-1, NULL, THIS_MODULE, sizeof(*isight), &card);
+	if (err < 0)
+		return err;
+	snd_card_set_dev(card, unit_dev);
+
+	isight = card->private_data;
+	isight->card = card;
+	mutex_init(&isight->mutex);
+	isight->unit = fw_unit_get(unit);
+	isight->device = fw_device_get(fw_dev);
+	isight->audio_base = get_unit_base(unit);
+	if (!isight->audio_base) {
+		dev_err(&unit->device, "audio unit base not found\n");
+		err = -ENXIO;
+		goto err_unit;
+	}
+	fw_iso_resources_init(&isight->resources, unit);
+
+	card->private_free = isight_card_free;
+
+	strcpy(card->driver, "iSight");
+	strcpy(card->shortname, "Apple iSight");
+	snprintf(card->longname, sizeof(card->longname),
+		 "Apple iSight (GUID %08x%08x) at %s, S%d",
+		 fw_dev->config_rom[3], fw_dev->config_rom[4],
+		 dev_name(&unit->device), 100 << fw_dev->max_speed);
+	strcpy(card->mixername, "iSight");
+
+	err = isight_create_pcm(isight);
+	if (err < 0)
+		goto error;
+
+	err = isight_create_mixer(isight);
+	if (err < 0)
+		goto error;
+
+	err = snd_card_register(card);
+	if (err < 0)
+		goto error;
+
+	dev_set_drvdata(unit_dev, isight);
+
+	return 0;
+
+err_unit:
+	fw_unit_put(isight->unit);
+	fw_device_put(isight->device);
+	mutex_destroy(&isight->mutex);
+error:
+	snd_card_free(card);
+	return err;
+}
+
+static int isight_remove(struct device *dev)
+{
+	struct isight *isight = dev_get_drvdata(dev);
+
+	snd_card_disconnect(isight->card);
+
+	mutex_lock(&isight->mutex);
+	isight_pcm_abort(isight);
+	isight_stop_streaming(isight);
+	mutex_unlock(&isight->mutex);
+
+	snd_card_free_when_closed(isight->card);
+
+	return 0;
+}
+
+static void isight_bus_reset(struct fw_unit *unit)
+{
+	struct isight *isight = dev_get_drvdata(&unit->device);
+
+	mutex_lock(&isight->mutex);
+	if (fw_iso_resources_update(&isight->resources) < 0) {
+		isight_pcm_abort(isight);
+		isight_stop_streaming(isight);
+	}
+	mutex_unlock(&isight->mutex);
+}
+
+static const struct ieee1394_device_id isight_id_table[] = {
+	{
+		.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |
+				IEEE1394_MATCH_VERSION,
+		.specifier_id = OUI_APPLE,
+		.version      = SW_ISIGHT_AUDIO,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(ieee1394, isight_id_table);
+
+static struct fw_driver isight_driver = {
+	.driver   = {
+		.owner	= THIS_MODULE,
+		.name	= KBUILD_MODNAME,
+		.bus	= &fw_bus_type,
+		.probe	= isight_probe,
+		.remove	= isight_remove,
+	},
+	.update   = isight_bus_reset,
+	.id_table = isight_id_table,
+};
+
+static int __init alsa_isight_init(void)
+{
+	return driver_register(&isight_driver.driver);
+}
+
+static void __exit alsa_isight_exit(void)
+{
+	driver_unregister(&isight_driver.driver);
+}
+
+module_init(alsa_isight_init);
+module_exit(alsa_isight_exit);
