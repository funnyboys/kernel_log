commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/iso-resources.c b/sound/firewire/iso-resources.c
index 066b5df666f4..84f71b2eaa82 100644
--- a/sound/firewire/iso-resources.c
+++ b/sound/firewire/iso-resources.c
@@ -1,8 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * isochronous resources helper functions
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include <linux/device.h>

commit 0c264af7be2013266c5b4c644f3f366399ee490a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 20 15:54:26 2017 +0900

    ALSA: firewire: fix NULL pointer dereference when releasing uninitialized data of iso-resource
    
    When calling 'iso_resource_free()' for uninitialized data, this function
    causes NULL pointer dereference due to its 'unit' member. This occurs when
    unplugging audio and music units on IEEE 1394 bus at failure of card
    registration.
    
    This commit fixes the bug. The bug exists since kernel v4.5.
    
    Fixes: 324540c4e05c ('ALSA: fireface: postpone sound card registration') at v4.12
    Fixes: 8865a31e0fd8 ('ALSA: firewire-motu: postpone sound card registration') at v4.12
    Fixes: b610386c8afb ('ALSA: firewire-tascam: deleyed registration of sound card') at v4.7
    Fixes: 86c8dd7f4da3 ('ALSA: firewire-digi00x: delayed registration of sound card') at v4.7
    Fixes: 6c29230e2a5f ('ALSA: oxfw: delayed registration of sound card') at v4.7
    Fixes: 7d3c1d5901aa ('ALSA: fireworks: delayed registration of sound card') at v4.7
    Fixes: 04a2c73c97eb ('ALSA: bebob: delayed registration of sound card') at v4.7
    Fixes: b59fb1900b4f ('ALSA: dice: postpone card registration') at v4.5
    Cc: <stable@vger.kernel.org> # v4.5+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/iso-resources.c b/sound/firewire/iso-resources.c
index f0e4d502d604..066b5df666f4 100644
--- a/sound/firewire/iso-resources.c
+++ b/sound/firewire/iso-resources.c
@@ -210,9 +210,14 @@ EXPORT_SYMBOL(fw_iso_resources_update);
  */
 void fw_iso_resources_free(struct fw_iso_resources *r)
 {
-	struct fw_card *card = fw_parent_device(r->unit)->card;
+	struct fw_card *card;
 	int bandwidth, channel;
 
+	/* Not initialized. */
+	if (r->unit == NULL)
+		return;
+	card = fw_parent_device(r->unit)->card;
+
 	mutex_lock(&r->mutex);
 
 	if (r->allocated) {

commit 59294a01d7037f63fb8bf994af10ce63c618770a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Mar 10 21:54:35 2015 +0900

    ALSA: firewire-lib: leave unit reference counting completely
    
    With previous commit, this module managed to leave the counting to each
    drivers, but the isochronous resources functionality still increment/decrement
    the count.
    
    This commit purge such codes to leave the responsibility to each drivers.
    
    Fix: c6f224dc20ad ('ALSA: firewire-lib: remove reference counting')
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/iso-resources.c b/sound/firewire/iso-resources.c
index 5f17b77ee152..f0e4d502d604 100644
--- a/sound/firewire/iso-resources.c
+++ b/sound/firewire/iso-resources.c
@@ -26,7 +26,7 @@
 int fw_iso_resources_init(struct fw_iso_resources *r, struct fw_unit *unit)
 {
 	r->channels_mask = ~0uLL;
-	r->unit = fw_unit_get(unit);
+	r->unit = unit;
 	mutex_init(&r->mutex);
 	r->allocated = false;
 
@@ -42,7 +42,6 @@ void fw_iso_resources_destroy(struct fw_iso_resources *r)
 {
 	WARN_ON(r->allocated);
 	mutex_destroy(&r->mutex);
-	fw_unit_put(r->unit);
 }
 EXPORT_SYMBOL(fw_iso_resources_destroy);
 

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/firewire/iso-resources.c b/sound/firewire/iso-resources.c
index ffe20b877e9f..5f17b77ee152 100644
--- a/sound/firewire/iso-resources.c
+++ b/sound/firewire/iso-resources.c
@@ -8,6 +8,7 @@
 #include <linux/device.h>
 #include <linux/firewire.h>
 #include <linux/firewire-constants.h>
+#include <linux/export.h>
 #include <linux/jiffies.h>
 #include <linux/mutex.h>
 #include <linux/sched.h>

commit 710421cc7d295cc59eb2676fe2ba3bc3252c124e
Merge: d7ef64a9f998 f686c74cc3e7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 23 08:52:38 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6: (346 commits)
      ASoC: core: Don't set "(null)" as a driver name
      ALSA: hda - Use LPIB for ATI/AMD chipsets as default
      Revert "ALSA: hda - Use position_fix=3 as default for AMD chipsets"
      ASoC: Tegra: Fix compile when debugfs not enabled
      ASoC: spdif-dit: Add missing MODULE_*
      SOUND: OSS: Remove Au1550 driver.
      ALSA: hda - add Intel Panther Point HDMI codec id
      ALSA: emu10k1 - Add dB range to Bass and Treble for SB Live!
      ALSA: hda - Remove PCM mixer elements from Virtual Master of realtek
      ALSA: hda - Fix input-src parse in patch_analog.c
      ASoC: davinci-mcasp: enable ping-pong SRAM buffers
      ASoC: add iPAQ hx4700 machine driver
      ASoC: Asahi Kasei AK4641 codec driver
      ALSA: hda - Enable Realtek ALC269 codec input layer beep
      ALSA: intel8x0m: enable AMD8111 modem
      ALSA: HDA: Add jack detection for HDMI
      ALSA: sound, core, pcm_lib: fix xrun_log
      ASoC: Max98095: Move existing NULL check before pointer dereference.
      ALSA: sound, core, pcm_lib: xrun_log: log also in_interrupt
      ALSA: usb-audio - Add support for USB X-Fi S51 Pro
      ...

commit 3a691b28a0ca3cf4d9010c6158318159e0275d2c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed May 11 10:44:51 2011 +0200

    ALSA: add Apple iSight microphone driver
    
    This adds an experimental driver for the front and rear microphones of
    the Apple iSight web camera.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/iso-resources.c b/sound/firewire/iso-resources.c
index 775dbd5f3445..9d4a6714f9ec 100644
--- a/sound/firewire/iso-resources.c
+++ b/sound/firewire/iso-resources.c
@@ -36,6 +36,7 @@ int fw_iso_resources_init(struct fw_iso_resources *r, struct fw_unit *unit)
 
 	return 0;
 }
+EXPORT_SYMBOL(fw_iso_resources_init);
 
 /**
  * fw_iso_resources_destroy - destroy a resource manager
@@ -48,6 +49,7 @@ void fw_iso_resources_destroy(struct fw_iso_resources *r)
 	mutex_destroy(&r->mutex);
 	fw_unit_put(r->unit);
 }
+EXPORT_SYMBOL(fw_iso_resources_destroy);
 
 static unsigned int packet_bandwidth(unsigned int max_payload_bytes, int speed)
 {
@@ -152,6 +154,7 @@ int fw_iso_resources_allocate(struct fw_iso_resources *r,
 
 	return channel;
 }
+EXPORT_SYMBOL(fw_iso_resources_allocate);
 
 /**
  * fw_iso_resources_update - update resource allocations after a bus reset
@@ -203,6 +206,7 @@ int fw_iso_resources_update(struct fw_iso_resources *r)
 
 	return channel;
 }
+EXPORT_SYMBOL(fw_iso_resources_update);
 
 /**
  * fw_iso_resources_free - frees allocated resources
@@ -230,3 +234,4 @@ void fw_iso_resources_free(struct fw_iso_resources *r)
 
 	mutex_unlock(&r->mutex);
 }
+EXPORT_SYMBOL(fw_iso_resources_free);

commit f30e6d3e419bfb5540fa82ba7eca01d578556e6b
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Apr 22 15:13:54 2011 +0200

    firewire: octlet AT payloads can be stack-allocated
    
    We do not need slab allocations anymore in order to satisfy
    streaming DMA mapping constraints, thanks to commit da28947e7e36
    "firewire: ohci: avoid separate DMA mapping for small AT payloads".
    
    (Besides, the slab-allocated buffers that firewire-core, firewire-sbp2,
    and firedtv used to provide for 8-byte write and lock requests were
    still not fully portable since they crossed cacheline boundaries or
    shared a cacheline with unrelated CPU-accessed data.  snd-firewire-lib
    got this aspect right by using an extra kmalloc/ kfree just for the
    8-byte transaction buffer.)
    
    This change replaces kmalloc'ed lock transaction scratch buffers in
    firewire-core, firedtv, and snd-firewire-lib by local stack allocations.
    Perhaps the most notable result of the change is simpler locking because
    there is no need to serialize usages of preallocated per-device buffers
    anymore.  Also, allocations and deallocations are simpler.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/firewire/iso-resources.c b/sound/firewire/iso-resources.c
index 775dbd5f3445..bb9c0c1fb529 100644
--- a/sound/firewire/iso-resources.c
+++ b/sound/firewire/iso-resources.c
@@ -11,7 +11,6 @@
 #include <linux/jiffies.h>
 #include <linux/mutex.h>
 #include <linux/sched.h>
-#include <linux/slab.h>
 #include <linux/spinlock.h>
 #include "iso-resources.h"
 
@@ -25,10 +24,6 @@
  */
 int fw_iso_resources_init(struct fw_iso_resources *r, struct fw_unit *unit)
 {
-	r->buffer = kmalloc(2 * 4, GFP_KERNEL);
-	if (!r->buffer)
-		return -ENOMEM;
-
 	r->channels_mask = ~0uLL;
 	r->unit = fw_unit_get(unit);
 	mutex_init(&r->mutex);
@@ -44,7 +39,6 @@ int fw_iso_resources_init(struct fw_iso_resources *r, struct fw_unit *unit)
 void fw_iso_resources_destroy(struct fw_iso_resources *r)
 {
 	WARN_ON(r->allocated);
-	kfree(r->buffer);
 	mutex_destroy(&r->mutex);
 	fw_unit_put(r->unit);
 }
@@ -131,7 +125,7 @@ int fw_iso_resources_allocate(struct fw_iso_resources *r,
 
 	bandwidth = r->bandwidth + r->bandwidth_overhead;
 	fw_iso_resource_manage(card, r->generation, r->channels_mask,
-			       &channel, &bandwidth, true, r->buffer);
+			       &channel, &bandwidth, true);
 	if (channel == -EAGAIN) {
 		mutex_unlock(&r->mutex);
 		goto retry_after_bus_reset;
@@ -184,7 +178,7 @@ int fw_iso_resources_update(struct fw_iso_resources *r)
 	bandwidth = r->bandwidth + r->bandwidth_overhead;
 
 	fw_iso_resource_manage(card, r->generation, 1uLL << r->channel,
-			       &channel, &bandwidth, true, r->buffer);
+			       &channel, &bandwidth, true);
 	/*
 	 * When another bus reset happens, pretend that the allocation
 	 * succeeded; we will try again for the new generation later.
@@ -220,7 +214,7 @@ void fw_iso_resources_free(struct fw_iso_resources *r)
 	if (r->allocated) {
 		bandwidth = r->bandwidth + r->bandwidth_overhead;
 		fw_iso_resource_manage(card, r->generation, 1uLL << r->channel,
-				       &channel, &bandwidth, false, r->buffer);
+				       &channel, &bandwidth, false);
 		if (channel < 0)
 			dev_err(&r->unit->device,
 				"isochronous resource deallocation failed\n");

commit 5b2599a07eaee53d713fb68f5343eba88fa249c0
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Mar 15 07:55:50 2011 +0100

    ALSA: firewire-lib: allocate DMA buffer separately
    
    For correct cache coherency on some architectures, DMA buffers must be
    allocated in a different cache line than data that is concurrently used
    by the CPU.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/iso-resources.c b/sound/firewire/iso-resources.c
index 6f2b5f8651fd..775dbd5f3445 100644
--- a/sound/firewire/iso-resources.c
+++ b/sound/firewire/iso-resources.c
@@ -11,6 +11,7 @@
 #include <linux/jiffies.h>
 #include <linux/mutex.h>
 #include <linux/sched.h>
+#include <linux/slab.h>
 #include <linux/spinlock.h>
 #include "iso-resources.h"
 
@@ -22,12 +23,18 @@
  * If the device does not support all channel numbers, change @r->channels_mask
  * after calling this function.
  */
-void fw_iso_resources_init(struct fw_iso_resources *r, struct fw_unit *unit)
+int fw_iso_resources_init(struct fw_iso_resources *r, struct fw_unit *unit)
 {
+	r->buffer = kmalloc(2 * 4, GFP_KERNEL);
+	if (!r->buffer)
+		return -ENOMEM;
+
 	r->channels_mask = ~0uLL;
 	r->unit = fw_unit_get(unit);
 	mutex_init(&r->mutex);
 	r->allocated = false;
+
+	return 0;
 }
 
 /**
@@ -37,6 +44,7 @@ void fw_iso_resources_init(struct fw_iso_resources *r, struct fw_unit *unit)
 void fw_iso_resources_destroy(struct fw_iso_resources *r)
 {
 	WARN_ON(r->allocated);
+	kfree(r->buffer);
 	mutex_destroy(&r->mutex);
 	fw_unit_put(r->unit);
 }

commit 31ef9134eb52636d383a7d0626cbbd345cb94f2f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Mar 15 07:53:21 2011 +0100

    ALSA: add LaCie FireWire Speakers/Griffin FireWave Surround driver
    
    Add a driver for two playback-only FireWire devices based on the OXFW970
    chip.
    
    v2: better AMDTP API abstraction; fix fw_unit leak; small fixes
    v3: cache the iPCR value
    v4: FireWave constraints; fix fw_device reference counting;
        fix PCR caching; small changes and fixes
    v5: volume/mute support; fix crashing due to pcm stop races
    v6: fix build; one-channel volume for LaCie
    v7: use signed values to make volume (range checks) work; fix function
        block IDs for volume/mute; always use channel 0 for LaCie volume
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Tested-by: Jay Fenlason <fenlason@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/iso-resources.c b/sound/firewire/iso-resources.c
new file mode 100644
index 000000000000..6f2b5f8651fd
--- /dev/null
+++ b/sound/firewire/iso-resources.c
@@ -0,0 +1,224 @@
+/*
+ * isochronous resources helper functions
+ *
+ * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include <linux/device.h>
+#include <linux/firewire.h>
+#include <linux/firewire-constants.h>
+#include <linux/jiffies.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include "iso-resources.h"
+
+/**
+ * fw_iso_resources_init - initializes a &struct fw_iso_resources
+ * @r: the resource manager to initialize
+ * @unit: the device unit for which the resources will be needed
+ *
+ * If the device does not support all channel numbers, change @r->channels_mask
+ * after calling this function.
+ */
+void fw_iso_resources_init(struct fw_iso_resources *r, struct fw_unit *unit)
+{
+	r->channels_mask = ~0uLL;
+	r->unit = fw_unit_get(unit);
+	mutex_init(&r->mutex);
+	r->allocated = false;
+}
+
+/**
+ * fw_iso_resources_destroy - destroy a resource manager
+ * @r: the resource manager that is no longer needed
+ */
+void fw_iso_resources_destroy(struct fw_iso_resources *r)
+{
+	WARN_ON(r->allocated);
+	mutex_destroy(&r->mutex);
+	fw_unit_put(r->unit);
+}
+
+static unsigned int packet_bandwidth(unsigned int max_payload_bytes, int speed)
+{
+	unsigned int bytes, s400_bytes;
+
+	/* iso packets have three header quadlets and quadlet-aligned payload */
+	bytes = 3 * 4 + ALIGN(max_payload_bytes, 4);
+
+	/* convert to bandwidth units (quadlets at S1600 = bytes at S400) */
+	if (speed <= SCODE_400)
+		s400_bytes = bytes * (1 << (SCODE_400 - speed));
+	else
+		s400_bytes = DIV_ROUND_UP(bytes, 1 << (speed - SCODE_400));
+
+	return s400_bytes;
+}
+
+static int current_bandwidth_overhead(struct fw_card *card)
+{
+	/*
+	 * Under the usual pessimistic assumption (cable length 4.5 m), the
+	 * isochronous overhead for N cables is 1.797 µs + N * 0.494 µs, or
+	 * 88.3 + N * 24.3 in bandwidth units.
+	 *
+	 * The calculation below tries to deduce N from the current gap count.
+	 * If the gap count has been optimized by measuring the actual packet
+	 * transmission time, this derived overhead should be near the actual
+	 * overhead as well.
+	 */
+	return card->gap_count < 63 ? card->gap_count * 97 / 10 + 89 : 512;
+}
+
+static int wait_isoch_resource_delay_after_bus_reset(struct fw_card *card)
+{
+	for (;;) {
+		s64 delay = (card->reset_jiffies + HZ) - get_jiffies_64();
+		if (delay <= 0)
+			return 0;
+		if (schedule_timeout_interruptible(delay) > 0)
+			return -ERESTARTSYS;
+	}
+}
+
+/**
+ * fw_iso_resources_allocate - allocate isochronous channel and bandwidth
+ * @r: the resource manager
+ * @max_payload_bytes: the amount of data (including CIP headers) per packet
+ * @speed: the speed (e.g., SCODE_400) at which the packets will be sent
+ *
+ * This function allocates one isochronous channel and enough bandwidth for the
+ * specified packet size.
+ *
+ * Returns the channel number that the caller must use for streaming, or
+ * a negative error code.  Due to potentionally long delays, this function is
+ * interruptible and can return -ERESTARTSYS.  On success, the caller is
+ * responsible for calling fw_iso_resources_update() on bus resets, and
+ * fw_iso_resources_free() when the resources are not longer needed.
+ */
+int fw_iso_resources_allocate(struct fw_iso_resources *r,
+			      unsigned int max_payload_bytes, int speed)
+{
+	struct fw_card *card = fw_parent_device(r->unit)->card;
+	int bandwidth, channel, err;
+
+	if (WARN_ON(r->allocated))
+		return -EBADFD;
+
+	r->bandwidth = packet_bandwidth(max_payload_bytes, speed);
+
+retry_after_bus_reset:
+	spin_lock_irq(&card->lock);
+	r->generation = card->generation;
+	r->bandwidth_overhead = current_bandwidth_overhead(card);
+	spin_unlock_irq(&card->lock);
+
+	err = wait_isoch_resource_delay_after_bus_reset(card);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&r->mutex);
+
+	bandwidth = r->bandwidth + r->bandwidth_overhead;
+	fw_iso_resource_manage(card, r->generation, r->channels_mask,
+			       &channel, &bandwidth, true, r->buffer);
+	if (channel == -EAGAIN) {
+		mutex_unlock(&r->mutex);
+		goto retry_after_bus_reset;
+	}
+	if (channel >= 0) {
+		r->channel = channel;
+		r->allocated = true;
+	} else {
+		if (channel == -EBUSY)
+			dev_err(&r->unit->device,
+				"isochronous resources exhausted\n");
+		else
+			dev_err(&r->unit->device,
+				"isochronous resource allocation failed\n");
+	}
+
+	mutex_unlock(&r->mutex);
+
+	return channel;
+}
+
+/**
+ * fw_iso_resources_update - update resource allocations after a bus reset
+ * @r: the resource manager
+ *
+ * This function must be called from the driver's .update handler to reallocate
+ * any resources that were allocated before the bus reset.  It is safe to call
+ * this function if no resources are currently allocated.
+ *
+ * Returns a negative error code on failure.  If this happens, the caller must
+ * stop streaming.
+ */
+int fw_iso_resources_update(struct fw_iso_resources *r)
+{
+	struct fw_card *card = fw_parent_device(r->unit)->card;
+	int bandwidth, channel;
+
+	mutex_lock(&r->mutex);
+
+	if (!r->allocated) {
+		mutex_unlock(&r->mutex);
+		return 0;
+	}
+
+	spin_lock_irq(&card->lock);
+	r->generation = card->generation;
+	r->bandwidth_overhead = current_bandwidth_overhead(card);
+	spin_unlock_irq(&card->lock);
+
+	bandwidth = r->bandwidth + r->bandwidth_overhead;
+
+	fw_iso_resource_manage(card, r->generation, 1uLL << r->channel,
+			       &channel, &bandwidth, true, r->buffer);
+	/*
+	 * When another bus reset happens, pretend that the allocation
+	 * succeeded; we will try again for the new generation later.
+	 */
+	if (channel < 0 && channel != -EAGAIN) {
+		r->allocated = false;
+		if (channel == -EBUSY)
+			dev_err(&r->unit->device,
+				"isochronous resources exhausted\n");
+		else
+			dev_err(&r->unit->device,
+				"isochronous resource allocation failed\n");
+	}
+
+	mutex_unlock(&r->mutex);
+
+	return channel;
+}
+
+/**
+ * fw_iso_resources_free - frees allocated resources
+ * @r: the resource manager
+ *
+ * This function deallocates the channel and bandwidth, if allocated.
+ */
+void fw_iso_resources_free(struct fw_iso_resources *r)
+{
+	struct fw_card *card = fw_parent_device(r->unit)->card;
+	int bandwidth, channel;
+
+	mutex_lock(&r->mutex);
+
+	if (r->allocated) {
+		bandwidth = r->bandwidth + r->bandwidth_overhead;
+		fw_iso_resource_manage(card, r->generation, 1uLL << r->channel,
+				       &channel, &bandwidth, false, r->buffer);
+		if (channel < 0)
+			dev_err(&r->unit->device,
+				"isochronous resource deallocation failed\n");
+
+		r->allocated = false;
+	}
+
+	mutex_unlock(&r->mutex);
+}
