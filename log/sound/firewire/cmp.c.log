commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 7bc93821a70adc621df443c8b7a4745023c36e7c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Jun 15 18:11:01 2019 +0900

    ALSA: firewire-lib: split allocation of isochronous resources from establishment of connection
    
    In current implementation, establishment connection corresponds to
    allocation of isochronous resources. Although this is an ideal
    implementation of CMP described in IEC 61883-1, it's not enough
    efficient to recover PCM substream multiplexed in packet streaming.
    The packet streaming can always restart on the same allocated
    isochronous resources even if the previous packet streaming
    corrupted.
    
    This commit splits allocation of isochronous resources from
    establishment of connection so that CMP runs with allocated
    isochronous resources.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index ae3bc1940efa..5dedc4f31842 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -185,6 +185,37 @@ void cmp_connection_destroy(struct cmp_connection *c)
 }
 EXPORT_SYMBOL(cmp_connection_destroy);
 
+int cmp_connection_reserve(struct cmp_connection *c,
+			   unsigned int max_payload_bytes)
+{
+	int err;
+
+	mutex_lock(&c->mutex);
+
+	if (WARN_ON(c->resources.allocated)) {
+		err = -EBUSY;
+		goto end;
+	}
+
+	c->speed = min(c->max_speed,
+		       fw_parent_device(c->resources.unit)->max_speed);
+
+	err = fw_iso_resources_allocate(&c->resources, max_payload_bytes,
+					c->speed);
+end:
+	mutex_unlock(&c->mutex);
+
+	return err;
+}
+EXPORT_SYMBOL(cmp_connection_reserve);
+
+void cmp_connection_release(struct cmp_connection *c)
+{
+	mutex_lock(&c->mutex);
+	fw_iso_resources_free(&c->resources);
+	mutex_unlock(&c->mutex);
+}
+EXPORT_SYMBOL(cmp_connection_release);
 
 static __be32 ipcr_set_modify(struct cmp_connection *c, __be32 ipcr)
 {
@@ -270,25 +301,18 @@ static int pcr_set_check(struct cmp_connection *c, __be32 pcr)
  * When this function succeeds, the caller is responsible for starting
  * transmitting packets.
  */
-int cmp_connection_establish(struct cmp_connection *c,
-			     unsigned int max_payload_bytes)
+int cmp_connection_establish(struct cmp_connection *c)
 {
 	int err;
 
-	if (WARN_ON(c->connected))
-		return -EISCONN;
-
-	c->speed = min(c->max_speed,
-		       fw_parent_device(c->resources.unit)->max_speed);
-
 	mutex_lock(&c->mutex);
 
-retry_after_bus_reset:
-	err = fw_iso_resources_allocate(&c->resources,
-					max_payload_bytes, c->speed);
-	if (err < 0)
-		goto err_mutex;
+	if (WARN_ON(c->connected)) {
+		mutex_unlock(&c->mutex);
+		return -EISCONN;
+	}
 
+retry_after_bus_reset:
 	if (c->direction == CMP_OUTPUT)
 		err = pcr_modify(c, opcr_set_modify, pcr_set_check,
 				 ABORT_ON_BUS_RESET);
@@ -297,21 +321,13 @@ int cmp_connection_establish(struct cmp_connection *c,
 				 ABORT_ON_BUS_RESET);
 
 	if (err == -EAGAIN) {
-		fw_iso_resources_free(&c->resources);
-		goto retry_after_bus_reset;
+		err = fw_iso_resources_update(&c->resources);
+		if (err >= 0)
+			goto retry_after_bus_reset;
 	}
-	if (err < 0)
-		goto err_resources;
-
-	c->connected = true;
-
-	mutex_unlock(&c->mutex);
-
-	return 0;
+	if (err >= 0)
+		c->connected = true;
 
-err_resources:
-	fw_iso_resources_free(&c->resources);
-err_mutex:
 	mutex_unlock(&c->mutex);
 
 	return err;
@@ -351,14 +367,12 @@ int cmp_connection_update(struct cmp_connection *c)
 				 SUCCEED_ON_BUS_RESET);
 
 	if (err < 0)
-		goto err_resources;
+		goto err_unconnect;
 
 	mutex_unlock(&c->mutex);
 
 	return 0;
 
-err_resources:
-	fw_iso_resources_free(&c->resources);
 err_unconnect:
 	c->connected = false;
 	mutex_unlock(&c->mutex);
@@ -395,8 +409,6 @@ void cmp_connection_break(struct cmp_connection *c)
 	if (err < 0)
 		cmp_error(c, "plug is still connected\n");
 
-	fw_iso_resources_free(&c->resources);
-
 	c->connected = false;
 
 	mutex_unlock(&c->mutex);

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index ae3bc1940efa..13f8abc19cfb 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -1,8 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Connection Management Procedures (IEC 61883-1) helper functions
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include <linux/device.h>

commit 5f217f905bc5e9d609d0aac830736bcfc087c7f5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Nov 18 23:59:40 2014 +0900

    ALSA: firewire-lib: fix kerneldoc errors
    
    Complete missing parameters, correct wrong reference, and add an explaination
    about the differences between the latest specification and our implementation.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index ba8df5a1be39..ae3bc1940efa 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -114,6 +114,7 @@ static int pcr_modify(struct cmp_connection *c,
  * cmp_connection_init - initializes a connection manager
  * @c: the connection manager to initialize
  * @unit: a unit of the target device
+ * @direction: input or output
  * @pcr_index: the index of the iPCR/oPCR on the target device
  */
 int cmp_connection_init(struct cmp_connection *c,
@@ -154,6 +155,7 @@ EXPORT_SYMBOL(cmp_connection_init);
 /**
  * cmp_connection_check_used - check connection is already esablished or not
  * @c: the connection manager to be checked
+ * @used: the pointer to store the result of checking the connection
  */
 int cmp_connection_check_used(struct cmp_connection *c, bool *used)
 {

commit 51212eea4f0e2ba9086d0949a524f81834d20ac4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 28 00:14:37 2014 +0900

    ALSA: firewire-lib: Fix sparse warning of incorrect type in assignment
    
    __be32 value should not be assigned directly to bool value.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index d31a403ac539..ba8df5a1be39 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -164,7 +164,9 @@ int cmp_connection_check_used(struct cmp_connection *c, bool *used)
 			c->resources.unit, TCODE_READ_QUADLET_REQUEST,
 			pcr_address(c), &pcr, 4, 0);
 	if (err >= 0)
-		*used = (pcr & cpu_to_be32(PCR_BCAST_CONN | PCR_P2P_CONN_MASK));
+		*used = !!(pcr & cpu_to_be32(PCR_BCAST_CONN |
+					     PCR_P2P_CONN_MASK));
+
 	return err;
 }
 EXPORT_SYMBOL(cmp_connection_check_used);

commit b04479fb8540c906f0ad17f21e4c2715f6e8e7a3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:44:57 2014 +0900

    ALSA: firewire-lib: Add a new function to check others' connection
    
    Plug Control Registers have two fields related to the number of established
    connections, one is 'Broadcast connection counter' and another is
    'Point-to-point connection counter'. The driver can know there are established
    connections or not to check these fields.
    
    This commit is for considering about JACK/FFADO streaming. Currently, when
    JACK/FFADO starts its streaming to the device, cmp_connection_establish() is
    failed expectedly. This seems to be enough but there are some devices which
    needs to change sampling frequency before trying to establish connections.
    For such devices, this functionality is needed.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index 9da40d9e79da..d31a403ac539 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -151,6 +151,24 @@ int cmp_connection_init(struct cmp_connection *c,
 }
 EXPORT_SYMBOL(cmp_connection_init);
 
+/**
+ * cmp_connection_check_used - check connection is already esablished or not
+ * @c: the connection manager to be checked
+ */
+int cmp_connection_check_used(struct cmp_connection *c, bool *used)
+{
+	__be32 pcr;
+	int err;
+
+	err = snd_fw_transaction(
+			c->resources.unit, TCODE_READ_QUADLET_REQUEST,
+			pcr_address(c), &pcr, 4, 0);
+	if (err >= 0)
+		*used = (pcr & cpu_to_be32(PCR_BCAST_CONN | PCR_P2P_CONN_MASK));
+	return err;
+}
+EXPORT_SYMBOL(cmp_connection_check_used);
+
 /**
  * cmp_connection_destroy - free connection manager resources
  * @c: the connection manager

commit 44aff6980af107cccda4d6677995c88b9dad3482
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:44:56 2014 +0900

    ALSA: firewire-lib: Add handling output connection by CMP
    
    This patch adds some macros, codes with condition of direction and new functions
    to handle output connection. Once cmp_connection_init() is executed with its
    direction, CMP input and output connection can be handled by the same way.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index c7f7a3164390..9da40d9e79da 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -29,6 +29,14 @@
 #define PCR_CHANNEL_MASK	0x003f0000
 #define PCR_CHANNEL_SHIFT	16
 
+/* oPCR specific fields */
+#define OPCR_XSPEED_MASK	0x00C00000
+#define OPCR_XSPEED_SHIFT	22
+#define OPCR_SPEED_MASK		0x0000C000
+#define OPCR_SPEED_SHIFT	14
+#define OPCR_OVERHEAD_ID_MASK	0x00003C00
+#define OPCR_OVERHEAD_ID_SHIFT	10
+
 enum bus_reset_handling {
 	ABORT_ON_BUS_RESET,
 	SUCCEED_ON_BUS_RESET,
@@ -41,10 +49,27 @@ void cmp_error(struct cmp_connection *c, const char *fmt, ...)
 
 	va_start(va, fmt);
 	dev_err(&c->resources.unit->device, "%cPCR%u: %pV",
-		'i', c->pcr_index, &(struct va_format){ fmt, &va });
+		(c->direction == CMP_INPUT) ? 'i' : 'o',
+		c->pcr_index, &(struct va_format){ fmt, &va });
 	va_end(va);
 }
 
+static u64 mpr_address(struct cmp_connection *c)
+{
+	if (c->direction == CMP_INPUT)
+		return CSR_REGISTER_BASE + CSR_IMPR;
+	else
+		return CSR_REGISTER_BASE + CSR_OMPR;
+}
+
+static u64 pcr_address(struct cmp_connection *c)
+{
+	if (c->direction == CMP_INPUT)
+		return CSR_REGISTER_BASE + CSR_IPCR(c->pcr_index);
+	else
+		return CSR_REGISTER_BASE + CSR_OPCR(c->pcr_index);
+}
+
 static int pcr_modify(struct cmp_connection *c,
 		      __be32 (*modify)(struct cmp_connection *c, __be32 old),
 		      int (*check)(struct cmp_connection *c, __be32 pcr),
@@ -60,8 +85,7 @@ static int pcr_modify(struct cmp_connection *c,
 
 		err = snd_fw_transaction(
 				c->resources.unit, TCODE_LOCK_COMPARE_SWAP,
-				CSR_REGISTER_BASE + CSR_IPCR(c->pcr_index),
-				buffer, 8,
+				pcr_address(c), buffer, 8,
 				FW_FIXED_GENERATION | c->resources.generation);
 
 		if (err < 0) {
@@ -101,9 +125,9 @@ int cmp_connection_init(struct cmp_connection *c,
 	u32 mpr;
 	int err;
 
+	c->direction = direction;
 	err = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,
-				 CSR_REGISTER_BASE + CSR_IMPR,
-				 &mpr_be, 4, 0);
+				 mpr_address(c), &mpr_be, 4, 0);
 	if (err < 0)
 		return err;
 	mpr = be32_to_cpu(mpr_be);
@@ -151,6 +175,53 @@ static __be32 ipcr_set_modify(struct cmp_connection *c, __be32 ipcr)
 	return ipcr;
 }
 
+static int get_overhead_id(struct cmp_connection *c)
+{
+	int id;
+
+	/*
+	 * apply "oPCR overhead ID encoding"
+	 * the encoding table can convert up to 512.
+	 * here the value over 512 is converted as the same way as 512.
+	 */
+	for (id = 1; id < 16; id++) {
+		if (c->resources.bandwidth_overhead < (id << 5))
+			break;
+	}
+	if (id == 16)
+		id = 0;
+
+	return id;
+}
+
+static __be32 opcr_set_modify(struct cmp_connection *c, __be32 opcr)
+{
+	unsigned int spd, xspd;
+
+	/* generate speed and extended speed field value */
+	if (c->speed > SCODE_400) {
+		spd  = SCODE_800;
+		xspd = c->speed - SCODE_800;
+	} else {
+		spd = c->speed;
+		xspd = 0;
+	}
+
+	opcr &= ~cpu_to_be32(PCR_BCAST_CONN |
+			     PCR_P2P_CONN_MASK |
+			     OPCR_XSPEED_MASK |
+			     PCR_CHANNEL_MASK |
+			     OPCR_SPEED_MASK |
+			     OPCR_OVERHEAD_ID_MASK);
+	opcr |= cpu_to_be32(1 << PCR_P2P_CONN_SHIFT);
+	opcr |= cpu_to_be32(xspd << OPCR_XSPEED_SHIFT);
+	opcr |= cpu_to_be32(c->resources.channel << PCR_CHANNEL_SHIFT);
+	opcr |= cpu_to_be32(spd << OPCR_SPEED_SHIFT);
+	opcr |= cpu_to_be32(get_overhead_id(c) << OPCR_OVERHEAD_ID_SHIFT);
+
+	return opcr;
+}
+
 static int pcr_set_check(struct cmp_connection *c, __be32 pcr)
 {
 	if (pcr & cpu_to_be32(PCR_BCAST_CONN |
@@ -196,8 +267,13 @@ int cmp_connection_establish(struct cmp_connection *c,
 	if (err < 0)
 		goto err_mutex;
 
-	err = pcr_modify(c, ipcr_set_modify, pcr_set_check,
-			 ABORT_ON_BUS_RESET);
+	if (c->direction == CMP_OUTPUT)
+		err = pcr_modify(c, opcr_set_modify, pcr_set_check,
+				 ABORT_ON_BUS_RESET);
+	else
+		err = pcr_modify(c, ipcr_set_modify, pcr_set_check,
+				 ABORT_ON_BUS_RESET);
+
 	if (err == -EAGAIN) {
 		fw_iso_resources_free(&c->resources);
 		goto retry_after_bus_reset;
@@ -245,8 +321,13 @@ int cmp_connection_update(struct cmp_connection *c)
 	if (err < 0)
 		goto err_unconnect;
 
-	err = pcr_modify(c, ipcr_set_modify, pcr_set_check,
-			 SUCCEED_ON_BUS_RESET);
+	if (c->direction == CMP_OUTPUT)
+		err = pcr_modify(c, opcr_set_modify, pcr_set_check,
+				 SUCCEED_ON_BUS_RESET);
+	else
+		err = pcr_modify(c, ipcr_set_modify, pcr_set_check,
+				 SUCCEED_ON_BUS_RESET);
+
 	if (err < 0)
 		goto err_resources;
 

commit c68a1c6584d066d0f2b7aa2117d2eddce2d01def
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:44:55 2014 +0900

    ALSA: firewire-lib: Add 'direction' member to 'cmp_connection' structure
    
    This patch adds 'direction' member to 'cmp_connection' structure to indicate
    the direction of connection. This patch also adds 'direction' argument to
    cmp_connection_init() function to determine the direction.
    
    The cmp_connection_init() function is exported and used in snd-firewire-speakers
    so this patch also affect it.
    
    This patch just add them. Actual implementation will be done by followed
    patches.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index deb494d6e785..c7f7a3164390 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -94,6 +94,7 @@ static int pcr_modify(struct cmp_connection *c,
  */
 int cmp_connection_init(struct cmp_connection *c,
 			struct fw_unit *unit,
+			enum cmp_direction direction,
 			unsigned int pcr_index)
 {
 	__be32 mpr_be;

commit a7fa0d047f879bf3c744e9005769183abdf2ec4b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:44:54 2014 +0900

    ALSA: firewire-lib: Rename macros, variables and functions for CMP
    
    Referring to IEC 61883-1, oMPR and iMPR, oPCR and iPCR have some fields with
    the same role in the same position. This patch renames some macros, variables
    and function arguments with "i" in its prefix to reuse them between oMPR and
    iMPR, oPCR and iPCR.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index efdbf585e404..deb494d6e785 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -14,18 +14,20 @@
 #include "iso-resources.h"
 #include "cmp.h"
 
-#define IMPR_SPEED_MASK		0xc0000000
-#define IMPR_SPEED_SHIFT	30
-#define IMPR_XSPEED_MASK	0x00000060
-#define IMPR_XSPEED_SHIFT	5
-#define IMPR_PLUGS_MASK		0x0000001f
-
-#define IPCR_ONLINE		0x80000000
-#define IPCR_BCAST_CONN		0x40000000
-#define IPCR_P2P_CONN_MASK	0x3f000000
-#define IPCR_P2P_CONN_SHIFT	24
-#define IPCR_CHANNEL_MASK	0x003f0000
-#define IPCR_CHANNEL_SHIFT	16
+/* MPR common fields */
+#define MPR_SPEED_MASK		0xc0000000
+#define MPR_SPEED_SHIFT		30
+#define MPR_XSPEED_MASK		0x00000060
+#define MPR_XSPEED_SHIFT	5
+#define MPR_PLUGS_MASK		0x0000001f
+
+/* PCR common fields */
+#define PCR_ONLINE		0x80000000
+#define PCR_BCAST_CONN		0x40000000
+#define PCR_P2P_CONN_MASK	0x3f000000
+#define PCR_P2P_CONN_SHIFT	24
+#define PCR_CHANNEL_MASK	0x003f0000
+#define PCR_CHANNEL_SHIFT	16
 
 enum bus_reset_handling {
 	ABORT_ON_BUS_RESET,
@@ -88,24 +90,24 @@ static int pcr_modify(struct cmp_connection *c,
  * cmp_connection_init - initializes a connection manager
  * @c: the connection manager to initialize
  * @unit: a unit of the target device
- * @ipcr_index: the index of the iPCR on the target device
+ * @pcr_index: the index of the iPCR/oPCR on the target device
  */
 int cmp_connection_init(struct cmp_connection *c,
 			struct fw_unit *unit,
-			unsigned int ipcr_index)
+			unsigned int pcr_index)
 {
-	__be32 impr_be;
-	u32 impr;
+	__be32 mpr_be;
+	u32 mpr;
 	int err;
 
 	err = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,
 				 CSR_REGISTER_BASE + CSR_IMPR,
-				 &impr_be, 4, 0);
+				 &mpr_be, 4, 0);
 	if (err < 0)
 		return err;
-	impr = be32_to_cpu(impr_be);
+	mpr = be32_to_cpu(mpr_be);
 
-	if (ipcr_index >= (impr & IMPR_PLUGS_MASK))
+	if (pcr_index >= (mpr & MPR_PLUGS_MASK))
 		return -EINVAL;
 
 	err = fw_iso_resources_init(&c->resources, unit);
@@ -115,10 +117,10 @@ int cmp_connection_init(struct cmp_connection *c,
 	c->connected = false;
 	mutex_init(&c->mutex);
 	c->last_pcr_value = cpu_to_be32(0x80000000);
-	c->pcr_index = ipcr_index;
-	c->max_speed = (impr & IMPR_SPEED_MASK) >> IMPR_SPEED_SHIFT;
+	c->pcr_index = pcr_index;
+	c->max_speed = (mpr & MPR_SPEED_MASK) >> MPR_SPEED_SHIFT;
 	if (c->max_speed == SCODE_BETA)
-		c->max_speed += (impr & IMPR_XSPEED_MASK) >> IMPR_XSPEED_SHIFT;
+		c->max_speed += (mpr & MPR_XSPEED_MASK) >> MPR_XSPEED_SHIFT;
 
 	return 0;
 }
@@ -139,23 +141,23 @@ EXPORT_SYMBOL(cmp_connection_destroy);
 
 static __be32 ipcr_set_modify(struct cmp_connection *c, __be32 ipcr)
 {
-	ipcr &= ~cpu_to_be32(IPCR_BCAST_CONN |
-			     IPCR_P2P_CONN_MASK |
-			     IPCR_CHANNEL_MASK);
-	ipcr |= cpu_to_be32(1 << IPCR_P2P_CONN_SHIFT);
-	ipcr |= cpu_to_be32(c->resources.channel << IPCR_CHANNEL_SHIFT);
+	ipcr &= ~cpu_to_be32(PCR_BCAST_CONN |
+			     PCR_P2P_CONN_MASK |
+			     PCR_CHANNEL_MASK);
+	ipcr |= cpu_to_be32(1 << PCR_P2P_CONN_SHIFT);
+	ipcr |= cpu_to_be32(c->resources.channel << PCR_CHANNEL_SHIFT);
 
 	return ipcr;
 }
 
-static int ipcr_set_check(struct cmp_connection *c, __be32 ipcr)
+static int pcr_set_check(struct cmp_connection *c, __be32 pcr)
 {
-	if (ipcr & cpu_to_be32(IPCR_BCAST_CONN |
-			       IPCR_P2P_CONN_MASK)) {
+	if (pcr & cpu_to_be32(PCR_BCAST_CONN |
+			      PCR_P2P_CONN_MASK)) {
 		cmp_error(c, "plug is already in use\n");
 		return -EBUSY;
 	}
-	if (!(ipcr & cpu_to_be32(IPCR_ONLINE))) {
+	if (!(pcr & cpu_to_be32(PCR_ONLINE))) {
 		cmp_error(c, "plug is not on-line\n");
 		return -ECONNREFUSED;
 	}
@@ -170,9 +172,9 @@ static int ipcr_set_check(struct cmp_connection *c, __be32 ipcr)
  *
  * This function establishes a point-to-point connection from the local
  * computer to the target by allocating isochronous resources (channel and
- * bandwidth) and setting the target's input plug control register.  When this
- * function succeeds, the caller is responsible for starting transmitting
- * packets.
+ * bandwidth) and setting the target's input/output plug control register.
+ * When this function succeeds, the caller is responsible for starting
+ * transmitting packets.
  */
 int cmp_connection_establish(struct cmp_connection *c,
 			     unsigned int max_payload_bytes)
@@ -193,7 +195,7 @@ int cmp_connection_establish(struct cmp_connection *c,
 	if (err < 0)
 		goto err_mutex;
 
-	err = pcr_modify(c, ipcr_set_modify, ipcr_set_check,
+	err = pcr_modify(c, ipcr_set_modify, pcr_set_check,
 			 ABORT_ON_BUS_RESET);
 	if (err == -EAGAIN) {
 		fw_iso_resources_free(&c->resources);
@@ -221,8 +223,8 @@ EXPORT_SYMBOL(cmp_connection_establish);
  * cmp_connection_update - update the connection after a bus reset
  * @c: the connection manager
  *
- * This function must be called from the driver's .update handler to reestablish
- * any connection that might have been active.
+ * This function must be called from the driver's .update handler to
+ * reestablish any connection that might have been active.
  *
  * Returns zero on success, or a negative error code.  On an error, the
  * connection is broken and the caller must stop transmitting iso packets.
@@ -242,7 +244,7 @@ int cmp_connection_update(struct cmp_connection *c)
 	if (err < 0)
 		goto err_unconnect;
 
-	err = pcr_modify(c, ipcr_set_modify, ipcr_set_check,
+	err = pcr_modify(c, ipcr_set_modify, pcr_set_check,
 			 SUCCEED_ON_BUS_RESET);
 	if (err < 0)
 		goto err_resources;
@@ -261,19 +263,18 @@ int cmp_connection_update(struct cmp_connection *c)
 }
 EXPORT_SYMBOL(cmp_connection_update);
 
-
-static __be32 ipcr_break_modify(struct cmp_connection *c, __be32 ipcr)
+static __be32 pcr_break_modify(struct cmp_connection *c, __be32 pcr)
 {
-	return ipcr & ~cpu_to_be32(IPCR_BCAST_CONN | IPCR_P2P_CONN_MASK);
+	return pcr & ~cpu_to_be32(PCR_BCAST_CONN | PCR_P2P_CONN_MASK);
 }
 
 /**
  * cmp_connection_break - break the connection to the target
  * @c: the connection manager
  *
- * This function deactives the connection in the target's input plug control
- * register, and frees the isochronous resources of the connection.  Before
- * calling this function, the caller should cease transmitting packets.
+ * This function deactives the connection in the target's input/output plug
+ * control register, and frees the isochronous resources of the connection.
+ * Before calling this function, the caller should cease transmitting packets.
  */
 void cmp_connection_break(struct cmp_connection *c)
 {
@@ -286,7 +287,7 @@ void cmp_connection_break(struct cmp_connection *c)
 		return;
 	}
 
-	err = pcr_modify(c, ipcr_break_modify, NULL, SUCCEED_ON_BUS_RESET);
+	err = pcr_modify(c, pcr_break_modify, NULL, SUCCEED_ON_BUS_RESET);
 	if (err < 0)
 		cmp_error(c, "plug is still connected\n");
 

commit 1b70485f135a39d5f2d8c392a16817456fa3a5cd
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Sep 4 22:17:38 2011 +0200

    ALSA: firewire: extend snd_fw_transaction()
    
    Add a flag to snd_fw_transaction() to allow it to abort when a bus reset
    happens.  This removes most of the duplicated error handling loops that
    were required around calls to the low-level fw_run_transaction().
    
    Also add a flag to suppress error messages; errors are expected when we
    attempt to clean up after the device was unplugged.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index 645cb0ba4293..efdbf585e404 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -48,9 +48,6 @@ static int pcr_modify(struct cmp_connection *c,
 		      int (*check)(struct cmp_connection *c, __be32 pcr),
 		      enum bus_reset_handling bus_reset_handling)
 {
-	struct fw_device *device = fw_parent_device(c->resources.unit);
-	int generation = c->resources.generation;
-	int rcode, errors = 0;
 	__be32 old_arg, buffer[2];
 	int err;
 
@@ -59,36 +56,31 @@ static int pcr_modify(struct cmp_connection *c,
 		old_arg = buffer[0];
 		buffer[1] = modify(c, buffer[0]);
 
-		rcode = fw_run_transaction(
-				device->card, TCODE_LOCK_COMPARE_SWAP,
-				device->node_id, generation, device->max_speed,
+		err = snd_fw_transaction(
+				c->resources.unit, TCODE_LOCK_COMPARE_SWAP,
 				CSR_REGISTER_BASE + CSR_IPCR(c->pcr_index),
-				buffer, 8);
-
-		if (rcode == RCODE_COMPLETE) {
-			if (buffer[0] == old_arg) /* success? */
-				break;
-
-			if (check) {
-				err = check(c, buffer[0]);
-				if (err < 0)
-					return err;
-			}
-		} else if (rcode == RCODE_GENERATION)
-			goto bus_reset;
-		else if (rcode_is_permanent_error(rcode) || ++errors >= 3)
-			goto io_error;
+				buffer, 8,
+				FW_FIXED_GENERATION | c->resources.generation);
+
+		if (err < 0) {
+			if (err == -EAGAIN &&
+			    bus_reset_handling == SUCCEED_ON_BUS_RESET)
+				err = 0;
+			return err;
+		}
+
+		if (buffer[0] == old_arg) /* success? */
+			break;
+
+		if (check) {
+			err = check(c, buffer[0]);
+			if (err < 0)
+				return err;
+		}
 	}
 	c->last_pcr_value = buffer[1];
 
 	return 0;
-
-io_error:
-	cmp_error(c, "transaction failed: %s\n", fw_rcode_string(rcode));
-	return -EIO;
-
-bus_reset:
-	return bus_reset_handling == ABORT_ON_BUS_RESET ? -EAGAIN : 0;
 }
 
 
@@ -108,7 +100,7 @@ int cmp_connection_init(struct cmp_connection *c,
 
 	err = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,
 				 CSR_REGISTER_BASE + CSR_IMPR,
-				 &impr_be, 4);
+				 &impr_be, 4, 0);
 	if (err < 0)
 		return err;
 	impr = be32_to_cpu(impr_be);

commit 7bdbff6762a573b911e4ee5715779d8ee6a62631
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Apr 11 17:38:10 2012 +0200

    firewire: move rcode_string() to core
    
    There is nothing audio-specific about the rcode_string() helper, so move
    it from snd-firewire-lib into firewire-core to allow other code to use it.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (fixed sound/firewire/cmp.c)

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index 76294f2ae47f..645cb0ba4293 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -84,7 +84,7 @@ static int pcr_modify(struct cmp_connection *c,
 	return 0;
 
 io_error:
-	cmp_error(c, "transaction failed: %s\n", rcode_string(rcode));
+	cmp_error(c, "transaction failed: %s\n", fw_rcode_string(rcode));
 	return -EIO;
 
 bus_reset:

commit b9075fa968a0a4347aef35e235e2995c0e57dddd
Author: Joe Perches <joe@perches.com>
Date:   Mon Oct 31 17:11:33 2011 -0700

    treewide: use __printf not __attribute__((format(printf,...)))
    
    Standardize the style for compiler based printf format verification.
    Standardized the location of __printf too.
    
    Done via script and a little typing.
    
    $ grep -rPl --include=*.[ch] -w "__attribute__" * | \
      grep -vP "^(tools|scripts|include/linux/compiler-gcc.h)" | \
      xargs perl -n -i -e 'local $/; while (<>) { s/\b__attribute__\s*\(\s*\(\s*format\s*\(\s*printf\s*,\s*(.+)\s*,\s*(.+)\s*\)\s*\)\s*\)/__printf($1, $2)/g ; print; }'
    
    [akpm@linux-foundation.org: revert arch bits]
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index 14cacbc655dd..76294f2ae47f 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -32,7 +32,7 @@ enum bus_reset_handling {
 	SUCCEED_ON_BUS_RESET,
 };
 
-static __attribute__((format(printf, 2, 3)))
+static __printf(2, 3)
 void cmp_error(struct cmp_connection *c, const char *fmt, ...)
 {
 	va_list va;

commit f30e6d3e419bfb5540fa82ba7eca01d578556e6b
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Apr 22 15:13:54 2011 +0200

    firewire: octlet AT payloads can be stack-allocated
    
    We do not need slab allocations anymore in order to satisfy
    streaming DMA mapping constraints, thanks to commit da28947e7e36
    "firewire: ohci: avoid separate DMA mapping for small AT payloads".
    
    (Besides, the slab-allocated buffers that firewire-core, firewire-sbp2,
    and firedtv used to provide for 8-byte write and lock requests were
    still not fully portable since they crossed cacheline boundaries or
    shared a cacheline with unrelated CPU-accessed data.  snd-firewire-lib
    got this aspect right by using an extra kmalloc/ kfree just for the
    8-byte transaction buffer.)
    
    This change replaces kmalloc'ed lock transaction scratch buffers in
    firewire-core, firedtv, and snd-firewire-lib by local stack allocations.
    Perhaps the most notable result of the change is simpler locking because
    there is no need to serialize usages of preallocated per-device buffers
    anymore.  Also, allocations and deallocations are simpler.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index 4a37f3a6fab9..14cacbc655dd 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -49,10 +49,9 @@ static int pcr_modify(struct cmp_connection *c,
 		      enum bus_reset_handling bus_reset_handling)
 {
 	struct fw_device *device = fw_parent_device(c->resources.unit);
-	__be32 *buffer = c->resources.buffer;
 	int generation = c->resources.generation;
 	int rcode, errors = 0;
-	__be32 old_arg;
+	__be32 old_arg, buffer[2];
 	int err;
 
 	buffer[0] = c->last_pcr_value;

commit 5b2599a07eaee53d713fb68f5343eba88fa249c0
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Mar 15 07:55:50 2011 +0100

    ALSA: firewire-lib: allocate DMA buffer separately
    
    For correct cache coherency on some architectures, DMA buffers must be
    allocated in a different cache line than data that is concurrently used
    by the CPU.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
index c992dab4bb95..4a37f3a6fab9 100644
--- a/sound/firewire/cmp.c
+++ b/sound/firewire/cmp.c
@@ -117,9 +117,12 @@ int cmp_connection_init(struct cmp_connection *c,
 	if (ipcr_index >= (impr & IMPR_PLUGS_MASK))
 		return -EINVAL;
 
+	err = fw_iso_resources_init(&c->resources, unit);
+	if (err < 0)
+		return err;
+
 	c->connected = false;
 	mutex_init(&c->mutex);
-	fw_iso_resources_init(&c->resources, unit);
 	c->last_pcr_value = cpu_to_be32(0x80000000);
 	c->pcr_index = ipcr_index;
 	c->max_speed = (impr & IMPR_SPEED_MASK) >> IMPR_SPEED_SHIFT;

commit 31ef9134eb52636d383a7d0626cbbd345cb94f2f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Mar 15 07:53:21 2011 +0100

    ALSA: add LaCie FireWire Speakers/Griffin FireWave Surround driver
    
    Add a driver for two playback-only FireWire devices based on the OXFW970
    chip.
    
    v2: better AMDTP API abstraction; fix fw_unit leak; small fixes
    v3: cache the iPCR value
    v4: FireWave constraints; fix fw_device reference counting;
        fix PCR caching; small changes and fixes
    v5: volume/mute support; fix crashing due to pcm stop races
    v6: fix build; one-channel volume for LaCie
    v7: use signed values to make volume (range checks) work; fix function
        block IDs for volume/mute; always use channel 0 for LaCie volume
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Tested-by: Jay Fenlason <fenlason@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/cmp.c b/sound/firewire/cmp.c
new file mode 100644
index 000000000000..c992dab4bb95
--- /dev/null
+++ b/sound/firewire/cmp.c
@@ -0,0 +1,305 @@
+/*
+ * Connection Management Procedures (IEC 61883-1) helper functions
+ *
+ * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include <linux/device.h>
+#include <linux/firewire.h>
+#include <linux/firewire-constants.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include "lib.h"
+#include "iso-resources.h"
+#include "cmp.h"
+
+#define IMPR_SPEED_MASK		0xc0000000
+#define IMPR_SPEED_SHIFT	30
+#define IMPR_XSPEED_MASK	0x00000060
+#define IMPR_XSPEED_SHIFT	5
+#define IMPR_PLUGS_MASK		0x0000001f
+
+#define IPCR_ONLINE		0x80000000
+#define IPCR_BCAST_CONN		0x40000000
+#define IPCR_P2P_CONN_MASK	0x3f000000
+#define IPCR_P2P_CONN_SHIFT	24
+#define IPCR_CHANNEL_MASK	0x003f0000
+#define IPCR_CHANNEL_SHIFT	16
+
+enum bus_reset_handling {
+	ABORT_ON_BUS_RESET,
+	SUCCEED_ON_BUS_RESET,
+};
+
+static __attribute__((format(printf, 2, 3)))
+void cmp_error(struct cmp_connection *c, const char *fmt, ...)
+{
+	va_list va;
+
+	va_start(va, fmt);
+	dev_err(&c->resources.unit->device, "%cPCR%u: %pV",
+		'i', c->pcr_index, &(struct va_format){ fmt, &va });
+	va_end(va);
+}
+
+static int pcr_modify(struct cmp_connection *c,
+		      __be32 (*modify)(struct cmp_connection *c, __be32 old),
+		      int (*check)(struct cmp_connection *c, __be32 pcr),
+		      enum bus_reset_handling bus_reset_handling)
+{
+	struct fw_device *device = fw_parent_device(c->resources.unit);
+	__be32 *buffer = c->resources.buffer;
+	int generation = c->resources.generation;
+	int rcode, errors = 0;
+	__be32 old_arg;
+	int err;
+
+	buffer[0] = c->last_pcr_value;
+	for (;;) {
+		old_arg = buffer[0];
+		buffer[1] = modify(c, buffer[0]);
+
+		rcode = fw_run_transaction(
+				device->card, TCODE_LOCK_COMPARE_SWAP,
+				device->node_id, generation, device->max_speed,
+				CSR_REGISTER_BASE + CSR_IPCR(c->pcr_index),
+				buffer, 8);
+
+		if (rcode == RCODE_COMPLETE) {
+			if (buffer[0] == old_arg) /* success? */
+				break;
+
+			if (check) {
+				err = check(c, buffer[0]);
+				if (err < 0)
+					return err;
+			}
+		} else if (rcode == RCODE_GENERATION)
+			goto bus_reset;
+		else if (rcode_is_permanent_error(rcode) || ++errors >= 3)
+			goto io_error;
+	}
+	c->last_pcr_value = buffer[1];
+
+	return 0;
+
+io_error:
+	cmp_error(c, "transaction failed: %s\n", rcode_string(rcode));
+	return -EIO;
+
+bus_reset:
+	return bus_reset_handling == ABORT_ON_BUS_RESET ? -EAGAIN : 0;
+}
+
+
+/**
+ * cmp_connection_init - initializes a connection manager
+ * @c: the connection manager to initialize
+ * @unit: a unit of the target device
+ * @ipcr_index: the index of the iPCR on the target device
+ */
+int cmp_connection_init(struct cmp_connection *c,
+			struct fw_unit *unit,
+			unsigned int ipcr_index)
+{
+	__be32 impr_be;
+	u32 impr;
+	int err;
+
+	err = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,
+				 CSR_REGISTER_BASE + CSR_IMPR,
+				 &impr_be, 4);
+	if (err < 0)
+		return err;
+	impr = be32_to_cpu(impr_be);
+
+	if (ipcr_index >= (impr & IMPR_PLUGS_MASK))
+		return -EINVAL;
+
+	c->connected = false;
+	mutex_init(&c->mutex);
+	fw_iso_resources_init(&c->resources, unit);
+	c->last_pcr_value = cpu_to_be32(0x80000000);
+	c->pcr_index = ipcr_index;
+	c->max_speed = (impr & IMPR_SPEED_MASK) >> IMPR_SPEED_SHIFT;
+	if (c->max_speed == SCODE_BETA)
+		c->max_speed += (impr & IMPR_XSPEED_MASK) >> IMPR_XSPEED_SHIFT;
+
+	return 0;
+}
+EXPORT_SYMBOL(cmp_connection_init);
+
+/**
+ * cmp_connection_destroy - free connection manager resources
+ * @c: the connection manager
+ */
+void cmp_connection_destroy(struct cmp_connection *c)
+{
+	WARN_ON(c->connected);
+	mutex_destroy(&c->mutex);
+	fw_iso_resources_destroy(&c->resources);
+}
+EXPORT_SYMBOL(cmp_connection_destroy);
+
+
+static __be32 ipcr_set_modify(struct cmp_connection *c, __be32 ipcr)
+{
+	ipcr &= ~cpu_to_be32(IPCR_BCAST_CONN |
+			     IPCR_P2P_CONN_MASK |
+			     IPCR_CHANNEL_MASK);
+	ipcr |= cpu_to_be32(1 << IPCR_P2P_CONN_SHIFT);
+	ipcr |= cpu_to_be32(c->resources.channel << IPCR_CHANNEL_SHIFT);
+
+	return ipcr;
+}
+
+static int ipcr_set_check(struct cmp_connection *c, __be32 ipcr)
+{
+	if (ipcr & cpu_to_be32(IPCR_BCAST_CONN |
+			       IPCR_P2P_CONN_MASK)) {
+		cmp_error(c, "plug is already in use\n");
+		return -EBUSY;
+	}
+	if (!(ipcr & cpu_to_be32(IPCR_ONLINE))) {
+		cmp_error(c, "plug is not on-line\n");
+		return -ECONNREFUSED;
+	}
+
+	return 0;
+}
+
+/**
+ * cmp_connection_establish - establish a connection to the target
+ * @c: the connection manager
+ * @max_payload_bytes: the amount of data (including CIP headers) per packet
+ *
+ * This function establishes a point-to-point connection from the local
+ * computer to the target by allocating isochronous resources (channel and
+ * bandwidth) and setting the target's input plug control register.  When this
+ * function succeeds, the caller is responsible for starting transmitting
+ * packets.
+ */
+int cmp_connection_establish(struct cmp_connection *c,
+			     unsigned int max_payload_bytes)
+{
+	int err;
+
+	if (WARN_ON(c->connected))
+		return -EISCONN;
+
+	c->speed = min(c->max_speed,
+		       fw_parent_device(c->resources.unit)->max_speed);
+
+	mutex_lock(&c->mutex);
+
+retry_after_bus_reset:
+	err = fw_iso_resources_allocate(&c->resources,
+					max_payload_bytes, c->speed);
+	if (err < 0)
+		goto err_mutex;
+
+	err = pcr_modify(c, ipcr_set_modify, ipcr_set_check,
+			 ABORT_ON_BUS_RESET);
+	if (err == -EAGAIN) {
+		fw_iso_resources_free(&c->resources);
+		goto retry_after_bus_reset;
+	}
+	if (err < 0)
+		goto err_resources;
+
+	c->connected = true;
+
+	mutex_unlock(&c->mutex);
+
+	return 0;
+
+err_resources:
+	fw_iso_resources_free(&c->resources);
+err_mutex:
+	mutex_unlock(&c->mutex);
+
+	return err;
+}
+EXPORT_SYMBOL(cmp_connection_establish);
+
+/**
+ * cmp_connection_update - update the connection after a bus reset
+ * @c: the connection manager
+ *
+ * This function must be called from the driver's .update handler to reestablish
+ * any connection that might have been active.
+ *
+ * Returns zero on success, or a negative error code.  On an error, the
+ * connection is broken and the caller must stop transmitting iso packets.
+ */
+int cmp_connection_update(struct cmp_connection *c)
+{
+	int err;
+
+	mutex_lock(&c->mutex);
+
+	if (!c->connected) {
+		mutex_unlock(&c->mutex);
+		return 0;
+	}
+
+	err = fw_iso_resources_update(&c->resources);
+	if (err < 0)
+		goto err_unconnect;
+
+	err = pcr_modify(c, ipcr_set_modify, ipcr_set_check,
+			 SUCCEED_ON_BUS_RESET);
+	if (err < 0)
+		goto err_resources;
+
+	mutex_unlock(&c->mutex);
+
+	return 0;
+
+err_resources:
+	fw_iso_resources_free(&c->resources);
+err_unconnect:
+	c->connected = false;
+	mutex_unlock(&c->mutex);
+
+	return err;
+}
+EXPORT_SYMBOL(cmp_connection_update);
+
+
+static __be32 ipcr_break_modify(struct cmp_connection *c, __be32 ipcr)
+{
+	return ipcr & ~cpu_to_be32(IPCR_BCAST_CONN | IPCR_P2P_CONN_MASK);
+}
+
+/**
+ * cmp_connection_break - break the connection to the target
+ * @c: the connection manager
+ *
+ * This function deactives the connection in the target's input plug control
+ * register, and frees the isochronous resources of the connection.  Before
+ * calling this function, the caller should cease transmitting packets.
+ */
+void cmp_connection_break(struct cmp_connection *c)
+{
+	int err;
+
+	mutex_lock(&c->mutex);
+
+	if (!c->connected) {
+		mutex_unlock(&c->mutex);
+		return;
+	}
+
+	err = pcr_modify(c, ipcr_break_modify, NULL, SUCCEED_ON_BUS_RESET);
+	if (err < 0)
+		cmp_error(c, "plug is still connected\n");
+
+	fw_iso_resources_free(&c->resources);
+
+	c->connected = false;
+
+	mutex_unlock(&c->mutex);
+}
+EXPORT_SYMBOL(cmp_connection_break);
