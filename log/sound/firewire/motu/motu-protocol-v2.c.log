commit 506ad56a59086751eee28b6b6e5dff5572cd669f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:41 2020 +0900

    ALSA: firewire-motu: refactoring protocol v2 for fetching mode switch
    
    This commit splits the method to switch fetching mode for protocol
    version 2 so that model-dependent operations are explicitly defined.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-15-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 2e6c3cc8a9e1..e59e69ab1538 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -170,52 +170,69 @@ int snd_motu_protocol_v2_get_clock_source(struct snd_motu *motu,
 	return get_clock_source(motu, be32_to_cpu(reg), src);
 }
 
-int snd_motu_protocol_v2_switch_fetching_mode(struct snd_motu *motu,
-					      bool enable)
+// Expected for Traveler and 896HD, which implements Altera Cyclone EP1C3.
+static int switch_fetching_mode_cyclone(struct snd_motu *motu, u32 *data,
+					bool enable)
 {
-	enum snd_motu_clock_source src;
-	__be32 reg;
-	u32 data;
-	int err = 0;
+	*data |= V2_CLOCK_MODEL_SPECIFIC;
 
-	// 828mkII implements Altera ACEX 1K EP1K30. Nothing to do.
-	if (motu->spec == &snd_motu_spec_828mk2)
-		return 0;
+	return 0;
+}
 
-	err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,
-					sizeof(reg));
+// For UltraLite and 8pre, which implements Xilinx Spartan XC3S200.
+static int switch_fetching_mode_spartan(struct snd_motu *motu, u32 *data,
+					bool enable)
+{
+	unsigned int rate;
+	enum snd_motu_clock_source src;
+	int err;
+
+	err = get_clock_source(motu, *data, &src);
 	if (err < 0)
 		return err;
-	data = be32_to_cpu(reg);
 
-	err = get_clock_source(motu, data, &src);
+	err = get_clock_rate(*data, &rate);
 	if (err < 0)
 		return err;
 
-	data &= ~(V2_CLOCK_FETCH_ENABLE | V2_CLOCK_MODEL_SPECIFIC);
-	if (enable)
-		data |= V2_CLOCK_FETCH_ENABLE;
+	if (src == SND_MOTU_CLOCK_SOURCE_SPH && rate > 48000)
+		*data |= V2_CLOCK_MODEL_SPECIFIC;
 
-	if (motu->spec == &snd_motu_spec_traveler) {
-		// Expected for Traveler and 896HD, which implements Altera
-		// Cyclone EP1C3.
-		data |= V2_CLOCK_MODEL_SPECIFIC;
+	return 0;
+}
+
+int snd_motu_protocol_v2_switch_fetching_mode(struct snd_motu *motu,
+					      bool enable)
+{
+	if (motu->spec == &snd_motu_spec_828mk2) {
+		// 828mkII implements Altera ACEX 1K EP1K30. Nothing to do.
+		return 0;
 	} else {
-		// For UltraLite and 8pre, which implements Xilinx Spartan
-		// XC3S200.
-		unsigned int rate;
+		__be32 reg;
+		u32 data;
+		int err;
 
-		err = get_clock_rate(data, &rate);
+		err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET,
+						&reg, sizeof(reg));
 		if (err < 0)
 			return err;
+		data = be32_to_cpu(reg);
 
-		if (src == SND_MOTU_CLOCK_SOURCE_SPH && rate > 48000)
-			data |= V2_CLOCK_MODEL_SPECIFIC;
-	}
+		data &= ~(V2_CLOCK_FETCH_ENABLE | V2_CLOCK_MODEL_SPECIFIC);
+		if (enable)
+			data |= V2_CLOCK_FETCH_ENABLE;
 
-	reg = cpu_to_be32(data);
-	return snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET, &reg,
-					  sizeof(reg));
+		if (motu->spec == &snd_motu_spec_traveler)
+			err = switch_fetching_mode_cyclone(motu, &data, enable);
+		else
+			err = switch_fetching_mode_spartan(motu, &data, enable);
+		if (err < 0)
+			return err;
+
+		reg = cpu_to_be32(data);
+		return snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET,
+						  &reg, sizeof(reg));
+	}
 }
 
 static int detect_packet_formats_828mk2(struct snd_motu *motu, u32 data)

commit 2b8f050e4ea97bd9851d023935e0ca5229e6905b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:39 2020 +0900

    ALSA: firewire-motu: refactoring protocol v2 for clock source getter
    
    This commit splits the method to get clock source for protocol
    version 2 so that model-dependent operations are explicitly defined.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-13-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 1bdc905e8e22..2e6c3cc8a9e1 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -78,14 +78,10 @@ int snd_motu_protocol_v2_set_clock_rate(struct snd_motu *motu,
 					  sizeof(reg));
 }
 
-static int get_clock_source(struct snd_motu *motu, u32 data,
-			    enum snd_motu_clock_source *src)
+static int detect_clock_source_optical_model(struct snd_motu *motu, u32 data,
+					     enum snd_motu_clock_source *src)
 {
-	unsigned int index = data & V2_CLOCK_SRC_MASK;
-	if (index > 5)
-		return -EIO;
-
-	switch (index) {
+	switch (data) {
 	case 0:
 		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
 		break;
@@ -118,12 +114,48 @@ static int get_clock_source(struct snd_motu *motu, u32 data,
 		*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_DSUB;
 		break;
 	default:
-		return -EIO;
+		*src = SND_MOTU_CLOCK_SOURCE_UNKNOWN;
+		break;
+	}
+
+	return 0;
+}
+
+static int v2_detect_clock_source(struct snd_motu *motu, u32 data,
+				  enum snd_motu_clock_source *src)
+{
+	switch (data) {
+	case 0:
+		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
+		break;
+	case 2:
+		*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;
+		break;
+	case 3:
+		*src = SND_MOTU_CLOCK_SOURCE_SPH;
+		break;
+	case 4:
+		*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;
+		break;
+	default:
+		*src = SND_MOTU_CLOCK_SOURCE_UNKNOWN;
+		break;
 	}
 
 	return 0;
 }
 
+static int get_clock_source(struct snd_motu *motu, u32 data,
+			    enum snd_motu_clock_source *src)
+{
+	data &= V2_CLOCK_SRC_MASK;
+	if (motu->spec == &snd_motu_spec_828mk2 ||
+	    motu->spec == &snd_motu_spec_traveler)
+		return detect_clock_source_optical_model(motu, data, src);
+	else
+		return v2_detect_clock_source(motu, data, src);
+}
+
 int snd_motu_protocol_v2_get_clock_source(struct snd_motu *motu,
 					  enum snd_motu_clock_source *src)
 {

commit 739bdbaec76ae7e6e2de80c06e1d4ca31e7c96b9
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:38 2020 +0900

    ALSA: firewire-motu: remove obsoleted codes
    
    The way to decide CIP payload size by calculation with any flag is now
    obsoleted. This commit removes the codes.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-12-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 2ed800ccf6a2..1bdc905e8e22 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -186,86 +186,6 @@ int snd_motu_protocol_v2_switch_fetching_mode(struct snd_motu *motu,
 					  sizeof(reg));
 }
 
-static void calculate_fixed_part(struct snd_motu_packet_format *formats,
-				 enum amdtp_stream_direction dir,
-				 enum snd_motu_spec_flags flags,
-				 unsigned char analog_ports)
-{
-	unsigned char pcm_chunks[3] = {0, 0, 0};
-
-	pcm_chunks[0] = analog_ports;
-	pcm_chunks[1] = analog_ports;
-	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
-		pcm_chunks[2] = analog_ports;
-
-	if (dir == AMDTP_IN_STREAM) {
-		if (flags & SND_MOTU_SPEC_TX_MICINST_CHUNK) {
-			pcm_chunks[0] += 2;
-			pcm_chunks[1] += 2;
-		}
-		if (flags & SND_MOTU_SPEC_TX_RETURN_CHUNK) {
-			pcm_chunks[0] += 2;
-			pcm_chunks[1] += 2;
-		}
-	} else {
-		if (flags & SND_MOTU_SPEC_RX_SEPARATED_MAIN) {
-			pcm_chunks[0] += 2;
-			pcm_chunks[1] += 2;
-		}
-
-		// Packets to v2 units include 2 chunks for phone 1/2, except
-		// for 176.4/192.0 kHz.
-		pcm_chunks[0] += 2;
-		pcm_chunks[1] += 2;
-	}
-
-	if (flags & SND_MOTU_SPEC_HAS_AESEBU_IFACE) {
-		pcm_chunks[0] += 2;
-		pcm_chunks[1] += 2;
-	}
-
-	/*
-	 * All of v2 models have a pair of coaxial interfaces for digital in/out
-	 * port. At 44.1/48.0/88.2/96.0 kHz, packets includes PCM from these
-	 * ports.
-	 */
-	pcm_chunks[0] += 2;
-	pcm_chunks[1] += 2;
-
-	formats->fixed_part_pcm_chunks[0] = pcm_chunks[0];
-	formats->fixed_part_pcm_chunks[1] = pcm_chunks[1];
-	formats->fixed_part_pcm_chunks[2] = pcm_chunks[2];
-}
-
-static void calculate_differed_part(struct snd_motu_packet_format *formats,
-				    enum snd_motu_spec_flags flags,
-				    u32 data, u32 mask, u32 shift)
-{
-	unsigned char pcm_chunks[2] = {0, 0};
-
-	/*
-	 * When optical interfaces are configured for S/PDIF (TOSLINK),
-	 * the above PCM frames come from them, instead of coaxial
-	 * interfaces.
-	 */
-	data = (data & mask) >> shift;
-	if (data == V2_OPT_IFACE_MODE_ADAT) {
-		if (flags & SND_MOTU_SPEC_HAS_OPT_IFACE_A) {
-			pcm_chunks[0] += 8;
-			pcm_chunks[1] += 4;
-		}
-		// 8pre has two sets of optical interface and doesn't reduce
-		// chunks for ADAT signals.
-		if (flags & SND_MOTU_SPEC_HAS_OPT_IFACE_B) {
-			pcm_chunks[1] += 4;
-		}
-	}
-
-	/* At mode x4, no data chunks are supported in this part. */
-	formats->differed_part_pcm_chunks[0] = pcm_chunks[0];
-	formats->differed_part_pcm_chunks[1] = pcm_chunks[1];
-}
-
 static int detect_packet_formats_828mk2(struct snd_motu *motu, u32 data)
 {
 	if (((data & V2_OPT_IN_IFACE_MASK) >> V2_OPT_IN_IFACE_SHIFT) ==
@@ -335,16 +255,6 @@ int snd_motu_protocol_v2_cache_packet_formats(struct snd_motu *motu)
 		return err;
 	data = be32_to_cpu(reg);
 
-	calculate_fixed_part(&motu->tx_packet_formats, AMDTP_IN_STREAM,
-			     motu->spec->flags, motu->spec->analog_in_ports);
-	calculate_differed_part(&motu->tx_packet_formats, motu->spec->flags,
-			data, V2_OPT_IN_IFACE_MASK, V2_OPT_IN_IFACE_SHIFT);
-
-	calculate_fixed_part(&motu->rx_packet_formats, AMDTP_OUT_STREAM,
-			     motu->spec->flags, motu->spec->analog_out_ports);
-	calculate_differed_part(&motu->rx_packet_formats, motu->spec->flags,
-			data, V2_OPT_OUT_IFACE_MASK, V2_OPT_OUT_IFACE_SHIFT);
-
 	memcpy(motu->tx_packet_formats.pcm_chunks,
 	       motu->spec->tx_fixed_pcm_chunks,
 	       sizeof(motu->tx_packet_formats.pcm_chunks));
@@ -365,62 +275,35 @@ int snd_motu_protocol_v2_cache_packet_formats(struct snd_motu *motu)
 const struct snd_motu_spec snd_motu_spec_828mk2 = {
 	.name = "828mk2",
 	.protocol_version = SND_MOTU_PROTOCOL_V2,
-	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
-		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
-		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
-		 SND_MOTU_SPEC_RX_SEPARATED_MAIN |
-		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
-		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+	.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
 	.tx_fixed_pcm_chunks = {14, 14, 0},
 	.rx_fixed_pcm_chunks = {14, 14, 0},
-	.analog_in_ports = 8,
-	.analog_out_ports = 8,
 };
 
 const struct snd_motu_spec snd_motu_spec_traveler = {
 	.name = "Traveler",
 	.protocol_version = SND_MOTU_PROTOCOL_V2,
-	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
-		 SND_MOTU_SPEC_SUPPORT_CLOCK_X4 |
-		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
-		 SND_MOTU_SPEC_HAS_AESEBU_IFACE |
-		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
-		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+	.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
 	.tx_fixed_pcm_chunks = {14, 14, 8},
 	.rx_fixed_pcm_chunks = {14, 14, 8},
-	.analog_in_ports = 8,
-	.analog_out_ports = 8,
 };
 
 const struct snd_motu_spec snd_motu_spec_ultralite = {
 	.name = "UltraLite",
 	.protocol_version = SND_MOTU_PROTOCOL_V2,
-	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
-		 SND_MOTU_SPEC_TX_MICINST_CHUNK | // padding.
-		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
-		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
-		 SND_MOTU_SPEC_TX_MIDI_2ND_Q |
-		 SND_MOTU_SPEC_RX_SEPARATED_MAIN,
+	.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
 	.tx_fixed_pcm_chunks = {14, 14, 0},
 	.rx_fixed_pcm_chunks = {14, 14, 0},
-	.analog_in_ports = 8,
-	.analog_out_ports = 8,
 };
 
 const struct snd_motu_spec snd_motu_spec_8pre = {
 	.name = "8pre",
 	.protocol_version = SND_MOTU_PROTOCOL_V2,
-	// In tx, use coax chunks for mix-return 1/2. In rx, use coax chunks for
-	// dummy 1/2.
-	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
-		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
-		 SND_MOTU_SPEC_HAS_OPT_IFACE_B |
-		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+	.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
 	.tx_fixed_pcm_chunks = {10, 6, 0},
 	.rx_fixed_pcm_chunks = {10, 6, 0},
-	.analog_in_ports = 8,
-	.analog_out_ports = 2,
 };

commit 0090c1c5f327da077f371f5f8675a576bca6ebf9
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:35 2020 +0900

    ALSA: firewire-motu: add alternative functions to detect packet format for protocol v3
    
    This commit adds alternative functions to detect packet format so that
    each function corresponds to each model.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-9-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index cd409efe3350..2ed800ccf6a2 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -345,6 +345,12 @@ int snd_motu_protocol_v2_cache_packet_formats(struct snd_motu *motu)
 	calculate_differed_part(&motu->rx_packet_formats, motu->spec->flags,
 			data, V2_OPT_OUT_IFACE_MASK, V2_OPT_OUT_IFACE_SHIFT);
 
+	memcpy(motu->tx_packet_formats.pcm_chunks,
+	       motu->spec->tx_fixed_pcm_chunks,
+	       sizeof(motu->tx_packet_formats.pcm_chunks));
+	memcpy(motu->rx_packet_formats.pcm_chunks,
+	       motu->spec->rx_fixed_pcm_chunks,
+	       sizeof(motu->rx_packet_formats.pcm_chunks));
 
 	if (motu->spec == &snd_motu_spec_828mk2)
 		return detect_packet_formats_828mk2(motu, data);

commit 28c8d3c91af79de34b2ea540b5385b2da4999e80
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:34 2020 +0900

    ALSA: firewire-motu: add alternative functions to detect packet format for protocol v2
    
    This commit adds alternative functions to detect packet format so that
    each function corresponds to each model.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-8-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 6cd7a5f1f46c..cd409efe3350 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -164,7 +164,7 @@ int snd_motu_protocol_v2_switch_fetching_mode(struct snd_motu *motu,
 	if (enable)
 		data |= V2_CLOCK_FETCH_ENABLE;
 
-	if (motu->spec->flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4) {
+	if (motu->spec == &snd_motu_spec_traveler) {
 		// Expected for Traveler and 896HD, which implements Altera
 		// Cyclone EP1C3.
 		data |= V2_CLOCK_MODEL_SPECIFIC;
@@ -193,8 +193,6 @@ static void calculate_fixed_part(struct snd_motu_packet_format *formats,
 {
 	unsigned char pcm_chunks[3] = {0, 0, 0};
 
-	formats->msg_chunks = 2;
-
 	pcm_chunks[0] = analog_ports;
 	pcm_chunks[1] = analog_ports;
 	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
@@ -268,12 +266,69 @@ static void calculate_differed_part(struct snd_motu_packet_format *formats,
 	formats->differed_part_pcm_chunks[1] = pcm_chunks[1];
 }
 
+static int detect_packet_formats_828mk2(struct snd_motu *motu, u32 data)
+{
+	if (((data & V2_OPT_IN_IFACE_MASK) >> V2_OPT_IN_IFACE_SHIFT) ==
+	    V2_OPT_IFACE_MODE_ADAT) {
+		motu->tx_packet_formats.pcm_chunks[0] += 8;
+		motu->tx_packet_formats.pcm_chunks[1] += 4;
+	}
+
+	if (((data & V2_OPT_OUT_IFACE_MASK) >> V2_OPT_OUT_IFACE_SHIFT) ==
+	    V2_OPT_IFACE_MODE_ADAT) {
+		motu->rx_packet_formats.pcm_chunks[0] += 8;
+		motu->rx_packet_formats.pcm_chunks[1] += 4;
+	}
+
+	return 0;
+}
+
+static int detect_packet_formats_traveler(struct snd_motu *motu, u32 data)
+{
+	if (((data & V2_OPT_IN_IFACE_MASK) >> V2_OPT_IN_IFACE_SHIFT) ==
+	    V2_OPT_IFACE_MODE_ADAT) {
+		motu->tx_packet_formats.pcm_chunks[0] += 8;
+		motu->tx_packet_formats.pcm_chunks[1] += 4;
+	}
+
+	if (((data & V2_OPT_OUT_IFACE_MASK) >> V2_OPT_OUT_IFACE_SHIFT) ==
+	    V2_OPT_IFACE_MODE_ADAT) {
+		motu->rx_packet_formats.pcm_chunks[0] += 8;
+		motu->rx_packet_formats.pcm_chunks[1] += 4;
+	}
+
+	return 0;
+}
+
+static int detect_packet_formats_8pre(struct snd_motu *motu, u32 data)
+{
+	if (((data & V2_OPT_IN_IFACE_MASK) >> V2_OPT_IN_IFACE_SHIFT) ==
+	    V2_OPT_IFACE_MODE_ADAT) {
+		motu->tx_packet_formats.pcm_chunks[0] += 8;
+		motu->tx_packet_formats.pcm_chunks[1] += 8;
+	}
+
+	if (((data & V2_OPT_OUT_IFACE_MASK) >> V2_OPT_OUT_IFACE_SHIFT) ==
+	    V2_OPT_IFACE_MODE_ADAT) {
+		motu->rx_packet_formats.pcm_chunks[0] += 8;
+		motu->rx_packet_formats.pcm_chunks[1] += 8;
+	}
+
+	return 0;
+}
+
 int snd_motu_protocol_v2_cache_packet_formats(struct snd_motu *motu)
 {
 	__be32 reg;
 	u32 data;
 	int err;
 
+	motu->tx_packet_formats.pcm_byte_offset = 10;
+	motu->rx_packet_formats.pcm_byte_offset = 10;
+
+	motu->tx_packet_formats.msg_chunks = 2;
+	motu->rx_packet_formats.msg_chunks = 2;
+
 	err = snd_motu_transaction_read(motu, V2_IN_OUT_CONF_OFFSET, &reg,
 					sizeof(reg));
 	if (err < 0)
@@ -290,10 +345,15 @@ int snd_motu_protocol_v2_cache_packet_formats(struct snd_motu *motu)
 	calculate_differed_part(&motu->rx_packet_formats, motu->spec->flags,
 			data, V2_OPT_OUT_IFACE_MASK, V2_OPT_OUT_IFACE_SHIFT);
 
-	motu->tx_packet_formats.pcm_byte_offset = 10;
-	motu->rx_packet_formats.pcm_byte_offset = 10;
 
-	return 0;
+	if (motu->spec == &snd_motu_spec_828mk2)
+		return detect_packet_formats_828mk2(motu, data);
+	else if (motu->spec == &snd_motu_spec_traveler)
+		return detect_packet_formats_traveler(motu, data);
+	else if (motu->spec == &snd_motu_spec_8pre)
+		return detect_packet_formats_8pre(motu, data);
+	else
+		return 0;
 }
 
 const struct snd_motu_spec snd_motu_spec_828mk2 = {

commit dfbaa4dc11eb93e3662dcefbf00a14235c4c1e8e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:33 2020 +0900

    ALSA: firewire-motu: add model-specific table of chunk count
    
    In MOTU protocol, data block consists of SPH and 24-bit chunks
    aligned to quadlet. The number of chunks per data block is specific
    to model. For models with optical interface, the number differs
    depending on I/O settings for the interface (ADAT, TOSLINK).
    
    Currently the number is calculated from flags in model-specific
    data. However this is weak in the case that the model has quirks.
    Actually, for quirks of some models, flags are used against their
    original meanings.
    
    This commit adds model-specific table of chunk count. For future
    integration, this table is based on the calculation.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-7-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index e2913cb54da8..6cd7a5f1f46c 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -306,7 +306,8 @@ const struct snd_motu_spec snd_motu_spec_828mk2 = {
 		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
 		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
-
+	.tx_fixed_pcm_chunks = {14, 14, 0},
+	.rx_fixed_pcm_chunks = {14, 14, 0},
 	.analog_in_ports = 8,
 	.analog_out_ports = 8,
 };
@@ -321,7 +322,8 @@ const struct snd_motu_spec snd_motu_spec_traveler = {
 		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
 		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
-
+	.tx_fixed_pcm_chunks = {14, 14, 8},
+	.rx_fixed_pcm_chunks = {14, 14, 8},
 	.analog_in_ports = 8,
 	.analog_out_ports = 8,
 };
@@ -335,6 +337,8 @@ const struct snd_motu_spec snd_motu_spec_ultralite = {
 		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_TX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_RX_SEPARATED_MAIN,
+	.tx_fixed_pcm_chunks = {14, 14, 0},
+	.rx_fixed_pcm_chunks = {14, 14, 0},
 	.analog_in_ports = 8,
 	.analog_out_ports = 8,
 };
@@ -349,6 +353,8 @@ const struct snd_motu_spec snd_motu_spec_8pre = {
 		 SND_MOTU_SPEC_HAS_OPT_IFACE_B |
 		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
+	.tx_fixed_pcm_chunks = {10, 6, 0},
+	.rx_fixed_pcm_chunks = {10, 6, 0},
 	.analog_in_ports = 8,
 	.analog_out_ports = 2,
 };

commit 562f0c6700cfeb28b7a95d4b7cb6b0496d0b2fb5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:32 2020 +0900

    ALSA: firewire-motu: drop protocol structure
    
    Now protocol structure becomes useless. This commit drops it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-6-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 26534ed97fbc..e2913cb54da8 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -296,13 +296,9 @@ int snd_motu_protocol_v2_cache_packet_formats(struct snd_motu *motu)
 	return 0;
 }
 
-static const struct snd_motu_protocol snd_motu_protocol_v2 = {
-};
-
 const struct snd_motu_spec snd_motu_spec_828mk2 = {
 	.name = "828mk2",
 	.protocol_version = SND_MOTU_PROTOCOL_V2,
-	.protocol = &snd_motu_protocol_v2,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
 		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
@@ -317,7 +313,6 @@ const struct snd_motu_spec snd_motu_spec_828mk2 = {
 
 const struct snd_motu_spec snd_motu_spec_traveler = {
 	.name = "Traveler",
-	.protocol = &snd_motu_protocol_v2,
 	.protocol_version = SND_MOTU_PROTOCOL_V2,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_SUPPORT_CLOCK_X4 |
@@ -334,7 +329,6 @@ const struct snd_motu_spec snd_motu_spec_traveler = {
 const struct snd_motu_spec snd_motu_spec_ultralite = {
 	.name = "UltraLite",
 	.protocol_version = SND_MOTU_PROTOCOL_V2,
-	.protocol = &snd_motu_protocol_v2,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK | // padding.
 		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
@@ -348,7 +342,6 @@ const struct snd_motu_spec snd_motu_spec_ultralite = {
 const struct snd_motu_spec snd_motu_spec_8pre = {
 	.name = "8pre",
 	.protocol_version = SND_MOTU_PROTOCOL_V2,
-	.protocol = &snd_motu_protocol_v2,
 	// In tx, use coax chunks for mix-return 1/2. In rx, use coax chunks for
 	// dummy 1/2.
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |

commit ff222b7e45eb1ffb2931269abf66b9d3576c9eeb
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:31 2020 +0900

    ALSA: firewire-motu: add wrapper functions for protocol-dependent operations
    
    This commit adds helper functions which wraps function call for each
    protocol.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-5-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 2cd710a7c792..26534ed97fbc 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -35,7 +35,8 @@ static int get_clock_rate(u32 data, unsigned int *rate)
 	return 0;
 }
 
-static int v2_get_clock_rate(struct snd_motu *motu, unsigned int *rate)
+int snd_motu_protocol_v2_get_clock_rate(struct snd_motu *motu,
+					unsigned int *rate)
 {
 	__be32 reg;
 	int err;
@@ -48,7 +49,8 @@ static int v2_get_clock_rate(struct snd_motu *motu, unsigned int *rate)
 	return get_clock_rate(be32_to_cpu(reg), rate);
 }
 
-static int v2_set_clock_rate(struct snd_motu *motu, unsigned int rate)
+int snd_motu_protocol_v2_set_clock_rate(struct snd_motu *motu,
+					unsigned int rate)
 {
 	__be32 reg;
 	u32 data;
@@ -122,8 +124,8 @@ static int get_clock_source(struct snd_motu *motu, u32 data,
 	return 0;
 }
 
-static int v2_get_clock_source(struct snd_motu *motu,
-			       enum snd_motu_clock_source *src)
+int snd_motu_protocol_v2_get_clock_source(struct snd_motu *motu,
+					  enum snd_motu_clock_source *src)
 {
 	__be32 reg;
 	int err;
@@ -136,7 +138,8 @@ static int v2_get_clock_source(struct snd_motu *motu,
 	return get_clock_source(motu, be32_to_cpu(reg), src);
 }
 
-static int v2_switch_fetching_mode(struct snd_motu *motu, bool enable)
+int snd_motu_protocol_v2_switch_fetching_mode(struct snd_motu *motu,
+					      bool enable)
 {
 	enum snd_motu_clock_source src;
 	__be32 reg;
@@ -265,7 +268,7 @@ static void calculate_differed_part(struct snd_motu_packet_format *formats,
 	formats->differed_part_pcm_chunks[1] = pcm_chunks[1];
 }
 
-static int v2_cache_packet_formats(struct snd_motu *motu)
+int snd_motu_protocol_v2_cache_packet_formats(struct snd_motu *motu)
 {
 	__be32 reg;
 	u32 data;
@@ -294,11 +297,6 @@ static int v2_cache_packet_formats(struct snd_motu *motu)
 }
 
 static const struct snd_motu_protocol snd_motu_protocol_v2 = {
-	.get_clock_rate		= v2_get_clock_rate,
-	.set_clock_rate		= v2_set_clock_rate,
-	.get_clock_source	= v2_get_clock_source,
-	.switch_fetching_mode	= v2_switch_fetching_mode,
-	.cache_packet_formats	= v2_cache_packet_formats,
 };
 
 const struct snd_motu_spec snd_motu_spec_828mk2 = {

commit 61d79c70c976a14cb321e537c39d147f7069e86a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:30 2020 +0900

    ALSA: firewire-motu: localize protocol data
    
    This commit adds enumerations of protocol version to localize protocol
    data.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index ed71c08e5942..2cd710a7c792 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -293,7 +293,7 @@ static int v2_cache_packet_formats(struct snd_motu *motu)
 	return 0;
 }
 
-const struct snd_motu_protocol snd_motu_protocol_v2 = {
+static const struct snd_motu_protocol snd_motu_protocol_v2 = {
 	.get_clock_rate		= v2_get_clock_rate,
 	.set_clock_rate		= v2_set_clock_rate,
 	.get_clock_source	= v2_get_clock_source,
@@ -303,6 +303,7 @@ const struct snd_motu_protocol snd_motu_protocol_v2 = {
 
 const struct snd_motu_spec snd_motu_spec_828mk2 = {
 	.name = "828mk2",
+	.protocol_version = SND_MOTU_PROTOCOL_V2,
 	.protocol = &snd_motu_protocol_v2,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
@@ -319,6 +320,7 @@ const struct snd_motu_spec snd_motu_spec_828mk2 = {
 const struct snd_motu_spec snd_motu_spec_traveler = {
 	.name = "Traveler",
 	.protocol = &snd_motu_protocol_v2,
+	.protocol_version = SND_MOTU_PROTOCOL_V2,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_SUPPORT_CLOCK_X4 |
 		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
@@ -333,6 +335,7 @@ const struct snd_motu_spec snd_motu_spec_traveler = {
 
 const struct snd_motu_spec snd_motu_spec_ultralite = {
 	.name = "UltraLite",
+	.protocol_version = SND_MOTU_PROTOCOL_V2,
 	.protocol = &snd_motu_protocol_v2,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK | // padding.
@@ -346,6 +349,7 @@ const struct snd_motu_spec snd_motu_spec_ultralite = {
 
 const struct snd_motu_spec snd_motu_spec_8pre = {
 	.name = "8pre",
+	.protocol_version = SND_MOTU_PROTOCOL_V2,
 	.protocol = &snd_motu_protocol_v2,
 	// In tx, use coax chunks for mix-return 1/2. In rx, use coax chunks for
 	// dummy 1/2.

commit 0a7c7b47e44f7062069f23a4d674c81eb7f4ad56
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:28 2020 +0900

    ALSA: firewire-motu: move spec data to v2 protocol file
    
    The most of members in spec data is used in each protocol file. It's
    better to capsulate the data to the file.
    
    This commit moves the data to the file for protocol version 2.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 619b6ae73f62..ed71c08e5942 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -300,3 +300,60 @@ const struct snd_motu_protocol snd_motu_protocol_v2 = {
 	.switch_fetching_mode	= v2_switch_fetching_mode,
 	.cache_packet_formats	= v2_cache_packet_formats,
 };
+
+const struct snd_motu_spec snd_motu_spec_828mk2 = {
+	.name = "828mk2",
+	.protocol = &snd_motu_protocol_v2,
+	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
+		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
+		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
+		 SND_MOTU_SPEC_RX_SEPARATED_MAIN |
+		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
+		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
+
+	.analog_in_ports = 8,
+	.analog_out_ports = 8,
+};
+
+const struct snd_motu_spec snd_motu_spec_traveler = {
+	.name = "Traveler",
+	.protocol = &snd_motu_protocol_v2,
+	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
+		 SND_MOTU_SPEC_SUPPORT_CLOCK_X4 |
+		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
+		 SND_MOTU_SPEC_HAS_AESEBU_IFACE |
+		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
+		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
+
+	.analog_in_ports = 8,
+	.analog_out_ports = 8,
+};
+
+const struct snd_motu_spec snd_motu_spec_ultralite = {
+	.name = "UltraLite",
+	.protocol = &snd_motu_protocol_v2,
+	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
+		 SND_MOTU_SPEC_TX_MICINST_CHUNK | // padding.
+		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
+		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+		 SND_MOTU_SPEC_TX_MIDI_2ND_Q |
+		 SND_MOTU_SPEC_RX_SEPARATED_MAIN,
+	.analog_in_ports = 8,
+	.analog_out_ports = 8,
+};
+
+const struct snd_motu_spec snd_motu_spec_8pre = {
+	.name = "8pre",
+	.protocol = &snd_motu_protocol_v2,
+	// In tx, use coax chunks for mix-return 1/2. In rx, use coax chunks for
+	// dummy 1/2.
+	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
+		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
+		 SND_MOTU_SPEC_HAS_OPT_IFACE_B |
+		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+		 SND_MOTU_SPEC_TX_MIDI_2ND_Q,
+	.analog_in_ports = 8,
+	.analog_out_ports = 2,
+};

commit bd1073728260e1d2f9589c928b6d8ddb14f5646f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 30 17:06:43 2019 +0900

    ALSA: firewire-motu: code refactoring to handle model specific switch for protocol v2
    
    In MOTU FireWire series, devices which support protocol version 2 have
    several types of hardware design to process audio data frames for isoc
    packet. Roughly devices are categorized into three groups:
     - 828mkII
     - Traveler/896HD
     - UltraLite/8pre FireWire
    
    Some bit flags in register addressed by 0x'ffff'f000'0b14
    includes device-specific effects.
    
    This commit cleanups implementation of protocol v2 in this point.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191030080644.1704-6-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index cb0e58a9f33d..619b6ae73f62 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -12,10 +12,8 @@
 #define  V2_CLOCK_RATE_SHIFT			3
 #define  V2_CLOCK_SRC_MASK			0x00000007
 #define  V2_CLOCK_SRC_SHIFT			0
-#define  V2_CLOCK_TRAVELER_FETCH_DISABLE	0x04000000
-#define  V2_CLOCK_TRAVELER_FETCH_ENABLE		0x03000000
-#define  V2_CLOCK_8PRE_FETCH_DISABLE		0x02000000
-#define  V2_CLOCK_8PRE_FETCH_ENABLE		0x00000000
+#define  V2_CLOCK_FETCH_ENABLE			0x02000000
+#define  V2_CLOCK_MODEL_SPECIFIC		0x04000000
 
 #define V2_IN_OUT_CONF_OFFSET			0x0c04
 #define  V2_OPT_OUT_IFACE_MASK			0x00000c00
@@ -73,11 +71,6 @@ static int v2_set_clock_rate(struct snd_motu *motu, unsigned int rate)
 	data &= ~V2_CLOCK_RATE_MASK;
 	data |= i << V2_CLOCK_RATE_SHIFT;
 
-	if (motu->spec == &snd_motu_spec_traveler) {
-		data &= ~V2_CLOCK_TRAVELER_FETCH_ENABLE;
-		data |= V2_CLOCK_TRAVELER_FETCH_DISABLE;
-	}
-
 	reg = cpu_to_be32(data);
 	return snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET, &reg,
 					  sizeof(reg));
@@ -145,42 +138,49 @@ static int v2_get_clock_source(struct snd_motu *motu,
 
 static int v2_switch_fetching_mode(struct snd_motu *motu, bool enable)
 {
+	enum snd_motu_clock_source src;
 	__be32 reg;
 	u32 data;
 	int err = 0;
 
-	if (motu->spec == &snd_motu_spec_traveler ||
-	    motu->spec == &snd_motu_spec_8pre) {
-		err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET,
-						&reg, sizeof(reg));
+	// 828mkII implements Altera ACEX 1K EP1K30. Nothing to do.
+	if (motu->spec == &snd_motu_spec_828mk2)
+		return 0;
+
+	err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+	data = be32_to_cpu(reg);
+
+	err = get_clock_source(motu, data, &src);
+	if (err < 0)
+		return err;
+
+	data &= ~(V2_CLOCK_FETCH_ENABLE | V2_CLOCK_MODEL_SPECIFIC);
+	if (enable)
+		data |= V2_CLOCK_FETCH_ENABLE;
+
+	if (motu->spec->flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4) {
+		// Expected for Traveler and 896HD, which implements Altera
+		// Cyclone EP1C3.
+		data |= V2_CLOCK_MODEL_SPECIFIC;
+	} else {
+		// For UltraLite and 8pre, which implements Xilinx Spartan
+		// XC3S200.
+		unsigned int rate;
+
+		err = get_clock_rate(data, &rate);
 		if (err < 0)
 			return err;
-		data = be32_to_cpu(reg);
-
-		if (motu->spec == &snd_motu_spec_traveler) {
-			data &= ~(V2_CLOCK_TRAVELER_FETCH_DISABLE |
-				  V2_CLOCK_TRAVELER_FETCH_ENABLE);
-
-			if (enable)
-				data |= V2_CLOCK_TRAVELER_FETCH_ENABLE;
-			else
-				data |= V2_CLOCK_TRAVELER_FETCH_DISABLE;
-		} else if (motu->spec == &snd_motu_spec_8pre) {
-			data &= ~(V2_CLOCK_8PRE_FETCH_DISABLE |
-				  V2_CLOCK_8PRE_FETCH_ENABLE);
-
-			if (enable)
-				data |= V2_CLOCK_8PRE_FETCH_DISABLE;
-			else
-				data |= V2_CLOCK_8PRE_FETCH_ENABLE;
-		}
 
-		reg = cpu_to_be32(data);
-		err = snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET,
-						 &reg, sizeof(reg));
+		if (src == SND_MOTU_CLOCK_SOURCE_SPH && rate > 48000)
+			data |= V2_CLOCK_MODEL_SPECIFIC;
 	}
 
-	return err;
+	reg = cpu_to_be32(data);
+	return snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET, &reg,
+					  sizeof(reg));
 }
 
 static void calculate_fixed_part(struct snd_motu_packet_format *formats,

commit 4b2079f80aa065b237955e75d0b627943656b0ab
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 30 17:06:42 2019 +0900

    ALSA: firewire-motu: minor code refactoring for protocol version 2
    
    This commit adds some helper functions to parse register value for
    source of sampling clock and nominal sampling transmission frequency.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191030080644.1704-5-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 2757e5b42b9b..cb0e58a9f33d 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -26,10 +26,20 @@
 #define  V2_OPT_IFACE_MODE_ADAT			1
 #define  V2_OPT_IFACE_MODE_SPDIF		2
 
+static int get_clock_rate(u32 data, unsigned int *rate)
+{
+	unsigned int index = (data & V2_CLOCK_RATE_MASK) >> V2_CLOCK_RATE_SHIFT;
+	if (index >= ARRAY_SIZE(snd_motu_clock_rates))
+		return -EIO;
+
+	*rate = snd_motu_clock_rates[index];
+
+	return 0;
+}
+
 static int v2_get_clock_rate(struct snd_motu *motu, unsigned int *rate)
 {
 	__be32 reg;
-	unsigned int index;
 	int err;
 
 	err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,
@@ -37,13 +47,7 @@ static int v2_get_clock_rate(struct snd_motu *motu, unsigned int *rate)
 	if (err < 0)
 		return err;
 
-	index = (be32_to_cpu(reg) & V2_CLOCK_RATE_MASK) >> V2_CLOCK_RATE_SHIFT;
-	if (index >= ARRAY_SIZE(snd_motu_clock_rates))
-		return -EIO;
-
-	*rate = snd_motu_clock_rates[index];
-
-	return 0;
+	return get_clock_rate(be32_to_cpu(reg), rate);
 }
 
 static int v2_set_clock_rate(struct snd_motu *motu, unsigned int rate)
@@ -79,38 +83,33 @@ static int v2_set_clock_rate(struct snd_motu *motu, unsigned int rate)
 					  sizeof(reg));
 }
 
-static int v2_get_clock_source(struct snd_motu *motu,
-			       enum snd_motu_clock_source *src)
+static int get_clock_source(struct snd_motu *motu, u32 data,
+			    enum snd_motu_clock_source *src)
 {
-	__be32 reg;
-	unsigned int index;
-	int err;
-
-	err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,
-					sizeof(reg));
-	if (err < 0)
-		return err;
-
-	index = be32_to_cpu(reg) & V2_CLOCK_SRC_MASK;
+	unsigned int index = data & V2_CLOCK_SRC_MASK;
 	if (index > 5)
 		return -EIO;
 
-	/* To check the configuration of optical interface. */
-	err = snd_motu_transaction_read(motu, V2_IN_OUT_CONF_OFFSET, &reg,
-					sizeof(reg));
-	if (err < 0)
-		return err;
-
 	switch (index) {
 	case 0:
 		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
 		break;
 	case 1:
+	{
+		__be32 reg;
+
+		// To check the configuration of optical interface.
+		int err = snd_motu_transaction_read(motu, V2_IN_OUT_CONF_OFFSET,
+						    &reg, sizeof(reg));
+		if (err < 0)
+			return err;
+
 		if (be32_to_cpu(reg) & 0x00000200)
 			*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_OPT;
 		else
 			*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_OPT;
 		break;
+	}
 	case 2:
 		*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;
 		break;
@@ -130,6 +129,20 @@ static int v2_get_clock_source(struct snd_motu *motu,
 	return 0;
 }
 
+static int v2_get_clock_source(struct snd_motu *motu,
+			       enum snd_motu_clock_source *src)
+{
+	__be32 reg;
+	int err;
+
+	err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+
+	return get_clock_source(motu, be32_to_cpu(reg), src);
+}
+
 static int v2_switch_fetching_mode(struct snd_motu *motu, bool enable)
 {
 	__be32 reg;

commit 3f58f004bff3273d102583e0b2f478526cf9d3c8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 30 17:06:41 2019 +0900

    ALSA: firewire-motu: detect SPH source of sampling clock
    
    In MOTU FireWire series, devices have a mode to generate sampling clock
    from a sequence of source packet header (SPH) included in each data block
    of received packet. This mode is used for several purposes such as mode
    for SMPTE time code, sync to the other sound cards and so on.
    
    This commit adds support for the SPH mode.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191030080644.1704-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index a42f77fc3858..2757e5b42b9b 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -114,6 +114,9 @@ static int v2_get_clock_source(struct snd_motu *motu,
 	case 2:
 		*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;
 		break;
+	case 3:
+		*src = SND_MOTU_CLOCK_SOURCE_SPH;
+		break;
 	case 4:
 		*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;
 		break;

commit 2644df63c709e107c1882be95d802adea284dbf5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 30 17:06:39 2019 +0900

    ALSA: firewire-motu: fix wrong spelling for macro
    
    Just replace 'SEPARETED' with 'SEPARATED' for macro.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191030080644.1704-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 9e2f16eebe0a..a42f77fc3858 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -191,7 +191,7 @@ static void calculate_fixed_part(struct snd_motu_packet_format *formats,
 			pcm_chunks[1] += 2;
 		}
 	} else {
-		if (flags & SND_MOTU_SPEC_RX_SEPARETED_MAIN) {
+		if (flags & SND_MOTU_SPEC_RX_SEPARATED_MAIN) {
 			pcm_chunks[0] += 2;
 			pcm_chunks[1] += 2;
 		}

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 848fffe7387e..9e2f16eebe0a 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * motu-protocol-v2.c - a part of driver for MOTU FireWire series
  *
  * Copyright (c) 2015-2017 Takashi Sakamoto <o-takashi@sakamocchi.jp>
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "motu.h"

commit 35033d8cb71b4dd4fa8d8d28a534af1ee921b9a0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Mar 17 16:50:24 2019 +0900

    ALSA: firewire-motu: add support MOTU 8pre FireWire
    
    This commit adds support for MOTU 8pre FireWire, which was shipped 2007
    and nowadays already discontinued. Userspace applications can transmit
    and receive PCM frames and MIDI messages for this model via ALSA PCM
    interface and RawMidi/Sequencer interfaces.
    
    Like the other models of MOTU FireWire series, this model has many
    quirks in its CIP.
    
    At first, data channels for two pairs of optical interfaces. At lower
    sampling transmission frequency, i.e. 44.1 and 48.0 kHz, one pair is
    available for ADAT data, thus 8 data chunks are transferred by CIP.
    At middle sampling transmission frequency, i.e.  88.2 and 96.0 kHz,
    two pairs are available to keep 8 chunks for ADAT data, thus CIP
    still includes 8 data chunks.
    
    Apart from data chunks for optical interface, CIP includes fixed number
    of data chunks. In tx stream, two chunks for status message, eight
    chunks for samples from analog 1-8 input, two chunks for mix-return.
    In rx stream, two chunks for control message, two chunks for main 1-2
    output, two chunks for phone 1-2 output, two chunks for dummy 1-2.
    
    CIP header in tx stream includes quirks for its dbs and dbc fields.
    The value of dbs field is fixed to 0x13, against its actual size.
    The value of dbc field is firstly updated to 0x07 from zero, then
    it's incremented continuously according to actual number of data h
    blocks.
    
    Finally, the model has own bits to disable frame fetch.
    
    This commit uses several options to absorb the above quirks.
    
    $ python2 crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  0410b57d  bus_info_length 4, crc_length 16, crc 46461
    404  31333934  bus_name "1394"
    408  20001000  irmc 0, cmc 0, isc 1, bmc 0, cyc_clk_acc 0, max_rec 1 (4)
    40c  0001f200  company_id 0001f2     |
    410  00083dfb  device_id 0000083dfb  | EUI-64 0001f20000083dfb
    
                   root directory
                   -----------------------------------------------------------------
    414  0004c65c  directory_length 4, crc 50780
    418  030001f2  vendor
    41c  0c0083c0  node capabilities per IEEE 1394
    420  8d000006  --> eui-64 leaf at 438
    424  d1000001  --> unit directory at 428
    
                   unit directory at 428
                   -----------------------------------------------------------------
    428  0003991c  directory_length 3, crc 39196
    42c  120001f2  specifier id
    430  1300000f  version
    434  17103800  model
    
                   eui-64 leaf at 438
                   -----------------------------------------------------------------
    438  00022681  leaf_length 2, crc 9857
    43c  0001f200  company_id 0001f2     |
    440  00083dfb  device_id 0000083dfb  | EUI-64 0001f20000083dfb
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 453fc29fade7..848fffe7387e 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -15,6 +15,8 @@
 #define  V2_CLOCK_SRC_SHIFT			0
 #define  V2_CLOCK_TRAVELER_FETCH_DISABLE	0x04000000
 #define  V2_CLOCK_TRAVELER_FETCH_ENABLE		0x03000000
+#define  V2_CLOCK_8PRE_FETCH_DISABLE		0x02000000
+#define  V2_CLOCK_8PRE_FETCH_ENABLE		0x00000000
 
 #define V2_IN_OUT_CONF_OFFSET			0x0c04
 #define  V2_OPT_OUT_IFACE_MASK			0x00000c00
@@ -132,20 +134,31 @@ static int v2_switch_fetching_mode(struct snd_motu *motu, bool enable)
 	u32 data;
 	int err = 0;
 
-	if (motu->spec == &snd_motu_spec_traveler) {
+	if (motu->spec == &snd_motu_spec_traveler ||
+	    motu->spec == &snd_motu_spec_8pre) {
 		err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET,
 						&reg, sizeof(reg));
 		if (err < 0)
 			return err;
 		data = be32_to_cpu(reg);
 
-		data &= ~(V2_CLOCK_TRAVELER_FETCH_DISABLE |
-			  V2_CLOCK_TRAVELER_FETCH_ENABLE);
-
-		if (enable)
-			data |= V2_CLOCK_TRAVELER_FETCH_ENABLE;
-		else
-			data |= V2_CLOCK_TRAVELER_FETCH_DISABLE;
+		if (motu->spec == &snd_motu_spec_traveler) {
+			data &= ~(V2_CLOCK_TRAVELER_FETCH_DISABLE |
+				  V2_CLOCK_TRAVELER_FETCH_ENABLE);
+
+			if (enable)
+				data |= V2_CLOCK_TRAVELER_FETCH_ENABLE;
+			else
+				data |= V2_CLOCK_TRAVELER_FETCH_DISABLE;
+		} else if (motu->spec == &snd_motu_spec_8pre) {
+			data &= ~(V2_CLOCK_8PRE_FETCH_DISABLE |
+				  V2_CLOCK_8PRE_FETCH_ENABLE);
+
+			if (enable)
+				data |= V2_CLOCK_8PRE_FETCH_DISABLE;
+			else
+				data |= V2_CLOCK_8PRE_FETCH_ENABLE;
+		}
 
 		reg = cpu_to_be32(data);
 		err = snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET,
@@ -220,10 +233,16 @@ static void calculate_differed_part(struct snd_motu_packet_format *formats,
 	 * interfaces.
 	 */
 	data = (data & mask) >> shift;
-	if ((flags & SND_MOTU_SPEC_HAS_OPT_IFACE_A) &&
-	    data == V2_OPT_IFACE_MODE_ADAT) {
-		pcm_chunks[0] += 8;
-		pcm_chunks[1] += 4;
+	if (data == V2_OPT_IFACE_MODE_ADAT) {
+		if (flags & SND_MOTU_SPEC_HAS_OPT_IFACE_A) {
+			pcm_chunks[0] += 8;
+			pcm_chunks[1] += 4;
+		}
+		// 8pre has two sets of optical interface and doesn't reduce
+		// chunks for ADAT signals.
+		if (flags & SND_MOTU_SPEC_HAS_OPT_IFACE_B) {
+			pcm_chunks[1] += 4;
+		}
 	}
 
 	/* At mode x4, no data chunks are supported in this part. */

commit 6c5e1ac0e144a8560cfa11bed8cdadab9491952f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 18 21:07:55 2018 +0900

    ALSA: firewire-motu: add support for Motu Traveler
    
    This commit adds support for MOTU Traveler, launched in 2005, discontinued
    quite before. As a result, transmission of PCM frame and MIDI messages is
    available via ALSA PCM and RawMIDI/Sequencer interfaces.
    
    This model supports sampling transmission frequency up to 192.0 kHz, and
    AES/EBU on XLR interface and ADAT on optical interface. Unlike
    Motu 828MkII, Windows driver can switch fetching mode for DSP, like
    mute/unmute feature.
    
    Although this commit enables high sampling transmission frequency, actual
    sound from this model is not good. As long as I tested, it's silence at
    176.4 kHz, and it includes hissing noise at 192.0 kHz. In my opinion, as I
    reported at 3526ce7f9ba7 ('ALSA: firewire-motu: add MOTU specific protocol
    layer'), timestamping on source packet header (SPH) may not still be good
    for this model as well.
    
    $ python2 crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  04106505  bus_info_length 4, crc_length 16, crc 25861
    404  31333934  bus_name "1394"
    408  20001000  irmc 0, cmc 0, isc 1, bmc 0, cyc_clk_acc 0, max_rec 1 (4)
    40c  0001f200  company_id 0001f2     |
    410  0001f32f  device_id 000001f32f  | EUI-64 0001f2000001f32f
    
                   root directory
                   -----------------------------------------------------------------
    414  0004c65c  directory_length 4, crc 50780
    418  030001f2  vendor
    41c  0c0083c0  node capabilities per IEEE 1394
    420  8d000006  --> eui-64 leaf at 438
    424  d1000001  --> unit directory at 428
    
                   unit directory at 428
                   -----------------------------------------------------------------
    428  00035955  directory_length 3, crc 22869
    42c  120001f2  specifier id
    430  13000009  version
    434  17107800  model
    
                   eui-64 leaf at 438
                   -----------------------------------------------------------------
    438  000206b2  leaf_length 2, crc 1714
    43c  0001f200  company_id 0001f2     |
    440  0001f32f  device_id 000001f32f  | EUI-64 0001f2000001f32f
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index e5bd3ac02300..453fc29fade7 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -13,6 +13,8 @@
 #define  V2_CLOCK_RATE_SHIFT			3
 #define  V2_CLOCK_SRC_MASK			0x00000007
 #define  V2_CLOCK_SRC_SHIFT			0
+#define  V2_CLOCK_TRAVELER_FETCH_DISABLE	0x04000000
+#define  V2_CLOCK_TRAVELER_FETCH_ENABLE		0x03000000
 
 #define V2_IN_OUT_CONF_OFFSET			0x0c04
 #define  V2_OPT_OUT_IFACE_MASK			0x00000c00
@@ -66,6 +68,11 @@ static int v2_set_clock_rate(struct snd_motu *motu, unsigned int rate)
 	data &= ~V2_CLOCK_RATE_MASK;
 	data |= i << V2_CLOCK_RATE_SHIFT;
 
+	if (motu->spec == &snd_motu_spec_traveler) {
+		data &= ~V2_CLOCK_TRAVELER_FETCH_ENABLE;
+		data |= V2_CLOCK_TRAVELER_FETCH_DISABLE;
+	}
+
 	reg = cpu_to_be32(data);
 	return snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET, &reg,
 					  sizeof(reg));
@@ -121,8 +128,31 @@ static int v2_get_clock_source(struct snd_motu *motu,
 
 static int v2_switch_fetching_mode(struct snd_motu *motu, bool enable)
 {
-	/* V2 protocol doesn't have this feature. */
-	return 0;
+	__be32 reg;
+	u32 data;
+	int err = 0;
+
+	if (motu->spec == &snd_motu_spec_traveler) {
+		err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET,
+						&reg, sizeof(reg));
+		if (err < 0)
+			return err;
+		data = be32_to_cpu(reg);
+
+		data &= ~(V2_CLOCK_TRAVELER_FETCH_DISABLE |
+			  V2_CLOCK_TRAVELER_FETCH_ENABLE);
+
+		if (enable)
+			data |= V2_CLOCK_TRAVELER_FETCH_ENABLE;
+		else
+			data |= V2_CLOCK_TRAVELER_FETCH_DISABLE;
+
+		reg = cpu_to_be32(data);
+		err = snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET,
+						 &reg, sizeof(reg));
+	}
+
+	return err;
 }
 
 static void calculate_fixed_part(struct snd_motu_packet_format *formats,

commit 191ef57683aab1939d9b7afdc43f9213c21c5e1e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 18 21:07:54 2018 +0900

    ALSA: firewire-motu: cancel chunk alignment for protocol version 2
    
    For MOTU protocol version 2, this driver arranges the number of data
    chunks to align chunks to quadlet data channel. However, MOTU Traveler
    has padding bytes in the end of data block at high clock mode.
    
    This commit removes the arrangement. Fortunately, at low and middle clock
    mode, supported model for v2 protocol (828mkII) gets no influence from this
    change because all of combination for data chunks are just aligned to
    quadlet data channel.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index f25b1ba118a2..e5bd3ac02300 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -173,12 +173,9 @@ static void calculate_fixed_part(struct snd_motu_packet_format *formats,
 	pcm_chunks[0] += 2;
 	pcm_chunks[1] += 2;
 
-	/* This part should be multiples of 4. */
-	formats->fixed_part_pcm_chunks[0] = round_up(2 + pcm_chunks[0], 4) - 2;
-	formats->fixed_part_pcm_chunks[1] = round_up(2 + pcm_chunks[1], 4) - 2;
-	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
-		formats->fixed_part_pcm_chunks[2] =
-					round_up(2 + pcm_chunks[2], 4) - 2;
+	formats->fixed_part_pcm_chunks[0] = pcm_chunks[0];
+	formats->fixed_part_pcm_chunks[1] = pcm_chunks[1];
+	formats->fixed_part_pcm_chunks[2] = pcm_chunks[2];
 }
 
 static void calculate_differed_part(struct snd_motu_packet_format *formats,

commit 06ac0b6f8f74e98d32f9dea5209bd26f3e7b50ba
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 18 21:07:53 2018 +0900

    ALSA: firewire-motu: add a flag for AES/EBU on XLR interface
    
    MOTU Traveler supports AES/EBU on XLR interface and data block of rx/tx
    packet includes two chunk for the interface. This commit adds a flag
    for this purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 614f9b11e010..f25b1ba118a2 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -160,6 +160,11 @@ static void calculate_fixed_part(struct snd_motu_packet_format *formats,
 		pcm_chunks[1] += 2;
 	}
 
+	if (flags & SND_MOTU_SPEC_HAS_AESEBU_IFACE) {
+		pcm_chunks[0] += 2;
+		pcm_chunks[1] += 2;
+	}
+
 	/*
 	 * All of v2 models have a pair of coaxial interfaces for digital in/out
 	 * port. At 44.1/48.0/88.2/96.0 kHz, packets includes PCM from these

commit 81720c6d49b7932d642e7dca736bef9a40c9b5f7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 18 21:07:52 2018 +0900

    ALSA: firewire-motu: add a flag for chunks for main 1/2 out
    
    This driver explicitly assumes that all of supported models have main data
    chunk separated from chunk for analog ports. However, MOTU Traveler doesn't
    support the separated main data chunk.
    
    This commit adds a flag for the separated main data chunk.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index a51fd196d884..614f9b11e010 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -149,11 +149,15 @@ static void calculate_fixed_part(struct snd_motu_packet_format *formats,
 			pcm_chunks[1] += 2;
 		}
 	} else {
-		/*
-		 * Packets to v2 units transfer main-out-1/2 and phone-out-1/2.
-		 */
-		pcm_chunks[0] += 4;
-		pcm_chunks[1] += 4;
+		if (flags & SND_MOTU_SPEC_RX_SEPARETED_MAIN) {
+			pcm_chunks[0] += 2;
+			pcm_chunks[1] += 2;
+		}
+
+		// Packets to v2 units include 2 chunks for phone 1/2, except
+		// for 176.4/192.0 kHz.
+		pcm_chunks[0] += 2;
+		pcm_chunks[1] += 2;
 	}
 
 	/*

commit 6c1549c4cc3c1b0d8623cde00e28f094b2db0d41
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 18 21:07:51 2018 +0900

    ALSA: firewire-motu: suppless consumption for unused element of array in stack
    
    In MOTU firewire protocol, data block consists of 24 bit data chunks except
    for one quadlet for source packet header (SPH). The number of data chunk in
    a data block is different between three clock modes; low, middle and high.
    When unit supports ADAT on optical interface, the data block includes some
    chunks for ADAT channels. These ADAT chunks are unavailable at high mode.
    
    This driver has local functions to calculate the number of ADAT chunks. But
    They uses stack for three clock modes. This is useless for higher mode.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 525b746330be..a51fd196d884 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -176,7 +176,7 @@ static void calculate_differed_part(struct snd_motu_packet_format *formats,
 				    enum snd_motu_spec_flags flags,
 				    u32 data, u32 mask, u32 shift)
 {
-	unsigned char pcm_chunks[3] = {0, 0};
+	unsigned char pcm_chunks[2] = {0, 0};
 
 	/*
 	 * When optical interfaces are configured for S/PDIF (TOSLINK),

commit 8b460c76bd17128db90d69a3f8b4ad2ee744d118
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 20 21:25:03 2017 +0900

    ALSA: firewire-motu: add specification flag for position of flag for MIDI messages
    
    In protocols of MOTU FireWire series, when transferring MIDI messages,
    transmitter set existence flag to one byte on first several quadlets. The
    position differs depending on protocols and models, however two cases are
    confirmed; in 5th byte and 8th byte from MSB side.
    
    This commit adds a series of specification flag to describe them. When
    the existence flag is in the 5th byte, SND_MOTU_SPEC_[R|T]X_MIDI_2ND_Q is
    used. Else, another set of the flag is used. Here, '_Q' means quadlet.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
index 05b5d287c2f3..525b746330be 100644
--- a/sound/firewire/motu/motu-protocol-v2.c
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -217,12 +217,7 @@ static int v2_cache_packet_formats(struct snd_motu *motu)
 	calculate_differed_part(&motu->rx_packet_formats, motu->spec->flags,
 			data, V2_OPT_OUT_IFACE_MASK, V2_OPT_OUT_IFACE_SHIFT);
 
-	motu->tx_packet_formats.midi_flag_offset = 4;
-	motu->tx_packet_formats.midi_byte_offset = 6;
 	motu->tx_packet_formats.pcm_byte_offset = 10;
-
-	motu->rx_packet_formats.midi_flag_offset = 4;
-	motu->rx_packet_formats.midi_byte_offset = 6;
 	motu->rx_packet_formats.pcm_byte_offset = 10;
 
 	return 0;

commit 949613e366ed436a7639722b0ab6ed66a0199ae9
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:26 2017 +0900

    ALSA: firewire-motu: add support for MOTU 828mk2 as a model with protocol version 2
    
    MOTU 828mk2 is one of second generation in MOTU FireWire series, produced in
    2003. This model consists of four chips:
     * TI TSB41AB2 (Physical layer for IEEE 1394 bus)
     * PDI 1394L40BE (Link layer for IEEE 1394 bus and packet processing layer)
     * ALTERA ACEX 1K EP1K30 Series FPGA (Data block processing layer)
     * TI TMS320VC5402 (Digital signal processing)
    
    This commit adds a support for this model, with its unique protocol as
    version 2. The features of this protocol are:
    
     * Support data chunks for status and control messages for both
       directions.
     * Support a pair of MIDI input/output.
     * Support a data chunk for mic/instrument independent of analog line in.
     * Support a data chunk for playback return.
     * Support independent data chunks for S/PDIF of both optical/coaxial
       interfaces.
     * Support independent data chunks for each of main out and phone out.
    
    Status of clock is configured by write transactions to 0x'ffff'f000'0b14.
    Modes of optical interfaces are configured by write transactions to
    0x'ffff'f000'0c04.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v2.c b/sound/firewire/motu/motu-protocol-v2.c
new file mode 100644
index 000000000000..05b5d287c2f3
--- /dev/null
+++ b/sound/firewire/motu/motu-protocol-v2.c
@@ -0,0 +1,237 @@
+/*
+ * motu-protocol-v2.c - a part of driver for MOTU FireWire series
+ *
+ * Copyright (c) 2015-2017 Takashi Sakamoto <o-takashi@sakamocchi.jp>
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "motu.h"
+
+#define V2_CLOCK_STATUS_OFFSET			0x0b14
+#define  V2_CLOCK_RATE_MASK			0x00000038
+#define  V2_CLOCK_RATE_SHIFT			3
+#define  V2_CLOCK_SRC_MASK			0x00000007
+#define  V2_CLOCK_SRC_SHIFT			0
+
+#define V2_IN_OUT_CONF_OFFSET			0x0c04
+#define  V2_OPT_OUT_IFACE_MASK			0x00000c00
+#define  V2_OPT_OUT_IFACE_SHIFT			10
+#define  V2_OPT_IN_IFACE_MASK			0x00000300
+#define  V2_OPT_IN_IFACE_SHIFT			8
+#define  V2_OPT_IFACE_MODE_NONE			0
+#define  V2_OPT_IFACE_MODE_ADAT			1
+#define  V2_OPT_IFACE_MODE_SPDIF		2
+
+static int v2_get_clock_rate(struct snd_motu *motu, unsigned int *rate)
+{
+	__be32 reg;
+	unsigned int index;
+	int err;
+
+	err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+
+	index = (be32_to_cpu(reg) & V2_CLOCK_RATE_MASK) >> V2_CLOCK_RATE_SHIFT;
+	if (index >= ARRAY_SIZE(snd_motu_clock_rates))
+		return -EIO;
+
+	*rate = snd_motu_clock_rates[index];
+
+	return 0;
+}
+
+static int v2_set_clock_rate(struct snd_motu *motu, unsigned int rate)
+{
+	__be32 reg;
+	u32 data;
+	int i;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {
+		if (snd_motu_clock_rates[i] == rate)
+			break;
+	}
+	if (i == ARRAY_SIZE(snd_motu_clock_rates))
+		return -EINVAL;
+
+	err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+	data = be32_to_cpu(reg);
+
+	data &= ~V2_CLOCK_RATE_MASK;
+	data |= i << V2_CLOCK_RATE_SHIFT;
+
+	reg = cpu_to_be32(data);
+	return snd_motu_transaction_write(motu, V2_CLOCK_STATUS_OFFSET, &reg,
+					  sizeof(reg));
+}
+
+static int v2_get_clock_source(struct snd_motu *motu,
+			       enum snd_motu_clock_source *src)
+{
+	__be32 reg;
+	unsigned int index;
+	int err;
+
+	err = snd_motu_transaction_read(motu, V2_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+
+	index = be32_to_cpu(reg) & V2_CLOCK_SRC_MASK;
+	if (index > 5)
+		return -EIO;
+
+	/* To check the configuration of optical interface. */
+	err = snd_motu_transaction_read(motu, V2_IN_OUT_CONF_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+
+	switch (index) {
+	case 0:
+		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
+		break;
+	case 1:
+		if (be32_to_cpu(reg) & 0x00000200)
+			*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_OPT;
+		else
+			*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_OPT;
+		break;
+	case 2:
+		*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;
+		break;
+	case 4:
+		*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;
+		break;
+	case 5:
+		*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_DSUB;
+		break;
+	default:
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int v2_switch_fetching_mode(struct snd_motu *motu, bool enable)
+{
+	/* V2 protocol doesn't have this feature. */
+	return 0;
+}
+
+static void calculate_fixed_part(struct snd_motu_packet_format *formats,
+				 enum amdtp_stream_direction dir,
+				 enum snd_motu_spec_flags flags,
+				 unsigned char analog_ports)
+{
+	unsigned char pcm_chunks[3] = {0, 0, 0};
+
+	formats->msg_chunks = 2;
+
+	pcm_chunks[0] = analog_ports;
+	pcm_chunks[1] = analog_ports;
+	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
+		pcm_chunks[2] = analog_ports;
+
+	if (dir == AMDTP_IN_STREAM) {
+		if (flags & SND_MOTU_SPEC_TX_MICINST_CHUNK) {
+			pcm_chunks[0] += 2;
+			pcm_chunks[1] += 2;
+		}
+		if (flags & SND_MOTU_SPEC_TX_RETURN_CHUNK) {
+			pcm_chunks[0] += 2;
+			pcm_chunks[1] += 2;
+		}
+	} else {
+		/*
+		 * Packets to v2 units transfer main-out-1/2 and phone-out-1/2.
+		 */
+		pcm_chunks[0] += 4;
+		pcm_chunks[1] += 4;
+	}
+
+	/*
+	 * All of v2 models have a pair of coaxial interfaces for digital in/out
+	 * port. At 44.1/48.0/88.2/96.0 kHz, packets includes PCM from these
+	 * ports.
+	 */
+	pcm_chunks[0] += 2;
+	pcm_chunks[1] += 2;
+
+	/* This part should be multiples of 4. */
+	formats->fixed_part_pcm_chunks[0] = round_up(2 + pcm_chunks[0], 4) - 2;
+	formats->fixed_part_pcm_chunks[1] = round_up(2 + pcm_chunks[1], 4) - 2;
+	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
+		formats->fixed_part_pcm_chunks[2] =
+					round_up(2 + pcm_chunks[2], 4) - 2;
+}
+
+static void calculate_differed_part(struct snd_motu_packet_format *formats,
+				    enum snd_motu_spec_flags flags,
+				    u32 data, u32 mask, u32 shift)
+{
+	unsigned char pcm_chunks[3] = {0, 0};
+
+	/*
+	 * When optical interfaces are configured for S/PDIF (TOSLINK),
+	 * the above PCM frames come from them, instead of coaxial
+	 * interfaces.
+	 */
+	data = (data & mask) >> shift;
+	if ((flags & SND_MOTU_SPEC_HAS_OPT_IFACE_A) &&
+	    data == V2_OPT_IFACE_MODE_ADAT) {
+		pcm_chunks[0] += 8;
+		pcm_chunks[1] += 4;
+	}
+
+	/* At mode x4, no data chunks are supported in this part. */
+	formats->differed_part_pcm_chunks[0] = pcm_chunks[0];
+	formats->differed_part_pcm_chunks[1] = pcm_chunks[1];
+}
+
+static int v2_cache_packet_formats(struct snd_motu *motu)
+{
+	__be32 reg;
+	u32 data;
+	int err;
+
+	err = snd_motu_transaction_read(motu, V2_IN_OUT_CONF_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+	data = be32_to_cpu(reg);
+
+	calculate_fixed_part(&motu->tx_packet_formats, AMDTP_IN_STREAM,
+			     motu->spec->flags, motu->spec->analog_in_ports);
+	calculate_differed_part(&motu->tx_packet_formats, motu->spec->flags,
+			data, V2_OPT_IN_IFACE_MASK, V2_OPT_IN_IFACE_SHIFT);
+
+	calculate_fixed_part(&motu->rx_packet_formats, AMDTP_OUT_STREAM,
+			     motu->spec->flags, motu->spec->analog_out_ports);
+	calculate_differed_part(&motu->rx_packet_formats, motu->spec->flags,
+			data, V2_OPT_OUT_IFACE_MASK, V2_OPT_OUT_IFACE_SHIFT);
+
+	motu->tx_packet_formats.midi_flag_offset = 4;
+	motu->tx_packet_formats.midi_byte_offset = 6;
+	motu->tx_packet_formats.pcm_byte_offset = 10;
+
+	motu->rx_packet_formats.midi_flag_offset = 4;
+	motu->rx_packet_formats.midi_byte_offset = 6;
+	motu->rx_packet_formats.pcm_byte_offset = 10;
+
+	return 0;
+}
+
+const struct snd_motu_protocol snd_motu_protocol_v2 = {
+	.get_clock_rate		= v2_get_clock_rate,
+	.set_clock_rate		= v2_set_clock_rate,
+	.get_clock_source	= v2_get_clock_source,
+	.switch_fetching_mode	= v2_switch_fetching_mode,
+	.cache_packet_formats	= v2_cache_packet_formats,
+};
