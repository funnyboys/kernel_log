commit e0b2db351bc708037571deb3fc82c7d9043b4ea8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat May 23 16:17:33 2020 +0900

    ALSA: firewire-motu: add support for MOTU UltraLite-mk3 (FireWire only model)
    
    UltraLite-mk3 was shipped 2008 by MOTU. This model has two lineups;
    FireWire-only and FireWire/USB2.0 Hybrid model. Additionally, the latter
    has two variants in respect of the type of IEEE 1394 connector; alpha
    and beta connector.
    
    This commit adds support for the FireWire-only model, which is already
    discontinued.
    
    $ python3 crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  0410353a  bus_info_length 4, crc_length 16, crc 13626
    404  31333934  bus_name "1394"
    408  20ff7000  irmc 0, cmc 0, isc 1, bmc 0, cyc_clk_acc 255, max_rec 7 (256)
    40c  0001f200  company_id 0001f2     |
    410  000902c7  device_id 00000902c7  | EUI-64 0001f200000902c7
    
                   root directory
                   -----------------------------------------------------------------
    414  0004ef04  directory_length 4, crc 61188
    418  030001f2  vendor
    41c  0c0083c0  node capabilities per IEEE 1394
    420  d1000002  --> unit directory at 428
    424  8d000005  --> eui-64 leaf at 438
    
                   unit directory at 428
                   -----------------------------------------------------------------
    428  00035556  directory_length 3, crc 21846
    42c  120001f2  specifier id
    430  13000019  version
    434  17100800  model
    
                   eui-64 leaf at 438
                   -----------------------------------------------------------------
    438  0002f3c5  leaf_length 2, crc 62405
    43c  0001f200  company_id 0001f2     |
    440  000902c7  device_id 00000902c7  | EUI-64 0001f200000902c7
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200523071733.170129-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index fd49d1fcf473..01a47ac7bb2d 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -290,6 +290,15 @@ const struct snd_motu_spec snd_motu_spec_828mk3 = {
 	.rx_fixed_pcm_chunks = {14, 14, 10},
 };
 
+const struct snd_motu_spec snd_motu_spec_ultralite_mk3 = {
+	.name = "UltraLiteMk3",
+	.protocol_version = SND_MOTU_PROTOCOL_V3,
+	.flags = SND_MOTU_SPEC_RX_MIDI_3RD_Q |
+		 SND_MOTU_SPEC_TX_MIDI_3RD_Q,
+	.tx_fixed_pcm_chunks = {18, 14, 10},
+	.rx_fixed_pcm_chunks = {14, 14, 14},
+};
+
 const struct snd_motu_spec snd_motu_spec_audio_express = {
 	.name = "AudioExpress",
 	.protocol_version = SND_MOTU_PROTOCOL_V3,

commit 7b47c0d719f47e990a4130534182058780f7322a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:40 2020 +0900

    ALSA: firewire-motu: refactoring protocol v3 for clock source getter
    
    This commit splits the method to get clock source for protocol
    version 3 so that model-dependent operations are explicitly defined.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-14-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index cc100d7be0bf..fd49d1fcf473 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -87,54 +87,100 @@ int snd_motu_protocol_v3_set_clock_rate(struct snd_motu *motu,
 	return 0;
 }
 
-int snd_motu_protocol_v3_get_clock_source(struct snd_motu *motu,
-					  enum snd_motu_clock_source *src)
+static int detect_clock_source_828mk3(struct snd_motu *motu, u32 data,
+				      enum snd_motu_clock_source *src)
 {
-	__be32 reg;
-	u32 data;
-	unsigned int val;
-	int err;
-
-	err = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,
-					sizeof(reg));
-	if (err < 0)
-		return err;
-	data = be32_to_cpu(reg);
-
-	val = data & V3_CLOCK_SOURCE_MASK;
-	if (val == 0x00) {
+	switch (data) {
+	case 0x00:
 		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
-	} else if (val == 0x01) {
+		break;
+	case 0x01:
 		*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;
-	} else if (val == 0x02) {
+		break;
+	case 0x02:
 		*src = SND_MOTU_CLOCK_SOURCE_SPH;
-	} else if (val == 0x10) {
+		break;
+	case 0x10:
 		*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;
-	} else if (val == 0x18 || val == 0x19) {
-		err = snd_motu_transaction_read(motu, V3_OPT_IFACE_MODE_OFFSET,
-						&reg, sizeof(reg));
+		break;
+	case 0x18:
+	case 0x19:
+	{
+		__be32 reg;
+		u32 options;
+		int err;
+
+		err = snd_motu_transaction_read(motu,
+				V3_OPT_IFACE_MODE_OFFSET, &reg, sizeof(reg));
 		if (err < 0)
 			return err;
-		data = be32_to_cpu(reg);
+		options = be32_to_cpu(reg);
 
-		if (val == 0x18) {
-			if (data & V3_NO_ADAT_OPT_IN_IFACE_A)
+		if (data == 0x18) {
+			if (options & V3_NO_ADAT_OPT_IN_IFACE_A)
 				*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_OPT_A;
 			else
 				*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_OPT_A;
 		} else {
-			if (data & V3_NO_ADAT_OPT_IN_IFACE_B)
+			if (options & V3_NO_ADAT_OPT_IN_IFACE_B)
 				*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_OPT_B;
 			else
 				*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_OPT_B;
 		}
-	} else {
+
+		break;
+	}
+	default:
 		*src = SND_MOTU_CLOCK_SOURCE_UNKNOWN;
+		break;
 	}
 
 	return 0;
 }
 
+static int v3_detect_clock_source(struct snd_motu *motu, u32 data,
+				  enum snd_motu_clock_source *src)
+{
+	switch (data) {
+	case 0x00:
+		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
+		break;
+	case 0x01:
+		*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;
+		break;
+	case 0x02:
+		*src = SND_MOTU_CLOCK_SOURCE_SPH;
+		break;
+	case 0x10:
+		*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;
+		break;
+	default:
+		*src = SND_MOTU_CLOCK_SOURCE_UNKNOWN;
+		break;
+	}
+
+	return 0;
+}
+
+int snd_motu_protocol_v3_get_clock_source(struct snd_motu *motu,
+					  enum snd_motu_clock_source *src)
+{
+	__be32 reg;
+	u32 data;
+	int err;
+
+	err = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+	data = be32_to_cpu(reg) & V3_CLOCK_SOURCE_MASK;
+
+	if (motu->spec == &snd_motu_spec_828mk3)
+		return detect_clock_source_828mk3(motu, data, src);
+	else
+		return v3_detect_clock_source(motu, data, src);
+}
+
 int snd_motu_protocol_v3_switch_fetching_mode(struct snd_motu *motu,
 					      bool enable)
 {

commit 739bdbaec76ae7e6e2de80c06e1d4ca31e7c96b9
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:38 2020 +0900

    ALSA: firewire-motu: remove obsoleted codes
    
    The way to decide CIP payload size by calculation with any flag is now
    obsoleted. This commit removes the codes.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-12-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index 903a7eb209f9..cc100d7be0bf 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -158,124 +158,6 @@ int snd_motu_protocol_v3_switch_fetching_mode(struct snd_motu *motu,
 					  sizeof(reg));
 }
 
-static void calculate_fixed_part(struct snd_motu_packet_format *formats,
-				 enum amdtp_stream_direction dir,
-				 enum snd_motu_spec_flags flags,
-				 unsigned char analog_ports)
-{
-	unsigned char pcm_chunks[3] = {0, 0, 0};
-
-	pcm_chunks[0] = analog_ports;
-	pcm_chunks[1] = analog_ports;
-	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
-		pcm_chunks[2] = analog_ports;
-
-	if (dir == AMDTP_IN_STREAM) {
-		if (flags & SND_MOTU_SPEC_TX_MICINST_CHUNK) {
-			pcm_chunks[0] += 2;
-			pcm_chunks[1] += 2;
-			if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
-				pcm_chunks[2] += 2;
-		}
-
-		if (flags & SND_MOTU_SPEC_TX_RETURN_CHUNK) {
-			pcm_chunks[0] += 2;
-			pcm_chunks[1] += 2;
-			if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
-				pcm_chunks[2] += 2;
-		}
-
-		if (flags & SND_MOTU_SPEC_TX_REVERB_CHUNK) {
-			pcm_chunks[0] += 2;
-			pcm_chunks[1] += 2;
-		}
-	} else {
-		if (flags & SND_MOTU_SPEC_RX_SEPARATED_MAIN) {
-			pcm_chunks[0] += 2;
-			pcm_chunks[1] += 2;
-		}
-
-		// Packets to v3 units include 2 chunks for phone 1/2, except
-		// for 176.4/192.0 kHz.
-		pcm_chunks[0] += 2;
-		pcm_chunks[1] += 2;
-	}
-
-	if (flags & SND_MOTU_SPEC_HAS_AESEBU_IFACE) {
-		pcm_chunks[0] += 2;
-		pcm_chunks[1] += 2;
-	}
-
-	/*
-	 * At least, packets have two data chunks for S/PDIF on coaxial
-	 * interface.
-	 */
-	pcm_chunks[0] += 2;
-	pcm_chunks[1] += 2;
-
-	/*
-	 * Fixed part consists of PCM chunks multiple of 4, with msg chunks. As
-	 * a result, this part can includes empty data chunks.
-	 */
-	formats->fixed_part_pcm_chunks[0] = round_up(2 + pcm_chunks[0], 4) - 2;
-	formats->fixed_part_pcm_chunks[1] = round_up(2 + pcm_chunks[1], 4) - 2;
-	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
-		formats->fixed_part_pcm_chunks[2] =
-					round_up(2 + pcm_chunks[2], 4) - 2;
-}
-
-static void calculate_differed_part(struct snd_motu_packet_format *formats,
-				    enum snd_motu_spec_flags flags, u32 data,
-				    u32 a_enable_mask, u32 a_no_adat_mask,
-				    u32 b_enable_mask, u32 b_no_adat_mask)
-{
-	unsigned char pcm_chunks[3] = {0, 0, 0};
-	int i;
-
-	if ((flags & SND_MOTU_SPEC_HAS_OPT_IFACE_A) && (data & a_enable_mask)) {
-		if (data & a_no_adat_mask) {
-			/*
-			 * Additional two data chunks for S/PDIF on optical
-			 * interface A. This includes empty data chunks.
-			 */
-			pcm_chunks[0] += 4;
-			pcm_chunks[1] += 4;
-		} else {
-			/*
-			 * Additional data chunks for ADAT on optical interface
-			 * A.
-			 */
-			pcm_chunks[0] += 8;
-			pcm_chunks[1] += 4;
-		}
-	}
-
-	if ((flags & SND_MOTU_SPEC_HAS_OPT_IFACE_B) && (data & b_enable_mask)) {
-		if (data & b_no_adat_mask) {
-			/*
-			 * Additional two data chunks for S/PDIF on optical
-			 * interface B. This includes empty data chunks.
-			 */
-			pcm_chunks[0] += 4;
-			pcm_chunks[1] += 4;
-		} else {
-			/*
-			 * Additional data chunks for ADAT on optical interface
-			 * B.
-			 */
-			pcm_chunks[0] += 8;
-			pcm_chunks[1] += 4;
-		}
-	}
-
-	for (i = 0; i < 3; ++i) {
-		if (pcm_chunks[i] > 0)
-			pcm_chunks[i] = round_up(pcm_chunks[i], 4);
-
-		formats->differed_part_pcm_chunks[i] = pcm_chunks[i];
-	}
-}
-
 static int detect_packet_formats_828mk3(struct snd_motu *motu, u32 data)
 {
 	if (data & V3_ENABLE_OPT_IN_IFACE_A) {
@@ -339,20 +221,6 @@ int snd_motu_protocol_v3_cache_packet_formats(struct snd_motu *motu)
 		return err;
 	data = be32_to_cpu(reg);
 
-	calculate_fixed_part(&motu->tx_packet_formats, AMDTP_IN_STREAM,
-			     motu->spec->flags, motu->spec->analog_in_ports);
-	calculate_differed_part(&motu->tx_packet_formats,
-			motu->spec->flags, data,
-			V3_ENABLE_OPT_IN_IFACE_A, V3_NO_ADAT_OPT_IN_IFACE_A,
-			V3_ENABLE_OPT_IN_IFACE_B, V3_NO_ADAT_OPT_IN_IFACE_B);
-
-	calculate_fixed_part(&motu->rx_packet_formats, AMDTP_OUT_STREAM,
-			     motu->spec->flags, motu->spec->analog_out_ports);
-	calculate_differed_part(&motu->rx_packet_formats,
-			motu->spec->flags, data,
-			V3_ENABLE_OPT_OUT_IFACE_A, V3_NO_ADAT_OPT_OUT_IFACE_A,
-			V3_ENABLE_OPT_OUT_IFACE_B, V3_NO_ADAT_OPT_OUT_IFACE_B);
-
 	memcpy(motu->tx_packet_formats.pcm_chunks,
 	       motu->spec->tx_fixed_pcm_chunks,
 	       sizeof(motu->tx_packet_formats.pcm_chunks));
@@ -370,46 +238,24 @@ int snd_motu_protocol_v3_cache_packet_formats(struct snd_motu *motu)
 const struct snd_motu_spec snd_motu_spec_828mk3 = {
 	.name = "828mk3",
 	.protocol_version = SND_MOTU_PROTOCOL_V3,
-	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
-		 SND_MOTU_SPEC_SUPPORT_CLOCK_X4 |
-		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
-		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
-		 SND_MOTU_SPEC_TX_REVERB_CHUNK |
-		 SND_MOTU_SPEC_RX_SEPARATED_MAIN |
-		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
-		 SND_MOTU_SPEC_HAS_OPT_IFACE_B |
-		 SND_MOTU_SPEC_RX_MIDI_3RD_Q |
+	.flags = SND_MOTU_SPEC_RX_MIDI_3RD_Q |
 		 SND_MOTU_SPEC_TX_MIDI_3RD_Q,
 	.tx_fixed_pcm_chunks = {18, 18, 14},
 	.rx_fixed_pcm_chunks = {14, 14, 10},
-	.analog_in_ports = 8,
-	.analog_out_ports = 8,
 };
 
 const struct snd_motu_spec snd_motu_spec_audio_express = {
 	.name = "AudioExpress",
 	.protocol_version = SND_MOTU_PROTOCOL_V3,
-	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
-		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
-		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
-		 SND_MOTU_SPEC_RX_SEPARATED_MAIN |
-		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+	.flags = SND_MOTU_SPEC_RX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_TX_MIDI_3RD_Q,
 	.tx_fixed_pcm_chunks = {10, 10, 0},
 	.rx_fixed_pcm_chunks = {10, 10, 0},
-	.analog_in_ports = 2,
-	.analog_out_ports = 4,
 };
 
 const struct snd_motu_spec snd_motu_spec_4pre = {
 	.name = "4pre",
 	.protocol_version = SND_MOTU_PROTOCOL_V3,
-	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
-		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
-		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
-		 SND_MOTU_SPEC_RX_SEPARATED_MAIN,
 	.tx_fixed_pcm_chunks = {10, 10, 0},
 	.rx_fixed_pcm_chunks = {10, 10, 0},
-	.analog_in_ports = 2,
-	.analog_out_ports = 2,
 };

commit 0090c1c5f327da077f371f5f8675a576bca6ebf9
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:35 2020 +0900

    ALSA: firewire-motu: add alternative functions to detect packet format for protocol v3
    
    This commit adds alternative functions to detect packet format so that
    each function corresponds to each model.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-9-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index 370d22da276e..903a7eb209f9 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -165,8 +165,6 @@ static void calculate_fixed_part(struct snd_motu_packet_format *formats,
 {
 	unsigned char pcm_chunks[3] = {0, 0, 0};
 
-	formats->msg_chunks = 2;
-
 	pcm_chunks[0] = analog_ports;
 	pcm_chunks[1] = analog_ports;
 	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
@@ -278,12 +276,63 @@ static void calculate_differed_part(struct snd_motu_packet_format *formats,
 	}
 }
 
+static int detect_packet_formats_828mk3(struct snd_motu *motu, u32 data)
+{
+	if (data & V3_ENABLE_OPT_IN_IFACE_A) {
+		if (data & V3_NO_ADAT_OPT_IN_IFACE_A) {
+			motu->tx_packet_formats.pcm_chunks[0] += 4;
+			motu->tx_packet_formats.pcm_chunks[1] += 4;
+		} else {
+			motu->tx_packet_formats.pcm_chunks[0] += 8;
+			motu->tx_packet_formats.pcm_chunks[1] += 4;
+		}
+	}
+
+	if (data & V3_ENABLE_OPT_IN_IFACE_B) {
+		if (data & V3_NO_ADAT_OPT_IN_IFACE_B) {
+			motu->tx_packet_formats.pcm_chunks[0] += 4;
+			motu->tx_packet_formats.pcm_chunks[1] += 4;
+		} else {
+			motu->tx_packet_formats.pcm_chunks[0] += 8;
+			motu->tx_packet_formats.pcm_chunks[1] += 4;
+		}
+	}
+
+	if (data & V3_ENABLE_OPT_OUT_IFACE_A) {
+		if (data & V3_NO_ADAT_OPT_OUT_IFACE_A) {
+			motu->rx_packet_formats.pcm_chunks[0] += 4;
+			motu->rx_packet_formats.pcm_chunks[1] += 4;
+		} else {
+			motu->rx_packet_formats.pcm_chunks[0] += 8;
+			motu->rx_packet_formats.pcm_chunks[1] += 4;
+		}
+	}
+
+	if (data & V3_ENABLE_OPT_OUT_IFACE_B) {
+		if (data & V3_NO_ADAT_OPT_OUT_IFACE_B) {
+			motu->rx_packet_formats.pcm_chunks[0] += 4;
+			motu->rx_packet_formats.pcm_chunks[1] += 4;
+		} else {
+			motu->rx_packet_formats.pcm_chunks[0] += 8;
+			motu->rx_packet_formats.pcm_chunks[1] += 4;
+		}
+	}
+
+	return 0;
+}
+
 int snd_motu_protocol_v3_cache_packet_formats(struct snd_motu *motu)
 {
 	__be32 reg;
 	u32 data;
 	int err;
 
+	motu->tx_packet_formats.pcm_byte_offset = 10;
+	motu->rx_packet_formats.pcm_byte_offset = 10;
+
+	motu->tx_packet_formats.msg_chunks = 2;
+	motu->rx_packet_formats.msg_chunks = 2;
+
 	err = snd_motu_transaction_read(motu, V3_OPT_IFACE_MODE_OFFSET, &reg,
 					sizeof(reg));
 	if (err < 0)
@@ -304,10 +353,17 @@ int snd_motu_protocol_v3_cache_packet_formats(struct snd_motu *motu)
 			V3_ENABLE_OPT_OUT_IFACE_A, V3_NO_ADAT_OPT_OUT_IFACE_A,
 			V3_ENABLE_OPT_OUT_IFACE_B, V3_NO_ADAT_OPT_OUT_IFACE_B);
 
-	motu->tx_packet_formats.pcm_byte_offset = 10;
-	motu->rx_packet_formats.pcm_byte_offset = 10;
+	memcpy(motu->tx_packet_formats.pcm_chunks,
+	       motu->spec->tx_fixed_pcm_chunks,
+	       sizeof(motu->tx_packet_formats.pcm_chunks));
+	memcpy(motu->rx_packet_formats.pcm_chunks,
+	       motu->spec->rx_fixed_pcm_chunks,
+	       sizeof(motu->rx_packet_formats.pcm_chunks));
 
-	return 0;
+	if (motu->spec == &snd_motu_spec_828mk3)
+		return detect_packet_formats_828mk3(motu, data);
+	else
+		return 0;
 }
 
 

commit dfbaa4dc11eb93e3662dcefbf00a14235c4c1e8e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:33 2020 +0900

    ALSA: firewire-motu: add model-specific table of chunk count
    
    In MOTU protocol, data block consists of SPH and 24-bit chunks
    aligned to quadlet. The number of chunks per data block is specific
    to model. For models with optical interface, the number differs
    depending on I/O settings for the interface (ADAT, TOSLINK).
    
    Currently the number is calculated from flags in model-specific
    data. However this is weak in the case that the model has quirks.
    Actually, for quirks of some models, flags are used against their
    original meanings.
    
    This commit adds model-specific table of chunk count. For future
    integration, this table is based on the calculation.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-7-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index 8192bcdd1b37..370d22da276e 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -324,7 +324,8 @@ const struct snd_motu_spec snd_motu_spec_828mk3 = {
 		 SND_MOTU_SPEC_HAS_OPT_IFACE_B |
 		 SND_MOTU_SPEC_RX_MIDI_3RD_Q |
 		 SND_MOTU_SPEC_TX_MIDI_3RD_Q,
-
+	.tx_fixed_pcm_chunks = {18, 18, 14},
+	.rx_fixed_pcm_chunks = {14, 14, 10},
 	.analog_in_ports = 8,
 	.analog_out_ports = 8,
 };
@@ -338,6 +339,8 @@ const struct snd_motu_spec snd_motu_spec_audio_express = {
 		 SND_MOTU_SPEC_RX_SEPARATED_MAIN |
 		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
 		 SND_MOTU_SPEC_TX_MIDI_3RD_Q,
+	.tx_fixed_pcm_chunks = {10, 10, 0},
+	.rx_fixed_pcm_chunks = {10, 10, 0},
 	.analog_in_ports = 2,
 	.analog_out_ports = 4,
 };
@@ -349,6 +352,8 @@ const struct snd_motu_spec snd_motu_spec_4pre = {
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
 		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
 		 SND_MOTU_SPEC_RX_SEPARATED_MAIN,
+	.tx_fixed_pcm_chunks = {10, 10, 0},
+	.rx_fixed_pcm_chunks = {10, 10, 0},
 	.analog_in_ports = 2,
 	.analog_out_ports = 2,
 };

commit 562f0c6700cfeb28b7a95d4b7cb6b0496d0b2fb5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:32 2020 +0900

    ALSA: firewire-motu: drop protocol structure
    
    Now protocol structure becomes useless. This commit drops it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-6-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index d8b42d28304a..8192bcdd1b37 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -310,13 +310,10 @@ int snd_motu_protocol_v3_cache_packet_formats(struct snd_motu *motu)
 	return 0;
 }
 
-static const struct snd_motu_protocol snd_motu_protocol_v3 = {
-};
 
 const struct snd_motu_spec snd_motu_spec_828mk3 = {
 	.name = "828mk3",
 	.protocol_version = SND_MOTU_PROTOCOL_V3,
-	.protocol = &snd_motu_protocol_v3,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_SUPPORT_CLOCK_X4 |
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
@@ -335,7 +332,6 @@ const struct snd_motu_spec snd_motu_spec_828mk3 = {
 const struct snd_motu_spec snd_motu_spec_audio_express = {
 	.name = "AudioExpress",
 	.protocol_version = SND_MOTU_PROTOCOL_V3,
-	.protocol = &snd_motu_protocol_v3,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
 		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
@@ -349,7 +345,6 @@ const struct snd_motu_spec snd_motu_spec_audio_express = {
 const struct snd_motu_spec snd_motu_spec_4pre = {
 	.name = "4pre",
 	.protocol_version = SND_MOTU_PROTOCOL_V3,
-	.protocol = &snd_motu_protocol_v3,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
 		 SND_MOTU_SPEC_TX_RETURN_CHUNK |

commit ff222b7e45eb1ffb2931269abf66b9d3576c9eeb
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:31 2020 +0900

    ALSA: firewire-motu: add wrapper functions for protocol-dependent operations
    
    This commit adds helper functions which wraps function call for each
    protocol.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-5-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index 548c97752cb8..d8b42d28304a 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -24,7 +24,8 @@
 #define  V3_NO_ADAT_OPT_OUT_IFACE_A	0x00040000
 #define  V3_NO_ADAT_OPT_OUT_IFACE_B	0x00400000
 
-static int v3_get_clock_rate(struct snd_motu *motu, unsigned int *rate)
+int snd_motu_protocol_v3_get_clock_rate(struct snd_motu *motu,
+					unsigned int *rate)
 {
 	__be32 reg;
 	u32 data;
@@ -45,7 +46,8 @@ static int v3_get_clock_rate(struct snd_motu *motu, unsigned int *rate)
 	return 0;
 }
 
-static int v3_set_clock_rate(struct snd_motu *motu, unsigned int rate)
+int snd_motu_protocol_v3_set_clock_rate(struct snd_motu *motu,
+					unsigned int rate)
 {
 	__be32 reg;
 	u32 data;
@@ -85,8 +87,8 @@ static int v3_set_clock_rate(struct snd_motu *motu, unsigned int rate)
 	return 0;
 }
 
-static int v3_get_clock_source(struct snd_motu *motu,
-			       enum snd_motu_clock_source *src)
+int snd_motu_protocol_v3_get_clock_source(struct snd_motu *motu,
+					  enum snd_motu_clock_source *src)
 {
 	__be32 reg;
 	u32 data;
@@ -133,7 +135,8 @@ static int v3_get_clock_source(struct snd_motu *motu,
 	return 0;
 }
 
-static int v3_switch_fetching_mode(struct snd_motu *motu, bool enable)
+int snd_motu_protocol_v3_switch_fetching_mode(struct snd_motu *motu,
+					      bool enable)
 {
 	__be32 reg;
 	u32 data;
@@ -275,7 +278,7 @@ static void calculate_differed_part(struct snd_motu_packet_format *formats,
 	}
 }
 
-static int v3_cache_packet_formats(struct snd_motu *motu)
+int snd_motu_protocol_v3_cache_packet_formats(struct snd_motu *motu)
 {
 	__be32 reg;
 	u32 data;
@@ -308,11 +311,6 @@ static int v3_cache_packet_formats(struct snd_motu *motu)
 }
 
 static const struct snd_motu_protocol snd_motu_protocol_v3 = {
-	.get_clock_rate		= v3_get_clock_rate,
-	.set_clock_rate		= v3_set_clock_rate,
-	.get_clock_source	= v3_get_clock_source,
-	.switch_fetching_mode	= v3_switch_fetching_mode,
-	.cache_packet_formats	= v3_cache_packet_formats,
 };
 
 const struct snd_motu_spec snd_motu_spec_828mk3 = {

commit 61d79c70c976a14cb321e537c39d147f7069e86a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:30 2020 +0900

    ALSA: firewire-motu: localize protocol data
    
    This commit adds enumerations of protocol version to localize protocol
    data.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index 947fab7905fe..548c97752cb8 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -307,7 +307,7 @@ static int v3_cache_packet_formats(struct snd_motu *motu)
 	return 0;
 }
 
-const struct snd_motu_protocol snd_motu_protocol_v3 = {
+static const struct snd_motu_protocol snd_motu_protocol_v3 = {
 	.get_clock_rate		= v3_get_clock_rate,
 	.set_clock_rate		= v3_set_clock_rate,
 	.get_clock_source	= v3_get_clock_source,
@@ -317,6 +317,7 @@ const struct snd_motu_protocol snd_motu_protocol_v3 = {
 
 const struct snd_motu_spec snd_motu_spec_828mk3 = {
 	.name = "828mk3",
+	.protocol_version = SND_MOTU_PROTOCOL_V3,
 	.protocol = &snd_motu_protocol_v3,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_SUPPORT_CLOCK_X4 |
@@ -335,6 +336,7 @@ const struct snd_motu_spec snd_motu_spec_828mk3 = {
 
 const struct snd_motu_spec snd_motu_spec_audio_express = {
 	.name = "AudioExpress",
+	.protocol_version = SND_MOTU_PROTOCOL_V3,
 	.protocol = &snd_motu_protocol_v3,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
@@ -348,6 +350,7 @@ const struct snd_motu_spec snd_motu_spec_audio_express = {
 
 const struct snd_motu_spec snd_motu_spec_4pre = {
 	.name = "4pre",
+	.protocol_version = SND_MOTU_PROTOCOL_V3,
 	.protocol = &snd_motu_protocol_v3,
 	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
 		 SND_MOTU_SPEC_TX_MICINST_CHUNK |

commit c806a0e228318dec8384d765462764443bdc4786
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:29 2020 +0900

    ALSA: firewire-motu: move spec data to v3 protocol file
    
    The most of members in spec data is used in each protocol file. It's
    better to capsulate the data to the file.
    
    This commit moves the data to the file for protocol version 3.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-3-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index d1545e2b5caa..947fab7905fe 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -314,3 +314,45 @@ const struct snd_motu_protocol snd_motu_protocol_v3 = {
 	.switch_fetching_mode	= v3_switch_fetching_mode,
 	.cache_packet_formats	= v3_cache_packet_formats,
 };
+
+const struct snd_motu_spec snd_motu_spec_828mk3 = {
+	.name = "828mk3",
+	.protocol = &snd_motu_protocol_v3,
+	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
+		 SND_MOTU_SPEC_SUPPORT_CLOCK_X4 |
+		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
+		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
+		 SND_MOTU_SPEC_TX_REVERB_CHUNK |
+		 SND_MOTU_SPEC_RX_SEPARATED_MAIN |
+		 SND_MOTU_SPEC_HAS_OPT_IFACE_A |
+		 SND_MOTU_SPEC_HAS_OPT_IFACE_B |
+		 SND_MOTU_SPEC_RX_MIDI_3RD_Q |
+		 SND_MOTU_SPEC_TX_MIDI_3RD_Q,
+
+	.analog_in_ports = 8,
+	.analog_out_ports = 8,
+};
+
+const struct snd_motu_spec snd_motu_spec_audio_express = {
+	.name = "AudioExpress",
+	.protocol = &snd_motu_protocol_v3,
+	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
+		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
+		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
+		 SND_MOTU_SPEC_RX_SEPARATED_MAIN |
+		 SND_MOTU_SPEC_RX_MIDI_2ND_Q |
+		 SND_MOTU_SPEC_TX_MIDI_3RD_Q,
+	.analog_in_ports = 2,
+	.analog_out_ports = 4,
+};
+
+const struct snd_motu_spec snd_motu_spec_4pre = {
+	.name = "4pre",
+	.protocol = &snd_motu_protocol_v3,
+	.flags = SND_MOTU_SPEC_SUPPORT_CLOCK_X2 |
+		 SND_MOTU_SPEC_TX_MICINST_CHUNK |
+		 SND_MOTU_SPEC_TX_RETURN_CHUNK |
+		 SND_MOTU_SPEC_RX_SEPARATED_MAIN,
+	.analog_in_ports = 2,
+	.analog_out_ports = 2,
+};

commit 3f58f004bff3273d102583e0b2f478526cf9d3c8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 30 17:06:41 2019 +0900

    ALSA: firewire-motu: detect SPH source of sampling clock
    
    In MOTU FireWire series, devices have a mode to generate sampling clock
    from a sequence of source packet header (SPH) included in each data block
    of received packet. This mode is used for several purposes such as mode
    for SMPTE time code, sync to the other sound cards and so on.
    
    This commit adds support for the SPH mode.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191030080644.1704-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index ba5794c724be..d1545e2b5caa 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -104,6 +104,8 @@ static int v3_get_clock_source(struct snd_motu *motu,
 		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
 	} else if (val == 0x01) {
 		*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;
+	} else if (val == 0x02) {
+		*src = SND_MOTU_CLOCK_SOURCE_SPH;
 	} else if (val == 0x10) {
 		*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;
 	} else if (val == 0x18 || val == 0x19) {

commit 2644df63c709e107c1882be95d802adea284dbf5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 30 17:06:39 2019 +0900

    ALSA: firewire-motu: fix wrong spelling for macro
    
    Just replace 'SEPARETED' with 'SEPARATED' for macro.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191030080644.1704-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index 5eafa506e8a9..ba5794c724be 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -187,7 +187,7 @@ static void calculate_fixed_part(struct snd_motu_packet_format *formats,
 			pcm_chunks[1] += 2;
 		}
 	} else {
-		if (flags & SND_MOTU_SPEC_RX_SEPARETED_MAIN) {
+		if (flags & SND_MOTU_SPEC_RX_SEPARATED_MAIN) {
 			pcm_chunks[0] += 2;
 			pcm_chunks[1] += 2;
 		}

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index 7cc80a05e91f..5eafa506e8a9 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * motu-protocol-v3.c - a part of driver for MOTU FireWire series
  *
  * Copyright (c) 2015-2017 Takashi Sakamoto <o-takashi@sakamocchi.jp>
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include <linux/delay.h>

commit 06ac0b6f8f74e98d32f9dea5209bd26f3e7b50ba
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 18 21:07:53 2018 +0900

    ALSA: firewire-motu: add a flag for AES/EBU on XLR interface
    
    MOTU Traveler supports AES/EBU on XLR interface and data block of rx/tx
    packet includes two chunk for the interface. This commit adds a flag
    for this purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index 293353991591..7cc80a05e91f 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -199,6 +199,11 @@ static void calculate_fixed_part(struct snd_motu_packet_format *formats,
 		pcm_chunks[1] += 2;
 	}
 
+	if (flags & SND_MOTU_SPEC_HAS_AESEBU_IFACE) {
+		pcm_chunks[0] += 2;
+		pcm_chunks[1] += 2;
+	}
+
 	/*
 	 * At least, packets have two data chunks for S/PDIF on coaxial
 	 * interface.

commit 81720c6d49b7932d642e7dca736bef9a40c9b5f7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 18 21:07:52 2018 +0900

    ALSA: firewire-motu: add a flag for chunks for main 1/2 out
    
    This driver explicitly assumes that all of supported models have main data
    chunk separated from chunk for analog ports. However, MOTU Traveler doesn't
    support the separated main data chunk.
    
    This commit adds a flag for the separated main data chunk.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index c7cd9864dc4d..293353991591 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -188,11 +188,15 @@ static void calculate_fixed_part(struct snd_motu_packet_format *formats,
 			pcm_chunks[1] += 2;
 		}
 	} else {
-		/*
-		 * Packets to v2 units transfer main-out-1/2 and phone-out-1/2.
-		 */
-		pcm_chunks[0] += 4;
-		pcm_chunks[1] += 4;
+		if (flags & SND_MOTU_SPEC_RX_SEPARETED_MAIN) {
+			pcm_chunks[0] += 2;
+			pcm_chunks[1] += 2;
+		}
+
+		// Packets to v3 units include 2 chunks for phone 1/2, except
+		// for 176.4/192.0 kHz.
+		pcm_chunks[0] += 2;
+		pcm_chunks[1] += 2;
 	}
 
 	/*

commit 8b460c76bd17128db90d69a3f8b4ad2ee744d118
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 20 21:25:03 2017 +0900

    ALSA: firewire-motu: add specification flag for position of flag for MIDI messages
    
    In protocols of MOTU FireWire series, when transferring MIDI messages,
    transmitter set existence flag to one byte on first several quadlets. The
    position differs depending on protocols and models, however two cases are
    confirmed; in 5th byte and 8th byte from MSB side.
    
    This commit adds a series of specification flag to describe them. When
    the existence flag is in the 5th byte, SND_MOTU_SPEC_[R|T]X_MIDI_2ND_Q is
    used. Else, another set of the flag is used. Here, '_Q' means quadlet.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index ddb647254ed2..c7cd9864dc4d 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -291,12 +291,7 @@ static int v3_cache_packet_formats(struct snd_motu *motu)
 			V3_ENABLE_OPT_OUT_IFACE_A, V3_NO_ADAT_OPT_OUT_IFACE_A,
 			V3_ENABLE_OPT_OUT_IFACE_B, V3_NO_ADAT_OPT_OUT_IFACE_B);
 
-	motu->tx_packet_formats.midi_flag_offset = 8;
-	motu->tx_packet_formats.midi_byte_offset = 7;
 	motu->tx_packet_formats.pcm_byte_offset = 10;
-
-	motu->rx_packet_formats.midi_flag_offset = 8;
-	motu->rx_packet_formats.midi_byte_offset = 7;
 	motu->rx_packet_formats.pcm_byte_offset = 10;
 
 	return 0;

commit 5b33504bada4d85092b69b3aaa7048c398b21dbb
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Apr 3 21:13:50 2017 +0900

    ALSA: firewire-motu: remove invalid bitshift for register value
    
    In protocol version 3, drivers can read current sampling clock status from
    register 0x'ffff'f000'0b14. 8 bits of LSB of this register represents type
    of signal as source of clock.
    
    Current driver code includes invalid bitshift to handle the parameter. This
    commit fixes the bug.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Fixes: 5992e30034c4 ("ALSA: firewire-motu: add support for MOTU 828mk3 (FireWire/Hybrid) as a model with protocol version 3")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
index b463da99feb1..ddb647254ed2 100644
--- a/sound/firewire/motu/motu-protocol-v3.c
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -14,7 +14,6 @@
 #define  V3_CLOCK_RATE_MASK		0x0000ff00
 #define  V3_CLOCK_RATE_SHIFT		8
 #define  V3_CLOCK_SOURCE_MASK		0x000000ff
-#define  V3_CLOCK_SOURCE_SHIFT		8
 
 #define V3_OPT_IFACE_MODE_OFFSET	0x0c94
 #define  V3_ENABLE_OPT_IN_IFACE_A	0x00000001
@@ -101,7 +100,7 @@ static int v3_get_clock_source(struct snd_motu *motu,
 		return err;
 	data = be32_to_cpu(reg);
 
-	val = (data & V3_CLOCK_SOURCE_MASK) >> V3_CLOCK_SOURCE_SHIFT;
+	val = data & V3_CLOCK_SOURCE_MASK;
 	if (val == 0x00) {
 		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
 	} else if (val == 0x01) {

commit 5992e30034c43917968f2327d2948d22be6d4603
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:28 2017 +0900

    ALSA: firewire-motu: add support for MOTU 828mk3 (FireWire/Hybrid) as a model with protocol version 3
    
    MOTU 828mk3 (FireWire/Hybrid) is one of third generation in MOTU FireWire
    series, produced in 2008/2014. This model consists of three chips for
    functionality on IEEE 1394 bus:
    
     * TI TSB41AB2 (Physical layer for IEEE 1394 bus)
     * Xilinx Spartan-3E FPGA Family (Link layer for IEEE 1394 bus, packet
       processing and data block processing layer)
     * TI TMS320C6722 (Digital signal processing)
    
    This commit adds a support for this model, with its unique protocol as
    version 3. This protocol has some additional features to protocol
    version 2.
    
     * Support several optical interfaces.
     * Support a data chunk for return of reverb effect.
     * Have a quirk of tx packets.
     * Support heartbeat asynchronous transaction.
    
    In this protocol, series of transferred packets has some quirks. Below
    fields in CIP headers of the packets are out of IEC 61883-1:
     - SID (source node id): always 0x0d
     - DBS (data block size): always 0x04
     - DBC (data block counter): always 0x00
     - EOH (End of header): always 0x00
    
    Below is an actual sample of transferred packets.
    
    quads CIP1       CIP2
    520   0x0D040400 0x22FFFFFF
      8   0x0D040400 0x22FFFFFF
    520   0x0D040400 0x22FFFFFF
    520   0x0D040400 0x22FFFFFF
      8   0x0D040400 0x22FFFFFF
    
    Status of clock is configured by write transactions to 0x'ffff'f000'0b14,
    as well as version 2, while meanings of fields are different from the
    former protocols. Modes of optical interfaces are configured by write
    transactions to 0x'ffff'f000'0c94.
    
    Drivers can register its address to receive heatbeat transactions from the
    unit. 0x'ffff'f000'0b0c is for the higher part and 0x'ffff'f000'0b10 is
    for the lower part. Nevertheless, this feature is not useless for this
    driver and this commit omits it.
    
    Each data block consists of two parts in a point of the number of included
    data chunks. In both of 'fixed' and 'differed' parts, the number of
    included data blocks are a multiple of 4, thus depending on models there's
    some empty data chunks. For example, 828mk3 includes one pair of empty
    data chunks in its fixed part. When optical interface is configured to
    S/PDIF, 828mk3 includes one pair of empty data chunks in its differed part.
    To reduce consumption of CPU cycles with additional conditions/loops, this
    commit just exposes these empty chunks to user space as PCM channels.
    
    Additionally, 828mk3 has a non-negligible overhead to change its sampling
    transfer frequency. When softwares send asynchronous transaction to
    perform it, LED on the unit starts to blink. In a worst case, it continues
    blink during several seconds; e.g. 10 seconds. When stopping blinking,
    the unit seems to be prepared for the requested sampling transfer
    frequency. To wait for the preparation, this commit forces the driver
    to call task scheduler and applications sleeps for 4 seconds.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-protocol-v3.c b/sound/firewire/motu/motu-protocol-v3.c
new file mode 100644
index 000000000000..b463da99feb1
--- /dev/null
+++ b/sound/firewire/motu/motu-protocol-v3.c
@@ -0,0 +1,312 @@
+/*
+ * motu-protocol-v3.c - a part of driver for MOTU FireWire series
+ *
+ * Copyright (c) 2015-2017 Takashi Sakamoto <o-takashi@sakamocchi.jp>
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include <linux/delay.h>
+#include "motu.h"
+
+#define V3_CLOCK_STATUS_OFFSET		0x0b14
+#define  V3_FETCH_PCM_FRAMES		0x02000000
+#define  V3_CLOCK_RATE_MASK		0x0000ff00
+#define  V3_CLOCK_RATE_SHIFT		8
+#define  V3_CLOCK_SOURCE_MASK		0x000000ff
+#define  V3_CLOCK_SOURCE_SHIFT		8
+
+#define V3_OPT_IFACE_MODE_OFFSET	0x0c94
+#define  V3_ENABLE_OPT_IN_IFACE_A	0x00000001
+#define  V3_ENABLE_OPT_IN_IFACE_B	0x00000002
+#define  V3_ENABLE_OPT_OUT_IFACE_A	0x00000100
+#define  V3_ENABLE_OPT_OUT_IFACE_B	0x00000200
+#define  V3_NO_ADAT_OPT_IN_IFACE_A	0x00010000
+#define  V3_NO_ADAT_OPT_IN_IFACE_B	0x00100000
+#define  V3_NO_ADAT_OPT_OUT_IFACE_A	0x00040000
+#define  V3_NO_ADAT_OPT_OUT_IFACE_B	0x00400000
+
+static int v3_get_clock_rate(struct snd_motu *motu, unsigned int *rate)
+{
+	__be32 reg;
+	u32 data;
+	int err;
+
+	err = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+	data = be32_to_cpu(reg);
+
+	data = (data & V3_CLOCK_RATE_MASK) >> V3_CLOCK_RATE_SHIFT;
+	if (data >= ARRAY_SIZE(snd_motu_clock_rates))
+		return -EIO;
+
+	*rate = snd_motu_clock_rates[data];
+
+	return 0;
+}
+
+static int v3_set_clock_rate(struct snd_motu *motu, unsigned int rate)
+{
+	__be32 reg;
+	u32 data;
+	bool need_to_wait;
+	int i, err;
+
+	for (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {
+		if (snd_motu_clock_rates[i] == rate)
+			break;
+	}
+	if (i == ARRAY_SIZE(snd_motu_clock_rates))
+		return -EINVAL;
+
+	err = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+	data = be32_to_cpu(reg);
+
+	data &= ~(V3_CLOCK_RATE_MASK | V3_FETCH_PCM_FRAMES);
+	data |= i << V3_CLOCK_RATE_SHIFT;
+
+	need_to_wait = data != be32_to_cpu(reg);
+
+	reg = cpu_to_be32(data);
+	err = snd_motu_transaction_write(motu, V3_CLOCK_STATUS_OFFSET, &reg,
+					 sizeof(reg));
+	if (err < 0)
+		return err;
+
+	if (need_to_wait) {
+		/* Cost expensive. */
+		if (msleep_interruptible(4000) > 0)
+			return -EINTR;
+	}
+
+	return 0;
+}
+
+static int v3_get_clock_source(struct snd_motu *motu,
+			       enum snd_motu_clock_source *src)
+{
+	__be32 reg;
+	u32 data;
+	unsigned int val;
+	int err;
+
+	err = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+	data = be32_to_cpu(reg);
+
+	val = (data & V3_CLOCK_SOURCE_MASK) >> V3_CLOCK_SOURCE_SHIFT;
+	if (val == 0x00) {
+		*src = SND_MOTU_CLOCK_SOURCE_INTERNAL;
+	} else if (val == 0x01) {
+		*src = SND_MOTU_CLOCK_SOURCE_WORD_ON_BNC;
+	} else if (val == 0x10) {
+		*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_COAX;
+	} else if (val == 0x18 || val == 0x19) {
+		err = snd_motu_transaction_read(motu, V3_OPT_IFACE_MODE_OFFSET,
+						&reg, sizeof(reg));
+		if (err < 0)
+			return err;
+		data = be32_to_cpu(reg);
+
+		if (val == 0x18) {
+			if (data & V3_NO_ADAT_OPT_IN_IFACE_A)
+				*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_OPT_A;
+			else
+				*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_OPT_A;
+		} else {
+			if (data & V3_NO_ADAT_OPT_IN_IFACE_B)
+				*src = SND_MOTU_CLOCK_SOURCE_SPDIF_ON_OPT_B;
+			else
+				*src = SND_MOTU_CLOCK_SOURCE_ADAT_ON_OPT_B;
+		}
+	} else {
+		*src = SND_MOTU_CLOCK_SOURCE_UNKNOWN;
+	}
+
+	return 0;
+}
+
+static int v3_switch_fetching_mode(struct snd_motu *motu, bool enable)
+{
+	__be32 reg;
+	u32 data;
+	int err;
+
+	err = snd_motu_transaction_read(motu, V3_CLOCK_STATUS_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return 0;
+	data = be32_to_cpu(reg);
+
+	if (enable)
+		data |= V3_FETCH_PCM_FRAMES;
+	else
+		data &= ~V3_FETCH_PCM_FRAMES;
+
+	reg = cpu_to_be32(data);
+	return snd_motu_transaction_write(motu, V3_CLOCK_STATUS_OFFSET, &reg,
+					  sizeof(reg));
+}
+
+static void calculate_fixed_part(struct snd_motu_packet_format *formats,
+				 enum amdtp_stream_direction dir,
+				 enum snd_motu_spec_flags flags,
+				 unsigned char analog_ports)
+{
+	unsigned char pcm_chunks[3] = {0, 0, 0};
+
+	formats->msg_chunks = 2;
+
+	pcm_chunks[0] = analog_ports;
+	pcm_chunks[1] = analog_ports;
+	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
+		pcm_chunks[2] = analog_ports;
+
+	if (dir == AMDTP_IN_STREAM) {
+		if (flags & SND_MOTU_SPEC_TX_MICINST_CHUNK) {
+			pcm_chunks[0] += 2;
+			pcm_chunks[1] += 2;
+			if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
+				pcm_chunks[2] += 2;
+		}
+
+		if (flags & SND_MOTU_SPEC_TX_RETURN_CHUNK) {
+			pcm_chunks[0] += 2;
+			pcm_chunks[1] += 2;
+			if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
+				pcm_chunks[2] += 2;
+		}
+
+		if (flags & SND_MOTU_SPEC_TX_REVERB_CHUNK) {
+			pcm_chunks[0] += 2;
+			pcm_chunks[1] += 2;
+		}
+	} else {
+		/*
+		 * Packets to v2 units transfer main-out-1/2 and phone-out-1/2.
+		 */
+		pcm_chunks[0] += 4;
+		pcm_chunks[1] += 4;
+	}
+
+	/*
+	 * At least, packets have two data chunks for S/PDIF on coaxial
+	 * interface.
+	 */
+	pcm_chunks[0] += 2;
+	pcm_chunks[1] += 2;
+
+	/*
+	 * Fixed part consists of PCM chunks multiple of 4, with msg chunks. As
+	 * a result, this part can includes empty data chunks.
+	 */
+	formats->fixed_part_pcm_chunks[0] = round_up(2 + pcm_chunks[0], 4) - 2;
+	formats->fixed_part_pcm_chunks[1] = round_up(2 + pcm_chunks[1], 4) - 2;
+	if (flags & SND_MOTU_SPEC_SUPPORT_CLOCK_X4)
+		formats->fixed_part_pcm_chunks[2] =
+					round_up(2 + pcm_chunks[2], 4) - 2;
+}
+
+static void calculate_differed_part(struct snd_motu_packet_format *formats,
+				    enum snd_motu_spec_flags flags, u32 data,
+				    u32 a_enable_mask, u32 a_no_adat_mask,
+				    u32 b_enable_mask, u32 b_no_adat_mask)
+{
+	unsigned char pcm_chunks[3] = {0, 0, 0};
+	int i;
+
+	if ((flags & SND_MOTU_SPEC_HAS_OPT_IFACE_A) && (data & a_enable_mask)) {
+		if (data & a_no_adat_mask) {
+			/*
+			 * Additional two data chunks for S/PDIF on optical
+			 * interface A. This includes empty data chunks.
+			 */
+			pcm_chunks[0] += 4;
+			pcm_chunks[1] += 4;
+		} else {
+			/*
+			 * Additional data chunks for ADAT on optical interface
+			 * A.
+			 */
+			pcm_chunks[0] += 8;
+			pcm_chunks[1] += 4;
+		}
+	}
+
+	if ((flags & SND_MOTU_SPEC_HAS_OPT_IFACE_B) && (data & b_enable_mask)) {
+		if (data & b_no_adat_mask) {
+			/*
+			 * Additional two data chunks for S/PDIF on optical
+			 * interface B. This includes empty data chunks.
+			 */
+			pcm_chunks[0] += 4;
+			pcm_chunks[1] += 4;
+		} else {
+			/*
+			 * Additional data chunks for ADAT on optical interface
+			 * B.
+			 */
+			pcm_chunks[0] += 8;
+			pcm_chunks[1] += 4;
+		}
+	}
+
+	for (i = 0; i < 3; ++i) {
+		if (pcm_chunks[i] > 0)
+			pcm_chunks[i] = round_up(pcm_chunks[i], 4);
+
+		formats->differed_part_pcm_chunks[i] = pcm_chunks[i];
+	}
+}
+
+static int v3_cache_packet_formats(struct snd_motu *motu)
+{
+	__be32 reg;
+	u32 data;
+	int err;
+
+	err = snd_motu_transaction_read(motu, V3_OPT_IFACE_MODE_OFFSET, &reg,
+					sizeof(reg));
+	if (err < 0)
+		return err;
+	data = be32_to_cpu(reg);
+
+	calculate_fixed_part(&motu->tx_packet_formats, AMDTP_IN_STREAM,
+			     motu->spec->flags, motu->spec->analog_in_ports);
+	calculate_differed_part(&motu->tx_packet_formats,
+			motu->spec->flags, data,
+			V3_ENABLE_OPT_IN_IFACE_A, V3_NO_ADAT_OPT_IN_IFACE_A,
+			V3_ENABLE_OPT_IN_IFACE_B, V3_NO_ADAT_OPT_IN_IFACE_B);
+
+	calculate_fixed_part(&motu->rx_packet_formats, AMDTP_OUT_STREAM,
+			     motu->spec->flags, motu->spec->analog_out_ports);
+	calculate_differed_part(&motu->rx_packet_formats,
+			motu->spec->flags, data,
+			V3_ENABLE_OPT_OUT_IFACE_A, V3_NO_ADAT_OPT_OUT_IFACE_A,
+			V3_ENABLE_OPT_OUT_IFACE_B, V3_NO_ADAT_OPT_OUT_IFACE_B);
+
+	motu->tx_packet_formats.midi_flag_offset = 8;
+	motu->tx_packet_formats.midi_byte_offset = 7;
+	motu->tx_packet_formats.pcm_byte_offset = 10;
+
+	motu->rx_packet_formats.midi_flag_offset = 8;
+	motu->rx_packet_formats.midi_byte_offset = 7;
+	motu->rx_packet_formats.pcm_byte_offset = 10;
+
+	return 0;
+}
+
+const struct snd_motu_protocol snd_motu_protocol_v3 = {
+	.get_clock_rate		= v3_get_clock_rate,
+	.set_clock_rate		= v3_set_clock_rate,
+	.get_clock_source	= v3_get_clock_source,
+	.switch_fetching_mode	= v3_switch_fetching_mode,
+	.cache_packet_formats	= v3_cache_packet_formats,
+};
