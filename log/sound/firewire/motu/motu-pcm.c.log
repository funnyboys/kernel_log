commit 9883b3850fba6c2842a15ac3b38e36b214e03ddf
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:36 2020 +0900

    ALSA: firewire-motu: use table-based calculation of packet formats for proc
    
    This commit uses table-based calculation of packet formats for proc
    nodes.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-10-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index b24bb870388e..8e1437371263 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -26,8 +26,7 @@ static int motu_rate_constraint(struct snd_pcm_hw_params *params,
 		rate = snd_motu_clock_rates[i];
 		mode = i / 2;
 
-		pcm_channels = formats->fixed_part_pcm_chunks[mode] +
-			       formats->differed_part_pcm_chunks[mode];
+		pcm_channels = formats->pcm_chunks[mode];
 		if (!snd_interval_test(c, pcm_channels))
 			continue;
 
@@ -59,8 +58,7 @@ static int motu_channels_constraint(struct snd_pcm_hw_params *params,
 		if (!snd_interval_test(r, rate))
 			continue;
 
-		pcm_channels = formats->fixed_part_pcm_chunks[mode] +
-			       formats->differed_part_pcm_chunks[mode];
+		pcm_channels = formats->pcm_chunks[mode];
 		channels.min = min(channels.min, pcm_channels);
 		channels.max = max(channels.max, pcm_channels);
 	}
@@ -82,8 +80,7 @@ static void limit_channels_and_rates(struct snd_motu *motu,
 		rate = snd_motu_clock_rates[i];
 		mode = i / 2;
 
-		pcm_channels = formats->fixed_part_pcm_chunks[mode] +
-			       formats->differed_part_pcm_chunks[mode];
+		pcm_channels = formats->pcm_chunks[mode];
 		if (pcm_channels == 0)
 			continue;
 

commit ff222b7e45eb1ffb2931269abf66b9d3576c9eeb
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:31 2020 +0900

    ALSA: firewire-motu: add wrapper functions for protocol-dependent operations
    
    This commit adds helper functions which wraps function call for each
    protocol.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-5-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 2d41a1a4052c..b24bb870388e 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -133,7 +133,6 @@ static int init_hw_info(struct snd_motu *motu,
 static int pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_motu *motu = substream->private_data;
-	const struct snd_motu_protocol *const protocol = motu->spec->protocol;
 	struct amdtp_domain *d = &motu->domain;
 	enum snd_motu_clock_source src;
 	int err;
@@ -152,7 +151,7 @@ static int pcm_open(struct snd_pcm_substream *substream)
 	if (err < 0)
 		goto err_locked;
 
-	err = protocol->get_clock_source(motu, &src);
+	err = snd_motu_protocol_get_clock_source(motu, &src);
 	if (err < 0)
 		goto err_locked;
 
@@ -166,7 +165,7 @@ static int pcm_open(struct snd_pcm_substream *substream)
 		unsigned int frames_per_buffer = d->events_per_buffer;
 		unsigned int rate;
 
-		err = protocol->get_clock_rate(motu, &rate);
+		err = snd_motu_protocol_get_clock_rate(motu, &rate);
 		if (err < 0)
 			goto err_locked;
 

commit d45b3aaea26c8bc43ca5bc8cba05cb399096d631
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:27 2019 +0100

    ALSA: firewire: Drop superfluous ioctl PCM ops
    
    All the PCM ioctl ops of ALSA FireWire drivers do nothing but calling
    the default handler.
    
    Now PCM core accepts NULL as the default ioctl ops(*), so let's drop
    altogether.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Acked-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191210061145.24641-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 931978eb30c9..2d41a1a4052c 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -340,7 +340,6 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 	static const struct snd_pcm_ops capture_ops = {
 		.open      = pcm_open,
 		.close     = pcm_close,
-		.ioctl     = snd_pcm_lib_ioctl,
 		.hw_params = pcm_hw_params,
 		.hw_free   = pcm_hw_free,
 		.prepare   = capture_prepare,
@@ -351,7 +350,6 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 	static const struct snd_pcm_ops playback_ops = {
 		.open      = pcm_open,
 		.close     = pcm_close,
-		.ioctl     = snd_pcm_lib_ioctl,
 		.hw_params = pcm_hw_params,
 		.hw_free   = pcm_hw_free,
 		.prepare   = playback_prepare,

commit 7641d549b13bbb1dcc6c7759c010c1ca288c90be
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:48:41 2019 +0100

    ALSA: firewire: Use managed buffer allocation
    
    Clean up the drivers with the new managed buffer allocation API.
    The superfluous snd_pcm_lib_malloc_pages() and
    snd_pcm_lib_free_pages() calls are dropped.
    
    Acked-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191209192422.23902-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 005970931030..931978eb30c9 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -212,11 +212,7 @@ static int pcm_hw_params(struct snd_pcm_substream *substream,
 			 struct snd_pcm_hw_params *hw_params)
 {
 	struct snd_motu *motu = substream->private_data;
-	int err;
-
-	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-	if (err < 0)
-		return err;
+	int err = 0;
 
 	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		unsigned int rate = params_rate(hw_params);
@@ -247,7 +243,7 @@ static int pcm_hw_free(struct snd_pcm_substream *substream)
 
 	mutex_unlock(&motu->mutex);
 
-	return snd_pcm_lib_free_pages(substream);
+	return 0;
 }
 
 static int capture_prepare(struct snd_pcm_substream *substream)
@@ -374,8 +370,7 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
-					      NULL, 0, 0);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);
 
 	return 0;
 }

commit 9ff3483e5c552311676369b31bc64f0e8208fcd2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Dec 9 08:22:26 2019 +0900

    ALSA: firewire-motu: fix double unlocked 'motu->mutex'
    
    Mutex is doubly unlocked in some error path of pcm.open. This commit fixes
    ALSA firewire-motu driver in Linux kernel v5.5.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Fixes: 3fd80b200388 ("ALSA: firewire-motu: use the same size of period for PCM substream in AMDTP streams")
    Fixes: 0f5482e7875b ("ALSA: firewire-motu: share PCM buffer size for both direction")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191208232226.6685-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 349b4d09e84f..005970931030 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -177,18 +177,14 @@ static int pcm_open(struct snd_pcm_substream *substream)
 			err = snd_pcm_hw_constraint_minmax(substream->runtime,
 					SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					frames_per_period, frames_per_period);
-			if (err < 0) {
-				mutex_unlock(&motu->mutex);
+			if (err < 0)
 				goto err_locked;
-			}
 
 			err = snd_pcm_hw_constraint_minmax(substream->runtime,
 					SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
 					frames_per_buffer, frames_per_buffer);
-			if (err < 0) {
-				mutex_unlock(&motu->mutex);
+			if (err < 0)
 				goto err_locked;
-			}
 		}
 	}
 

commit a3f4f2d5d02095d098ff03c4d0bdbae2e53a5bba
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:42 2019 +0100

    ALSA: firewire: Convert to the common vmalloc memalloc
    
    The recent change (*) in the ALSA memalloc core allows us to drop the
    special vmalloc-specific allocation and page handling.  This patch
    coverts to the common code.
    (*) 1fe7f397cfe2: ALSA: memalloc: Add vmalloc buffer allocation
                      support
        7e8edae39fd1: ALSA: pcm: Handle special page mapping in the
                      default mmap handler
    
    Link: https://lore.kernel.org/r/20191105151856.10785-11-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 490408b49157..349b4d09e84f 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -218,8 +218,7 @@ static int pcm_hw_params(struct snd_pcm_substream *substream,
 	struct snd_motu *motu = substream->private_data;
 	int err;
 
-	err = snd_pcm_lib_alloc_vmalloc_buffer(substream,
-					       params_buffer_bytes(hw_params));
+	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 	if (err < 0)
 		return err;
 
@@ -252,7 +251,7 @@ static int pcm_hw_free(struct snd_pcm_substream *substream)
 
 	mutex_unlock(&motu->mutex);
 
-	return snd_pcm_lib_free_vmalloc_buffer(substream);
+	return snd_pcm_lib_free_pages(substream);
 }
 
 static int capture_prepare(struct snd_pcm_substream *substream)
@@ -356,7 +355,6 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 		.trigger   = capture_trigger,
 		.pointer   = capture_pointer,
 		.ack       = capture_ack,
-		.page      = snd_pcm_lib_get_vmalloc_page,
 	};
 	static const struct snd_pcm_ops playback_ops = {
 		.open      = pcm_open,
@@ -368,7 +366,6 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 		.trigger   = playback_trigger,
 		.pointer   = playback_pointer,
 		.ack       = playback_ack,
-		.page      = snd_pcm_lib_get_vmalloc_page,
 	};
 	struct snd_pcm *pcm;
 	int err;
@@ -381,6 +378,8 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
+					      NULL, 0, 0);
 
 	return 0;
 }

commit 3f58f004bff3273d102583e0b2f478526cf9d3c8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 30 17:06:41 2019 +0900

    ALSA: firewire-motu: detect SPH source of sampling clock
    
    In MOTU FireWire series, devices have a mode to generate sampling clock
    from a sequence of source packet header (SPH) included in each data block
    of received packet. This mode is used for several purposes such as mode
    for SMPTE time code, sync to the other sound cards and so on.
    
    This commit adds support for the SPH mode.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191030080644.1704-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 55d3d6661731..490408b49157 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -159,7 +159,8 @@ static int pcm_open(struct snd_pcm_substream *substream)
 	// When source of clock is not internal or any stream is reserved for
 	// transmission of PCM frames, the available sampling rate is limited
 	// at current one.
-	if (src != SND_MOTU_CLOCK_SOURCE_INTERNAL ||
+	if ((src != SND_MOTU_CLOCK_SOURCE_INTERNAL &&
+	     src != SND_MOTU_CLOCK_SOURCE_SPH) ||
 	    (motu->substreams_counter > 0 && d->events_per_period > 0)) {
 		unsigned int frames_per_period = d->events_per_period;
 		unsigned int frames_per_buffer = d->events_per_buffer;

commit e6dcc92fcea07f23c13996b7bb6a2a32ed4c6ed5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 15:19:08 2019 +0900

    ALSA: firewire-lib: replace ack callback to flush isoc contexts in AMDTP domain
    
    An isoc context for AMDTP stream is flushed to queue packet
    by a call of pcm.ack. This commit extends this for AMDTP
    domain.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191018061911.24909-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 13e2577c2a07..55d3d6661731 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -333,14 +333,14 @@ static int capture_ack(struct snd_pcm_substream *substream)
 {
 	struct snd_motu *motu = substream->private_data;
 
-	return amdtp_stream_pcm_ack(&motu->tx_stream);
+	return amdtp_domain_stream_pcm_ack(&motu->domain, &motu->tx_stream);
 }
 
 static int playback_ack(struct snd_pcm_substream *substream)
 {
 	struct snd_motu *motu = substream->private_data;
 
-	return amdtp_stream_pcm_ack(&motu->rx_stream);
+	return amdtp_domain_stream_pcm_ack(&motu->domain, &motu->rx_stream);
 }
 
 int snd_motu_create_pcm_devices(struct snd_motu *motu)

commit f890f9a04b361b2209c38e3317e6290a98e6ff6e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 15:19:07 2019 +0900

    ALSA: firewire-lib: replace pointer callback to flush isoc contexts in AMDTP domain
    
    An isoc context for AMDTP stream is flushed to queue packet
    by a call of pcm.pointer. This commit extends this for AMDTP
    domain.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191018061911.24909-3-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 00e693da0cad..13e2577c2a07 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -320,13 +320,13 @@ static snd_pcm_uframes_t capture_pointer(struct snd_pcm_substream *substream)
 {
 	struct snd_motu *motu = substream->private_data;
 
-	return amdtp_stream_pcm_pointer(&motu->tx_stream);
+	return amdtp_domain_stream_pcm_pointer(&motu->domain, &motu->tx_stream);
 }
 static snd_pcm_uframes_t playback_pointer(struct snd_pcm_substream *substream)
 {
 	struct snd_motu *motu = substream->private_data;
 
-	return amdtp_stream_pcm_pointer(&motu->rx_stream);
+	return amdtp_domain_stream_pcm_pointer(&motu->domain, &motu->rx_stream);
 }
 
 static int capture_ack(struct snd_pcm_substream *substream)

commit 0f5482e7875bc2d507e6d92fcc8de22ff75fbdda
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 00:54:20 2019 +0900

    ALSA: firewire-motu: share PCM buffer size for both direction
    
    This commit allows ALSA firewire-motu driver to share PCM buffer
    size for both capture and playback PCM substream. When AMDTP domain
    starts for one of the PCM substream, buffer size of the PCM substream
    is stores to AMDTP domain structure. Some AMDTP streams have already
    run with the buffer size when another PCM substream starts, therefore
    the PCM substream has a constraint to its buffer size.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191017155424.885-9-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 7bbf8b86a33d..00e693da0cad 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -162,6 +162,7 @@ static int pcm_open(struct snd_pcm_substream *substream)
 	if (src != SND_MOTU_CLOCK_SOURCE_INTERNAL ||
 	    (motu->substreams_counter > 0 && d->events_per_period > 0)) {
 		unsigned int frames_per_period = d->events_per_period;
+		unsigned int frames_per_buffer = d->events_per_buffer;
 		unsigned int rate;
 
 		err = protocol->get_clock_rate(motu, &rate);
@@ -179,6 +180,14 @@ static int pcm_open(struct snd_pcm_substream *substream)
 				mutex_unlock(&motu->mutex);
 				goto err_locked;
 			}
+
+			err = snd_pcm_hw_constraint_minmax(substream->runtime,
+					SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+					frames_per_buffer, frames_per_buffer);
+			if (err < 0) {
+				mutex_unlock(&motu->mutex);
+				goto err_locked;
+			}
 		}
 	}
 
@@ -216,10 +225,11 @@ static int pcm_hw_params(struct snd_pcm_substream *substream,
 	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		unsigned int rate = params_rate(hw_params);
 		unsigned int frames_per_period = params_period_size(hw_params);
+		unsigned int frames_per_buffer = params_buffer_size(hw_params);
 
 		mutex_lock(&motu->mutex);
 		err = snd_motu_stream_reserve_duplex(motu, rate,
-						     frames_per_period);
+					frames_per_period, frames_per_buffer);
 		if (err >= 0)
 			++motu->substreams_counter;
 		mutex_unlock(&motu->mutex);

commit 3fd80b2003882b6a328caff9e6b3a14bed61f27c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 7 20:05:31 2019 +0900

    ALSA: firewire-motu: use the same size of period for PCM substream in AMDTP streams
    
    In current implementation, when opening a PCM substream, it's needed to
    check whether the opposite PCM substream runs. This is to assign
    effectual constraints (e.g. sampling rate) to opened PCM substream.
    
    The number of PCM substreams and MIDI substreams on AMDTP streams in
    domain is recorded in own structure. Usage of this count is an
    alternative of the above check. This is better because the count is
    incremented in pcm.hw_params earlier than pcm.trigger.
    
    This idea has one issue because it's incremented for MIDI substreams as
    well. In current implementation, for a case that any MIDI substream run
    and a PCM substream is going to start, PCM application to start the PCM
    substream can decide hardware parameters by restart packet streaming.
    Just checking the substream count can brings regression.
    
    Now AMDTP domain structure has a member for the size of PCM period in
    PCM substream which starts AMDTP streams in domain. When the value has
    zero and the substream count is greater than 1, it means that any MIDI
    substream starts AMDTP streams in domain. Usage of the value can resolve
    the above issue.
    
    This commit replaces the check with the substream count and the value for
    the size of PCM period.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191007110532.30270-17-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 9a54c562494b..7bbf8b86a33d 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -134,8 +134,8 @@ static int pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_motu *motu = substream->private_data;
 	const struct snd_motu_protocol *const protocol = motu->spec->protocol;
+	struct amdtp_domain *d = &motu->domain;
 	enum snd_motu_clock_source src;
-	unsigned int rate;
 	int err;
 
 	err = snd_motu_stream_lock_try(motu);
@@ -152,28 +152,41 @@ static int pcm_open(struct snd_pcm_substream *substream)
 	if (err < 0)
 		goto err_locked;
 
-	/*
-	 * When source of clock is not internal or any PCM streams are running,
-	 * available sampling rate is limited at current sampling rate.
-	 */
 	err = protocol->get_clock_source(motu, &src);
 	if (err < 0)
 		goto err_locked;
+
+	// When source of clock is not internal or any stream is reserved for
+	// transmission of PCM frames, the available sampling rate is limited
+	// at current one.
 	if (src != SND_MOTU_CLOCK_SOURCE_INTERNAL ||
-	    amdtp_stream_pcm_running(&motu->tx_stream) ||
-	    amdtp_stream_pcm_running(&motu->rx_stream)) {
+	    (motu->substreams_counter > 0 && d->events_per_period > 0)) {
+		unsigned int frames_per_period = d->events_per_period;
+		unsigned int rate;
+
 		err = protocol->get_clock_rate(motu, &rate);
 		if (err < 0)
 			goto err_locked;
+
 		substream->runtime->hw.rate_min = rate;
 		substream->runtime->hw.rate_max = rate;
+
+		if (frames_per_period > 0) {
+			err = snd_pcm_hw_constraint_minmax(substream->runtime,
+					SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+					frames_per_period, frames_per_period);
+			if (err < 0) {
+				mutex_unlock(&motu->mutex);
+				goto err_locked;
+			}
+		}
 	}
 
 	snd_pcm_set_sync(substream);
 
 	mutex_unlock(&motu->mutex);
 
-	return err;
+	return 0;
 err_locked:
 	mutex_unlock(&motu->mutex);
 	snd_motu_stream_lock_release(motu);

commit 0d39cd0e449925a6221da48835ef962cd72f330f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 7 20:05:23 2019 +0900

    ALSA: firewire-motu: register the size of PCM period to AMDTP domain
    
    This commit is a preparation to share the size of PCM period between
    PCM substreams on AMDTP streams in the same domain. At this time,
    the size of PCM period in PCM substream which starts AMDTP streams in the
    same domain is recorded.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191007110532.30270-9-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index aa2e584da6fe..9a54c562494b 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -202,9 +202,11 @@ static int pcm_hw_params(struct snd_pcm_substream *substream,
 
 	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		unsigned int rate = params_rate(hw_params);
+		unsigned int frames_per_period = params_period_size(hw_params);
 
 		mutex_lock(&motu->mutex);
-		err = snd_motu_stream_reserve_duplex(motu, rate);
+		err = snd_motu_stream_reserve_duplex(motu, rate,
+						     frames_per_period);
 		if (err >= 0)
 			++motu->substreams_counter;
 		mutex_unlock(&motu->mutex);

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit eccd895c998549ebb4a80f0ebee13b6a179bd40c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jun 18 22:26:17 2019 +0900

    ALSA: firewire-motu: unify stop and release method for duplex streams
    
    >From callbacks for pcm and rawmidi interfaces, the functions to stop
    and release duplex streams are called at the same time. This commit
    merges the two functions.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index b9852c911b98..60c691d18952 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -224,7 +224,6 @@ static int pcm_hw_free(struct snd_pcm_substream *substream)
 		--motu->substreams_counter;
 
 	snd_motu_stream_stop_duplex(motu);
-	snd_motu_stream_release_duplex(motu);
 
 	mutex_unlock(&motu->mutex);
 

commit 15d472ecc510e20e42337c8205fa3987329e488d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 17 17:15:10 2019 +0900

    ALSA: firewire-motu: code refactoring for pcm.hw_params/hw_free callbacks
    
    The pairs of pcm.hw_params callbacks and .hw_free callbacks for both
    direction have no differences.
    
    This commit unifies the pairs.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index d4e75d3ee928..b9852c911b98 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -190,8 +190,8 @@ static int pcm_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static int capture_hw_params(struct snd_pcm_substream *substream,
-			     struct snd_pcm_hw_params *hw_params)
+static int pcm_hw_params(struct snd_pcm_substream *substream,
+			 struct snd_pcm_hw_params *hw_params)
 {
 	struct snd_motu *motu = substream->private_data;
 	int err;
@@ -213,48 +213,8 @@ static int capture_hw_params(struct snd_pcm_substream *substream,
 
 	return err;
 }
-static int playback_hw_params(struct snd_pcm_substream *substream,
-			      struct snd_pcm_hw_params *hw_params)
-{
-	struct snd_motu *motu = substream->private_data;
-	int err;
-
-	err = snd_pcm_lib_alloc_vmalloc_buffer(substream,
-					       params_buffer_bytes(hw_params));
-	if (err < 0)
-		return err;
-
-	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
-		unsigned int rate = params_rate(hw_params);
-
-		mutex_lock(&motu->mutex);
-		err = snd_motu_stream_reserve_duplex(motu, rate);
-		if (err >= 0)
-			++motu->substreams_counter;
-		mutex_unlock(&motu->mutex);
-	}
-
-	return err;
-}
-
-static int capture_hw_free(struct snd_pcm_substream *substream)
-{
-	struct snd_motu *motu = substream->private_data;
-
-	mutex_lock(&motu->mutex);
-
-	if (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)
-		--motu->substreams_counter;
-
-	snd_motu_stream_stop_duplex(motu);
-	snd_motu_stream_release_duplex(motu);
-
-	mutex_unlock(&motu->mutex);
-
-	return snd_pcm_lib_free_vmalloc_buffer(substream);
-}
 
-static int playback_hw_free(struct snd_pcm_substream *substream)
+static int pcm_hw_free(struct snd_pcm_substream *substream)
 {
 	struct snd_motu *motu = substream->private_data;
 
@@ -366,8 +326,8 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 		.open      = pcm_open,
 		.close     = pcm_close,
 		.ioctl     = snd_pcm_lib_ioctl,
-		.hw_params = capture_hw_params,
-		.hw_free   = capture_hw_free,
+		.hw_params = pcm_hw_params,
+		.hw_free   = pcm_hw_free,
 		.prepare   = capture_prepare,
 		.trigger   = capture_trigger,
 		.pointer   = capture_pointer,
@@ -378,8 +338,8 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 		.open      = pcm_open,
 		.close     = pcm_close,
 		.ioctl     = snd_pcm_lib_ioctl,
-		.hw_params = playback_hw_params,
-		.hw_free   = playback_hw_free,
+		.hw_params = pcm_hw_params,
+		.hw_free   = pcm_hw_free,
 		.prepare   = playback_prepare,
 		.trigger   = playback_trigger,
 		.pointer   = playback_pointer,

commit 8edc56ec8f14a586a55b2ab2fda76e6bf4738ee6
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 17 17:15:08 2019 +0900

    ALSA: firewire-motu: reserve/release isochronous resources in pcm.hw_params/hw_free callbacks
    
    Once allocated, isochronous resources are available for packet
    streaming, even if the streaming is cancelled. For this reason,
    current implementation handles allocation of the resources and
    starting packet streaming at the same time. However, this brings
    complicated procedure to start packet streaming.
    
    This commit separates the allocation and starting. The allocation is
    done in pcm.hw_params callback and available till pcm.hw_free callback.
    Even if any XRUN occurs, pcm.prepare callback is done to restart
    packet streaming without releasing/allocating the resources.
    
    There are two points to stop packet streaming; in pcm.hw_params and
    pcm.prepare callbacks. The former point is a case that packet streaming
    is already started for any MIDI substream then packet streaming is
    requested with different sampling transfer frequency for any PCM
    substream. The latter point is cases of any XRUN or packet queueing
    error.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index b0e5ebf05bec..d4e75d3ee928 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -202,12 +202,16 @@ static int capture_hw_params(struct snd_pcm_substream *substream,
 		return err;
 
 	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
+		unsigned int rate = params_rate(hw_params);
+
 		mutex_lock(&motu->mutex);
-		motu->substreams_counter++;
+		err = snd_motu_stream_reserve_duplex(motu, rate);
+		if (err >= 0)
+			++motu->substreams_counter;
 		mutex_unlock(&motu->mutex);
 	}
 
-	return 0;
+	return err;
 }
 static int playback_hw_params(struct snd_pcm_substream *substream,
 			      struct snd_pcm_hw_params *hw_params)
@@ -221,12 +225,16 @@ static int playback_hw_params(struct snd_pcm_substream *substream,
 		return err;
 
 	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
+		unsigned int rate = params_rate(hw_params);
+
 		mutex_lock(&motu->mutex);
-		motu->substreams_counter++;
+		err = snd_motu_stream_reserve_duplex(motu, rate);
+		if (err >= 0)
+			++motu->substreams_counter;
 		mutex_unlock(&motu->mutex);
 	}
 
-	return 0;
+	return err;
 }
 
 static int capture_hw_free(struct snd_pcm_substream *substream)
@@ -236,9 +244,10 @@ static int capture_hw_free(struct snd_pcm_substream *substream)
 	mutex_lock(&motu->mutex);
 
 	if (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)
-		motu->substreams_counter--;
+		--motu->substreams_counter;
 
 	snd_motu_stream_stop_duplex(motu);
+	snd_motu_stream_release_duplex(motu);
 
 	mutex_unlock(&motu->mutex);
 
@@ -252,9 +261,10 @@ static int playback_hw_free(struct snd_pcm_substream *substream)
 	mutex_lock(&motu->mutex);
 
 	if (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)
-		motu->substreams_counter--;
+		--motu->substreams_counter;
 
 	snd_motu_stream_stop_duplex(motu);
+	snd_motu_stream_release_duplex(motu);
 
 	mutex_unlock(&motu->mutex);
 
@@ -267,7 +277,7 @@ static int capture_prepare(struct snd_pcm_substream *substream)
 	int err;
 
 	mutex_lock(&motu->mutex);
-	err = snd_motu_stream_start_duplex(motu, substream->runtime->rate);
+	err = snd_motu_stream_start_duplex(motu);
 	mutex_unlock(&motu->mutex);
 	if (err >= 0)
 		amdtp_stream_pcm_prepare(&motu->tx_stream);
@@ -280,7 +290,7 @@ static int playback_prepare(struct snd_pcm_substream *substream)
 	int err;
 
 	mutex_lock(&motu->mutex);
-	err = snd_motu_stream_start_duplex(motu, substream->runtime->rate);
+	err = snd_motu_stream_start_duplex(motu);
 	mutex_unlock(&motu->mutex);
 	if (err >= 0)
 		amdtp_stream_pcm_prepare(&motu->rx_stream);

commit 18f26034be2711254adfa8923dfd263b50d4018a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 17 17:15:01 2019 +0900

    ALSA: firewire-motu: unify the count of subscriber for packet streaming
    
    Two counters are used to maintain isochronous packet streaming for both
    directions. However, like the other drivers, they can be replaced with
    one counter. This commit unifies them.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index ab69d7e6ac05..b0e5ebf05bec 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -203,7 +203,7 @@ static int capture_hw_params(struct snd_pcm_substream *substream,
 
 	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		mutex_lock(&motu->mutex);
-		motu->capture_substreams++;
+		motu->substreams_counter++;
 		mutex_unlock(&motu->mutex);
 	}
 
@@ -222,7 +222,7 @@ static int playback_hw_params(struct snd_pcm_substream *substream,
 
 	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		mutex_lock(&motu->mutex);
-		motu->playback_substreams++;
+		motu->substreams_counter++;
 		mutex_unlock(&motu->mutex);
 	}
 
@@ -236,7 +236,7 @@ static int capture_hw_free(struct snd_pcm_substream *substream)
 	mutex_lock(&motu->mutex);
 
 	if (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)
-		motu->capture_substreams--;
+		motu->substreams_counter--;
 
 	snd_motu_stream_stop_duplex(motu);
 
@@ -252,7 +252,7 @@ static int playback_hw_free(struct snd_pcm_substream *substream)
 	mutex_lock(&motu->mutex);
 
 	if (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)
-		motu->playback_substreams--;
+		motu->substreams_counter--;
 
 	snd_motu_stream_stop_duplex(motu);
 

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index ab69d7e6ac05..5e7db7aa4f08 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * motu-pcm.c - a part of driver for MOTU FireWire series
  *
  * Copyright (c) 2015-2017 Takashi Sakamoto <o-takashi@sakamocchi.jp>
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include <sound/pcm_params.h>

commit fa84cf094ef9667e2b91c104b0a788fd1896f482
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 18 07:40:53 2018 +0200

    ALSA: pcm: Nuke snd_pcm_lib_mmap_vmalloc()
    
    snd_pcm_lib_mmap_vmalloc() was supposed to be implemented with
    somewhat special for vmalloc handling, but in the end, this turned to
    just the default handler, i.e. NULL.  As the situation has never
    changed over decades, let's rip it off.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 4330220890e8..ab69d7e6ac05 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -363,7 +363,6 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 		.pointer   = capture_pointer,
 		.ack       = capture_ack,
 		.page      = snd_pcm_lib_get_vmalloc_page,
-		.mmap      = snd_pcm_lib_mmap_vmalloc,
 	};
 	static const struct snd_pcm_ops playback_ops = {
 		.open      = pcm_open,
@@ -376,7 +375,6 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 		.pointer   = playback_pointer,
 		.ack       = playback_ack,
 		.page      = snd_pcm_lib_get_vmalloc_page,
-		.mmap      = snd_pcm_lib_mmap_vmalloc,
 	};
 	struct snd_pcm *pcm;
 	int err;

commit 8b460c76bd17128db90d69a3f8b4ad2ee744d118
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 20 21:25:03 2017 +0900

    ALSA: firewire-motu: add specification flag for position of flag for MIDI messages
    
    In protocols of MOTU FireWire series, when transferring MIDI messages,
    transmitter set existence flag to one byte on first several quadlets. The
    position differs depending on protocols and models, however two cases are
    confirmed; in 5th byte and 8th byte from MSB side.
    
    This commit adds a series of specification flag to describe them. When
    the existence flag is in the 5th byte, SND_MOTU_SPEC_[R|T]X_MIDI_2ND_Q is
    used. Else, another set of the flag is used. Here, '_Q' means quadlet.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 1466e46a101e..4330220890e8 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -145,7 +145,7 @@ static int pcm_open(struct snd_pcm_substream *substream)
 
 	mutex_lock(&motu->mutex);
 
-	err = protocol->cache_packet_formats(motu);
+	err = snd_motu_stream_cache_packet_formats(motu);
 	if (err < 0)
 		goto err_locked;
 

commit b2165f3889ace44ee21a41ca72467be3119121db
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 18 13:15:13 2017 +0530

    ALSA: firewire: constify snd_pcm_ops structures
    
    snd_pcm_ops are not supposed to change at runtime. All functions
    working with snd_pcm_ops provided by <sound/pcm.h> work with
    const snd_pcm_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index a2b50df70874..1466e46a101e 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -352,7 +352,7 @@ static int playback_ack(struct snd_pcm_substream *substream)
 
 int snd_motu_create_pcm_devices(struct snd_motu *motu)
 {
-	static struct snd_pcm_ops capture_ops = {
+	static const struct snd_pcm_ops capture_ops = {
 		.open      = pcm_open,
 		.close     = pcm_close,
 		.ioctl     = snd_pcm_lib_ioctl,
@@ -365,7 +365,7 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 		.page      = snd_pcm_lib_get_vmalloc_page,
 		.mmap      = snd_pcm_lib_mmap_vmalloc,
 	};
-	static struct snd_pcm_ops playback_ops = {
+	static const struct snd_pcm_ops playback_ops = {
 		.open      = pcm_open,
 		.close     = pcm_close,
 		.ioctl     = snd_pcm_lib_ioctl,

commit 55799c5ab99e8762e58c387e39f9fa36e8f14158
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Jun 8 09:11:03 2017 +0900

    ALSA: firewire: arrange common PCM info/constraints for AMDTP engine applications
    
    In ALSA firewire stack, 8 drivers uses IEC 61883-1/6 engine for data
    transmission. They have common PCM info/constraints and duplicated codes.
    
    This commit unifies the codes into fireiwre-lib.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index e3ef89cee565..a2b50df70874 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -96,18 +96,6 @@ static void limit_channels_and_rates(struct snd_motu *motu,
 	snd_pcm_limit_hw_rates(runtime);
 }
 
-static void limit_period_and_buffer(struct snd_pcm_hardware *hw)
-{
-	hw->periods_min = 2;			/* SNDRV_PCM_INFO_BATCH */
-	hw->periods_max = UINT_MAX;
-
-	hw->period_bytes_min = 4 * hw->channels_max;    /* byte for a frame */
-
-	/* Just to prevent from allocating much pages. */
-	hw->period_bytes_max = hw->period_bytes_min * 2048;
-	hw->buffer_bytes_max = hw->period_bytes_max * hw->periods_min;
-}
-
 static int init_hw_info(struct snd_motu *motu,
 			struct snd_pcm_substream *substream)
 {
@@ -117,13 +105,6 @@ static int init_hw_info(struct snd_motu *motu,
 	struct snd_motu_packet_format *formats;
 	int err;
 
-	hw->info = SNDRV_PCM_INFO_MMAP |
-		   SNDRV_PCM_INFO_MMAP_VALID |
-		   SNDRV_PCM_INFO_BATCH |
-		   SNDRV_PCM_INFO_INTERLEAVED |
-		   SNDRV_PCM_INFO_JOINT_DUPLEX |
-		   SNDRV_PCM_INFO_BLOCK_TRANSFER;
-
 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 		hw->formats = SNDRV_PCM_FMTBIT_S32;
 		stream = &motu->tx_stream;
@@ -135,7 +116,6 @@ static int init_hw_info(struct snd_motu *motu,
 	}
 
 	limit_channels_and_rates(motu, runtime, formats);
-	limit_period_and_buffer(hw);
 
 	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
 				  motu_rate_constraint, formats,

commit 875becf8412c60ffae93c5f69e95a4d023f0e8ee
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 7 09:38:05 2017 +0900

    ALSA: firewire: process packets in 'struct snd_pcm_ops.ack' callback
    
    In recent commit for ALSA PCM core, some arrangement is done for
    'struct snd_pcm_ops.ack' callback. This is called when appl_ptr is
    explicitly moved in intermediate buffer for PCM frames, except for
    some cases described later.
    
    For drivers in ALSA firewire stack, usage of this callback has a merit to
    reduce latency between time of PCM frame queueing and handling actual
    packets in recent isochronous cycle, because no need to wait for software
    IRQ context from isochronous context of OHCI 1394.
    
    If this works well in a case that mapped page frame is used for the
    intermediate buffer, user process should execute some commands for ioctl(2)
    to tell the number of handled PCM frames in the intermediate buffer just
    after handling them. Therefore, at present, with a combination of below
    conditions, this doesn't work as expected and user process should wait for
    the software IRQ context as usual:
     - when ALSA PCM core judges page frame mapping is available for status
       data (struct snd_pcm_mmap_status) and control data
       (struct snd_pcm_mmap_control).
     - user process handles PCM frames by loop just with 'snd_pcm_mmap_begin()'
       and 'snd_pcm_mmap_commit()'.
     - user process uses PCM hw plugin in alsa-lib to operate I/O without
       'sync_ptr_ioctl' option.
    
    Unfortunately, major use case include these three conditions.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index 94558f3d218b..e3ef89cee565 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -356,6 +356,20 @@ static snd_pcm_uframes_t playback_pointer(struct snd_pcm_substream *substream)
 	return amdtp_stream_pcm_pointer(&motu->rx_stream);
 }
 
+static int capture_ack(struct snd_pcm_substream *substream)
+{
+	struct snd_motu *motu = substream->private_data;
+
+	return amdtp_stream_pcm_ack(&motu->tx_stream);
+}
+
+static int playback_ack(struct snd_pcm_substream *substream)
+{
+	struct snd_motu *motu = substream->private_data;
+
+	return amdtp_stream_pcm_ack(&motu->rx_stream);
+}
+
 int snd_motu_create_pcm_devices(struct snd_motu *motu)
 {
 	static struct snd_pcm_ops capture_ops = {
@@ -367,6 +381,7 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 		.prepare   = capture_prepare,
 		.trigger   = capture_trigger,
 		.pointer   = capture_pointer,
+		.ack       = capture_ack,
 		.page      = snd_pcm_lib_get_vmalloc_page,
 		.mmap      = snd_pcm_lib_mmap_vmalloc,
 	};
@@ -379,6 +394,7 @@ int snd_motu_create_pcm_devices(struct snd_motu *motu)
 		.prepare   = playback_prepare,
 		.trigger   = playback_trigger,
 		.pointer   = playback_pointer,
+		.ack       = playback_ack,
 		.page      = snd_pcm_lib_get_vmalloc_page,
 		.mmap      = snd_pcm_lib_mmap_vmalloc,
 	};

commit 71c3797779d3cd8378767f5b2d8cfd3b2f88c5c1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:24 2017 +0900

    ALSA: firewire-motu: add hwdep interface
    
    This commit adds hwdep interface so as the other sound drivers for units
    on IEEE 1394 bus have.
    
    This interface is designed for mixer/control applications. By using this
    interface, an application can get information about firewire node, can
    lock/unlock kernel streaming and can get notification at starting/stopping
    kernel streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
index a50bcd6f4a63..94558f3d218b 100644
--- a/sound/firewire/motu/motu-pcm.c
+++ b/sound/firewire/motu/motu-pcm.c
@@ -159,15 +159,19 @@ static int pcm_open(struct snd_pcm_substream *substream)
 	unsigned int rate;
 	int err;
 
+	err = snd_motu_stream_lock_try(motu);
+	if (err < 0)
+		return err;
+
 	mutex_lock(&motu->mutex);
 
 	err = protocol->cache_packet_formats(motu);
 	if (err < 0)
-		return err;
+		goto err_locked;
 
 	err = init_hw_info(motu, substream);
 	if (err < 0)
-		return err;
+		goto err_locked;
 
 	/*
 	 * When source of clock is not internal or any PCM streams are running,
@@ -175,13 +179,13 @@ static int pcm_open(struct snd_pcm_substream *substream)
 	 */
 	err = protocol->get_clock_source(motu, &src);
 	if (err < 0)
-		return err;
+		goto err_locked;
 	if (src != SND_MOTU_CLOCK_SOURCE_INTERNAL ||
 	    amdtp_stream_pcm_running(&motu->tx_stream) ||
 	    amdtp_stream_pcm_running(&motu->rx_stream)) {
 		err = protocol->get_clock_rate(motu, &rate);
 		if (err < 0)
-			return err;
+			goto err_locked;
 		substream->runtime->hw.rate_min = rate;
 		substream->runtime->hw.rate_max = rate;
 	}
@@ -190,11 +194,19 @@ static int pcm_open(struct snd_pcm_substream *substream)
 
 	mutex_unlock(&motu->mutex);
 
+	return err;
+err_locked:
+	mutex_unlock(&motu->mutex);
+	snd_motu_stream_lock_release(motu);
 	return err;
 }
 
 static int pcm_close(struct snd_pcm_substream *substream)
 {
+	struct snd_motu *motu = substream->private_data;
+
+	snd_motu_stream_lock_release(motu);
+
 	return 0;
 }
 

commit dd49b2d1f04af9b1f44e9fe82c85f374f662c61b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:22 2017 +0900

    ALSA: firewire-motu: add PCM functionality
    
    This commit adds PCM functionality to transmit/receive PCM samples.
    
    When one of PCM substreams are running or external clock source is
    selected, current sampling rate is used. Else, the sampling rate is
    changed according to requests from a userspace application.
    
    Available number of samples in a frame of PCM substream is determined at
    open(2) to corresponding PCM character device. Later, packet streaming
    starts by ioctl(2) with SNDRV_PCM_IOCTL_PREPARE. In theory, between them,
    applications can change state of the unit by any write transaction to
    change the number. In this case, this driver may fail packet streaming due
    to wrong data format.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/motu-pcm.c b/sound/firewire/motu/motu-pcm.c
new file mode 100644
index 000000000000..a50bcd6f4a63
--- /dev/null
+++ b/sound/firewire/motu/motu-pcm.c
@@ -0,0 +1,386 @@
+/*
+ * motu-pcm.c - a part of driver for MOTU FireWire series
+ *
+ * Copyright (c) 2015-2017 Takashi Sakamoto <o-takashi@sakamocchi.jp>
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include <sound/pcm_params.h>
+#include "motu.h"
+
+static int motu_rate_constraint(struct snd_pcm_hw_params *params,
+				struct snd_pcm_hw_rule *rule)
+{
+	struct snd_motu_packet_format *formats = rule->private;
+
+	const struct snd_interval *c =
+		hw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *r =
+		hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval rates = {
+		.min = UINT_MAX, .max = 0, .integer = 1
+	};
+	unsigned int i, pcm_channels, rate, mode;
+
+	for (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {
+		rate = snd_motu_clock_rates[i];
+		mode = i / 2;
+
+		pcm_channels = formats->fixed_part_pcm_chunks[mode] +
+			       formats->differed_part_pcm_chunks[mode];
+		if (!snd_interval_test(c, pcm_channels))
+			continue;
+
+		rates.min = min(rates.min, rate);
+		rates.max = max(rates.max, rate);
+	}
+
+	return snd_interval_refine(r, &rates);
+}
+
+static int motu_channels_constraint(struct snd_pcm_hw_params *params,
+				    struct snd_pcm_hw_rule *rule)
+{
+	struct snd_motu_packet_format *formats = rule->private;
+
+	const struct snd_interval *r =
+		hw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *c =
+		hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval channels = {
+		.min = UINT_MAX, .max = 0, .integer = 1
+	};
+	unsigned int i, pcm_channels, rate, mode;
+
+	for (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {
+		rate = snd_motu_clock_rates[i];
+		mode = i / 2;
+
+		if (!snd_interval_test(r, rate))
+			continue;
+
+		pcm_channels = formats->fixed_part_pcm_chunks[mode] +
+			       formats->differed_part_pcm_chunks[mode];
+		channels.min = min(channels.min, pcm_channels);
+		channels.max = max(channels.max, pcm_channels);
+	}
+
+	return snd_interval_refine(c, &channels);
+}
+
+static void limit_channels_and_rates(struct snd_motu *motu,
+				     struct snd_pcm_runtime *runtime,
+				     struct snd_motu_packet_format *formats)
+{
+	struct snd_pcm_hardware *hw = &runtime->hw;
+	unsigned int i, pcm_channels, rate, mode;
+
+	hw->channels_min = UINT_MAX;
+	hw->channels_max = 0;
+
+	for (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {
+		rate = snd_motu_clock_rates[i];
+		mode = i / 2;
+
+		pcm_channels = formats->fixed_part_pcm_chunks[mode] +
+			       formats->differed_part_pcm_chunks[mode];
+		if (pcm_channels == 0)
+			continue;
+
+		hw->rates |= snd_pcm_rate_to_rate_bit(rate);
+		hw->channels_min = min(hw->channels_min, pcm_channels);
+		hw->channels_max = max(hw->channels_max, pcm_channels);
+	}
+
+	snd_pcm_limit_hw_rates(runtime);
+}
+
+static void limit_period_and_buffer(struct snd_pcm_hardware *hw)
+{
+	hw->periods_min = 2;			/* SNDRV_PCM_INFO_BATCH */
+	hw->periods_max = UINT_MAX;
+
+	hw->period_bytes_min = 4 * hw->channels_max;    /* byte for a frame */
+
+	/* Just to prevent from allocating much pages. */
+	hw->period_bytes_max = hw->period_bytes_min * 2048;
+	hw->buffer_bytes_max = hw->period_bytes_max * hw->periods_min;
+}
+
+static int init_hw_info(struct snd_motu *motu,
+			struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_pcm_hardware *hw = &runtime->hw;
+	struct amdtp_stream *stream;
+	struct snd_motu_packet_format *formats;
+	int err;
+
+	hw->info = SNDRV_PCM_INFO_MMAP |
+		   SNDRV_PCM_INFO_MMAP_VALID |
+		   SNDRV_PCM_INFO_BATCH |
+		   SNDRV_PCM_INFO_INTERLEAVED |
+		   SNDRV_PCM_INFO_JOINT_DUPLEX |
+		   SNDRV_PCM_INFO_BLOCK_TRANSFER;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		hw->formats = SNDRV_PCM_FMTBIT_S32;
+		stream = &motu->tx_stream;
+		formats = &motu->tx_packet_formats;
+	} else {
+		hw->formats = SNDRV_PCM_FMTBIT_S32;
+		stream = &motu->rx_stream;
+		formats = &motu->rx_packet_formats;
+	}
+
+	limit_channels_and_rates(motu, runtime, formats);
+	limit_period_and_buffer(hw);
+
+	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				  motu_rate_constraint, formats,
+				  SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	if (err < 0)
+		return err;
+	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+				  motu_channels_constraint, formats,
+				  SNDRV_PCM_HW_PARAM_RATE, -1);
+	if (err < 0)
+		return err;
+
+	return amdtp_motu_add_pcm_hw_constraints(stream, runtime);
+}
+
+static int pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_motu *motu = substream->private_data;
+	const struct snd_motu_protocol *const protocol = motu->spec->protocol;
+	enum snd_motu_clock_source src;
+	unsigned int rate;
+	int err;
+
+	mutex_lock(&motu->mutex);
+
+	err = protocol->cache_packet_formats(motu);
+	if (err < 0)
+		return err;
+
+	err = init_hw_info(motu, substream);
+	if (err < 0)
+		return err;
+
+	/*
+	 * When source of clock is not internal or any PCM streams are running,
+	 * available sampling rate is limited at current sampling rate.
+	 */
+	err = protocol->get_clock_source(motu, &src);
+	if (err < 0)
+		return err;
+	if (src != SND_MOTU_CLOCK_SOURCE_INTERNAL ||
+	    amdtp_stream_pcm_running(&motu->tx_stream) ||
+	    amdtp_stream_pcm_running(&motu->rx_stream)) {
+		err = protocol->get_clock_rate(motu, &rate);
+		if (err < 0)
+			return err;
+		substream->runtime->hw.rate_min = rate;
+		substream->runtime->hw.rate_max = rate;
+	}
+
+	snd_pcm_set_sync(substream);
+
+	mutex_unlock(&motu->mutex);
+
+	return err;
+}
+
+static int pcm_close(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static int capture_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_motu *motu = substream->private_data;
+	int err;
+
+	err = snd_pcm_lib_alloc_vmalloc_buffer(substream,
+					       params_buffer_bytes(hw_params));
+	if (err < 0)
+		return err;
+
+	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
+		mutex_lock(&motu->mutex);
+		motu->capture_substreams++;
+		mutex_unlock(&motu->mutex);
+	}
+
+	return 0;
+}
+static int playback_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_motu *motu = substream->private_data;
+	int err;
+
+	err = snd_pcm_lib_alloc_vmalloc_buffer(substream,
+					       params_buffer_bytes(hw_params));
+	if (err < 0)
+		return err;
+
+	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {
+		mutex_lock(&motu->mutex);
+		motu->playback_substreams++;
+		mutex_unlock(&motu->mutex);
+	}
+
+	return 0;
+}
+
+static int capture_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_motu *motu = substream->private_data;
+
+	mutex_lock(&motu->mutex);
+
+	if (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)
+		motu->capture_substreams--;
+
+	snd_motu_stream_stop_duplex(motu);
+
+	mutex_unlock(&motu->mutex);
+
+	return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int playback_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_motu *motu = substream->private_data;
+
+	mutex_lock(&motu->mutex);
+
+	if (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)
+		motu->playback_substreams--;
+
+	snd_motu_stream_stop_duplex(motu);
+
+	mutex_unlock(&motu->mutex);
+
+	return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int capture_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_motu *motu = substream->private_data;
+	int err;
+
+	mutex_lock(&motu->mutex);
+	err = snd_motu_stream_start_duplex(motu, substream->runtime->rate);
+	mutex_unlock(&motu->mutex);
+	if (err >= 0)
+		amdtp_stream_pcm_prepare(&motu->tx_stream);
+
+	return 0;
+}
+static int playback_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_motu *motu = substream->private_data;
+	int err;
+
+	mutex_lock(&motu->mutex);
+	err = snd_motu_stream_start_duplex(motu, substream->runtime->rate);
+	mutex_unlock(&motu->mutex);
+	if (err >= 0)
+		amdtp_stream_pcm_prepare(&motu->rx_stream);
+
+	return err;
+}
+
+static int capture_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_motu *motu = substream->private_data;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		amdtp_stream_pcm_trigger(&motu->tx_stream, substream);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		amdtp_stream_pcm_trigger(&motu->tx_stream, NULL);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+static int playback_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_motu *motu = substream->private_data;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		amdtp_stream_pcm_trigger(&motu->rx_stream, substream);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		amdtp_stream_pcm_trigger(&motu->rx_stream, NULL);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t capture_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_motu *motu = substream->private_data;
+
+	return amdtp_stream_pcm_pointer(&motu->tx_stream);
+}
+static snd_pcm_uframes_t playback_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_motu *motu = substream->private_data;
+
+	return amdtp_stream_pcm_pointer(&motu->rx_stream);
+}
+
+int snd_motu_create_pcm_devices(struct snd_motu *motu)
+{
+	static struct snd_pcm_ops capture_ops = {
+		.open      = pcm_open,
+		.close     = pcm_close,
+		.ioctl     = snd_pcm_lib_ioctl,
+		.hw_params = capture_hw_params,
+		.hw_free   = capture_hw_free,
+		.prepare   = capture_prepare,
+		.trigger   = capture_trigger,
+		.pointer   = capture_pointer,
+		.page      = snd_pcm_lib_get_vmalloc_page,
+		.mmap      = snd_pcm_lib_mmap_vmalloc,
+	};
+	static struct snd_pcm_ops playback_ops = {
+		.open      = pcm_open,
+		.close     = pcm_close,
+		.ioctl     = snd_pcm_lib_ioctl,
+		.hw_params = playback_hw_params,
+		.hw_free   = playback_hw_free,
+		.prepare   = playback_prepare,
+		.trigger   = playback_trigger,
+		.pointer   = playback_pointer,
+		.page      = snd_pcm_lib_get_vmalloc_page,
+		.mmap      = snd_pcm_lib_mmap_vmalloc,
+	};
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_pcm_new(motu->card, motu->card->driver, 0, 1, 1, &pcm);
+	if (err < 0)
+		return err;
+	pcm->private_data = motu;
+	strcpy(pcm->name, motu->card->shortname);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);
+
+	return 0;
+}
