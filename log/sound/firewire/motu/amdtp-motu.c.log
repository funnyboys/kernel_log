commit 88e8f89dcc66eafcd4c11fd41988ebe22b793df1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:37 2020 +0900

    ALSA: firewire-motu: use table-based calculation of packet formats for stream management
    
    This commit uses table-based calculation of packet formats for stream
    management.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-11-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 17c9ea8eb4c8..edb31ac26868 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -76,15 +76,11 @@ int amdtp_motu_set_parameters(struct amdtp_stream *s, unsigned int rate,
 	if (i == ARRAY_SIZE(snd_motu_clock_rates))
 		return -EINVAL;
 
-	pcm_chunks = formats->fixed_part_pcm_chunks[mode] +
-		     formats->differed_part_pcm_chunks[mode];
+	// Each data block includes SPH in its head. Data chunks follow with
+	// 3 byte alignment. Padding follows with zero to conform to quadlet
+	// alignment.
+	pcm_chunks = formats->pcm_chunks[mode];
 	data_chunks = formats->msg_chunks + pcm_chunks;
-
-	/*
-	 * Each data block includes SPH in its head. Data chunks follow with
-	 * 3 byte alignment. Padding follows with zero to conform to quadlet
-	 * alignment.
-	 */
 	data_block_quadlets = 1 + DIV_ROUND_UP(data_chunks * 3, 4);
 
 	err = amdtp_stream_set_parameters(s, rate, data_block_quadlets);

commit 61d79c70c976a14cb321e537c39d147f7069e86a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 19 20:16:30 2020 +0900

    ALSA: firewire-motu: localize protocol data
    
    This commit adds enumerations of protocol version to localize protocol
    data.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200519111641.123211-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 0fd36e469ad0..17c9ea8eb4c8 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -440,7 +440,7 @@ static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
 
 int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
 		    enum amdtp_stream_direction dir,
-		    const struct snd_motu_protocol *const protocol)
+		    const struct snd_motu_spec *spec)
 {
 	amdtp_stream_process_ctx_payloads_t process_ctx_payloads;
 	int fmt = CIP_FMT_MOTU;
@@ -454,14 +454,15 @@ int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
 		 * Units of version 3 transmits packets with invalid CIP header
 		 * against IEC 61883-1.
 		 */
-		if (protocol == &snd_motu_protocol_v3) {
+		if (spec->protocol_version == SND_MOTU_PROTOCOL_V3) {
 			flags |= CIP_WRONG_DBS |
 				 CIP_SKIP_DBC_ZERO_CHECK |
 				 CIP_HEADER_WITHOUT_EOH;
 			fmt = CIP_FMT_MOTU_TX_V3;
 		}
 
-		if (protocol == &snd_motu_protocol_v2) {
+		if (spec == &snd_motu_spec_8pre ||
+		    spec == &snd_motu_spec_ultralite) {
 			// 8pre has some quirks.
 			flags |= CIP_WRONG_DBS |
 				 CIP_SKIP_DBC_ZERO_CHECK;

commit d2d5a6b0253d30ef04d513447cdd00df4fa627c3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:37:10 2019 +0900

    ALSA: firewire-motu: more code refactoring for MOTU data block processing layer
    
    MOTU data block processing layer has some tracepoints events. This
    commit is code refactoring to split probing the events from processing
    data blocks.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 05a6e218b0ad..0fd36e469ad0 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -310,6 +310,22 @@ static void __maybe_unused copy_message(u64 *frames, __be32 *buffer,
 	}
 }
 
+static void probe_tracepoints_events(struct amdtp_stream *s,
+				     const struct pkt_desc *descs,
+				     unsigned int packets)
+{
+	int i;
+
+	for (i = 0; i < packets; ++i) {
+		const struct pkt_desc *desc = descs + i;
+		__be32 *buf = desc->ctx_payload;
+		unsigned int data_blocks = desc->data_blocks;
+
+		trace_data_block_sph(s, data_blocks, buf);
+		trace_data_block_message(s, data_blocks, buf);
+	}
+}
+
 static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
 					    const struct pkt_desc *descs,
 					    unsigned int packets,
@@ -319,23 +335,26 @@ static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
 	unsigned int pcm_frames = 0;
 	int i;
 
+	// For data block processing.
 	for (i = 0; i < packets; ++i) {
 		const struct pkt_desc *desc = descs + i;
 		__be32 *buf = desc->ctx_payload;
 		unsigned int data_blocks = desc->data_blocks;
 
-		trace_data_block_sph(s, data_blocks, buf);
-		trace_data_block_message(s, data_blocks, buf);
-
-		if (p->midi_ports)
-			read_midi_messages(s, buf, data_blocks);
-
 		if (pcm) {
 			read_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
 			pcm_frames += data_blocks;
 		}
+
+		if (p->midi_ports)
+			read_midi_messages(s, buf, data_blocks);
 	}
 
+	// For tracepoints.
+	if (trace_data_block_sph_enabled() ||
+	    trace_data_block_message_enabled())
+		probe_tracepoints_events(s, descs, packets);
+
 	return pcm_frames;
 }
 
@@ -390,16 +409,12 @@ static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
 	unsigned int pcm_frames = 0;
 	int i;
 
+	// For data block processing.
 	for (i = 0; i < packets; ++i) {
 		const struct pkt_desc *desc = descs + i;
 		__be32 *buf = desc->ctx_payload;
 		unsigned int data_blocks = desc->data_blocks;
 
-		// TODO: how to interact control messages between userspace?
-
-		if (p->midi_ports)
-			write_midi_messages(s, buf, data_blocks);
-
 		if (pcm) {
 			write_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
 			pcm_frames += data_blocks;
@@ -407,12 +422,19 @@ static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
 			write_pcm_silence(s, buf, data_blocks);
 		}
 
-		write_sph(s, buf, data_blocks);
+		if (p->midi_ports)
+			write_midi_messages(s, buf, data_blocks);
 
-		trace_data_block_sph(s, data_blocks, buf);
-		trace_data_block_message(s, data_blocks, buf);
+		// TODO: how to interact control messages between userspace?
+
+		write_sph(s, buf, data_blocks);
 	}
 
+	// For tracepoints.
+	if (trace_data_block_sph_enabled() ||
+	    trace_data_block_message_enabled())
+		probe_tracepoints_events(s, descs, packets);
+
 	return pcm_frames;
 }
 

commit 9a738ad1b1a64ef6d8271d8d42d715b75db6eb0d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:37:09 2019 +0900

    ALSA: firewire-lib: process payload of isoc context according to packet descriptors
    
    This commit changes each of data block processing layer so that it
    receives list of packet descriptor.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 21c6bfdf47c0..05a6e218b0ad 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -310,23 +310,30 @@ static void __maybe_unused copy_message(u64 *frames, __be32 *buffer,
 	}
 }
 
-static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
-					   const struct pkt_desc *desc,
-					   struct snd_pcm_substream *pcm)
+static unsigned int process_ir_ctx_payloads(struct amdtp_stream *s,
+					    const struct pkt_desc *descs,
+					    unsigned int packets,
+					    struct snd_pcm_substream *pcm)
 {
 	struct amdtp_motu *p = s->protocol;
 	unsigned int pcm_frames = 0;
+	int i;
+
+	for (i = 0; i < packets; ++i) {
+		const struct pkt_desc *desc = descs + i;
+		__be32 *buf = desc->ctx_payload;
+		unsigned int data_blocks = desc->data_blocks;
 
-	trace_data_block_sph(s, desc->data_blocks, desc->ctx_payload);
-	trace_data_block_message(s, desc->data_blocks, desc->ctx_payload);
+		trace_data_block_sph(s, data_blocks, buf);
+		trace_data_block_message(s, data_blocks, buf);
 
-	if (p->midi_ports)
-		read_midi_messages(s, desc->ctx_payload, desc->data_blocks);
+		if (p->midi_ports)
+			read_midi_messages(s, buf, data_blocks);
 
-	if (pcm) {
-		read_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks,
-			     pcm_frames);
-		pcm_frames = desc->data_blocks;
+		if (pcm) {
+			read_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+			pcm_frames += data_blocks;
+		}
 	}
 
 	return pcm_frames;
@@ -374,30 +381,37 @@ static void write_sph(struct amdtp_stream *s, __be32 *buffer,
 	}
 }
 
-static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
-					   const struct pkt_desc *desc,
-					   struct snd_pcm_substream *pcm)
+static unsigned int process_it_ctx_payloads(struct amdtp_stream *s,
+					    const struct pkt_desc *descs,
+					    unsigned int packets,
+					    struct snd_pcm_substream *pcm)
 {
 	struct amdtp_motu *p = s->protocol;
 	unsigned int pcm_frames = 0;
+	int i;
 
-	/* TODO: how to interact control messages between userspace? */
+	for (i = 0; i < packets; ++i) {
+		const struct pkt_desc *desc = descs + i;
+		__be32 *buf = desc->ctx_payload;
+		unsigned int data_blocks = desc->data_blocks;
 
-	if (p->midi_ports)
-		write_midi_messages(s, desc->ctx_payload, desc->data_blocks);
+		// TODO: how to interact control messages between userspace?
 
-	if (pcm) {
-		write_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks,
-			      pcm_frames);
-		pcm_frames = desc->data_blocks;
-	} else {
-		write_pcm_silence(s, desc->ctx_payload, desc->data_blocks);
-	}
+		if (p->midi_ports)
+			write_midi_messages(s, buf, data_blocks);
 
-	write_sph(s, desc->ctx_payload, desc->data_blocks);
+		if (pcm) {
+			write_pcm_s32(s, pcm, buf, data_blocks, pcm_frames);
+			pcm_frames += data_blocks;
+		} else {
+			write_pcm_silence(s, buf, data_blocks);
+		}
 
-	trace_data_block_sph(s, desc->data_blocks, desc->ctx_payload);
-	trace_data_block_message(s, desc->data_blocks, desc->ctx_payload);
+		write_sph(s, buf, data_blocks);
+
+		trace_data_block_sph(s, data_blocks, buf);
+		trace_data_block_message(s, data_blocks, buf);
+	}
 
 	return pcm_frames;
 }
@@ -406,13 +420,13 @@ int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
 		    enum amdtp_stream_direction dir,
 		    const struct snd_motu_protocol *const protocol)
 {
-	amdtp_stream_process_data_blocks_t process_data_blocks;
+	amdtp_stream_process_ctx_payloads_t process_ctx_payloads;
 	int fmt = CIP_FMT_MOTU;
 	int flags = CIP_BLOCKING;
 	int err;
 
 	if (dir == AMDTP_IN_STREAM) {
-		process_data_blocks = process_tx_data_blocks;
+		process_ctx_payloads = process_ir_ctx_payloads;
 
 		/*
 		 * Units of version 3 transmits packets with invalid CIP header
@@ -431,11 +445,11 @@ int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
 				 CIP_SKIP_DBC_ZERO_CHECK;
 		}
 	} else {
-		process_data_blocks = process_rx_data_blocks;
+		process_ctx_payloads = process_it_ctx_payloads;
 		flags |= CIP_DBC_IS_END_EVENT;
 	}
 
-	err = amdtp_stream_init(s, unit, dir, flags, fmt, process_data_blocks,
+	err = amdtp_stream_init(s, unit, dir, flags, fmt, process_ctx_payloads,
 				sizeof(struct amdtp_motu));
 	if (err < 0)
 		return err;

commit 00d004db6493c62b8bbd7073a9b3b7290cbe0cea
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:37:07 2019 +0900

    ALSA: firewire-motu: code refactoring for MOTU data block processing layer
    
    This is code refactoring for MOTU data block processing layer so that
    it can receive list of packet descriptor.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 36ee2c1dd667..21c6bfdf47c0 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -117,19 +117,25 @@ int amdtp_motu_set_parameters(struct amdtp_stream *s, unsigned int rate,
 	return 0;
 }
 
-static void read_pcm_s32(struct amdtp_stream *s,
-			 struct snd_pcm_runtime *runtime,
-			 __be32 *buffer, unsigned int data_blocks)
+static void read_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,
+			 __be32 *buffer, unsigned int data_blocks,
+			 unsigned int pcm_frames)
 {
 	struct amdtp_motu *p = s->protocol;
-	unsigned int channels, remaining_frames, i, c;
+	unsigned int channels = p->pcm_chunks;
+	struct snd_pcm_runtime *runtime = pcm->runtime;
+	unsigned int pcm_buffer_pointer;
+	int remaining_frames;
 	u8 *byte;
 	u32 *dst;
+	int i, c;
+
+	pcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;
+	pcm_buffer_pointer %= runtime->buffer_size;
 
-	channels = p->pcm_chunks;
 	dst = (void *)runtime->dma_area +
-			frames_to_bytes(runtime, s->pcm_buffer_pointer);
-	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
+				frames_to_bytes(runtime, pcm_buffer_pointer);
+	remaining_frames = runtime->buffer_size - pcm_buffer_pointer;
 
 	for (i = 0; i < data_blocks; ++i) {
 		byte = (u8 *)buffer + p->pcm_byte_offset;
@@ -147,19 +153,25 @@ static void read_pcm_s32(struct amdtp_stream *s,
 	}
 }
 
-static void write_pcm_s32(struct amdtp_stream *s,
-			  struct snd_pcm_runtime *runtime,
-			  __be32 *buffer, unsigned int data_blocks)
+static void write_pcm_s32(struct amdtp_stream *s, struct snd_pcm_substream *pcm,
+			  __be32 *buffer, unsigned int data_blocks,
+			  unsigned int pcm_frames)
 {
 	struct amdtp_motu *p = s->protocol;
-	unsigned int channels, remaining_frames, i, c;
+	unsigned int channels = p->pcm_chunks;
+	struct snd_pcm_runtime *runtime = pcm->runtime;
+	unsigned int pcm_buffer_pointer;
+	int remaining_frames;
 	u8 *byte;
 	const u32 *src;
+	int i, c;
+
+	pcm_buffer_pointer = s->pcm_buffer_pointer + pcm_frames;
+	pcm_buffer_pointer %= runtime->buffer_size;
 
-	channels = p->pcm_chunks;
 	src = (void *)runtime->dma_area +
-			frames_to_bytes(runtime, s->pcm_buffer_pointer);
-	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
+				frames_to_bytes(runtime, pcm_buffer_pointer);
+	remaining_frames = runtime->buffer_size - pcm_buffer_pointer;
 
 	for (i = 0; i < data_blocks; ++i) {
 		byte = (u8 *)buffer + p->pcm_byte_offset;
@@ -303,7 +315,7 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 					   struct snd_pcm_substream *pcm)
 {
 	struct amdtp_motu *p = s->protocol;
-	unsigned int pcm_frames;
+	unsigned int pcm_frames = 0;
 
 	trace_data_block_sph(s, desc->data_blocks, desc->ctx_payload);
 	trace_data_block_message(s, desc->data_blocks, desc->ctx_payload);
@@ -312,11 +324,9 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 		read_midi_messages(s, desc->ctx_payload, desc->data_blocks);
 
 	if (pcm) {
-		read_pcm_s32(s, pcm->runtime, desc->ctx_payload,
-			     desc->data_blocks);
+		read_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks,
+			     pcm_frames);
 		pcm_frames = desc->data_blocks;
-	} else {
-		pcm_frames = 0;
 	}
 
 	return pcm_frames;
@@ -368,8 +378,8 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 					   const struct pkt_desc *desc,
 					   struct snd_pcm_substream *pcm)
 {
-	struct amdtp_motu *p = (struct amdtp_motu *)s->protocol;
-	unsigned int pcm_frames;
+	struct amdtp_motu *p = s->protocol;
+	unsigned int pcm_frames = 0;
 
 	/* TODO: how to interact control messages between userspace? */
 
@@ -377,12 +387,11 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 		write_midi_messages(s, desc->ctx_payload, desc->data_blocks);
 
 	if (pcm) {
-		write_pcm_s32(s, pcm->runtime, desc->ctx_payload,
-			      desc->data_blocks);
+		write_pcm_s32(s, pcm, desc->ctx_payload, desc->data_blocks,
+			      pcm_frames);
 		pcm_frames = desc->data_blocks;
 	} else {
 		write_pcm_silence(s, desc->ctx_payload, desc->data_blocks);
-		pcm_frames = 0;
 	}
 
 	write_sph(s, desc->ctx_payload, desc->data_blocks);

commit d2c104a3426be9991b35c65f0f260a107c4b2942
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:37:03 2019 +0900

    ALSA: firewire-lib: pass packet descriptor to data block processing layer
    
    This commit changes signature of callback function to call data block
    processing layer with packet descriptor. At present, the layer is called
    per packet.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 30d5f87119cc..36ee2c1dd667 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -299,23 +299,27 @@ static void __maybe_unused copy_message(u64 *frames, __be32 *buffer,
 }
 
 static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
-				__be32 *buffer, unsigned int data_blocks,
-				unsigned int data_block_counter)
+					   const struct pkt_desc *desc,
+					   struct snd_pcm_substream *pcm)
 {
 	struct amdtp_motu *p = s->protocol;
-	struct snd_pcm_substream *pcm;
+	unsigned int pcm_frames;
 
-	trace_data_block_sph(s, data_blocks, buffer);
-	trace_data_block_message(s, data_blocks, buffer);
+	trace_data_block_sph(s, desc->data_blocks, desc->ctx_payload);
+	trace_data_block_message(s, desc->data_blocks, desc->ctx_payload);
 
 	if (p->midi_ports)
-		read_midi_messages(s, buffer, data_blocks);
+		read_midi_messages(s, desc->ctx_payload, desc->data_blocks);
 
-	pcm = READ_ONCE(s->pcm);
-	if (data_blocks > 0 && pcm)
-		read_pcm_s32(s, pcm->runtime, buffer, data_blocks);
+	if (pcm) {
+		read_pcm_s32(s, pcm->runtime, desc->ctx_payload,
+			     desc->data_blocks);
+		pcm_frames = desc->data_blocks;
+	} else {
+		pcm_frames = 0;
+	}
 
-	return data_blocks;
+	return pcm_frames;
 }
 
 static inline void compute_next_elapse_from_start(struct amdtp_motu *p)
@@ -361,29 +365,32 @@ static void write_sph(struct amdtp_stream *s, __be32 *buffer,
 }
 
 static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
-				__be32 *buffer, unsigned int data_blocks,
-				unsigned int data_block_counter)
+					   const struct pkt_desc *desc,
+					   struct snd_pcm_substream *pcm)
 {
 	struct amdtp_motu *p = (struct amdtp_motu *)s->protocol;
-	struct snd_pcm_substream *pcm;
+	unsigned int pcm_frames;
 
 	/* TODO: how to interact control messages between userspace? */
 
 	if (p->midi_ports)
-		write_midi_messages(s, buffer, data_blocks);
+		write_midi_messages(s, desc->ctx_payload, desc->data_blocks);
 
-	pcm = READ_ONCE(s->pcm);
-	if (pcm)
-		write_pcm_s32(s, pcm->runtime, buffer, data_blocks);
-	else
-		write_pcm_silence(s, buffer, data_blocks);
+	if (pcm) {
+		write_pcm_s32(s, pcm->runtime, desc->ctx_payload,
+			      desc->data_blocks);
+		pcm_frames = desc->data_blocks;
+	} else {
+		write_pcm_silence(s, desc->ctx_payload, desc->data_blocks);
+		pcm_frames = 0;
+	}
 
-	write_sph(s, buffer, data_blocks);
+	write_sph(s, desc->ctx_payload, desc->data_blocks);
 
-	trace_data_block_sph(s, data_blocks, buffer);
-	trace_data_block_message(s, data_blocks, buffer);
+	trace_data_block_sph(s, desc->data_blocks, desc->ctx_payload);
+	trace_data_block_message(s, desc->data_blocks, desc->ctx_payload);
 
-	return data_blocks;
+	return pcm_frames;
 }
 
 int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,

commit 600c8018df605a91575aef6811cf927e2d933d30
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:57 2019 +0900

    ALSA: firewire-lib: pass no syt information to data block processing layer
    
    In a previous commit, the variable passed from packet streaming layer
    for syt variable is useless. This commit obsoletes it.
    
    In my future work, the syt information is passed to data block processing
    layer by another way.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 683873699885..30d5f87119cc 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -299,8 +299,8 @@ static void __maybe_unused copy_message(u64 *frames, __be32 *buffer,
 }
 
 static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
-			__be32 *buffer, unsigned int data_blocks,
-			unsigned int data_block_counter, unsigned int *syt)
+				__be32 *buffer, unsigned int data_blocks,
+				unsigned int data_block_counter)
 {
 	struct amdtp_motu *p = s->protocol;
 	struct snd_pcm_substream *pcm;
@@ -361,15 +361,12 @@ static void write_sph(struct amdtp_stream *s, __be32 *buffer,
 }
 
 static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
-			__be32 *buffer, unsigned int data_blocks,
-			unsigned int data_block_counter, unsigned int *syt)
+				__be32 *buffer, unsigned int data_blocks,
+				unsigned int data_block_counter)
 {
 	struct amdtp_motu *p = (struct amdtp_motu *)s->protocol;
 	struct snd_pcm_substream *pcm;
 
-	/* Not used. */
-	*syt = 0xffff;
-
 	/* TODO: how to interact control messages between userspace? */
 
 	if (p->midi_ports)

commit 3baf30532f94030244a31a275b546d042656c535
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:56 2019 +0900

    ALSA: firewire-lib: add syt_override member for some protocols
    
    Some protocols don't use syt field of CIP header to represent
    presentation timestamp. For such protocol, ALSA IEC 61883-1/6
    packet streaming engine uses a pointer into local variable for
    the value of syt to call data block processing layer. However,
    it can decide the value when initializing packet streaming
    layer.
    
    This commit adds 'syt_override' member for packet streaming
    layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 9693f37a0032..683873699885 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -428,7 +428,13 @@ int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
 		return err;
 
 	s->sph = 1;
-	s->ctx_data.rx.fdf = MOTU_FDF_AM824;
+
+	if (dir == AMDTP_OUT_STREAM) {
+		// Use fixed value for FDF field.
+		s->ctx_data.rx.fdf = MOTU_FDF_AM824;
+		// Not used.
+		s->ctx_data.rx.syt_override = 0xffff;
+	}
 
 	return 0;
 }

commit ab75481202d2925a017e4cb5407b0bb49c356de8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jul 22 12:36:53 2019 +0900

    ALSA: firewire-lib: pass data block counter to data block processing layer
    
    This is a preparation for future commit that 'struct
    amdtp_stream.data_block_count' does not represent the value of
    data block count for current data block.
    
    However, data block count is required for calculation of sequence index
    in sequence-multiplied data channel. Some of data block processing layer
    require it; e.g. for AM824 data block.
    
    This commit passes data block count to the processing layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 7973dedd31ef..9693f37a0032 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -299,8 +299,8 @@ static void __maybe_unused copy_message(u64 *frames, __be32 *buffer,
 }
 
 static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
-				__be32 *buffer, unsigned int data_blocks,
-				unsigned int *syt)
+			__be32 *buffer, unsigned int data_blocks,
+			unsigned int data_block_counter, unsigned int *syt)
 {
 	struct amdtp_motu *p = s->protocol;
 	struct snd_pcm_substream *pcm;
@@ -361,8 +361,8 @@ static void write_sph(struct amdtp_stream *s, __be32 *buffer,
 }
 
 static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
-				__be32 *buffer, unsigned int data_blocks,
-				unsigned int *syt)
+			__be32 *buffer, unsigned int data_blocks,
+			unsigned int data_block_counter, unsigned int *syt)
 {
 	struct amdtp_motu *p = (struct amdtp_motu *)s->protocol;
 	struct snd_pcm_substream *pcm;

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit c5dfd4b885284e4eaaf66172b918894fdde7eb06
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jun 24 18:16:46 2019 +0900

    ALSA: firewire-motu: unify common tracepoints for both direction
    
    In ALSA firewire-motu driver, some tracepoints are supported to probe
    vendor-specific data fields for SPH and status/control messages in
    payload of isochronous packet. At present, the events of tracepoints
    are unique each of direction, however the pair of events has the
    same structure and print format. It's possible to unify the pair.
    
    This commit unifies the pair. From userspace, direction is specified
    by filtering for src/dst fields in the structure.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 62685f2528ce..1c9ce04a2e89 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -306,8 +306,8 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 	struct amdtp_motu *p = s->protocol;
 	struct snd_pcm_substream *pcm;
 
-	trace_in_data_block_sph(s, data_blocks, buffer);
-	trace_in_data_block_message(s, data_blocks, buffer);
+	trace_data_block_sph(s, data_blocks, buffer);
+	trace_data_block_message(s, data_blocks, buffer);
 
 	if (p->midi_ports)
 		read_midi_messages(s, buffer, data_blocks);
@@ -384,8 +384,8 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 
 	write_sph(s, buffer, data_blocks);
 
-	trace_out_data_block_sph(s, data_blocks, buffer);
-	trace_out_data_block_message(s, data_blocks, buffer);
+	trace_data_block_sph(s, data_blocks, buffer);
+	trace_data_block_message(s, data_blocks, buffer);
 
 	return data_blocks;
 }

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index cb0c967dea63..782d1fa024ec 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * amdtp-motu.c - a part of driver for MOTU FireWire series
  *
  * Copyright (c) 2015-2017 Takashi Sakamoto <o-takashi@sakamocchi.jp>
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include <linux/slab.h>

commit d3d10a4a1b1950c2d20714c2511b5f58c99bab81
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue May 21 23:57:34 2019 +0900

    ALSA: firewire-lib: use union for directional parameters
    
    Some parameters of struct amdtp_stream is dependent on direction.
    
    This commit uses union for such parameters to distinguish from
    common parameters.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index cb0c967dea63..62685f2528ce 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -429,7 +429,7 @@ int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
 		return err;
 
 	s->sph = 1;
-	s->fdf = MOTU_FDF_AM824;
+	s->ctx_data.rx.fdf = MOTU_FDF_AM824;
 
 	return 0;
 }

commit 35033d8cb71b4dd4fa8d8d28a534af1ee921b9a0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Mar 17 16:50:24 2019 +0900

    ALSA: firewire-motu: add support MOTU 8pre FireWire
    
    This commit adds support for MOTU 8pre FireWire, which was shipped 2007
    and nowadays already discontinued. Userspace applications can transmit
    and receive PCM frames and MIDI messages for this model via ALSA PCM
    interface and RawMidi/Sequencer interfaces.
    
    Like the other models of MOTU FireWire series, this model has many
    quirks in its CIP.
    
    At first, data channels for two pairs of optical interfaces. At lower
    sampling transmission frequency, i.e. 44.1 and 48.0 kHz, one pair is
    available for ADAT data, thus 8 data chunks are transferred by CIP.
    At middle sampling transmission frequency, i.e.  88.2 and 96.0 kHz,
    two pairs are available to keep 8 chunks for ADAT data, thus CIP
    still includes 8 data chunks.
    
    Apart from data chunks for optical interface, CIP includes fixed number
    of data chunks. In tx stream, two chunks for status message, eight
    chunks for samples from analog 1-8 input, two chunks for mix-return.
    In rx stream, two chunks for control message, two chunks for main 1-2
    output, two chunks for phone 1-2 output, two chunks for dummy 1-2.
    
    CIP header in tx stream includes quirks for its dbs and dbc fields.
    The value of dbs field is fixed to 0x13, against its actual size.
    The value of dbc field is firstly updated to 0x07 from zero, then
    it's incremented continuously according to actual number of data h
    blocks.
    
    Finally, the model has own bits to disable frame fetch.
    
    This commit uses several options to absorb the above quirks.
    
    $ python2 crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  0410b57d  bus_info_length 4, crc_length 16, crc 46461
    404  31333934  bus_name "1394"
    408  20001000  irmc 0, cmc 0, isc 1, bmc 0, cyc_clk_acc 0, max_rec 1 (4)
    40c  0001f200  company_id 0001f2     |
    410  00083dfb  device_id 0000083dfb  | EUI-64 0001f20000083dfb
    
                   root directory
                   -----------------------------------------------------------------
    414  0004c65c  directory_length 4, crc 50780
    418  030001f2  vendor
    41c  0c0083c0  node capabilities per IEEE 1394
    420  8d000006  --> eui-64 leaf at 438
    424  d1000001  --> unit directory at 428
    
                   unit directory at 428
                   -----------------------------------------------------------------
    428  0003991c  directory_length 3, crc 39196
    42c  120001f2  specifier id
    430  1300000f  version
    434  17103800  model
    
                   eui-64 leaf at 438
                   -----------------------------------------------------------------
    438  00022681  leaf_length 2, crc 9857
    43c  0001f200  company_id 0001f2     |
    440  00083dfb  device_id 0000083dfb  | EUI-64 0001f20000083dfb
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 6c9b743ea74b..cb0c967dea63 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -412,6 +412,12 @@ int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
 				 CIP_HEADER_WITHOUT_EOH;
 			fmt = CIP_FMT_MOTU_TX_V3;
 		}
+
+		if (protocol == &snd_motu_protocol_v2) {
+			// 8pre has some quirks.
+			flags |= CIP_WRONG_DBS |
+				 CIP_SKIP_DBC_ZERO_CHECK;
+		}
 	} else {
 		process_data_blocks = process_rx_data_blocks;
 		flags |= CIP_DBC_IS_END_EVENT;

commit f97a0944a72b26a2bece72516294e112a890f98a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Feb 26 13:38:37 2019 +0900

    ALSA: firewire-motu: fix construction of PCM frame for capture direction
    
    In data blocks of common isochronous packet for MOTU devices, PCM
    frames are multiplexed in a shape of '24 bit * 4 Audio Pack', described
    in IEC 61883-6. The frames are not aligned to quadlet.
    
    For capture PCM substream, ALSA firewire-motu driver constructs PCM
    frames by reading data blocks byte-by-byte. However this operation
    includes bug for lower byte of the PCM sample. This brings invalid
    content of the PCM samples.
    
    This commit fixes the bug.
    
    Reported-by: Peter Sjöberg <autopeter@gmail.com>
    Cc: <stable@vger.kernel.org> # v4.12+
    Fixes: 4641c9394010 ("ALSA: firewire-motu: add MOTU specific protocol layer")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index f0555a24d90e..6c9b743ea74b 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -136,7 +136,9 @@ static void read_pcm_s32(struct amdtp_stream *s,
 		byte = (u8 *)buffer + p->pcm_byte_offset;
 
 		for (c = 0; c < channels; ++c) {
-			*dst = (byte[0] << 24) | (byte[1] << 16) | byte[2];
+			*dst = (byte[0] << 24) |
+			       (byte[1] << 16) |
+			       (byte[2] << 8);
 			byte += 3;
 			dst++;
 		}

commit 6aa7de059173a986114ac43b8f50b297a86f09a8
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Oct 23 14:07:29 2017 -0700

    locking/atomics: COCCINELLE/treewide: Convert trivial ACCESS_ONCE() patterns to READ_ONCE()/WRITE_ONCE()
    
    Please do not apply this to mainline directly, instead please re-run the
    coccinelle script shown below and apply its output.
    
    For several reasons, it is desirable to use {READ,WRITE}_ONCE() in
    preference to ACCESS_ONCE(), and new code is expected to use one of the
    former. So far, there's been no reason to change most existing uses of
    ACCESS_ONCE(), as these aren't harmful, and changing them results in
    churn.
    
    However, for some features, the read/write distinction is critical to
    correct operation. To distinguish these cases, separate read/write
    accessors must be used. This patch migrates (most) remaining
    ACCESS_ONCE() instances to {READ,WRITE}_ONCE(), using the following
    coccinelle script:
    
    ----
    // Convert trivial ACCESS_ONCE() uses to equivalent READ_ONCE() and
    // WRITE_ONCE()
    
    // $ make coccicheck COCCI=/home/mark/once.cocci SPFLAGS="--include-headers" MODE=patch
    
    virtual patch
    
    @ depends on patch @
    expression E1, E2;
    @@
    
    - ACCESS_ONCE(E1) = E2
    + WRITE_ONCE(E1, E2)
    
    @ depends on patch @
    expression E;
    @@
    
    - ACCESS_ONCE(E)
    + READ_ONCE(E)
    ----
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: davem@davemloft.net
    Cc: linux-arch@vger.kernel.org
    Cc: mpe@ellerman.id.au
    Cc: shuah@kernel.org
    Cc: snitzer@redhat.com
    Cc: thor.thayer@linux.intel.com
    Cc: tj@kernel.org
    Cc: viro@zeniv.linux.org.uk
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1508792849-3115-19-git-send-email-paulmck@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 96f0091144bb..f0555a24d90e 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -310,7 +310,7 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 	if (p->midi_ports)
 		read_midi_messages(s, buffer, data_blocks);
 
-	pcm = ACCESS_ONCE(s->pcm);
+	pcm = READ_ONCE(s->pcm);
 	if (data_blocks > 0 && pcm)
 		read_pcm_s32(s, pcm->runtime, buffer, data_blocks);
 
@@ -374,7 +374,7 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 	if (p->midi_ports)
 		write_midi_messages(s, buffer, data_blocks);
 
-	pcm = ACCESS_ONCE(s->pcm);
+	pcm = READ_ONCE(s->pcm);
 	if (pcm)
 		write_pcm_s32(s, pcm->runtime, buffer, data_blocks);
 	else

commit fa8323bf49f5c92363fe7c3c80b6b342f5430baa
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Apr 19 19:51:29 2017 +0200

    ALSA: firewire-motu: mark trace helpers as __maybe_unused
    
    Two functions were introduced for the purpose of tracing but cause warnings
    when tracing is disabled:
    
    sound/firewire/motu/amdtp-motu.c:284:13: error: 'copy_message' defined but not used [-Werror=unused-function]
     static void copy_message(u64 *frames, __be32 *buffer, unsigned int data_blocks,
    sound/firewire/motu/amdtp-motu.c:271:13: error: 'copy_sph' defined but not used [-Werror=unused-function]
     static void copy_sph(u32 *frames, __be32 *buffer, unsigned int data_blocks,
    
    Marking them as __maybe_unused will do the right thing here.
    
    Fixes: 17909c1b3058 ("ALSA: firewire-motu: add tracepoints for SPH in IEC 61883-1 fashion")
    Fixes: c6b0b9e65f09 ("ALSA: firewire-motu: add tracepoints for messages for unique protocol")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 996b5f818918..96f0091144bb 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -268,8 +268,9 @@ static void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,
 }
 
 /* For tracepoints. */
-static void copy_sph(u32 *frames, __be32 *buffer, unsigned int data_blocks,
-		     unsigned int data_block_quadlets)
+static void __maybe_unused copy_sph(u32 *frames, __be32 *buffer,
+				    unsigned int data_blocks,
+				    unsigned int data_block_quadlets)
 {
 	unsigned int i;
 
@@ -281,8 +282,9 @@ static void copy_sph(u32 *frames, __be32 *buffer, unsigned int data_blocks,
 }
 
 /* For tracepoints. */
-static void copy_message(u64 *frames, __be32 *buffer, unsigned int data_blocks,
-			 unsigned int data_block_quadlets)
+static void __maybe_unused copy_message(u64 *frames, __be32 *buffer,
+					unsigned int data_blocks,
+					unsigned int data_block_quadlets)
 {
 	unsigned int i;
 

commit c6b0b9e65f094deabc0c1d499b96ed5085b0f7db
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Apr 9 21:33:29 2017 +0900

    ALSA: firewire-motu: add tracepoints for messages for unique protocol
    
    MOTU units transfer/receive messages in each data block of their
    isochronous packet payload. A part of content in the message is cleard for
    MIDI message transmission, while the rest is unknown yet. Additional
    features are required to assist users and developers to reveal the
    details.
    
    This commit adds tracepoints for the purpose. The tracepoints are designed
    for MOTU's protocol version 2 and 3 (Protocol version 1 is not upstreamed
    yet). In the tracepoints, events are probed to gather first two 24 bit
    data chunks of each data block. The chunks are formatted into elements
    of 64 bit array with padding in MSB.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 2c77e8bb5424..996b5f818918 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -280,6 +280,21 @@ static void copy_sph(u32 *frames, __be32 *buffer, unsigned int data_blocks,
 	}
 }
 
+/* For tracepoints. */
+static void copy_message(u64 *frames, __be32 *buffer, unsigned int data_blocks,
+			 unsigned int data_block_quadlets)
+{
+	unsigned int i;
+
+	/* This is just for v2/v3 protocol. */
+	for (i = 0; i < data_blocks; ++i) {
+		*frames = (be32_to_cpu(buffer[1]) << 16) |
+			  (be32_to_cpu(buffer[2]) >> 16);
+		buffer += data_block_quadlets;
+		frames++;
+	}
+}
+
 static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 				__be32 *buffer, unsigned int data_blocks,
 				unsigned int *syt)
@@ -288,6 +303,7 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 	struct snd_pcm_substream *pcm;
 
 	trace_in_data_block_sph(s, data_blocks, buffer);
+	trace_in_data_block_message(s, data_blocks, buffer);
 
 	if (p->midi_ports)
 		read_midi_messages(s, buffer, data_blocks);
@@ -365,6 +381,7 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 	write_sph(s, buffer, data_blocks);
 
 	trace_out_data_block_sph(s, data_blocks, buffer);
+	trace_out_data_block_message(s, data_blocks, buffer);
 
 	return data_blocks;
 }

commit 17909c1b3058b315698965aeb33ed6434501567c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Apr 9 21:33:28 2017 +0900

    ALSA: firewire-motu: add tracepoints for SPH in IEC 61883-1 fashion
    
    Unique protocol is used for MOTU FireWire series. In this protocol,
    data block format is not compliant to AM824 in IEC 61883-1/6. Each of
    the data block consists of 24 bit data chunks, except for a first
    quadlet. The quadlet is used for source packet header (SPH) described
    in IEC 61883-1.
    
    The sequence of SPH seems to represent presentation timestamp
    corresponding to included data. Developers have experienced that invalid
    sequence brings disorder of units in the series.
    
    Unfortunately, current implementation of ALSA IEC 61883-1/6 engine and
    firewire-motu driver brings periodical noises to the units at sampling
    transmission frequency based on 44.1 kHz. The engine generates the SPH with
    even interval and this mechanism seems not to be suitable to the units.
    Further work is required for this issue and infrastructure is preferable
    to assist the work.
    
    This commit adds tracepoints for the purpose. In the tracepoints, events
    are probed to gather the SPHs from each data blocks.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 08bd1760b1b4..2c77e8bb5424 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -10,6 +10,9 @@
 #include <sound/pcm.h>
 #include "motu.h"
 
+#define CREATE_TRACE_POINTS
+#include "amdtp-motu-trace.h"
+
 #define CIP_FMT_MOTU		0x02
 #define CIP_FMT_MOTU_TX_V3	0x22
 #define MOTU_FDF_AM824		0x22
@@ -264,6 +267,19 @@ static void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,
 	}
 }
 
+/* For tracepoints. */
+static void copy_sph(u32 *frames, __be32 *buffer, unsigned int data_blocks,
+		     unsigned int data_block_quadlets)
+{
+	unsigned int i;
+
+	for (i = 0; i < data_blocks; ++i) {
+		*frames = be32_to_cpu(*buffer);
+		buffer += data_block_quadlets;
+		frames++;
+	}
+}
+
 static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 				__be32 *buffer, unsigned int data_blocks,
 				unsigned int *syt)
@@ -271,6 +287,8 @@ static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 	struct amdtp_motu *p = s->protocol;
 	struct snd_pcm_substream *pcm;
 
+	trace_in_data_block_sph(s, data_blocks, buffer);
+
 	if (p->midi_ports)
 		read_midi_messages(s, buffer, data_blocks);
 
@@ -346,6 +364,8 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 
 	write_sph(s, buffer, data_blocks);
 
+	trace_out_data_block_sph(s, data_blocks, buffer);
+
 	return data_blocks;
 }
 

commit 5992e30034c43917968f2327d2948d22be6d4603
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:28 2017 +0900

    ALSA: firewire-motu: add support for MOTU 828mk3 (FireWire/Hybrid) as a model with protocol version 3
    
    MOTU 828mk3 (FireWire/Hybrid) is one of third generation in MOTU FireWire
    series, produced in 2008/2014. This model consists of three chips for
    functionality on IEEE 1394 bus:
    
     * TI TSB41AB2 (Physical layer for IEEE 1394 bus)
     * Xilinx Spartan-3E FPGA Family (Link layer for IEEE 1394 bus, packet
       processing and data block processing layer)
     * TI TMS320C6722 (Digital signal processing)
    
    This commit adds a support for this model, with its unique protocol as
    version 3. This protocol has some additional features to protocol
    version 2.
    
     * Support several optical interfaces.
     * Support a data chunk for return of reverb effect.
     * Have a quirk of tx packets.
     * Support heartbeat asynchronous transaction.
    
    In this protocol, series of transferred packets has some quirks. Below
    fields in CIP headers of the packets are out of IEC 61883-1:
     - SID (source node id): always 0x0d
     - DBS (data block size): always 0x04
     - DBC (data block counter): always 0x00
     - EOH (End of header): always 0x00
    
    Below is an actual sample of transferred packets.
    
    quads CIP1       CIP2
    520   0x0D040400 0x22FFFFFF
      8   0x0D040400 0x22FFFFFF
    520   0x0D040400 0x22FFFFFF
    520   0x0D040400 0x22FFFFFF
      8   0x0D040400 0x22FFFFFF
    
    Status of clock is configured by write transactions to 0x'ffff'f000'0b14,
    as well as version 2, while meanings of fields are different from the
    former protocols. Modes of optical interfaces are configured by write
    transactions to 0x'ffff'f000'0c94.
    
    Drivers can register its address to receive heatbeat transactions from the
    unit. 0x'ffff'f000'0b0c is for the higher part and 0x'ffff'f000'0b10 is
    for the lower part. Nevertheless, this feature is not useless for this
    driver and this commit omits it.
    
    Each data block consists of two parts in a point of the number of included
    data chunks. In both of 'fixed' and 'differed' parts, the number of
    included data blocks are a multiple of 4, thus depending on models there's
    some empty data chunks. For example, 828mk3 includes one pair of empty
    data chunks in its fixed part. When optical interface is configured to
    S/PDIF, 828mk3 includes one pair of empty data chunks in its differed part.
    To reduce consumption of CPU cycles with additional conditions/loops, this
    commit just exposes these empty chunks to user space as PCM channels.
    
    Additionally, 828mk3 has a non-negligible overhead to change its sampling
    transfer frequency. When softwares send asynchronous transaction to
    perform it, LED on the unit starts to blink. In a worst case, it continues
    blink during several seconds; e.g. 10 seconds. When stopping blinking,
    the unit seems to be prepared for the requested sampling transfer
    frequency. To wait for the preparation, this commit forces the driver
    to call task scheduler and applications sleeps for 4 seconds.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 0930cd8ca2cb..08bd1760b1b4 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -11,6 +11,7 @@
 #include "motu.h"
 
 #define CIP_FMT_MOTU		0x02
+#define CIP_FMT_MOTU_TX_V3	0x22
 #define MOTU_FDF_AM824		0x22
 
 /*
@@ -359,6 +360,17 @@ int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
 
 	if (dir == AMDTP_IN_STREAM) {
 		process_data_blocks = process_tx_data_blocks;
+
+		/*
+		 * Units of version 3 transmits packets with invalid CIP header
+		 * against IEC 61883-1.
+		 */
+		if (protocol == &snd_motu_protocol_v3) {
+			flags |= CIP_WRONG_DBS |
+				 CIP_SKIP_DBC_ZERO_CHECK |
+				 CIP_HEADER_WITHOUT_EOH;
+			fmt = CIP_FMT_MOTU_TX_V3;
+		}
 	} else {
 		process_data_blocks = process_rx_data_blocks;
 		flags |= CIP_DBC_IS_END_EVENT;

commit 9e796e7d59e71f8a556cfbdc2ffa3aff0555dd0e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:23 2017 +0900

    ALSA: firewire-motu: add MIDI functionality
    
    In MOTU FireWire series, MIDI messages are multiplexed to isochronous
    packets as well as PCM frames, while the way is different from the one
    in IEC 61883-6.
    
    MIDI messages are put into a certain position in message chunks. One data
    block can includes one byte of the MIDI messages. When data block includes
    a MIDI byte, the block has a flag in a certain position of the message
    chunk. These positions are unique depending on protocols.
    
    Once a data block includes a MIDI byte, some following data blocks includes
    no MIDI bytes. Next MIDI byte appears on a data block corresponding to
    next cycle of physical MIDI bus. This seems to avoid buffer overflow caused
    by bandwidth differences between IEEE 1394 bus and physical MIDI bus.
    
    This commit adds MIDI functionality to transfer/receive MIDI messages.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
index 11e44123ad65..0930cd8ca2cb 100644
--- a/sound/firewire/motu/amdtp-motu.c
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -13,6 +13,12 @@
 #define CIP_FMT_MOTU		0x02
 #define MOTU_FDF_AM824		0x22
 
+/*
+ * Nominally 3125 bytes/second, but the MIDI port's clock might be
+ * 1% too slow, and the bus clock 100 ppm too fast.
+ */
+#define MIDI_BYTES_PER_SECOND	3093
+
 struct amdtp_motu {
 	/* For timestamp processing.  */
 	unsigned int quotient_ticks_per_event;
@@ -24,9 +30,18 @@ struct amdtp_motu {
 
 	unsigned int pcm_chunks;
 	unsigned int pcm_byte_offset;
+
+	struct snd_rawmidi_substream *midi;
+	unsigned int midi_ports;
+	unsigned int midi_flag_offset;
+	unsigned int midi_byte_offset;
+
+	int midi_db_count;
+	unsigned int midi_db_interval;
 };
 
 int amdtp_motu_set_parameters(struct amdtp_stream *s, unsigned int rate,
+			      unsigned int midi_ports,
 			      struct snd_motu_packet_format *formats)
 {
 	static const struct {
@@ -76,6 +91,13 @@ int amdtp_motu_set_parameters(struct amdtp_stream *s, unsigned int rate,
 	p->pcm_chunks = pcm_chunks;
 	p->pcm_byte_offset = formats->pcm_byte_offset;
 
+	p->midi_ports = midi_ports;
+	p->midi_flag_offset = formats->midi_flag_offset;
+	p->midi_byte_offset = formats->midi_byte_offset;
+
+	p->midi_db_count = 0;
+	p->midi_db_interval = rate / MIDI_BYTES_PER_SECOND;
+
 	/* IEEE 1394 bus requires. */
 	delay = 0x2e00;
 
@@ -187,12 +209,70 @@ int amdtp_motu_add_pcm_hw_constraints(struct amdtp_stream *s,
 	return amdtp_stream_add_pcm_hw_constraints(s, runtime);
 }
 
+void amdtp_motu_midi_trigger(struct amdtp_stream *s, unsigned int port,
+			     struct snd_rawmidi_substream *midi)
+{
+	struct amdtp_motu *p = s->protocol;
+
+	if (port < p->midi_ports)
+		WRITE_ONCE(p->midi, midi);
+}
+
+static void write_midi_messages(struct amdtp_stream *s, __be32 *buffer,
+				unsigned int data_blocks)
+{
+	struct amdtp_motu *p = s->protocol;
+	struct snd_rawmidi_substream *midi = READ_ONCE(p->midi);
+	u8 *b;
+	int i;
+
+	for (i = 0; i < data_blocks; i++) {
+		b = (u8 *)buffer;
+
+		if (midi && p->midi_db_count == 0 &&
+		    snd_rawmidi_transmit(midi, b + p->midi_byte_offset, 1) == 1) {
+			b[p->midi_flag_offset] = 0x01;
+		} else {
+			b[p->midi_byte_offset] = 0x00;
+			b[p->midi_flag_offset] = 0x00;
+		}
+
+		buffer += s->data_block_quadlets;
+
+		if (--p->midi_db_count < 0)
+			p->midi_db_count = p->midi_db_interval;
+	}
+}
+
+static void read_midi_messages(struct amdtp_stream *s, __be32 *buffer,
+			       unsigned int data_blocks)
+{
+	struct amdtp_motu *p = s->protocol;
+	struct snd_rawmidi_substream *midi;
+	u8 *b;
+	int i;
+
+	for (i = 0; i < data_blocks; i++) {
+		b = (u8 *)buffer;
+		midi = READ_ONCE(p->midi);
+
+		if (midi && (b[p->midi_flag_offset] & 0x01))
+			snd_rawmidi_receive(midi, b + p->midi_byte_offset, 1);
+
+		buffer += s->data_block_quadlets;
+	}
+}
+
 static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
 				__be32 *buffer, unsigned int data_blocks,
 				unsigned int *syt)
 {
+	struct amdtp_motu *p = s->protocol;
 	struct snd_pcm_substream *pcm;
 
+	if (p->midi_ports)
+		read_midi_messages(s, buffer, data_blocks);
+
 	pcm = ACCESS_ONCE(s->pcm);
 	if (data_blocks > 0 && pcm)
 		read_pcm_s32(s, pcm->runtime, buffer, data_blocks);
@@ -246,6 +326,7 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 				__be32 *buffer, unsigned int data_blocks,
 				unsigned int *syt)
 {
+	struct amdtp_motu *p = (struct amdtp_motu *)s->protocol;
 	struct snd_pcm_substream *pcm;
 
 	/* Not used. */
@@ -253,6 +334,9 @@ static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
 
 	/* TODO: how to interact control messages between userspace? */
 
+	if (p->midi_ports)
+		write_midi_messages(s, buffer, data_blocks);
+
 	pcm = ACCESS_ONCE(s->pcm);
 	if (pcm)
 		write_pcm_s32(s, pcm->runtime, buffer, data_blocks);

commit 4641c939401076c0ab7faba024827069723f719c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 22 21:30:18 2017 +0900

    ALSA: firewire-motu: add MOTU specific protocol layer
    
    MOTU FireWire series uses blocking transmission for AMDTP packet streaming.
    They transmit/receive 8,000 packets per second, to handle the same number
    of data blocks as current sampling transmission frequency. Thus,
    IEC 61883-1/6 packet streaming engine of ALSA firewire stack is available
    for them.
    
    However, the sequence of packet and data blocks includes some quirks.
    Below sample is a sequence of CIP headers of packets received by 828mk2,
    at 44.1kHz of sampling transmission frequency.
    
    quads CIP1        CIP2
    488   0x020F04E8  0x8222FFFF
      8   0x020F04F8  0x8222FFFF
    488   0x020F0400  0x8222FFFF
    488   0x020F0408  0x8222FFFF
      8   0x020F04E8  0x8222FFFF
    488   0x020F04F0  0x8222FFFF
    488   0x020F04F8  0x8222FFFF
    
    The SID (source node ID), DBS (data block size), SPH (source packet header),
    FMT (format ID), FDF (format dependent field) and SYT (time stamp) fields
    are in IEC 61883-1. Especially, FMT is 0x02, FDF is 0x22 and SYT is 0xffff
    to define MOTU specific protocol. In an aspect of dbc field, the value
    represents accumulated number of data blocks included the packet. This
    is against IEC 61883-1, because according to the specification this value
    should be the number of data blocks already transferred.
    
    In ALSA IEC 61883-1/6 engine, this quirk is already supported by
    CIP_DBC_IS_END_EVENT flag, because Echo Audio Fireworks has.
    
    Each data block includes SPH as its first quadlet field, to represent its
    presentation time stamp. Actual value of SPH is compliant to IEC 61883-1;
    lower 25 bits of 32 bits width consists of 13 bits cycle count and 12 bits
    cycle offset.
    
    The rest of each data block consists of 24 bit chunks. All of PCM samples,
    MIDI messages, status and control messages are transferred by the chunks.
    This is similar to '24-bit * 4 Audio Pack' in IEC 61883-6. The position of
    each kind of data depends on generations of each model. The number of
    whole chunks in a data block is a multiple of 4, to consists of
    quadlet-aligned packets.
    
    This commit adds data block processing layer specific for the MOTU
    protocol. The remarkable point is the way to generate SPH header. Time
    stamps for each data blocks are generated by below calculation:
    
     * Using pre-computed table for the number of ticks per event
      *  44,1kHz: (557 + 123/441)
      *  48.0kHz: (512 +   0/441)
      *  88.2kHz: (278 + 282/441)
      *  96.0kHz: (256 +   0/441)
      * 176.4kHz: (139 + 141/441)
      * 192.0kHz: (128 +   0/441)
     * Accumulate the ticks and set the value to SPH for every events.
     * This way makes sense only for blocking transmission because this mode
       transfers fixed number or none of events.
    
    This calculation assumes that each data block has a PCM frame which is
    sampled according to event timing clock. Current packet streaming layer
    has the same assumption.
    
    Although this sequence works fine for MOTU FireWire series at sampling
    transmission frequency based on 48.0kHz, it is not enough at the frequency
    based on 44.1kHz. The units generate choppy noise every few seconds.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/motu/amdtp-motu.c b/sound/firewire/motu/amdtp-motu.c
new file mode 100644
index 000000000000..11e44123ad65
--- /dev/null
+++ b/sound/firewire/motu/amdtp-motu.c
@@ -0,0 +1,292 @@
+/*
+ * amdtp-motu.c - a part of driver for MOTU FireWire series
+ *
+ * Copyright (c) 2015-2017 Takashi Sakamoto <o-takashi@sakamocchi.jp>
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include "motu.h"
+
+#define CIP_FMT_MOTU		0x02
+#define MOTU_FDF_AM824		0x22
+
+struct amdtp_motu {
+	/* For timestamp processing.  */
+	unsigned int quotient_ticks_per_event;
+	unsigned int remainder_ticks_per_event;
+	unsigned int next_ticks;
+	unsigned int next_accumulated;
+	unsigned int next_cycles;
+	unsigned int next_seconds;
+
+	unsigned int pcm_chunks;
+	unsigned int pcm_byte_offset;
+};
+
+int amdtp_motu_set_parameters(struct amdtp_stream *s, unsigned int rate,
+			      struct snd_motu_packet_format *formats)
+{
+	static const struct {
+		unsigned int quotient_ticks_per_event;
+		unsigned int remainder_ticks_per_event;
+	} params[] = {
+		[CIP_SFC_44100]  = { 557, 123 },
+		[CIP_SFC_48000]  = { 512,   0 },
+		[CIP_SFC_88200]  = { 278, 282 },
+		[CIP_SFC_96000]  = { 256,   0 },
+		[CIP_SFC_176400] = { 139, 141 },
+		[CIP_SFC_192000] = { 128,   0 },
+	};
+	struct amdtp_motu *p = s->protocol;
+	unsigned int pcm_chunks, data_chunks, data_block_quadlets;
+	unsigned int delay;
+	unsigned int mode;
+	int i, err;
+
+	if (amdtp_stream_running(s))
+		return -EBUSY;
+
+	for (i = 0; i < ARRAY_SIZE(snd_motu_clock_rates); ++i) {
+		if (snd_motu_clock_rates[i] == rate) {
+			mode = i >> 1;
+			break;
+		}
+	}
+	if (i == ARRAY_SIZE(snd_motu_clock_rates))
+		return -EINVAL;
+
+	pcm_chunks = formats->fixed_part_pcm_chunks[mode] +
+		     formats->differed_part_pcm_chunks[mode];
+	data_chunks = formats->msg_chunks + pcm_chunks;
+
+	/*
+	 * Each data block includes SPH in its head. Data chunks follow with
+	 * 3 byte alignment. Padding follows with zero to conform to quadlet
+	 * alignment.
+	 */
+	data_block_quadlets = 1 + DIV_ROUND_UP(data_chunks * 3, 4);
+
+	err = amdtp_stream_set_parameters(s, rate, data_block_quadlets);
+	if (err < 0)
+		return err;
+
+	p->pcm_chunks = pcm_chunks;
+	p->pcm_byte_offset = formats->pcm_byte_offset;
+
+	/* IEEE 1394 bus requires. */
+	delay = 0x2e00;
+
+	/* For no-data or empty packets to adjust PCM sampling frequency. */
+	delay += 8000 * 3072 * s->syt_interval / rate;
+
+	p->next_seconds = 0;
+	p->next_cycles = delay / 3072;
+	p->quotient_ticks_per_event = params[s->sfc].quotient_ticks_per_event;
+	p->remainder_ticks_per_event = params[s->sfc].remainder_ticks_per_event;
+	p->next_ticks = delay % 3072;
+	p->next_accumulated = 0;
+
+	return 0;
+}
+
+static void read_pcm_s32(struct amdtp_stream *s,
+			 struct snd_pcm_runtime *runtime,
+			 __be32 *buffer, unsigned int data_blocks)
+{
+	struct amdtp_motu *p = s->protocol;
+	unsigned int channels, remaining_frames, i, c;
+	u8 *byte;
+	u32 *dst;
+
+	channels = p->pcm_chunks;
+	dst = (void *)runtime->dma_area +
+			frames_to_bytes(runtime, s->pcm_buffer_pointer);
+	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
+
+	for (i = 0; i < data_blocks; ++i) {
+		byte = (u8 *)buffer + p->pcm_byte_offset;
+
+		for (c = 0; c < channels; ++c) {
+			*dst = (byte[0] << 24) | (byte[1] << 16) | byte[2];
+			byte += 3;
+			dst++;
+		}
+		buffer += s->data_block_quadlets;
+		if (--remaining_frames == 0)
+			dst = (void *)runtime->dma_area;
+	}
+}
+
+static void write_pcm_s32(struct amdtp_stream *s,
+			  struct snd_pcm_runtime *runtime,
+			  __be32 *buffer, unsigned int data_blocks)
+{
+	struct amdtp_motu *p = s->protocol;
+	unsigned int channels, remaining_frames, i, c;
+	u8 *byte;
+	const u32 *src;
+
+	channels = p->pcm_chunks;
+	src = (void *)runtime->dma_area +
+			frames_to_bytes(runtime, s->pcm_buffer_pointer);
+	remaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;
+
+	for (i = 0; i < data_blocks; ++i) {
+		byte = (u8 *)buffer + p->pcm_byte_offset;
+
+		for (c = 0; c < channels; ++c) {
+			byte[0] = (*src >> 24) & 0xff;
+			byte[1] = (*src >> 16) & 0xff;
+			byte[2] = (*src >>  8) & 0xff;
+			byte += 3;
+			src++;
+		}
+
+		buffer += s->data_block_quadlets;
+		if (--remaining_frames == 0)
+			src = (void *)runtime->dma_area;
+	}
+}
+
+static void write_pcm_silence(struct amdtp_stream *s, __be32 *buffer,
+			      unsigned int data_blocks)
+{
+	struct amdtp_motu *p = s->protocol;
+	unsigned int channels, i, c;
+	u8 *byte;
+
+	channels = p->pcm_chunks;
+
+	for (i = 0; i < data_blocks; ++i) {
+		byte = (u8 *)buffer + p->pcm_byte_offset;
+
+		for (c = 0; c < channels; ++c) {
+			byte[0] = 0;
+			byte[1] = 0;
+			byte[2] = 0;
+			byte += 3;
+		}
+
+		buffer += s->data_block_quadlets;
+	}
+}
+
+int amdtp_motu_add_pcm_hw_constraints(struct amdtp_stream *s,
+				      struct snd_pcm_runtime *runtime)
+{
+	int err;
+
+	/* TODO: how to set an constraint for exactly 24bit PCM sample? */
+	err = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+	if (err < 0)
+		return err;
+
+	return amdtp_stream_add_pcm_hw_constraints(s, runtime);
+}
+
+static unsigned int process_tx_data_blocks(struct amdtp_stream *s,
+				__be32 *buffer, unsigned int data_blocks,
+				unsigned int *syt)
+{
+	struct snd_pcm_substream *pcm;
+
+	pcm = ACCESS_ONCE(s->pcm);
+	if (data_blocks > 0 && pcm)
+		read_pcm_s32(s, pcm->runtime, buffer, data_blocks);
+
+	return data_blocks;
+}
+
+static inline void compute_next_elapse_from_start(struct amdtp_motu *p)
+{
+	p->next_accumulated += p->remainder_ticks_per_event;
+	if (p->next_accumulated >= 441) {
+		p->next_accumulated -= 441;
+		p->next_ticks++;
+	}
+
+	p->next_ticks += p->quotient_ticks_per_event;
+	if (p->next_ticks >= 3072) {
+		p->next_ticks -= 3072;
+		p->next_cycles++;
+	}
+
+	if (p->next_cycles >= 8000) {
+		p->next_cycles -= 8000;
+		p->next_seconds++;
+	}
+
+	if (p->next_seconds >= 128)
+		p->next_seconds -= 128;
+}
+
+static void write_sph(struct amdtp_stream *s, __be32 *buffer,
+		      unsigned int data_blocks)
+{
+	struct amdtp_motu *p = s->protocol;
+	unsigned int next_cycles;
+	unsigned int i;
+	u32 sph;
+
+	for (i = 0; i < data_blocks; i++) {
+		next_cycles = (s->start_cycle + p->next_cycles) % 8000;
+		sph = ((next_cycles << 12) | p->next_ticks) & 0x01ffffff;
+		*buffer = cpu_to_be32(sph);
+
+		compute_next_elapse_from_start(p);
+
+		buffer += s->data_block_quadlets;
+	}
+}
+
+static unsigned int process_rx_data_blocks(struct amdtp_stream *s,
+				__be32 *buffer, unsigned int data_blocks,
+				unsigned int *syt)
+{
+	struct snd_pcm_substream *pcm;
+
+	/* Not used. */
+	*syt = 0xffff;
+
+	/* TODO: how to interact control messages between userspace? */
+
+	pcm = ACCESS_ONCE(s->pcm);
+	if (pcm)
+		write_pcm_s32(s, pcm->runtime, buffer, data_blocks);
+	else
+		write_pcm_silence(s, buffer, data_blocks);
+
+	write_sph(s, buffer, data_blocks);
+
+	return data_blocks;
+}
+
+int amdtp_motu_init(struct amdtp_stream *s, struct fw_unit *unit,
+		    enum amdtp_stream_direction dir,
+		    const struct snd_motu_protocol *const protocol)
+{
+	amdtp_stream_process_data_blocks_t process_data_blocks;
+	int fmt = CIP_FMT_MOTU;
+	int flags = CIP_BLOCKING;
+	int err;
+
+	if (dir == AMDTP_IN_STREAM) {
+		process_data_blocks = process_tx_data_blocks;
+	} else {
+		process_data_blocks = process_rx_data_blocks;
+		flags |= CIP_DBC_IS_END_EVENT;
+	}
+
+	err = amdtp_stream_init(s, unit, dir, flags, fmt, process_data_blocks,
+				sizeof(struct amdtp_motu));
+	if (err < 0)
+		return err;
+
+	s->sph = 1;
+	s->fdf = MOTU_FDF_AM824;
+
+	return 0;
+}
