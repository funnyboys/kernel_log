commit 06a42a74a0e704458754bdc5f29cf62cc1ce4b53
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jan 13 16:34:17 2020 +0900

    ALSA: oxfw: don't add MIDI/PCM interface when packet streaming is unavailable
    
    Stanton SCS.1d doesn't support packet streaming even if it has plugs for
    isochronous communication.
    
    This commit is a preparation for this case. The 'has_input' member is
    added to specific structure, and MIDI/PCM interfaces are not added when
    the member is false.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200113073418.24622-3-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index fb6df3fc018e..1f1e3236efb8 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -118,7 +118,8 @@ static void oxfw_card_free(struct snd_card *card)
 {
 	struct snd_oxfw *oxfw = card->private_data;
 
-	snd_oxfw_stream_destroy_duplex(oxfw);
+	if (oxfw->has_output || oxfw->has_input)
+		snd_oxfw_stream_destroy_duplex(oxfw);
 }
 
 static int detect_quirks(struct snd_oxfw *oxfw)
@@ -206,23 +207,25 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	err = snd_oxfw_stream_init_duplex(oxfw);
-	if (err < 0)
-		goto error;
+	if (oxfw->has_output || oxfw->has_input) {
+		err = snd_oxfw_stream_init_duplex(oxfw);
+		if (err < 0)
+			goto error;
 
-	err = snd_oxfw_create_pcm(oxfw);
-	if (err < 0)
-		goto error;
+		err = snd_oxfw_create_pcm(oxfw);
+		if (err < 0)
+			goto error;
 
-	snd_oxfw_proc_init(oxfw);
+		snd_oxfw_proc_init(oxfw);
 
-	err = snd_oxfw_create_midi(oxfw);
-	if (err < 0)
-		goto error;
+		err = snd_oxfw_create_midi(oxfw);
+		if (err < 0)
+			goto error;
 
-	err = snd_oxfw_create_hwdep(oxfw);
-	if (err < 0)
-		goto error;
+		err = snd_oxfw_create_hwdep(oxfw);
+		if (err < 0)
+			goto error;
+	}
 
 	err = snd_card_register(oxfw->card);
 	if (err < 0)
@@ -274,9 +277,11 @@ static void oxfw_bus_reset(struct fw_unit *unit)
 	fcp_bus_reset(oxfw->unit);
 
 	if (oxfw->registered) {
-		mutex_lock(&oxfw->mutex);
-		snd_oxfw_stream_update_duplex(oxfw);
-		mutex_unlock(&oxfw->mutex);
+		if (oxfw->has_output || oxfw->has_input) {
+			mutex_lock(&oxfw->mutex);
+			snd_oxfw_stream_update_duplex(oxfw);
+			mutex_unlock(&oxfw->mutex);
+		}
 
 		if (oxfw->entry->vendor_id == OUI_STANTON)
 			snd_oxfw_scs1x_update(oxfw);

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit b5c21c84705dbd96a0fff930d33022a17910b4f4
Merge: 7c2b3629d09d 7fbd1753b64e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 1 17:01:00 2019 +0200

    Merge branch 'for-linus' into for-next
    
    This back-merge is necessary for adjusting the latest FireWire fix
    with the recent refactoring in 5.3 development branch.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit bcb46a0e0e5c79291ffbc1e4b5d1d3d119e0f984
Merge: c11fb13a117e 17d304604a88
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 14 05:37:06 2019 -1000

    Merge tag 'sound-5.2-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound fixes from Takashi Iwai:
     "It might feel like deja vu to receive a bulk of changes at rc5, and it
      happens again; we've got a collection of fixes for ASoC. Most of fixes
      are targeted for the newly merged SOF (Sound Open Firmware) stuff and
      the relevant fixes for Intel platforms.
    
      Other than that, there are a few regression fixes for the recent ASoC
      core changes and HD-audio quirk, as well as a couple of FireWire fixes
      and for other ASoC codecs"
    
    * tag 'sound-5.2-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (54 commits)
      Revert "ALSA: hda/realtek - Improve the headset mic for Acer Aspire laptops"
      ALSA: ice1712: Check correct return value to snd_i2c_sendbytes (EWS/DMX 6Fire)
      ALSA: oxfw: allow PCM capture for Stanton SCS.1m
      ALSA: firewire-motu: fix destruction of data for isochronous resources
      ASoC: Intel: sst: fix kmalloc call with wrong flags
      ASoC: core: Fix deadlock in snd_soc_instantiate_card()
      SoC: rt274: Fix internal jack assignment in set_jack callback
      ALSA: hdac: fix memory release for SST and SOF drivers
      ASoC: SOF: Intel: hda: use the defined ppcap functions
      ASoC: core: move DAI pre-links initiation to snd_soc_instantiate_card
      ASoC: Intel: cht_bsw_rt5672: fix kernel oops with platform_name override
      ASoC: Intel: cht_bsw_nau8824: fix kernel oops with platform_name override
      ASoC: Intel: bytcht_es8316: fix kernel oops with platform_name override
      ASoC: Intel: cht_bsw_max98090: fix kernel oops with platform_name override
      ASoC: sun4i-i2s: Add offset to RX channel select
      ASoC: sun4i-i2s: Fix sun8i tx channel offset mask
      ASoC: max98090: remove 24-bit format support if RJ is 0
      ASoC: da7219: Fix build error without CONFIG_I2C
      ASoC: SOF: Intel: hda: Fix COMPILE_TEST build error
      ASoC: SOF: fix DSP oops definitions in FW ABI
      ...

commit 779f0dba0b99f32276315ba40e812648b6ceed34
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:19 2019 +0900

    ALSA: oxfw: rename helper functions for duplex streams
    
    In former commits, ALSA oxfw driver handles two isochronous contexts
    at the same time, except for some devices which supports one endpoint
    of isochronous packet stream.
    
    This commit renames some helper functions so that they handles duplex
    streams.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 3d27f3378d5d..2de26a9987f8 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -118,9 +118,7 @@ static void oxfw_card_free(struct snd_card *card)
 {
 	struct snd_oxfw *oxfw = card->private_data;
 
-	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
-	if (oxfw->has_output)
-		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
+	snd_oxfw_stream_destroy_duplex(oxfw);
 }
 
 static int detect_quirks(struct snd_oxfw *oxfw)
@@ -211,14 +209,9 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->rx_stream);
+	err = snd_oxfw_stream_init_duplex(oxfw);
 	if (err < 0)
 		goto error;
-	if (oxfw->has_output) {
-		err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->tx_stream);
-		if (err < 0)
-			goto error;
-	}
 
 	err = snd_oxfw_create_pcm(oxfw);
 	if (err < 0)
@@ -285,11 +278,7 @@ static void oxfw_bus_reset(struct fw_unit *unit)
 
 	if (oxfw->registered) {
 		mutex_lock(&oxfw->mutex);
-
-		snd_oxfw_stream_update_simplex(oxfw, &oxfw->rx_stream);
-		if (oxfw->has_output)
-			snd_oxfw_stream_update_simplex(oxfw, &oxfw->tx_stream);
-
+		snd_oxfw_stream_update_duplex(oxfw);
 		mutex_unlock(&oxfw->mutex);
 
 		if (oxfw->entry->vendor_id == OUI_STANTON)

commit d8fa87c368f5b4096c4746894fdcc195da285df1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 9 19:29:12 2019 +0900

    ALSA: oxfw: allow PCM capture for Stanton SCS.1m
    
    Stanton SCS.1m can transfer isochronous packet with Multi Bit Linear
    Audio data channels, therefore it allows software to capture PCM
    substream. However, ALSA oxfw driver doesn't.
    
    This commit changes the driver to add one PCM substream for capture
    direction.
    
    Fixes: de5126cc3c0b ("ALSA: oxfw: add stream format quirk for SCS.1 models")
    Cc: <stable@vger.kernel.org> # v4.5+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 3d27f3378d5d..b4bef574929d 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -148,9 +148,6 @@ static int detect_quirks(struct snd_oxfw *oxfw)
 		oxfw->midi_input_ports = 0;
 		oxfw->midi_output_ports = 0;
 
-		/* Output stream exists but no data channels are useful. */
-		oxfw->has_output = false;
-
 		return snd_oxfw_scs1x_add(oxfw);
 	}
 

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 3d27f3378d5d..5e31c460a90f 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -1,8 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * oxfw.c - a part of driver for OXFW970/971 based devices
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "oxfw.h"

commit fba43f454cdf9caa3185219d116bd2a6e6354552
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Nov 13 12:01:30 2018 +0900

    ALSA: oxfw: add support for APOGEE duet FireWire
    
    This commit adds support for APOGEE duet FireWire, launched 2007, already
    discontinued. This model uses Oxford Semiconductor FW971 as its
    communication engine. Below is information on Configuration ROM of this
    unit. The unit supports some AV/C commands defined by Audio subunit
    specification and vendor dependent commands.
    
    $ ./hinawa-config-rom-printer /dev/fw1
    { 'bus-info': { 'adj': False,
                    'bmc': False,
                    'chip_ID': 42949742248,
                    'cmc': False,
                    'cyc_clk_acc': 255,
                    'generation': 0,
                    'imc': False,
                    'isc': True,
                    'link_spd': 3,
                    'max_ROM': 0,
                    'max_rec': 64,
                    'name': '1394',
                    'node_vendor_ID': 987,
                    'pmc': False},
      'root-directory': [ ['VENDOR', 987],
                          ['DESCRIPTOR', 'Apogee Electronics'],
                          ['MODEL', 122333],
                          ['DESCRIPTOR', 'Duet'],
                          [ 'NODE_CAPABILITIES',
                            { 'addressing': {'64': True, 'fix': True, 'prv': False},
                              'misc': {'int': False, 'ms': False, 'spt': True},
                              'state': { 'atn': False,
                                         'ded': False,
                                         'drq': True,
                                         'elo': False,
                                         'init': False,
                                         'lst': True,
                                         'off': False},
                              'testing': {'bas': False, 'ext': False}}],
                          [ 'UNIT',
                            [ ['SPECIFIER_ID', 41005],
                              ['VERSION', 65537],
                              ['MODEL', 122333],
                              ['DESCRIPTOR', 'Duet']]]]}
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index afb78d90384b..3d27f3378d5d 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -20,6 +20,7 @@
 #define VENDOR_LACIE		0x00d04b
 #define VENDOR_TASCAM		0x00022e
 #define OUI_STANTON		0x001260
+#define OUI_APOGEE		0x0003db
 
 #define MODEL_SATELLITE		0x00200f
 
@@ -397,6 +398,13 @@ static const struct ieee1394_device_id oxfw_id_table[] = {
 		.vendor_id	= OUI_STANTON,
 		.model_id	= 0x002000,
 	},
+	// APOGEE, duet FireWire
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= OUI_APOGEE,
+		.model_id	= 0x01dddd,
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(ieee1394, oxfw_id_table);

commit 3babca4555b20fc80aff4776662fb237257d9afd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:02 2018 +0900

    ALSA: firewire: simplify cleanup process when failing to register sound card
    
    In former commits, .private_free callback releases resources just for
    data transmission. This release function can be called without the
    resources are actually allocated in error paths.
    
    This commit applies a small refactoring to clean up codes in error
    paths.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 14fe02a9ed5d..afb78d90384b 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -113,24 +113,15 @@ static int name_card(struct snd_oxfw *oxfw)
 	return err;
 }
 
-static void oxfw_free(struct snd_oxfw *oxfw)
+static void oxfw_card_free(struct snd_card *card)
 {
+	struct snd_oxfw *oxfw = card->private_data;
+
 	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
 	if (oxfw->has_output)
 		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
 }
 
-/*
- * This module releases the FireWire unit data after all ALSA character devices
- * are released by applications. This is for releasing stream data or finishing
- * transactions safely. Thus at returning from .remove(), this module still keep
- * references for the unit.
- */
-static void oxfw_card_free(struct snd_card *card)
-{
-	oxfw_free(card->private_data);
-}
-
 static int detect_quirks(struct snd_oxfw *oxfw)
 {
 	struct fw_device *fw_dev = fw_parent_device(oxfw->unit);
@@ -204,6 +195,8 @@ static void do_registration(struct work_struct *work)
 			   &oxfw->card);
 	if (err < 0)
 		return;
+	oxfw->card->private_free = oxfw_card_free;
+	oxfw->card->private_data = oxfw;
 
 	err = name_card(oxfw);
 	if (err < 0)
@@ -244,19 +237,10 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	/*
-	 * After registered, oxfw instance can be released corresponding to
-	 * releasing the sound card instance.
-	 */
-	oxfw->card->private_free = oxfw_card_free;
-	oxfw->card->private_data = oxfw;
 	oxfw->registered = true;
 
 	return;
 error:
-	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
-	if (oxfw->has_output)
-		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
 	snd_card_free(oxfw->card);
 	dev_info(&oxfw->unit->device,
 		 "Sound card registration failed: %d\n", err);

commit 5b14ec25a79bf60fc9a663fe579a500b6ac9d8ab
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:00 2018 +0900

    ALSA: firewire: release reference count of firewire unit in .remove callback of bus driver
    
    In a previous commit, drivers in ALSA firewire stack blocks .remove
    callback of bus driver. This enables to release members of private
    data in the callback after releasing device of sound card.
    
    This commit simplifies codes to release the members.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 36f905b371e6..14fe02a9ed5d 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -118,9 +118,6 @@ static void oxfw_free(struct snd_oxfw *oxfw)
 	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
 	if (oxfw->has_output)
 		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
-
-	mutex_destroy(&oxfw->mutex);
-	fw_unit_put(oxfw->unit);
 }
 
 /*
@@ -329,10 +326,10 @@ static void oxfw_remove(struct fw_unit *unit)
 	if (oxfw->registered) {
 		// Block till all of ALSA character devices are released.
 		snd_card_free(oxfw->card);
-	} else {
-		/* Don't forget this case. */
-		oxfw_free(oxfw);
 	}
+
+	mutex_destroy(&oxfw->mutex);
+	fw_unit_put(oxfw->unit);
 }
 
 static const struct compat_info griffin_firewave = {

commit 61ccc6f6b27c03bb32ca38a3c580d49ce1612d43
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:34:59 2018 +0900

    ALSA: firewire: block .remove callback of bus driver till all of ALSA character devices are released
    
    At present, in .remove callback of bus driver just decrease reference
    count of device for ALSA card instance. This delegates release of the
    device to a process in which the last of ALSA character device is
    released.
    
    On the other hand, the other drivers such as for devices on PCIe are
    programmed to block .remove callback of bus driver till all of ALSA
    character devices are released.
    
    For consistency of behaviour for whole drivers, this probably confuses
    users. This commit takes drivers in ALSA firewire stack to imitate the
    above behaviour.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 6ac551786b93..36f905b371e6 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -327,8 +327,8 @@ static void oxfw_remove(struct fw_unit *unit)
 	cancel_delayed_work_sync(&oxfw->dwork);
 
 	if (oxfw->registered) {
-		/* No need to wait for releasing card object in this context. */
-		snd_card_free_when_closed(oxfw->card);
+		// Block till all of ALSA character devices are released.
+		snd_card_free(oxfw->card);
 	} else {
 		/* Don't forget this case. */
 		oxfw_free(oxfw);

commit cd3b7116b57527f659b96ff6988d2de3d448c5b3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:54 2018 +0900

    ALSA: oxfw: use managed-resource to maintain cache of stream formats
    
    ALSA oxfw driver allocates memory objects for cache of stream formats.
    The objects are used to maintain packet streaming by components for
    ALSA rawMIDI/PCM interface. They can be released as managed-resource
    of 'struct snd_card.card_dev'.
    
    This commit uses managed-resource of the sound card device for this
    purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 06d791acfdc5..6ac551786b93 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -115,17 +115,10 @@ static int name_card(struct snd_oxfw *oxfw)
 
 static void oxfw_free(struct snd_oxfw *oxfw)
 {
-	unsigned int i;
-
 	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
 	if (oxfw->has_output)
 		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
 
-	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
-		kfree(oxfw->tx_stream_formats[i]);
-		kfree(oxfw->rx_stream_formats[i]);
-	}
-
 	mutex_destroy(&oxfw->mutex);
 	fw_unit_put(oxfw->unit);
 }
@@ -205,7 +198,6 @@ static int detect_quirks(struct snd_oxfw *oxfw)
 static void do_registration(struct work_struct *work)
 {
 	struct snd_oxfw *oxfw = container_of(work, struct snd_oxfw, dwork.work);
-	int i;
 	int err;
 
 	if (oxfw->registered)
@@ -268,12 +260,6 @@ static void do_registration(struct work_struct *work)
 	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
 	if (oxfw->has_output)
 		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
-	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; ++i) {
-		kfree(oxfw->tx_stream_formats[i]);
-		oxfw->tx_stream_formats[i] = NULL;
-		kfree(oxfw->rx_stream_formats[i]);
-		oxfw->rx_stream_formats[i] = NULL;
-	}
 	snd_card_free(oxfw->card);
 	dev_info(&oxfw->unit->device,
 		 "Sound card registration failed: %d\n", err);

commit 72bc8c4378f82307ff09f0959011fef2c818146d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:53 2018 +0900

    ALSA: oxfw: use managed-resource to maintain model-specific data
    
    ALSA oxfw driver allocates memory objects for data specific to some
    models. These objects are used to maintain functionalities specific
    to the models for ALSA rawMIDI/control interfaces. They can be
    released as managed-resource of 'struct snd_card.card_dev'.
    
    This commit uses managed-resource of the sound card device for this
    purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index b892a8642204..06d791acfdc5 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -126,7 +126,6 @@ static void oxfw_free(struct snd_oxfw *oxfw)
 		kfree(oxfw->rx_stream_formats[i]);
 	}
 
-	kfree(oxfw->spec);
 	mutex_destroy(&oxfw->mutex);
 	fw_unit_put(oxfw->unit);
 }
@@ -276,8 +275,6 @@ static void do_registration(struct work_struct *work)
 		oxfw->rx_stream_formats[i] = NULL;
 	}
 	snd_card_free(oxfw->card);
-	kfree(oxfw->spec);
-	oxfw->spec = NULL;
 	dev_info(&oxfw->unit->device,
 		 "Sound card registration failed: %d\n", err);
 }

commit 366a20d7a75cff7f89dede6fdfd41bd491aaf8ac
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:50 2018 +0900

    ALSA: firewire: use managed-resource of fw unit device for private data
    
    At present, private data of each driver in ALSA firewire stack is
    allocated/freed by kernel slab allocator for corresponding unit on
    IEEE 1394 bus. In this case, resource-managed slab allocator is
    available to release memory object automatically just before releasing
    device structure for the unit. This idea can prevent runtime from
    memory leak due to programming mistakes.
    
    This commit uses the allocator for the private data. These drivers
    already use reference counter to maintain lifetime of device structure
    for the unit by a pair of fw_unit_get()/fw_unit_put(). The private data
    is safely released in a callback of 'struct snd_card.private_free().
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 2ea8be6c8584..b892a8642204 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -121,8 +121,6 @@ static void oxfw_free(struct snd_oxfw *oxfw)
 	if (oxfw->has_output)
 		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
 
-	fw_unit_put(oxfw->unit);
-
 	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
 		kfree(oxfw->tx_stream_formats[i]);
 		kfree(oxfw->rx_stream_formats[i]);
@@ -130,7 +128,7 @@ static void oxfw_free(struct snd_oxfw *oxfw)
 
 	kfree(oxfw->spec);
 	mutex_destroy(&oxfw->mutex);
-	kfree(oxfw);
+	fw_unit_put(oxfw->unit);
 }
 
 /*
@@ -293,14 +291,13 @@ static int oxfw_probe(struct fw_unit *unit,
 		return -ENODEV;
 
 	/* Allocate this independent of sound card instance. */
-	oxfw = kzalloc(sizeof(struct snd_oxfw), GFP_KERNEL);
-	if (oxfw == NULL)
+	oxfw = devm_kzalloc(&unit->device, sizeof(struct snd_oxfw), GFP_KERNEL);
+	if (!oxfw)
 		return -ENOMEM;
-
-	oxfw->entry = entry;
 	oxfw->unit = fw_unit_get(unit);
 	dev_set_drvdata(&unit->device, oxfw);
 
+	oxfw->entry = entry;
 	mutex_init(&oxfw->mutex);
 	spin_lock_init(&oxfw->lock);
 	init_waitqueue_head(&oxfw->hwdep_wait);

commit 1064bc685d359f549f91c2d5f111965a9284f328
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Sep 17 17:26:20 2018 +0900

    ALSA: oxfw: fix memory leak of discovered stream formats at error path
    
    After finishing discover of stream formats, ALSA OXFW driver has memory
    leak of allocated memory object at error path.
    
    This commit releases the memory object at the error path.
    
    Fixes: 6c29230e2a5f ('ALSA: oxfw: delayed registration of sound card')
    Cc: <stable@vger.kernel.org> # v4.7+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 75c6ba2fe3dc..2ea8be6c8584 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -208,6 +208,7 @@ static int detect_quirks(struct snd_oxfw *oxfw)
 static void do_registration(struct work_struct *work)
 {
 	struct snd_oxfw *oxfw = container_of(work, struct snd_oxfw, dwork.work);
+	int i;
 	int err;
 
 	if (oxfw->registered)
@@ -270,6 +271,12 @@ static void do_registration(struct work_struct *work)
 	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
 	if (oxfw->has_output)
 		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
+	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; ++i) {
+		kfree(oxfw->tx_stream_formats[i]);
+		oxfw->tx_stream_formats[i] = NULL;
+		kfree(oxfw->rx_stream_formats[i]);
+		oxfw->rx_stream_formats[i] = NULL;
+	}
 	snd_card_free(oxfw->card);
 	kfree(oxfw->spec);
 	oxfw->spec = NULL;

commit ce925f088b979537f22f9e05eb923ef9822ca139
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Sep 17 17:26:08 2018 +0900

    ALSA: oxfw: fix memory leak for model-dependent data at error path
    
    After allocating model-dependent data, ALSA OXFW driver has memory leak
    of the data at error path.
    
    This commit releases the data at the error path.
    
    Fixes: 6c29230e2a5f ('ALSA: oxfw: delayed registration of sound card')
    Cc: <stable@vger.kernel.org> # v4.7+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index fd34ef2ac679..75c6ba2fe3dc 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -271,6 +271,8 @@ static void do_registration(struct work_struct *work)
 	if (oxfw->has_output)
 		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
 	snd_card_free(oxfw->card);
+	kfree(oxfw->spec);
+	oxfw->spec = NULL;
 	dev_info(&oxfw->unit->device,
 		 "Sound card registration failed: %d\n", err);
 }

commit 498fe23aad8e3b5a9554f55719c537603b4476ea
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Sep 13 21:31:18 2018 +0900

    ALSA: oxfw: fix memory leak of private data
    
    Although private data of sound card instance is usually allocated in the
    tail of the instance, drivers in ALSA firewire stack allocate the private
    data before allocating the instance. In this case, the private data
    should be released explicitly at .private_free callback of the instance.
    
    This commit fixes memory leak following to the above design.
    
    Fixes: 6c29230e2a5f ('ALSA: oxfw: delayed registration of sound card')
    Cc: <stable@vger.kernel.org> # v4.7+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 1e5b2c802635..fd34ef2ac679 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -130,6 +130,7 @@ static void oxfw_free(struct snd_oxfw *oxfw)
 
 	kfree(oxfw->spec);
 	mutex_destroy(&oxfw->mutex);
+	kfree(oxfw);
 }
 
 /*

commit 2cc47d31ebf967cfca74045ac8fc9bb742f17ab3
Author: Yisheng Xie <xieyisheng1@huawei.com>
Date:   Mon May 21 19:58:06 2018 +0800

    ALSA: oxfw: use match_string() helper
    
    match_string() returns the index of an array for a matching string,
    which can be used intead of open coded variant.
    
    Signed-off-by: Yisheng Xie <xieyisheng1@huawei.com>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 413ab6313bb6..1e5b2c802635 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -49,7 +49,6 @@ static bool detect_loud_models(struct fw_unit *unit)
 		"Tapco LINK.firewire 4x6",
 		"U.420"};
 	char model[32];
-	unsigned int i;
 	int err;
 
 	err = fw_csr_string(unit->directory, CSR_MODEL,
@@ -57,12 +56,7 @@ static bool detect_loud_models(struct fw_unit *unit)
 	if (err < 0)
 		return false;
 
-	for (i = 0; i < ARRAY_SIZE(models); i++) {
-		if (strcmp(models[i], model) == 0)
-			break;
-	}
-
-	return (i < ARRAY_SIZE(models));
+	return match_string(models, ARRAY_SIZE(models), model) >= 0;
 }
 
 static int name_card(struct snd_oxfw *oxfw)

commit 3d016d57fdc5e6caa4cd67896f4b081bccad6e2c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Apr 3 21:13:40 2017 +0900

    ALSA: oxfw: fix regression to handle Stanton SCS.1m/1d
    
    At a commit 6c29230e2a5f ("ALSA: oxfw: delayed registration of sound
    card"), ALSA oxfw driver fails to handle SCS.1m/1d, due to -EBUSY at a call
    of snd_card_register(). The cause is that the driver manages to register
    two rawmidi instances with the same device number 0. This is a regression
    introduced since kernel 4.7.
    
    This commit fixes the regression, by fixing up device property after
    discovering stream formats.
    
    Fixes: 6c29230e2a5f ("ALSA: oxfw: delayed registration of sound card")
    Cc: <stable@vger.kernel.org> # 4.7+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 74d7fb6efce6..413ab6313bb6 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -227,11 +227,11 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	err = detect_quirks(oxfw);
+	err = snd_oxfw_stream_discover(oxfw);
 	if (err < 0)
 		goto error;
 
-	err = snd_oxfw_stream_discover(oxfw);
+	err = detect_quirks(oxfw);
 	if (err < 0)
 		goto error;
 

commit 03abd33a11e3598dffbc821b2826ffc5fb6e980f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jan 3 11:36:08 2017 +0900

    ALSA: oxfw: add support for Mackie Onyx 1640i
    
    As of kernel 4.10,  ALSA OXFW driver has no entry for Onyx 1640i produced
    by Mackie (Loud Technologies). This commit supplement it.
    
    I note that there're two models produced by Mackie (Loud Technologies),
    which have the same name 'Onyx 1640i'. The former model based on OXFW970,
    the latter model based on Dice. This is probably due to low quality of
    communication of OXFW series.
    
    Additionally, the tester reports his or her experiences to get unexpected
    result at higher sampling transmission frequency as 88.2/96.0 kHz. We
    didn't have further investigation yet[0].
    
    $ ./linux-firewire-utils/src/crpp < config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  042525ce  bus_info_length 4, crc_length 37, crc 9678
    404  31333934  bus_name "1394"
    408  20ff5003  irmc 0, cmc 0, isc 1, bmc 0, cyc_clk_acc 255, max_rec 5 (64)
    40c  000ff205  company_id 000ff2     |
    410  00000fcf  device_id 0500000fcf  | EUI-64 000ff20500000fcf
    
                   root directory
                   -----------------------------------------------------------------
    414  0006c1b7  directory_length 6, crc 49591
    418  03000ff2  vendor
    41c  8100000a  --> descriptor leaf at 444
    420  17001640  model
    424  81000011  --> descriptor leaf at 468
    428  0c0083c0  node capabilities per IEEE 1394
    42c  d1000001  --> unit directory at 430
    
                   unit directory at 430
                   -----------------------------------------------------------------
    430  00040b97  directory_length 4, crc 2967
    434  1200a02d  specifier id: 1394 TA
    438  13010001  version: AV/C
    43c  17001640  model
    440  81000010  --> descriptor leaf at 480
    
                   descriptor leaf at 444
                   -----------------------------------------------------------------
    444  0008a886  leaf_length 8, crc 43142
    448  00000000  textual descriptor
    44c  00000000  minimal ASCII
    450  4c6f7564  "Loud"
    454  20546563  " Tec"
    458  686e6f6c  "hnol"
    45c  6f676965  "ogie"
    460  7320496e  "s In"
    464  632e0000  "c."
    
                   descriptor leaf at 468
                   -----------------------------------------------------------------
    468  00059fcf  leaf_length 5, crc 40911
    46c  00000000  textual descriptor
    470  00000000  minimal ASCII
    474  4f6e7978  "Onyx"
    478  20313634  " 164"
    47c  30690000  "0i"
    
                   descriptor leaf at 480
                   -----------------------------------------------------------------
    480  00059fcf  leaf_length 5, crc 40911
    484  00000000  textual descriptor
    488  00000000  minimal ASCII
    48c  4f6e7978  "Onyx"
    490  20313634  " 164"
    494  30690000  "0i"
    
    [0]: [FFADO-user] Mackie 1640i issues (finer details)
    https://sourceforge.net/p/ffado/mailman/message/35229260/
    
    Tested-by: Seth O'Bannion <saobannion@gmail.com>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index e629b88f7d93..74d7fb6efce6 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -43,6 +43,7 @@ static bool detect_loud_models(struct fw_unit *unit)
 	const char *const models[] = {
 		"Onyxi",
 		"Onyx-i",
+		"Onyx 1640i",
 		"d.Pro",
 		"Mackie Onyx Satellite",
 		"Tapco LINK.firewire 4x6",

commit 6c29230e2a5ff84df2b1358681414bad3e4bd220
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Mar 31 08:47:07 2016 +0900

    ALSA: oxfw: delayed registration of sound card
    
    Some oxfw based units tends to fail asynchronous communication when
    IEEE 1394 bus is under bus-reset state. When registering sound card
    instance at unit probe callback, userspace applications can be involved
    to the state.
    
    This commit postpones the registration till the bus is calm.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index abedc2207261..e629b88f7d93 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -118,15 +118,8 @@ static int name_card(struct snd_oxfw *oxfw)
 	return err;
 }
 
-/*
- * This module releases the FireWire unit data after all ALSA character devices
- * are released by applications. This is for releasing stream data or finishing
- * transactions safely. Thus at returning from .remove(), this module still keep
- * references for the unit.
- */
-static void oxfw_card_free(struct snd_card *card)
+static void oxfw_free(struct snd_oxfw *oxfw)
 {
-	struct snd_oxfw *oxfw = card->private_data;
 	unsigned int i;
 
 	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
@@ -144,6 +137,17 @@ static void oxfw_card_free(struct snd_card *card)
 	mutex_destroy(&oxfw->mutex);
 }
 
+/*
+ * This module releases the FireWire unit data after all ALSA character devices
+ * are released by applications. This is for releasing stream data or finishing
+ * transactions safely. Thus at returning from .remove(), this module still keep
+ * references for the unit.
+ */
+static void oxfw_card_free(struct snd_card *card)
+{
+	oxfw_free(card->private_data);
+}
+
 static int detect_quirks(struct snd_oxfw *oxfw)
 {
 	struct fw_device *fw_dev = fw_parent_device(oxfw->unit);
@@ -205,41 +209,39 @@ static int detect_quirks(struct snd_oxfw *oxfw)
 	return 0;
 }
 
-static int oxfw_probe(struct fw_unit *unit,
-		      const struct ieee1394_device_id *entry)
+static void do_registration(struct work_struct *work)
 {
-	struct snd_card *card;
-	struct snd_oxfw *oxfw;
+	struct snd_oxfw *oxfw = container_of(work, struct snd_oxfw, dwork.work);
 	int err;
 
-	if (entry->vendor_id == VENDOR_LOUD && !detect_loud_models(unit))
-		return -ENODEV;
+	if (oxfw->registered)
+		return;
 
-	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
-			   sizeof(*oxfw), &card);
+	err = snd_card_new(&oxfw->unit->device, -1, NULL, THIS_MODULE, 0,
+			   &oxfw->card);
 	if (err < 0)
-		return err;
+		return;
 
-	card->private_free = oxfw_card_free;
-	oxfw = card->private_data;
-	oxfw->card = card;
-	mutex_init(&oxfw->mutex);
-	oxfw->unit = fw_unit_get(unit);
-	oxfw->entry = entry;
-	spin_lock_init(&oxfw->lock);
-	init_waitqueue_head(&oxfw->hwdep_wait);
+	err = name_card(oxfw);
+	if (err < 0)
+		goto error;
 
-	err = snd_oxfw_stream_discover(oxfw);
+	err = detect_quirks(oxfw);
 	if (err < 0)
 		goto error;
 
-	err = name_card(oxfw);
+	err = snd_oxfw_stream_discover(oxfw);
 	if (err < 0)
 		goto error;
 
-	err = detect_quirks(oxfw);
+	err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->rx_stream);
 	if (err < 0)
 		goto error;
+	if (oxfw->has_output) {
+		err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->tx_stream);
+		if (err < 0)
+			goto error;
+	}
 
 	err = snd_oxfw_create_pcm(oxfw);
 	if (err < 0)
@@ -255,54 +257,97 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->rx_stream);
+	err = snd_card_register(oxfw->card);
 	if (err < 0)
 		goto error;
-	if (oxfw->has_output) {
-		err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->tx_stream);
-		if (err < 0)
-			goto error;
-	}
 
-	err = snd_card_register(card);
-	if (err < 0) {
-		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
-		if (oxfw->has_output)
-			snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
-		goto error;
-	}
+	/*
+	 * After registered, oxfw instance can be released corresponding to
+	 * releasing the sound card instance.
+	 */
+	oxfw->card->private_free = oxfw_card_free;
+	oxfw->card->private_data = oxfw;
+	oxfw->registered = true;
+
+	return;
+error:
+	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
+	if (oxfw->has_output)
+		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
+	snd_card_free(oxfw->card);
+	dev_info(&oxfw->unit->device,
+		 "Sound card registration failed: %d\n", err);
+}
+
+static int oxfw_probe(struct fw_unit *unit,
+		      const struct ieee1394_device_id *entry)
+{
+	struct snd_oxfw *oxfw;
+
+	if (entry->vendor_id == VENDOR_LOUD && !detect_loud_models(unit))
+		return -ENODEV;
+
+	/* Allocate this independent of sound card instance. */
+	oxfw = kzalloc(sizeof(struct snd_oxfw), GFP_KERNEL);
+	if (oxfw == NULL)
+		return -ENOMEM;
+
+	oxfw->entry = entry;
+	oxfw->unit = fw_unit_get(unit);
 	dev_set_drvdata(&unit->device, oxfw);
 
+	mutex_init(&oxfw->mutex);
+	spin_lock_init(&oxfw->lock);
+	init_waitqueue_head(&oxfw->hwdep_wait);
+
+	/* Allocate and register this sound card later. */
+	INIT_DEFERRABLE_WORK(&oxfw->dwork, do_registration);
+	snd_fw_schedule_registration(unit, &oxfw->dwork);
+
 	return 0;
-error:
-	snd_card_free(card);
-	return err;
 }
 
 static void oxfw_bus_reset(struct fw_unit *unit)
 {
 	struct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);
 
+	if (!oxfw->registered)
+		snd_fw_schedule_registration(unit, &oxfw->dwork);
+
 	fcp_bus_reset(oxfw->unit);
 
-	mutex_lock(&oxfw->mutex);
+	if (oxfw->registered) {
+		mutex_lock(&oxfw->mutex);
 
-	snd_oxfw_stream_update_simplex(oxfw, &oxfw->rx_stream);
-	if (oxfw->has_output)
-		snd_oxfw_stream_update_simplex(oxfw, &oxfw->tx_stream);
+		snd_oxfw_stream_update_simplex(oxfw, &oxfw->rx_stream);
+		if (oxfw->has_output)
+			snd_oxfw_stream_update_simplex(oxfw, &oxfw->tx_stream);
 
-	mutex_unlock(&oxfw->mutex);
+		mutex_unlock(&oxfw->mutex);
 
-	if (oxfw->entry->vendor_id == OUI_STANTON)
-		snd_oxfw_scs1x_update(oxfw);
+		if (oxfw->entry->vendor_id == OUI_STANTON)
+			snd_oxfw_scs1x_update(oxfw);
+	}
 }
 
 static void oxfw_remove(struct fw_unit *unit)
 {
 	struct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);
 
-	/* No need to wait for releasing card object in this context. */
-	snd_card_free_when_closed(oxfw->card);
+	/*
+	 * Confirm to stop the work for registration before the sound card is
+	 * going to be released. The work is not scheduled again because bus
+	 * reset handler is not called anymore.
+	 */
+	cancel_delayed_work_sync(&oxfw->dwork);
+
+	if (oxfw->registered) {
+		/* No need to wait for releasing card object in this context. */
+		snd_card_free_when_closed(oxfw->card);
+	} else {
+		/* Don't forget this case. */
+		oxfw_free(oxfw);
+	}
 }
 
 static const struct compat_info griffin_firewave = {

commit de5126cc3c0b0f291d08fa591dcdf237bc595a56
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 22 09:15:46 2015 +0900

    ALSA: oxfw: add stream format quirk for SCS.1 models
    
    As long as I investigate SCS.1m, this model reports to transfer/receive
    PCM data channels/MIDI conformant data channels in tx/rx AMDTP packet.
    There's a contradiction that this model actually has no analog/digital
    capture port for PCM frames and no physical MIDI ports.
    
    I guess that SCS.1d also has the contradiction. This model has no
    analog/digital ports for PCM frames and no physical MIDI ports, thus it
    requires no streaming functionality.
    
    This commit adds some modification codes to handle the contradiction,
    as much as possible. Unfortunately, this module adds one PCM playback
    substream for SCS.1d so as SCS.1m.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index e7f2698c4cb8..abedc2207261 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -164,8 +164,16 @@ static int detect_quirks(struct snd_oxfw *oxfw)
 	 * Stanton models supports asynchronous transactions for unique MIDI
 	 * messages.
 	 */
-	if (oxfw->entry->vendor_id == OUI_STANTON)
+	if (oxfw->entry->vendor_id == OUI_STANTON) {
+		/* No physical MIDI ports. */
+		oxfw->midi_input_ports = 0;
+		oxfw->midi_output_ports = 0;
+
+		/* Output stream exists but no data channels are useful. */
+		oxfw->has_output = false;
+
 		return snd_oxfw_scs1x_add(oxfw);
+	}
 
 	/*
 	 * TASCAM FireOne has physical control and requires a pair of additional

commit 9e2004f9cedf50469e62e3206bc3363913a972b4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 22 09:15:45 2015 +0900

    ALSA: oxfw: obsolete scs1x module
    
    Now ALSA oxfw driver gains functionalities which scs1x module has.
    
    This commit obsoletes the scs1x module, and adds a line of MODULE_ALIAS
    to load oxfw module instead of scs1x module.
    
    In scs1x module, the name of 'shortname' field is fixed as 'SCS1x'. This
    field is used to name MIDI ports for both of SCS.1m and SCS.1d. This is
    not good because typically some SCS.1m and SCS.1d are used in the same
    system. It's better to distinguish them according to name of the ports.
    This commit applies model name in config ROM to the 'shortname'.
    
    For the name of 'driver' and 'longname', this commit uses the same way
    applied to the other models. This change may not bring disadvantages to
    users because userspace applications use ALSA rawmidi or seq interface
    and these interfaces are not influenced by them directly.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index b20e496e2201..e7f2698c4cb8 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -19,6 +19,7 @@
 #define VENDOR_BEHRINGER	0x001564
 #define VENDOR_LACIE		0x00d04b
 #define VENDOR_TASCAM		0x00022e
+#define OUI_STANTON		0x001260
 
 #define MODEL_SATELLITE		0x00200f
 
@@ -29,6 +30,7 @@ MODULE_DESCRIPTION("Oxford Semiconductor FW970/971 driver");
 MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("snd-firewire-speakers");
+MODULE_ALIAS("snd-scs1x");
 
 struct compat_info {
 	const char *driver_name;
@@ -158,6 +160,13 @@ static int detect_quirks(struct snd_oxfw *oxfw)
 	if (oxfw->entry->vendor_id == VENDOR_LACIE)
 		return snd_oxfw_add_spkr(oxfw, true);
 
+	/*
+	 * Stanton models supports asynchronous transactions for unique MIDI
+	 * messages.
+	 */
+	if (oxfw->entry->vendor_id == OUI_STANTON)
+		return snd_oxfw_scs1x_add(oxfw);
+
 	/*
 	 * TASCAM FireOne has physical control and requires a pair of additional
 	 * MIDI ports.
@@ -275,6 +284,9 @@ static void oxfw_bus_reset(struct fw_unit *unit)
 		snd_oxfw_stream_update_simplex(oxfw, &oxfw->tx_stream);
 
 	mutex_unlock(&oxfw->mutex);
+
+	if (oxfw->entry->vendor_id == OUI_STANTON)
+		snd_oxfw_scs1x_update(oxfw);
 }
 
 static void oxfw_remove(struct fw_unit *unit)
@@ -352,6 +364,20 @@ static const struct ieee1394_device_id oxfw_id_table[] = {
 		.vendor_id	= VENDOR_TASCAM,
 		.model_id	= 0x800007,
 	},
+	/* Stanton, Stanton Controllers & Systems 1 Mixer (SCS.1m) */
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= OUI_STANTON,
+		.model_id	= 0x001000,
+	},
+	/* Stanton, Stanton Controllers & Systems 1 Deck (SCS.1d) */
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= OUI_STANTON,
+		.model_id	= 0x002000,
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(ieee1394, oxfw_id_table);

commit 3f47152a1c8f4d4c8ca18740bf3f1a7fff1b3fd9
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 22 09:15:39 2015 +0900

    ALSA: oxfw: add scs1x layer
    
    Stanton Controllers and Systems 1 (SCS.1) series is supported by ALSA
    scs1x driver. This driver just supports MIDI functionality. On the other
    hand, models in this series are based on OXFW971 and ALSA OXFW driver can
    support them.
    
    SCS.1 series has MIDI functionality to control its surface state such as
    LED lighting. When operating physical knobs and faders, the models
    generate MIDI messages. These MIDI messages are transferred by asynchronous
    transactions. These transactions are really model-specific and ALSA OXFW
    driver requires the functionality so as scs1x module implements.
    
    This commit adds scs1x layer as a preparation to merge scs1x driver to
    oxfw driver.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 96fbb784f086..b20e496e2201 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -216,11 +216,11 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = detect_quirks(oxfw);
+	err = name_card(oxfw);
 	if (err < 0)
 		goto error;
 
-	err = name_card(oxfw);
+	err = detect_quirks(oxfw);
 	if (err < 0)
 		goto error;
 

commit d6ce6bbd7d83453ce958cfc03b7250dbee3a431e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Dec 16 20:37:57 2015 +0900

    ALSA: oxfw: rename a structure so that it means backward compatibility to old drivers
    
    In former commits, some model-specific members are split from the
    structure. The structure is just to keep names for compatibility to old
    drivers.
    
    This commit arranges name of the structure and localize it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 16ee6ea033e4..96fbb784f086 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -30,6 +30,12 @@ MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("snd-firewire-speakers");
 
+struct compat_info {
+	const char *driver_name;
+	const char *vendor_name;
+	const char *model_name;
+};
+
 static bool detect_loud_models(struct fw_unit *unit)
 {
 	const char *const models[] = {
@@ -59,7 +65,7 @@ static bool detect_loud_models(struct fw_unit *unit)
 static int name_card(struct snd_oxfw *oxfw)
 {
 	struct fw_device *fw_dev = fw_parent_device(oxfw->unit);
-	const struct device_info *info;
+	const struct compat_info *info;
 	char vendor[24];
 	char model[32];
 	const char *d, *v, *m;
@@ -87,7 +93,7 @@ static int name_card(struct snd_oxfw *oxfw)
 	/* to apply card definitions */
 	if (oxfw->entry->vendor_id == VENDOR_GRIFFIN ||
 	    oxfw->entry->vendor_id == VENDOR_LACIE) {
-		info = (const struct device_info *)oxfw->entry->driver_data;
+		info = (const struct compat_info *)oxfw->entry->driver_data;
 		d = info->driver_name;
 		v = info->vendor_name;
 		m = info->model_name;
@@ -279,13 +285,13 @@ static void oxfw_remove(struct fw_unit *unit)
 	snd_card_free_when_closed(oxfw->card);
 }
 
-static const struct device_info griffin_firewave = {
+static const struct compat_info griffin_firewave = {
 	.driver_name = "FireWave",
 	.vendor_name = "Griffin",
 	.model_name = "FireWave",
 };
 
-static const struct device_info lacie_speakers = {
+static const struct compat_info lacie_speakers = {
 	.driver_name = "FWSpeakers",
 	.vendor_name = "LaCie",
 	.model_name = "FireWire Speakers",

commit 3e2f45708eb59179444f992ba1dc60ccf2cbdacd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Dec 16 20:37:56 2015 +0900

    ALSA: oxfw: move model-specific parameters from common structure
    
    In previous commit, some members are moved from 'struct snd_oxfw' because
    they're model-specific. There are also the other model-specific parameters
    in 'struct device_info'.
    
    This commit moves these members to model-specific structure.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 7e50a4fcee50..16ee6ea033e4 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -147,12 +147,10 @@ static int detect_quirks(struct snd_oxfw *oxfw)
 	 * Add ALSA control elements for two models to keep compatibility to
 	 * old firewire-speaker module.
 	 */
-	if (oxfw->entry->vendor_id == VENDOR_GRIFFIN ||
-	    oxfw->entry->vendor_id == VENDOR_LACIE) {
-		oxfw->device_info =
-			(const struct device_info *)oxfw->entry->driver_data;
-		return snd_oxfw_add_spkr(oxfw);
-	}
+	if (oxfw->entry->vendor_id == VENDOR_GRIFFIN)
+		return snd_oxfw_add_spkr(oxfw, false);
+	if (oxfw->entry->vendor_id == VENDOR_LACIE)
+		return snd_oxfw_add_spkr(oxfw, true);
 
 	/*
 	 * TASCAM FireOne has physical control and requires a pair of additional
@@ -285,18 +283,12 @@ static const struct device_info griffin_firewave = {
 	.driver_name = "FireWave",
 	.vendor_name = "Griffin",
 	.model_name = "FireWave",
-	.mixer_channels = 6,
-	.mute_fb_id   = 0x01,
-	.volume_fb_id = 0x02,
 };
 
 static const struct device_info lacie_speakers = {
 	.driver_name = "FWSpeakers",
 	.vendor_name = "LaCie",
 	.model_name = "FireWire Speakers",
-	.mixer_channels = 1,
-	.mute_fb_id   = 0x01,
-	.volume_fb_id = 0x01,
 };
 
 static const struct ieee1394_device_id oxfw_id_table[] = {

commit c582cc66b98af8130f4a26ccbd7e05d5aef2a96d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Dec 16 20:37:54 2015 +0900

    ALSA: oxfw: enable to keep memory block for model-specific structure
    
    ALSA oxfw driver should have backward compatibility to old
    firewire-speakers driver. Additionally, in future commit, scs1x driver
    will be merged. It's nice to add a pointer to have a memory block for
    model-specific structures.
    
    This commit adds a member to 'struct snd_oxfw' for this aim. Deallocation
    is done at freeing ALSA card structure.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index d4fb3c10163a..7e50a4fcee50 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -132,6 +132,7 @@ static void oxfw_card_free(struct snd_card *card)
 		kfree(oxfw->rx_stream_formats[i]);
 	}
 
+	kfree(oxfw->spec);
 	mutex_destroy(&oxfw->mutex);
 }
 

commit 5ce8cc48443596e500586007b443e1eea6334efc
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 15 23:56:21 2015 +0900

    ALSA: oxfw: gather model-dependent conditions to a function
    
    Adding control elements is just for models supported by old
    firewire-speakers modules. The processing should be in a function to add
    model-dependent quirk.
    
    This commit moves the codes to the function. As a result, the function
    should handle error state, thus this commit also changes prototype of
    the function.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 836d75777973..d4fb3c10163a 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -135,13 +135,24 @@ static void oxfw_card_free(struct snd_card *card)
 	mutex_destroy(&oxfw->mutex);
 }
 
-static void detect_quirks(struct snd_oxfw *oxfw)
+static int detect_quirks(struct snd_oxfw *oxfw)
 {
 	struct fw_device *fw_dev = fw_parent_device(oxfw->unit);
 	struct fw_csr_iterator it;
 	int key, val;
 	int vendor, model;
 
+	/*
+	 * Add ALSA control elements for two models to keep compatibility to
+	 * old firewire-speaker module.
+	 */
+	if (oxfw->entry->vendor_id == VENDOR_GRIFFIN ||
+	    oxfw->entry->vendor_id == VENDOR_LACIE) {
+		oxfw->device_info =
+			(const struct device_info *)oxfw->entry->driver_data;
+		return snd_oxfw_add_spkr(oxfw);
+	}
+
 	/*
 	 * TASCAM FireOne has physical control and requires a pair of additional
 	 * MIDI ports.
@@ -149,7 +160,7 @@ static void detect_quirks(struct snd_oxfw *oxfw)
 	if (oxfw->entry->vendor_id == VENDOR_TASCAM) {
 		oxfw->midi_input_ports++;
 		oxfw->midi_output_ports++;
-		return;
+		return 0;
 	}
 
 	/* Seek from Root Directory of Config ROM. */
@@ -168,6 +179,8 @@ static void detect_quirks(struct snd_oxfw *oxfw)
 	 */
 	if (vendor == VENDOR_LOUD && model == MODEL_SATELLITE)
 		oxfw->wrong_dbs = true;
+
+	return 0;
 }
 
 static int oxfw_probe(struct fw_unit *unit,
@@ -198,7 +211,9 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	detect_quirks(oxfw);
+	err = detect_quirks(oxfw);
+	if (err < 0)
+		goto error;
 
 	err = name_card(oxfw);
 	if (err < 0)
@@ -208,14 +223,6 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	if (oxfw->device_info) {
-		oxfw->device_info =
-				(const struct device_info *)entry->driver_data;
-		err = snd_oxfw_add_spkr(oxfw);
-		if (err < 0)
-			goto error;
-	}
-
 	snd_oxfw_proc_init(oxfw);
 
 	err = snd_oxfw_create_midi(oxfw);

commit 27e66635016fc5bd3d36355daedf741f0a7329bb
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 15 23:56:20 2015 +0900

    ALSA: oxfw: reuse driver entry to detect quirks
    
    Currently, assignment to model-dependent quirk is corresponding to
    asynchronous transactions on IEEE 1394 bus. This is also achieved with
    device entry.
    
    This commit changes the processing of model-dependent quirk with the
    entry. As a result, the transactions are sent only for Loud models.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 0304d4549f44..836d75777973 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -59,6 +59,7 @@ static bool detect_loud_models(struct fw_unit *unit)
 static int name_card(struct snd_oxfw *oxfw)
 {
 	struct fw_device *fw_dev = fw_parent_device(oxfw->unit);
+	const struct device_info *info;
 	char vendor[24];
 	char model[32];
 	const char *d, *v, *m;
@@ -84,10 +85,12 @@ static int name_card(struct snd_oxfw *oxfw)
 	be32_to_cpus(&firmware);
 
 	/* to apply card definitions */
-	if (oxfw->device_info) {
-		d = oxfw->device_info->driver_name;
-		v = oxfw->device_info->vendor_name;
-		m = oxfw->device_info->model_name;
+	if (oxfw->entry->vendor_id == VENDOR_GRIFFIN ||
+	    oxfw->entry->vendor_id == VENDOR_LACIE) {
+		info = (const struct device_info *)oxfw->entry->driver_data;
+		d = info->driver_name;
+		v = info->vendor_name;
+		m = info->model_name;
 	} else {
 		d = "OXFW";
 		v = vendor;
@@ -139,6 +142,16 @@ static void detect_quirks(struct snd_oxfw *oxfw)
 	int key, val;
 	int vendor, model;
 
+	/*
+	 * TASCAM FireOne has physical control and requires a pair of additional
+	 * MIDI ports.
+	 */
+	if (oxfw->entry->vendor_id == VENDOR_TASCAM) {
+		oxfw->midi_input_ports++;
+		oxfw->midi_output_ports++;
+		return;
+	}
+
 	/* Seek from Root Directory of Config ROM. */
 	vendor = model = 0;
 	fw_csr_iterator_init(&it, fw_dev->config_rom + 5);
@@ -155,25 +168,16 @@ static void detect_quirks(struct snd_oxfw *oxfw)
 	 */
 	if (vendor == VENDOR_LOUD && model == MODEL_SATELLITE)
 		oxfw->wrong_dbs = true;
-
-	/*
-	 * TASCAM FireOne has physical control and requires a pair of additional
-	 * MIDI ports.
-	 */
-	if (vendor == VENDOR_TASCAM) {
-		oxfw->midi_input_ports++;
-		oxfw->midi_output_ports++;
-	}
 }
 
 static int oxfw_probe(struct fw_unit *unit,
-		       const struct ieee1394_device_id *id)
+		      const struct ieee1394_device_id *entry)
 {
 	struct snd_card *card;
 	struct snd_oxfw *oxfw;
 	int err;
 
-	if ((id->vendor_id == VENDOR_LOUD) && !detect_loud_models(unit))
+	if (entry->vendor_id == VENDOR_LOUD && !detect_loud_models(unit))
 		return -ENODEV;
 
 	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
@@ -186,7 +190,7 @@ static int oxfw_probe(struct fw_unit *unit,
 	oxfw->card = card;
 	mutex_init(&oxfw->mutex);
 	oxfw->unit = fw_unit_get(unit);
-	oxfw->device_info = (const struct device_info *)id->driver_data;
+	oxfw->entry = entry;
 	spin_lock_init(&oxfw->lock);
 	init_waitqueue_head(&oxfw->hwdep_wait);
 
@@ -205,6 +209,8 @@ static int oxfw_probe(struct fw_unit *unit,
 		goto error;
 
 	if (oxfw->device_info) {
+		oxfw->device_info =
+				(const struct device_info *)entry->driver_data;
 		err = snd_oxfw_add_spkr(oxfw);
 		if (err < 0)
 			goto error;

commit 29aa09acb20485ee682de38903734cb3a0e582cd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 15 23:56:18 2015 +0900

    ALSA: oxfw: rename local functions for control elements so that they represent as local
    
    This commit renames local functions with prefix 'spkr_', so that they're
    for firewire-speakers.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 588b93f20c2e..0304d4549f44 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -205,7 +205,7 @@ static int oxfw_probe(struct fw_unit *unit,
 		goto error;
 
 	if (oxfw->device_info) {
-		err = snd_oxfw_create_mixer(oxfw);
+		err = snd_oxfw_add_spkr(oxfw);
 		if (err < 0)
 			goto error;
 	}

commit 759a2f40c9fa3839c021f7cdc4ec19d10fd63b44
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 18 17:09:40 2015 +0900

    ALSA: oxfw: add an entry for TASCAM FireOne
    
    TASCAM FireOne is based on OXFW971 and ALSA OXFW driver can support it.
    These are values of identical registers.
    
    $ ./firewire-request /dev/fw1 read 0xfffff0050000
    result: 97100105
    
    $ ./firewire-request /dev/fw1 read 0xfffff0090020
    result: 39373100
    
    This commit adds an entry for this model. This model has physical controls
    and its MIDI control messages are transferred to second MIDI data stream
    multiplexed in one MIDI conformant data channel.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index d606e3a9ce97..588b93f20c2e 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -18,6 +18,7 @@
 #define VENDOR_GRIFFIN		0x001292
 #define VENDOR_BEHRINGER	0x001564
 #define VENDOR_LACIE		0x00d04b
+#define VENDOR_TASCAM		0x00022e
 
 #define MODEL_SATELLITE		0x00200f
 
@@ -154,6 +155,15 @@ static void detect_quirks(struct snd_oxfw *oxfw)
 	 */
 	if (vendor == VENDOR_LOUD && model == MODEL_SATELLITE)
 		oxfw->wrong_dbs = true;
+
+	/*
+	 * TASCAM FireOne has physical control and requires a pair of additional
+	 * MIDI ports.
+	 */
+	if (vendor == VENDOR_TASCAM) {
+		oxfw->midi_input_ports++;
+		oxfw->midi_output_ports++;
+	}
 }
 
 static int oxfw_probe(struct fw_unit *unit,
@@ -323,6 +333,13 @@ static const struct ieee1394_device_id oxfw_id_table[] = {
 		.specifier_id	= SPECIFIER_1394TA,
 		.version	= VERSION_AVC,
 	},
+	/* TASCAM, FireOne */
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= VENDOR_TASCAM,
+		.model_id	= 0x800007,
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(ieee1394, oxfw_id_table);

commit 13f3a46d2a6cbdff1bbb06fac6de7dce753db8e1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Sep 20 21:18:55 2015 +0900

    ALSA: oxfw: add Mackie Onyx Satellite quirk to inform wrong value in 'dbs' field in tx CIP header
    
    Mackie Onyx Satellite has two usage; standalone and with base station.
    
    These two modes has different stream formats. In standalone mode, rx data
    block includes 2 Multi Bit Linear Audio (MBLA) data channels and tx data
    block includes 2. With base station, they're 6 and 2.
    
    Although, with base station, the actual tx packet include wrong value in
    'dbs' field in its CIP header. This quirk causes packet streaming layer to
    detect packet discontinuity and to stop PCM substream.
    
    This is a response of 'single' subfunction 'extended stream format
    information' command in AV/C Stream Format Information Specification 1.1.
    It means that a data block in tx packets includes 2 MBLA data channels.
    
    $ ./firewire-request /dev/fw1 fcp 0x01ffbfc001000000ffffffff
    response: 000: 0c ff bf c0 01 00 00 00 ff 00 90 40 03 02 01 02
    response: 010: 06
    
    Current OXFW driver parses the response and detects stream formats
    correctly.
    
    $ cat /proc/asound/card1/firewire/formation
    ...
    Output Stream from device:
            Rate    PCM     MIDI
    *       48000   2       0
            44100   2       0
            88200   2       0
            96000   2       0
    
    On the other hand, in actual tx CIP, the 'dbs' field has 6. But the number
    of quadlets in CIP payload is not multiple of 6. Seeing the subtraction of
    two successive payload quadlets, it should be multiple of 2.
    
    payload  CIP      CIP
    quadlets header0  header1
          24 00060052 9002ffff
          24 0006005e 9002ffff
          26 0006006a 9002ffff
          24 00060077 9002ffff
          24 00060083 9002ffff
          26 0006008f 9002ffff
          24 0006009c 9002ffff
          24 000600a8 9002ffff
          26 000600b4 9002ffff
          24 000600c1 9002ffff
    
    This commit adds support for this quirk to OXFW driver, by using
    CIP_WRONG_DBS flag. When this flag is set, packet streaming layer uses
    the value of its 'data_block_quadlets' member instead of the value in CIP
    header. This value is already set by OXFW driver and no discontinuity is
    detected.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 8c6ce019f437..d606e3a9ce97 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -19,6 +19,8 @@
 #define VENDOR_BEHRINGER	0x001564
 #define VENDOR_LACIE		0x00d04b
 
+#define MODEL_SATELLITE		0x00200f
+
 #define SPECIFIER_1394TA	0x00a02d
 #define VERSION_AVC		0x010001
 
@@ -129,6 +131,31 @@ static void oxfw_card_free(struct snd_card *card)
 	mutex_destroy(&oxfw->mutex);
 }
 
+static void detect_quirks(struct snd_oxfw *oxfw)
+{
+	struct fw_device *fw_dev = fw_parent_device(oxfw->unit);
+	struct fw_csr_iterator it;
+	int key, val;
+	int vendor, model;
+
+	/* Seek from Root Directory of Config ROM. */
+	vendor = model = 0;
+	fw_csr_iterator_init(&it, fw_dev->config_rom + 5);
+	while (fw_csr_iterator_next(&it, &key, &val)) {
+		if (key == CSR_VENDOR)
+			vendor = val;
+		else if (key == CSR_MODEL)
+			model = val;
+	}
+
+	/*
+	 * Mackie Onyx Satellite with base station has a quirk to report a wrong
+	 * value in 'dbs' field of CIP header against its format information.
+	 */
+	if (vendor == VENDOR_LOUD && model == MODEL_SATELLITE)
+		oxfw->wrong_dbs = true;
+}
+
 static int oxfw_probe(struct fw_unit *unit,
 		       const struct ieee1394_device_id *id)
 {
@@ -157,6 +184,8 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	detect_quirks(oxfw);
+
 	err = name_card(oxfw);
 	if (err < 0)
 		goto error;

commit dec84316dd53c90e93b4ee849483bd4bd1e9a585
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 21 23:55:00 2015 +0900

    ALSA: fireworks/bebob/dice/oxfw: make it possible to shutdown safely
    
    A part of these drivers, especially BeBoB driver, are programmed to wait
    some events. Thus the drivers should not destroy any data in .remove()
    context.
    
    This commit moves some destructors from 'struct fw_driver.remove()' to
    'struct snd_card.private_free()' to shutdown safely.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 1607b26404c3..8c6ce019f437 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -115,6 +115,10 @@ static void oxfw_card_free(struct snd_card *card)
 	struct snd_oxfw *oxfw = card->private_data;
 	unsigned int i;
 
+	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
+	if (oxfw->has_output)
+		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
+
 	fw_unit_put(oxfw->unit);
 
 	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
@@ -220,12 +224,6 @@ static void oxfw_remove(struct fw_unit *unit)
 {
 	struct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);
 
-	snd_card_disconnect(oxfw->card);
-
-	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
-	if (oxfw->has_output)
-		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
-
 	/* No need to wait for releasing card object in this context. */
 	snd_card_free_when_closed(oxfw->card);
 }

commit 12ed719291a953d443921f9cdb0ffee41066c340
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 21 23:54:57 2015 +0900

    ALSA: fireworks/bebob/dice/oxfw: add reference-counting for FireWire unit
    
    Fireworks and Dice drivers try to touch instances of FireWire unit after
    sound card object is released, while references to the unit is decremented
    in .remove(). When unplugging during streaming, sound card object is
    released after .remove(), thus Fireworks and Dice drivers causes GPF or
    Null-pointer-dereferencing to application processes because an instance of
    FireWire unit was already released.
    
    This commit adds reference-counting for FireWire unit in drivers to allow
    them to touch an instance of FireWire unit after .remove(). In most case,
    any operations after .remove() may be failed safely.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 60e5cad0531a..1607b26404c3 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -104,11 +104,19 @@ static int name_card(struct snd_oxfw *oxfw)
 	return err;
 }
 
+/*
+ * This module releases the FireWire unit data after all ALSA character devices
+ * are released by applications. This is for releasing stream data or finishing
+ * transactions safely. Thus at returning from .remove(), this module still keep
+ * references for the unit.
+ */
 static void oxfw_card_free(struct snd_card *card)
 {
 	struct snd_oxfw *oxfw = card->private_data;
 	unsigned int i;
 
+	fw_unit_put(oxfw->unit);
+
 	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
 		kfree(oxfw->tx_stream_formats[i]);
 		kfree(oxfw->rx_stream_formats[i]);
@@ -136,7 +144,7 @@ static int oxfw_probe(struct fw_unit *unit,
 	oxfw = card->private_data;
 	oxfw->card = card;
 	mutex_init(&oxfw->mutex);
-	oxfw->unit = unit;
+	oxfw->unit = fw_unit_get(unit);
 	oxfw->device_info = (const struct device_info *)id->driver_data;
 	spin_lock_init(&oxfw->lock);
 	init_waitqueue_head(&oxfw->hwdep_wait);
@@ -218,6 +226,7 @@ static void oxfw_remove(struct fw_unit *unit)
 	if (oxfw->has_output)
 		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
 
+	/* No need to wait for releasing card object in this context. */
 	snd_card_free_when_closed(oxfw->card);
 }
 

commit 0d3aba30b755fe9ccaf390f0e71f6fb9fd55bd87
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Dec 12 22:28:10 2014 +0300

    ALSA: oxfw: fix detect_loud_models() return value
    
    This code causes a static checker warning:
    
            sound/firewire/oxfw/oxfw.c:46 detect_loud_models()
            warn: signedness bug returning '(-2)'
    
    The detect_loud_models() function should return false on falure, so that
    we don't try to set up the loud code for hardware that doesn't support
    it.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index cf1d0b55e827..60e5cad0531a 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -43,7 +43,7 @@ static bool detect_loud_models(struct fw_unit *unit)
 	err = fw_csr_string(unit->directory, CSR_MODEL,
 			    model, sizeof(model));
 	if (err < 0)
-		return err;
+		return false;
 
 	for (i = 0; i < ARRAY_SIZE(models); i++) {
 		if (strcmp(models[i], model) == 0)

commit 8985f4ac1c42bd25799f294f4e87fa73064673c7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:49 2014 +0900

    ALSA: oxfw: Add hwdep interface
    
    This interface is designed for mixer/control application. By using this
    interface, an application can get information about firewire node, can
    lock/unlock kernel streaming and can get notification at starting/stopping
    kernel streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 9cfbfb168dac..cf1d0b55e827 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -139,6 +139,7 @@ static int oxfw_probe(struct fw_unit *unit,
 	oxfw->unit = unit;
 	oxfw->device_info = (const struct device_info *)id->driver_data;
 	spin_lock_init(&oxfw->lock);
+	init_waitqueue_head(&oxfw->hwdep_wait);
 
 	err = snd_oxfw_stream_discover(oxfw);
 	if (err < 0)
@@ -164,6 +165,10 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_oxfw_create_hwdep(oxfw);
+	if (err < 0)
+		goto error;
+
 	err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->rx_stream);
 	if (err < 0)
 		goto error;

commit 05588d340a128ff5c7b768c517150e31842a78aa
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:48 2014 +0900

    ALSA: oxfw: Add support for capture/playback MIDI messages
    
    This commit adds MIDI functionality with an assumption of 'if the device
    has MIDI comformant data channels in its stream formation, the device has
    one MIDI port'.
    
    When no streams have already started, MIDI functionality starts stream
    with current sampling rate.
    
    When MIDI functionality has already starts some streams and PCM
    functionality is going to start streams at different sampling rate,
    this driver stops streams once and changes sampling rate, then restarts
    streams for both PCM/MIDI substreams.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 23c00a2bb7d3..9cfbfb168dac 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -138,6 +138,7 @@ static int oxfw_probe(struct fw_unit *unit,
 	mutex_init(&oxfw->mutex);
 	oxfw->unit = unit;
 	oxfw->device_info = (const struct device_info *)id->driver_data;
+	spin_lock_init(&oxfw->lock);
 
 	err = snd_oxfw_stream_discover(oxfw);
 	if (err < 0)
@@ -159,6 +160,10 @@ static int oxfw_probe(struct fw_unit *unit,
 
 	snd_oxfw_proc_init(oxfw);
 
+	err = snd_oxfw_create_midi(oxfw);
+	if (err < 0)
+		goto error;
+
 	err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->rx_stream);
 	if (err < 0)
 		goto error;

commit b0ac00095fe1485f60bb8ea7326426d3d02a1aec
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:46 2014 +0900

    ALSA: oxfw: Add support AMDTP in-stream
    
    Previous commit adds support for some devices which can capture PCM samples.
    These devices transmit AMDTP stream in non-blocking mode. This commit adds
    functionality to handle AMDTP incoming stream.
    
    OXFW seems to have two quirks:
     - Transmits packets with non-zero dbc in its beginning
     - Transmits packets with wrong values in syt field
    
    For the first quirk, this commit adds CIP_SKIP_INIT_DBC_CHECK flag for
    incoming stream to skip first check of dbc.
    
    For the second quirk, this commit doesn't add duplex stream which
    Fireworks/BeBoB drivers use. So OXFW driver generates syt value for outgoing
    stream.
    
    Here are examples of a sequence of packets transmitted by Behringer F-Control
    Audio 202. There are differences between sequences of syt value when OXFW
    driver transfers outgoing stream or not.
    
    When driver gives no outgoing stream:
    Index   Payload CIP_Header_0    CIP_Header_1
    38      14      00020092        900103D1
    39      12      00020098        900102FF
    40      12      0002009D        9001027F
    41      14      000200A2        90010396
    42      14      000200A8        900102E8
    43      12      000200AE        90010219
    44      14      000200B3        90010331
    45      12      000200B9        9001025F
    46      14      000200BE        90010376
    47      12      000200C4        900102A1
    00      12      000200C9        9001023E
    01      14      000200CE        90010358
    02      12      000200D4        90010289
    03      16      000200D9        900103A3
    04      12      000200E0        900102DD
    05      14      000200E5        900103F1
    06      12      000200EB        90010335
    07      12      000200F0        90010263
    08      14      000200F5        9001037C
    09      12      000200FB        900102AE
    
    When driver gives outgoing stream:
    Index   Payload CIP_Header_0    CIP_Header_1
    38      12      000200BD        900104A8
    39      14      000200C2        900104A8
    40      12      000200C8        900104AC
    41      14      000200CD        900104A9
    42      12      000200D3        900104B1
    43      14      000200D8        900104A8
    44      12      000200DE        900104AA
    45      14      000200E3        900104A9
    46      14      000200E9        900104AE
    47      12      000200EF        900104A8
    00      14      000200F4        900104AD
    01      12      000200FA        900104A7
    02      14      000200FF        900104A9
    03      12      00020005        900104A9
    04      14      0002000A        900104B1
    05      12      00020010        900104AA
    06      14      00020015        900104AD
    07      12      0002001B        900104A7
    08      14      00020020        900104AC
    09      12      00020026        900104A7
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 797af33c7bcb..23c00a2bb7d3 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -109,8 +109,10 @@ static void oxfw_card_free(struct snd_card *card)
 	struct snd_oxfw *oxfw = card->private_data;
 	unsigned int i;
 
-	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++)
+	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
+		kfree(oxfw->tx_stream_formats[i]);
 		kfree(oxfw->rx_stream_formats[i]);
+	}
 
 	mutex_destroy(&oxfw->mutex);
 }
@@ -157,13 +159,20 @@ static int oxfw_probe(struct fw_unit *unit,
 
 	snd_oxfw_proc_init(oxfw);
 
-	err = snd_oxfw_stream_init_simplex(oxfw);
+	err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->rx_stream);
 	if (err < 0)
 		goto error;
+	if (oxfw->has_output) {
+		err = snd_oxfw_stream_init_simplex(oxfw, &oxfw->tx_stream);
+		if (err < 0)
+			goto error;
+	}
 
 	err = snd_card_register(card);
 	if (err < 0) {
-		snd_oxfw_stream_destroy_simplex(oxfw);
+		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
+		if (oxfw->has_output)
+			snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
 		goto error;
 	}
 	dev_set_drvdata(&unit->device, oxfw);
@@ -181,7 +190,11 @@ static void oxfw_bus_reset(struct fw_unit *unit)
 	fcp_bus_reset(oxfw->unit);
 
 	mutex_lock(&oxfw->mutex);
-	snd_oxfw_stream_update_simplex(oxfw);
+
+	snd_oxfw_stream_update_simplex(oxfw, &oxfw->rx_stream);
+	if (oxfw->has_output)
+		snd_oxfw_stream_update_simplex(oxfw, &oxfw->tx_stream);
+
 	mutex_unlock(&oxfw->mutex);
 }
 
@@ -191,7 +204,9 @@ static void oxfw_remove(struct fw_unit *unit)
 
 	snd_card_disconnect(oxfw->card);
 
-	snd_oxfw_stream_destroy_simplex(oxfw);
+	snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->rx_stream);
+	if (oxfw->has_output)
+		snd_oxfw_stream_destroy_simplex(oxfw, &oxfw->tx_stream);
 
 	snd_card_free_when_closed(oxfw->card);
 }

commit ec4dba5053e1109368fb80d1c0b88f2a9c971122
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:45 2014 +0900

    ALSA: oxfw: Add support for Behringer/Mackie devices
    
    Some devices produced by Behringer/Mackie are based on OXFW970/971. This
    commit adds support for them. Additionally, this commit changes the way to
    name card with some information in config rom.
    
    Ids of some Mackie(Loud) models are not identified, therefore this commit
    applies name detection for these models.
    
    The devices support capture/playback of PCM-samples and some of them
    supports capture/playback of MIDI messages. These functionalities are
    implemented by followed commits.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index a70149ab511b..797af33c7bcb 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -14,7 +14,9 @@
 #define OXFORD_HARDWARE_ID_OXFW970	0x39443841
 #define OXFORD_HARDWARE_ID_OXFW971	0x39373100
 
+#define VENDOR_LOUD		0x000ff2
 #define VENDOR_GRIFFIN		0x001292
+#define VENDOR_BEHRINGER	0x001564
 #define VENDOR_LACIE		0x00d04b
 
 #define SPECIFIER_1394TA	0x00a02d
@@ -25,22 +27,69 @@ MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("snd-firewire-speakers");
 
+static bool detect_loud_models(struct fw_unit *unit)
+{
+	const char *const models[] = {
+		"Onyxi",
+		"Onyx-i",
+		"d.Pro",
+		"Mackie Onyx Satellite",
+		"Tapco LINK.firewire 4x6",
+		"U.420"};
+	char model[32];
+	unsigned int i;
+	int err;
+
+	err = fw_csr_string(unit->directory, CSR_MODEL,
+			    model, sizeof(model));
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < ARRAY_SIZE(models); i++) {
+		if (strcmp(models[i], model) == 0)
+			break;
+	}
+
+	return (i < ARRAY_SIZE(models));
+}
+
 static int name_card(struct snd_oxfw *oxfw)
 {
 	struct fw_device *fw_dev = fw_parent_device(oxfw->unit);
+	char vendor[24];
+	char model[32];
 	const char *d, *v, *m;
 	u32 firmware;
 	int err;
 
+	/* get vendor name from root directory */
+	err = fw_csr_string(fw_dev->config_rom + 5, CSR_VENDOR,
+			    vendor, sizeof(vendor));
+	if (err < 0)
+		goto end;
+
+	/* get model name from unit directory */
+	err = fw_csr_string(oxfw->unit->directory, CSR_MODEL,
+			    model, sizeof(model));
+	if (err < 0)
+		goto end;
+
 	err = snd_fw_transaction(oxfw->unit, TCODE_READ_QUADLET_REQUEST,
 				 OXFORD_FIRMWARE_ID_ADDRESS, &firmware, 4, 0);
 	if (err < 0)
 		goto end;
 	be32_to_cpus(&firmware);
 
-	d = oxfw->device_info->driver_name;
-	v = oxfw->device_info->vendor_name;
-	m = oxfw->device_info->model_name;
+	/* to apply card definitions */
+	if (oxfw->device_info) {
+		d = oxfw->device_info->driver_name;
+		v = oxfw->device_info->vendor_name;
+		m = oxfw->device_info->model_name;
+	} else {
+		d = "OXFW";
+		v = vendor;
+		m = model;
+	}
 
 	strcpy(oxfw->card->driver, d);
 	strcpy(oxfw->card->mixername, m);
@@ -73,6 +122,9 @@ static int oxfw_probe(struct fw_unit *unit,
 	struct snd_oxfw *oxfw;
 	int err;
 
+	if ((id->vendor_id == VENDOR_LOUD) && !detect_loud_models(unit))
+		return -ENODEV;
+
 	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
 			   sizeof(*oxfw), &card);
 	if (err < 0)
@@ -97,9 +149,11 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_oxfw_create_mixer(oxfw);
-	if (err < 0)
-		goto error;
+	if (oxfw->device_info) {
+		err = snd_oxfw_create_mixer(oxfw);
+		if (err < 0)
+			goto error;
+	}
 
 	snd_oxfw_proc_init(oxfw);
 
@@ -183,6 +237,31 @@ static const struct ieee1394_device_id oxfw_id_table[] = {
 		.version      = VERSION_AVC,
 		.driver_data  = (kernel_ulong_t)&lacie_speakers,
 	},
+	/* Behringer,F-Control Audio 202 */
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= VENDOR_BEHRINGER,
+		.model_id	= 0x00fc22,
+	},
+	/*
+	 * Any Mackie(Loud) models (name string/model id):
+	 *  Onyx-i series (former models):	0x081216
+	 *  Mackie Onyx Satellite:		0x00200f
+	 *  Tapco LINK.firewire 4x6:		0x000460
+	 *  d.2 pro:				Unknown
+	 *  d.4 pro:				Unknown
+	 *  U.420:				Unknown
+	 *  U.420d:				Unknown
+	 */
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_SPECIFIER_ID |
+				  IEEE1394_MATCH_VERSION,
+		.vendor_id	= VENDOR_LOUD,
+		.specifier_id	= SPECIFIER_1394TA,
+		.version	= VERSION_AVC,
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(ieee1394, oxfw_id_table);

commit 3c96101f190020e91d413c5835f7a722fc007923
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:43 2014 +0900

    ALSA: oxfw: Add proc interface for debugging purpose
    
    This commit adds proc interface to get information about stream
    formation. This commit also adds snd_oxfw_stream_get_current_formation()
    to get current stream formation.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index a8f9062b2884..a70149ab511b 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -101,6 +101,8 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	snd_oxfw_proc_init(oxfw);
+
 	err = snd_oxfw_stream_init_simplex(oxfw);
 	if (err < 0)
 		goto error;

commit 5cd1d3f47a6321612a51ab88ffe8ef65120fcbe0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:42 2014 +0900

    ALSA: oxfw: Change the way to make PCM rules/constraints
    
    In previous commit, this driver can get to know stream formations at
    each supported sampling rates. This commit uses it to make PCM
    rules/constraints and obsoletes hard-coded rules/constraints.
    
    For this purpose, this commit adds 'struct snd_oxfw_stream_formation' and
    snd_oxfw_stream_parse_format() to parse data channel formation of data
    block.
    
    According to datasheet of OXFW970/971, they support 32.0kHz to 196.0kHz.
    
    As long as developers investigate, some devices are confirmed to have
    several formats for the same sampling rate.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index dd576bf61c37..a8f9062b2884 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -58,6 +58,10 @@ static int name_card(struct snd_oxfw *oxfw)
 static void oxfw_card_free(struct snd_card *card)
 {
 	struct snd_oxfw *oxfw = card->private_data;
+	unsigned int i;
+
+	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++)
+		kfree(oxfw->rx_stream_formats[i]);
 
 	mutex_destroy(&oxfw->mutex);
 }
@@ -81,6 +85,10 @@ static int oxfw_probe(struct fw_unit *unit,
 	oxfw->unit = unit;
 	oxfw->device_info = (const struct device_info *)id->driver_data;
 
+	err = snd_oxfw_stream_discover(oxfw);
+	if (err < 0)
+		goto error;
+
 	err = name_card(oxfw);
 	if (err < 0)
 		goto error;
@@ -136,7 +144,6 @@ static const struct device_info griffin_firewave = {
 	.driver_name = "FireWave",
 	.vendor_name = "Griffin",
 	.model_name = "FireWave",
-	.pcm_constraints = firewave_constraints,
 	.mixer_channels = 6,
 	.mute_fb_id   = 0x01,
 	.volume_fb_id = 0x02,
@@ -146,7 +153,6 @@ static const struct device_info lacie_speakers = {
 	.driver_name = "FWSpeakers",
 	.vendor_name = "LaCie",
 	.model_name = "FireWire Speakers",
-	.pcm_constraints = lacie_speakers_constraints,
 	.mixer_channels = 1,
 	.mute_fb_id   = 0x01,
 	.volume_fb_id = 0x01,

commit fec7b7536207897693e708411dcb95909d56c431
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:40 2014 +0900

    ALSA: oxfw: Change the way to name card
    
    This is a preparation for more models. In following commit, members
    of 'struct snd_card' related to name becomes to consists of vendor and
    model strings in device's config-rom.
    
    Current supported devices also has strings in their config rom, but the
    strings are too long to name sound card, thus this driver still keep
    hard-coded vendor and model names for them.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 951d9a4e2102..dd576bf61c37 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -25,14 +25,34 @@ MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("snd-firewire-speakers");
 
-static u32 oxfw_read_firmware_version(struct fw_unit *unit)
+static int name_card(struct snd_oxfw *oxfw)
 {
-	__be32 data;
+	struct fw_device *fw_dev = fw_parent_device(oxfw->unit);
+	const char *d, *v, *m;
+	u32 firmware;
 	int err;
 
-	err = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,
-				 OXFORD_FIRMWARE_ID_ADDRESS, &data, 4, 0);
-	return err >= 0 ? be32_to_cpu(data) : 0;
+	err = snd_fw_transaction(oxfw->unit, TCODE_READ_QUADLET_REQUEST,
+				 OXFORD_FIRMWARE_ID_ADDRESS, &firmware, 4, 0);
+	if (err < 0)
+		goto end;
+	be32_to_cpus(&firmware);
+
+	d = oxfw->device_info->driver_name;
+	v = oxfw->device_info->vendor_name;
+	m = oxfw->device_info->model_name;
+
+	strcpy(oxfw->card->driver, d);
+	strcpy(oxfw->card->mixername, m);
+	strcpy(oxfw->card->shortname, m);
+
+	snprintf(oxfw->card->longname, sizeof(oxfw->card->longname),
+		 "%s %s (OXFW%x %04x), GUID %08x%08x at %s, S%d",
+		 v, m, firmware >> 20, firmware & 0xffff,
+		 fw_dev->config_rom[3], fw_dev->config_rom[4],
+		 dev_name(&oxfw->unit->device), 100 << fw_dev->max_speed);
+end:
+	return err;
 }
 
 static void oxfw_card_free(struct snd_card *card)
@@ -45,10 +65,8 @@ static void oxfw_card_free(struct snd_card *card)
 static int oxfw_probe(struct fw_unit *unit,
 		       const struct ieee1394_device_id *id)
 {
-	struct fw_device *fw_dev = fw_parent_device(unit);
 	struct snd_card *card;
 	struct snd_oxfw *oxfw;
-	u32 firmware;
 	int err;
 
 	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
@@ -63,16 +81,9 @@ static int oxfw_probe(struct fw_unit *unit,
 	oxfw->unit = unit;
 	oxfw->device_info = (const struct device_info *)id->driver_data;
 
-	strcpy(card->driver, oxfw->device_info->driver_name);
-	strcpy(card->shortname, oxfw->device_info->short_name);
-	firmware = oxfw_read_firmware_version(unit);
-	snprintf(card->longname, sizeof(card->longname),
-		 "%s (OXFW%x %04x), GUID %08x%08x at %s, S%d",
-		 oxfw->device_info->long_name,
-		 firmware >> 20, firmware & 0xffff,
-		 fw_dev->config_rom[3], fw_dev->config_rom[4],
-		 dev_name(&unit->device), 100 << fw_dev->max_speed);
-	strcpy(card->mixername, "OXFW");
+	err = name_card(oxfw);
+	if (err < 0)
+		goto error;
 
 	err = snd_oxfw_create_pcm(oxfw);
 	if (err < 0)
@@ -123,8 +134,8 @@ static void oxfw_remove(struct fw_unit *unit)
 
 static const struct device_info griffin_firewave = {
 	.driver_name = "FireWave",
-	.short_name  = "FireWave",
-	.long_name   = "Griffin FireWave Surround",
+	.vendor_name = "Griffin",
+	.model_name = "FireWave",
 	.pcm_constraints = firewave_constraints,
 	.mixer_channels = 6,
 	.mute_fb_id   = 0x01,
@@ -133,8 +144,8 @@ static const struct device_info griffin_firewave = {
 
 static const struct device_info lacie_speakers = {
 	.driver_name = "FWSpeakers",
-	.short_name  = "FireWire Speakers",
-	.long_name   = "LaCie FireWire Speakers",
+	.vendor_name = "LaCie",
+	.model_name = "FireWire Speakers",
 	.pcm_constraints = lacie_speakers_constraints,
 	.mixer_channels = 1,
 	.mute_fb_id   = 0x01,

commit 31514bfb4ab8ba6f93b5ce5fcc543cb2ac4f96e5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Nov 29 00:59:29 2014 +0900

    ALSA: oxfw: Split control functionality to a new file
    
    This is a help for works in followed patches.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 24bb6dff23cc..951d9a4e2102 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -25,281 +25,6 @@ MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("snd-firewire-speakers");
 
-enum control_action { CTL_READ, CTL_WRITE };
-enum control_attribute {
-	CTL_MIN		= 0x02,
-	CTL_MAX		= 0x03,
-	CTL_CURRENT	= 0x10,
-};
-
-static int oxfw_mute_command(struct snd_oxfw *oxfw, bool *value,
-			      enum control_action action)
-{
-	u8 *buf;
-	u8 response_ok;
-	int err;
-
-	buf = kmalloc(11, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	if (action == CTL_READ) {
-		buf[0] = 0x01;		/* AV/C, STATUS */
-		response_ok = 0x0c;	/*       STABLE */
-	} else {
-		buf[0] = 0x00;		/* AV/C, CONTROL */
-		response_ok = 0x09;	/*       ACCEPTED */
-	}
-	buf[1] = 0x08;			/* audio unit 0 */
-	buf[2] = 0xb8;			/* FUNCTION BLOCK */
-	buf[3] = 0x81;			/* function block type: feature */
-	buf[4] = oxfw->device_info->mute_fb_id; /* function block ID */
-	buf[5] = 0x10;			/* control attribute: current */
-	buf[6] = 0x02;			/* selector length */
-	buf[7] = 0x00;			/* audio channel number */
-	buf[8] = 0x01;			/* control selector: mute */
-	buf[9] = 0x01;			/* control data length */
-	if (action == CTL_READ)
-		buf[10] = 0xff;
-	else
-		buf[10] = *value ? 0x70 : 0x60;
-
-	err = fcp_avc_transaction(oxfw->unit, buf, 11, buf, 11, 0x3fe);
-	if (err < 0)
-		goto error;
-	if (err < 11) {
-		dev_err(&oxfw->unit->device, "short FCP response\n");
-		err = -EIO;
-		goto error;
-	}
-	if (buf[0] != response_ok) {
-		dev_err(&oxfw->unit->device, "mute command failed\n");
-		err = -EIO;
-		goto error;
-	}
-	if (action == CTL_READ)
-		*value = buf[10] == 0x70;
-
-	err = 0;
-
-error:
-	kfree(buf);
-
-	return err;
-}
-
-static int oxfw_volume_command(struct snd_oxfw *oxfw, s16 *value,
-				unsigned int channel,
-				enum control_attribute attribute,
-				enum control_action action)
-{
-	u8 *buf;
-	u8 response_ok;
-	int err;
-
-	buf = kmalloc(12, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	if (action == CTL_READ) {
-		buf[0] = 0x01;		/* AV/C, STATUS */
-		response_ok = 0x0c;	/*       STABLE */
-	} else {
-		buf[0] = 0x00;		/* AV/C, CONTROL */
-		response_ok = 0x09;	/*       ACCEPTED */
-	}
-	buf[1] = 0x08;			/* audio unit 0 */
-	buf[2] = 0xb8;			/* FUNCTION BLOCK */
-	buf[3] = 0x81;			/* function block type: feature */
-	buf[4] = oxfw->device_info->volume_fb_id; /* function block ID */
-	buf[5] = attribute;		/* control attribute */
-	buf[6] = 0x02;			/* selector length */
-	buf[7] = channel;		/* audio channel number */
-	buf[8] = 0x02;			/* control selector: volume */
-	buf[9] = 0x02;			/* control data length */
-	if (action == CTL_READ) {
-		buf[10] = 0xff;
-		buf[11] = 0xff;
-	} else {
-		buf[10] = *value >> 8;
-		buf[11] = *value;
-	}
-
-	err = fcp_avc_transaction(oxfw->unit, buf, 12, buf, 12, 0x3fe);
-	if (err < 0)
-		goto error;
-	if (err < 12) {
-		dev_err(&oxfw->unit->device, "short FCP response\n");
-		err = -EIO;
-		goto error;
-	}
-	if (buf[0] != response_ok) {
-		dev_err(&oxfw->unit->device, "volume command failed\n");
-		err = -EIO;
-		goto error;
-	}
-	if (action == CTL_READ)
-		*value = (buf[10] << 8) | buf[11];
-
-	err = 0;
-
-error:
-	kfree(buf);
-
-	return err;
-}
-
-static int oxfw_mute_get(struct snd_kcontrol *control,
-			  struct snd_ctl_elem_value *value)
-{
-	struct snd_oxfw *oxfw = control->private_data;
-
-	value->value.integer.value[0] = !oxfw->mute;
-
-	return 0;
-}
-
-static int oxfw_mute_put(struct snd_kcontrol *control,
-			  struct snd_ctl_elem_value *value)
-{
-	struct snd_oxfw *oxfw = control->private_data;
-	bool mute;
-	int err;
-
-	mute = !value->value.integer.value[0];
-
-	if (mute == oxfw->mute)
-		return 0;
-
-	err = oxfw_mute_command(oxfw, &mute, CTL_WRITE);
-	if (err < 0)
-		return err;
-	oxfw->mute = mute;
-
-	return 1;
-}
-
-static int oxfw_volume_info(struct snd_kcontrol *control,
-			     struct snd_ctl_elem_info *info)
-{
-	struct snd_oxfw *oxfw = control->private_data;
-
-	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	info->count = oxfw->device_info->mixer_channels;
-	info->value.integer.min = oxfw->volume_min;
-	info->value.integer.max = oxfw->volume_max;
-
-	return 0;
-}
-
-static const u8 channel_map[6] = { 0, 1, 4, 5, 2, 3 };
-
-static int oxfw_volume_get(struct snd_kcontrol *control,
-			    struct snd_ctl_elem_value *value)
-{
-	struct snd_oxfw *oxfw = control->private_data;
-	unsigned int i;
-
-	for (i = 0; i < oxfw->device_info->mixer_channels; ++i)
-		value->value.integer.value[channel_map[i]] = oxfw->volume[i];
-
-	return 0;
-}
-
-static int oxfw_volume_put(struct snd_kcontrol *control,
-			  struct snd_ctl_elem_value *value)
-{
-	struct snd_oxfw *oxfw = control->private_data;
-	unsigned int i, changed_channels;
-	bool equal_values = true;
-	s16 volume;
-	int err;
-
-	for (i = 0; i < oxfw->device_info->mixer_channels; ++i) {
-		if (value->value.integer.value[i] < oxfw->volume_min ||
-		    value->value.integer.value[i] > oxfw->volume_max)
-			return -EINVAL;
-		if (value->value.integer.value[i] !=
-		    value->value.integer.value[0])
-			equal_values = false;
-	}
-
-	changed_channels = 0;
-	for (i = 0; i < oxfw->device_info->mixer_channels; ++i)
-		if (value->value.integer.value[channel_map[i]] !=
-							oxfw->volume[i])
-			changed_channels |= 1 << (i + 1);
-
-	if (equal_values && changed_channels != 0)
-		changed_channels = 1 << 0;
-
-	for (i = 0; i <= oxfw->device_info->mixer_channels; ++i) {
-		volume = value->value.integer.value[channel_map[i ? i - 1 : 0]];
-		if (changed_channels & (1 << i)) {
-			err = oxfw_volume_command(oxfw, &volume, i,
-						   CTL_CURRENT, CTL_WRITE);
-			if (err < 0)
-				return err;
-		}
-		if (i > 0)
-			oxfw->volume[i - 1] = volume;
-	}
-
-	return changed_channels != 0;
-}
-
-static int oxfw_create_mixer(struct snd_oxfw *oxfw)
-{
-	static const struct snd_kcontrol_new controls[] = {
-		{
-			.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-			.name = "PCM Playback Switch",
-			.info = snd_ctl_boolean_mono_info,
-			.get = oxfw_mute_get,
-			.put = oxfw_mute_put,
-		},
-		{
-			.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-			.name = "PCM Playback Volume",
-			.info = oxfw_volume_info,
-			.get = oxfw_volume_get,
-			.put = oxfw_volume_put,
-		},
-	};
-	unsigned int i, first_ch;
-	int err;
-
-	err = oxfw_volume_command(oxfw, &oxfw->volume_min,
-				   0, CTL_MIN, CTL_READ);
-	if (err < 0)
-		return err;
-	err = oxfw_volume_command(oxfw, &oxfw->volume_max,
-				   0, CTL_MAX, CTL_READ);
-	if (err < 0)
-		return err;
-
-	err = oxfw_mute_command(oxfw, &oxfw->mute, CTL_READ);
-	if (err < 0)
-		return err;
-
-	first_ch = oxfw->device_info->mixer_channels == 1 ? 0 : 1;
-	for (i = 0; i < oxfw->device_info->mixer_channels; ++i) {
-		err = oxfw_volume_command(oxfw, &oxfw->volume[i],
-					   first_ch + i, CTL_CURRENT, CTL_READ);
-		if (err < 0)
-			return err;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(controls); ++i) {
-		err = snd_ctl_add(oxfw->card,
-				  snd_ctl_new1(&controls[i], oxfw));
-		if (err < 0)
-			return err;
-	}
-
-	return 0;
-}
-
 static u32 oxfw_read_firmware_version(struct fw_unit *unit)
 {
 	__be32 data;
@@ -353,7 +78,7 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = oxfw_create_mixer(oxfw);
+	err = snd_oxfw_create_mixer(oxfw);
 	if (err < 0)
 		goto error;
 

commit 3713d93a6a12f8629c2660bb4a30d48b98105fca
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Nov 29 00:59:28 2014 +0900

    ALSA: oxfw: Split PCM functionality to a new file
    
    This is a help for works in followed patches.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 40556677ea07..24bb6dff23cc 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -25,244 +25,6 @@ MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("snd-firewire-speakers");
 
-static int firewave_rate_constraint(struct snd_pcm_hw_params *params,
-				    struct snd_pcm_hw_rule *rule)
-{
-	static unsigned int stereo_rates[] = { 48000, 96000 };
-	struct snd_interval *channels =
-			hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
-	struct snd_interval *rate =
-			hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
-
-	/* two channels work only at 48/96 kHz */
-	if (snd_interval_max(channels) < 6)
-		return snd_interval_list(rate, 2, stereo_rates, 0);
-	return 0;
-}
-
-static int firewave_channels_constraint(struct snd_pcm_hw_params *params,
-					struct snd_pcm_hw_rule *rule)
-{
-	static const struct snd_interval all_channels = { .min = 6, .max = 6 };
-	struct snd_interval *rate =
-			hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
-	struct snd_interval *channels =
-			hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
-
-	/* 32/44.1 kHz work only with all six channels */
-	if (snd_interval_max(rate) < 48000)
-		return snd_interval_refine(channels, &all_channels);
-	return 0;
-}
-
-static int firewave_constraints(struct snd_pcm_runtime *runtime)
-{
-	static unsigned int channels_list[] = { 2, 6 };
-	static struct snd_pcm_hw_constraint_list channels_list_constraint = {
-		.count = 2,
-		.list = channels_list,
-	};
-	int err;
-
-	runtime->hw.rates = SNDRV_PCM_RATE_32000 |
-			    SNDRV_PCM_RATE_44100 |
-			    SNDRV_PCM_RATE_48000 |
-			    SNDRV_PCM_RATE_96000;
-	runtime->hw.channels_max = 6;
-
-	err = snd_pcm_hw_constraint_list(runtime, 0,
-					 SNDRV_PCM_HW_PARAM_CHANNELS,
-					 &channels_list_constraint);
-	if (err < 0)
-		return err;
-	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-				  firewave_rate_constraint, NULL,
-				  SNDRV_PCM_HW_PARAM_CHANNELS, -1);
-	if (err < 0)
-		return err;
-	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				  firewave_channels_constraint, NULL,
-				  SNDRV_PCM_HW_PARAM_RATE, -1);
-	if (err < 0)
-		return err;
-
-	return 0;
-}
-
-static int lacie_speakers_constraints(struct snd_pcm_runtime *runtime)
-{
-	runtime->hw.rates = SNDRV_PCM_RATE_32000 |
-			    SNDRV_PCM_RATE_44100 |
-			    SNDRV_PCM_RATE_48000 |
-			    SNDRV_PCM_RATE_88200 |
-			    SNDRV_PCM_RATE_96000;
-
-	return 0;
-}
-
-static int oxfw_open(struct snd_pcm_substream *substream)
-{
-	static const struct snd_pcm_hardware hardware = {
-		.info = SNDRV_PCM_INFO_MMAP |
-			SNDRV_PCM_INFO_MMAP_VALID |
-			SNDRV_PCM_INFO_BATCH |
-			SNDRV_PCM_INFO_INTERLEAVED |
-			SNDRV_PCM_INFO_BLOCK_TRANSFER,
-		.formats = AMDTP_OUT_PCM_FORMAT_BITS,
-		.channels_min = 2,
-		.channels_max = 2,
-		.buffer_bytes_max = 4 * 1024 * 1024,
-		.period_bytes_min = 1,
-		.period_bytes_max = UINT_MAX,
-		.periods_min = 1,
-		.periods_max = UINT_MAX,
-	};
-	struct snd_oxfw *oxfw = substream->private_data;
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	int err;
-
-	runtime->hw = hardware;
-
-	err = oxfw->device_info->pcm_constraints(runtime);
-	if (err < 0)
-		return err;
-	err = snd_pcm_limit_hw_rates(runtime);
-	if (err < 0)
-		return err;
-
-	err = amdtp_stream_add_pcm_hw_constraints(&oxfw->rx_stream, runtime);
-	if (err < 0)
-		return err;
-
-	return 0;
-}
-
-static int oxfw_close(struct snd_pcm_substream *substream)
-{
-	return 0;
-}
-
-static int oxfw_hw_params(struct snd_pcm_substream *substream,
-			   struct snd_pcm_hw_params *hw_params)
-{
-	struct snd_oxfw *oxfw = substream->private_data;
-	int err;
-
-	mutex_lock(&oxfw->mutex);
-
-	snd_oxfw_stream_stop_simplex(oxfw);
-
-	err = snd_pcm_lib_alloc_vmalloc_buffer(substream,
-					       params_buffer_bytes(hw_params));
-	if (err < 0)
-		goto error;
-
-	amdtp_stream_set_parameters(&oxfw->rx_stream,
-				    params_rate(hw_params),
-				    params_channels(hw_params),
-				    0);
-
-	amdtp_stream_set_pcm_format(&oxfw->rx_stream,
-				    params_format(hw_params));
-
-	err = avc_general_set_sig_fmt(oxfw->unit, params_rate(hw_params),
-				      AVC_GENERAL_PLUG_DIR_IN, 0);
-	if (err < 0) {
-		dev_err(&oxfw->unit->device, "failed to set sample rate\n");
-		goto err_buffer;
-	}
-
-	return 0;
-
-err_buffer:
-	snd_pcm_lib_free_vmalloc_buffer(substream);
-error:
-	mutex_unlock(&oxfw->mutex);
-	return err;
-}
-
-static int oxfw_hw_free(struct snd_pcm_substream *substream)
-{
-	struct snd_oxfw *oxfw = substream->private_data;
-
-	mutex_lock(&oxfw->mutex);
-	snd_oxfw_stream_stop_simplex(oxfw);
-	mutex_unlock(&oxfw->mutex);
-
-	return snd_pcm_lib_free_vmalloc_buffer(substream);
-}
-
-static int oxfw_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_oxfw *oxfw = substream->private_data;
-	int err;
-
-	mutex_lock(&oxfw->mutex);
-
-	snd_oxfw_stream_stop_simplex(oxfw);
-
-	err = snd_oxfw_stream_start_simplex(oxfw);
-	if (err < 0)
-		goto end;
-
-	amdtp_stream_pcm_prepare(&oxfw->rx_stream);
-end:
-	mutex_unlock(&oxfw->mutex);
-	return err;
-}
-
-static int oxfw_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-	struct snd_oxfw *oxfw = substream->private_data;
-	struct snd_pcm_substream *pcm;
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		pcm = substream;
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		pcm = NULL;
-		break;
-	default:
-		return -EINVAL;
-	}
-	amdtp_stream_pcm_trigger(&oxfw->rx_stream, pcm);
-	return 0;
-}
-
-static snd_pcm_uframes_t oxfw_pointer(struct snd_pcm_substream *substream)
-{
-	struct snd_oxfw *oxfw = substream->private_data;
-
-	return amdtp_stream_pcm_pointer(&oxfw->rx_stream);
-}
-
-static int oxfw_create_pcm(struct snd_oxfw *oxfw)
-{
-	static struct snd_pcm_ops ops = {
-		.open      = oxfw_open,
-		.close     = oxfw_close,
-		.ioctl     = snd_pcm_lib_ioctl,
-		.hw_params = oxfw_hw_params,
-		.hw_free   = oxfw_hw_free,
-		.prepare   = oxfw_prepare,
-		.trigger   = oxfw_trigger,
-		.pointer   = oxfw_pointer,
-		.page      = snd_pcm_lib_get_vmalloc_page,
-		.mmap      = snd_pcm_lib_mmap_vmalloc,
-	};
-	struct snd_pcm *pcm;
-	int err;
-
-	err = snd_pcm_new(oxfw->card, "OXFW", 0, 1, 0, &pcm);
-	if (err < 0)
-		return err;
-	pcm->private_data = oxfw;
-	strcpy(pcm->name, oxfw->device_info->short_name);
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &ops);
-	return 0;
-}
-
 enum control_action { CTL_READ, CTL_WRITE };
 enum control_attribute {
 	CTL_MIN		= 0x02,
@@ -587,7 +349,7 @@ static int oxfw_probe(struct fw_unit *unit,
 		 dev_name(&unit->device), 100 << fw_dev->max_speed);
 	strcpy(card->mixername, "OXFW");
 
-	err = oxfw_create_pcm(oxfw);
+	err = snd_oxfw_create_pcm(oxfw);
 	if (err < 0)
 		goto error;
 

commit e2786ca648d780d106bd8abca06746eb30d15ee7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Nov 29 00:59:27 2014 +0900

    ALSA: oxfw: Split stream functionality to a new file and add a header file
    
    This is a help for works in followed patches.
    
    And this commit remove 'fw_unit_get()/fw_unit_put()' because these
    are called by helper functions in 'snd-firewire-lib'.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
index 55c687ef3247..40556677ea07 100644
--- a/sound/firewire/oxfw/oxfw.c
+++ b/sound/firewire/oxfw/oxfw.c
@@ -5,22 +5,7 @@
  * Licensed under the terms of the GNU General Public License, version 2.
  */
 
-#include <linux/device.h>
-#include <linux/firewire.h>
-#include <linux/firewire-constants.h>
-#include <linux/module.h>
-#include <linux/mod_devicetable.h>
-#include <linux/mutex.h>
-#include <linux/slab.h>
-#include <sound/control.h>
-#include <sound/core.h>
-#include <sound/initval.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include "../cmp.h"
-#include "../fcp.h"
-#include "../amdtp.h"
-#include "../lib.h"
+#include "oxfw.h"
 
 #define OXFORD_FIRMWARE_ID_ADDRESS	(CSR_REGISTER_BASE + 0x50000)
 /* 0x970?vvvv or 0x971?vvvv, where vvvv = firmware version */
@@ -35,29 +20,6 @@
 #define SPECIFIER_1394TA	0x00a02d
 #define VERSION_AVC		0x010001
 
-struct device_info {
-	const char *driver_name;
-	const char *short_name;
-	const char *long_name;
-	int (*pcm_constraints)(struct snd_pcm_runtime *runtime);
-	unsigned int mixer_channels;
-	u8 mute_fb_id;
-	u8 volume_fb_id;
-};
-
-struct snd_oxfw {
-	struct snd_card *card;
-	struct fw_unit *unit;
-	const struct device_info *device_info;
-	struct mutex mutex;
-	struct cmp_connection in_conn;
-	struct amdtp_stream rx_stream;
-	bool mute;
-	s16 volume[6];
-	s16 volume_min;
-	s16 volume_max;
-};
-
 MODULE_DESCRIPTION("Oxford Semiconductor FW970/971 driver");
 MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_LICENSE("GPL v2");
@@ -180,14 +142,6 @@ static int oxfw_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static void oxfw_stop_stream(struct snd_oxfw *oxfw)
-{
-	if (amdtp_stream_running(&oxfw->rx_stream)) {
-		amdtp_stream_stop(&oxfw->rx_stream);
-		cmp_connection_break(&oxfw->in_conn);
-	}
-}
-
 static int oxfw_hw_params(struct snd_pcm_substream *substream,
 			   struct snd_pcm_hw_params *hw_params)
 {
@@ -195,8 +149,8 @@ static int oxfw_hw_params(struct snd_pcm_substream *substream,
 	int err;
 
 	mutex_lock(&oxfw->mutex);
-	oxfw_stop_stream(oxfw);
-	mutex_unlock(&oxfw->mutex);
+
+	snd_oxfw_stream_stop_simplex(oxfw);
 
 	err = snd_pcm_lib_alloc_vmalloc_buffer(substream,
 					       params_buffer_bytes(hw_params));
@@ -223,6 +177,7 @@ static int oxfw_hw_params(struct snd_pcm_substream *substream,
 err_buffer:
 	snd_pcm_lib_free_vmalloc_buffer(substream);
 error:
+	mutex_unlock(&oxfw->mutex);
 	return err;
 }
 
@@ -231,7 +186,7 @@ static int oxfw_hw_free(struct snd_pcm_substream *substream)
 	struct snd_oxfw *oxfw = substream->private_data;
 
 	mutex_lock(&oxfw->mutex);
-	oxfw_stop_stream(oxfw);
+	snd_oxfw_stream_stop_simplex(oxfw);
 	mutex_unlock(&oxfw->mutex);
 
 	return snd_pcm_lib_free_vmalloc_buffer(substream);
@@ -244,33 +199,15 @@ static int oxfw_prepare(struct snd_pcm_substream *substream)
 
 	mutex_lock(&oxfw->mutex);
 
-	if (amdtp_streaming_error(&oxfw->rx_stream))
-		oxfw_stop_stream(oxfw);
-
-	if (!amdtp_stream_running(&oxfw->rx_stream)) {
-		err = cmp_connection_establish(&oxfw->in_conn,
-			amdtp_stream_get_max_payload(&oxfw->rx_stream));
-		if (err < 0)
-			goto err_mutex;
+	snd_oxfw_stream_stop_simplex(oxfw);
 
-		err = amdtp_stream_start(&oxfw->rx_stream,
-					 oxfw->in_conn.resources.channel,
-					 oxfw->in_conn.speed);
-		if (err < 0)
-			goto err_connection;
-	}
-
-	mutex_unlock(&oxfw->mutex);
+	err = snd_oxfw_stream_start_simplex(oxfw);
+	if (err < 0)
+		goto end;
 
 	amdtp_stream_pcm_prepare(&oxfw->rx_stream);
-
-	return 0;
-
-err_connection:
-	cmp_connection_break(&oxfw->in_conn);
-err_mutex:
+end:
 	mutex_unlock(&oxfw->mutex);
-
 	return err;
 }
 
@@ -615,9 +552,6 @@ static void oxfw_card_free(struct snd_card *card)
 {
 	struct snd_oxfw *oxfw = card->private_data;
 
-	amdtp_stream_destroy(&oxfw->rx_stream);
-	cmp_connection_destroy(&oxfw->in_conn);
-	fw_unit_put(oxfw->unit);
 	mutex_destroy(&oxfw->mutex);
 }
 
@@ -635,23 +569,13 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		return err;
 
+	card->private_free = oxfw_card_free;
 	oxfw = card->private_data;
 	oxfw->card = card;
 	mutex_init(&oxfw->mutex);
-	oxfw->unit = fw_unit_get(unit);
+	oxfw->unit = unit;
 	oxfw->device_info = (const struct device_info *)id->driver_data;
 
-	err = cmp_connection_init(&oxfw->in_conn, unit, CMP_INPUT, 0);
-	if (err < 0)
-		goto err_unit;
-
-	err = amdtp_stream_init(&oxfw->rx_stream, unit, AMDTP_OUT_STREAM,
-				CIP_NONBLOCKING);
-	if (err < 0)
-		goto err_connection;
-
-	card->private_free = oxfw_card_free;
-
 	strcpy(card->driver, oxfw->device_info->driver_name);
 	strcpy(card->shortname, oxfw->device_info->short_name);
 	firmware = oxfw_read_firmware_version(unit);
@@ -671,19 +595,18 @@ static int oxfw_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_card_register(card);
+	err = snd_oxfw_stream_init_simplex(oxfw);
 	if (err < 0)
 		goto error;
 
+	err = snd_card_register(card);
+	if (err < 0) {
+		snd_oxfw_stream_destroy_simplex(oxfw);
+		goto error;
+	}
 	dev_set_drvdata(&unit->device, oxfw);
 
 	return 0;
-
-err_connection:
-	cmp_connection_destroy(&oxfw->in_conn);
-err_unit:
-	fw_unit_put(oxfw->unit);
-	mutex_destroy(&oxfw->mutex);
 error:
 	snd_card_free(card);
 	return err;
@@ -695,27 +618,18 @@ static void oxfw_bus_reset(struct fw_unit *unit)
 
 	fcp_bus_reset(oxfw->unit);
 
-	if (cmp_connection_update(&oxfw->in_conn) < 0) {
-		amdtp_stream_pcm_abort(&oxfw->rx_stream);
-		mutex_lock(&oxfw->mutex);
-		oxfw_stop_stream(oxfw);
-		mutex_unlock(&oxfw->mutex);
-		return;
-	}
-
-	amdtp_stream_update(&oxfw->rx_stream);
+	mutex_lock(&oxfw->mutex);
+	snd_oxfw_stream_update_simplex(oxfw);
+	mutex_unlock(&oxfw->mutex);
 }
 
 static void oxfw_remove(struct fw_unit *unit)
 {
 	struct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);
 
-	amdtp_stream_pcm_abort(&oxfw->rx_stream);
 	snd_card_disconnect(oxfw->card);
 
-	mutex_lock(&oxfw->mutex);
-	oxfw_stop_stream(oxfw);
-	mutex_unlock(&oxfw->mutex);
+	snd_oxfw_stream_destroy_simplex(oxfw);
 
 	snd_card_free_when_closed(oxfw->card);
 }

commit 1a4e39c2e5ca2eb494a53ecd73055562f690bca0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Nov 29 00:59:26 2014 +0900

    ALSA: oxfw: Move to its own directory
    
    Followed commits add much codes. To make the work easy, this commit creates
    own directory and move current file to it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw.c b/sound/firewire/oxfw/oxfw.c
new file mode 100644
index 000000000000..55c687ef3247
--- /dev/null
+++ b/sound/firewire/oxfw/oxfw.c
@@ -0,0 +1,793 @@
+/*
+ * oxfw.c - a part of driver for OXFW970/971 based devices
+ *
+ * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include <linux/device.h>
+#include <linux/firewire.h>
+#include <linux/firewire-constants.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include "../cmp.h"
+#include "../fcp.h"
+#include "../amdtp.h"
+#include "../lib.h"
+
+#define OXFORD_FIRMWARE_ID_ADDRESS	(CSR_REGISTER_BASE + 0x50000)
+/* 0x970?vvvv or 0x971?vvvv, where vvvv = firmware version */
+
+#define OXFORD_HARDWARE_ID_ADDRESS	(CSR_REGISTER_BASE + 0x90020)
+#define OXFORD_HARDWARE_ID_OXFW970	0x39443841
+#define OXFORD_HARDWARE_ID_OXFW971	0x39373100
+
+#define VENDOR_GRIFFIN		0x001292
+#define VENDOR_LACIE		0x00d04b
+
+#define SPECIFIER_1394TA	0x00a02d
+#define VERSION_AVC		0x010001
+
+struct device_info {
+	const char *driver_name;
+	const char *short_name;
+	const char *long_name;
+	int (*pcm_constraints)(struct snd_pcm_runtime *runtime);
+	unsigned int mixer_channels;
+	u8 mute_fb_id;
+	u8 volume_fb_id;
+};
+
+struct snd_oxfw {
+	struct snd_card *card;
+	struct fw_unit *unit;
+	const struct device_info *device_info;
+	struct mutex mutex;
+	struct cmp_connection in_conn;
+	struct amdtp_stream rx_stream;
+	bool mute;
+	s16 volume[6];
+	s16 volume_min;
+	s16 volume_max;
+};
+
+MODULE_DESCRIPTION("Oxford Semiconductor FW970/971 driver");
+MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("snd-firewire-speakers");
+
+static int firewave_rate_constraint(struct snd_pcm_hw_params *params,
+				    struct snd_pcm_hw_rule *rule)
+{
+	static unsigned int stereo_rates[] = { 48000, 96000 };
+	struct snd_interval *channels =
+			hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *rate =
+			hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+
+	/* two channels work only at 48/96 kHz */
+	if (snd_interval_max(channels) < 6)
+		return snd_interval_list(rate, 2, stereo_rates, 0);
+	return 0;
+}
+
+static int firewave_channels_constraint(struct snd_pcm_hw_params *params,
+					struct snd_pcm_hw_rule *rule)
+{
+	static const struct snd_interval all_channels = { .min = 6, .max = 6 };
+	struct snd_interval *rate =
+			hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels =
+			hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	/* 32/44.1 kHz work only with all six channels */
+	if (snd_interval_max(rate) < 48000)
+		return snd_interval_refine(channels, &all_channels);
+	return 0;
+}
+
+static int firewave_constraints(struct snd_pcm_runtime *runtime)
+{
+	static unsigned int channels_list[] = { 2, 6 };
+	static struct snd_pcm_hw_constraint_list channels_list_constraint = {
+		.count = 2,
+		.list = channels_list,
+	};
+	int err;
+
+	runtime->hw.rates = SNDRV_PCM_RATE_32000 |
+			    SNDRV_PCM_RATE_44100 |
+			    SNDRV_PCM_RATE_48000 |
+			    SNDRV_PCM_RATE_96000;
+	runtime->hw.channels_max = 6;
+
+	err = snd_pcm_hw_constraint_list(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_CHANNELS,
+					 &channels_list_constraint);
+	if (err < 0)
+		return err;
+	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				  firewave_rate_constraint, NULL,
+				  SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	if (err < 0)
+		return err;
+	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+				  firewave_channels_constraint, NULL,
+				  SNDRV_PCM_HW_PARAM_RATE, -1);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lacie_speakers_constraints(struct snd_pcm_runtime *runtime)
+{
+	runtime->hw.rates = SNDRV_PCM_RATE_32000 |
+			    SNDRV_PCM_RATE_44100 |
+			    SNDRV_PCM_RATE_48000 |
+			    SNDRV_PCM_RATE_88200 |
+			    SNDRV_PCM_RATE_96000;
+
+	return 0;
+}
+
+static int oxfw_open(struct snd_pcm_substream *substream)
+{
+	static const struct snd_pcm_hardware hardware = {
+		.info = SNDRV_PCM_INFO_MMAP |
+			SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_BATCH |
+			SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER,
+		.formats = AMDTP_OUT_PCM_FORMAT_BITS,
+		.channels_min = 2,
+		.channels_max = 2,
+		.buffer_bytes_max = 4 * 1024 * 1024,
+		.period_bytes_min = 1,
+		.period_bytes_max = UINT_MAX,
+		.periods_min = 1,
+		.periods_max = UINT_MAX,
+	};
+	struct snd_oxfw *oxfw = substream->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+
+	runtime->hw = hardware;
+
+	err = oxfw->device_info->pcm_constraints(runtime);
+	if (err < 0)
+		return err;
+	err = snd_pcm_limit_hw_rates(runtime);
+	if (err < 0)
+		return err;
+
+	err = amdtp_stream_add_pcm_hw_constraints(&oxfw->rx_stream, runtime);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int oxfw_close(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static void oxfw_stop_stream(struct snd_oxfw *oxfw)
+{
+	if (amdtp_stream_running(&oxfw->rx_stream)) {
+		amdtp_stream_stop(&oxfw->rx_stream);
+		cmp_connection_break(&oxfw->in_conn);
+	}
+}
+
+static int oxfw_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_oxfw *oxfw = substream->private_data;
+	int err;
+
+	mutex_lock(&oxfw->mutex);
+	oxfw_stop_stream(oxfw);
+	mutex_unlock(&oxfw->mutex);
+
+	err = snd_pcm_lib_alloc_vmalloc_buffer(substream,
+					       params_buffer_bytes(hw_params));
+	if (err < 0)
+		goto error;
+
+	amdtp_stream_set_parameters(&oxfw->rx_stream,
+				    params_rate(hw_params),
+				    params_channels(hw_params),
+				    0);
+
+	amdtp_stream_set_pcm_format(&oxfw->rx_stream,
+				    params_format(hw_params));
+
+	err = avc_general_set_sig_fmt(oxfw->unit, params_rate(hw_params),
+				      AVC_GENERAL_PLUG_DIR_IN, 0);
+	if (err < 0) {
+		dev_err(&oxfw->unit->device, "failed to set sample rate\n");
+		goto err_buffer;
+	}
+
+	return 0;
+
+err_buffer:
+	snd_pcm_lib_free_vmalloc_buffer(substream);
+error:
+	return err;
+}
+
+static int oxfw_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_oxfw *oxfw = substream->private_data;
+
+	mutex_lock(&oxfw->mutex);
+	oxfw_stop_stream(oxfw);
+	mutex_unlock(&oxfw->mutex);
+
+	return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int oxfw_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_oxfw *oxfw = substream->private_data;
+	int err;
+
+	mutex_lock(&oxfw->mutex);
+
+	if (amdtp_streaming_error(&oxfw->rx_stream))
+		oxfw_stop_stream(oxfw);
+
+	if (!amdtp_stream_running(&oxfw->rx_stream)) {
+		err = cmp_connection_establish(&oxfw->in_conn,
+			amdtp_stream_get_max_payload(&oxfw->rx_stream));
+		if (err < 0)
+			goto err_mutex;
+
+		err = amdtp_stream_start(&oxfw->rx_stream,
+					 oxfw->in_conn.resources.channel,
+					 oxfw->in_conn.speed);
+		if (err < 0)
+			goto err_connection;
+	}
+
+	mutex_unlock(&oxfw->mutex);
+
+	amdtp_stream_pcm_prepare(&oxfw->rx_stream);
+
+	return 0;
+
+err_connection:
+	cmp_connection_break(&oxfw->in_conn);
+err_mutex:
+	mutex_unlock(&oxfw->mutex);
+
+	return err;
+}
+
+static int oxfw_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_oxfw *oxfw = substream->private_data;
+	struct snd_pcm_substream *pcm;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		pcm = substream;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		pcm = NULL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	amdtp_stream_pcm_trigger(&oxfw->rx_stream, pcm);
+	return 0;
+}
+
+static snd_pcm_uframes_t oxfw_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_oxfw *oxfw = substream->private_data;
+
+	return amdtp_stream_pcm_pointer(&oxfw->rx_stream);
+}
+
+static int oxfw_create_pcm(struct snd_oxfw *oxfw)
+{
+	static struct snd_pcm_ops ops = {
+		.open      = oxfw_open,
+		.close     = oxfw_close,
+		.ioctl     = snd_pcm_lib_ioctl,
+		.hw_params = oxfw_hw_params,
+		.hw_free   = oxfw_hw_free,
+		.prepare   = oxfw_prepare,
+		.trigger   = oxfw_trigger,
+		.pointer   = oxfw_pointer,
+		.page      = snd_pcm_lib_get_vmalloc_page,
+		.mmap      = snd_pcm_lib_mmap_vmalloc,
+	};
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_pcm_new(oxfw->card, "OXFW", 0, 1, 0, &pcm);
+	if (err < 0)
+		return err;
+	pcm->private_data = oxfw;
+	strcpy(pcm->name, oxfw->device_info->short_name);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &ops);
+	return 0;
+}
+
+enum control_action { CTL_READ, CTL_WRITE };
+enum control_attribute {
+	CTL_MIN		= 0x02,
+	CTL_MAX		= 0x03,
+	CTL_CURRENT	= 0x10,
+};
+
+static int oxfw_mute_command(struct snd_oxfw *oxfw, bool *value,
+			      enum control_action action)
+{
+	u8 *buf;
+	u8 response_ok;
+	int err;
+
+	buf = kmalloc(11, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (action == CTL_READ) {
+		buf[0] = 0x01;		/* AV/C, STATUS */
+		response_ok = 0x0c;	/*       STABLE */
+	} else {
+		buf[0] = 0x00;		/* AV/C, CONTROL */
+		response_ok = 0x09;	/*       ACCEPTED */
+	}
+	buf[1] = 0x08;			/* audio unit 0 */
+	buf[2] = 0xb8;			/* FUNCTION BLOCK */
+	buf[3] = 0x81;			/* function block type: feature */
+	buf[4] = oxfw->device_info->mute_fb_id; /* function block ID */
+	buf[5] = 0x10;			/* control attribute: current */
+	buf[6] = 0x02;			/* selector length */
+	buf[7] = 0x00;			/* audio channel number */
+	buf[8] = 0x01;			/* control selector: mute */
+	buf[9] = 0x01;			/* control data length */
+	if (action == CTL_READ)
+		buf[10] = 0xff;
+	else
+		buf[10] = *value ? 0x70 : 0x60;
+
+	err = fcp_avc_transaction(oxfw->unit, buf, 11, buf, 11, 0x3fe);
+	if (err < 0)
+		goto error;
+	if (err < 11) {
+		dev_err(&oxfw->unit->device, "short FCP response\n");
+		err = -EIO;
+		goto error;
+	}
+	if (buf[0] != response_ok) {
+		dev_err(&oxfw->unit->device, "mute command failed\n");
+		err = -EIO;
+		goto error;
+	}
+	if (action == CTL_READ)
+		*value = buf[10] == 0x70;
+
+	err = 0;
+
+error:
+	kfree(buf);
+
+	return err;
+}
+
+static int oxfw_volume_command(struct snd_oxfw *oxfw, s16 *value,
+				unsigned int channel,
+				enum control_attribute attribute,
+				enum control_action action)
+{
+	u8 *buf;
+	u8 response_ok;
+	int err;
+
+	buf = kmalloc(12, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (action == CTL_READ) {
+		buf[0] = 0x01;		/* AV/C, STATUS */
+		response_ok = 0x0c;	/*       STABLE */
+	} else {
+		buf[0] = 0x00;		/* AV/C, CONTROL */
+		response_ok = 0x09;	/*       ACCEPTED */
+	}
+	buf[1] = 0x08;			/* audio unit 0 */
+	buf[2] = 0xb8;			/* FUNCTION BLOCK */
+	buf[3] = 0x81;			/* function block type: feature */
+	buf[4] = oxfw->device_info->volume_fb_id; /* function block ID */
+	buf[5] = attribute;		/* control attribute */
+	buf[6] = 0x02;			/* selector length */
+	buf[7] = channel;		/* audio channel number */
+	buf[8] = 0x02;			/* control selector: volume */
+	buf[9] = 0x02;			/* control data length */
+	if (action == CTL_READ) {
+		buf[10] = 0xff;
+		buf[11] = 0xff;
+	} else {
+		buf[10] = *value >> 8;
+		buf[11] = *value;
+	}
+
+	err = fcp_avc_transaction(oxfw->unit, buf, 12, buf, 12, 0x3fe);
+	if (err < 0)
+		goto error;
+	if (err < 12) {
+		dev_err(&oxfw->unit->device, "short FCP response\n");
+		err = -EIO;
+		goto error;
+	}
+	if (buf[0] != response_ok) {
+		dev_err(&oxfw->unit->device, "volume command failed\n");
+		err = -EIO;
+		goto error;
+	}
+	if (action == CTL_READ)
+		*value = (buf[10] << 8) | buf[11];
+
+	err = 0;
+
+error:
+	kfree(buf);
+
+	return err;
+}
+
+static int oxfw_mute_get(struct snd_kcontrol *control,
+			  struct snd_ctl_elem_value *value)
+{
+	struct snd_oxfw *oxfw = control->private_data;
+
+	value->value.integer.value[0] = !oxfw->mute;
+
+	return 0;
+}
+
+static int oxfw_mute_put(struct snd_kcontrol *control,
+			  struct snd_ctl_elem_value *value)
+{
+	struct snd_oxfw *oxfw = control->private_data;
+	bool mute;
+	int err;
+
+	mute = !value->value.integer.value[0];
+
+	if (mute == oxfw->mute)
+		return 0;
+
+	err = oxfw_mute_command(oxfw, &mute, CTL_WRITE);
+	if (err < 0)
+		return err;
+	oxfw->mute = mute;
+
+	return 1;
+}
+
+static int oxfw_volume_info(struct snd_kcontrol *control,
+			     struct snd_ctl_elem_info *info)
+{
+	struct snd_oxfw *oxfw = control->private_data;
+
+	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	info->count = oxfw->device_info->mixer_channels;
+	info->value.integer.min = oxfw->volume_min;
+	info->value.integer.max = oxfw->volume_max;
+
+	return 0;
+}
+
+static const u8 channel_map[6] = { 0, 1, 4, 5, 2, 3 };
+
+static int oxfw_volume_get(struct snd_kcontrol *control,
+			    struct snd_ctl_elem_value *value)
+{
+	struct snd_oxfw *oxfw = control->private_data;
+	unsigned int i;
+
+	for (i = 0; i < oxfw->device_info->mixer_channels; ++i)
+		value->value.integer.value[channel_map[i]] = oxfw->volume[i];
+
+	return 0;
+}
+
+static int oxfw_volume_put(struct snd_kcontrol *control,
+			  struct snd_ctl_elem_value *value)
+{
+	struct snd_oxfw *oxfw = control->private_data;
+	unsigned int i, changed_channels;
+	bool equal_values = true;
+	s16 volume;
+	int err;
+
+	for (i = 0; i < oxfw->device_info->mixer_channels; ++i) {
+		if (value->value.integer.value[i] < oxfw->volume_min ||
+		    value->value.integer.value[i] > oxfw->volume_max)
+			return -EINVAL;
+		if (value->value.integer.value[i] !=
+		    value->value.integer.value[0])
+			equal_values = false;
+	}
+
+	changed_channels = 0;
+	for (i = 0; i < oxfw->device_info->mixer_channels; ++i)
+		if (value->value.integer.value[channel_map[i]] !=
+							oxfw->volume[i])
+			changed_channels |= 1 << (i + 1);
+
+	if (equal_values && changed_channels != 0)
+		changed_channels = 1 << 0;
+
+	for (i = 0; i <= oxfw->device_info->mixer_channels; ++i) {
+		volume = value->value.integer.value[channel_map[i ? i - 1 : 0]];
+		if (changed_channels & (1 << i)) {
+			err = oxfw_volume_command(oxfw, &volume, i,
+						   CTL_CURRENT, CTL_WRITE);
+			if (err < 0)
+				return err;
+		}
+		if (i > 0)
+			oxfw->volume[i - 1] = volume;
+	}
+
+	return changed_channels != 0;
+}
+
+static int oxfw_create_mixer(struct snd_oxfw *oxfw)
+{
+	static const struct snd_kcontrol_new controls[] = {
+		{
+			.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+			.name = "PCM Playback Switch",
+			.info = snd_ctl_boolean_mono_info,
+			.get = oxfw_mute_get,
+			.put = oxfw_mute_put,
+		},
+		{
+			.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+			.name = "PCM Playback Volume",
+			.info = oxfw_volume_info,
+			.get = oxfw_volume_get,
+			.put = oxfw_volume_put,
+		},
+	};
+	unsigned int i, first_ch;
+	int err;
+
+	err = oxfw_volume_command(oxfw, &oxfw->volume_min,
+				   0, CTL_MIN, CTL_READ);
+	if (err < 0)
+		return err;
+	err = oxfw_volume_command(oxfw, &oxfw->volume_max,
+				   0, CTL_MAX, CTL_READ);
+	if (err < 0)
+		return err;
+
+	err = oxfw_mute_command(oxfw, &oxfw->mute, CTL_READ);
+	if (err < 0)
+		return err;
+
+	first_ch = oxfw->device_info->mixer_channels == 1 ? 0 : 1;
+	for (i = 0; i < oxfw->device_info->mixer_channels; ++i) {
+		err = oxfw_volume_command(oxfw, &oxfw->volume[i],
+					   first_ch + i, CTL_CURRENT, CTL_READ);
+		if (err < 0)
+			return err;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(controls); ++i) {
+		err = snd_ctl_add(oxfw->card,
+				  snd_ctl_new1(&controls[i], oxfw));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static u32 oxfw_read_firmware_version(struct fw_unit *unit)
+{
+	__be32 data;
+	int err;
+
+	err = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,
+				 OXFORD_FIRMWARE_ID_ADDRESS, &data, 4, 0);
+	return err >= 0 ? be32_to_cpu(data) : 0;
+}
+
+static void oxfw_card_free(struct snd_card *card)
+{
+	struct snd_oxfw *oxfw = card->private_data;
+
+	amdtp_stream_destroy(&oxfw->rx_stream);
+	cmp_connection_destroy(&oxfw->in_conn);
+	fw_unit_put(oxfw->unit);
+	mutex_destroy(&oxfw->mutex);
+}
+
+static int oxfw_probe(struct fw_unit *unit,
+		       const struct ieee1394_device_id *id)
+{
+	struct fw_device *fw_dev = fw_parent_device(unit);
+	struct snd_card *card;
+	struct snd_oxfw *oxfw;
+	u32 firmware;
+	int err;
+
+	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
+			   sizeof(*oxfw), &card);
+	if (err < 0)
+		return err;
+
+	oxfw = card->private_data;
+	oxfw->card = card;
+	mutex_init(&oxfw->mutex);
+	oxfw->unit = fw_unit_get(unit);
+	oxfw->device_info = (const struct device_info *)id->driver_data;
+
+	err = cmp_connection_init(&oxfw->in_conn, unit, CMP_INPUT, 0);
+	if (err < 0)
+		goto err_unit;
+
+	err = amdtp_stream_init(&oxfw->rx_stream, unit, AMDTP_OUT_STREAM,
+				CIP_NONBLOCKING);
+	if (err < 0)
+		goto err_connection;
+
+	card->private_free = oxfw_card_free;
+
+	strcpy(card->driver, oxfw->device_info->driver_name);
+	strcpy(card->shortname, oxfw->device_info->short_name);
+	firmware = oxfw_read_firmware_version(unit);
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s (OXFW%x %04x), GUID %08x%08x at %s, S%d",
+		 oxfw->device_info->long_name,
+		 firmware >> 20, firmware & 0xffff,
+		 fw_dev->config_rom[3], fw_dev->config_rom[4],
+		 dev_name(&unit->device), 100 << fw_dev->max_speed);
+	strcpy(card->mixername, "OXFW");
+
+	err = oxfw_create_pcm(oxfw);
+	if (err < 0)
+		goto error;
+
+	err = oxfw_create_mixer(oxfw);
+	if (err < 0)
+		goto error;
+
+	err = snd_card_register(card);
+	if (err < 0)
+		goto error;
+
+	dev_set_drvdata(&unit->device, oxfw);
+
+	return 0;
+
+err_connection:
+	cmp_connection_destroy(&oxfw->in_conn);
+err_unit:
+	fw_unit_put(oxfw->unit);
+	mutex_destroy(&oxfw->mutex);
+error:
+	snd_card_free(card);
+	return err;
+}
+
+static void oxfw_bus_reset(struct fw_unit *unit)
+{
+	struct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);
+
+	fcp_bus_reset(oxfw->unit);
+
+	if (cmp_connection_update(&oxfw->in_conn) < 0) {
+		amdtp_stream_pcm_abort(&oxfw->rx_stream);
+		mutex_lock(&oxfw->mutex);
+		oxfw_stop_stream(oxfw);
+		mutex_unlock(&oxfw->mutex);
+		return;
+	}
+
+	amdtp_stream_update(&oxfw->rx_stream);
+}
+
+static void oxfw_remove(struct fw_unit *unit)
+{
+	struct snd_oxfw *oxfw = dev_get_drvdata(&unit->device);
+
+	amdtp_stream_pcm_abort(&oxfw->rx_stream);
+	snd_card_disconnect(oxfw->card);
+
+	mutex_lock(&oxfw->mutex);
+	oxfw_stop_stream(oxfw);
+	mutex_unlock(&oxfw->mutex);
+
+	snd_card_free_when_closed(oxfw->card);
+}
+
+static const struct device_info griffin_firewave = {
+	.driver_name = "FireWave",
+	.short_name  = "FireWave",
+	.long_name   = "Griffin FireWave Surround",
+	.pcm_constraints = firewave_constraints,
+	.mixer_channels = 6,
+	.mute_fb_id   = 0x01,
+	.volume_fb_id = 0x02,
+};
+
+static const struct device_info lacie_speakers = {
+	.driver_name = "FWSpeakers",
+	.short_name  = "FireWire Speakers",
+	.long_name   = "LaCie FireWire Speakers",
+	.pcm_constraints = lacie_speakers_constraints,
+	.mixer_channels = 1,
+	.mute_fb_id   = 0x01,
+	.volume_fb_id = 0x01,
+};
+
+static const struct ieee1394_device_id oxfw_id_table[] = {
+	{
+		.match_flags  = IEEE1394_MATCH_VENDOR_ID |
+				IEEE1394_MATCH_MODEL_ID |
+				IEEE1394_MATCH_SPECIFIER_ID |
+				IEEE1394_MATCH_VERSION,
+		.vendor_id    = VENDOR_GRIFFIN,
+		.model_id     = 0x00f970,
+		.specifier_id = SPECIFIER_1394TA,
+		.version      = VERSION_AVC,
+		.driver_data  = (kernel_ulong_t)&griffin_firewave,
+	},
+	{
+		.match_flags  = IEEE1394_MATCH_VENDOR_ID |
+				IEEE1394_MATCH_MODEL_ID |
+				IEEE1394_MATCH_SPECIFIER_ID |
+				IEEE1394_MATCH_VERSION,
+		.vendor_id    = VENDOR_LACIE,
+		.model_id     = 0x00f970,
+		.specifier_id = SPECIFIER_1394TA,
+		.version      = VERSION_AVC,
+		.driver_data  = (kernel_ulong_t)&lacie_speakers,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(ieee1394, oxfw_id_table);
+
+static struct fw_driver oxfw_driver = {
+	.driver   = {
+		.owner	= THIS_MODULE,
+		.name	= KBUILD_MODNAME,
+		.bus	= &fw_bus_type,
+	},
+	.probe    = oxfw_probe,
+	.update   = oxfw_bus_reset,
+	.remove   = oxfw_remove,
+	.id_table = oxfw_id_table,
+};
+
+static int __init snd_oxfw_init(void)
+{
+	return driver_register(&oxfw_driver.driver);
+}
+
+static void __exit snd_oxfw_exit(void)
+{
+	driver_unregister(&oxfw_driver.driver);
+}
+
+module_init(snd_oxfw_init);
+module_exit(snd_oxfw_exit);
