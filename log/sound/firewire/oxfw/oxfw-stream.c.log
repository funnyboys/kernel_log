commit 41dbc792794acf520892afe40b7df4cc58a8f5f5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jan 13 16:34:18 2020 +0900

    ALSA: oxfw: fix for Stanton SCS.1d
    
    Stanton SCS.1d uses Oxford Semiconductor FW 971 ASIC (FW971) for
    communication. Although the unit is bound to ALSA oxfw driver, the instance
    of sound card can not be added due to its quirk of plug information. This
    bug was added when snd-scs1x is merged into snd-oxfw at commit
    9e2004f9cedf ("ALSA: oxfw: obsolete scs1x module").
    
    This commit fixes the driver for the quirk. In cases that the unit returns
    NOT IMPLEMENTED for some AV/C commands, the sound card is added without any
    PCM/MIDI interfaces for packet streaming. For SCS.1d, model dependent
    operation adds MIDI interface and applications can use it to operate
    according to HSS1394 protocol from reverse-engineering work by Sean M.
    Pappalardo.
    
    Plug Control Register (PCR) has information that the unit has a pair of
    plugs for isochronous communication:
    
    (oMPR)
    $ ./firewire-request /dev/fw1 read 0xfffff0000900
    result: 80ff0001
    (iMPR)
    $ ./firewire-request /dev/fw1 read 0xfffff0000980
    result: 80ff0001
    
    AV/C PLUG INFO also returns information that the unit has a pair of
    plugs for isochronous communication.
    
    (AV/C PLUG INFO command)
    $ ./firewire-request /dev/fw1 fcp 0x01ff0200ffffffff
    response: 000: 0c ff 02 00 01 01 02 02
    
    However, AV/C PLUG SIGNAL INFO command is rejected for both plugs.
    
    (AV/C OUTPUT PLUG SIGNAL INFO command)
    $ ./firewire-request /dev/fw1 fcp 0x01ff1800ffffffff
    response: 000: 0a ff 18 00 ff ff ff ff
    (AV/C INPUT PLUG SIGNAL INFO command)
    $ ./firewire-request /dev/fw1 fcp 0x01ff1900ffffffff
    response: 000: 0a ff 19 00 ff ff ff ff
    
    Furthermore, AV/C EXTENDED STREAM FORMAT INFO is not implemented.
    
    (AV/C EXTENDED STREAM FORMAT INFO list subfunction for input plug)
    $ ./firewire-request /dev/fw1 fcp 0x01ffbfc000000000ffff00ff
    response: 000: 08 ff bf c0 00 00 00 00 ff ff 00 ff
    (AV/C EXTENDED STREAM FORMAT INFO list subfunction for output plug)
    $ ./firewire-request /dev/fw1 fcp 0x01ffbfc001000000ffff00ff
    response: 000: 08 ff bf c0 01 00 00 00 ff ff 00 ff
    (AV/C EXTENDED STREAM FORMAT INFO single subfunction for input plug)
    $ ./firewire-request /dev/fw1 fcp 0x01ffbfc100000000ffffffff
    response: 000: 08 ff bf c1 00 00 00 00 ff ff ff ff
    (AV/C EXTENDED STREAM FORMAT INFO single subfunction for output plug)
    $ ./firewire-request /dev/fw1 fcp 0x01ffbfc101000000ffffffff
    response: 000: 08 ff bf c1 01 00 00 00 ff ff ff ff
    
    Reference: https://mailman.alsa-project.org/pipermail/alsa-devel/2012-May/052264.html
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200113073418.24622-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 36c3dd84d189..80c9dc13f1b5 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -735,45 +735,57 @@ int snd_oxfw_stream_discover(struct snd_oxfw *oxfw)
 	/* use oPCR[0] if exists */
 	if (plugs[1] > 0) {
 		err = fill_stream_formats(oxfw, AVC_GENERAL_PLUG_DIR_OUT, 0);
-		if (err < 0)
-			goto end;
+		if (err < 0) {
+			if (err != -ENXIO)
+				return err;
 
-		for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
-			format = oxfw->tx_stream_formats[i];
-			if (format == NULL)
-				continue;
-			err = snd_oxfw_stream_parse_format(format, &formation);
-			if (err < 0)
-				continue;
-
-			/* Add one MIDI port. */
-			if (formation.midi > 0)
-				oxfw->midi_input_ports = 1;
-		}
+			// The oPCR is not available for isoc communication.
+			err = 0;
+		} else {
+			for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
+				format = oxfw->tx_stream_formats[i];
+				if (format == NULL)
+					continue;
+				err = snd_oxfw_stream_parse_format(format,
+								   &formation);
+				if (err < 0)
+					continue;
+
+				/* Add one MIDI port. */
+				if (formation.midi > 0)
+					oxfw->midi_input_ports = 1;
+			}
 
-		oxfw->has_output = true;
+			oxfw->has_output = true;
+		}
 	}
 
 	/* use iPCR[0] if exists */
 	if (plugs[0] > 0) {
 		err = fill_stream_formats(oxfw, AVC_GENERAL_PLUG_DIR_IN, 0);
-		if (err < 0)
-			goto end;
+		if (err < 0) {
+			if (err != -ENXIO)
+				return err;
 
-		for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
-			format = oxfw->rx_stream_formats[i];
-			if (format == NULL)
-				continue;
-			err = snd_oxfw_stream_parse_format(format, &formation);
-			if (err < 0)
-				continue;
-
-			/* Add one MIDI port. */
-			if (formation.midi > 0)
-				oxfw->midi_output_ports = 1;
-		}
+			// The iPCR is not available for isoc communication.
+			err = 0;
+		} else {
+			for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
+				format = oxfw->rx_stream_formats[i];
+				if (format == NULL)
+					continue;
+				err = snd_oxfw_stream_parse_format(format,
+								   &formation);
+				if (err < 0)
+					continue;
+
+				/* Add one MIDI port. */
+				if (formation.midi > 0)
+					oxfw->midi_output_ports = 1;
+			}
 
-		oxfw->has_input = true;
+			oxfw->has_input = true;
+		}
 	}
 end:
 	return err;

commit 06a42a74a0e704458754bdc5f29cf62cc1ce4b53
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jan 13 16:34:17 2020 +0900

    ALSA: oxfw: don't add MIDI/PCM interface when packet streaming is unavailable
    
    Stanton SCS.1d doesn't support packet streaming even if it has plugs for
    isochronous communication.
    
    This commit is a preparation for this case. The 'has_input' member is
    added to specific structure, and MIDI/PCM interfaces are not added when
    the member is false.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200113073418.24622-3-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 692324670c78..36c3dd84d189 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -772,6 +772,8 @@ int snd_oxfw_stream_discover(struct snd_oxfw *oxfw)
 			if (formation.midi > 0)
 				oxfw->midi_output_ports = 1;
 		}
+
+		oxfw->has_input = true;
 	}
 end:
 	return err;

commit 03be63b2953c1b33ac77b7c21345495acc47e84b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Jan 13 16:34:16 2020 +0900

    ALSA: oxfw: use ENXIO for not-supported cases
    
    When AV/C command returns 'NOT IMPLEMENTED' status in its response, ALSA
    oxfw driver uses ENOSYS as error code. However, it's expected just to be
    used for missing system call number.
    
    This commit replaces it with ENXIO.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200113073418.24622-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 501a80094bf7..692324670c78 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -513,7 +513,7 @@ int snd_oxfw_stream_parse_format(u8 *format,
 	 *  Level 1:	AM824 Compound  (0x40)
 	 */
 	if ((format[0] != 0x90) || (format[1] != 0x40))
-		return -ENOSYS;
+		return -ENXIO;
 
 	/* check the sampling rate */
 	for (i = 0; i < ARRAY_SIZE(avc_stream_rate_table); i++) {
@@ -521,7 +521,7 @@ int snd_oxfw_stream_parse_format(u8 *format,
 			break;
 	}
 	if (i == ARRAY_SIZE(avc_stream_rate_table))
-		return -ENOSYS;
+		return -ENXIO;
 
 	formation->rate = oxfw_rate_table[i];
 
@@ -565,13 +565,13 @@ int snd_oxfw_stream_parse_format(u8 *format,
 		/* Don't care */
 		case 0xff:
 		default:
-			return -ENOSYS;	/* not supported */
+			return -ENXIO;	/* not supported */
 		}
 	}
 
 	if (formation->pcm  > AM824_MAX_CHANNELS_FOR_PCM ||
 	    formation->midi > AM824_MAX_CHANNELS_FOR_MIDI)
-		return -ENOSYS;
+		return -ENXIO;
 
 	return 0;
 }
@@ -656,7 +656,7 @@ static int fill_stream_formats(struct snd_oxfw *oxfw,
 	/* get first entry */
 	len = AVC_GENERIC_FRAME_MAXIMUM_BYTES;
 	err = avc_stream_get_format_list(oxfw->unit, dir, 0, buf, &len, 0);
-	if (err == -ENOSYS) {
+	if (err == -ENXIO) {
 		/* LIST subfunction is not implemented */
 		len = AVC_GENERIC_FRAME_MAXIMUM_BYTES;
 		err = assume_stream_formats(oxfw, dir, pid, buf, &len,
@@ -728,7 +728,7 @@ int snd_oxfw_stream_discover(struct snd_oxfw *oxfw)
 			err);
 		goto end;
 	} else if ((plugs[0] == 0) && (plugs[1] == 0)) {
-		err = -ENOSYS;
+		err = -ENXIO;
 		goto end;
 	}
 

commit acfedcbe1ce4c69e1da914f39c02d945c80198d4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 15:19:11 2019 +0900

    ALSA: firewire-lib: postpone to start IR context
    
    Some devices have a quirk to postpone transmission of isoc packet for
    several dozen or hundred isoc cycles since configured to transmit.
    Furthermore, some devices have a quirk to transmit isoc packet with
    discontinued data of its header.
    
    In 1394 OHCI specification, software allows to start isoc context with
    certain isoc cycle. Linux firewire subsystem has kernel API to use it
    as well.
    
    This commit uses the functionality of 1394 OHCI controller to handle
    the quirks. At present, this feature is convenient to ALSA bebob and
    fireface driver. As a result, some devices can be safely handled, as
    long as I know:
     - MAudio FireWire solo
     - MAudio ProFire Lightbridge
     - MAudio FireWire 410
     - Roland FA-66
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191018061911.24909-7-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 995e9c5bd84b..501a80094bf7 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -355,7 +355,7 @@ int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw)
 			}
 		}
 
-		err = amdtp_domain_start(&oxfw->domain);
+		err = amdtp_domain_start(&oxfw->domain, 0);
 		if (err < 0)
 			goto error;
 

commit 3299d2a0f74c0774da0672d0bc54741da4bbda6e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 00:54:16 2019 +0900

    ALSA: oxfw: share PCM buffer size for both direction
    
    This commit allows ALSA oxfw driver to share PCM buffer size for both
    capture and playback PCM substream. When AMDTP domain starts for one
    of the PCM substream, buffer size of the PCM substream is stores to
    AMDTP domain structure. Some AMDTP streams have already run with the
    buffer size when another PCM substream starts, therefore the PCM
    substream has a constraint to its buffer size.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191017155424.885-5-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 318de8217b3a..995e9c5bd84b 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -245,7 +245,8 @@ static int keep_resources(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 				   struct amdtp_stream *stream,
 				   unsigned int rate, unsigned int pcm_channels,
-				   unsigned int frames_per_period)
+				   unsigned int frames_per_period,
+				   unsigned int frames_per_buffer)
 {
 	struct snd_oxfw_stream_formation formation;
 	enum avc_general_plug_dir dir;
@@ -308,7 +309,7 @@ int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 		}
 
 		err = amdtp_domain_set_events_per_period(&oxfw->domain,
-							frames_per_period, 0);
+					frames_per_period, frames_per_buffer);
 		if (err < 0) {
 			cmp_connection_release(&oxfw->in_conn);
 			if (oxfw->has_output)

commit a0e023317e2d55c6b2fbf342c12d8a59797e1cff
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Oct 18 00:54:13 2019 +0900

    ALSA: firewire-lib: use variable size of queue for isoc packets instead of fixed size
    
    The number of packets in packet buffer has been fixed number (=48) since
    first commit of ALSA IEC 61883-1/6 packet streaming engine.
    
    This commit allows the engine to use variable number of packets in the
    buffer. The size is calculated by a parameter in AMDTP domain structure
    surely to store the number of events in the packets of buffer. Although
    the value of parameter is expected to come from 'period size' parameter
    of PCM substream, at present 48 is still used.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191017155424.885-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 7d2e88c5b73d..318de8217b3a 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -308,7 +308,7 @@ int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 		}
 
 		err = amdtp_domain_set_events_per_period(&oxfw->domain,
-							frames_per_period);
+							frames_per_period, 0);
 		if (err < 0) {
 			cmp_connection_release(&oxfw->in_conn);
 			if (oxfw->has_output)

commit 1d6a722c4a0146ac20fd0daa541a177279adcbb2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 7 20:05:19 2019 +0900

    ALSA: oxfw: register the size of PCM period to AMDTP domain
    
    This commit is a preparation to share the size of PCM period between
    PCM substreams on AMDTP streams in the same domain. At this time,
    the size of PCM period in PCM substream which starts AMDTP streams in the
    same domain is recorded.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20191007110532.30270-5-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 3c9a796b6526..7d2e88c5b73d 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -244,7 +244,8 @@ static int keep_resources(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 
 int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 				   struct amdtp_stream *stream,
-				   unsigned int rate, unsigned int pcm_channels)
+				   unsigned int rate, unsigned int pcm_channels,
+				   unsigned int frames_per_period)
 {
 	struct snd_oxfw_stream_formation formation;
 	enum avc_general_plug_dir dir;
@@ -305,6 +306,15 @@ int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 				return err;
 			}
 		}
+
+		err = amdtp_domain_set_events_per_period(&oxfw->domain,
+							frames_per_period);
+		if (err < 0) {
+			cmp_connection_release(&oxfw->in_conn);
+			if (oxfw->has_output)
+				cmp_connection_release(&oxfw->out_conn);
+			return err;
+		}
 	}
 
 	return 0;

commit 4c098dab121a4164e9daa4d1ddbc59e93054e79e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Aug 26 22:54:15 2019 +0900

    ALSA: oxfw: fix NULL pointer dereference to unused stream structure
    
    ALSA oxfw driver supports Griffin FireWave. This device supports one
    isochronous stream for PCM playback. Current driver executes code to
    wait event for stream structure of opposite direction. This causes
    NULL pointer dereference.
    
    This commit fixes the bug.
    
    Fixes: ac5d77864cfc ("ALSA: oxfw: support AMDTP domain")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 0318dc4dcc55..3c9a796b6526 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -350,13 +350,18 @@ int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw)
 
 		// Wait first packet.
 		if (!amdtp_stream_wait_callback(&oxfw->rx_stream,
-						CALLBACK_TIMEOUT) ||
-		    !amdtp_stream_wait_callback(&oxfw->tx_stream,
 						CALLBACK_TIMEOUT)) {
 			err = -ETIMEDOUT;
 			goto error;
 		}
 
+		if (oxfw->has_output) {
+			if (!amdtp_stream_wait_callback(&oxfw->tx_stream,
+							CALLBACK_TIMEOUT)) {
+				err = -ETIMEDOUT;
+				goto error;
+			}
+		}
 	}
 
 	return 0;

commit ac5d77864cfcb0f034221c2b3dac828ae24c722e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Aug 4 15:21:32 2019 +0900

    ALSA: oxfw: support AMDTP domain
    
    This commit adds AMDTP domain support for ALSA oxfw driver.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 74c972d25c66..0318dc4dcc55 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -114,19 +114,13 @@ static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 	if (err < 0)
 		return err;
 
-	err = amdtp_stream_start(stream, conn->resources.channel, conn->speed);
+	err = amdtp_domain_add_stream(&oxfw->domain, stream,
+				      conn->resources.channel, conn->speed);
 	if (err < 0) {
 		cmp_connection_break(conn);
 		return err;
 	}
 
-	// Wait first packet.
-	if (!amdtp_stream_wait_callback(stream, CALLBACK_TIMEOUT)) {
-		amdtp_stream_stop(stream);
-		cmp_connection_break(conn);
-		return -ETIMEDOUT;
-	}
-
 	return 0;
 }
 
@@ -280,12 +274,12 @@ int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 		pcm_channels = formation.pcm;
 	}
 	if (formation.rate != rate || formation.pcm != pcm_channels) {
-		amdtp_stream_stop(&oxfw->rx_stream);
+		amdtp_domain_stop(&oxfw->domain);
+
 		cmp_connection_break(&oxfw->in_conn);
 		cmp_connection_release(&oxfw->in_conn);
 
 		if (oxfw->has_output) {
-			amdtp_stream_stop(&oxfw->tx_stream);
 			cmp_connection_break(&oxfw->out_conn);
 			cmp_connection_release(&oxfw->out_conn);
 		}
@@ -325,55 +319,66 @@ int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw)
 
 	if (amdtp_streaming_error(&oxfw->rx_stream) ||
 	    amdtp_streaming_error(&oxfw->tx_stream)) {
-		amdtp_stream_stop(&oxfw->rx_stream);
-		cmp_connection_break(&oxfw->in_conn);
+		amdtp_domain_stop(&oxfw->domain);
 
-		if (oxfw->has_output) {
-			amdtp_stream_stop(&oxfw->tx_stream);
+		cmp_connection_break(&oxfw->in_conn);
+		if (oxfw->has_output)
 			cmp_connection_break(&oxfw->out_conn);
-		}
 	}
 
 	if (!amdtp_stream_running(&oxfw->rx_stream)) {
 		err = start_stream(oxfw, &oxfw->rx_stream);
 		if (err < 0) {
 			dev_err(&oxfw->unit->device,
-				"fail to start rx stream: %d\n", err);
+				"fail to prepare rx stream: %d\n", err);
 			goto error;
 		}
-	}
 
-	if (oxfw->has_output) {
-		if (!amdtp_stream_running(&oxfw->tx_stream)) {
+		if (oxfw->has_output &&
+		    !amdtp_stream_running(&oxfw->tx_stream)) {
 			err = start_stream(oxfw, &oxfw->tx_stream);
 			if (err < 0) {
 				dev_err(&oxfw->unit->device,
-					"fail to start tx stream: %d\n", err);
+					"fail to prepare tx stream: %d\n", err);
 				goto error;
 			}
 		}
+
+		err = amdtp_domain_start(&oxfw->domain);
+		if (err < 0)
+			goto error;
+
+		// Wait first packet.
+		if (!amdtp_stream_wait_callback(&oxfw->rx_stream,
+						CALLBACK_TIMEOUT) ||
+		    !amdtp_stream_wait_callback(&oxfw->tx_stream,
+						CALLBACK_TIMEOUT)) {
+			err = -ETIMEDOUT;
+			goto error;
+		}
+
 	}
 
 	return 0;
 error:
-	amdtp_stream_stop(&oxfw->rx_stream);
+	amdtp_domain_stop(&oxfw->domain);
+
 	cmp_connection_break(&oxfw->in_conn);
-	if (oxfw->has_output) {
-		amdtp_stream_stop(&oxfw->tx_stream);
+	if (oxfw->has_output)
 		cmp_connection_break(&oxfw->out_conn);
-	}
+
 	return err;
 }
 
 void snd_oxfw_stream_stop_duplex(struct snd_oxfw *oxfw)
 {
 	if (oxfw->substreams_count == 0) {
-		amdtp_stream_stop(&oxfw->rx_stream);
+		amdtp_domain_stop(&oxfw->domain);
+
 		cmp_connection_break(&oxfw->in_conn);
 		cmp_connection_release(&oxfw->in_conn);
 
 		if (oxfw->has_output) {
-			amdtp_stream_stop(&oxfw->tx_stream);
 			cmp_connection_break(&oxfw->out_conn);
 			cmp_connection_release(&oxfw->out_conn);
 		}
@@ -409,13 +414,22 @@ int snd_oxfw_stream_init_duplex(struct snd_oxfw *oxfw)
 		}
 	}
 
-	return 0;
+	err = amdtp_domain_init(&oxfw->domain);
+	if (err < 0) {
+		destroy_stream(oxfw, &oxfw->rx_stream);
+		if (oxfw->has_output)
+			destroy_stream(oxfw, &oxfw->tx_stream);
+	}
+
+	return err;
 }
 
 // This function should be called before starting the stream or after stopping
 // the streams.
 void snd_oxfw_stream_destroy_duplex(struct snd_oxfw *oxfw)
 {
+	amdtp_domain_destroy(&oxfw->domain);
+
 	destroy_stream(oxfw, &oxfw->rx_stream);
 
 	if (oxfw->has_output)
@@ -424,13 +438,13 @@ void snd_oxfw_stream_destroy_duplex(struct snd_oxfw *oxfw)
 
 void snd_oxfw_stream_update_duplex(struct snd_oxfw *oxfw)
 {
-	amdtp_stream_stop(&oxfw->rx_stream);
+	amdtp_domain_stop(&oxfw->domain);
+
 	cmp_connection_break(&oxfw->in_conn);
 
 	amdtp_stream_pcm_abort(&oxfw->rx_stream);
 
 	if (oxfw->has_output) {
-		amdtp_stream_stop(&oxfw->tx_stream);
 		cmp_connection_break(&oxfw->out_conn);
 
 		amdtp_stream_pcm_abort(&oxfw->tx_stream);

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 3f2ce83ddba936568de2d057bbd29d74cd2de80d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jun 18 22:26:22 2019 +0900

    ALSA: oxfw: ensure to release isochronous resources in pcm.hw_params callback
    
    When stopping packet streaming in reserve function for duplex streams,
    isochronous resources should be released.
    
    Fixes: 7bc93821a70a ("ALSA: firewire-lib: split allocation of isochronous resources from establishment of connection")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index a8bc798731ff..a7502810a3ad 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -283,10 +283,12 @@ int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 	if (formation.rate != rate || formation.pcm != pcm_channels) {
 		amdtp_stream_stop(&oxfw->rx_stream);
 		cmp_connection_break(&oxfw->in_conn);
+		cmp_connection_release(&oxfw->in_conn);
 
 		if (oxfw->has_output) {
 			amdtp_stream_stop(&oxfw->tx_stream);
 			cmp_connection_break(&oxfw->out_conn);
+			cmp_connection_release(&oxfw->out_conn);
 		}
 	}
 

commit 7bc93821a70adc621df443c8b7a4745023c36e7c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Jun 15 18:11:01 2019 +0900

    ALSA: firewire-lib: split allocation of isochronous resources from establishment of connection
    
    In current implementation, establishment connection corresponds to
    allocation of isochronous resources. Although this is an ideal
    implementation of CMP described in IEC 61883-1, it's not enough
    efficient to recover PCM substream multiplexed in packet streaming.
    The packet streaming can always restart on the same allocated
    isochronous resources even if the previous packet streaming
    corrupted.
    
    This commit splits allocation of isochronous resources from
    establishment of connection so that CMP runs with allocated
    isochronous resources.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 837733f10736..a8bc798731ff 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -111,8 +111,7 @@ static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 	else
 		conn = &oxfw->out_conn;
 
-	err = cmp_connection_establish(conn,
-				       amdtp_stream_get_max_payload(stream));
+	err = cmp_connection_establish(conn);
 	if (err < 0)
 		return err;
 
@@ -203,15 +202,18 @@ static int keep_resources(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 	enum avc_general_plug_dir dir;
 	u8 **formats;
 	struct snd_oxfw_stream_formation formation;
+	struct cmp_connection *conn;
 	int i;
 	int err;
 
 	if (stream == &oxfw->rx_stream) {
 		dir = AVC_GENERAL_PLUG_DIR_IN;
 		formats = oxfw->rx_stream_formats;
+		conn = &oxfw->in_conn;
 	} else {
 		dir = AVC_GENERAL_PLUG_DIR_OUT;
 		formats = oxfw->tx_stream_formats;
+		conn = &oxfw->out_conn;
 	}
 
 	err = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);
@@ -239,8 +241,12 @@ static int keep_resources(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 	if (formation.pcm == 0)
 		return -EINVAL;
 
-	return amdtp_am824_set_parameters(stream, formation.rate, formation.pcm,
+	err = amdtp_am824_set_parameters(stream, formation.rate, formation.pcm,
 					 formation.midi * 8, false);
+	if (err < 0)
+		return err;
+
+	return cmp_connection_reserve(conn, amdtp_stream_get_max_payload(stream));
 }
 
 int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
@@ -299,8 +305,10 @@ int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 
 		if (oxfw->has_output) {
 			err = keep_resources(oxfw, &oxfw->tx_stream);
-			if (err < 0)
+			if (err < 0) {
+				cmp_connection_release(&oxfw->in_conn);
 				return err;
+			}
 		}
 	}
 
@@ -361,10 +369,12 @@ void snd_oxfw_stream_stop_duplex(struct snd_oxfw *oxfw)
 	if (oxfw->substreams_count == 0) {
 		amdtp_stream_stop(&oxfw->rx_stream);
 		cmp_connection_break(&oxfw->in_conn);
+		cmp_connection_release(&oxfw->in_conn);
 
 		if (oxfw->has_output) {
 			amdtp_stream_stop(&oxfw->tx_stream);
 			cmp_connection_break(&oxfw->out_conn);
+			cmp_connection_release(&oxfw->out_conn);
 		}
 	}
 }

commit 0356ce3adda0a7b5ef49d580790e94b9c80e8862
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:22 2019 +0900

    ALSA: oxfw: configure stream parameter in pcm.hw_params callback
    
    This commit is a part of preparation to perform allocation/release
    of isochronous resources in pcm.hw_params/hw_free callbacks.
    
    This commit splits out an operation to configure stream parameters into
    pcm.hw_params callback. In pcm.prepare callback, establishing
    connections and start isochronous contexts.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 373154d8ee0e..837733f10736 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -103,51 +103,13 @@ static int set_stream_format(struct snd_oxfw *oxfw, struct amdtp_stream *s,
 
 static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 {
-	u8 **formats;
-	enum avc_general_plug_dir dir;
 	struct cmp_connection *conn;
-	struct snd_oxfw_stream_formation formation;
-	int i;
 	int err;
 
-	if (stream == &oxfw->rx_stream) {
-		dir = AVC_GENERAL_PLUG_DIR_IN;
-		formats = oxfw->rx_stream_formats;
+	if (stream == &oxfw->rx_stream)
 		conn = &oxfw->in_conn;
-	} else {
-		dir = AVC_GENERAL_PLUG_DIR_OUT;
-		formats = oxfw->tx_stream_formats;
+	else
 		conn = &oxfw->out_conn;
-	}
-
-	err = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);
-	if (err < 0)
-		return err;
-
-	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
-		struct snd_oxfw_stream_formation fmt;
-
-		if (formats[i] == NULL)
-			break;
-
-		err = snd_oxfw_stream_parse_format(formats[i], &fmt);
-		if (err < 0)
-			return err;
-		if (fmt.rate == formation.rate && fmt.pcm == formation.pcm &&
-		    fmt.midi == formation.midi)
-			break;
-	}
-	if (i == SND_OXFW_STREAM_FORMAT_ENTRIES)
-		return -EINVAL;
-
-	// The stream should have one pcm channels at least.
-	if (formation.pcm == 0)
-		return -EINVAL;
-
-	err = amdtp_am824_set_parameters(stream, formation.rate, formation.pcm,
-					 formation.midi * 8, false);
-	if (err < 0)
-		return err;
 
 	err = cmp_connection_establish(conn,
 				       amdtp_stream_get_max_payload(stream));
@@ -236,6 +198,51 @@ static int init_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 	return 0;
 }
 
+static int keep_resources(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
+{
+	enum avc_general_plug_dir dir;
+	u8 **formats;
+	struct snd_oxfw_stream_formation formation;
+	int i;
+	int err;
+
+	if (stream == &oxfw->rx_stream) {
+		dir = AVC_GENERAL_PLUG_DIR_IN;
+		formats = oxfw->rx_stream_formats;
+	} else {
+		dir = AVC_GENERAL_PLUG_DIR_OUT;
+		formats = oxfw->tx_stream_formats;
+	}
+
+	err = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
+		struct snd_oxfw_stream_formation fmt;
+
+		if (formats[i] == NULL)
+			break;
+
+		err = snd_oxfw_stream_parse_format(formats[i], &fmt);
+		if (err < 0)
+			return err;
+
+		if (fmt.rate == formation.rate && fmt.pcm == formation.pcm &&
+		    fmt.midi == formation.midi)
+			break;
+	}
+	if (i == SND_OXFW_STREAM_FORMAT_ENTRIES)
+		return -EINVAL;
+
+	// The stream should have one pcm channels at least.
+	if (formation.pcm == 0)
+		return -EINVAL;
+
+	return amdtp_am824_set_parameters(stream, formation.rate, formation.pcm,
+					 formation.midi * 8, false);
+}
+
 int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 				   struct amdtp_stream *stream,
 				   unsigned int rate, unsigned int pcm_channels)
@@ -285,6 +292,16 @@ int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
 				"fail to set stream format: %d\n", err);
 			return err;
 		}
+
+		err = keep_resources(oxfw, &oxfw->rx_stream);
+		if (err < 0)
+			return err;
+
+		if (oxfw->has_output) {
+			err = keep_resources(oxfw, &oxfw->tx_stream);
+			if (err < 0)
+				return err;
+		}
 	}
 
 	return 0;

commit 4f380d0070528da8b93c4ac3994c20097393f6dd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:21 2019 +0900

    ALSA: oxfw: configure packet format in pcm.hw_params callback
    
    This commit is a part of preparation to perform allocation/release
    of isochronous resources in pcm.hw_params/hw_free callbacks.
    
    At present, several operations are done in pcm.prepare callback. To
    reduce load of the callback, This commit splits out an operation to
    set packet format in pcm.hw_params callback.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index ebfe0777773b..373154d8ee0e 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -236,16 +236,13 @@ static int init_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 	return 0;
 }
 
-int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw,
-				 struct amdtp_stream *stream,
-				 unsigned int rate, unsigned int pcm_channels)
+int snd_oxfw_stream_reserve_duplex(struct snd_oxfw *oxfw,
+				   struct amdtp_stream *stream,
+				   unsigned int rate, unsigned int pcm_channels)
 {
 	struct snd_oxfw_stream_formation formation;
 	enum avc_general_plug_dir dir;
-	int err = 0;
-
-	if (oxfw->substreams_count == 0)
-		return -EIO;
+	int err;
 
 	// Considering JACK/FFADO streaming:
 	// TODO: This can be removed hwdep functionality becomes popular.
@@ -266,14 +263,11 @@ int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw,
 	err = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);
 	if (err < 0)
 		return err;
-	if (rate == 0)
+	if (rate == 0) {
 		rate = formation.rate;
-	if (pcm_channels == 0)
 		pcm_channels = formation.pcm;
-
-	if (formation.rate != rate || formation.pcm != pcm_channels ||
-	    amdtp_streaming_error(&oxfw->rx_stream) ||
-	    amdtp_streaming_error(&oxfw->tx_stream)) {
+	}
+	if (formation.rate != rate || formation.pcm != pcm_channels) {
 		amdtp_stream_stop(&oxfw->rx_stream);
 		cmp_connection_break(&oxfw->in_conn);
 
@@ -281,7 +275,10 @@ int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw,
 			amdtp_stream_stop(&oxfw->tx_stream);
 			cmp_connection_break(&oxfw->out_conn);
 		}
+	}
 
+	if (oxfw->substreams_count == 0 ||
+	    formation.rate != rate || formation.pcm != pcm_channels) {
 		err = set_stream_format(oxfw, stream, rate, pcm_channels);
 		if (err < 0) {
 			dev_err(&oxfw->unit->device,
@@ -290,6 +287,27 @@ int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw,
 		}
 	}
 
+	return 0;
+}
+
+int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw)
+{
+	int err;
+
+	if (oxfw->substreams_count == 0)
+		return -EIO;
+
+	if (amdtp_streaming_error(&oxfw->rx_stream) ||
+	    amdtp_streaming_error(&oxfw->tx_stream)) {
+		amdtp_stream_stop(&oxfw->rx_stream);
+		cmp_connection_break(&oxfw->in_conn);
+
+		if (oxfw->has_output) {
+			amdtp_stream_stop(&oxfw->tx_stream);
+			cmp_connection_break(&oxfw->out_conn);
+		}
+	}
+
 	if (!amdtp_stream_running(&oxfw->rx_stream)) {
 		err = start_stream(oxfw, &oxfw->rx_stream);
 		if (err < 0) {

commit 4a0a04729a44ea317270885e1722636b156cf620
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:20 2019 +0900

    ALSA: oxfw: unify substreams counter
    
    In former commits, two isochronous contexts are handles at the same
    time. This commit unifies stream counters to obsolete them.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 52cf815c27f7..ebfe0777773b 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -244,7 +244,7 @@ int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw,
 	enum avc_general_plug_dir dir;
 	int err = 0;
 
-	if (oxfw->capture_substreams == 0 && oxfw->playback_substreams == 0)
+	if (oxfw->substreams_count == 0)
 		return -EIO;
 
 	// Considering JACK/FFADO streaming:
@@ -323,7 +323,7 @@ int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw,
 
 void snd_oxfw_stream_stop_duplex(struct snd_oxfw *oxfw)
 {
-	if (oxfw->capture_substreams == 0 && oxfw->playback_substreams == 0) {
+	if (oxfw->substreams_count == 0) {
 		amdtp_stream_stop(&oxfw->rx_stream);
 		cmp_connection_break(&oxfw->in_conn);
 

commit 779f0dba0b99f32276315ba40e812648b6ceed34
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:19 2019 +0900

    ALSA: oxfw: rename helper functions for duplex streams
    
    In former commits, ALSA oxfw driver handles two isochronous contexts
    at the same time, except for some devices which supports one endpoint
    of isochronous packet stream.
    
    This commit renames some helper functions so that they handles duplex
    streams.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 561ceb09d927..52cf815c27f7 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -194,8 +194,7 @@ static int check_connection_used_by_others(struct snd_oxfw *oxfw,
 	return err;
 }
 
-int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw,
-				 struct amdtp_stream *stream)
+static int init_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 {
 	struct cmp_connection *conn;
 	enum cmp_direction c_dir;
@@ -214,13 +213,12 @@ int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw,
 
 	err = cmp_connection_init(conn, oxfw->unit, c_dir, 0);
 	if (err < 0)
-		goto end;
+		return err;
 
 	err = amdtp_am824_init(stream, oxfw->unit, s_dir, CIP_NONBLOCKING);
 	if (err < 0) {
-		amdtp_stream_destroy(stream);
 		cmp_connection_destroy(conn);
-		goto end;
+		return err;
 	}
 
 	/*
@@ -234,13 +232,13 @@ int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw,
 		if (oxfw->wrong_dbs)
 			oxfw->tx_stream.flags |= CIP_WRONG_DBS;
 	}
-end:
-	return err;
+
+	return 0;
 }
 
-int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
-				  struct amdtp_stream *stream,
-				  unsigned int rate, unsigned int pcm_channels)
+int snd_oxfw_stream_start_duplex(struct snd_oxfw *oxfw,
+				 struct amdtp_stream *stream,
+				 unsigned int rate, unsigned int pcm_channels)
 {
 	struct snd_oxfw_stream_formation formation;
 	enum avc_general_plug_dir dir;
@@ -323,8 +321,7 @@ int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
 	return err;
 }
 
-void snd_oxfw_stream_stop_simplex(struct snd_oxfw *oxfw,
-				  struct amdtp_stream *stream)
+void snd_oxfw_stream_stop_duplex(struct snd_oxfw *oxfw)
 {
 	if (oxfw->capture_substreams == 0 && oxfw->playback_substreams == 0) {
 		amdtp_stream_stop(&oxfw->rx_stream);
@@ -337,12 +334,7 @@ void snd_oxfw_stream_stop_simplex(struct snd_oxfw *oxfw,
 	}
 }
 
-/*
- * This function should be called before starting the stream or after stopping
- * the streams.
- */
-void snd_oxfw_stream_destroy_simplex(struct snd_oxfw *oxfw,
-				     struct amdtp_stream *stream)
+static void destroy_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 {
 	struct cmp_connection *conn;
 
@@ -355,8 +347,36 @@ void snd_oxfw_stream_destroy_simplex(struct snd_oxfw *oxfw,
 	cmp_connection_destroy(conn);
 }
 
-void snd_oxfw_stream_update_simplex(struct snd_oxfw *oxfw,
-				    struct amdtp_stream *stream)
+int snd_oxfw_stream_init_duplex(struct snd_oxfw *oxfw)
+{
+	int err;
+
+	err = init_stream(oxfw, &oxfw->rx_stream);
+	if (err < 0)
+		return err;
+
+	if (oxfw->has_output) {
+		err = init_stream(oxfw, &oxfw->tx_stream);
+		if (err < 0) {
+			destroy_stream(oxfw, &oxfw->rx_stream);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+// This function should be called before starting the stream or after stopping
+// the streams.
+void snd_oxfw_stream_destroy_duplex(struct snd_oxfw *oxfw)
+{
+	destroy_stream(oxfw, &oxfw->rx_stream);
+
+	if (oxfw->has_output)
+		destroy_stream(oxfw, &oxfw->tx_stream);
+}
+
+void snd_oxfw_stream_update_duplex(struct snd_oxfw *oxfw)
 {
 	amdtp_stream_stop(&oxfw->rx_stream);
 	cmp_connection_break(&oxfw->in_conn);

commit e34244dd2266773f699977c831b60a44fc3a164b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:18 2019 +0900

    ALSA: oxfw: expand stop procedure for packet streaming
    
    The helper function stop packet streaming is not enough useful. This
    commit obsoletes it and expands its code.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 806a7fded99d..561ceb09d927 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -101,17 +101,6 @@ static int set_stream_format(struct snd_oxfw *oxfw, struct amdtp_stream *s,
 	return 0;
 }
 
-static void stop_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
-{
-	amdtp_stream_pcm_abort(stream);
-	amdtp_stream_stop(stream);
-
-	if (stream == &oxfw->tx_stream)
-		cmp_connection_break(&oxfw->out_conn);
-	else
-		cmp_connection_break(&oxfw->in_conn);
-}
-
 static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 {
 	u8 **formats;
@@ -158,28 +147,27 @@ static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 	err = amdtp_am824_set_parameters(stream, formation.rate, formation.pcm,
 					 formation.midi * 8, false);
 	if (err < 0)
-		goto end;
+		return err;
 
 	err = cmp_connection_establish(conn,
 				       amdtp_stream_get_max_payload(stream));
 	if (err < 0)
-		goto end;
+		return err;
 
-	err = amdtp_stream_start(stream,
-				 conn->resources.channel,
-				 conn->speed);
+	err = amdtp_stream_start(stream, conn->resources.channel, conn->speed);
 	if (err < 0) {
 		cmp_connection_break(conn);
-		goto end;
+		return err;
 	}
 
-	/* Wait first packet */
+	// Wait first packet.
 	if (!amdtp_stream_wait_callback(stream, CALLBACK_TIMEOUT)) {
-		stop_stream(oxfw, stream);
-		err = -ETIMEDOUT;
+		amdtp_stream_stop(stream);
+		cmp_connection_break(conn);
+		return -ETIMEDOUT;
 	}
-end:
-	return err;
+
+	return 0;
 }
 
 static int check_connection_used_by_others(struct snd_oxfw *oxfw,
@@ -288,9 +276,13 @@ int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
 	if (formation.rate != rate || formation.pcm != pcm_channels ||
 	    amdtp_streaming_error(&oxfw->rx_stream) ||
 	    amdtp_streaming_error(&oxfw->tx_stream)) {
-		stop_stream(oxfw, &oxfw->rx_stream);
-		if (oxfw->has_output)
-			stop_stream(oxfw, &oxfw->tx_stream);
+		amdtp_stream_stop(&oxfw->rx_stream);
+		cmp_connection_break(&oxfw->in_conn);
+
+		if (oxfw->has_output) {
+			amdtp_stream_stop(&oxfw->tx_stream);
+			cmp_connection_break(&oxfw->out_conn);
+		}
 
 		err = set_stream_format(oxfw, stream, rate, pcm_channels);
 		if (err < 0) {
@@ -322,10 +314,10 @@ int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
 
 	return 0;
 error:
-	stop_stream(oxfw, &oxfw->rx_stream);
+	amdtp_stream_stop(&oxfw->rx_stream);
 	cmp_connection_break(&oxfw->in_conn);
 	if (oxfw->has_output) {
-		stop_stream(oxfw, &oxfw->tx_stream);
+		amdtp_stream_stop(&oxfw->tx_stream);
 		cmp_connection_break(&oxfw->out_conn);
 	}
 	return err;
@@ -335,10 +327,13 @@ void snd_oxfw_stream_stop_simplex(struct snd_oxfw *oxfw,
 				  struct amdtp_stream *stream)
 {
 	if (oxfw->capture_substreams == 0 && oxfw->playback_substreams == 0) {
-		stop_stream(oxfw, &oxfw->rx_stream);
+		amdtp_stream_stop(&oxfw->rx_stream);
+		cmp_connection_break(&oxfw->in_conn);
 
-		if (oxfw->has_output)
-			stop_stream(oxfw, &oxfw->tx_stream);
+		if (oxfw->has_output) {
+			amdtp_stream_stop(&oxfw->tx_stream);
+			cmp_connection_break(&oxfw->out_conn);
+		}
 	}
 }
 
@@ -363,10 +358,17 @@ void snd_oxfw_stream_destroy_simplex(struct snd_oxfw *oxfw,
 void snd_oxfw_stream_update_simplex(struct snd_oxfw *oxfw,
 				    struct amdtp_stream *stream)
 {
-	stop_stream(oxfw, &oxfw->rx_stream);
+	amdtp_stream_stop(&oxfw->rx_stream);
+	cmp_connection_break(&oxfw->in_conn);
 
-	if (oxfw->has_output)
-		stop_stream(oxfw, &oxfw->tx_stream);
+	amdtp_stream_pcm_abort(&oxfw->rx_stream);
+
+	if (oxfw->has_output) {
+		amdtp_stream_stop(&oxfw->tx_stream);
+		cmp_connection_break(&oxfw->out_conn);
+
+		amdtp_stream_pcm_abort(&oxfw->tx_stream);
+	}
 }
 
 int snd_oxfw_stream_get_current_formation(struct snd_oxfw *oxfw,

commit 7efa19ab4848305a17aea542b09930e3d7d1bede
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:17 2019 +0900

    ALSA: oxfw: break packet streaming at bus-reset handler
    
    In most cases, recovery from bus reset is not successful. This commit
    aborts packet streaming in bus reset handler.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index bb4ba6c196ea..806a7fded99d 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -363,17 +363,10 @@ void snd_oxfw_stream_destroy_simplex(struct snd_oxfw *oxfw,
 void snd_oxfw_stream_update_simplex(struct snd_oxfw *oxfw,
 				    struct amdtp_stream *stream)
 {
-	struct cmp_connection *conn;
-
-	if (stream == &oxfw->tx_stream)
-		conn = &oxfw->out_conn;
-	else
-		conn = &oxfw->in_conn;
+	stop_stream(oxfw, &oxfw->rx_stream);
 
-	if (cmp_connection_update(conn) < 0)
-		stop_stream(oxfw, stream);
-	else
-		amdtp_stream_update(stream);
+	if (oxfw->has_output)
+		stop_stream(oxfw, &oxfw->tx_stream);
 }
 
 int snd_oxfw_stream_get_current_formation(struct snd_oxfw *oxfw,

commit 20358d4460bd4aa833b1ad79b79763887d9b75e4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:16 2019 +0900

    ALSA: oxfw: start duplex streams if supported
    
    It's inconvenient to handle two isochronous context separately
    each other. This commit unifies the counters to handle the two
    at the same time.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 1691fdc1a575..bb4ba6c196ea 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -254,96 +254,92 @@ int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
 				  struct amdtp_stream *stream,
 				  unsigned int rate, unsigned int pcm_channels)
 {
-	struct amdtp_stream *opposite;
 	struct snd_oxfw_stream_formation formation;
 	enum avc_general_plug_dir dir;
-	unsigned int substreams, opposite_substreams;
 	int err = 0;
 
-	if (stream == &oxfw->tx_stream) {
-		substreams = oxfw->capture_substreams;
-		opposite = &oxfw->rx_stream;
-		opposite_substreams = oxfw->playback_substreams;
-		dir = AVC_GENERAL_PLUG_DIR_OUT;
-	} else {
-		substreams = oxfw->playback_substreams;
-		opposite_substreams = oxfw->capture_substreams;
+	if (oxfw->capture_substreams == 0 && oxfw->playback_substreams == 0)
+		return -EIO;
 
-		if (oxfw->has_output)
-			opposite = &oxfw->rx_stream;
-		else
-			opposite = NULL;
-
-		dir = AVC_GENERAL_PLUG_DIR_IN;
+	// Considering JACK/FFADO streaming:
+	// TODO: This can be removed hwdep functionality becomes popular.
+	err = check_connection_used_by_others(oxfw, &oxfw->rx_stream);
+	if (err < 0)
+		return err;
+	if (oxfw->has_output) {
+		err = check_connection_used_by_others(oxfw, &oxfw->tx_stream);
+		if (err < 0)
+			return err;
 	}
 
-	if (substreams == 0)
-		goto end;
-
-	/*
-	 * Considering JACK/FFADO streaming:
-	 * TODO: This can be removed hwdep functionality becomes popular.
-	 */
-	err = check_connection_used_by_others(oxfw, stream);
-	if (err < 0)
-		goto end;
+	if (stream == &oxfw->tx_stream)
+		dir = AVC_GENERAL_PLUG_DIR_OUT;
+	else
+		dir = AVC_GENERAL_PLUG_DIR_IN;
 
 	err = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);
 	if (err < 0)
-		goto end;
+		return err;
 	if (rate == 0)
 		rate = formation.rate;
 	if (pcm_channels == 0)
 		pcm_channels = formation.pcm;
 
 	if (formation.rate != rate || formation.pcm != pcm_channels ||
-	    amdtp_streaming_error(stream)) {
-		if (opposite != NULL) {
-			err = check_connection_used_by_others(oxfw, opposite);
-			if (err < 0)
-				goto end;
-			stop_stream(oxfw, opposite);
-		}
-		stop_stream(oxfw, stream);
+	    amdtp_streaming_error(&oxfw->rx_stream) ||
+	    amdtp_streaming_error(&oxfw->tx_stream)) {
+		stop_stream(oxfw, &oxfw->rx_stream);
+		if (oxfw->has_output)
+			stop_stream(oxfw, &oxfw->tx_stream);
 
 		err = set_stream_format(oxfw, stream, rate, pcm_channels);
 		if (err < 0) {
 			dev_err(&oxfw->unit->device,
 				"fail to set stream format: %d\n", err);
-			goto end;
+			return err;
+		}
+	}
+
+	if (!amdtp_stream_running(&oxfw->rx_stream)) {
+		err = start_stream(oxfw, &oxfw->rx_stream);
+		if (err < 0) {
+			dev_err(&oxfw->unit->device,
+				"fail to start rx stream: %d\n", err);
+			goto error;
 		}
+	}
 
-		/* Start opposite stream if needed. */
-		if (opposite && !amdtp_stream_running(opposite) &&
-		    (opposite_substreams > 0)) {
-			err = start_stream(oxfw, opposite);
+	if (oxfw->has_output) {
+		if (!amdtp_stream_running(&oxfw->tx_stream)) {
+			err = start_stream(oxfw, &oxfw->tx_stream);
 			if (err < 0) {
 				dev_err(&oxfw->unit->device,
-					"fail to restart stream: %d\n", err);
-				goto end;
+					"fail to start tx stream: %d\n", err);
+				goto error;
 			}
 		}
 	}
 
-	/* Start requested stream. */
-	if (!amdtp_stream_running(stream)) {
-		err = start_stream(oxfw, stream);
-		if (err < 0)
-			dev_err(&oxfw->unit->device,
-				"fail to start stream: %d\n", err);
+	return 0;
+error:
+	stop_stream(oxfw, &oxfw->rx_stream);
+	cmp_connection_break(&oxfw->in_conn);
+	if (oxfw->has_output) {
+		stop_stream(oxfw, &oxfw->tx_stream);
+		cmp_connection_break(&oxfw->out_conn);
 	}
-end:
 	return err;
 }
 
 void snd_oxfw_stream_stop_simplex(struct snd_oxfw *oxfw,
 				  struct amdtp_stream *stream)
 {
-	if (((stream == &oxfw->tx_stream) && (oxfw->capture_substreams > 0)) ||
-	    ((stream == &oxfw->rx_stream) && (oxfw->playback_substreams > 0)))
-		return;
+	if (oxfw->capture_substreams == 0 && oxfw->playback_substreams == 0) {
+		stop_stream(oxfw, &oxfw->rx_stream);
 
-	stop_stream(oxfw, stream);
+		if (oxfw->has_output)
+			stop_stream(oxfw, &oxfw->tx_stream);
+	}
 }
 
 /*

commit 521b2e11fad0b4d6b36727ecca624710b5f81fd1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:15 2019 +0900

    ALSA: oxfw: set packet parameter according to current configuration
    
    After a call of pcm.hw_params, the state of target device is expected
    for applications. This commit retrieves the state and start packet
    streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 34ff673e6ff8..1691fdc1a575 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -112,51 +112,51 @@ static void stop_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 		cmp_connection_break(&oxfw->in_conn);
 }
 
-static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream,
-			unsigned int rate, unsigned int pcm_channels)
+static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 {
 	u8 **formats;
+	enum avc_general_plug_dir dir;
 	struct cmp_connection *conn;
 	struct snd_oxfw_stream_formation formation;
-	unsigned int i, midi_ports;
+	int i;
 	int err;
 
 	if (stream == &oxfw->rx_stream) {
+		dir = AVC_GENERAL_PLUG_DIR_IN;
 		formats = oxfw->rx_stream_formats;
 		conn = &oxfw->in_conn;
 	} else {
+		dir = AVC_GENERAL_PLUG_DIR_OUT;
 		formats = oxfw->tx_stream_formats;
 		conn = &oxfw->out_conn;
 	}
 
-	/* Get stream format */
+	err = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);
+	if (err < 0)
+		return err;
+
 	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
+		struct snd_oxfw_stream_formation fmt;
+
 		if (formats[i] == NULL)
 			break;
 
-		err = snd_oxfw_stream_parse_format(formats[i], &formation);
+		err = snd_oxfw_stream_parse_format(formats[i], &fmt);
 		if (err < 0)
-			goto end;
-		if (rate != formation.rate)
-			continue;
-		if (pcm_channels == 0 ||  pcm_channels == formation.pcm)
+			return err;
+		if (fmt.rate == formation.rate && fmt.pcm == formation.pcm &&
+		    fmt.midi == formation.midi)
 			break;
 	}
-	if (i == SND_OXFW_STREAM_FORMAT_ENTRIES) {
-		err = -EINVAL;
-		goto end;
-	}
+	if (i == SND_OXFW_STREAM_FORMAT_ENTRIES)
+		return -EINVAL;
 
-	pcm_channels = formation.pcm;
-	midi_ports = formation.midi * 8;
+	// The stream should have one pcm channels at least.
+	if (formation.pcm == 0)
+		return -EINVAL;
 
-	/* The stream should have one pcm channels at least */
-	if (pcm_channels == 0) {
-		err = -EINVAL;
-		goto end;
-	}
-	err = amdtp_am824_set_parameters(stream, rate, pcm_channels, midi_ports,
-					 false);
+	err = amdtp_am824_set_parameters(stream, formation.rate, formation.pcm,
+					 formation.midi * 8, false);
 	if (err < 0)
 		goto end;
 
@@ -316,7 +316,7 @@ int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
 		/* Start opposite stream if needed. */
 		if (opposite && !amdtp_stream_running(opposite) &&
 		    (opposite_substreams > 0)) {
-			err = start_stream(oxfw, opposite, rate, 0);
+			err = start_stream(oxfw, opposite);
 			if (err < 0) {
 				dev_err(&oxfw->unit->device,
 					"fail to restart stream: %d\n", err);
@@ -327,7 +327,7 @@ int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
 
 	/* Start requested stream. */
 	if (!amdtp_stream_running(stream)) {
-		err = start_stream(oxfw, stream, rate, pcm_channels);
+		err = start_stream(oxfw, stream);
 		if (err < 0)
 			dev_err(&oxfw->unit->device,
 				"fail to start stream: %d\n", err);

commit da2af86d51ac32067c77759e40a162d684690a43
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Jun 12 17:44:14 2019 +0900

    ALSA: oxfw: code refactoring for stop condition of packet streaming
    
    This commit unifies stop condition due to queueing error and unmatched
    state of the target device.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index f230a9e44c3c..34ff673e6ff8 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -288,10 +288,6 @@ int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
 	if (err < 0)
 		goto end;
 
-	/* packet queueing error */
-	if (amdtp_streaming_error(stream))
-		stop_stream(oxfw, stream);
-
 	err = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);
 	if (err < 0)
 		goto end;
@@ -300,7 +296,8 @@ int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
 	if (pcm_channels == 0)
 		pcm_channels = formation.pcm;
 
-	if ((formation.rate != rate) || (formation.pcm != pcm_channels)) {
+	if (formation.rate != rate || formation.pcm != pcm_channels ||
+	    amdtp_streaming_error(stream)) {
 		if (opposite != NULL) {
 			err = check_connection_used_by_others(oxfw, opposite);
 			if (err < 0)

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index f230a9e44c3c..5ffedb0ade3f 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * oxfw_stream.c - a part of driver for OXFW970/971 based devices
  *
  * Copyright (c) 2014 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "oxfw.h"

commit cd3b7116b57527f659b96ff6988d2de3d448c5b3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:54 2018 +0900

    ALSA: oxfw: use managed-resource to maintain cache of stream formats
    
    ALSA oxfw driver allocates memory objects for cache of stream formats.
    The objects are used to maintain packet streaming by components for
    ALSA rawMIDI/PCM interface. They can be released as managed-resource
    of 'struct snd_card.card_dev'.
    
    This commit uses managed-resource of the sound card device for this
    purpose.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index d9361f352133..f230a9e44c3c 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -517,8 +517,9 @@ assume_stream_formats(struct snd_oxfw *oxfw, enum avc_general_plug_dir dir,
 	if (err < 0)
 		goto end;
 
-	formats[eid] = kmemdup(buf, *len, GFP_KERNEL);
-	if (formats[eid] == NULL) {
+	formats[eid] = devm_kmemdup(&oxfw->card->card_dev, buf, *len,
+				    GFP_KERNEL);
+	if (!formats[eid]) {
 		err = -ENOMEM;
 		goto end;
 	}
@@ -535,7 +536,8 @@ assume_stream_formats(struct snd_oxfw *oxfw, enum avc_general_plug_dir dir,
 			continue;
 
 		eid++;
-		formats[eid] = kmemdup(buf, *len, GFP_KERNEL);
+		formats[eid] = devm_kmemdup(&oxfw->card->card_dev, buf, *len,
+					    GFP_KERNEL);
 		if (formats[eid] == NULL) {
 			err = -ENOMEM;
 			goto end;
@@ -597,8 +599,9 @@ static int fill_stream_formats(struct snd_oxfw *oxfw,
 		if (err < 0)
 			break;
 
-		formats[eid] = kmemdup(buf, len, GFP_KERNEL);
-		if (formats[eid] == NULL) {
+		formats[eid] = devm_kmemdup(&oxfw->card->card_dev, buf, len,
+					    GFP_KERNEL);
+		if (!formats[eid]) {
 			err = -ENOMEM;
 			break;
 		}

commit 62f00e40b0718ebd8bd54fc7a9e89e873524d495
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon May 9 23:15:56 2016 +0900

    ALSA: firewire-lib: enable the same feature as CIP_SKIP_INIT_DBC_CHECK flag
    
    In former commit, drivers in ALSA firewire stack always starts IT context
    before IR context. If IR context starts after packets are transmitted by
    peer unit, packet discontinuity may be detected because the context starts
    in the middle of packet streaming. This situation is rare because IT
    context usually starts immediately. However, it's better to solve this
    issue. This is suppressed with CIP_SKIP_INIT_DBC_CHECK flag.
    
    This commit enables the same feature as CIP_SKIP_INIT_DBC_CHECK.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 7cb5743c073b..d9361f352133 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -242,8 +242,7 @@ int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw,
 	 * blocks than IEC 61883-6 defines.
 	 */
 	if (stream == &oxfw->tx_stream) {
-		oxfw->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK |
-					 CIP_JUMBO_PAYLOAD;
+		oxfw->tx_stream.flags |= CIP_JUMBO_PAYLOAD;
 		if (oxfw->wrong_dbs)
 			oxfw->tx_stream.flags |= CIP_WRONG_DBS;
 	}

commit bb71da43469679bf53dc97433dc02895e4d58352
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 18 17:09:39 2015 +0900

    ALSA: oxfw: support more MIDI ports
    
    In IEC 61883-6, sequence multiplexing is applied to MIDI conformant data
    channel. As a result, eight MIDI data streams are included in the channel.
    Although ALSA AM824 data block processing layer implements this
    multiplexing, current OXFW driver doesn't utilize it due to wrong
    calculation of MIDI ports.
    
    This commit fixes this bug to add proper calculation. Although this commit
    allows to use 8 MIDI data streams, the number of available MIDI ports is
    limited by the number of ALSA MIDI ports added by the driver.
    
    Fixes: df075feefbd3('ALSA: firewire-lib: complete AM824 data block processing layer')
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 48798084de16..7cb5743c073b 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -148,7 +148,7 @@ static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream,
 	}
 
 	pcm_channels = formation.pcm;
-	midi_ports = DIV_ROUND_UP(formation.midi, 8);
+	midi_ports = formation.midi * 8;
 
 	/* The stream should have one pcm channels at least */
 	if (pcm_channels == 0) {

commit 32056041019aa91c2555cc4c280f9fbca8a1be99
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 18 17:09:38 2015 +0900

    ALSA: oxfw: calculating MIDI ports in stream discover
    
    Current OXFW driver calculates the number of MIDI ports just before adding
    ALSA MIDI ports. It's convenient for some devices with quirks to move
    these codes before handling quirks.
    
    This commit implements this idea.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 2c63058bd245..48798084de16 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -629,6 +629,9 @@ static int fill_stream_formats(struct snd_oxfw *oxfw,
 int snd_oxfw_stream_discover(struct snd_oxfw *oxfw)
 {
 	u8 plugs[AVC_PLUG_INFO_BUF_BYTES];
+	struct snd_oxfw_stream_formation formation;
+	u8 *format;
+	unsigned int i;
 	int err;
 
 	/* the number of plugs for isoc in/out, ext in/out  */
@@ -648,12 +651,42 @@ int snd_oxfw_stream_discover(struct snd_oxfw *oxfw)
 		err = fill_stream_formats(oxfw, AVC_GENERAL_PLUG_DIR_OUT, 0);
 		if (err < 0)
 			goto end;
+
+		for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
+			format = oxfw->tx_stream_formats[i];
+			if (format == NULL)
+				continue;
+			err = snd_oxfw_stream_parse_format(format, &formation);
+			if (err < 0)
+				continue;
+
+			/* Add one MIDI port. */
+			if (formation.midi > 0)
+				oxfw->midi_input_ports = 1;
+		}
+
 		oxfw->has_output = true;
 	}
 
 	/* use iPCR[0] if exists */
-	if (plugs[0] > 0)
+	if (plugs[0] > 0) {
 		err = fill_stream_formats(oxfw, AVC_GENERAL_PLUG_DIR_IN, 0);
+		if (err < 0)
+			goto end;
+
+		for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
+			format = oxfw->rx_stream_formats[i];
+			if (format == NULL)
+				continue;
+			err = snd_oxfw_stream_parse_format(format, &formation);
+			if (err < 0)
+				continue;
+
+			/* Add one MIDI port. */
+			if (formation.midi > 0)
+				oxfw->midi_output_ports = 1;
+		}
+	}
 end:
 	return err;
 }

commit d8dfacf8b50c260d79864933ac82a8198a0908a9
Merge: e87359efcaf4 df075feefbd3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 29 12:52:07 2015 +0200

    Merge branch 'topic/firewire-update' into for-next

commit 49c7b3fcd9f0a0125e8cd8212d5576382198eeb2
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:22:01 2015 +0900

    ALSA: firewire-lib: rename macros with AM824 prefix
    
    This commit renames some macros just related to AM824 format. In later
    commit, they're moved to AM824 layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 4982befc9c25..0c40c00daf12 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -483,8 +483,8 @@ int snd_oxfw_stream_parse_format(u8 *format,
 		}
 	}
 
-	if (formation->pcm  > AMDTP_MAX_CHANNELS_FOR_PCM ||
-	    formation->midi > AMDTP_MAX_CHANNELS_FOR_MIDI)
+	if (formation->pcm  > AM824_MAX_CHANNELS_FOR_PCM ||
+	    formation->midi > AM824_MAX_CHANNELS_FOR_MIDI)
 		return -ENOSYS;
 
 	return 0;

commit 51c29fd21389d9995a8a18a91eeb8dd1220a2119
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:56 2015 +0900

    ALSA: firewire-lib: rename parameter setting function for AM824 with FDF field
    
    The value of FDF field in CIP header is protocol-dependent. Thus, it's
    better to allow data block processing layer to decide the value in any
    timing.
    
    In AM824 data format, the value of FDF field in CIP header indicates
    N-flag and Nominal Sampling Frequency Code (sfc). The N-flag is for
    switching 'Clock-based rate control mode' and 'Command-based rate control
    mode'. In our implementation, 'Clock-based rate control mode' is just
    supported. Therefore, When sampling transfer frequency is decided, then
    the FDF can be set.
    
    This commit replaces 'amdtp_stream_set_parameters' with
    'amdtp_am824_set_parameters' to set the FDF. This is the same timing
    to decide the ration between the number of data blocks and the number of
    PCM frames.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 83683414793f..4982befc9c25 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -155,8 +155,8 @@ static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream,
 		err = -EINVAL;
 		goto end;
 	}
-	err = amdtp_stream_set_parameters(stream, rate,
-					  pcm_channels, midi_ports, false);
+	err = amdtp_am824_set_parameters(stream, rate, pcm_channels, midi_ports,
+					 false);
 	if (err < 0)
 		goto end;
 

commit 5955815e71ff9c773b156680c781c87728e37bea
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:55 2015 +0900

    ALSA: firewire-lib: add data block processing layer for AM824 format
    
    This commit adds data block processing layer for AM824 format. The new
    layer initializes streaming layer with its value for fmt field.
    
    Currently, most implementation of data block processing still remains
    streaming layer. In later commits, these codes will be moved to the layer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 318f78e1a313..83683414793f 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -228,7 +228,7 @@ int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw,
 	if (err < 0)
 		goto end;
 
-	err = amdtp_stream_init(stream, oxfw->unit, s_dir, CIP_NONBLOCKING);
+	err = amdtp_am824_init(stream, oxfw->unit, s_dir, CIP_NONBLOCKING);
 	if (err < 0) {
 		amdtp_stream_destroy(stream);
 		cmp_connection_destroy(conn);

commit 27ec83b5c6ac08599240ec9a95286e79d6ea9e51
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:50 2015 +0900

    ALSA: firewire-lib: add an argument for Dice's dual wire mode
    
    In IEC 61883-6, one data block represents one event. In ALSA, the event is
    one PCM frame. Therefore, when processing one data block, current
    implementation counts one PCM frame.
    
    On the other hand, Dice platform has a quirk called as 'dual wire' at
    higher sampling rate. In detail, see comment of commit 6eb6c81eee2a
    ("ALSA: dice: Split stream functionality into a file").
    
    Currently, to handle this quirk, AMDTP stream structure has a
    'double_pcm_frames' member. When this is enabled, two PCM frames are
    counted. Each driver set this flag by accessing the structure member
    directly.
    
    In future commit, some members related to AM824 data block will be moved
    to specific structure, to separate packet streaming layer and data block
    processing layer. The access will be limited by opaque pointer.
    
    For this reason, this commit adds an argument into
    amdtp_stream_set_parameter() to set the flag.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index d119468fedf4..318f78e1a313 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -156,7 +156,7 @@ static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream,
 		goto end;
 	}
 	err = amdtp_stream_set_parameters(stream, rate,
-					  pcm_channels, midi_ports);
+					  pcm_channels, midi_ports, false);
 	if (err < 0)
 		goto end;
 

commit 547e631ce3886175a33b5ccf67729bdd18e9b7e0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Sep 19 11:21:49 2015 +0900

    ALSA: firewire-lib: return error code when amdtp_stream_set_parameters() detects error
    
    Currently, amdtp_stream_set_parameters() returns no error even if wrong
    arguments are given. This is not good for streaming layer because drivers
    can continue processing ignoring capability of streaming layer.
    
    This commit changes this function to return error code.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 77ad5b98e806..d119468fedf4 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -155,7 +155,10 @@ static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream,
 		err = -EINVAL;
 		goto end;
 	}
-	amdtp_stream_set_parameters(stream, rate, pcm_channels, midi_ports);
+	err = amdtp_stream_set_parameters(stream, rate,
+					  pcm_channels, midi_ports);
+	if (err < 0)
+		goto end;
 
 	err = cmp_connection_establish(conn,
 				       amdtp_stream_get_max_payload(stream));

commit 13f3a46d2a6cbdff1bbb06fac6de7dce753db8e1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Sep 20 21:18:55 2015 +0900

    ALSA: oxfw: add Mackie Onyx Satellite quirk to inform wrong value in 'dbs' field in tx CIP header
    
    Mackie Onyx Satellite has two usage; standalone and with base station.
    
    These two modes has different stream formats. In standalone mode, rx data
    block includes 2 Multi Bit Linear Audio (MBLA) data channels and tx data
    block includes 2. With base station, they're 6 and 2.
    
    Although, with base station, the actual tx packet include wrong value in
    'dbs' field in its CIP header. This quirk causes packet streaming layer to
    detect packet discontinuity and to stop PCM substream.
    
    This is a response of 'single' subfunction 'extended stream format
    information' command in AV/C Stream Format Information Specification 1.1.
    It means that a data block in tx packets includes 2 MBLA data channels.
    
    $ ./firewire-request /dev/fw1 fcp 0x01ffbfc001000000ffffffff
    response: 000: 0c ff bf c0 01 00 00 00 ff 00 90 40 03 02 01 02
    response: 010: 06
    
    Current OXFW driver parses the response and detects stream formats
    correctly.
    
    $ cat /proc/asound/card1/firewire/formation
    ...
    Output Stream from device:
            Rate    PCM     MIDI
    *       48000   2       0
            44100   2       0
            88200   2       0
            96000   2       0
    
    On the other hand, in actual tx CIP, the 'dbs' field has 6. But the number
    of quadlets in CIP payload is not multiple of 6. Seeing the subtraction of
    two successive payload quadlets, it should be multiple of 2.
    
    payload  CIP      CIP
    quadlets header0  header1
          24 00060052 9002ffff
          24 0006005e 9002ffff
          26 0006006a 9002ffff
          24 00060077 9002ffff
          24 00060083 9002ffff
          26 0006008f 9002ffff
          24 0006009c 9002ffff
          24 000600a8 9002ffff
          26 000600b4 9002ffff
          24 000600c1 9002ffff
    
    This commit adds support for this quirk to OXFW driver, by using
    CIP_WRONG_DBS flag. When this flag is set, packet streaming layer uses
    the value of its 'data_block_quadlets' member instead of the value in CIP
    header. This value is already set by OXFW driver and no discontinuity is
    detected.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 77ad5b98e806..863eb4ae7246 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -238,9 +238,12 @@ int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw,
 	 * packets. As a result, next isochronous packet includes more data
 	 * blocks than IEC 61883-6 defines.
 	 */
-	if (stream == &oxfw->tx_stream)
+	if (stream == &oxfw->tx_stream) {
 		oxfw->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK |
 					 CIP_JUMBO_PAYLOAD;
+		if (oxfw->wrong_dbs)
+			oxfw->tx_stream.flags |= CIP_WRONG_DBS;
+	}
 end:
 	return err;
 }

commit 96bab82f6ba3c4e116ee89989b3854dde6c0cd2d
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Fri Aug 7 09:59:35 2015 +0200

    ALSA: firewire: use kmemdup rather than duplicating its implementation
    
    The patch was generated using fixed coccinelle semantic patch
    scripts/coccinelle/api/memdup.cocci [1].
    
    [1]: http://permalink.gmane.org/gmane.linux.kernel/2014320
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 873d40fc4509..77ad5b98e806 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -512,12 +512,11 @@ assume_stream_formats(struct snd_oxfw *oxfw, enum avc_general_plug_dir dir,
 	if (err < 0)
 		goto end;
 
-	formats[eid] = kmalloc(*len, GFP_KERNEL);
+	formats[eid] = kmemdup(buf, *len, GFP_KERNEL);
 	if (formats[eid] == NULL) {
 		err = -ENOMEM;
 		goto end;
 	}
-	memcpy(formats[eid], buf, *len);
 
 	/* apply the format for each available sampling rate */
 	for (i = 0; i < ARRAY_SIZE(oxfw_rate_table); i++) {
@@ -531,12 +530,11 @@ assume_stream_formats(struct snd_oxfw *oxfw, enum avc_general_plug_dir dir,
 			continue;
 
 		eid++;
-		formats[eid] = kmalloc(*len, GFP_KERNEL);
+		formats[eid] = kmemdup(buf, *len, GFP_KERNEL);
 		if (formats[eid] == NULL) {
 			err = -ENOMEM;
 			goto end;
 		}
-		memcpy(formats[eid], buf, *len);
 		formats[eid][2] = avc_stream_rate_table[i];
 	}
 
@@ -594,12 +592,11 @@ static int fill_stream_formats(struct snd_oxfw *oxfw,
 		if (err < 0)
 			break;
 
-		formats[eid] = kmalloc(len, GFP_KERNEL);
+		formats[eid] = kmemdup(buf, len, GFP_KERNEL);
 		if (formats[eid] == NULL) {
 			err = -ENOMEM;
 			break;
 		}
-		memcpy(formats[eid], buf, len);
 
 		/* get next entry */
 		len = AVC_GENERIC_FRAME_MAXIMUM_BYTES;

commit a2064710ba2b38a4f07c1b273c389b70b14b2d18
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 22 23:00:50 2015 +0900

    ALSA: firewire-lib: add buffer-over-run protection at receiving more data blocks than expected
    
    In IEC 61883-6, the number of data blocks in a packet is limited up to
    the value of SYT_INTERVAL. Current implementation is compliant to the
    limitation, while it can cause buffer-over-run when the value of dbs
    field in received packet is illegally large.
    
    This commit adds a validator to detect such illegal packets to prevent
    the buffer-over-run. Actually, the buffer is aligned to the size of memory
     page, thus this issue hardly causes system errors due to the room to page
    alignment, as long as a few packets includes such jumbo payload; i.e.
    a packet to several received packets.
    
    Here, Behringer F-Control Audio 202 (based on OXFW 960) has a quirk to
    postpone transferring isochronous packet till finish handling any
    asynchronous packets. In this case, this model is lazy, transfers no
    packets according to several cycle-start packets. After finishing, this
    model pushes required data in next isochronous packet. As a result, the
    packet include more data blocks than IEC 61883-6 defines.
    
    To continue to support this model, this commit adds a new flag to extend
    the length of calculated payload. This flag allows the size of payload
    5 times as large as IEC 61883-6 defines. As a result, packets from this
    model passed the validator successfully.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index e6757cd85724..873d40fc4509 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -232,9 +232,15 @@ int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw,
 		goto end;
 	}
 
-	/* OXFW starts to transmit packets with non-zero dbc. */
+	/*
+	 * OXFW starts to transmit packets with non-zero dbc.
+	 * OXFW postpone transferring packets till handling any asynchronous
+	 * packets. As a result, next isochronous packet includes more data
+	 * blocks than IEC 61883-6 defines.
+	 */
 	if (stream == &oxfw->tx_stream)
-		oxfw->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK;
+		oxfw->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK |
+					 CIP_JUMBO_PAYLOAD;
 end:
 	return err;
 }

commit f2b14c0bc510c6a8f67a4f36049deefe5d99a537
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Feb 27 09:39:32 2015 +0900

    ALSA: oxfw: fix a condition and return code in start_stream()
    
    The amdtp_stream_wait_callback() doesn't return minus value and
    the return code is not for error code.
    
    This commit fixes with a propper condition and an error code.
    
    Fixes: f3699e2c7745 ('ALSA: oxfw: Change the way to start stream')
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 29ccb3637164..e6757cd85724 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -171,9 +171,10 @@ static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream,
 	}
 
 	/* Wait first packet */
-	err = amdtp_stream_wait_callback(stream, CALLBACK_TIMEOUT);
-	if (err < 0)
+	if (!amdtp_stream_wait_callback(stream, CALLBACK_TIMEOUT)) {
 		stop_stream(oxfw, stream);
+		err = -ETIMEDOUT;
+	}
 end:
 	return err;
 }

commit d23c2cc4485d10f0cedfef99dd2961d9652b1b3f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Feb 21 23:54:59 2015 +0900

    ALSA: fireworks/bebob/dice/oxfw: allow stream destructor after releasing runtime
    
    Currently stream destructor in each driver has a problem to be called in
    a context in which sound card object is released, because the destructors
    call amdtp_stream_pcm_abort() and touch PCM runtime data.
    
    The PCM runtime data is destroyed in application's context with
    snd_pcm_close(), on the other hand PCM substream data is destroyed after
    sound card object is released, in most case after all of ALSA character
    devices are released. When PCM runtime is destroyed and PCM substream is
    remained, amdtp_stream_pcm_abort() touches PCM runtime data and causes
    Null-pointer-dereference.
    
    This commit changes stream destructors and allows each driver to call
    it after releasing runtime.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index bda845afb470..29ccb3637164 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -337,6 +337,10 @@ void snd_oxfw_stream_stop_simplex(struct snd_oxfw *oxfw,
 	stop_stream(oxfw, stream);
 }
 
+/*
+ * This function should be called before starting the stream or after stopping
+ * the streams.
+ */
 void snd_oxfw_stream_destroy_simplex(struct snd_oxfw *oxfw,
 				     struct amdtp_stream *stream)
 {
@@ -347,8 +351,6 @@ void snd_oxfw_stream_destroy_simplex(struct snd_oxfw *oxfw,
 	else
 		conn = &oxfw->in_conn;
 
-	stop_stream(oxfw, stream);
-
 	amdtp_stream_destroy(stream);
 	cmp_connection_destroy(conn);
 }

commit 5580ba7bf61a6047a8b95459a9ed893f01947737
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Dec 12 22:27:03 2014 +0300

    ALSA: oxfw: some signedness bugs
    
    This code tends to use unsigned variables by default and it causes
    signedness bugs when we use negative variables for error handling.
    The "i" and "j" variables are used to iterated over small positive
    values and so they should be type "int".  The "len" variable doesn't
    *need* to be signed but it should be signed to make the code easier to
    read and audit.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index b77cf80f1678..bda845afb470 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -61,7 +61,8 @@ static int set_stream_format(struct snd_oxfw *oxfw, struct amdtp_stream *s,
 	u8 **formats;
 	struct snd_oxfw_stream_formation formation;
 	enum avc_general_plug_dir dir;
-	unsigned int i, err, len;
+	unsigned int len;
+	int i, err;
 
 	if (s == &oxfw->tx_stream) {
 		formats = oxfw->tx_stream_formats;

commit 8985f4ac1c42bd25799f294f4e87fa73064673c7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:49 2014 +0900

    ALSA: oxfw: Add hwdep interface
    
    This interface is designed for mixer/control application. By using this
    interface, an application can get information about firewire node, can
    lock/unlock kernel streaming and can get notification at starting/stopping
    kernel streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index a38b3c36faca..b77cf80f1678 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -644,3 +644,42 @@ int snd_oxfw_stream_discover(struct snd_oxfw *oxfw)
 end:
 	return err;
 }
+
+void snd_oxfw_stream_lock_changed(struct snd_oxfw *oxfw)
+{
+	oxfw->dev_lock_changed = true;
+	wake_up(&oxfw->hwdep_wait);
+}
+
+int snd_oxfw_stream_lock_try(struct snd_oxfw *oxfw)
+{
+	int err;
+
+	spin_lock_irq(&oxfw->lock);
+
+	/* user land lock this */
+	if (oxfw->dev_lock_count < 0) {
+		err = -EBUSY;
+		goto end;
+	}
+
+	/* this is the first time */
+	if (oxfw->dev_lock_count++ == 0)
+		snd_oxfw_stream_lock_changed(oxfw);
+	err = 0;
+end:
+	spin_unlock_irq(&oxfw->lock);
+	return err;
+}
+
+void snd_oxfw_stream_lock_release(struct snd_oxfw *oxfw)
+{
+	spin_lock_irq(&oxfw->lock);
+
+	if (WARN_ON(oxfw->dev_lock_count <= 0))
+		goto end;
+	if (--oxfw->dev_lock_count == 0)
+		snd_oxfw_stream_lock_changed(oxfw);
+end:
+	spin_unlock_irq(&oxfw->lock);
+}

commit 05588d340a128ff5c7b768c517150e31842a78aa
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:48 2014 +0900

    ALSA: oxfw: Add support for capture/playback MIDI messages
    
    This commit adds MIDI functionality with an assumption of 'if the device
    has MIDI comformant data channels in its stream formation, the device has
    one MIDI port'.
    
    When no streams have already started, MIDI functionality starts stream
    with current sampling rate.
    
    When MIDI functionality has already starts some streams and PCM
    functionality is going to start streams at different sampling rate,
    this driver stops streams once and changes sampling rate, then restarts
    streams for both PCM/MIDI substreams.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 1d154284873e..a38b3c36faca 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -282,6 +282,10 @@ int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
 	err = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);
 	if (err < 0)
 		goto end;
+	if (rate == 0)
+		rate = formation.rate;
+	if (pcm_channels == 0)
+		pcm_channels = formation.pcm;
 
 	if ((formation.rate != rate) || (formation.pcm != pcm_channels)) {
 		if (opposite != NULL) {

commit b0ac00095fe1485f60bb8ea7326426d3d02a1aec
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:46 2014 +0900

    ALSA: oxfw: Add support AMDTP in-stream
    
    Previous commit adds support for some devices which can capture PCM samples.
    These devices transmit AMDTP stream in non-blocking mode. This commit adds
    functionality to handle AMDTP incoming stream.
    
    OXFW seems to have two quirks:
     - Transmits packets with non-zero dbc in its beginning
     - Transmits packets with wrong values in syt field
    
    For the first quirk, this commit adds CIP_SKIP_INIT_DBC_CHECK flag for
    incoming stream to skip first check of dbc.
    
    For the second quirk, this commit doesn't add duplex stream which
    Fireworks/BeBoB drivers use. So OXFW driver generates syt value for outgoing
    stream.
    
    Here are examples of a sequence of packets transmitted by Behringer F-Control
    Audio 202. There are differences between sequences of syt value when OXFW
    driver transfers outgoing stream or not.
    
    When driver gives no outgoing stream:
    Index   Payload CIP_Header_0    CIP_Header_1
    38      14      00020092        900103D1
    39      12      00020098        900102FF
    40      12      0002009D        9001027F
    41      14      000200A2        90010396
    42      14      000200A8        900102E8
    43      12      000200AE        90010219
    44      14      000200B3        90010331
    45      12      000200B9        9001025F
    46      14      000200BE        90010376
    47      12      000200C4        900102A1
    00      12      000200C9        9001023E
    01      14      000200CE        90010358
    02      12      000200D4        90010289
    03      16      000200D9        900103A3
    04      12      000200E0        900102DD
    05      14      000200E5        900103F1
    06      12      000200EB        90010335
    07      12      000200F0        90010263
    08      14      000200F5        9001037C
    09      12      000200FB        900102AE
    
    When driver gives outgoing stream:
    Index   Payload CIP_Header_0    CIP_Header_1
    38      12      000200BD        900104A8
    39      14      000200C2        900104A8
    40      12      000200C8        900104AC
    41      14      000200CD        900104A9
    42      12      000200D3        900104B1
    43      14      000200D8        900104A8
    44      12      000200DE        900104AA
    45      14      000200E3        900104A9
    46      14      000200E9        900104AE
    47      12      000200EF        900104A8
    00      14      000200F4        900104AD
    01      12      000200FA        900104A7
    02      14      000200FF        900104A9
    03      12      00020005        900104A9
    04      14      0002000A        900104B1
    05      12      00020010        900104AA
    06      14      00020015        900104AD
    07      12      0002001B        900104A7
    08      14      00020020        900104AC
    09      12      00020026        900104A7
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 1820497f4bbf..1d154284873e 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -39,6 +39,22 @@ static const unsigned int avc_stream_rate_table[] = {
 	[5] = 0x07,
 };
 
+static int set_rate(struct snd_oxfw *oxfw, unsigned int rate)
+{
+	int err;
+
+	err = avc_general_set_sig_fmt(oxfw->unit, rate,
+				      AVC_GENERAL_PLUG_DIR_IN, 0);
+	if (err < 0)
+		goto end;
+
+	if (oxfw->has_output)
+		err = avc_general_set_sig_fmt(oxfw->unit, rate,
+					      AVC_GENERAL_PLUG_DIR_OUT, 0);
+end:
+	return err;
+}
+
 static int set_stream_format(struct snd_oxfw *oxfw, struct amdtp_stream *s,
 			     unsigned int rate, unsigned int pcm_channels)
 {
@@ -47,8 +63,13 @@ static int set_stream_format(struct snd_oxfw *oxfw, struct amdtp_stream *s,
 	enum avc_general_plug_dir dir;
 	unsigned int i, err, len;
 
-	formats = oxfw->rx_stream_formats;
-	dir = AVC_GENERAL_PLUG_DIR_IN;
+	if (s == &oxfw->tx_stream) {
+		formats = oxfw->tx_stream_formats;
+		dir = AVC_GENERAL_PLUG_DIR_OUT;
+	} else {
+		formats = oxfw->rx_stream_formats;
+		dir = AVC_GENERAL_PLUG_DIR_IN;
+	}
 
 	/* Seek stream format for requirements. */
 	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
@@ -64,8 +85,7 @@ static int set_stream_format(struct snd_oxfw *oxfw, struct amdtp_stream *s,
 
 	/* If assumed, just change rate. */
 	if (oxfw->assumed)
-		return avc_general_set_sig_fmt(oxfw->unit, rate,
-					       AVC_GENERAL_PLUG_DIR_IN, 0);
+		return set_rate(oxfw, rate);
 
 	/* Calculate format length. */
 	len = 5 + formats[i][4] * 2;
@@ -80,47 +100,35 @@ static int set_stream_format(struct snd_oxfw *oxfw, struct amdtp_stream *s,
 	return 0;
 }
 
-int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw)
+static void stop_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream)
 {
-	int err;
-
-	err = cmp_connection_init(&oxfw->in_conn, oxfw->unit,
-				  CMP_INPUT, 0);
-	if (err < 0)
-		goto end;
+	amdtp_stream_pcm_abort(stream);
+	amdtp_stream_stop(stream);
 
-	err = amdtp_stream_init(&oxfw->rx_stream, oxfw->unit,
-				AMDTP_OUT_STREAM, CIP_NONBLOCKING);
-	if (err < 0) {
-		amdtp_stream_destroy(&oxfw->rx_stream);
-		cmp_connection_destroy(&oxfw->in_conn);
-	}
-end:
-	return err;
-}
-
-static void stop_stream(struct snd_oxfw *oxfw)
-{
-	amdtp_stream_pcm_abort(&oxfw->rx_stream);
-	amdtp_stream_stop(&oxfw->rx_stream);
-	cmp_connection_break(&oxfw->in_conn);
+	if (stream == &oxfw->tx_stream)
+		cmp_connection_break(&oxfw->out_conn);
+	else
+		cmp_connection_break(&oxfw->in_conn);
 }
 
-static int start_stream(struct snd_oxfw *oxfw, unsigned int rate,
-			unsigned int pcm_channels)
+static int start_stream(struct snd_oxfw *oxfw, struct amdtp_stream *stream,
+			unsigned int rate, unsigned int pcm_channels)
 {
 	u8 **formats;
 	struct cmp_connection *conn;
 	struct snd_oxfw_stream_formation formation;
 	unsigned int i, midi_ports;
-	struct amdtp_stream *stream;
 	int err;
 
-	stream = &oxfw->rx_stream;
-	formats = oxfw->rx_stream_formats;
-	conn = &oxfw->in_conn;
+	if (stream == &oxfw->rx_stream) {
+		formats = oxfw->rx_stream_formats;
+		conn = &oxfw->in_conn;
+	} else {
+		formats = oxfw->tx_stream_formats;
+		conn = &oxfw->out_conn;
+	}
 
-	/* Get stream formation */
+	/* Get stream format */
 	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
 		if (formats[i] == NULL)
 			break;
@@ -164,67 +172,196 @@ static int start_stream(struct snd_oxfw *oxfw, unsigned int rate,
 	/* Wait first packet */
 	err = amdtp_stream_wait_callback(stream, CALLBACK_TIMEOUT);
 	if (err < 0)
-		stop_stream(oxfw);
+		stop_stream(oxfw, stream);
 end:
 	return err;
 }
 
-int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw, unsigned int rate,
-				  unsigned int pcm_channels)
+static int check_connection_used_by_others(struct snd_oxfw *oxfw,
+					   struct amdtp_stream *stream)
 {
+	struct cmp_connection *conn;
+	bool used;
+	int err;
+
+	if (stream == &oxfw->tx_stream)
+		conn = &oxfw->out_conn;
+	else
+		conn = &oxfw->in_conn;
+
+	err = cmp_connection_check_used(conn, &used);
+	if ((err >= 0) && used && !amdtp_stream_running(stream)) {
+		dev_err(&oxfw->unit->device,
+			"Connection established by others: %cPCR[%d]\n",
+			(conn->direction == CMP_OUTPUT) ? 'o' : 'i',
+			conn->pcr_index);
+		err = -EBUSY;
+	}
+
+	return err;
+}
+
+int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw,
+				 struct amdtp_stream *stream)
+{
+	struct cmp_connection *conn;
+	enum cmp_direction c_dir;
+	enum amdtp_stream_direction s_dir;
+	int err;
+
+	if (stream == &oxfw->tx_stream) {
+		conn = &oxfw->out_conn;
+		c_dir = CMP_OUTPUT;
+		s_dir = AMDTP_IN_STREAM;
+	} else {
+		conn = &oxfw->in_conn;
+		c_dir = CMP_INPUT;
+		s_dir = AMDTP_OUT_STREAM;
+	}
+
+	err = cmp_connection_init(conn, oxfw->unit, c_dir, 0);
+	if (err < 0)
+		goto end;
+
+	err = amdtp_stream_init(stream, oxfw->unit, s_dir, CIP_NONBLOCKING);
+	if (err < 0) {
+		amdtp_stream_destroy(stream);
+		cmp_connection_destroy(conn);
+		goto end;
+	}
+
+	/* OXFW starts to transmit packets with non-zero dbc. */
+	if (stream == &oxfw->tx_stream)
+		oxfw->tx_stream.flags |= CIP_SKIP_INIT_DBC_CHECK;
+end:
+	return err;
+}
+
+int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw,
+				  struct amdtp_stream *stream,
+				  unsigned int rate, unsigned int pcm_channels)
+{
+	struct amdtp_stream *opposite;
 	struct snd_oxfw_stream_formation formation;
+	enum avc_general_plug_dir dir;
+	unsigned int substreams, opposite_substreams;
 	int err = 0;
 
+	if (stream == &oxfw->tx_stream) {
+		substreams = oxfw->capture_substreams;
+		opposite = &oxfw->rx_stream;
+		opposite_substreams = oxfw->playback_substreams;
+		dir = AVC_GENERAL_PLUG_DIR_OUT;
+	} else {
+		substreams = oxfw->playback_substreams;
+		opposite_substreams = oxfw->capture_substreams;
+
+		if (oxfw->has_output)
+			opposite = &oxfw->rx_stream;
+		else
+			opposite = NULL;
+
+		dir = AVC_GENERAL_PLUG_DIR_IN;
+	}
+
+	if (substreams == 0)
+		goto end;
+
+	/*
+	 * Considering JACK/FFADO streaming:
+	 * TODO: This can be removed hwdep functionality becomes popular.
+	 */
+	err = check_connection_used_by_others(oxfw, stream);
+	if (err < 0)
+		goto end;
+
 	/* packet queueing error */
-	if (amdtp_streaming_error(&oxfw->rx_stream))
-		stop_stream(oxfw);
+	if (amdtp_streaming_error(stream))
+		stop_stream(oxfw, stream);
 
-	err = snd_oxfw_stream_get_current_formation(oxfw,
-						    AVC_GENERAL_PLUG_DIR_IN,
-						    &formation);
+	err = snd_oxfw_stream_get_current_formation(oxfw, dir, &formation);
 	if (err < 0)
 		goto end;
 
 	if ((formation.rate != rate) || (formation.pcm != pcm_channels)) {
-		stop_stream(oxfw);
+		if (opposite != NULL) {
+			err = check_connection_used_by_others(oxfw, opposite);
+			if (err < 0)
+				goto end;
+			stop_stream(oxfw, opposite);
+		}
+		stop_stream(oxfw, stream);
 
-		/* arrange sampling rate */
-		err = set_stream_format(oxfw, &oxfw->rx_stream, rate,
-					pcm_channels);
+		err = set_stream_format(oxfw, stream, rate, pcm_channels);
 		if (err < 0) {
 			dev_err(&oxfw->unit->device,
 				"fail to set stream format: %d\n", err);
 			goto end;
 		}
+
+		/* Start opposite stream if needed. */
+		if (opposite && !amdtp_stream_running(opposite) &&
+		    (opposite_substreams > 0)) {
+			err = start_stream(oxfw, opposite, rate, 0);
+			if (err < 0) {
+				dev_err(&oxfw->unit->device,
+					"fail to restart stream: %d\n", err);
+				goto end;
+			}
+		}
 	}
 
-	err = start_stream(oxfw, rate, pcm_channels);
-	if (err < 0)
-		dev_err(&oxfw->unit->device,
-			"fail to start stream: %d\n", err);
+	/* Start requested stream. */
+	if (!amdtp_stream_running(stream)) {
+		err = start_stream(oxfw, stream, rate, pcm_channels);
+		if (err < 0)
+			dev_err(&oxfw->unit->device,
+				"fail to start stream: %d\n", err);
+	}
 end:
 	return err;
 }
 
-void snd_oxfw_stream_stop_simplex(struct snd_oxfw *oxfw)
+void snd_oxfw_stream_stop_simplex(struct snd_oxfw *oxfw,
+				  struct amdtp_stream *stream)
 {
-	stop_stream(oxfw);
+	if (((stream == &oxfw->tx_stream) && (oxfw->capture_substreams > 0)) ||
+	    ((stream == &oxfw->rx_stream) && (oxfw->playback_substreams > 0)))
+		return;
+
+	stop_stream(oxfw, stream);
 }
 
-void snd_oxfw_stream_destroy_simplex(struct snd_oxfw *oxfw)
+void snd_oxfw_stream_destroy_simplex(struct snd_oxfw *oxfw,
+				     struct amdtp_stream *stream)
 {
-	stop_stream(oxfw);
+	struct cmp_connection *conn;
+
+	if (stream == &oxfw->tx_stream)
+		conn = &oxfw->out_conn;
+	else
+		conn = &oxfw->in_conn;
 
-	amdtp_stream_destroy(&oxfw->rx_stream);
-	cmp_connection_destroy(&oxfw->in_conn);
+	stop_stream(oxfw, stream);
+
+	amdtp_stream_destroy(stream);
+	cmp_connection_destroy(conn);
 }
 
-void snd_oxfw_stream_update_simplex(struct snd_oxfw *oxfw)
+void snd_oxfw_stream_update_simplex(struct snd_oxfw *oxfw,
+				    struct amdtp_stream *stream)
 {
-	if (cmp_connection_update(&oxfw->in_conn) < 0)
-		stop_stream(oxfw);
+	struct cmp_connection *conn;
+
+	if (stream == &oxfw->tx_stream)
+		conn = &oxfw->out_conn;
+	else
+		conn = &oxfw->in_conn;
+
+	if (cmp_connection_update(conn) < 0)
+		stop_stream(oxfw, stream);
 	else
-		amdtp_stream_update(&oxfw->rx_stream);
+		amdtp_stream_update(stream);
 }
 
 int snd_oxfw_stream_get_current_formation(struct snd_oxfw *oxfw,
@@ -408,7 +545,10 @@ static int fill_stream_formats(struct snd_oxfw *oxfw,
 	if (buf == NULL)
 		return -ENOMEM;
 
-	formats = oxfw->rx_stream_formats;
+	if (dir == AVC_GENERAL_PLUG_DIR_OUT)
+		formats = oxfw->tx_stream_formats;
+	else
+		formats = oxfw->rx_stream_formats;
 
 	/* get first entry */
 	len = AVC_GENERIC_FRAME_MAXIMUM_BYTES;
@@ -481,11 +621,19 @@ int snd_oxfw_stream_discover(struct snd_oxfw *oxfw)
 		"fail to get info for isoc/external in/out plugs: %d\n",
 			err);
 		goto end;
-	} else if (plugs[0] == 0) {
+	} else if ((plugs[0] == 0) && (plugs[1] == 0)) {
 		err = -ENOSYS;
 		goto end;
 	}
 
+	/* use oPCR[0] if exists */
+	if (plugs[1] > 0) {
+		err = fill_stream_formats(oxfw, AVC_GENERAL_PLUG_DIR_OUT, 0);
+		if (err < 0)
+			goto end;
+		oxfw->has_output = true;
+	}
+
 	/* use iPCR[0] if exists */
 	if (plugs[0] > 0)
 		err = fill_stream_formats(oxfw, AVC_GENERAL_PLUG_DIR_IN, 0);

commit f3699e2c77455a6cccc977b391c553f2c816f639
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:44 2014 +0900

    ALSA: oxfw: Change the way to start stream
    
    In past commit, this driver can keep stream formations for each sampling
    rate. So its stream functionality can decide stream formations with given
    some parameters.
    
    This commit moves related codes from PCM functionality to stream
    functionality. Furthermore, to set stream format correctly, this commit
    uses AV/C Stream Format Information command instead of AV/C Input/Output
    Plug Signal Format command.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 210bf5a2f56e..1820497f4bbf 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -7,8 +7,10 @@
  */
 
 #include "oxfw.h"
+#include <linux/delay.h>
 
 #define AVC_GENERIC_FRAME_MAXIMUM_BYTES	512
+#define CALLBACK_TIMEOUT	200
 
 /*
  * According to datasheet of Oxford Semiconductor:
@@ -37,6 +39,47 @@ static const unsigned int avc_stream_rate_table[] = {
 	[5] = 0x07,
 };
 
+static int set_stream_format(struct snd_oxfw *oxfw, struct amdtp_stream *s,
+			     unsigned int rate, unsigned int pcm_channels)
+{
+	u8 **formats;
+	struct snd_oxfw_stream_formation formation;
+	enum avc_general_plug_dir dir;
+	unsigned int i, err, len;
+
+	formats = oxfw->rx_stream_formats;
+	dir = AVC_GENERAL_PLUG_DIR_IN;
+
+	/* Seek stream format for requirements. */
+	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
+		err = snd_oxfw_stream_parse_format(formats[i], &formation);
+		if (err < 0)
+			return err;
+
+		if ((formation.rate == rate) && (formation.pcm == pcm_channels))
+			break;
+	}
+	if (i == SND_OXFW_STREAM_FORMAT_ENTRIES)
+		return -EINVAL;
+
+	/* If assumed, just change rate. */
+	if (oxfw->assumed)
+		return avc_general_set_sig_fmt(oxfw->unit, rate,
+					       AVC_GENERAL_PLUG_DIR_IN, 0);
+
+	/* Calculate format length. */
+	len = 5 + formats[i][4] * 2;
+
+	err = avc_stream_set_format(oxfw->unit, dir, 0, formats[i], len);
+	if (err < 0)
+		return err;
+
+	/* Some requests just after changing format causes freezing. */
+	msleep(100);
+
+	return 0;
+}
+
 int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw)
 {
 	int err;
@@ -63,30 +106,106 @@ static void stop_stream(struct snd_oxfw *oxfw)
 	cmp_connection_break(&oxfw->in_conn);
 }
 
-int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw)
+static int start_stream(struct snd_oxfw *oxfw, unsigned int rate,
+			unsigned int pcm_channels)
 {
-	int err = 0;
+	u8 **formats;
+	struct cmp_connection *conn;
+	struct snd_oxfw_stream_formation formation;
+	unsigned int i, midi_ports;
+	struct amdtp_stream *stream;
+	int err;
 
-	if (amdtp_streaming_error(&oxfw->rx_stream))
-		stop_stream(oxfw);
+	stream = &oxfw->rx_stream;
+	formats = oxfw->rx_stream_formats;
+	conn = &oxfw->in_conn;
 
-	if (amdtp_stream_running(&oxfw->rx_stream))
+	/* Get stream formation */
+	for (i = 0; i < SND_OXFW_STREAM_FORMAT_ENTRIES; i++) {
+		if (formats[i] == NULL)
+			break;
+
+		err = snd_oxfw_stream_parse_format(formats[i], &formation);
+		if (err < 0)
+			goto end;
+		if (rate != formation.rate)
+			continue;
+		if (pcm_channels == 0 ||  pcm_channels == formation.pcm)
+			break;
+	}
+	if (i == SND_OXFW_STREAM_FORMAT_ENTRIES) {
+		err = -EINVAL;
 		goto end;
+	}
 
-	err = cmp_connection_establish(&oxfw->in_conn,
-			amdtp_stream_get_max_payload(&oxfw->rx_stream));
+	pcm_channels = formation.pcm;
+	midi_ports = DIV_ROUND_UP(formation.midi, 8);
+
+	/* The stream should have one pcm channels at least */
+	if (pcm_channels == 0) {
+		err = -EINVAL;
+		goto end;
+	}
+	amdtp_stream_set_parameters(stream, rate, pcm_channels, midi_ports);
+
+	err = cmp_connection_establish(conn,
+				       amdtp_stream_get_max_payload(stream));
 	if (err < 0)
 		goto end;
 
-	err = amdtp_stream_start(&oxfw->rx_stream,
-				 oxfw->in_conn.resources.channel,
-				 oxfw->in_conn.speed);
+	err = amdtp_stream_start(stream,
+				 conn->resources.channel,
+				 conn->speed);
+	if (err < 0) {
+		cmp_connection_break(conn);
+		goto end;
+	}
+
+	/* Wait first packet */
+	err = amdtp_stream_wait_callback(stream, CALLBACK_TIMEOUT);
 	if (err < 0)
 		stop_stream(oxfw);
 end:
 	return err;
 }
 
+int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw, unsigned int rate,
+				  unsigned int pcm_channels)
+{
+	struct snd_oxfw_stream_formation formation;
+	int err = 0;
+
+	/* packet queueing error */
+	if (amdtp_streaming_error(&oxfw->rx_stream))
+		stop_stream(oxfw);
+
+	err = snd_oxfw_stream_get_current_formation(oxfw,
+						    AVC_GENERAL_PLUG_DIR_IN,
+						    &formation);
+	if (err < 0)
+		goto end;
+
+	if ((formation.rate != rate) || (formation.pcm != pcm_channels)) {
+		stop_stream(oxfw);
+
+		/* arrange sampling rate */
+		err = set_stream_format(oxfw, &oxfw->rx_stream, rate,
+					pcm_channels);
+		if (err < 0) {
+			dev_err(&oxfw->unit->device,
+				"fail to set stream format: %d\n", err);
+			goto end;
+		}
+	}
+
+	err = start_stream(oxfw, rate, pcm_channels);
+	if (err < 0)
+		dev_err(&oxfw->unit->device,
+			"fail to start stream: %d\n", err);
+end:
+	return err;
+}
+
 void snd_oxfw_stream_stop_simplex(struct snd_oxfw *oxfw)
 {
 	stop_stream(oxfw);

commit 3c96101f190020e91d413c5835f7a722fc007923
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:43 2014 +0900

    ALSA: oxfw: Add proc interface for debugging purpose
    
    This commit adds proc interface to get information about stream
    formation. This commit also adds snd_oxfw_stream_get_current_formation()
    to get current stream formation.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index 17e3802e6ac2..210bf5a2f56e 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -108,6 +108,33 @@ void snd_oxfw_stream_update_simplex(struct snd_oxfw *oxfw)
 		amdtp_stream_update(&oxfw->rx_stream);
 }
 
+int snd_oxfw_stream_get_current_formation(struct snd_oxfw *oxfw,
+				enum avc_general_plug_dir dir,
+				struct snd_oxfw_stream_formation *formation)
+{
+	u8 *format;
+	unsigned int len;
+	int err;
+
+	len = AVC_GENERIC_FRAME_MAXIMUM_BYTES;
+	format = kmalloc(len, GFP_KERNEL);
+	if (format == NULL)
+		return -ENOMEM;
+
+	err = avc_stream_get_format_single(oxfw->unit, dir, 0, format, &len);
+	if (err < 0)
+		goto end;
+	if (len < 3) {
+		err = -EIO;
+		goto end;
+	}
+
+	err = snd_oxfw_stream_parse_format(format, formation);
+end:
+	kfree(format);
+	return err;
+}
+
 /*
  * See Table 6.16 - AM824 Stream Format
  *     Figure 6.19 - format_information field for AM824 Compound

commit 5cd1d3f47a6321612a51ab88ffe8ef65120fcbe0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 9 00:10:42 2014 +0900

    ALSA: oxfw: Change the way to make PCM rules/constraints
    
    In previous commit, this driver can get to know stream formations at
    each supported sampling rates. This commit uses it to make PCM
    rules/constraints and obsoletes hard-coded rules/constraints.
    
    For this purpose, this commit adds 'struct snd_oxfw_stream_formation' and
    snd_oxfw_stream_parse_format() to parse data channel formation of data
    block.
    
    According to datasheet of OXFW970/971, they support 32.0kHz to 196.0kHz.
    
    As long as developers investigate, some devices are confirmed to have
    several formats for the same sampling rate.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
index ebd156f3e29d..17e3802e6ac2 100644
--- a/sound/firewire/oxfw/oxfw-stream.c
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -8,6 +8,35 @@
 
 #include "oxfw.h"
 
+#define AVC_GENERIC_FRAME_MAXIMUM_BYTES	512
+
+/*
+ * According to datasheet of Oxford Semiconductor:
+ *  OXFW970: 32.0/44.1/48.0/96.0 Khz, 8 audio channels I/O
+ *  OXFW971: 32.0/44.1/48.0/88.2/96.0/192.0 kHz, 16 audio channels I/O, MIDI I/O
+ */
+static const unsigned int oxfw_rate_table[] = {
+	[0] = 32000,
+	[1] = 44100,
+	[2] = 48000,
+	[3] = 88200,
+	[4] = 96000,
+	[5] = 192000,
+};
+
+/*
+ * See Table 5.7 – Sampling frequency for Multi-bit Audio
+ * in AV/C Stream Format Information Specification 1.1 (Apr 2005, 1394TA)
+ */
+static const unsigned int avc_stream_rate_table[] = {
+	[0] = 0x02,
+	[1] = 0x03,
+	[2] = 0x04,
+	[3] = 0x0a,
+	[4] = 0x05,
+	[5] = 0x07,
+};
+
 int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw)
 {
 	int err;
@@ -78,3 +107,242 @@ void snd_oxfw_stream_update_simplex(struct snd_oxfw *oxfw)
 	else
 		amdtp_stream_update(&oxfw->rx_stream);
 }
+
+/*
+ * See Table 6.16 - AM824 Stream Format
+ *     Figure 6.19 - format_information field for AM824 Compound
+ * in AV/C Stream Format Information Specification 1.1 (Apr 2005, 1394TA)
+ * Also 'Clause 12 AM824 sequence adaption layers' in IEC 61883-6:2005
+ */
+int snd_oxfw_stream_parse_format(u8 *format,
+				 struct snd_oxfw_stream_formation *formation)
+{
+	unsigned int i, e, channels, type;
+
+	memset(formation, 0, sizeof(struct snd_oxfw_stream_formation));
+
+	/*
+	 * this module can support a hierarchy combination that:
+	 *  Root:	Audio and Music (0x90)
+	 *  Level 1:	AM824 Compound  (0x40)
+	 */
+	if ((format[0] != 0x90) || (format[1] != 0x40))
+		return -ENOSYS;
+
+	/* check the sampling rate */
+	for (i = 0; i < ARRAY_SIZE(avc_stream_rate_table); i++) {
+		if (format[2] == avc_stream_rate_table[i])
+			break;
+	}
+	if (i == ARRAY_SIZE(avc_stream_rate_table))
+		return -ENOSYS;
+
+	formation->rate = oxfw_rate_table[i];
+
+	for (e = 0; e < format[4]; e++) {
+		channels = format[5 + e * 2];
+		type = format[6 + e * 2];
+
+		switch (type) {
+		/* IEC 60958 Conformant, currently handled as MBLA */
+		case 0x00:
+		/* Multi Bit Linear Audio (Raw) */
+		case 0x06:
+			formation->pcm += channels;
+			break;
+		/* MIDI Conformant */
+		case 0x0d:
+			formation->midi = channels;
+			break;
+		/* IEC 61937-3 to 7 */
+		case 0x01:
+		case 0x02:
+		case 0x03:
+		case 0x04:
+		case 0x05:
+		/* Multi Bit Linear Audio */
+		case 0x07:	/* DVD-Audio */
+		case 0x0c:	/* High Precision */
+		/* One Bit Audio */
+		case 0x08:	/* (Plain) Raw */
+		case 0x09:	/* (Plain) SACD */
+		case 0x0a:	/* (Encoded) Raw */
+		case 0x0b:	/* (Encoded) SACD */
+		/* SMPTE Time-Code conformant */
+		case 0x0e:
+		/* Sample Count */
+		case 0x0f:
+		/* Anciliary Data */
+		case 0x10:
+		/* Synchronization Stream (Stereo Raw audio) */
+		case 0x40:
+		/* Don't care */
+		case 0xff:
+		default:
+			return -ENOSYS;	/* not supported */
+		}
+	}
+
+	if (formation->pcm  > AMDTP_MAX_CHANNELS_FOR_PCM ||
+	    formation->midi > AMDTP_MAX_CHANNELS_FOR_MIDI)
+		return -ENOSYS;
+
+	return 0;
+}
+
+static int
+assume_stream_formats(struct snd_oxfw *oxfw, enum avc_general_plug_dir dir,
+		      unsigned int pid, u8 *buf, unsigned int *len,
+		      u8 **formats)
+{
+	struct snd_oxfw_stream_formation formation;
+	unsigned int i, eid;
+	int err;
+
+	/* get format at current sampling rate */
+	err = avc_stream_get_format_single(oxfw->unit, dir, pid, buf, len);
+	if (err < 0) {
+		dev_err(&oxfw->unit->device,
+		"fail to get current stream format for isoc %s plug %d:%d\n",
+			(dir == AVC_GENERAL_PLUG_DIR_IN) ? "in" : "out",
+			pid, err);
+		goto end;
+	}
+
+	/* parse and set stream format */
+	eid = 0;
+	err = snd_oxfw_stream_parse_format(buf, &formation);
+	if (err < 0)
+		goto end;
+
+	formats[eid] = kmalloc(*len, GFP_KERNEL);
+	if (formats[eid] == NULL) {
+		err = -ENOMEM;
+		goto end;
+	}
+	memcpy(formats[eid], buf, *len);
+
+	/* apply the format for each available sampling rate */
+	for (i = 0; i < ARRAY_SIZE(oxfw_rate_table); i++) {
+		if (formation.rate == oxfw_rate_table[i])
+			continue;
+
+		err = avc_general_inquiry_sig_fmt(oxfw->unit,
+						  oxfw_rate_table[i],
+						  dir, pid);
+		if (err < 0)
+			continue;
+
+		eid++;
+		formats[eid] = kmalloc(*len, GFP_KERNEL);
+		if (formats[eid] == NULL) {
+			err = -ENOMEM;
+			goto end;
+		}
+		memcpy(formats[eid], buf, *len);
+		formats[eid][2] = avc_stream_rate_table[i];
+	}
+
+	err = 0;
+	oxfw->assumed = true;
+end:
+	return err;
+}
+
+static int fill_stream_formats(struct snd_oxfw *oxfw,
+			       enum avc_general_plug_dir dir,
+			       unsigned short pid)
+{
+	u8 *buf, **formats;
+	unsigned int len, eid = 0;
+	struct snd_oxfw_stream_formation dummy;
+	int err;
+
+	buf = kmalloc(AVC_GENERIC_FRAME_MAXIMUM_BYTES, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	formats = oxfw->rx_stream_formats;
+
+	/* get first entry */
+	len = AVC_GENERIC_FRAME_MAXIMUM_BYTES;
+	err = avc_stream_get_format_list(oxfw->unit, dir, 0, buf, &len, 0);
+	if (err == -ENOSYS) {
+		/* LIST subfunction is not implemented */
+		len = AVC_GENERIC_FRAME_MAXIMUM_BYTES;
+		err = assume_stream_formats(oxfw, dir, pid, buf, &len,
+					    formats);
+		goto end;
+	} else if (err < 0) {
+		dev_err(&oxfw->unit->device,
+			"fail to get stream format %d for isoc %s plug %d:%d\n",
+			eid, (dir == AVC_GENERAL_PLUG_DIR_IN) ? "in" : "out",
+			pid, err);
+		goto end;
+	}
+
+	/* LIST subfunction is implemented */
+	while (eid < SND_OXFW_STREAM_FORMAT_ENTRIES) {
+		/* The format is too short. */
+		if (len < 3) {
+			err = -EIO;
+			break;
+		}
+
+		/* parse and set stream format */
+		err = snd_oxfw_stream_parse_format(buf, &dummy);
+		if (err < 0)
+			break;
+
+		formats[eid] = kmalloc(len, GFP_KERNEL);
+		if (formats[eid] == NULL) {
+			err = -ENOMEM;
+			break;
+		}
+		memcpy(formats[eid], buf, len);
+
+		/* get next entry */
+		len = AVC_GENERIC_FRAME_MAXIMUM_BYTES;
+		err = avc_stream_get_format_list(oxfw->unit, dir, 0,
+						 buf, &len, ++eid);
+		/* No entries remained. */
+		if (err == -EINVAL) {
+			err = 0;
+			break;
+		} else if (err < 0) {
+			dev_err(&oxfw->unit->device,
+			"fail to get stream format %d for isoc %s plug %d:%d\n",
+				eid, (dir == AVC_GENERAL_PLUG_DIR_IN) ? "in" :
+									"out",
+				pid, err);
+			break;
+		}
+	}
+end:
+	kfree(buf);
+	return err;
+}
+
+int snd_oxfw_stream_discover(struct snd_oxfw *oxfw)
+{
+	u8 plugs[AVC_PLUG_INFO_BUF_BYTES];
+	int err;
+
+	/* the number of plugs for isoc in/out, ext in/out  */
+	err = avc_general_get_plug_info(oxfw->unit, 0x1f, 0x07, 0x00, plugs);
+	if (err < 0) {
+		dev_err(&oxfw->unit->device,
+		"fail to get info for isoc/external in/out plugs: %d\n",
+			err);
+		goto end;
+	} else if (plugs[0] == 0) {
+		err = -ENOSYS;
+		goto end;
+	}
+
+	/* use iPCR[0] if exists */
+	if (plugs[0] > 0)
+		err = fill_stream_formats(oxfw, AVC_GENERAL_PLUG_DIR_IN, 0);
+end:
+	return err;
+}

commit e2786ca648d780d106bd8abca06746eb30d15ee7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sat Nov 29 00:59:27 2014 +0900

    ALSA: oxfw: Split stream functionality to a new file and add a header file
    
    This is a help for works in followed patches.
    
    And this commit remove 'fw_unit_get()/fw_unit_put()' because these
    are called by helper functions in 'snd-firewire-lib'.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/oxfw/oxfw-stream.c b/sound/firewire/oxfw/oxfw-stream.c
new file mode 100644
index 000000000000..ebd156f3e29d
--- /dev/null
+++ b/sound/firewire/oxfw/oxfw-stream.c
@@ -0,0 +1,80 @@
+/*
+ * oxfw_stream.c - a part of driver for OXFW970/971 based devices
+ *
+ * Copyright (c) 2014 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "oxfw.h"
+
+int snd_oxfw_stream_init_simplex(struct snd_oxfw *oxfw)
+{
+	int err;
+
+	err = cmp_connection_init(&oxfw->in_conn, oxfw->unit,
+				  CMP_INPUT, 0);
+	if (err < 0)
+		goto end;
+
+	err = amdtp_stream_init(&oxfw->rx_stream, oxfw->unit,
+				AMDTP_OUT_STREAM, CIP_NONBLOCKING);
+	if (err < 0) {
+		amdtp_stream_destroy(&oxfw->rx_stream);
+		cmp_connection_destroy(&oxfw->in_conn);
+	}
+end:
+	return err;
+}
+
+static void stop_stream(struct snd_oxfw *oxfw)
+{
+	amdtp_stream_pcm_abort(&oxfw->rx_stream);
+	amdtp_stream_stop(&oxfw->rx_stream);
+	cmp_connection_break(&oxfw->in_conn);
+}
+
+int snd_oxfw_stream_start_simplex(struct snd_oxfw *oxfw)
+{
+	int err = 0;
+
+	if (amdtp_streaming_error(&oxfw->rx_stream))
+		stop_stream(oxfw);
+
+	if (amdtp_stream_running(&oxfw->rx_stream))
+		goto end;
+
+	err = cmp_connection_establish(&oxfw->in_conn,
+			amdtp_stream_get_max_payload(&oxfw->rx_stream));
+	if (err < 0)
+		goto end;
+
+	err = amdtp_stream_start(&oxfw->rx_stream,
+				 oxfw->in_conn.resources.channel,
+				 oxfw->in_conn.speed);
+	if (err < 0)
+		stop_stream(oxfw);
+end:
+	return err;
+}
+
+void snd_oxfw_stream_stop_simplex(struct snd_oxfw *oxfw)
+{
+	stop_stream(oxfw);
+}
+
+void snd_oxfw_stream_destroy_simplex(struct snd_oxfw *oxfw)
+{
+	stop_stream(oxfw);
+
+	amdtp_stream_destroy(&oxfw->rx_stream);
+	cmp_connection_destroy(&oxfw->in_conn);
+}
+
+void snd_oxfw_stream_update_simplex(struct snd_oxfw *oxfw)
+{
+	if (cmp_connection_update(&oxfw->in_conn) < 0)
+		stop_stream(oxfw);
+	else
+		amdtp_stream_update(&oxfw->rx_stream);
+}
