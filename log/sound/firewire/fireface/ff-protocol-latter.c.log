commit 1f65e6683267dde67a71c6bfcf71de35916be11a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun May 10 16:43:01 2020 +0900

    ALSA: fireface: add support for RME Fireface UFX (untested)
    
    Fireface UFX was shipped by RME GmbH in 2010, and now discontinued.
    Although this model has some enhanced feature which Fireface 802
    doesn't have (e.g. on-board USB mass storage device class, configuration
    interface with color display), the functionality relevant to
    packet communication on IEEE 1394 bus seems to be the same as
    Fireface 802 (e.g. available number of channels for PCM frame in
    each sampling transfer frequency).
    
    With the assumption, this commit adds support for Fireface UFX. In ALSA
    fireface driver, these two models are handled as the same one.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200510074301.116224-7-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index ea885e725950..8d3b23778eb2 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -199,7 +199,7 @@ static int latter_begin_session(struct snd_ff *ff, unsigned int rate)
 		else
 			return -EINVAL;
 	} else {
-		// For Fireface 802. Due to bandwidth limitation on
+		// For Fireface UFX and 802. Due to bandwidth limitation on
 		// IEEE 1394a (400 Mbps), Analog 1-12 and AES are available
 		// without any ADAT at quadruple speed.
 		if (rate >= 32000 && rate <= 48000)

commit 062bb452b078ba481d856e1aca176e16b8b1466d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun May 10 16:43:00 2020 +0900

    ALSA: fireface: add support for RME FireFace 802
    
    Fireface 802 was shipped by RME GmbH in 2014. This model supports later
    protocol for management of isochronous communication and synchronization
    of sampling transmission frequency.
    
    This model consists of below ICs:
     * TI TSB41AB2
     * Xilinx Spartan-6 FPGA XC6SLX16
     * TI TMS320 C6747
     * SMSC USB3250
    
    Especially, this model just supports IEEE 1394a, against its name which
    evokes Fireface 800.
    
    This commit adds support for Fireface 802 (tested). Userspace applications
    can transfer PCM frames and MIDI messages via ALSA PCM/Rawmidi interface.
    I note that 4 channels for ADAt1 and ADAT2 are disabled at higher sampling
    transfer frequency since isochronous resources reservation fails due to
    bandwidth limitation of IEEE 1394a.
    
    The value read from LATTER_SYNC_STATUS register is slightly different
    from the one of Fireface UCX. The higher 4 bits and lower 4 bits are
    swapped within the same byte.
    
    Without any assist of userspace application, transmitted MIDI messages
    from the device are not going to be processed. For detail, please refer
    to my comment in code of latter protocol.
    
    $ python crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  0404ffff  bus_info_length 4, crc_length 4, crc 65535 (should be 26805)
    404  31333934  bus_name "1394"
    408  20008000  irmc 0, cmc 0, isc 1, bmc 0, cyc_clk_acc 0, max_rec 8 (512)
    40c  000a3504  company_id 000a35     |
    410  38077423  device_id 0438077423  | EUI-64 000a350438077423
    
                   root directory
                   -----------------------------------------------------------------
    414  0005ffff  directory_length 5, crc 65535 (should be 9514)
    418  0c0083c0  node capabilities per IEEE 1394
    41c  03000a35  vendor
    420  8100000b  --> descriptor leaf at 44c
    424  8d000007  --> eui-64 leaf at 440
    428  d1000001  --> unit directory at 42c
    
                   unit directory at 42c
                   -----------------------------------------------------------------
    42c  0004ffff  directory_length 4, crc 65535 (should be 45134)
    430  12000a35  specifier id
    434  13000005  version
    438  17101800  model
    43c  81000008  --> descriptor leaf at 45c
    
                   eui-64 leaf at 440
                   -----------------------------------------------------------------
    440  0002ffff  leaf_length 2, crc 65535 (should be 60131)
    444  000a3504  company_id 000a35     |
    448  38077423  device_id 0438077423  | EUI-64 000a350438077423
    
                   descriptor leaf at 44c
                   -----------------------------------------------------------------
    44c  0003ffff  leaf_length 3, crc 65535 (should be 469)
    450  00000000  textual descriptor
    454  00000000  minimal ASCII
    458  524d4521  "RME!"
    
                   descriptor leaf at 45c
                   -----------------------------------------------------------------
    45c  0005ffff  leaf_length 5, crc 65535 (should be 10561)
    460  00000000  textual descriptor
    464  00000000  minimal ASCII
    468  46697265  "Fire"
    46c  66616365  "face"
    470  20383032  " 802"
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200510074301.116224-6-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index 76ae568489ef..ea885e725950 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -16,7 +16,8 @@
 #define LATTER_SYNC_STATUS	0x0000801c0000ULL
 
 static int parse_clock_bits(u32 data, unsigned int *rate,
-			    enum snd_ff_clock_src *src)
+			    enum snd_ff_clock_src *src,
+			    enum snd_ff_unit_version unit_version)
 {
 	static const struct {
 		unsigned int rate;
@@ -43,6 +44,11 @@ static int parse_clock_bits(u32 data, unsigned int *rate,
 	};
 	int i;
 
+	if (unit_version != SND_FF_UNIT_VERSION_UCX) {
+		// e.g. 0x00fe0f20 but expected 0x00eff002.
+		data = ((data & 0xf0f0f0f0) >> 4) | ((data & 0x0f0f0f0f) << 4);
+	}
+
 	for (i = 0; i < ARRAY_SIZE(rate_entries); ++i) {
 		rate_entry = rate_entries + i;
 		if ((data & 0x0f000000) == rate_entry->flag) {
@@ -79,7 +85,7 @@ static int latter_get_clock(struct snd_ff *ff, unsigned int *rate,
 		return err;
 	data = le32_to_cpu(reg);
 
-	return parse_clock_bits(data, rate, src);
+	return parse_clock_bits(data, rate, src, ff->unit_version);
 }
 
 static int latter_switch_fetching_mode(struct snd_ff *ff, bool enable)
@@ -181,14 +187,30 @@ static int latter_begin_session(struct snd_ff *ff, unsigned int rate)
 	__le32 reg;
 	int err;
 
-	if (rate >= 32000 && rate <= 48000)
-		flag = 0x92;
-	else if (rate >= 64000 && rate <= 96000)
-		flag = 0x8e;
-	else if (rate >= 128000 && rate <= 192000)
-		flag = 0x8c;
-	else
-		return -EINVAL;
+	if (ff->unit_version == SND_FF_UNIT_VERSION_UCX) {
+		// For Fireface UCX. Always use the maximum number of data
+		// channels in data block of packet.
+		if (rate >= 32000 && rate <= 48000)
+			flag = 0x92;
+		else if (rate >= 64000 && rate <= 96000)
+			flag = 0x8e;
+		else if (rate >= 128000 && rate <= 192000)
+			flag = 0x8c;
+		else
+			return -EINVAL;
+	} else {
+		// For Fireface 802. Due to bandwidth limitation on
+		// IEEE 1394a (400 Mbps), Analog 1-12 and AES are available
+		// without any ADAT at quadruple speed.
+		if (rate >= 32000 && rate <= 48000)
+			flag = 0x9e;
+		else if (rate >= 64000 && rate <= 96000)
+			flag = 0x96;
+		else if (rate >= 128000 && rate <= 192000)
+			flag = 0x8e;
+		else
+			return -EINVAL;
+	}
 
 	if (generation != fw_parent_device(ff->unit)->card->generation) {
 		err = fw_iso_resources_update(&ff->tx_resources);
@@ -207,8 +229,6 @@ static int latter_begin_session(struct snd_ff *ff, unsigned int rate)
 	if (err < 0)
 		return err;
 
-	// Always use the maximum number of data channels in data block of
-	// packet.
 	reg = cpu_to_le32(flag);
 	return snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
 				  LATTER_ISOC_START, &reg, sizeof(reg), 0);
@@ -263,7 +283,7 @@ static void latter_dump_status(struct snd_ff *ff, struct snd_info_buffer *buffer
 		}
 	}
 
-	err = parse_clock_bits(data, &rate, &src);
+	err = parse_clock_bits(data, &rate, &src, ff->unit_version);
 	if (err < 0)
 		return;
 	label = snd_ff_proc_get_clk_label(src);

commit bbd6aac3ae15bef762af03bf62e35ace5c4292bd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun May 10 16:42:56 2020 +0900

    ALSA: fireface: fix configuration error for nominal sampling transfer frequency
    
    128000 and 192000 are congruence modulo 32000, thus it's wrong to
    distinguish them as multiple of 32000 and 48000 by modulo 32000 at
    first.
    
    Additionally, used condition statement to detect quadruple speed can
    cause missing bit flag.
    
    Furthermore, counter to ensure the configuration is wrong and it
    causes false positive.
    
    This commit fixes the above three bugs.
    
    Cc: <stable@vger.kernel.org>
    Fixes: 60aec494b389 ("ALSA: fireface: support allocate_resources operation in latter protocol")
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200510074301.116224-2-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index 0e4c3a9ed5e4..76ae568489ef 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -107,18 +107,18 @@ static int latter_allocate_resources(struct snd_ff *ff, unsigned int rate)
 	int err;
 
 	// Set the number of data blocks transferred in a second.
-	if (rate % 32000 == 0)
-		code = 0x00;
+	if (rate % 48000 == 0)
+		code = 0x04;
 	else if (rate % 44100 == 0)
 		code = 0x02;
-	else if (rate % 48000 == 0)
-		code = 0x04;
+	else if (rate % 32000 == 0)
+		code = 0x00;
 	else
 		return -EINVAL;
 
 	if (rate >= 64000 && rate < 128000)
 		code |= 0x08;
-	else if (rate >= 128000 && rate < 192000)
+	else if (rate >= 128000)
 		code |= 0x10;
 
 	reg = cpu_to_le32(code);
@@ -140,7 +140,7 @@ static int latter_allocate_resources(struct snd_ff *ff, unsigned int rate)
 		if (curr_rate == rate)
 			break;
 	}
-	if (count == 10)
+	if (count > 10)
 		return -ETIMEDOUT;
 
 	for (i = 0; i < ARRAY_SIZE(amdtp_rate_table); ++i) {

commit b5c21c84705dbd96a0fff930d33022a17910b4f4
Merge: 7c2b3629d09d 7fbd1753b64e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 1 17:01:00 2019 +0200

    Merge branch 'for-linus' into for-next
    
    This back-merge is necessary for adjusting the latest FireWire fix
    with the recent refactoring in 5.3 development branch.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit b88f4d7c3812e3f3f746895cc4475b02c530303e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 2 16:12:57 2019 +0900

    ALSA: fireface: update isochronous resources when starting packet streaming after bus-reset
    
    After bus reset, isochronous resource manager releases all of allocated
    isochronous resources. The nodes to restart packet streaming should
    request reallocation of the resources.
    
    However, between the bus-reset and invocation of 'struct fw_driver.update'
    handler, ALSA PCM application can detect this situation by XRUN because
    the target device cancelled to transmit packets once bus-reset occurs.
    
    Due to the above mechanism, ALSA fireface driver just stops packet
    streaming in the update handler, thus pcm.prepare handler should
    request the reallocation.
    
    This commit requests the reallocation in pcm.prepare callback when
    bus generation is changed.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index 3d12ba5b2a9b..8d6ebb638e93 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -175,6 +175,7 @@ static int latter_allocate_resources(struct snd_ff *ff, unsigned int rate)
 
 static int latter_begin_session(struct snd_ff *ff, unsigned int rate)
 {
+	unsigned int generation = ff->rx_resources.generation;
 	unsigned int flag;
 	u32 data;
 	__le32 reg;
@@ -189,6 +190,16 @@ static int latter_begin_session(struct snd_ff *ff, unsigned int rate)
 	else
 		return -EINVAL;
 
+	if (generation != fw_parent_device(ff->unit)->card->generation) {
+		err = fw_iso_resources_update(&ff->tx_resources);
+		if (err < 0)
+			return err;
+
+		err = fw_iso_resources_update(&ff->rx_resources);
+		if (err < 0)
+			return err;
+	}
+
 	data = (ff->tx_resources.channel << 8) | ff->rx_resources.channel;
 	reg = cpu_to_le32(data);
 	err = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,

commit 60aec494b389ae518b9fe8812bce953440c33123
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jun 2 16:12:55 2019 +0900

    ALSA: fireface: support allocate_resources operation in latter protocol
    
    This commit is a part of preparation to perform allocation/release
    of isochronous channels in pcm.hw_params/hw_free callbacks.
    
    This commit implements allocate_resources callback for the protocol
    specific to latter models. The encoded values of constant table is
    split into several condition statements to separate the operation
    to configure sampling transfer frequency from the operation to
    configure the number of data channels in rx packet.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index c8236ff89b7f..3d12ba5b2a9b 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -97,25 +97,64 @@ static int latter_switch_fetching_mode(struct snd_ff *ff, bool enable)
 				  LATTER_FETCH_MODE, &reg, sizeof(reg), 0);
 }
 
-static int keep_resources(struct snd_ff *ff, unsigned int rate)
+static int latter_allocate_resources(struct snd_ff *ff, unsigned int rate)
 {
 	enum snd_ff_stream_mode mode;
+	unsigned int code;
+	__le32 reg;
+	unsigned int count;
 	int i;
 	int err;
 
-	// Check whether the given value is supported or not.
-	for (i = 0; i < CIP_SFC_COUNT; i++) {
-		if (amdtp_rate_table[i] == rate)
+	// Set the number of data blocks transferred in a second.
+	if (rate % 32000 == 0)
+		code = 0x00;
+	else if (rate % 44100 == 0)
+		code = 0x02;
+	else if (rate % 48000 == 0)
+		code = 0x04;
+	else
+		return -EINVAL;
+
+	if (rate >= 64000 && rate < 128000)
+		code |= 0x08;
+	else if (rate >= 128000 && rate < 192000)
+		code |= 0x10;
+
+	reg = cpu_to_le32(code);
+	err = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
+				 LATTER_STF, &reg, sizeof(reg), 0);
+	if (err < 0)
+		return err;
+
+	// Confirm to shift transmission clock.
+	count = 0;
+	while (count++ < 10) {
+		unsigned int curr_rate;
+		enum snd_ff_clock_src src;
+
+		err = latter_get_clock(ff, &curr_rate, &src);
+		if (err < 0)
+			return err;
+
+		if (curr_rate == rate)
 			break;
 	}
-	if (i >= CIP_SFC_COUNT)
+	if (count == 10)
+		return -ETIMEDOUT;
+
+	for (i = 0; i < ARRAY_SIZE(amdtp_rate_table); ++i) {
+		if (rate == amdtp_rate_table[i])
+			break;
+	}
+	if (i == ARRAY_SIZE(amdtp_rate_table))
 		return -EINVAL;
 
 	err = snd_ff_stream_get_multiplier_mode(i, &mode);
 	if (err < 0)
 		return err;
 
-	/* Keep resources for in-stream. */
+	// Keep resources for in-stream.
 	ff->tx_resources.channels_mask = 0x00000000000000ffuLL;
 	err = fw_iso_resources_allocate(&ff->tx_resources,
 			amdtp_stream_get_max_payload(&ff->tx_stream),
@@ -123,7 +162,7 @@ static int keep_resources(struct snd_ff *ff, unsigned int rate)
 	if (err < 0)
 		return err;
 
-	/* Keep resources for out-stream. */
+	// Keep resources for out-stream.
 	ff->rx_resources.channels_mask = 0x00000000000000ffuLL;
 	err = fw_iso_resources_allocate(&ff->rx_resources,
 			amdtp_stream_get_max_payload(&ff->rx_stream),
@@ -136,61 +175,20 @@ static int keep_resources(struct snd_ff *ff, unsigned int rate)
 
 static int latter_begin_session(struct snd_ff *ff, unsigned int rate)
 {
-	static const struct {
-		unsigned int stf;
-		unsigned int code;
-		unsigned int flag;
-	} *entry, rate_table[] = {
-		{ 32000,  0x00, 0x92, },
-		{ 44100,  0x02, 0x92, },
-		{ 48000,  0x04, 0x92, },
-		{ 64000,  0x08, 0x8e, },
-		{ 88200,  0x0a, 0x8e, },
-		{ 96000,  0x0c, 0x8e, },
-		{ 128000, 0x10, 0x8c, },
-		{ 176400, 0x12, 0x8c, },
-		{ 192000, 0x14, 0x8c, },
-	};
+	unsigned int flag;
 	u32 data;
 	__le32 reg;
-	unsigned int count;
-	int i;
 	int err;
 
-	for (i = 0; i < ARRAY_SIZE(rate_table); ++i) {
-		entry = rate_table + i;
-		if (entry->stf == rate)
-			break;
-	}
-	if (i == ARRAY_SIZE(rate_table))
+	if (rate >= 32000 && rate <= 48000)
+		flag = 0x92;
+	else if (rate >= 64000 && rate <= 96000)
+		flag = 0x8e;
+	else if (rate >= 128000 && rate <= 192000)
+		flag = 0x8c;
+	else
 		return -EINVAL;
 
-	reg = cpu_to_le32(entry->code);
-	err = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
-				 LATTER_STF, &reg, sizeof(reg), 0);
-	if (err < 0)
-		return err;
-
-	// Confirm to shift transmission clock.
-	count = 0;
-	while (count++ < 10) {
-		unsigned int curr_rate;
-		enum snd_ff_clock_src src;
-
-		err = latter_get_clock(ff, &curr_rate, &src);
-		if (err < 0)
-			return err;
-
-		if (curr_rate == rate)
-			break;
-	}
-	if (count == 10)
-		return -ETIMEDOUT;
-
-	err = keep_resources(ff, rate);
-	if (err < 0)
-		return err;
-
 	data = (ff->tx_resources.channel << 8) | ff->rx_resources.channel;
 	reg = cpu_to_le32(data);
 	err = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
@@ -200,7 +198,7 @@ static int latter_begin_session(struct snd_ff *ff, unsigned int rate)
 
 	// Always use the maximum number of data channels in data block of
 	// packet.
-	reg = cpu_to_le32(entry->flag);
+	reg = cpu_to_le32(flag);
 	return snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
 				  LATTER_ISOC_START, &reg, sizeof(reg), 0);
 }
@@ -424,6 +422,7 @@ const struct snd_ff_protocol snd_ff_protocol_latter = {
 	.fill_midi_msg		= latter_fill_midi_msg,
 	.get_clock		= latter_get_clock,
 	.switch_fetching_mode	= latter_switch_fetching_mode,
+	.allocate_resources	= latter_allocate_resources,
 	.begin_session		= latter_begin_session,
 	.finish_session		= latter_finish_session,
 	.dump_status		= latter_dump_status,

commit 6954158a16404e7091cea494cd0a435ca2f90388
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue May 28 16:24:23 2019 +0200

    ALSA: fireface: Use ULL suffixes for 64-bit constants
    
    With gcc 4.1:
    
        sound/firewire/fireface/ff-protocol-latter.c: In function ‘latter_switch_fetching_mode’:
        sound/firewire/fireface/ff-protocol-latter.c:97: warning: integer constant is too large for ‘long’ type
        sound/firewire/fireface/ff-protocol-latter.c: In function ‘latter_begin_session’:
        sound/firewire/fireface/ff-protocol-latter.c:170: warning: integer constant is too large for ‘long’ type
        sound/firewire/fireface/ff-protocol-latter.c:197: warning: integer constant is too large for ‘long’ type
        sound/firewire/fireface/ff-protocol-latter.c:205: warning: integer constant is too large for ‘long’ type
        sound/firewire/fireface/ff-protocol-latter.c: In function ‘latter_finish_session’:
        sound/firewire/fireface/ff-protocol-latter.c:214: warning: integer constant is too large for ‘long’ type
    
    Fix this by adding the missing "ULL" suffixes.
    Add the same suffix to the last constant, to maintain consistency.
    
    Fixes: fd1cc9de64c2ca6c ("ALSA: fireface: add support for Fireface UCX")
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index c8236ff89b7f..b30d02d359b1 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -9,11 +9,11 @@
 
 #include "ff.h"
 
-#define LATTER_STF		0xffff00000004
-#define LATTER_ISOC_CHANNELS	0xffff00000008
-#define LATTER_ISOC_START	0xffff0000000c
-#define LATTER_FETCH_MODE	0xffff00000010
-#define LATTER_SYNC_STATUS	0x0000801c0000
+#define LATTER_STF		0xffff00000004ULL
+#define LATTER_ISOC_CHANNELS	0xffff00000008ULL
+#define LATTER_ISOC_START	0xffff0000000cULL
+#define LATTER_FETCH_MODE	0xffff00000010ULL
+#define LATTER_SYNC_STATUS	0x0000801c0000ULL
 
 static int parse_clock_bits(u32 data, unsigned int *rate,
 			    enum snd_ff_clock_src *src)

commit 2dee43ec3f31de39dc74e76e6ed65d976f486df0
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jan 25 15:44:18 2019 +0300

    ALSA: fireface: Off by one in latter_handle_midi_msg()
    
    The > should be >= or otherwise we potentially read one element beyond
    the end of the ff->tx_midi_substreams[] array.
    
    Fixes: 73f5537fb209 ("ALSA: fireface: support tx MIDI functionality of Fireface UCX")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index 0fbc1950327f..c8236ff89b7f 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -293,7 +293,7 @@ static void latter_handle_midi_msg(struct snd_ff *ff, unsigned int offset,
 	struct snd_rawmidi_substream *substream;
 	unsigned int len;
 
-	if (index > ff->spec->midi_in_ports)
+	if (index >= ff->spec->midi_in_ports)
 		return;
 
 	switch (data & 0x0000000f) {

commit d8002539ec7b8bc793a212b79db4a796ce9bce9c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Jan 24 18:32:03 2019 +0900

    ALSA: fireface: comment cleanup about destination address of async transactions for MIDI messages
    
    In Fireface series, registration of higher 4 bytes of destination
    address for asynchronous transaction of MIDI messages is done by
    a write transaction to model-specific register.
    
    On the other hand, registration of lower 4 bytes of the address is
    selectable from 4 options. A register for this registration includes
    the other purpose options such as input attenuation. Thus this
    driver expects userspace applications to configure the register.
    
    Actual behaviour for the asynchronous transaction is different
    depending on protocols. In former protocol, destination offset
    of each transaction is the same as the registered address even if
    it is block request. In latter models, destination offset of each
    transaction is the offset of previous transaction plus 4 byte
    and the transaction is quadlet request.
    
    This commit cleanups comments about the above mechanism.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index 817af4447349..0fbc1950327f 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -266,6 +266,24 @@ static void latter_dump_status(struct snd_ff *ff, struct snd_info_buffer *buffer
 
 // NOTE: transactions are transferred within 0x00-0x7f in allocated range of
 // address. This seems to be for check of discontinuity in receiver side.
+//
+// Like Fireface 400, drivers can select one of 4 options for lower 4 bytes of
+// destination address by bit flags in quadlet register (little endian) at
+// 0x'ffff'0000'0014:
+//
+// bit flags: offset of destination address
+// - 0x00002000: 0x'....'....'0000'0000
+// - 0x00004000: 0x'....'....'0000'0080
+// - 0x00008000: 0x'....'....'0000'0100
+// - 0x00010000: 0x'....'....'0000'0180
+//
+// Drivers can suppress the device to transfer asynchronous transactions by
+// clear these bit flags.
+//
+// Actually, the register is write-only and includes the other settings such as
+// input attenuation. This driver allocates for the first option
+// (0x'....'....'0000'0000) and expects userspace application to configure the
+// register for it.
 static void latter_handle_midi_msg(struct snd_ff *ff, unsigned int offset,
 				   __le32 *buf, size_t length)
 {

commit f0f9f497d44e2f696b4e16c41f3eaa13a009f22d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jan 22 22:17:05 2019 +0900

    ALSA: fireface: support rx MIDI functionality for Fireface UCX
    
    In latter model of Fireface series, asynchronous transaction includes
    a prefix byte to indicate the way to decode included MIDI bytes.
    
    Upper 4 bits of the prefix byte indicates port number, and the rest 4
    bits indicate the way to decode rest of bytes for MIDI messages.
    
    Basically the rest bits indicates the number of bytes for MIDI message.
    However, if the last byte of each MIDi message is included, the rest
    bits are 0xf. For example:
    
    message: f0 00 00 66 14 20 00 00 f7
    offset: content (big endian, port 0)
     '0030: 0x02f00000
     '0030: 0x03006614
     '0030: 0x03200000
     '0030: 0x0ff70000
    
    This commit supports encoding scheme for the above and allows
    applications to transfer MIDI messages via ALSA rawmidi interface.
    An unused member (running_status) is reused to keep state of
    transmission of system exclusive messages.
    
    For your information, this is a dump of config rom.
    
    $ sudo ./hinawa-config-rom-printer /dev/fw1
    { 'bus-info': { 'bmc': False,
                    'chip_ID': 13225063715,
                    'cmc': False,
                    'cyc_clk_acc': 0,
                    'imc': False,
                    'isc': True,
                    'max_rec': 512,
                    'name': '1394',
                    'node_vendor_ID': 2613},
      'root-directory': [ [ 'NODE_CAPABILITIES',
                            { 'addressing': {'64': True, 'fix': True, 'prv': False},
                              'misc': {'int': False, 'ms': False, 'spt': True},
                              'state': { 'atn': False,
                                         'ded': False,
                                         'drq': True,
                                         'elo': False,
                                         'init': False,
                                         'lst': True,
                                         'off': False},
                              'testing': {'bas': False, 'ext': False}}],
                          ['VENDOR', 2613],
                          ['DESCRIPTOR', 'RME!'],
                          ['EUI_64', 2873037108442403],
                          [ 'UNIT',
                            [ ['SPECIFIER_ID', 2613],
                              ['VERSION', 4],
                              ['MODEL', 1054720],
                              ['DESCRIPTOR', 'Fireface UCX']]]]}
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index a812ab6feb58..817af4447349 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -306,8 +306,104 @@ static void latter_handle_midi_msg(struct snd_ff *ff, unsigned int offset,
 		snd_rawmidi_receive(substream, byte, len);
 }
 
+/*
+ * When return minus value, given argument is not MIDI status.
+ * When return 0, given argument is a beginning of system exclusive.
+ * When return the others, given argument is MIDI data.
+ */
+static inline int calculate_message_bytes(u8 status)
+{
+	switch (status) {
+	case 0xf6:	/* Tune request. */
+	case 0xf8:	/* Timing clock. */
+	case 0xfa:	/* Start. */
+	case 0xfb:	/* Continue. */
+	case 0xfc:	/* Stop. */
+	case 0xfe:	/* Active sensing. */
+	case 0xff:	/* System reset. */
+		return 1;
+	case 0xf1:	/* MIDI time code quarter frame. */
+	case 0xf3:	/* Song select. */
+		return 2;
+	case 0xf2:	/* Song position pointer. */
+		return 3;
+	case 0xf0:	/* Exclusive. */
+		return 0;
+	case 0xf7:	/* End of exclusive. */
+		break;
+	case 0xf4:	/* Undefined. */
+	case 0xf5:	/* Undefined. */
+	case 0xf9:	/* Undefined. */
+	case 0xfd:	/* Undefined. */
+		break;
+	default:
+		switch (status & 0xf0) {
+		case 0x80:	/* Note on. */
+		case 0x90:	/* Note off. */
+		case 0xa0:	/* Polyphonic key pressure. */
+		case 0xb0:	/* Control change and Mode change. */
+		case 0xe0:	/* Pitch bend change. */
+			return 3;
+		case 0xc0:	/* Program change. */
+		case 0xd0:	/* Channel pressure. */
+			return 2;
+		default:
+		break;
+		}
+	break;
+	}
+
+	return -EINVAL;
+}
+
+static int latter_fill_midi_msg(struct snd_ff *ff,
+				struct snd_rawmidi_substream *substream,
+				unsigned int port)
+{
+	u32 data = {0};
+	u8 *buf = (u8 *)&data;
+	int consumed;
+
+	buf[0] = port << 4;
+	consumed = snd_rawmidi_transmit_peek(substream, buf + 1, 3);
+	if (consumed <= 0)
+		return consumed;
+
+	if (!ff->on_sysex[port]) {
+		if (buf[1] != 0xf0) {
+			if (consumed < calculate_message_bytes(buf[1]))
+				return 0;
+		} else {
+			// The beginning of exclusives.
+			ff->on_sysex[port] = true;
+		}
+
+		buf[0] |= consumed;
+	} else {
+		if (buf[1] != 0xf7) {
+			if (buf[2] == 0xf7 || buf[3] == 0xf7) {
+				// Transfer end code at next time.
+				consumed -= 1;
+			}
+
+			buf[0] |= consumed;
+		} else {
+			// The end of exclusives.
+			ff->on_sysex[port] = false;
+			consumed = 1;
+			buf[0] |= 0x0f;
+		}
+	}
+
+	ff->msg_buf[port][0] = cpu_to_le32(data);
+	ff->rx_bytes[port] = consumed;
+
+	return 1;
+}
+
 const struct snd_ff_protocol snd_ff_protocol_latter = {
 	.handle_midi_msg	= latter_handle_midi_msg,
+	.fill_midi_msg		= latter_fill_midi_msg,
 	.get_clock		= latter_get_clock,
 	.switch_fetching_mode	= latter_switch_fetching_mode,
 	.begin_session		= latter_begin_session,

commit 73f5537fb209e8dcd503c9ce140baa7e892fb65e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jan 22 22:17:02 2019 +0900

    ALSA: fireface: support tx MIDI functionality of Fireface UCX
    
    Fireface UCX transfers asynchronous transactions for MIDI messages.
    One transaction includes quadlet data therefore it can transfer 3
    message bytes as maximum. Base address of the destination is
    configured by two settings; a register for higher 8 byte of the
    address, and a bitflag to option register indicates lower 8byte.
    
    The register for higher address is 0x'ffff'0000'0034. Unfortunately,
    firmware v24 includes a bug to ignore registered value for the
    destination address and transfers to 0x0001xxxxxxxx always. This
    driver doesn't work well if the bug exists, therefore users should
    install the latest firmware (v27).
    
    The bitflag is a part of value to be written to option register
    (0x'ffff'0000'0014).
    
    lower addr:  bitflag (little endian)
     '0000'0000: 0x00002000
     '0000'0080: 0x00004000
     '0000'0100: 0x00008000
     '0000'0180: 0x00010000
    
    This register includes more options but they are not relevant to
    packet streaming or MIDI functionality. This driver don't touch it.
    
    Furthermore, the transaction is sent to address offset incremented
    by 4 byte to the offset in previous time. When it reaches base address
    plus 0x7c, next offset is the base address.
    
    Content of the transaction includes a prefix byte. Upper 4 bits of
    the byte indicates port number, and the rest 4 bits indicate the way
    to decode rest of bytes for MIDI message.
    
    Except for system exclusive messages, the rest bits are the same as
    status bits of the message without channel bits. For system exclusive
    messages, the rest bits are encoded according to included message bytes.
    For example:
    
    message: f0 7e 7f 09 01 f7
    offset: content (little endian, port 0)
     '0000: 0x04f07e7f
     '0004: 0x070901f7
    
    message: f0 00 00 66 14 20 00 00 00 f7
    offset: content (little endian, port 1)
     '0014: 0x14f00000
     '0018: 0x14661420
     '001c: 0x14000000
     '0020: 0x15f70000
    
    message: f0 00 00 66 14 20 00 00 f7
    offset: content (little endian, port 0)
     '0078: 0x04f00000
     '007c: 0x04661420
     '0000: 0x070000f7
    
    This commit supports decoding scheme for the above and allows
    applications to receive MIDI messages via ALSA rawmidi interface.
    The lower 8 bytes of destination address is fixed to 0x'0000'0000,
    thus this driver expects userspace applications to configure option
    register with bitflag 0x00002000 in advance.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
index 64767ba439db..a812ab6feb58 100644
--- a/sound/firewire/fireface/ff-protocol-latter.c
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -264,7 +264,50 @@ static void latter_dump_status(struct snd_ff *ff, struct snd_info_buffer *buffer
 	snd_iprintf(buffer, "Referred clock: %s %d\n", label, rate);
 }
 
+// NOTE: transactions are transferred within 0x00-0x7f in allocated range of
+// address. This seems to be for check of discontinuity in receiver side.
+static void latter_handle_midi_msg(struct snd_ff *ff, unsigned int offset,
+				   __le32 *buf, size_t length)
+{
+	u32 data = le32_to_cpu(*buf);
+	unsigned int index = (data & 0x000000f0) >> 4;
+	u8 byte[3];
+	struct snd_rawmidi_substream *substream;
+	unsigned int len;
+
+	if (index > ff->spec->midi_in_ports)
+		return;
+
+	switch (data & 0x0000000f) {
+	case 0x00000008:
+	case 0x00000009:
+	case 0x0000000a:
+	case 0x0000000b:
+	case 0x0000000e:
+		len = 3;
+		break;
+	case 0x0000000c:
+	case 0x0000000d:
+		len = 2;
+		break;
+	default:
+		len = data & 0x00000003;
+		if (len == 0)
+			len = 3;
+		break;
+	}
+
+	byte[0] = (data & 0x0000ff00) >> 8;
+	byte[1] = (data & 0x00ff0000) >> 16;
+	byte[2] = (data & 0xff000000) >> 24;
+
+	substream = READ_ONCE(ff->tx_midi_substreams[index]);
+	if (substream)
+		snd_rawmidi_receive(substream, byte, len);
+}
+
 const struct snd_ff_protocol snd_ff_protocol_latter = {
+	.handle_midi_msg	= latter_handle_midi_msg,
 	.get_clock		= latter_get_clock,
 	.switch_fetching_mode	= latter_switch_fetching_mode,
 	.begin_session		= latter_begin_session,

commit fd1cc9de64c2ca6c2b5b9061421580a22bfac023
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jan 20 17:25:53 2019 +0900

    ALSA: fireface: add support for Fireface UCX
    
    Fireface UFX was shipped by RME GmbH in 2012. This model supports later
    protocol for management of isochronous communication and synchronization
    of sampling transmission frequency.
    
    This commit adds support for the model. At present, it's not clear how
    to encode MIDI messages and decide destination address for asynchronous
    transaction, thus this commit adds support for isochronous communication
    for PCM frames only.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff-protocol-latter.c b/sound/firewire/fireface/ff-protocol-latter.c
new file mode 100644
index 000000000000..64767ba439db
--- /dev/null
+++ b/sound/firewire/fireface/ff-protocol-latter.c
@@ -0,0 +1,273 @@
+// SPDX-License-Identifier: GPL-2.0
+// ff-protocol-latter - a part of driver for RME Fireface series
+//
+// Copyright (c) 2019 Takashi Sakamoto
+//
+// Licensed under the terms of the GNU General Public License, version 2.
+
+#include <linux/delay.h>
+
+#include "ff.h"
+
+#define LATTER_STF		0xffff00000004
+#define LATTER_ISOC_CHANNELS	0xffff00000008
+#define LATTER_ISOC_START	0xffff0000000c
+#define LATTER_FETCH_MODE	0xffff00000010
+#define LATTER_SYNC_STATUS	0x0000801c0000
+
+static int parse_clock_bits(u32 data, unsigned int *rate,
+			    enum snd_ff_clock_src *src)
+{
+	static const struct {
+		unsigned int rate;
+		u32 flag;
+	} *rate_entry, rate_entries[] = {
+		{ 32000,	0x00000000, },
+		{ 44100,	0x01000000, },
+		{ 48000,	0x02000000, },
+		{ 64000,	0x04000000, },
+		{ 88200,	0x05000000, },
+		{ 96000,	0x06000000, },
+		{ 128000,	0x08000000, },
+		{ 176400,	0x09000000, },
+		{ 192000,	0x0a000000, },
+	};
+	static const struct {
+		enum snd_ff_clock_src src;
+		u32 flag;
+	} *clk_entry, clk_entries[] = {
+		{ SND_FF_CLOCK_SRC_SPDIF,	0x00000200, },
+		{ SND_FF_CLOCK_SRC_ADAT1,	0x00000400, },
+		{ SND_FF_CLOCK_SRC_WORD,	0x00000600, },
+		{ SND_FF_CLOCK_SRC_INTERNAL,	0x00000e00, },
+	};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rate_entries); ++i) {
+		rate_entry = rate_entries + i;
+		if ((data & 0x0f000000) == rate_entry->flag) {
+			*rate = rate_entry->rate;
+			break;
+		}
+	}
+	if (i == ARRAY_SIZE(rate_entries))
+		return -EIO;
+
+	for (i = 0; i < ARRAY_SIZE(clk_entries); ++i) {
+		clk_entry = clk_entries + i;
+		if ((data & 0x000e00) == clk_entry->flag) {
+			*src = clk_entry->src;
+			break;
+		}
+	}
+	if (i == ARRAY_SIZE(clk_entries))
+		return -EIO;
+
+	return 0;
+}
+
+static int latter_get_clock(struct snd_ff *ff, unsigned int *rate,
+			   enum snd_ff_clock_src *src)
+{
+	__le32 reg;
+	u32 data;
+	int err;
+
+	err = snd_fw_transaction(ff->unit, TCODE_READ_QUADLET_REQUEST,
+				 LATTER_SYNC_STATUS, &reg, sizeof(reg), 0);
+	if (err < 0)
+		return err;
+	data = le32_to_cpu(reg);
+
+	return parse_clock_bits(data, rate, src);
+}
+
+static int latter_switch_fetching_mode(struct snd_ff *ff, bool enable)
+{
+	u32 data;
+	__le32 reg;
+
+	if (enable)
+		data = 0x00000000;
+	else
+		data = 0xffffffff;
+	reg = cpu_to_le32(data);
+
+	return snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
+				  LATTER_FETCH_MODE, &reg, sizeof(reg), 0);
+}
+
+static int keep_resources(struct snd_ff *ff, unsigned int rate)
+{
+	enum snd_ff_stream_mode mode;
+	int i;
+	int err;
+
+	// Check whether the given value is supported or not.
+	for (i = 0; i < CIP_SFC_COUNT; i++) {
+		if (amdtp_rate_table[i] == rate)
+			break;
+	}
+	if (i >= CIP_SFC_COUNT)
+		return -EINVAL;
+
+	err = snd_ff_stream_get_multiplier_mode(i, &mode);
+	if (err < 0)
+		return err;
+
+	/* Keep resources for in-stream. */
+	ff->tx_resources.channels_mask = 0x00000000000000ffuLL;
+	err = fw_iso_resources_allocate(&ff->tx_resources,
+			amdtp_stream_get_max_payload(&ff->tx_stream),
+			fw_parent_device(ff->unit)->max_speed);
+	if (err < 0)
+		return err;
+
+	/* Keep resources for out-stream. */
+	ff->rx_resources.channels_mask = 0x00000000000000ffuLL;
+	err = fw_iso_resources_allocate(&ff->rx_resources,
+			amdtp_stream_get_max_payload(&ff->rx_stream),
+			fw_parent_device(ff->unit)->max_speed);
+	if (err < 0)
+		fw_iso_resources_free(&ff->tx_resources);
+
+	return err;
+}
+
+static int latter_begin_session(struct snd_ff *ff, unsigned int rate)
+{
+	static const struct {
+		unsigned int stf;
+		unsigned int code;
+		unsigned int flag;
+	} *entry, rate_table[] = {
+		{ 32000,  0x00, 0x92, },
+		{ 44100,  0x02, 0x92, },
+		{ 48000,  0x04, 0x92, },
+		{ 64000,  0x08, 0x8e, },
+		{ 88200,  0x0a, 0x8e, },
+		{ 96000,  0x0c, 0x8e, },
+		{ 128000, 0x10, 0x8c, },
+		{ 176400, 0x12, 0x8c, },
+		{ 192000, 0x14, 0x8c, },
+	};
+	u32 data;
+	__le32 reg;
+	unsigned int count;
+	int i;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(rate_table); ++i) {
+		entry = rate_table + i;
+		if (entry->stf == rate)
+			break;
+	}
+	if (i == ARRAY_SIZE(rate_table))
+		return -EINVAL;
+
+	reg = cpu_to_le32(entry->code);
+	err = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
+				 LATTER_STF, &reg, sizeof(reg), 0);
+	if (err < 0)
+		return err;
+
+	// Confirm to shift transmission clock.
+	count = 0;
+	while (count++ < 10) {
+		unsigned int curr_rate;
+		enum snd_ff_clock_src src;
+
+		err = latter_get_clock(ff, &curr_rate, &src);
+		if (err < 0)
+			return err;
+
+		if (curr_rate == rate)
+			break;
+	}
+	if (count == 10)
+		return -ETIMEDOUT;
+
+	err = keep_resources(ff, rate);
+	if (err < 0)
+		return err;
+
+	data = (ff->tx_resources.channel << 8) | ff->rx_resources.channel;
+	reg = cpu_to_le32(data);
+	err = snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
+				 LATTER_ISOC_CHANNELS, &reg, sizeof(reg), 0);
+	if (err < 0)
+		return err;
+
+	// Always use the maximum number of data channels in data block of
+	// packet.
+	reg = cpu_to_le32(entry->flag);
+	return snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
+				  LATTER_ISOC_START, &reg, sizeof(reg), 0);
+}
+
+static void latter_finish_session(struct snd_ff *ff)
+{
+	__le32 reg;
+
+	reg = cpu_to_le32(0x00000000);
+	snd_fw_transaction(ff->unit, TCODE_WRITE_QUADLET_REQUEST,
+			   LATTER_ISOC_START, &reg, sizeof(reg), 0);
+}
+
+static void latter_dump_status(struct snd_ff *ff, struct snd_info_buffer *buffer)
+{
+	static const struct {
+		char *const label;
+		u32 locked_mask;
+		u32 synced_mask;
+	} *clk_entry, clk_entries[] = {
+		{ "S/PDIF",	0x00000001, 0x00000010, },
+		{ "ADAT",	0x00000002, 0x00000020, },
+		{ "WDClk",	0x00000004, 0x00000040, },
+	};
+	__le32 reg;
+	u32 data;
+	unsigned int rate;
+	enum snd_ff_clock_src src;
+	const char *label;
+	int i;
+	int err;
+
+	err = snd_fw_transaction(ff->unit, TCODE_READ_QUADLET_REQUEST,
+				 LATTER_SYNC_STATUS, &reg, sizeof(reg), 0);
+	if (err < 0)
+		return;
+	data = le32_to_cpu(reg);
+
+	snd_iprintf(buffer, "External source detection:\n");
+
+	for (i = 0; i < ARRAY_SIZE(clk_entries); ++i) {
+		clk_entry = clk_entries + i;
+		snd_iprintf(buffer, "%s: ", clk_entry->label);
+		if (data & clk_entry->locked_mask) {
+			if (data & clk_entry->synced_mask)
+				snd_iprintf(buffer, "sync\n");
+			else
+				snd_iprintf(buffer, "lock\n");
+		} else {
+			snd_iprintf(buffer, "none\n");
+		}
+	}
+
+	err = parse_clock_bits(data, &rate, &src);
+	if (err < 0)
+		return;
+	label = snd_ff_proc_get_clk_label(src);
+	if (!label)
+		return;
+
+	snd_iprintf(buffer, "Referred clock: %s %d\n", label, rate);
+}
+
+const struct snd_ff_protocol snd_ff_protocol_latter = {
+	.get_clock		= latter_get_clock,
+	.switch_fetching_mode	= latter_switch_fetching_mode,
+	.begin_session		= latter_begin_session,
+	.finish_session		= latter_finish_session,
+	.dump_status		= latter_dump_status,
+};
