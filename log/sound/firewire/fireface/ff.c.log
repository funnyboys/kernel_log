commit 1f65e6683267dde67a71c6bfcf71de35916be11a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun May 10 16:43:01 2020 +0900

    ALSA: fireface: add support for RME Fireface UFX (untested)
    
    Fireface UFX was shipped by RME GmbH in 2010, and now discontinued.
    Although this model has some enhanced feature which Fireface 802
    doesn't have (e.g. on-board USB mass storage device class, configuration
    interface with color display), the functionality relevant to
    packet communication on IEEE 1394 bus seems to be the same as
    Fireface 802 (e.g. available number of channels for PCM frame in
    each sampling transfer frequency).
    
    With the assumption, this commit adds support for Fireface UFX. In ALSA
    fireface driver, these two models are handled as the same one.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200510074301.116224-7-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index e4140116f3cc..bc39269415d2 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -19,6 +19,7 @@ static void name_card(struct snd_ff *ff)
 	const char *const names[] = {
 		[SND_FF_UNIT_VERSION_FF800]	= "Fireface800",
 		[SND_FF_UNIT_VERSION_FF400]	= "Fireface400",
+		[SND_FF_UNIT_VERSION_UFX]	= "FirefaceUFX",
 		[SND_FF_UNIT_VERSION_UCX]	= "FirefaceUCX",
 		[SND_FF_UNIT_VERSION_802]	= "Fireface802",
 	};
@@ -187,7 +188,7 @@ static const struct snd_ff_spec spec_ucx = {
 	.midi_rx_addrs = {0xffff00000030ull, 0xffff00000030ull},
 };
 
-static const struct snd_ff_spec spec_802 = {
+static const struct snd_ff_spec spec_ufx_802 = {
 	.pcm_capture_channels = {30, 22, 14},
 	.pcm_playback_channels = {30, 22, 14},
 	.midi_in_ports = 1,
@@ -223,6 +224,18 @@ static const struct ieee1394_device_id snd_ff_id_table[] = {
 		.model_id	= 0x101800,
 		.driver_data	= (kernel_ulong_t)&spec_ff400,
 	},
+	// Fireface UFX.
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_SPECIFIER_ID |
+				  IEEE1394_MATCH_VERSION |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= OUI_RME,
+		.specifier_id	= OUI_RME,
+		.version	= SND_FF_UNIT_VERSION_UFX,
+		.model_id	= 0x101800,
+		.driver_data	= (kernel_ulong_t)&spec_ufx_802,
+	},
 	// Fireface UCX.
 	{
 		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
@@ -245,7 +258,7 @@ static const struct ieee1394_device_id snd_ff_id_table[] = {
 		.specifier_id	= OUI_RME,
 		.version	= SND_FF_UNIT_VERSION_802,
 		.model_id	= 0x101800,
-		.driver_data	= (kernel_ulong_t)&spec_802,
+		.driver_data	= (kernel_ulong_t)&spec_ufx_802,
 	},
 	{}
 };

commit 062bb452b078ba481d856e1aca176e16b8b1466d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun May 10 16:43:00 2020 +0900

    ALSA: fireface: add support for RME FireFace 802
    
    Fireface 802 was shipped by RME GmbH in 2014. This model supports later
    protocol for management of isochronous communication and synchronization
    of sampling transmission frequency.
    
    This model consists of below ICs:
     * TI TSB41AB2
     * Xilinx Spartan-6 FPGA XC6SLX16
     * TI TMS320 C6747
     * SMSC USB3250
    
    Especially, this model just supports IEEE 1394a, against its name which
    evokes Fireface 800.
    
    This commit adds support for Fireface 802 (tested). Userspace applications
    can transfer PCM frames and MIDI messages via ALSA PCM/Rawmidi interface.
    I note that 4 channels for ADAt1 and ADAT2 are disabled at higher sampling
    transfer frequency since isochronous resources reservation fails due to
    bandwidth limitation of IEEE 1394a.
    
    The value read from LATTER_SYNC_STATUS register is slightly different
    from the one of Fireface UCX. The higher 4 bits and lower 4 bits are
    swapped within the same byte.
    
    Without any assist of userspace application, transmitted MIDI messages
    from the device are not going to be processed. For detail, please refer
    to my comment in code of latter protocol.
    
    $ python crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  0404ffff  bus_info_length 4, crc_length 4, crc 65535 (should be 26805)
    404  31333934  bus_name "1394"
    408  20008000  irmc 0, cmc 0, isc 1, bmc 0, cyc_clk_acc 0, max_rec 8 (512)
    40c  000a3504  company_id 000a35     |
    410  38077423  device_id 0438077423  | EUI-64 000a350438077423
    
                   root directory
                   -----------------------------------------------------------------
    414  0005ffff  directory_length 5, crc 65535 (should be 9514)
    418  0c0083c0  node capabilities per IEEE 1394
    41c  03000a35  vendor
    420  8100000b  --> descriptor leaf at 44c
    424  8d000007  --> eui-64 leaf at 440
    428  d1000001  --> unit directory at 42c
    
                   unit directory at 42c
                   -----------------------------------------------------------------
    42c  0004ffff  directory_length 4, crc 65535 (should be 45134)
    430  12000a35  specifier id
    434  13000005  version
    438  17101800  model
    43c  81000008  --> descriptor leaf at 45c
    
                   eui-64 leaf at 440
                   -----------------------------------------------------------------
    440  0002ffff  leaf_length 2, crc 65535 (should be 60131)
    444  000a3504  company_id 000a35     |
    448  38077423  device_id 0438077423  | EUI-64 000a350438077423
    
                   descriptor leaf at 44c
                   -----------------------------------------------------------------
    44c  0003ffff  leaf_length 3, crc 65535 (should be 469)
    450  00000000  textual descriptor
    454  00000000  minimal ASCII
    458  524d4521  "RME!"
    
                   descriptor leaf at 45c
                   -----------------------------------------------------------------
    45c  0005ffff  leaf_length 5, crc 65535 (should be 10561)
    460  00000000  textual descriptor
    464  00000000  minimal ASCII
    468  46697265  "Fire"
    46c  66616365  "face"
    470  20383032  " 802"
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200510074301.116224-6-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index dd3cd25f2e3b..e4140116f3cc 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -20,6 +20,7 @@ static void name_card(struct snd_ff *ff)
 		[SND_FF_UNIT_VERSION_FF800]	= "Fireface800",
 		[SND_FF_UNIT_VERSION_FF400]	= "Fireface400",
 		[SND_FF_UNIT_VERSION_UCX]	= "FirefaceUCX",
+		[SND_FF_UNIT_VERSION_802]	= "Fireface802",
 	};
 	const char *name;
 
@@ -186,6 +187,17 @@ static const struct snd_ff_spec spec_ucx = {
 	.midi_rx_addrs = {0xffff00000030ull, 0xffff00000030ull},
 };
 
+static const struct snd_ff_spec spec_802 = {
+	.pcm_capture_channels = {30, 22, 14},
+	.pcm_playback_channels = {30, 22, 14},
+	.midi_in_ports = 1,
+	.midi_out_ports = 1,
+	.protocol = &snd_ff_protocol_latter,
+	.midi_high_addr = 0xffff00000034ull,
+	.midi_addr_range = 0x80,
+	.midi_rx_addrs = {0xffff00000030ull, 0xffff00000030ull},
+};
+
 static const struct ieee1394_device_id snd_ff_id_table[] = {
 	/* Fireface 800 */
 	{
@@ -223,6 +235,18 @@ static const struct ieee1394_device_id snd_ff_id_table[] = {
 		.model_id	= 0x101800,
 		.driver_data	= (kernel_ulong_t)&spec_ucx,
 	},
+	// Fireface 802.
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_SPECIFIER_ID |
+				  IEEE1394_MATCH_VERSION |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= OUI_RME,
+		.specifier_id	= OUI_RME,
+		.version	= SND_FF_UNIT_VERSION_802,
+		.model_id	= 0x101800,
+		.driver_data	= (kernel_ulong_t)&spec_802,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(ieee1394, snd_ff_id_table);

commit 782222bab83a31f70c427b59587ada963d6c59c3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun May 10 16:42:59 2020 +0900

    ALSA: fireface: code refactoring to decide name of sound card
    
    This commit uses enumeration constants as index of table for the
    list of name of sound card.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200510074301.116224-5-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index b295e40a425d..dd3cd25f2e3b 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -16,12 +16,20 @@ MODULE_LICENSE("GPL v2");
 static void name_card(struct snd_ff *ff)
 {
 	struct fw_device *fw_dev = fw_parent_device(ff->unit);
+	const char *const names[] = {
+		[SND_FF_UNIT_VERSION_FF800]	= "Fireface800",
+		[SND_FF_UNIT_VERSION_FF400]	= "Fireface400",
+		[SND_FF_UNIT_VERSION_UCX]	= "FirefaceUCX",
+	};
+	const char *name;
+
+	name = names[ff->unit_version];
 
 	strcpy(ff->card->driver, "Fireface");
-	strcpy(ff->card->shortname, ff->spec->name);
-	strcpy(ff->card->mixername, ff->spec->name);
+	strcpy(ff->card->shortname, name);
+	strcpy(ff->card->mixername, name);
 	snprintf(ff->card->longname, sizeof(ff->card->longname),
-		 "RME %s, GUID %08x%08x at %s, S%d", ff->spec->name,
+		 "RME %s, GUID %08x%08x at %s, S%d", name,
 		 fw_dev->config_rom[3], fw_dev->config_rom[4],
 		 dev_name(&ff->unit->device), 100 << fw_dev->max_speed);
 }
@@ -101,6 +109,7 @@ static int snd_ff_probe(struct fw_unit *unit,
 	spin_lock_init(&ff->lock);
 	init_waitqueue_head(&ff->hwdep_wait);
 
+	ff->unit_version = entry->version;
 	ff->spec = (const struct snd_ff_spec *)entry->driver_data;
 
 	/* Register this sound card later. */
@@ -145,7 +154,6 @@ static void snd_ff_remove(struct fw_unit *unit)
 }
 
 static const struct snd_ff_spec spec_ff800 = {
-	.name = "Fireface800",
 	.pcm_capture_channels = {28, 20, 12},
 	.pcm_playback_channels = {28, 20, 12},
 	.midi_in_ports = 1,
@@ -157,7 +165,6 @@ static const struct snd_ff_spec spec_ff800 = {
 };
 
 static const struct snd_ff_spec spec_ff400 = {
-	.name = "Fireface400",
 	.pcm_capture_channels = {18, 14, 10},
 	.pcm_playback_channels = {18, 14, 10},
 	.midi_in_ports = 2,
@@ -169,7 +176,6 @@ static const struct snd_ff_spec spec_ff400 = {
 };
 
 static const struct snd_ff_spec spec_ucx = {
-	.name = "FirefaceUCX",
 	.pcm_capture_channels = {18, 14, 12},
 	.pcm_playback_channels = {18, 14, 12},
 	.midi_in_ports = 2,

commit c52f232e11077555cdd515f25376afa54ac36296
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun May 10 16:42:58 2020 +0900

    ALSA: fireface: code refactoring to add enumeration constants for model identification
    
    In RME fireface series, version field of unit directory in configuration
    ROM is used to distinguish each model. The value of field is known and
    it's better to use enumeration constants for code representation.
    
    This commit adds enumeration constants for model identification.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200510074301.116224-4-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index b62a4fd22407..b295e40a425d 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -189,7 +189,7 @@ static const struct ieee1394_device_id snd_ff_id_table[] = {
 				  IEEE1394_MATCH_MODEL_ID,
 		.vendor_id	= OUI_RME,
 		.specifier_id	= OUI_RME,
-		.version	= 0x000001,
+		.version	= SND_FF_UNIT_VERSION_FF800,
 		.model_id	= 0x101800,
 		.driver_data	= (kernel_ulong_t)&spec_ff800,
 	},
@@ -201,7 +201,7 @@ static const struct ieee1394_device_id snd_ff_id_table[] = {
 				  IEEE1394_MATCH_MODEL_ID,
 		.vendor_id	= OUI_RME,
 		.specifier_id	= OUI_RME,
-		.version	= 0x000002,
+		.version	= SND_FF_UNIT_VERSION_FF400,
 		.model_id	= 0x101800,
 		.driver_data	= (kernel_ulong_t)&spec_ff400,
 	},
@@ -213,7 +213,7 @@ static const struct ieee1394_device_id snd_ff_id_table[] = {
 				  IEEE1394_MATCH_MODEL_ID,
 		.vendor_id	= OUI_RME,
 		.specifier_id	= OUI_RME,
-		.version	= 0x000004,
+		.version	= SND_FF_UNIT_VERSION_UCX,
 		.model_id	= 0x101800,
 		.driver_data	= (kernel_ulong_t)&spec_ucx,
 	},

commit 9c0d16ac059148fc7647f5f9e90df6f34d3439f0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 6 22:52:29 2020 +0900

    ALSA: firewire: use KBUILD_MODNAME for struct driver.name instead of string
    
    KBUILD_MODNAME is available to name kernel modules according to its object
    name. This commit uses the macro instead of string for name field of
    struct driver since drivers in ALSA firewire stack have the same name of
    each object name.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200306135229.11659-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index f5a016560eb8..b62a4fd22407 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -224,7 +224,7 @@ MODULE_DEVICE_TABLE(ieee1394, snd_ff_id_table);
 static struct fw_driver ff_driver = {
 	.driver = {
 		.owner	= THIS_MODULE,
-		.name	= "snd-fireface",
+		.name	= KBUILD_MODNAME,
 		.bus	= &fw_bus_type,
 	},
 	.probe    = snd_ff_probe,

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index a9611157f4c8..f5a016560eb8 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * ff.c - a part of driver for RME Fireface series
  *
  * Copyright (c) 2015-2017 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "ff.h"

commit f0f9f497d44e2f696b4e16c41f3eaa13a009f22d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jan 22 22:17:05 2019 +0900

    ALSA: fireface: support rx MIDI functionality for Fireface UCX
    
    In latter model of Fireface series, asynchronous transaction includes
    a prefix byte to indicate the way to decode included MIDI bytes.
    
    Upper 4 bits of the prefix byte indicates port number, and the rest 4
    bits indicate the way to decode rest of bytes for MIDI messages.
    
    Basically the rest bits indicates the number of bytes for MIDI message.
    However, if the last byte of each MIDi message is included, the rest
    bits are 0xf. For example:
    
    message: f0 00 00 66 14 20 00 00 f7
    offset: content (big endian, port 0)
     '0030: 0x02f00000
     '0030: 0x03006614
     '0030: 0x03200000
     '0030: 0x0ff70000
    
    This commit supports encoding scheme for the above and allows
    applications to transfer MIDI messages via ALSA rawmidi interface.
    An unused member (running_status) is reused to keep state of
    transmission of system exclusive messages.
    
    For your information, this is a dump of config rom.
    
    $ sudo ./hinawa-config-rom-printer /dev/fw1
    { 'bus-info': { 'bmc': False,
                    'chip_ID': 13225063715,
                    'cmc': False,
                    'cyc_clk_acc': 0,
                    'imc': False,
                    'isc': True,
                    'max_rec': 512,
                    'name': '1394',
                    'node_vendor_ID': 2613},
      'root-directory': [ [ 'NODE_CAPABILITIES',
                            { 'addressing': {'64': True, 'fix': True, 'prv': False},
                              'misc': {'int': False, 'ms': False, 'spt': True},
                              'state': { 'atn': False,
                                         'ded': False,
                                         'drq': True,
                                         'elo': False,
                                         'init': False,
                                         'lst': True,
                                         'off': False},
                              'testing': {'bas': False, 'ext': False}}],
                          ['VENDOR', 2613],
                          ['DESCRIPTOR', 'RME!'],
                          ['EUI_64', 2873037108442403],
                          [ 'UNIT',
                            [ ['SPECIFIER_ID', 2613],
                              ['VERSION', 4],
                              ['MODEL', 1054720],
                              ['DESCRIPTOR', 'Fireface UCX']]]]}
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 675c6ab556eb..a9611157f4c8 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -174,6 +174,7 @@ static const struct snd_ff_spec spec_ucx = {
 	.pcm_capture_channels = {18, 14, 12},
 	.pcm_playback_channels = {18, 14, 12},
 	.midi_in_ports = 2,
+	.midi_out_ports = 2,
 	.protocol = &snd_ff_protocol_latter,
 	.midi_high_addr = 0xffff00000034ull,
 	.midi_addr_range = 0x80,

commit 481e09ac9a82644af697884cc522b76b4dd07e4d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jan 22 22:17:03 2019 +0900

    ALSA: fireface: add model-dependent parameter for address to receive async transaction for MIDI messages
    
    Between former and latter models, destination address to receive
    asynchronous transactions for MIDI messages is different.
    
    This commit adds model-dependent parameter for the addresses.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index a2a9fd82f27d..675c6ab556eb 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -154,6 +154,7 @@ static const struct snd_ff_spec spec_ff800 = {
 	.protocol = &snd_ff_protocol_ff800,
 	.midi_high_addr = 0x000200000320ull,
 	.midi_addr_range = 12,
+	.midi_rx_addrs = {0x000080180000ull, 0},
 };
 
 static const struct snd_ff_spec spec_ff400 = {
@@ -165,6 +166,7 @@ static const struct snd_ff_spec spec_ff400 = {
 	.protocol = &snd_ff_protocol_ff400,
 	.midi_high_addr = 0x0000801003f4ull,
 	.midi_addr_range = SND_FF_MAXIMIM_MIDI_QUADS * 4,
+	.midi_rx_addrs = {0x000080180000ull, 0x000080190000ull},
 };
 
 static const struct snd_ff_spec spec_ucx = {
@@ -175,6 +177,7 @@ static const struct snd_ff_spec spec_ucx = {
 	.protocol = &snd_ff_protocol_latter,
 	.midi_high_addr = 0xffff00000034ull,
 	.midi_addr_range = 0x80,
+	.midi_rx_addrs = {0xffff00000030ull, 0xffff00000030ull},
 };
 
 static const struct ieee1394_device_id snd_ff_id_table[] = {

commit 73f5537fb209e8dcd503c9ce140baa7e892fb65e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jan 22 22:17:02 2019 +0900

    ALSA: fireface: support tx MIDI functionality of Fireface UCX
    
    Fireface UCX transfers asynchronous transactions for MIDI messages.
    One transaction includes quadlet data therefore it can transfer 3
    message bytes as maximum. Base address of the destination is
    configured by two settings; a register for higher 8 byte of the
    address, and a bitflag to option register indicates lower 8byte.
    
    The register for higher address is 0x'ffff'0000'0034. Unfortunately,
    firmware v24 includes a bug to ignore registered value for the
    destination address and transfers to 0x0001xxxxxxxx always. This
    driver doesn't work well if the bug exists, therefore users should
    install the latest firmware (v27).
    
    The bitflag is a part of value to be written to option register
    (0x'ffff'0000'0014).
    
    lower addr:  bitflag (little endian)
     '0000'0000: 0x00002000
     '0000'0080: 0x00004000
     '0000'0100: 0x00008000
     '0000'0180: 0x00010000
    
    This register includes more options but they are not relevant to
    packet streaming or MIDI functionality. This driver don't touch it.
    
    Furthermore, the transaction is sent to address offset incremented
    by 4 byte to the offset in previous time. When it reaches base address
    plus 0x7c, next offset is the base address.
    
    Content of the transaction includes a prefix byte. Upper 4 bits of
    the byte indicates port number, and the rest 4 bits indicate the way
    to decode rest of bytes for MIDI message.
    
    Except for system exclusive messages, the rest bits are the same as
    status bits of the message without channel bits. For system exclusive
    messages, the rest bits are encoded according to included message bytes.
    For example:
    
    message: f0 7e 7f 09 01 f7
    offset: content (little endian, port 0)
     '0000: 0x04f07e7f
     '0004: 0x070901f7
    
    message: f0 00 00 66 14 20 00 00 00 f7
    offset: content (little endian, port 1)
     '0014: 0x14f00000
     '0018: 0x14661420
     '001c: 0x14000000
     '0020: 0x15f70000
    
    message: f0 00 00 66 14 20 00 00 f7
    offset: content (little endian, port 0)
     '0078: 0x04f00000
     '007c: 0x04661420
     '0000: 0x070000f7
    
    This commit supports decoding scheme for the above and allows
    applications to receive MIDI messages via ALSA rawmidi interface.
    The lower 8 bytes of destination address is fixed to 0x'0000'0000,
    thus this driver expects userspace applications to configure option
    register with bitflag 0x00002000 in advance.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index c09a4875aa86..a2a9fd82f27d 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -32,8 +32,7 @@ static void ff_card_free(struct snd_card *card)
 	struct snd_ff *ff = card->private_data;
 
 	snd_ff_stream_destroy_duplex(ff);
-	if (ff->spec->midi_high_addr > 0)
-		snd_ff_transaction_unregister(ff);
+	snd_ff_transaction_unregister(ff);
 }
 
 static void do_registration(struct work_struct *work)
@@ -51,11 +50,9 @@ static void do_registration(struct work_struct *work)
 	ff->card->private_free = ff_card_free;
 	ff->card->private_data = ff;
 
-	if (ff->spec->midi_high_addr > 0) {
-		err = snd_ff_transaction_register(ff);
-		if (err < 0)
-			goto error;
-	}
+	err = snd_ff_transaction_register(ff);
+	if (err < 0)
+		goto error;
 
 	name_card(ff);
 
@@ -65,11 +62,9 @@ static void do_registration(struct work_struct *work)
 
 	snd_ff_proc_init(ff);
 
-	if (ff->spec->midi_in_ports > 0 || ff->spec->midi_out_ports > 0) {
-		err = snd_ff_create_midi_devices(ff);
-		if (err < 0)
-			goto error;
-	}
+	err = snd_ff_create_midi_devices(ff);
+	if (err < 0)
+		goto error;
 
 	err = snd_ff_create_pcm_devices(ff);
 	if (err < 0)
@@ -124,8 +119,7 @@ static void snd_ff_update(struct fw_unit *unit)
 	if (!ff->registered)
 		snd_fw_schedule_registration(unit, &ff->dwork);
 
-	if (ff->spec->midi_high_addr > 0)
-		snd_ff_transaction_reregister(ff);
+	snd_ff_transaction_reregister(ff);
 
 	if (ff->registered)
 		snd_ff_stream_update_duplex(ff);
@@ -177,7 +171,10 @@ static const struct snd_ff_spec spec_ucx = {
 	.name = "FirefaceUCX",
 	.pcm_capture_channels = {18, 14, 12},
 	.pcm_playback_channels = {18, 14, 12},
+	.midi_in_ports = 2,
 	.protocol = &snd_ff_protocol_latter,
+	.midi_high_addr = 0xffff00000034ull,
+	.midi_addr_range = 0x80,
 };
 
 static const struct ieee1394_device_id snd_ff_id_table[] = {

commit 900896771a2f7ba126194911c58dc095fc0dd3d7
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Jan 22 22:17:01 2019 +0900

    ALSA: fireface: add model-dependent parameter for address range to receive async transaction
    
    In Fireface series, drivers can register destination address for
    asynchronous transaction which transfers MIDI messages from device.
    
    In former models, all of the transactions arrive at the registered
    address without any offset. In latter models, each of the transaction
    arrives at the registered address with sequential offset within 0x00
    to 0x7f. This seems to be for discontinuity detection.
    
    This commit adds model-dependent member for the address range.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index fd9c980e3cf4..c09a4875aa86 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -159,6 +159,7 @@ static const struct snd_ff_spec spec_ff800 = {
 	.midi_out_ports = 1,
 	.protocol = &snd_ff_protocol_ff800,
 	.midi_high_addr = 0x000200000320ull,
+	.midi_addr_range = 12,
 };
 
 static const struct snd_ff_spec spec_ff400 = {
@@ -169,6 +170,7 @@ static const struct snd_ff_spec spec_ff400 = {
 	.midi_out_ports = 2,
 	.protocol = &snd_ff_protocol_ff400,
 	.midi_high_addr = 0x0000801003f4ull,
+	.midi_addr_range = SND_FF_MAXIMIM_MIDI_QUADS * 4,
 };
 
 static const struct snd_ff_spec spec_ucx = {

commit fd1cc9de64c2ca6c2b5b9061421580a22bfac023
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Jan 20 17:25:53 2019 +0900

    ALSA: fireface: add support for Fireface UCX
    
    Fireface UFX was shipped by RME GmbH in 2012. This model supports later
    protocol for management of isochronous communication and synchronization
    of sampling transmission frequency.
    
    This commit adds support for the model. At present, it's not clear how
    to encode MIDI messages and decide destination address for asynchronous
    transaction, thus this commit adds support for isochronous communication
    for PCM frames only.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 36575f4159d1..fd9c980e3cf4 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -32,7 +32,8 @@ static void ff_card_free(struct snd_card *card)
 	struct snd_ff *ff = card->private_data;
 
 	snd_ff_stream_destroy_duplex(ff);
-	snd_ff_transaction_unregister(ff);
+	if (ff->spec->midi_high_addr > 0)
+		snd_ff_transaction_unregister(ff);
 }
 
 static void do_registration(struct work_struct *work)
@@ -50,9 +51,11 @@ static void do_registration(struct work_struct *work)
 	ff->card->private_free = ff_card_free;
 	ff->card->private_data = ff;
 
-	err = snd_ff_transaction_register(ff);
-	if (err < 0)
-		goto error;
+	if (ff->spec->midi_high_addr > 0) {
+		err = snd_ff_transaction_register(ff);
+		if (err < 0)
+			goto error;
+	}
 
 	name_card(ff);
 
@@ -62,9 +65,11 @@ static void do_registration(struct work_struct *work)
 
 	snd_ff_proc_init(ff);
 
-	err = snd_ff_create_midi_devices(ff);
-	if (err < 0)
-		goto error;
+	if (ff->spec->midi_in_ports > 0 || ff->spec->midi_out_ports > 0) {
+		err = snd_ff_create_midi_devices(ff);
+		if (err < 0)
+			goto error;
+	}
 
 	err = snd_ff_create_pcm_devices(ff);
 	if (err < 0)
@@ -119,7 +124,8 @@ static void snd_ff_update(struct fw_unit *unit)
 	if (!ff->registered)
 		snd_fw_schedule_registration(unit, &ff->dwork);
 
-	snd_ff_transaction_reregister(ff);
+	if (ff->spec->midi_high_addr > 0)
+		snd_ff_transaction_reregister(ff);
 
 	if (ff->registered)
 		snd_ff_stream_update_duplex(ff);
@@ -165,6 +171,13 @@ static const struct snd_ff_spec spec_ff400 = {
 	.midi_high_addr = 0x0000801003f4ull,
 };
 
+static const struct snd_ff_spec spec_ucx = {
+	.name = "FirefaceUCX",
+	.pcm_capture_channels = {18, 14, 12},
+	.pcm_playback_channels = {18, 14, 12},
+	.protocol = &snd_ff_protocol_latter,
+};
+
 static const struct ieee1394_device_id snd_ff_id_table[] = {
 	/* Fireface 800 */
 	{
@@ -190,6 +203,18 @@ static const struct ieee1394_device_id snd_ff_id_table[] = {
 		.model_id	= 0x101800,
 		.driver_data	= (kernel_ulong_t)&spec_ff400,
 	},
+	// Fireface UCX.
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_SPECIFIER_ID |
+				  IEEE1394_MATCH_VERSION |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= OUI_RME,
+		.specifier_id	= OUI_RME,
+		.version	= 0x000004,
+		.model_id	= 0x101800,
+		.driver_data	= (kernel_ulong_t)&spec_ucx,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(ieee1394, snd_ff_id_table);

commit 6d1ef1bbfed5f903aaab743a08bde41cc372d646
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Dec 16 17:32:33 2018 +0900

    ALSA: fireface: code refactoring to handle model-specific registers
    
    As a result of investigation for Fireface 800, 'struct snd_ff_spec.regs'
    is just for higher address to receive tx asynchronous packets of MIDI
    messages, thus it can be simplified.
    
    This commit simplifies it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index f7a752930060..36575f4159d1 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -152,9 +152,7 @@ static const struct snd_ff_spec spec_ff800 = {
 	.midi_in_ports = 1,
 	.midi_out_ports = 1,
 	.protocol = &snd_ff_protocol_ff800,
-	.regs = {
-		[SND_FF_REG_TYPE_MIDI_HIGH_ADDR] = 0x000200000320ull,
-	},
+	.midi_high_addr = 0x000200000320ull,
 };
 
 static const struct snd_ff_spec spec_ff400 = {
@@ -164,9 +162,7 @@ static const struct snd_ff_spec spec_ff400 = {
 	.midi_in_ports = 2,
 	.midi_out_ports = 2,
 	.protocol = &snd_ff_protocol_ff400,
-	.regs = {
-		[SND_FF_REG_TYPE_MIDI_HIGH_ADDR] = 0x0000801003f4ull,
-	},
+	.midi_high_addr = 0x0000801003f4ull,
 };
 
 static const struct ieee1394_device_id snd_ff_id_table[] = {

commit fc716397a5c7a20247a39c9347fb7a543e0ae4ad
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Dec 16 17:32:32 2018 +0900

    ALSA: fireface: add support for packet streaming on Fireface 800
    
    This commit adds a functionality to multiplex PCM frames into isochronous
    packets and demultiplex PCM frames from isochronous packets for ALSA PCM
    applications.
    
    Fireface 800 voluntarily maintains resources for tx isochronous
    communication.  It performs reservation of isochronous channel and
    allocation/update of bandwidth in some cases below:
     - at a first request to allocation after bus resets
     - at requests to allocation when further bandwidth is required
    
    When request is grant and the unit is prepared, read data from
    0x0000801c0008 represents isochronous channel for tx stream, then
    the unit can handle requests to start communication. If driver
    send the request without checking the register, the unit takes
    panic to continue bus resets. The unit starts transmission of
    tx packets after receiving several rx packets from driver.
    
    I note that the unit can process tx/rx packets and generate/record
    sound regardless of HOST LED.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index d486984c0e5b..f7a752930060 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -31,8 +31,7 @@ static void ff_card_free(struct snd_card *card)
 {
 	struct snd_ff *ff = card->private_data;
 
-	if (ff->spec->protocol->begin_session)
-		snd_ff_stream_destroy_duplex(ff);
+	snd_ff_stream_destroy_duplex(ff);
 	snd_ff_transaction_unregister(ff);
 }
 
@@ -57,11 +56,9 @@ static void do_registration(struct work_struct *work)
 
 	name_card(ff);
 
-	if (ff->spec->protocol->begin_session) {
-		err = snd_ff_stream_init_duplex(ff);
-		if (err < 0)
-			goto error;
-	}
+	err = snd_ff_stream_init_duplex(ff);
+	if (err < 0)
+		goto error;
 
 	snd_ff_proc_init(ff);
 
@@ -69,15 +66,13 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	if (ff->spec->protocol->begin_session) {
-		err = snd_ff_create_pcm_devices(ff);
-		if (err < 0)
-			goto error;
+	err = snd_ff_create_pcm_devices(ff);
+	if (err < 0)
+		goto error;
 
-		err = snd_ff_create_hwdep_devices(ff);
-		if (err < 0)
-			goto error;
-	}
+	err = snd_ff_create_hwdep_devices(ff);
+	if (err < 0)
+		goto error;
 
 	err = snd_card_register(ff->card);
 	if (err < 0)
@@ -126,7 +121,7 @@ static void snd_ff_update(struct fw_unit *unit)
 
 	snd_ff_transaction_reregister(ff);
 
-	if (ff->registered && ff->spec->protocol->begin_session)
+	if (ff->registered)
 		snd_ff_stream_update_duplex(ff);
 }
 
@@ -152,6 +147,8 @@ static void snd_ff_remove(struct fw_unit *unit)
 
 static const struct snd_ff_spec spec_ff800 = {
 	.name = "Fireface800",
+	.pcm_capture_channels = {28, 20, 12},
+	.pcm_playback_channels = {28, 20, 12},
 	.midi_in_ports = 1,
 	.midi_out_ports = 1,
 	.protocol = &snd_ff_protocol_ff800,

commit a91f676074c05b3c455700b90849adcfda50079e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 11 19:17:35 2018 +0900

    ALSA: fireface: add support for Fireface 800 with MIDI functionality only
    
    Fireface 800 is a flagship model of RME GmbH for audio and music units
    on IEEE 1394 bus, shipped 2004. This model consists of four chips:
     - TI TSB81BA3D for physical layer on cable environment of EEE 1394 bus
     - TI TSB82AA2 for link layer for 1394 OHCI bus bridge to PCI bus
     - Xilinx Spartan-3 FPGA XC3S400
     - Xilinx High-Performance CPLD XC9572XL
    
    This commit adds support Fireface 800. In this time, the support is
    restricted to its MIDI functionality, thus this commit adds some
    condition statements to avoid touching streaming functionality.
    
    Unlike Fireface 400, Fireface 800 has no functionality to suppress
    asynchronous transactions for MIDI messages except for unregister of
    listen address in controller side, thus the feature is available as is.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 2ce5e115b0eb..d486984c0e5b 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -31,7 +31,8 @@ static void ff_card_free(struct snd_card *card)
 {
 	struct snd_ff *ff = card->private_data;
 
-	snd_ff_stream_destroy_duplex(ff);
+	if (ff->spec->protocol->begin_session)
+		snd_ff_stream_destroy_duplex(ff);
 	snd_ff_transaction_unregister(ff);
 }
 
@@ -56,9 +57,11 @@ static void do_registration(struct work_struct *work)
 
 	name_card(ff);
 
-	err = snd_ff_stream_init_duplex(ff);
-	if (err < 0)
-		goto error;
+	if (ff->spec->protocol->begin_session) {
+		err = snd_ff_stream_init_duplex(ff);
+		if (err < 0)
+			goto error;
+	}
 
 	snd_ff_proc_init(ff);
 
@@ -66,13 +69,15 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	err = snd_ff_create_pcm_devices(ff);
-	if (err < 0)
-		goto error;
+	if (ff->spec->protocol->begin_session) {
+		err = snd_ff_create_pcm_devices(ff);
+		if (err < 0)
+			goto error;
 
-	err = snd_ff_create_hwdep_devices(ff);
-	if (err < 0)
-		goto error;
+		err = snd_ff_create_hwdep_devices(ff);
+		if (err < 0)
+			goto error;
+	}
 
 	err = snd_card_register(ff->card);
 	if (err < 0)
@@ -121,7 +126,7 @@ static void snd_ff_update(struct fw_unit *unit)
 
 	snd_ff_transaction_reregister(ff);
 
-	if (ff->registered)
+	if (ff->registered && ff->spec->protocol->begin_session)
 		snd_ff_stream_update_duplex(ff);
 }
 
@@ -145,6 +150,16 @@ static void snd_ff_remove(struct fw_unit *unit)
 	fw_unit_put(ff->unit);
 }
 
+static const struct snd_ff_spec spec_ff800 = {
+	.name = "Fireface800",
+	.midi_in_ports = 1,
+	.midi_out_ports = 1,
+	.protocol = &snd_ff_protocol_ff800,
+	.regs = {
+		[SND_FF_REG_TYPE_MIDI_HIGH_ADDR] = 0x000200000320ull,
+	},
+};
+
 static const struct snd_ff_spec spec_ff400 = {
 	.name = "Fireface400",
 	.pcm_capture_channels = {18, 14, 10},
@@ -158,6 +173,18 @@ static const struct snd_ff_spec spec_ff400 = {
 };
 
 static const struct ieee1394_device_id snd_ff_id_table[] = {
+	/* Fireface 800 */
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_SPECIFIER_ID |
+				  IEEE1394_MATCH_VERSION |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= OUI_RME,
+		.specifier_id	= OUI_RME,
+		.version	= 0x000001,
+		.model_id	= 0x101800,
+		.driver_data	= (kernel_ulong_t)&spec_ff800,
+	},
 	/* Fireface 400 */
 	{
 		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
@@ -165,7 +192,7 @@ static const struct ieee1394_device_id snd_ff_id_table[] = {
 				  IEEE1394_MATCH_VERSION |
 				  IEEE1394_MATCH_MODEL_ID,
 		.vendor_id	= OUI_RME,
-		.specifier_id	= 0x000a35,
+		.specifier_id	= OUI_RME,
 		.version	= 0x000002,
 		.model_id	= 0x101800,
 		.driver_data	= (kernel_ulong_t)&spec_ff400,

commit 3eb8a24459491acc40440b655ca640c87125c5a3
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Dec 11 19:17:33 2018 +0900

    ALSA: fireface: add driver data for register for MIDI high address
    
    Fireface 400 and 800 have the same mechanism to decide address to which
    asynchronous transactions are sent for MIDI messages, however they use
    different registers for controllers to notify higher 4 byte of the
    address.
    
    This commit adds a model-specific parameter to represent the address.
    Additionally, it corrects some comments. I note that these two models have
    a difference to enable/disable the transaction.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 3f61cfeace69..2ce5e115b0eb 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -152,6 +152,9 @@ static const struct snd_ff_spec spec_ff400 = {
 	.midi_in_ports = 2,
 	.midi_out_ports = 2,
 	.protocol = &snd_ff_protocol_ff400,
+	.regs = {
+		[SND_FF_REG_TYPE_MIDI_HIGH_ADDR] = 0x0000801003f4ull,
+	},
 };
 
 static const struct ieee1394_device_id snd_ff_id_table[] = {

commit 3babca4555b20fc80aff4776662fb237257d9afd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:02 2018 +0900

    ALSA: firewire: simplify cleanup process when failing to register sound card
    
    In former commits, .private_free callback releases resources just for
    data transmission. This release function can be called without the
    resources are actually allocated in error paths.
    
    This commit applies a small refactoring to clean up codes in error
    paths.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 37866beeb160..3f61cfeace69 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -27,17 +27,14 @@ static void name_card(struct snd_ff *ff)
 		 dev_name(&ff->unit->device), 100 << fw_dev->max_speed);
 }
 
-static void ff_free(struct snd_ff *ff)
+static void ff_card_free(struct snd_card *card)
 {
+	struct snd_ff *ff = card->private_data;
+
 	snd_ff_stream_destroy_duplex(ff);
 	snd_ff_transaction_unregister(ff);
 }
 
-static void ff_card_free(struct snd_card *card)
-{
-	ff_free(card->private_data);
-}
-
 static void do_registration(struct work_struct *work)
 {
 	struct snd_ff *ff = container_of(work, struct snd_ff, dwork.work);
@@ -50,6 +47,8 @@ static void do_registration(struct work_struct *work)
 			   &ff->card);
 	if (err < 0)
 		return;
+	ff->card->private_free = ff_card_free;
+	ff->card->private_data = ff;
 
 	err = snd_ff_transaction_register(ff);
 	if (err < 0)
@@ -79,14 +78,10 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	ff->card->private_free = ff_card_free;
-	ff->card->private_data = ff;
 	ff->registered = true;
 
 	return;
 error:
-	snd_ff_transaction_unregister(ff);
-	snd_ff_stream_destroy_duplex(ff);
 	snd_card_free(ff->card);
 	dev_info(&ff->unit->device,
 		 "Sound card registration failed: %d\n", err);

commit 5b14ec25a79bf60fc9a663fe579a500b6ac9d8ab
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:00 2018 +0900

    ALSA: firewire: release reference count of firewire unit in .remove callback of bus driver
    
    In a previous commit, drivers in ALSA firewire stack blocks .remove
    callback of bus driver. This enables to release members of private
    data in the callback after releasing device of sound card.
    
    This commit simplifies codes to release the members.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 73425dfe63bf..37866beeb160 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -31,9 +31,6 @@ static void ff_free(struct snd_ff *ff)
 {
 	snd_ff_stream_destroy_duplex(ff);
 	snd_ff_transaction_unregister(ff);
-
-	mutex_destroy(&ff->mutex);
-	fw_unit_put(ff->unit);
 }
 
 static void ff_card_free(struct snd_card *card)
@@ -147,10 +144,10 @@ static void snd_ff_remove(struct fw_unit *unit)
 	if (ff->registered) {
 		// Block till all of ALSA character devices are released.
 		snd_card_free(ff->card);
-	} else {
-		/* Don't forget this case. */
-		ff_free(ff);
 	}
+
+	mutex_destroy(&ff->mutex);
+	fw_unit_put(ff->unit);
 }
 
 static const struct snd_ff_spec spec_ff400 = {

commit 61ccc6f6b27c03bb32ca38a3c580d49ce1612d43
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:34:59 2018 +0900

    ALSA: firewire: block .remove callback of bus driver till all of ALSA character devices are released
    
    At present, in .remove callback of bus driver just decrease reference
    count of device for ALSA card instance. This delegates release of the
    device to a process in which the last of ALSA character device is
    released.
    
    On the other hand, the other drivers such as for devices on PCIe are
    programmed to block .remove callback of bus driver till all of ALSA
    character devices are released.
    
    For consistency of behaviour for whole drivers, this probably confuses
    users. This commit takes drivers in ALSA firewire stack to imitate the
    above behaviour.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 98731bd8816f..73425dfe63bf 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -145,8 +145,8 @@ static void snd_ff_remove(struct fw_unit *unit)
 	cancel_work_sync(&ff->dwork.work);
 
 	if (ff->registered) {
-		/* No need to wait for releasing card object in this context. */
-		snd_card_free_when_closed(ff->card);
+		// Block till all of ALSA character devices are released.
+		snd_card_free(ff->card);
 	} else {
 		/* Don't forget this case. */
 		ff_free(ff);

commit 366a20d7a75cff7f89dede6fdfd41bd491aaf8ac
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:50 2018 +0900

    ALSA: firewire: use managed-resource of fw unit device for private data
    
    At present, private data of each driver in ALSA firewire stack is
    allocated/freed by kernel slab allocator for corresponding unit on
    IEEE 1394 bus. In this case, resource-managed slab allocator is
    available to release memory object automatically just before releasing
    device structure for the unit. This idea can prevent runtime from
    memory leak due to programming mistakes.
    
    This commit uses the allocator for the private data. These drivers
    already use reference counter to maintain lifetime of device structure
    for the unit by a pair of fw_unit_get()/fw_unit_put(). The private data
    is safely released in a callback of 'struct snd_card.private_free().
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 4974bc7980e9..98731bd8816f 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -32,10 +32,8 @@ static void ff_free(struct snd_ff *ff)
 	snd_ff_stream_destroy_duplex(ff);
 	snd_ff_transaction_unregister(ff);
 
-	fw_unit_put(ff->unit);
-
 	mutex_destroy(&ff->mutex);
-	kfree(ff);
+	fw_unit_put(ff->unit);
 }
 
 static void ff_card_free(struct snd_card *card)
@@ -102,11 +100,9 @@ static int snd_ff_probe(struct fw_unit *unit,
 {
 	struct snd_ff *ff;
 
-	ff = kzalloc(sizeof(struct snd_ff), GFP_KERNEL);
-	if (ff == NULL)
+	ff = devm_kzalloc(&unit->device, sizeof(struct snd_ff), GFP_KERNEL);
+	if (!ff)
 		return -ENOMEM;
-
-	/* initialize myself */
 	ff->unit = fw_unit_get(unit);
 	dev_set_drvdata(&unit->device, ff);
 

commit 782fbec745d84fa06708e703a92a431c4344daf0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Aug 22 22:58:15 2017 +0900

    ALSA: firewire: add const qualifier to identifiers for read-only symbols
    
    Drivers in ALSA firewire stack still includes some symbols which can be
    moved to a section for read-only symbols.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index eee7c8eac7a6..4974bc7980e9 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -157,7 +157,7 @@ static void snd_ff_remove(struct fw_unit *unit)
 	}
 }
 
-static struct snd_ff_spec spec_ff400 = {
+static const struct snd_ff_spec spec_ff400 = {
 	.name = "Fireface400",
 	.pcm_capture_channels = {18, 14, 10},
 	.pcm_playback_channels = {18, 14, 10},

commit 76fdb3a9e13a781df8bf8652312f6a7cbf5e2f43
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:12 2017 +0900

    ALSA: fireface: add support for Fireface 400
    
    Fireface 400 is a second model of RME Fireface series, released in 2006.
    This commit adds support for this model.
    
    This model supports 8 analog channels, 2 S/PDIF channels and 8 ADAT
    channels in both of tx/rx packet. The number of ADAT channels differs
    depending on each mode of sampling transmission frequency.
    
    $ python2 linux-firewire-utils/src/crpp < /sys/bus/firewire/devices/fw1/config_rom
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  04107768  bus_info_length 4, crc_length 16, crc 30568 (should be 61311)
    404  31333934  bus_name "1394"
    408  20009002  irmc 0, cmc 0, isc 1, bmc 0, cyc_clk_acc 0, max_rec 9 (1024)
    40c  000a3501  company_id 000a35     |
    410  1bd0862a  device_id 011bd0862a  | EUI-64 000a35011bd0862a
    
                   root directory
                   -----------------------------------------------------------------
    414  000485ec  directory_length 4, crc 34284
    418  03000a35  vendor
    41c  0c0083c0  node capabilities per IEEE 1394
    420  8d000006  --> eui-64 leaf at 438
    424  d1000001  --> unit directory at 428
    
                   unit directory at 428
                   -----------------------------------------------------------------
    428  000314c4  directory_length 3, crc 5316
    42c  12000a35  specifier id
    430  13000002  version
    434  17101800  model
    
                   eui-64 leaf at 438
                   -----------------------------------------------------------------
    438  000261a8  leaf_length 2, crc 25000
    43c  000a3501  company_id 000a35     |
    440  1bd0862a  device_id 011bd0862a  | EUI-64 000a35011bd0862a
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index f57b434144dc..eee7c8eac7a6 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -157,7 +157,28 @@ static void snd_ff_remove(struct fw_unit *unit)
 	}
 }
 
+static struct snd_ff_spec spec_ff400 = {
+	.name = "Fireface400",
+	.pcm_capture_channels = {18, 14, 10},
+	.pcm_playback_channels = {18, 14, 10},
+	.midi_in_ports = 2,
+	.midi_out_ports = 2,
+	.protocol = &snd_ff_protocol_ff400,
+};
+
 static const struct ieee1394_device_id snd_ff_id_table[] = {
+	/* Fireface 400 */
+	{
+		.match_flags	= IEEE1394_MATCH_VENDOR_ID |
+				  IEEE1394_MATCH_SPECIFIER_ID |
+				  IEEE1394_MATCH_VERSION |
+				  IEEE1394_MATCH_MODEL_ID,
+		.vendor_id	= OUI_RME,
+		.specifier_id	= 0x000a35,
+		.version	= 0x000002,
+		.model_id	= 0x101800,
+		.driver_data	= (kernel_ulong_t)&spec_ff400,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(ieee1394, snd_ff_id_table);

commit f656edd5fb33d889561978b81ec2897087c2f4ca
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:11 2017 +0900

    ALSA: fireface: add hwdep interface
    
    This commit adds hwdep interface so as the other drivers for audio and
    music units on IEEE 1394 have.
    
    This interface is designed for mixer/control applications. By using this
    interface, an application can get information about firewire node, can
    lock/unlock kernel streaming and can get notification at starting/stopping
    kernel streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index ff62d16fec0f..f57b434144dc 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -76,6 +76,10 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
+	err = snd_ff_create_hwdep_devices(ff);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(ff->card);
 	if (err < 0)
 		goto error;
@@ -108,6 +112,7 @@ static int snd_ff_probe(struct fw_unit *unit,
 
 	mutex_init(&ff->mutex);
 	spin_lock_init(&ff->lock);
+	init_waitqueue_head(&ff->hwdep_wait);
 
 	ff->spec = (const struct snd_ff_spec *)entry->driver_data;
 

commit 4b316436ab2e0b74e4986fc66b7cd7902cfd7054
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:10 2017 +0900

    ALSA: fireface: add support for PCM functionality
    
    This commit adds PCM functionality to transmit/receive PCM frames on
    isochronous packet streaming. This commit enables userspace applications
    to start/stop packet streaming via ALSA PCM interface.
    
    Sampling rate requested by applications is used as sampling transmission
    frequency of IEC 61883-1/6packet streaming. As I described in followed
    commits, units in this series manages sampling clock frequency
    independently of sampling transmission frequency, and they supports
    resampling between their packet streaming/data block processing layer and
    sampling data processing layer. This commit take this driver to utilize
    these features for usability.
    
    When internal clock is selected as source signal of sampling clock, this
    driver allows user space applications to start PCM substreams at any rate
    which packet streaming engine supports as sampling transmission frequency.
    In this case, this driver expects units to perform resampling PCM frames
    for rx/tx packets when sampling clock frequency and sampling transmission
    frequency are mismatched. This is for daily use cases.
    
    When any external clock is selected as the source signal, this driver
    gets configured sampling rate from units, then restricts available
    sampling rate to the rate for PCM applications. This is for studio use
    cases.
    
    Models in this series supports 64.0/128.0 kHz of sampling rate, however
    these frequencies are not supported by IEC 61883-6 as sampling transmission
    frequency. Therefore, packet streaming engine of ALSA firewire stack can't
    handle them. When units are configured to use any external clock as source
    signal of sampling clock and one of these unsupported rate is configured
    as rate of the sampling clock, this driver returns EIO to user space
    applications.
    
    Anyway, this driver doesn't voluntarily configure parameters of sampling
    clock. It's better for users to work with appropriate user space
    implementations to configure the parameters in advance of usage.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 6bdbebd9f61b..ff62d16fec0f 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -72,6 +72,10 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
+	err = snd_ff_create_pcm_devices(ff);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(ff->card);
 	if (err < 0)
 		goto error;

commit 75d6d898977830d6d789083bf0a63ea6826124c8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:09 2017 +0900

    ALSA: fireface: add stream management functionality
    
    This commit adds management functionality for packet streaming.
    
    As long as investigating Fireface 400, there're three modes depending
    on sampling transmission frequency. The number of data channels in each
    data block is different depending on the mode. The set of available
    data channels for each mode might be different for each protocol and
    model.
    
    The length of registers for the number of isochronous channel is just
    three bits, therefore 0-7ch are available.
    
    When bus reset occurs on IEEE 1394 bus, the device discontinues to
    transmit packets. This commit aborts PCM substreams at bus reset handler.
    
    As I described in followed commits, The device manages its sampling clock
    independently of sampling transmission frequency against IEC 61883-6.
    Thus, it's a lower cost to change the sampling transmission frequency,
    while data fetch between streaming layer and DSP require larger buffer
    for resampling. As a result, device latency might tend to be larger than
    ASICs for IEC 61883-1/6 such as DM1000/DM1100/DM1500 (BeBoB),
    DiceII/TCD2210/TCD2220/TCD3070 and OXFW970/971.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 22e7bcb4bd51..6bdbebd9f61b 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -29,6 +29,7 @@ static void name_card(struct snd_ff *ff)
 
 static void ff_free(struct snd_ff *ff)
 {
+	snd_ff_stream_destroy_duplex(ff);
 	snd_ff_transaction_unregister(ff);
 
 	fw_unit_put(ff->unit);
@@ -61,6 +62,10 @@ static void do_registration(struct work_struct *work)
 
 	name_card(ff);
 
+	err = snd_ff_stream_init_duplex(ff);
+	if (err < 0)
+		goto error;
+
 	snd_ff_proc_init(ff);
 
 	err = snd_ff_create_midi_devices(ff);
@@ -78,6 +83,7 @@ static void do_registration(struct work_struct *work)
 	return;
 error:
 	snd_ff_transaction_unregister(ff);
+	snd_ff_stream_destroy_duplex(ff);
 	snd_card_free(ff->card);
 	dev_info(&ff->unit->device,
 		 "Sound card registration failed: %d\n", err);
@@ -117,6 +123,9 @@ static void snd_ff_update(struct fw_unit *unit)
 		snd_fw_schedule_registration(unit, &ff->dwork);
 
 	snd_ff_transaction_reregister(ff);
+
+	if (ff->registered)
+		snd_ff_stream_update_duplex(ff);
 }
 
 static void snd_ff_remove(struct fw_unit *unit)

commit d3fc7aac11dc54f97f4f28c60a489a555529fa1c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:05 2017 +0900

    ALSA: fireface: add proc node to help debugging
    
    Drivers can retrieve the state and configuration of clock by read
    transactions.
    
    This commit allows protocol abstraction layer to to dump the
    information for debugging, via proc interface.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 11d76b372cd9..22e7bcb4bd51 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -61,6 +61,8 @@ static void do_registration(struct work_struct *work)
 
 	name_card(ff);
 
+	snd_ff_proc_init(ff);
+
 	err = snd_ff_create_midi_devices(ff);
 	if (err < 0)
 		goto error;

commit ff2c293efaf43feb120f6b166891e5eca0cf3ccc
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:04 2017 +0900

    ALSA: fireface: add support for MIDI functionality
    
    In previous commit, fireface driver supports unique transaction mechanism
    for MIDI feature. This commit adds MIDI functionality for userspace
    applications.
    
    As I wrote in a followed commit, user space applications get some
    requirement from this driver. It should not touch a register to which
    units transmit MIDI messages. It should configure a register in which
    MIDI transmission is controlled.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 4db630fe241c..11d76b372cd9 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -61,6 +61,10 @@ static void do_registration(struct work_struct *work)
 
 	name_card(ff);
 
+	err = snd_ff_create_midi_devices(ff);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(ff->card);
 	if (err < 0)
 		goto error;
@@ -91,6 +95,7 @@ static int snd_ff_probe(struct fw_unit *unit,
 	dev_set_drvdata(&unit->device, ff);
 
 	mutex_init(&ff->mutex);
+	spin_lock_init(&ff->lock);
 
 	ff->spec = (const struct snd_ff_spec *)entry->driver_data;
 

commit 19174295788de77dd58dc6060b0d1bcfda21625e
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:03 2017 +0900

    ALSA: fireface: add transaction support
    
    As long as investigating Fireface 400, MIDI messages are transferred by
    asynchronous communication over IEEE 1394 bus.
    
    Fireface 400 receives MIDI messages by write transactions to two addresses;
    0x'0000'0801'8000 and 0x'0000'0801'9000. Each of two seems to correspond to
    MIDI port 1 and 2.
    
    Fireface 400 transfers MIDI messages by write transactions to certain
    addresses which configured by drivers. The drivers can decide upper 4 byte
    of the addresses by write transactions to 0x'0000'0801'03f4. For the rest
    part of the address, drivers can select from below options:
     * 0x'0000'0000
     * 0x'0000'0080
     * 0x'0000'0100
     * 0x'0000'0180
    
    Selected options are represented in register 0x'0000'0801'051c as bit
    flags. Due to this mechanism, drivers are restricted to use addresses on
    'Memory space' of IEEE 1222, even if transactions to the address have
    some side effects.
    
    This commit adds transaction support for MIDI messaging, based on my
    assumption that the similar mechanism is used on the other protocols. To
    receive asynchronous transactions, the driver allocates a range of address
    in 'Memory space'. I apply a strategy to use 0x'0000'0000 as lower 4 byte
    of the address. When getting failure from Linux FireWire subsystem, this
    driver retries to allocate addresses.
    
    Unfortunately, read transaction to address 0x'0000'0801'051c returns zero
    always, however write transactions have effects to the other features such
    as status of sampling clock. For this reason, this commit delegates a task
    to configure this register to user space applications. The applications
    should set 3rd bit in LSB in little endian order.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 5c2bd9222c97..4db630fe241c 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -29,6 +29,8 @@ static void name_card(struct snd_ff *ff)
 
 static void ff_free(struct snd_ff *ff)
 {
+	snd_ff_transaction_unregister(ff);
+
 	fw_unit_put(ff->unit);
 
 	mutex_destroy(&ff->mutex);
@@ -53,6 +55,10 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		return;
 
+	err = snd_ff_transaction_register(ff);
+	if (err < 0)
+		goto error;
+
 	name_card(ff);
 
 	err = snd_card_register(ff->card);
@@ -65,6 +71,7 @@ static void do_registration(struct work_struct *work)
 
 	return;
 error:
+	snd_ff_transaction_unregister(ff);
 	snd_card_free(ff->card);
 	dev_info(&ff->unit->device,
 		 "Sound card registration failed: %d\n", err);
@@ -101,6 +108,8 @@ static void snd_ff_update(struct fw_unit *unit)
 	/* Postpone a workqueue for deferred registration. */
 	if (!ff->registered)
 		snd_fw_schedule_registration(unit, &ff->dwork);
+
+	snd_ff_transaction_reregister(ff);
 }
 
 static void snd_ff_remove(struct fw_unit *unit)

commit ed90f91a17112d474909bd820f1bb65a5480959d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:01 2017 +0900

    ALSA: fireface: add model specific structure
    
    RME Fireface series has several models and their specifications are
    different. Currently, we find no way to retrieve the specifications
    from actual devices and need to implement them in this driver.
    
    This commit adds a structure to describe model specific data. This
    structure has an identical name for each unit, and maximum number of
    data channels in each mode. I'll describe about the mode in following
    commits.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 7c026396b8b5..5c2bd9222c97 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -17,13 +17,12 @@ MODULE_LICENSE("GPL v2");
 static void name_card(struct snd_ff *ff)
 {
 	struct fw_device *fw_dev = fw_parent_device(ff->unit);
-	const char *const model = "Fireface Skeleton";
 
 	strcpy(ff->card->driver, "Fireface");
-	strcpy(ff->card->shortname, model);
-	strcpy(ff->card->mixername, model);
+	strcpy(ff->card->shortname, ff->spec->name);
+	strcpy(ff->card->mixername, ff->spec->name);
 	snprintf(ff->card->longname, sizeof(ff->card->longname),
-		 "RME %s, GUID %08x%08x at %s, S%d", model,
+		 "RME %s, GUID %08x%08x at %s, S%d", ff->spec->name,
 		 fw_dev->config_rom[3], fw_dev->config_rom[4],
 		 dev_name(&ff->unit->device), 100 << fw_dev->max_speed);
 }
@@ -86,6 +85,8 @@ static int snd_ff_probe(struct fw_unit *unit,
 
 	mutex_init(&ff->mutex);
 
+	ff->spec = (const struct snd_ff_spec *)entry->driver_data;
+
 	/* Register this sound card later. */
 	INIT_DEFERRABLE_WORK(&ff->dwork, do_registration);
 	snd_fw_schedule_registration(unit, &ff->dwork);

commit 324540c4e05c09c007f9e358cacb30b38f296bcc
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:06:00 2017 +0900

    ALSA: fireface: postpone sound card registration
    
    Just after appearing on IEEE 1394 bus, this unit generates several bus
    resets. This is due to loading firmware from on-board flash memory and
    initialize hardware. It's better to postpone sound card registration.
    
    This commit schedules workqueue to process actual probe processing
    2 seconds after the last bus-reset. The card instance is kept at unit
    probe callback and released at card free callback. Therefore, when the
    actual probe processing fails, the memory block is wasted. This is due to
    simplify driver implementation.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
index 358bba23deeb..7c026396b8b5 100644
--- a/sound/firewire/fireface/ff.c
+++ b/sound/firewire/fireface/ff.c
@@ -28,58 +28,98 @@ static void name_card(struct snd_ff *ff)
 		 dev_name(&ff->unit->device), 100 << fw_dev->max_speed);
 }
 
-static void ff_card_free(struct snd_card *card)
+static void ff_free(struct snd_ff *ff)
 {
-	struct snd_ff *ff = card->private_data;
-
 	fw_unit_put(ff->unit);
 
 	mutex_destroy(&ff->mutex);
+	kfree(ff);
+}
+
+static void ff_card_free(struct snd_card *card)
+{
+	ff_free(card->private_data);
+}
+
+static void do_registration(struct work_struct *work)
+{
+	struct snd_ff *ff = container_of(work, struct snd_ff, dwork.work);
+	int err;
+
+	if (ff->registered)
+		return;
+
+	err = snd_card_new(&ff->unit->device, -1, NULL, THIS_MODULE, 0,
+			   &ff->card);
+	if (err < 0)
+		return;
+
+	name_card(ff);
+
+	err = snd_card_register(ff->card);
+	if (err < 0)
+		goto error;
+
+	ff->card->private_free = ff_card_free;
+	ff->card->private_data = ff;
+	ff->registered = true;
+
+	return;
+error:
+	snd_card_free(ff->card);
+	dev_info(&ff->unit->device,
+		 "Sound card registration failed: %d\n", err);
 }
 
 static int snd_ff_probe(struct fw_unit *unit,
 			   const struct ieee1394_device_id *entry)
 {
-	struct snd_card *card;
 	struct snd_ff *ff;
-	int err;
 
-	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
-			   sizeof(struct snd_ff), &card);
-	if (err < 0)
-		return err;
-	card->private_free = ff_card_free;
+	ff = kzalloc(sizeof(struct snd_ff), GFP_KERNEL);
+	if (ff == NULL)
+		return -ENOMEM;
 
 	/* initialize myself */
-	ff = card->private_data;
-	ff->card = card;
 	ff->unit = fw_unit_get(unit);
 	dev_set_drvdata(&unit->device, ff);
 
 	mutex_init(&ff->mutex);
 
-	name_card(ff);
-
-	err = snd_card_register(card);
-	if (err < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	/* Register this sound card later. */
+	INIT_DEFERRABLE_WORK(&ff->dwork, do_registration);
+	snd_fw_schedule_registration(unit, &ff->dwork);
 
 	return 0;
 }
 
 static void snd_ff_update(struct fw_unit *unit)
 {
-	return;
+	struct snd_ff *ff = dev_get_drvdata(&unit->device);
+
+	/* Postpone a workqueue for deferred registration. */
+	if (!ff->registered)
+		snd_fw_schedule_registration(unit, &ff->dwork);
 }
 
 static void snd_ff_remove(struct fw_unit *unit)
 {
 	struct snd_ff *ff = dev_get_drvdata(&unit->device);
 
-	/* No need to wait for releasing card object in this context. */
-	snd_card_free_when_closed(ff->card);
+	/*
+	 * Confirm to stop the work for registration before the sound card is
+	 * going to be released. The work is not scheduled again because bus
+	 * reset handler is not called anymore.
+	 */
+	cancel_work_sync(&ff->dwork.work);
+
+	if (ff->registered) {
+		/* No need to wait for releasing card object in this context. */
+		snd_card_free_when_closed(ff->card);
+	} else {
+		/* Don't forget this case. */
+		ff_free(ff);
+	}
 }
 
 static const struct ieee1394_device_id snd_ff_id_table[] = {

commit 17c4e5eadc4ab7db4c0655c124174a6d8e5f4dc5
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 31 22:05:59 2017 +0900

    ALSA: fireface: add skeleton for RME Fireface series
    
    This commit adds a new driver for RME Fireface series. This commit just
    creates/removes card instance according to IEEE 1394 bus event. More
    functions will be added in following commits.
    
    Three types of firmware have released by RME GmbH; for Fireface 400, for
    Fireface 800 and for UCX/802/UFX. It's reasonable that these models use
    different protocol for communication. Currently, I've investigated
    Fireface 400 and nothing others.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/fireface/ff.c b/sound/firewire/fireface/ff.c
new file mode 100644
index 000000000000..358bba23deeb
--- /dev/null
+++ b/sound/firewire/fireface/ff.c
@@ -0,0 +1,113 @@
+/*
+ * ff.c - a part of driver for RME Fireface series
+ *
+ * Copyright (c) 2015-2017 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "ff.h"
+
+#define OUI_RME	0x000a35
+
+MODULE_DESCRIPTION("RME Fireface series Driver");
+MODULE_AUTHOR("Takashi Sakamoto <o-takashi@sakamocchi.jp>");
+MODULE_LICENSE("GPL v2");
+
+static void name_card(struct snd_ff *ff)
+{
+	struct fw_device *fw_dev = fw_parent_device(ff->unit);
+	const char *const model = "Fireface Skeleton";
+
+	strcpy(ff->card->driver, "Fireface");
+	strcpy(ff->card->shortname, model);
+	strcpy(ff->card->mixername, model);
+	snprintf(ff->card->longname, sizeof(ff->card->longname),
+		 "RME %s, GUID %08x%08x at %s, S%d", model,
+		 fw_dev->config_rom[3], fw_dev->config_rom[4],
+		 dev_name(&ff->unit->device), 100 << fw_dev->max_speed);
+}
+
+static void ff_card_free(struct snd_card *card)
+{
+	struct snd_ff *ff = card->private_data;
+
+	fw_unit_put(ff->unit);
+
+	mutex_destroy(&ff->mutex);
+}
+
+static int snd_ff_probe(struct fw_unit *unit,
+			   const struct ieee1394_device_id *entry)
+{
+	struct snd_card *card;
+	struct snd_ff *ff;
+	int err;
+
+	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
+			   sizeof(struct snd_ff), &card);
+	if (err < 0)
+		return err;
+	card->private_free = ff_card_free;
+
+	/* initialize myself */
+	ff = card->private_data;
+	ff->card = card;
+	ff->unit = fw_unit_get(unit);
+	dev_set_drvdata(&unit->device, ff);
+
+	mutex_init(&ff->mutex);
+
+	name_card(ff);
+
+	err = snd_card_register(card);
+	if (err < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	return 0;
+}
+
+static void snd_ff_update(struct fw_unit *unit)
+{
+	return;
+}
+
+static void snd_ff_remove(struct fw_unit *unit)
+{
+	struct snd_ff *ff = dev_get_drvdata(&unit->device);
+
+	/* No need to wait for releasing card object in this context. */
+	snd_card_free_when_closed(ff->card);
+}
+
+static const struct ieee1394_device_id snd_ff_id_table[] = {
+	{}
+};
+MODULE_DEVICE_TABLE(ieee1394, snd_ff_id_table);
+
+static struct fw_driver ff_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "snd-fireface",
+		.bus	= &fw_bus_type,
+	},
+	.probe    = snd_ff_probe,
+	.update   = snd_ff_update,
+	.remove   = snd_ff_remove,
+	.id_table = snd_ff_id_table,
+};
+
+static int __init snd_ff_init(void)
+{
+	return driver_register(&ff_driver.driver);
+}
+
+static void __exit snd_ff_exit(void)
+{
+	driver_unregister(&ff_driver.driver);
+}
+
+module_init(snd_ff_init);
+module_exit(snd_ff_exit);
