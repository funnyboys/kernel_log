commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 2ad692dd4b13..90288b4b4637 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * tascam-transaction.c - a part of driver for TASCAM FireWire series
  *
  * Copyright (c) 2015 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "tascam.h"

commit 6aa7de059173a986114ac43b8f50b297a86f09a8
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Oct 23 14:07:29 2017 -0700

    locking/atomics: COCCINELLE/treewide: Convert trivial ACCESS_ONCE() patterns to READ_ONCE()/WRITE_ONCE()
    
    Please do not apply this to mainline directly, instead please re-run the
    coccinelle script shown below and apply its output.
    
    For several reasons, it is desirable to use {READ,WRITE}_ONCE() in
    preference to ACCESS_ONCE(), and new code is expected to use one of the
    former. So far, there's been no reason to change most existing uses of
    ACCESS_ONCE(), as these aren't harmful, and changing them results in
    churn.
    
    However, for some features, the read/write distinction is critical to
    correct operation. To distinguish these cases, separate read/write
    accessors must be used. This patch migrates (most) remaining
    ACCESS_ONCE() instances to {READ,WRITE}_ONCE(), using the following
    coccinelle script:
    
    ----
    // Convert trivial ACCESS_ONCE() uses to equivalent READ_ONCE() and
    // WRITE_ONCE()
    
    // $ make coccicheck COCCI=/home/mark/once.cocci SPFLAGS="--include-headers" MODE=patch
    
    virtual patch
    
    @ depends on patch @
    expression E1, E2;
    @@
    
    - ACCESS_ONCE(E1) = E2
    + WRITE_ONCE(E1, E2)
    
    @ depends on patch @
    expression E;
    @@
    
    - ACCESS_ONCE(E)
    + READ_ONCE(E)
    ----
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: davem@davemloft.net
    Cc: linux-arch@vger.kernel.org
    Cc: mpe@ellerman.id.au
    Cc: shuah@kernel.org
    Cc: snitzer@redhat.com
    Cc: thor.thayer@linux.intel.com
    Cc: tj@kernel.org
    Cc: viro@zeniv.linux.org.uk
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1508792849-3115-19-git-send-email-paulmck@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 8967c52f5032..2ad692dd4b13 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -148,7 +148,7 @@ static void async_midi_port_callback(struct fw_card *card, int rcode,
 				     void *callback_data)
 {
 	struct snd_fw_async_midi_port *port = callback_data;
-	struct snd_rawmidi_substream *substream = ACCESS_ONCE(port->substream);
+	struct snd_rawmidi_substream *substream = READ_ONCE(port->substream);
 
 	/* This port is closed. */
 	if (substream == NULL)
@@ -173,7 +173,7 @@ static void midi_port_work(struct work_struct *work)
 {
 	struct snd_fw_async_midi_port *port =
 			container_of(work, struct snd_fw_async_midi_port, work);
-	struct snd_rawmidi_substream *substream = ACCESS_ONCE(port->substream);
+	struct snd_rawmidi_substream *substream = READ_ONCE(port->substream);
 	int generation;
 
 	/* Under transacting or error state. */
@@ -282,7 +282,7 @@ static void handle_midi_tx(struct fw_card *card, struct fw_request *request,
 				bytes = 3;
 		}
 
-		substream = ACCESS_ONCE(tscm->tx_midi_substreams[port]);
+		substream = READ_ONCE(tscm->tx_midi_substreams[port]);
 		if (substream != NULL)
 			snd_rawmidi_receive(substream, b + 1, bytes);
 	}

commit 1f94205d2225339c77e64d5872ec575ee2815720
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 14 16:46:31 2017 +0900

    ALSA: firewire-tascam: move message parameters for async midi port
    
    Units on TASCAM FireWire series handle MIDI messages with support for
    running status. Drivers for the series should remember current running
    status and transfer valid MIDI messages. For this purpose, current
    ALSA driver for the series has some members in its top-level structure.
    This is due to better abstraction of async midi port. Nowadays, the
    abstraction was localized just for the driver.
    
    This commit moves the members to structure for async midi port.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index a248a4ae0353..8967c52f5032 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -58,39 +58,38 @@ static inline int calculate_message_bytes(u8 status)
 	return -EINVAL;
 }
 
-static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
+static int fill_message(struct snd_fw_async_midi_port *port,
+			struct snd_rawmidi_substream *substream)
 {
-	struct snd_tscm *tscm = substream->rmidi->private_data;
-	unsigned int port = substream->number;
 	int i, len, consume;
 	u8 *label, *msg;
 	u8 status;
 
 	/* The first byte is used for label, the rest for MIDI bytes. */
-	label = buf;
-	msg = buf + 1;
+	label = port->buf;
+	msg = port->buf + 1;
 
 	consume = snd_rawmidi_transmit_peek(substream, msg, 3);
 	if (consume == 0)
 		return 0;
 
 	/* On exclusive message. */
-	if (tscm->on_sysex[port]) {
+	if (port->on_sysex) {
 		/* Seek the end of exclusives. */
 		for (i = 0; i < consume; ++i) {
 			if (msg[i] == 0xf7) {
-				tscm->on_sysex[port] = false;
+				port->on_sysex = false;
 				break;
 			}
 		}
 
 		/* At the end of exclusive message, use label 0x07. */
-		if (!tscm->on_sysex[port]) {
+		if (!port->on_sysex) {
 			consume = i + 1;
-			*label = (port << 4) | 0x07;
+			*label = (substream->number << 4) | 0x07;
 		/* During exclusive message, use label 0x04. */
 		} else if (consume == 3) {
-			*label = (port << 4) | 0x04;
+			*label = (substream->number << 4) | 0x04;
 		/* We need to fill whole 3 bytes. Go to next change. */
 		} else {
 			return 0;
@@ -101,12 +100,12 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 		/* The beginning of exclusives. */
 		if (msg[0] == 0xf0) {
 			/* Transfer it in next chance in another condition. */
-			tscm->on_sysex[port] = true;
+			port->on_sysex = true;
 			return 0;
 		} else {
 			/* On running-status. */
 			if ((msg[0] & 0x80) != 0x80)
-				status = tscm->running_status[port];
+				status = port->running_status;
 			else
 				status = msg[0];
 
@@ -124,18 +123,18 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 
 				msg[2] = msg[1];
 				msg[1] = msg[0];
-				msg[0] = tscm->running_status[port];
+				msg[0] = port->running_status;
 			} else {
 				/* Enough MIDI bytes were not retrieved. */
 				if (consume < len)
 					return 0;
 				consume = len;
 
-				tscm->running_status[port] = msg[0];
+				port->running_status = msg[0];
 			}
 		}
 
-		*label = (port << 4) | (msg[0] >> 4);
+		*label = (substream->number << 4) | (msg[0] >> 4);
 	}
 
 	if (len > 0 && len < 3)
@@ -196,7 +195,7 @@ static void midi_port_work(struct work_struct *work)
 	 * Later, snd_rawmidi_transmit_ack() is called.
 	 */
 	memset(port->buf, 0, 4);
-	port->consume_bytes = fill_message(substream, port->buf);
+	port->consume_bytes = fill_message(port, substream);
 	if (port->consume_bytes <= 0) {
 		/* Do it in next chance, immediately. */
 		if (port->consume_bytes == 0) {
@@ -240,6 +239,8 @@ void snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port)
 {
 	port->idling = true;
 	port->error = false;
+	port->running_status = 0;
+	port->on_sysex = false;
 }
 
 static void handle_midi_tx(struct fw_card *card, struct fw_request *request,

commit 3e7dc65ca001a6e40e78b912c6146ec013a3b49a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 14 16:46:30 2017 +0900

    ALSA: firewire-tascam: initialize parameters at open of rawmidi character devices
    
    In current design of ALSA driver for TASCAM FireWire series, initialization
    of members in asymc midi port structure is done at device probing. Some of
    the members should be initialized every time to use rawmidi devices because
    they're changed in sequence of transmission for MIDI messages.
    
    This commit adds a new function to initialize them. Invariant parameters
    during object lifetime are kept as is.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 248afe663387..a248a4ae0353 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -236,17 +236,10 @@ static void midi_port_work(struct work_struct *work)
 			port);
 }
 
-int snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port,
-		struct fw_unit *unit)
+void snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port)
 {
-	port->parent = fw_parent_device(unit);
 	port->idling = true;
-	port->next_ktime = 0;
 	port->error = false;
-
-	INIT_WORK(&port->work, midi_port_work);
-
-	return 0;
 }
 
 static void handle_midi_tx(struct fw_card *card, struct fw_request *request,
@@ -324,10 +317,9 @@ int snd_tscm_transaction_register(struct snd_tscm *tscm)
 		goto error;
 
 	for (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++) {
-		err = snd_fw_async_midi_port_init(
-				&tscm->out_ports[i], tscm->unit);
-		if (err < 0)
-			goto error;
+		tscm->out_ports[i].parent = fw_parent_device(tscm->unit);
+		tscm->out_ports[i].next_ktime = 0;
+		INIT_WORK(&tscm->out_ports[i].work, midi_port_work);
 	}
 
 	return err;

commit 98a00d3602a1c50a397893c5de26dbbe7d77804a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 14 16:46:29 2017 +0900

    ALSA: firewire-tascam: use fixed-length array for message cache to async midi port
    
    ALSA driver for TASCAM FireWire series internally allocates 4 byte buffer
    for asynchronous transaction to transfer MIDI messages. However, the buffer
    can be allocated with memory object of parent structure.
    
    This commit adds 4 byte array as a member of the structure and obsoletes
    the redundant allocation. This is deallocated with memory object of parent
    structure.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 4e362b83d8e8..248afe663387 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -239,10 +239,6 @@ static void midi_port_work(struct work_struct *work)
 int snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port,
 		struct fw_unit *unit)
 {
-	port->buf = kzalloc(4, GFP_KERNEL);
-	if (port->buf == NULL)
-		return -ENOMEM;
-
 	port->parent = fw_parent_device(unit);
 	port->idling = true;
 	port->next_ktime = 0;
@@ -253,13 +249,6 @@ int snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port,
 	return 0;
 }
 
-void snd_fw_async_midi_port_destroy(struct snd_fw_async_midi_port *port)
-{
-	snd_fw_async_midi_port_finish(port);
-	cancel_work_sync(&port->work);
-	kfree(port->buf);
-}
-
 static void handle_midi_tx(struct fw_card *card, struct fw_request *request,
 			   int tcode, int destination, int source,
 			   int generation, unsigned long long offset,
@@ -389,7 +378,6 @@ int snd_tscm_transaction_reregister(struct snd_tscm *tscm)
 void snd_tscm_transaction_unregister(struct snd_tscm *tscm)
 {
 	__be32 reg;
-	unsigned int i;
 
 	if (tscm->async_handler.callback_data == NULL)
 		return;
@@ -416,7 +404,4 @@ void snd_tscm_transaction_unregister(struct snd_tscm *tscm)
 
 	fw_core_remove_address_handler(&tscm->async_handler);
 	tscm->async_handler.callback_data = NULL;
-
-	for (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++)
-		snd_fw_async_midi_port_destroy(&tscm->out_ports[i]);
 }

commit 27badc4c10da29b884f1ac7cc9ce13e849ce8be4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 14 16:46:28 2017 +0900

    ALSA: firewire-tascam: use the same address for asynchronous transaction for MIDI message
    
    Units on TASCAM FireWire series receive MIDI messages by asynchronous
    transactions on IEEE 1394 bus. Although the transaction is sent to a
    certain register, current ALSA driver for this series has a redundant design.
    
    This commit use the same address for the transaction.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 2f5e20cf4ce5..4e362b83d8e8 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -230,20 +230,20 @@ static void midi_port_work(struct work_struct *work)
 	fw_send_request(port->parent->card, &port->transaction,
 			TCODE_WRITE_QUADLET_REQUEST,
 			port->parent->node_id, generation,
-			port->parent->max_speed, port->addr,
+			port->parent->max_speed,
+			TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_RX_QUAD,
 			port->buf, 4, async_midi_port_callback,
 			port);
 }
 
 int snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port,
-		struct fw_unit *unit, u64 addr)
+		struct fw_unit *unit)
 {
 	port->buf = kzalloc(4, GFP_KERNEL);
 	if (port->buf == NULL)
 		return -ENOMEM;
 
 	port->parent = fw_parent_device(unit);
-	port->addr = addr;
 	port->idling = true;
 	port->next_ktime = 0;
 	port->error = false;
@@ -336,8 +336,7 @@ int snd_tscm_transaction_register(struct snd_tscm *tscm)
 
 	for (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++) {
 		err = snd_fw_async_midi_port_init(
-				&tscm->out_ports[i], tscm->unit,
-				TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_RX_QUAD);
+				&tscm->out_ports[i], tscm->unit);
 		if (err < 0)
 			goto error;
 	}

commit 38d5826142496a6e0c21fa3fdb48fa910008c159
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 14 16:46:27 2017 +0900

    ALSA: firewire-tascam: send fixed-length transaction for async midi port
    
    TASCAM FireWire series uses asynchronous transactions with fixed length
    payload for MIDI messaging. On the other hand, ALSA driver for the series
    has a redundant design to handle different length of payload.
    
    This commit removes the redundant abstraction.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index dcbc0033a3ad..2f5e20cf4ce5 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -176,7 +176,6 @@ static void midi_port_work(struct work_struct *work)
 			container_of(work, struct snd_fw_async_midi_port, work);
 	struct snd_rawmidi_substream *substream = ACCESS_ONCE(port->substream);
 	int generation;
-	int type;
 
 	/* Under transacting or error state. */
 	if (!port->idling || port->error)
@@ -196,7 +195,7 @@ static void midi_port_work(struct work_struct *work)
 	 * Fill the buffer. The callee must use snd_rawmidi_transmit_peek().
 	 * Later, snd_rawmidi_transmit_ack() is called.
 	 */
-	memset(port->buf, 0, port->len);
+	memset(port->buf, 0, 4);
 	port->consume_bytes = fill_message(substream, port->buf);
 	if (port->consume_bytes <= 0) {
 		/* Do it in next chance, immediately. */
@@ -210,12 +209,6 @@ static void midi_port_work(struct work_struct *work)
 		return;
 	}
 
-	/* Calculate type of transaction. */
-	if (port->len == 4)
-		type = TCODE_WRITE_QUADLET_REQUEST;
-	else
-		type = TCODE_WRITE_BLOCK_REQUEST;
-
 	/* Set interval to next transaction. */
 	port->next_ktime = ktime_add_ns(ktime_get(),
 				port->consume_bytes * 8 * NSEC_PER_SEC / 31250);
@@ -234,18 +227,18 @@ static void midi_port_work(struct work_struct *work)
 	generation = port->parent->generation;
 	smp_rmb();
 
-	fw_send_request(port->parent->card, &port->transaction, type,
+	fw_send_request(port->parent->card, &port->transaction,
+			TCODE_WRITE_QUADLET_REQUEST,
 			port->parent->node_id, generation,
 			port->parent->max_speed, port->addr,
-			port->buf, port->len, async_midi_port_callback,
+			port->buf, 4, async_midi_port_callback,
 			port);
 }
 
 int snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port,
-		struct fw_unit *unit, u64 addr, unsigned int len)
+		struct fw_unit *unit, u64 addr)
 {
-	port->len = DIV_ROUND_UP(len, 4) * 4;
-	port->buf = kzalloc(port->len, GFP_KERNEL);
+	port->buf = kzalloc(4, GFP_KERNEL);
 	if (port->buf == NULL)
 		return -ENOMEM;
 
@@ -344,8 +337,7 @@ int snd_tscm_transaction_register(struct snd_tscm *tscm)
 	for (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++) {
 		err = snd_fw_async_midi_port_init(
 				&tscm->out_ports[i], tscm->unit,
-				TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_RX_QUAD,
-				4);
+				TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_RX_QUAD);
 		if (err < 0)
 			goto error;
 	}

commit 9bae2150d0144e0be423367e5385442141979213
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 14 16:46:26 2017 +0900

    ALSA: firewire-tascam: remove callback function from async midi port
    
    As a result of localization of async midi port, ALSA driver for TASCAM
    FireWire series can call helper function directly instead of callback
    registration.
    
    This commit removes the redundant design.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 8ba006e456e8..dcbc0033a3ad 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -197,7 +197,7 @@ static void midi_port_work(struct work_struct *work)
 	 * Later, snd_rawmidi_transmit_ack() is called.
 	 */
 	memset(port->buf, 0, port->len);
-	port->consume_bytes = port->fill(substream, port->buf);
+	port->consume_bytes = fill_message(substream, port->buf);
 	if (port->consume_bytes <= 0) {
 		/* Do it in next chance, immediately. */
 		if (port->consume_bytes == 0) {
@@ -242,8 +242,7 @@ static void midi_port_work(struct work_struct *work)
 }
 
 int snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port,
-		struct fw_unit *unit, u64 addr, unsigned int len,
-		snd_fw_async_midi_port_fill fill)
+		struct fw_unit *unit, u64 addr, unsigned int len)
 {
 	port->len = DIV_ROUND_UP(len, 4) * 4;
 	port->buf = kzalloc(port->len, GFP_KERNEL);
@@ -252,7 +251,6 @@ int snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port,
 
 	port->parent = fw_parent_device(unit);
 	port->addr = addr;
-	port->fill = fill;
 	port->idling = true;
 	port->next_ktime = 0;
 	port->error = false;
@@ -347,7 +345,7 @@ int snd_tscm_transaction_register(struct snd_tscm *tscm)
 		err = snd_fw_async_midi_port_init(
 				&tscm->out_ports[i], tscm->unit,
 				TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_RX_QUAD,
-				4, fill_message);
+				4);
 		if (err < 0)
 			goto error;
 	}

commit 531f471834227d0321110c071ea352bb14aca36d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 14 16:46:25 2017 +0900

    ALSA: firewire-lib/firewire-tascam: localize async midi port
    
    In Linux kernel 4.4, firewire-lib got a feature called as 'async midi port'
    for transmission of MIDI message via IEEE 1394 asynchronous communication,
    however actual consumer of this feature is ALSA driver for TASCAM FireWire
    series only. When adding this feature, I assumed that ALSA driver for
    Digi00x might also be a consumer, actually it's not.
    
    This commit moves the feature from firewire-lib to firewire-tascam module.
    Two minor kernel APIs are removed.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 040a96d1ba8e..8ba006e456e8 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -144,6 +144,131 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 	return consume;
 }
 
+static void async_midi_port_callback(struct fw_card *card, int rcode,
+				     void *data, size_t length,
+				     void *callback_data)
+{
+	struct snd_fw_async_midi_port *port = callback_data;
+	struct snd_rawmidi_substream *substream = ACCESS_ONCE(port->substream);
+
+	/* This port is closed. */
+	if (substream == NULL)
+		return;
+
+	if (rcode == RCODE_COMPLETE)
+		snd_rawmidi_transmit_ack(substream, port->consume_bytes);
+	else if (!rcode_is_permanent_error(rcode))
+		/* To start next transaction immediately for recovery. */
+		port->next_ktime = 0;
+	else
+		/* Don't continue processing. */
+		port->error = true;
+
+	port->idling = true;
+
+	if (!snd_rawmidi_transmit_empty(substream))
+		schedule_work(&port->work);
+}
+
+static void midi_port_work(struct work_struct *work)
+{
+	struct snd_fw_async_midi_port *port =
+			container_of(work, struct snd_fw_async_midi_port, work);
+	struct snd_rawmidi_substream *substream = ACCESS_ONCE(port->substream);
+	int generation;
+	int type;
+
+	/* Under transacting or error state. */
+	if (!port->idling || port->error)
+		return;
+
+	/* Nothing to do. */
+	if (substream == NULL || snd_rawmidi_transmit_empty(substream))
+		return;
+
+	/* Do it in next chance. */
+	if (ktime_after(port->next_ktime, ktime_get())) {
+		schedule_work(&port->work);
+		return;
+	}
+
+	/*
+	 * Fill the buffer. The callee must use snd_rawmidi_transmit_peek().
+	 * Later, snd_rawmidi_transmit_ack() is called.
+	 */
+	memset(port->buf, 0, port->len);
+	port->consume_bytes = port->fill(substream, port->buf);
+	if (port->consume_bytes <= 0) {
+		/* Do it in next chance, immediately. */
+		if (port->consume_bytes == 0) {
+			port->next_ktime = 0;
+			schedule_work(&port->work);
+		} else {
+			/* Fatal error. */
+			port->error = true;
+		}
+		return;
+	}
+
+	/* Calculate type of transaction. */
+	if (port->len == 4)
+		type = TCODE_WRITE_QUADLET_REQUEST;
+	else
+		type = TCODE_WRITE_BLOCK_REQUEST;
+
+	/* Set interval to next transaction. */
+	port->next_ktime = ktime_add_ns(ktime_get(),
+				port->consume_bytes * 8 * NSEC_PER_SEC / 31250);
+
+	/* Start this transaction. */
+	port->idling = false;
+
+	/*
+	 * In Linux FireWire core, when generation is updated with memory
+	 * barrier, node id has already been updated. In this module, After
+	 * this smp_rmb(), load/store instructions to memory are completed.
+	 * Thus, both of generation and node id are available with recent
+	 * values. This is a light-serialization solution to handle bus reset
+	 * events on IEEE 1394 bus.
+	 */
+	generation = port->parent->generation;
+	smp_rmb();
+
+	fw_send_request(port->parent->card, &port->transaction, type,
+			port->parent->node_id, generation,
+			port->parent->max_speed, port->addr,
+			port->buf, port->len, async_midi_port_callback,
+			port);
+}
+
+int snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port,
+		struct fw_unit *unit, u64 addr, unsigned int len,
+		snd_fw_async_midi_port_fill fill)
+{
+	port->len = DIV_ROUND_UP(len, 4) * 4;
+	port->buf = kzalloc(port->len, GFP_KERNEL);
+	if (port->buf == NULL)
+		return -ENOMEM;
+
+	port->parent = fw_parent_device(unit);
+	port->addr = addr;
+	port->fill = fill;
+	port->idling = true;
+	port->next_ktime = 0;
+	port->error = false;
+
+	INIT_WORK(&port->work, midi_port_work);
+
+	return 0;
+}
+
+void snd_fw_async_midi_port_destroy(struct snd_fw_async_midi_port *port)
+{
+	snd_fw_async_midi_port_finish(port);
+	cancel_work_sync(&port->work);
+	kfree(port->buf);
+}
+
 static void handle_midi_tx(struct fw_card *card, struct fw_request *request,
 			   int tcode, int destination, int source,
 			   int generation, unsigned long long offset,

commit 5d2560a427fc7c4050a320be62c4994705ca81b1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Feb 5 09:56:05 2016 +0900

    ALSA: firewire-tascam: fix NULL pointer dereference when model identification fails
    
    When unsupported models are connected, snd-firewire-tascam module causes
    NULL pointer dereference in fw_core_remove_address_handler() (due to
    list_del_rcu()).
    
    This commit prevents this bug.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 904ce0329fa1..040a96d1ba8e 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -230,6 +230,7 @@ int snd_tscm_transaction_register(struct snd_tscm *tscm)
 	return err;
 error:
 	fw_core_remove_address_handler(&tscm->async_handler);
+	tscm->async_handler.callback_data = NULL;
 	return err;
 }
 
@@ -276,6 +277,9 @@ void snd_tscm_transaction_unregister(struct snd_tscm *tscm)
 	__be32 reg;
 	unsigned int i;
 
+	if (tscm->async_handler.callback_data == NULL)
+		return;
+
 	/* Turn off FireWire LED. */
 	reg = cpu_to_be32(0x0000008e);
 	snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
@@ -297,6 +301,8 @@ void snd_tscm_transaction_unregister(struct snd_tscm *tscm)
 			   &reg, sizeof(reg), 0);
 
 	fw_core_remove_address_handler(&tscm->async_handler);
+	tscm->async_handler.callback_data = NULL;
+
 	for (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++)
 		snd_fw_async_midi_port_destroy(&tscm->out_ports[i]);
 }

commit f937b43d48f1080e39de723d15680b2ad5d7e6fd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Oct 20 23:46:59 2015 +0900

    ALSA: firewire-tascam: clear extra MIDI bytes in an asynchronous transaction
    
    When MIDI buffer stores two or more MIDI messages, TASCAM driver
    transfers asynchronous transactions including one MIDI message and
    extra bytes from second MIDI message.
    
    This commit fixes this bug by clearing needless bytes in the buffer. The
    consumed bytes are already calculated correctly, thus the sequence of
    transactions is already correct.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 99098aa2391e..904ce0329fa1 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -93,8 +93,10 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 			*label = (port << 4) | 0x04;
 		/* We need to fill whole 3 bytes. Go to next change. */
 		} else {
-			consume = 0;
+			return 0;
 		}
+
+		len = consume;
 	} else {
 		/* The beginning of exclusives. */
 		if (msg[0] == 0xf0) {
@@ -115,24 +117,30 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 
 			/* On running-status. */
 			if ((msg[0] & 0x80) != 0x80) {
+				/* Enough MIDI bytes were not retrieved. */
+				if (consume < len - 1)
+					return 0;
+				consume = len - 1;
+
 				msg[2] = msg[1];
 				msg[1] = msg[0];
 				msg[0] = tscm->running_status[port];
-				consume--;
 			} else {
+				/* Enough MIDI bytes were not retrieved. */
+				if (consume < len)
+					return 0;
+				consume = len;
+
 				tscm->running_status[port] = msg[0];
 			}
-
-			/* Confirm length. */
-			if (consume < len)
-				return 0;
-			if (consume > len)
-				consume = len;
 		}
 
 		*label = (port << 4) | (msg[0] >> 4);
 	}
 
+	if (len > 0 && len < 3)
+		memset(msg + len, 0, 3 - len);
+
 	return consume;
 }
 

commit 123990e930ac1213df2dfa0e2d57cfc0e1dd5e02
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Oct 20 23:46:58 2015 +0900

    ALSA: firewire-tascam: fix loop condition with some readable variables
    
    In transactions for MIDI messages, the first byte is used for label and
    the rest is for MIDI bytes. In current code, these are handled correctly,
    while there's a small mistake for loop condition to include meaningless
    statement.
    
    This commit adds two local variables for them and improve the loop
    condition.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index ea88655e7e08..99098aa2391e 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -63,17 +63,22 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 	struct snd_tscm *tscm = substream->rmidi->private_data;
 	unsigned int port = substream->number;
 	int i, len, consume;
+	u8 *label, *msg;
 	u8 status;
 
-	consume = snd_rawmidi_transmit_peek(substream, buf + 1, 3);
+	/* The first byte is used for label, the rest for MIDI bytes. */
+	label = buf;
+	msg = buf + 1;
+
+	consume = snd_rawmidi_transmit_peek(substream, msg, 3);
 	if (consume == 0)
 		return 0;
 
 	/* On exclusive message. */
 	if (tscm->on_sysex[port]) {
 		/* Seek the end of exclusives. */
-		for (i = 1; i < 4 || i < consume; ++i) {
-			if (buf[i] == 0xf7) {
+		for (i = 0; i < consume; ++i) {
+			if (msg[i] == 0xf7) {
 				tscm->on_sysex[port] = false;
 				break;
 			}
@@ -81,27 +86,27 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 
 		/* At the end of exclusive message, use label 0x07. */
 		if (!tscm->on_sysex[port]) {
-			consume = i;
-			buf[0] = (port << 4) | 0x07;
+			consume = i + 1;
+			*label = (port << 4) | 0x07;
 		/* During exclusive message, use label 0x04. */
 		} else if (consume == 3) {
-			buf[0] = (port << 4) | 0x04;
+			*label = (port << 4) | 0x04;
 		/* We need to fill whole 3 bytes. Go to next change. */
 		} else {
 			consume = 0;
 		}
 	} else {
 		/* The beginning of exclusives. */
-		if (buf[1] == 0xf0) {
+		if (msg[0] == 0xf0) {
 			/* Transfer it in next chance in another condition. */
 			tscm->on_sysex[port] = true;
 			return 0;
 		} else {
 			/* On running-status. */
-			if ((buf[1] & 0x80) != 0x80)
+			if ((msg[0] & 0x80) != 0x80)
 				status = tscm->running_status[port];
 			else
-				status = buf[1];
+				status = msg[0];
 
 			/* Calculate consume bytes. */
 			len = calculate_message_bytes(status);
@@ -109,13 +114,13 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 				return 0;
 
 			/* On running-status. */
-			if ((buf[1] & 0x80) != 0x80) {
-				buf[3] = buf[2];
-				buf[2] = buf[1];
-				buf[1] = tscm->running_status[port];
+			if ((msg[0] & 0x80) != 0x80) {
+				msg[2] = msg[1];
+				msg[1] = msg[0];
+				msg[0] = tscm->running_status[port];
 				consume--;
 			} else {
-				tscm->running_status[port] = buf[1];
+				tscm->running_status[port] = msg[0];
 			}
 
 			/* Confirm length. */
@@ -125,7 +130,7 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 				consume = len;
 		}
 
-		buf[0] = (port << 4) | (buf[1] >> 4);
+		*label = (port << 4) | (msg[0] >> 4);
 	}
 
 	return consume;

commit b7ab614f301741ae3cb61fb6a90e290083d3b95d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Oct 20 23:46:57 2015 +0900

    ALSA: firewire-tascam: use better name for local variables to describe their intension
    
    In the callback function of asynchronous MIDI port, the intension of some
    local variables are not clear.
    
    This commit improves them. The 'len' variable is used to calculate the
    number of MIDI bytes including in the transaction. The 'consume' variable
    is used to return the actual number of consumed bytes in ALSA MIDI buffer.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 7c8068469f57..ea88655e7e08 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -65,14 +65,14 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 	int i, len, consume;
 	u8 status;
 
-	len = snd_rawmidi_transmit_peek(substream, buf + 1, 3);
-	if (len == 0)
+	consume = snd_rawmidi_transmit_peek(substream, buf + 1, 3);
+	if (consume == 0)
 		return 0;
 
 	/* On exclusive message. */
 	if (tscm->on_sysex[port]) {
 		/* Seek the end of exclusives. */
-		for (i = 1; i < 4 || i < len; ++i) {
+		for (i = 1; i < 4 || i < consume; ++i) {
 			if (buf[i] == 0xf7) {
 				tscm->on_sysex[port] = false;
 				break;
@@ -81,14 +81,14 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 
 		/* At the end of exclusive message, use label 0x07. */
 		if (!tscm->on_sysex[port]) {
-			len = i;
+			consume = i;
 			buf[0] = (port << 4) | 0x07;
 		/* During exclusive message, use label 0x04. */
-		} else if (len == 3) {
+		} else if (consume == 3) {
 			buf[0] = (port << 4) | 0x04;
 		/* We need to fill whole 3 bytes. Go to next change. */
 		} else {
-			len = 0;
+			consume = 0;
 		}
 	} else {
 		/* The beginning of exclusives. */
@@ -104,8 +104,8 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 				status = buf[1];
 
 			/* Calculate consume bytes. */
-			consume = calculate_message_bytes(status);
-			if (consume <= 0)
+			len = calculate_message_bytes(status);
+			if (len <= 0)
 				return 0;
 
 			/* On running-status. */
@@ -119,16 +119,16 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 			}
 
 			/* Confirm length. */
-			if (len < consume)
+			if (consume < len)
 				return 0;
-			if (len > consume)
-				len = consume;
+			if (consume > len)
+				consume = len;
 		}
 
 		buf[0] = (port << 4) | (buf[1] >> 4);
 	}
 
-	return len;
+	return consume;
 }
 
 static void handle_midi_tx(struct fw_card *card, struct fw_request *request,

commit 516a30615635fdec6a298d7b7cedca1270bc641c
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Oct 20 23:46:56 2015 +0900

    ALSA: firewire-tascam: change type of valiables according to function prototype
    
    In the callback function of asynchronous MIDI port, some local variables
    are declared 'unsigned int', while they're assigned to int value of return
    from snd_rawmidi_transmit_peek().
    
    This commit fixes the type.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 370f9323b3df..7c8068469f57 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -62,10 +62,8 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 {
 	struct snd_tscm *tscm = substream->rmidi->private_data;
 	unsigned int port = substream->number;
-	unsigned int len;
-	unsigned int i;
+	int i, len, consume;
 	u8 status;
-	int consume;
 
 	len = snd_rawmidi_transmit_peek(substream, buf + 1, 3);
 	if (len == 0)

commit 9f9c5617c8f7dfd1190c438894a8701db25f171f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Oct 20 23:46:55 2015 +0900

    ALSA: firewire-tascam: remove buffer initialization in driver side
    
    The given buffer to callback function is cleared in caller side.
    
    This commit removes buffer initialization in callee side.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index d4f64ae182e7..370f9323b3df 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -67,8 +67,6 @@ static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
 	u8 status;
 	int consume;
 
-	buf[0] = buf[1] = buf[2] = buf[3] = 0x00;
-
 	len = snd_rawmidi_transmit_peek(substream, buf + 1, 3);
 	if (len == 0)
 		return 0;

commit 724097059a8e5df1aa162d153b8f90b0ffbb82dc
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Oct 15 21:17:11 2015 +0300

    ALSA: firewire-tascam: off by one in handle_midi_tx()
    
    My static checker complains because tscm->spec->midi_capture_ports is
    either 2 or 4 but the tscm->tx_midi_substreams[] array has 4 elements so
    this is possibly off by one.  I have looked at the code and I think it
    should be >= instead of > as well.
    
    Fixes: 107cc0129a68 ('ALSA: firewire-tascam: add support for incoming MIDI messages by asynchronous transaction')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 45c3ce3d6020..d4f64ae182e7 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -158,7 +158,7 @@ static void handle_midi_tx(struct fw_card *card, struct fw_request *request,
 
 		port = b[0] >> 4;
 		/* TODO: support virtual MIDI ports. */
-		if (port > tscm->spec->midi_capture_ports)
+		if (port >= tscm->spec->midi_capture_ports)
 			goto end;
 
 		/* Assume the message length. */

commit 69ec98d7e5661a1c98ec51c26d6e91af3bbe0e72
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Oct 15 21:16:30 2015 +0300

    ALSA: firewire-tascam: fix an LED bug
    
    We recently tried to add some new code to support turning the LED on and
    off but the code in snd_tscm_transaction_reregister() is unreachable.
    
    Fixes: e65e2cb99e44 ('ALSA: firewire-tascam: Turn on/off FireWire LED')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 1c9a88be55c8..45c3ce3d6020 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -249,7 +249,7 @@ int snd_tscm_transaction_reregister(struct snd_tscm *tscm)
 
 	/* Turn on messaging. */
 	reg = cpu_to_be32(0x00000001);
-	return snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
+	err = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
 				  TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,
 				  &reg, sizeof(reg), 0);
 	if (err < 0)

commit e65e2cb99e44704f63b76e4395092b0533bef88b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 12 19:10:24 2015 +0900

    ALSA: firewire-tascam: Turn on/off FireWire LED
    
    TASCAM FireWire series has some LEDs on its surface. These LEDs can be
    turned on/off by receiving asynchronous transactions to a certain
    address. One of the LEDs is labels as 'FireWire'. It's better to light it
    up when this driver starts to work. Besides, the LED for 'FireWire' is
    turned off at bus reset.
    
    This commit implements this idea.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 6b74fb5e5fd7..1c9a88be55c8 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -252,6 +252,14 @@ int snd_tscm_transaction_reregister(struct snd_tscm *tscm)
 	return snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
 				  TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,
 				  &reg, sizeof(reg), 0);
+	if (err < 0)
+		return err;
+
+	/* Turn on FireWire LED. */
+	reg = cpu_to_be32(0x0001008e);
+	return snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
+				  TSCM_ADDR_BASE + TSCM_OFFSET_LED_POWER,
+				  &reg, sizeof(reg), 0);
 }
 
 void snd_tscm_transaction_unregister(struct snd_tscm *tscm)
@@ -259,6 +267,12 @@ void snd_tscm_transaction_unregister(struct snd_tscm *tscm)
 	__be32 reg;
 	unsigned int i;
 
+	/* Turn off FireWire LED. */
+	reg = cpu_to_be32(0x0000008e);
+	snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
+			   TSCM_ADDR_BASE + TSCM_OFFSET_LED_POWER,
+			   &reg, sizeof(reg), 0);
+
 	/* Turn off messaging. */
 	reg = cpu_to_be32(0x00000000);
 	snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,

commit 3beab0f844fadefe16b6383f6ff7b76147db686b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 12 19:10:22 2015 +0900

    ALSA: firewire-tascam: add support for outgoing MIDI messages by asynchronous transaction
    
    TASCAM FireWire series use asynchronous transaction to receive MIDI
    messages. The transaction should be sent to a certain address.
    
    This commit supports the outgoing MIDI messages. The messages in the
    transaction includes some quirks:
     * One MIDI message is transferred in one quadlet transaction, except for
       system exclusives.
     * MIDI running status is not allowed, thus transactions always include
       status byte.
     * The basic data format is the same as transferring MIDI messages
       supported in previous commit.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
index 853438d93950..6b74fb5e5fd7 100644
--- a/sound/firewire/tascam/tascam-transaction.c
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -58,6 +58,83 @@ static inline int calculate_message_bytes(u8 status)
 	return -EINVAL;
 }
 
+static int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)
+{
+	struct snd_tscm *tscm = substream->rmidi->private_data;
+	unsigned int port = substream->number;
+	unsigned int len;
+	unsigned int i;
+	u8 status;
+	int consume;
+
+	buf[0] = buf[1] = buf[2] = buf[3] = 0x00;
+
+	len = snd_rawmidi_transmit_peek(substream, buf + 1, 3);
+	if (len == 0)
+		return 0;
+
+	/* On exclusive message. */
+	if (tscm->on_sysex[port]) {
+		/* Seek the end of exclusives. */
+		for (i = 1; i < 4 || i < len; ++i) {
+			if (buf[i] == 0xf7) {
+				tscm->on_sysex[port] = false;
+				break;
+			}
+		}
+
+		/* At the end of exclusive message, use label 0x07. */
+		if (!tscm->on_sysex[port]) {
+			len = i;
+			buf[0] = (port << 4) | 0x07;
+		/* During exclusive message, use label 0x04. */
+		} else if (len == 3) {
+			buf[0] = (port << 4) | 0x04;
+		/* We need to fill whole 3 bytes. Go to next change. */
+		} else {
+			len = 0;
+		}
+	} else {
+		/* The beginning of exclusives. */
+		if (buf[1] == 0xf0) {
+			/* Transfer it in next chance in another condition. */
+			tscm->on_sysex[port] = true;
+			return 0;
+		} else {
+			/* On running-status. */
+			if ((buf[1] & 0x80) != 0x80)
+				status = tscm->running_status[port];
+			else
+				status = buf[1];
+
+			/* Calculate consume bytes. */
+			consume = calculate_message_bytes(status);
+			if (consume <= 0)
+				return 0;
+
+			/* On running-status. */
+			if ((buf[1] & 0x80) != 0x80) {
+				buf[3] = buf[2];
+				buf[2] = buf[1];
+				buf[1] = tscm->running_status[port];
+				consume--;
+			} else {
+				tscm->running_status[port] = buf[1];
+			}
+
+			/* Confirm length. */
+			if (len < consume)
+				return 0;
+			if (len > consume)
+				len = consume;
+		}
+
+		buf[0] = (port << 4) | (buf[1] >> 4);
+	}
+
+	return len;
+}
+
 static void handle_midi_tx(struct fw_card *card, struct fw_request *request,
 			   int tcode, int destination, int source,
 			   int generation, unsigned long long offset,
@@ -111,6 +188,7 @@ int snd_tscm_transaction_register(struct snd_tscm *tscm)
 		.start	= 0xffffe0000000ull,
 		.end	= 0xffffe000ffffull,
 	};
+	unsigned int i;
 	int err;
 
 	/*
@@ -129,8 +207,20 @@ int snd_tscm_transaction_register(struct snd_tscm *tscm)
 
 	err = snd_tscm_transaction_reregister(tscm);
 	if (err < 0)
-		fw_core_remove_address_handler(&tscm->async_handler);
+		goto error;
+
+	for (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++) {
+		err = snd_fw_async_midi_port_init(
+				&tscm->out_ports[i], tscm->unit,
+				TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_RX_QUAD,
+				4, fill_message);
+		if (err < 0)
+			goto error;
+	}
 
+	return err;
+error:
+	fw_core_remove_address_handler(&tscm->async_handler);
 	return err;
 }
 
@@ -167,6 +257,7 @@ int snd_tscm_transaction_reregister(struct snd_tscm *tscm)
 void snd_tscm_transaction_unregister(struct snd_tscm *tscm)
 {
 	__be32 reg;
+	unsigned int i;
 
 	/* Turn off messaging. */
 	reg = cpu_to_be32(0x00000000);
@@ -183,4 +274,6 @@ void snd_tscm_transaction_unregister(struct snd_tscm *tscm)
 			   &reg, sizeof(reg), 0);
 
 	fw_core_remove_address_handler(&tscm->async_handler);
+	for (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++)
+		snd_fw_async_midi_port_destroy(&tscm->out_ports[i]);
 }

commit 107cc0129a685e88d09af88b8a371caec5c51ff0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 12 19:10:21 2015 +0900

    ALSA: firewire-tascam: add support for incoming MIDI messages by asynchronous transaction
    
    TASCAM FireWire series use asynchronous transaction to transfer MIDI
    messages. The transaction is sent to a registered address.
    
    This commit supports the incoming MIDI messages. The messages in the
    transaction include some quirks:
     * Two quadlets are used for one MIDI message and one timestamp.
     * Usually, the first byte of the first quadlet includes MIDI port and MSB
       4 bit of MIDI status. For system exclusive message, the first byte
       includes MIDI port and 0x04, or 0x07 in the end of the message.
     * The rest of the first quadlet includes MIDI bytes up to 3.
     * Several set of MIDI messages and timestamp can be transferred in one
       block transaction, up to 8 sets.
    
    I note that TASCAM FireWire series ignores ID bytes of system exclusive
    message. When receiving system exclusive messages with ID bytes on physical
    MIDI bus, the series transfers the messages without ID bytes on IEEE 1394
    bus, and vice versa.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam-transaction.c b/sound/firewire/tascam/tascam-transaction.c
new file mode 100644
index 000000000000..853438d93950
--- /dev/null
+++ b/sound/firewire/tascam/tascam-transaction.c
@@ -0,0 +1,186 @@
+/*
+ * tascam-transaction.c - a part of driver for TASCAM FireWire series
+ *
+ * Copyright (c) 2015 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "tascam.h"
+
+/*
+ * When return minus value, given argument is not MIDI status.
+ * When return 0, given argument is a beginning of system exclusive.
+ * When return the others, given argument is MIDI data.
+ */
+static inline int calculate_message_bytes(u8 status)
+{
+	switch (status) {
+	case 0xf6:	/* Tune request. */
+	case 0xf8:	/* Timing clock. */
+	case 0xfa:	/* Start. */
+	case 0xfb:	/* Continue. */
+	case 0xfc:	/* Stop. */
+	case 0xfe:	/* Active sensing. */
+	case 0xff:	/* System reset. */
+		return 1;
+	case 0xf1:	/* MIDI time code quarter frame. */
+	case 0xf3:	/* Song select. */
+		return 2;
+	case 0xf2:	/* Song position pointer. */
+		return 3;
+	case 0xf0:	/* Exclusive. */
+		return 0;
+	case 0xf7:	/* End of exclusive. */
+		break;
+	case 0xf4:	/* Undefined. */
+	case 0xf5:	/* Undefined. */
+	case 0xf9:	/* Undefined. */
+	case 0xfd:	/* Undefined. */
+		break;
+	default:
+		switch (status & 0xf0) {
+		case 0x80:	/* Note on. */
+		case 0x90:	/* Note off. */
+		case 0xa0:	/* Polyphonic key pressure. */
+		case 0xb0:	/* Control change and Mode change. */
+		case 0xe0:	/* Pitch bend change. */
+			return 3;
+		case 0xc0:	/* Program change. */
+		case 0xd0:	/* Channel pressure. */
+			return 2;
+		default:
+		break;
+		}
+	break;
+	}
+
+	return -EINVAL;
+}
+
+static void handle_midi_tx(struct fw_card *card, struct fw_request *request,
+			   int tcode, int destination, int source,
+			   int generation, unsigned long long offset,
+			   void *data, size_t length, void *callback_data)
+{
+	struct snd_tscm *tscm = callback_data;
+	u32 *buf = (u32 *)data;
+	unsigned int messages;
+	unsigned int i;
+	unsigned int port;
+	struct snd_rawmidi_substream *substream;
+	u8 *b;
+	int bytes;
+
+	if (offset != tscm->async_handler.offset)
+		goto end;
+
+	messages = length / 8;
+	for (i = 0; i < messages; i++) {
+		b = (u8 *)(buf + i * 2);
+
+		port = b[0] >> 4;
+		/* TODO: support virtual MIDI ports. */
+		if (port > tscm->spec->midi_capture_ports)
+			goto end;
+
+		/* Assume the message length. */
+		bytes = calculate_message_bytes(b[1]);
+		/* On MIDI data or exclusives. */
+		if (bytes <= 0) {
+			/* Seek the end of exclusives. */
+			for (bytes = 1; bytes < 4; bytes++) {
+				if (b[bytes] == 0xf7)
+					break;
+			}
+			if (bytes == 4)
+				bytes = 3;
+		}
+
+		substream = ACCESS_ONCE(tscm->tx_midi_substreams[port]);
+		if (substream != NULL)
+			snd_rawmidi_receive(substream, b + 1, bytes);
+	}
+end:
+	fw_send_response(card, request, RCODE_COMPLETE);
+}
+
+int snd_tscm_transaction_register(struct snd_tscm *tscm)
+{
+	static const struct fw_address_region resp_register_region = {
+		.start	= 0xffffe0000000ull,
+		.end	= 0xffffe000ffffull,
+	};
+	int err;
+
+	/*
+	 * Usually, two quadlets are transferred by one transaction. The first
+	 * quadlet has MIDI messages, the rest includes timestamp.
+	 * Sometimes, 8 set of the data is transferred by a block transaction.
+	 */
+	tscm->async_handler.length = 8 * 8;
+	tscm->async_handler.address_callback = handle_midi_tx;
+	tscm->async_handler.callback_data = tscm;
+
+	err = fw_core_add_address_handler(&tscm->async_handler,
+					  &resp_register_region);
+	if (err < 0)
+		return err;
+
+	err = snd_tscm_transaction_reregister(tscm);
+	if (err < 0)
+		fw_core_remove_address_handler(&tscm->async_handler);
+
+	return err;
+}
+
+/* At bus reset, these registers are cleared. */
+int snd_tscm_transaction_reregister(struct snd_tscm *tscm)
+{
+	struct fw_device *device = fw_parent_device(tscm->unit);
+	__be32 reg;
+	int err;
+
+	/* Register messaging address. Block transaction is not allowed. */
+	reg = cpu_to_be32((device->card->node_id << 16) |
+			  (tscm->async_handler.offset >> 32));
+	err = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
+				 TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_HI,
+				 &reg, sizeof(reg), 0);
+	if (err < 0)
+		return err;
+
+	reg = cpu_to_be32(tscm->async_handler.offset);
+	err = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
+				 TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_LO,
+				 &reg, sizeof(reg), 0);
+	if (err < 0)
+		return err;
+
+	/* Turn on messaging. */
+	reg = cpu_to_be32(0x00000001);
+	return snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
+				  TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,
+				  &reg, sizeof(reg), 0);
+}
+
+void snd_tscm_transaction_unregister(struct snd_tscm *tscm)
+{
+	__be32 reg;
+
+	/* Turn off messaging. */
+	reg = cpu_to_be32(0x00000000);
+	snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
+			   TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,
+			   &reg, sizeof(reg), 0);
+
+	/* Unregister the address. */
+	snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
+			   TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_HI,
+			   &reg, sizeof(reg), 0);
+	snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,
+			   TSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_LO,
+			   &reg, sizeof(reg), 0);
+
+	fw_core_remove_address_handler(&tscm->async_handler);
+}
