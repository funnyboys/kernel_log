commit 9c0d16ac059148fc7647f5f9e90df6f34d3439f0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Mar 6 22:52:29 2020 +0900

    ALSA: firewire: use KBUILD_MODNAME for struct driver.name instead of string
    
    KBUILD_MODNAME is available to name kernel modules according to its object
    name. This commit uses the macro instead of string for name field of
    struct driver since drivers in ALSA firewire stack have the same name of
    each object name.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20200306135229.11659-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index addc464503bc..5dac0d9fc58e 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -224,7 +224,7 @@ MODULE_DEVICE_TABLE(ieee1394, snd_tscm_id_table);
 static struct fw_driver tscm_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
-		.name = "snd-firewire-tascam",
+		.name = KBUILD_MODNAME,
 		.bus = &fw_bus_type,
 	},
 	.probe    = snd_tscm_probe,

commit e6e2fe2b8f7a4abd24170225050597ebc9f1427b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Sep 6 21:55:44 2019 +0900

    ALSA: firewire-tascam: add note for FE-8
    
    TASCAM FE-8 is the rest of model in TASCAM FireWire series. This device
    has no functionality to process audio signal and MIDI messages. Instead,
    it transfers control messages to host system corresponding to operations
    for some faders, buttons and knobs on its surface.
    
    Unlike the other devices in this series, the control messages are
    transmitted by asynchronous transactions. Some registers of device are
    used for registration of destination address for the transaction. The
    transaction includes quadlet-aligned data up to 32 quadlets.
    
    Userspace applications can receive the transaction and parse it for
    control message via Linux FireWire subsystem, without any support by
    ALSA firewire-tascam driver. Therefore the driver gives no support
    for it.
    
    This commit removes placeholder for FE-8 and add some comment for its
    functionalities as notes.
    
    $ python2 linux-firewire-utils/src/crpp < ~/git/am-config-rom/tascam/tascam-fe8.img
                   ROM header and bus information block
                   -----------------------------------------------------------------
    400  040f4798  bus_info_length 4, crc_length 15, crc 18328 (should be 14256)
    404  31333934  bus_name "1394"
    408  20ff7002  irmc 0, cmc 0, isc 1, bmc 0, cyc_clk_acc 255, max_rec 7 (256)
    40c  00022eff  company_id 00022e     |
    410  a094dcb7  device_id ffa094dcb7  | EUI-64 00022effa094dcb7
    
                   root directory
                   -----------------------------------------------------------------
    414  0004bccc  directory_length 4, crc 48332
    418  0300022e  vendor
    41c  0c0083c0  node capabilities per IEEE 1394
    420  8d000006  --> eui-64 leaf at 438
    424  d1000001  --> unit directory at 428
    
                   unit directory at 428
                   -----------------------------------------------------------------
    428  0003eda4  directory_length 3, crc 60836
    42c  1200022e  specifier id
    430  13800001  version
    434  d4000004  --> dependent info directory at 444
    
                   eui-64 leaf at 438
                   -----------------------------------------------------------------
    438  0002461e  leaf_length 2, crc 17950
    43c  00022eff  company_id 00022e     |
    440  a094dcb7  device_id ffa094dcb7  | EUI-64 00022effa094dcb7
    
                   dependent info directory at 444
                   -----------------------------------------------------------------
    444  0002ae47  directory_length 2, crc 44615
    448  81000002  --> descriptor leaf at 450
    44c  82000006  --> bus dependent info leaf at 464
    
                   descriptor leaf at 450
                   -----------------------------------------------------------------
    450  0004a79e  leaf_length 4, crc 42910
    454  00000000  textual descriptor
    458  00000000  minimal ASCII
    45c  54415343  "TASC"
    460  414d0000  "AM"
    
                   bus dependent info leaf at 464
                   -----------------------------------------------------------------
    464  0004a7d8  leaf_length 4, crc 42968
    468  00000000
    46c  00000000
    470  46452d38
    474  00000000
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Link: https://lore.kernel.org/r/20190906125544.13800-1-o-takashi@sakamocchi.jp
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index 231052db5680..addc464503bc 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -39,6 +39,9 @@ static const struct snd_tscm_spec model_specs[] = {
 		.midi_capture_ports = 2,
 		.midi_playback_ports = 4,
 	},
+	// This kernel module doesn't support FE-8 because the most of features
+	// can be implemented in userspace without any specific support of this
+	// module.
 };
 
 static int identify_model(struct snd_tscm *tscm)
@@ -214,7 +217,6 @@ static const struct ieee1394_device_id snd_tscm_id_table[] = {
 		.vendor_id = 0x00022e,
 		.specifier_id = 0x00022e,
 	},
-	/* FE-08 requires reverse-engineering because it just has faders. */
 	{}
 };
 MODULE_DEVICE_TABLE(ieee1394, snd_tscm_id_table);

commit da607e1969ffbf7a1ba06280ade768f4f5fee8c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 345
    
    Based on 1 normalized pattern(s):
    
      licensed under the terms of the gnu general public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 88 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000437.521539229@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index ef57fa4db323..231052db5680 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * tascam.c - a part of driver for TASCAM FireWire series
  *
  * Copyright (c) 2015 Takashi Sakamoto
- *
- * Licensed under the terms of the GNU General Public License, version 2.
  */
 
 #include "tascam.h"

commit 3babca4555b20fc80aff4776662fb237257d9afd
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:02 2018 +0900

    ALSA: firewire: simplify cleanup process when failing to register sound card
    
    In former commits, .private_free callback releases resources just for
    data transmission. This release function can be called without the
    resources are actually allocated in error paths.
    
    This commit applies a small refactoring to clean up codes in error
    paths.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index f4f959128341..ef57fa4db323 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -85,17 +85,14 @@ static int identify_model(struct snd_tscm *tscm)
 	return 0;
 }
 
-static void tscm_free(struct snd_tscm *tscm)
+static void tscm_card_free(struct snd_card *card)
 {
+	struct snd_tscm *tscm = card->private_data;
+
 	snd_tscm_transaction_unregister(tscm);
 	snd_tscm_stream_destroy_duplex(tscm);
 }
 
-static void tscm_card_free(struct snd_card *card)
-{
-	tscm_free(card->private_data);
-}
-
 static void do_registration(struct work_struct *work)
 {
 	struct snd_tscm *tscm = container_of(work, struct snd_tscm, dwork.work);
@@ -105,6 +102,8 @@ static void do_registration(struct work_struct *work)
 			   &tscm->card);
 	if (err < 0)
 		return;
+	tscm->card->private_free = tscm_card_free;
+	tscm->card->private_data = tscm;
 
 	err = identify_model(tscm);
 	if (err < 0)
@@ -136,18 +135,10 @@ static void do_registration(struct work_struct *work)
 	if (err < 0)
 		goto error;
 
-	/*
-	 * After registered, tscm instance can be released corresponding to
-	 * releasing the sound card instance.
-	 */
-	tscm->card->private_free = tscm_card_free;
-	tscm->card->private_data = tscm;
 	tscm->registered = true;
 
 	return;
 error:
-	snd_tscm_transaction_unregister(tscm);
-	snd_tscm_stream_destroy_duplex(tscm);
 	snd_card_free(tscm->card);
 	dev_info(&tscm->unit->device,
 		 "Sound card registration failed: %d\n", err);

commit 5b14ec25a79bf60fc9a663fe579a500b6ac9d8ab
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:35:00 2018 +0900

    ALSA: firewire: release reference count of firewire unit in .remove callback of bus driver
    
    In a previous commit, drivers in ALSA firewire stack blocks .remove
    callback of bus driver. This enables to release members of private
    data in the callback after releasing device of sound card.
    
    This commit simplifies codes to release the members.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index 6f7aaa8c84aa..f4f959128341 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -89,9 +89,6 @@ static void tscm_free(struct snd_tscm *tscm)
 {
 	snd_tscm_transaction_unregister(tscm);
 	snd_tscm_stream_destroy_duplex(tscm);
-
-	mutex_destroy(&tscm->mutex);
-	fw_unit_put(tscm->unit);
 }
 
 static void tscm_card_free(struct snd_card *card)
@@ -214,10 +211,10 @@ static void snd_tscm_remove(struct fw_unit *unit)
 	if (tscm->registered) {
 		// Block till all of ALSA character devices are released.
 		snd_card_free(tscm->card);
-	} else {
-		/* Don't forget this case. */
-		tscm_free(tscm);
 	}
+
+	mutex_destroy(&tscm->mutex);
+	fw_unit_put(tscm->unit);
 }
 
 static const struct ieee1394_device_id snd_tscm_id_table[] = {

commit 61ccc6f6b27c03bb32ca38a3c580d49ce1612d43
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 10 15:34:59 2018 +0900

    ALSA: firewire: block .remove callback of bus driver till all of ALSA character devices are released
    
    At present, in .remove callback of bus driver just decrease reference
    count of device for ALSA card instance. This delegates release of the
    device to a process in which the last of ALSA character device is
    released.
    
    On the other hand, the other drivers such as for devices on PCIe are
    programmed to block .remove callback of bus driver till all of ALSA
    character devices are released.
    
    For consistency of behaviour for whole drivers, this probably confuses
    users. This commit takes drivers in ALSA firewire stack to imitate the
    above behaviour.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index 53f20153ba71..6f7aaa8c84aa 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -212,8 +212,8 @@ static void snd_tscm_remove(struct fw_unit *unit)
 	cancel_delayed_work_sync(&tscm->dwork);
 
 	if (tscm->registered) {
-		/* No need to wait for releasing card object in this context. */
-		snd_card_free_when_closed(tscm->card);
+		// Block till all of ALSA character devices are released.
+		snd_card_free(tscm->card);
 	} else {
 		/* Don't forget this case. */
 		tscm_free(tscm);

commit 366a20d7a75cff7f89dede6fdfd41bd491aaf8ac
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Oct 3 08:21:50 2018 +0900

    ALSA: firewire: use managed-resource of fw unit device for private data
    
    At present, private data of each driver in ALSA firewire stack is
    allocated/freed by kernel slab allocator for corresponding unit on
    IEEE 1394 bus. In this case, resource-managed slab allocator is
    available to release memory object automatically just before releasing
    device structure for the unit. This idea can prevent runtime from
    memory leak due to programming mistakes.
    
    This commit uses the allocator for the private data. These drivers
    already use reference counter to maintain lifetime of device structure
    for the unit by a pair of fw_unit_get()/fw_unit_put(). The private data
    is safely released in a callback of 'struct snd_card.private_free().
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index d3fdc463a884..53f20153ba71 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -90,10 +90,8 @@ static void tscm_free(struct snd_tscm *tscm)
 	snd_tscm_transaction_unregister(tscm);
 	snd_tscm_stream_destroy_duplex(tscm);
 
-	fw_unit_put(tscm->unit);
-
 	mutex_destroy(&tscm->mutex);
-	kfree(tscm);
+	fw_unit_put(tscm->unit);
 }
 
 static void tscm_card_free(struct snd_card *card)
@@ -164,11 +162,9 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	struct snd_tscm *tscm;
 
 	/* Allocate this independent of sound card instance. */
-	tscm = kzalloc(sizeof(struct snd_tscm), GFP_KERNEL);
-	if (tscm == NULL)
+	tscm = devm_kzalloc(&unit->device, sizeof(struct snd_tscm), GFP_KERNEL);
+	if (!tscm)
 		return -ENOMEM;
-
-	/* initialize myself */
 	tscm->unit = fw_unit_get(unit);
 	dev_set_drvdata(&unit->device, tscm);
 

commit 8d28277c065a974873c6781d44b7bcdcd8fb4e8a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Sep 13 21:31:05 2018 +0900

    ALSA: firewire-tascam: fix memory leak of private data
    
    Although private data of sound card instance is usually allocated in the
    tail of the instance, drivers in ALSA firewire stack allocate the private
    data before allocating the instance. In this case, the private data
    should be released explicitly at .private_free callback of the instance.
    
    This commit fixes memory leak following to the above design.
    
    Fixes: b610386c8afb ('ALSA: firewire-tascam: deleyed registration of sound card')
    Cc: <stable@vger.kernel.org> # v4.7+
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index 44ad41fb7374..d3fdc463a884 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -93,6 +93,7 @@ static void tscm_free(struct snd_tscm *tscm)
 	fw_unit_put(tscm->unit);
 
 	mutex_destroy(&tscm->mutex);
+	kfree(tscm);
 }
 
 static void tscm_card_free(struct snd_card *card)

commit 782fbec745d84fa06708e703a92a431c4344daf0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Tue Aug 22 22:58:15 2017 +0900

    ALSA: firewire: add const qualifier to identifiers for read-only symbols
    
    Drivers in ALSA firewire stack still includes some symbols which can be
    moved to a section for read-only symbols.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index 9dc93a7eb9da..44ad41fb7374 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -12,7 +12,7 @@ MODULE_DESCRIPTION("TASCAM FireWire series Driver");
 MODULE_AUTHOR("Takashi Sakamoto <o-takashi@sakamocchi.jp>");
 MODULE_LICENSE("GPL v2");
 
-static struct snd_tscm_spec model_specs[] = {
+static const struct snd_tscm_spec model_specs[] = {
 	{
 		.name = "FW-1884",
 		.has_adat = true,

commit b610386c8afba397238329c50c45a3abc79ba45f
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Mar 31 08:47:09 2016 +0900

    ALSA: firewire-tascam: deleyed registration of sound card
    
    When some tascam units are connected sequentially, userspace
    applications are involved at bus-reset state on IEEE 1394 bus. In the
    state, any communications can be canceled. Therefore, sound card
    registration should be delayed till the bus gets calm.
    
    This commit achieves it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index e281c338e562..9dc93a7eb9da 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -85,10 +85,8 @@ static int identify_model(struct snd_tscm *tscm)
 	return 0;
 }
 
-static void tscm_card_free(struct snd_card *card)
+static void tscm_free(struct snd_tscm *tscm)
 {
-	struct snd_tscm *tscm = card->private_data;
-
 	snd_tscm_transaction_unregister(tscm);
 	snd_tscm_stream_destroy_duplex(tscm);
 
@@ -97,44 +95,36 @@ static void tscm_card_free(struct snd_card *card)
 	mutex_destroy(&tscm->mutex);
 }
 
-static int snd_tscm_probe(struct fw_unit *unit,
-			   const struct ieee1394_device_id *entry)
+static void tscm_card_free(struct snd_card *card)
 {
-	struct snd_card *card;
-	struct snd_tscm *tscm;
+	tscm_free(card->private_data);
+}
+
+static void do_registration(struct work_struct *work)
+{
+	struct snd_tscm *tscm = container_of(work, struct snd_tscm, dwork.work);
 	int err;
 
-	/* create card */
-	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
-			   sizeof(struct snd_tscm), &card);
+	err = snd_card_new(&tscm->unit->device, -1, NULL, THIS_MODULE, 0,
+			   &tscm->card);
 	if (err < 0)
-		return err;
-	card->private_free = tscm_card_free;
-
-	/* initialize myself */
-	tscm = card->private_data;
-	tscm->card = card;
-	tscm->unit = fw_unit_get(unit);
-
-	mutex_init(&tscm->mutex);
-	spin_lock_init(&tscm->lock);
-	init_waitqueue_head(&tscm->hwdep_wait);
+		return;
 
 	err = identify_model(tscm);
 	if (err < 0)
 		goto error;
 
-	snd_tscm_proc_init(tscm);
-
-	err = snd_tscm_stream_init_duplex(tscm);
+	err = snd_tscm_transaction_register(tscm);
 	if (err < 0)
 		goto error;
 
-	err = snd_tscm_create_pcm_devices(tscm);
+	err = snd_tscm_stream_init_duplex(tscm);
 	if (err < 0)
 		goto error;
 
-	err = snd_tscm_transaction_register(tscm);
+	snd_tscm_proc_init(tscm);
+
+	err = snd_tscm_create_pcm_devices(tscm);
 	if (err < 0)
 		goto error;
 
@@ -146,35 +136,91 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
-	err = snd_card_register(card);
+	err = snd_card_register(tscm->card);
 	if (err < 0)
 		goto error;
 
-	dev_set_drvdata(&unit->device, tscm);
+	/*
+	 * After registered, tscm instance can be released corresponding to
+	 * releasing the sound card instance.
+	 */
+	tscm->card->private_free = tscm_card_free;
+	tscm->card->private_data = tscm;
+	tscm->registered = true;
 
-	return err;
+	return;
 error:
-	snd_card_free(card);
-	return err;
+	snd_tscm_transaction_unregister(tscm);
+	snd_tscm_stream_destroy_duplex(tscm);
+	snd_card_free(tscm->card);
+	dev_info(&tscm->unit->device,
+		 "Sound card registration failed: %d\n", err);
+}
+
+static int snd_tscm_probe(struct fw_unit *unit,
+			   const struct ieee1394_device_id *entry)
+{
+	struct snd_tscm *tscm;
+
+	/* Allocate this independent of sound card instance. */
+	tscm = kzalloc(sizeof(struct snd_tscm), GFP_KERNEL);
+	if (tscm == NULL)
+		return -ENOMEM;
+
+	/* initialize myself */
+	tscm->unit = fw_unit_get(unit);
+	dev_set_drvdata(&unit->device, tscm);
+
+	mutex_init(&tscm->mutex);
+	spin_lock_init(&tscm->lock);
+	init_waitqueue_head(&tscm->hwdep_wait);
+
+	/* Allocate and register this sound card later. */
+	INIT_DEFERRABLE_WORK(&tscm->dwork, do_registration);
+	snd_fw_schedule_registration(unit, &tscm->dwork);
+
+	return 0;
 }
 
 static void snd_tscm_update(struct fw_unit *unit)
 {
 	struct snd_tscm *tscm = dev_get_drvdata(&unit->device);
 
+	/* Postpone a workqueue for deferred registration. */
+	if (!tscm->registered)
+		snd_fw_schedule_registration(unit, &tscm->dwork);
+
 	snd_tscm_transaction_reregister(tscm);
 
-	mutex_lock(&tscm->mutex);
-	snd_tscm_stream_update_duplex(tscm);
-	mutex_unlock(&tscm->mutex);
+	/*
+	 * After registration, userspace can start packet streaming, then this
+	 * code block works fine.
+	 */
+	if (tscm->registered) {
+		mutex_lock(&tscm->mutex);
+		snd_tscm_stream_update_duplex(tscm);
+		mutex_unlock(&tscm->mutex);
+	}
 }
 
 static void snd_tscm_remove(struct fw_unit *unit)
 {
 	struct snd_tscm *tscm = dev_get_drvdata(&unit->device);
 
-	/* No need to wait for releasing card object in this context. */
-	snd_card_free_when_closed(tscm->card);
+	/*
+	 * Confirm to stop the work for registration before the sound card is
+	 * going to be released. The work is not scheduled again because bus
+	 * reset handler is not called anymore.
+	 */
+	cancel_delayed_work_sync(&tscm->dwork);
+
+	if (tscm->registered) {
+		/* No need to wait for releasing card object in this context. */
+		snd_card_free_when_closed(tscm->card);
+	} else {
+		/* Don't forget this case. */
+		tscm_free(tscm);
+	}
 }
 
 static const struct ieee1394_device_id snd_tscm_id_table[] = {

commit 61ebe499643703af517a8253662982f6f4764c92
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Feb 5 09:56:07 2016 +0900

    ALSA: firewire-tascam: remove a flag for controller
    
    Currently, 'struct snd_tscm_spec' has a member named as 'is_controller' to
    identify MIDI controller. This member was originally added to skip
    parse control and status messages in isochronous packets for non-controller
    model.
    
    As long as I investigate, FW-1804 (non-controller) also transfers the
    control and status message, thus it becomes meaningless.
    
    This commit removes it.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index dcb11c26c225..e281c338e562 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -21,7 +21,6 @@ static struct snd_tscm_spec model_specs[] = {
 		.pcm_playback_analog_channels = 8,
 		.midi_capture_ports = 4,
 		.midi_playback_ports = 4,
-		.is_controller = true,
 	},
 	{
 		.name = "FW-1082",
@@ -31,7 +30,6 @@ static struct snd_tscm_spec model_specs[] = {
 		.pcm_playback_analog_channels = 2,
 		.midi_capture_ports = 2,
 		.midi_playback_ports = 2,
-		.is_controller = true,
 	},
 	{
 		.name = "FW-1804",
@@ -41,7 +39,6 @@ static struct snd_tscm_spec model_specs[] = {
 		.pcm_playback_analog_channels = 2,
 		.midi_capture_ports = 2,
 		.midi_playback_ports = 4,
-		.is_controller = false,
 	},
 };
 

commit 3e78e1518e129407fae75c867e48828262b3ea6d
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Feb 5 09:56:06 2016 +0900

    ALSA: firewire-tascam: add support for FW-1804
    
    This model supports:
     * maximum 12 PCM channels for PCM playback
     * maximum 18 PCM channels for PCM capture
     * 4 ports for MIDI playback
     * 4 ports for MIDI capture
     * control and status messages in tx isochronous packets
     * up to 96.0 kHz
    
    This commit adds support for the model. As the other supported models,
    all of available PCM channels are always enabled.
    
    As I described in commit c0949b278515da94, Ilya Zimnovich had investigated
    TASCAM FireWire series in 2011 with his FW-1804. In his report, this model
    has internal multiplexer and any software implementation can control it.
    Following to the design of ALSA firewire stack, this commit won't
    implement it. It should be in userspace via Linux fw character device.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index ee0bc1839508..dcb11c26c225 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -33,7 +33,16 @@ static struct snd_tscm_spec model_specs[] = {
 		.midi_playback_ports = 2,
 		.is_controller = true,
 	},
-	/* FW-1804 may be supported. */
+	{
+		.name = "FW-1804",
+		.has_adat = true,
+		.has_spdif = true,
+		.pcm_capture_analog_channels = 8,
+		.pcm_playback_analog_channels = 2,
+		.midi_capture_ports = 2,
+		.midi_playback_ports = 4,
+		.is_controller = false,
+	},
 };
 
 static int identify_model(struct snd_tscm *tscm)

commit 9a30ae2df29c27eca58581862928ee2c7bbdfa76
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Oct 19 14:29:27 2015 +0300

    ALSA: firewire-tascam: off by one in identify_model()
    
    Let's leave space for the NUL char otherwise the static checkers
    complain that we go beyond the end of the array.
    
    Fixes: 53b3ffee7885 ('ALSA: firewire-tascam: change device probing processing')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index c2f42cd3f3b8..ee0bc1839508 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -40,7 +40,7 @@ static int identify_model(struct snd_tscm *tscm)
 {
 	struct fw_device *fw_dev = fw_parent_device(tscm->unit);
 	const u32 *config_rom = fw_dev->config_rom;
-	char model[8];
+	char model[9];
 	unsigned int i;
 	u8 c;
 

commit bd04809bbe4c1f749650bb990c969112a5e10aef
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Oct 18 22:39:53 2015 +0900

    ALSA: firewire-digi00x/firewire-tascam: remove wrong conversion for Config ROM
    
    The contents of Config ROM in firewire device structure are already
    aligned to CPU-endianness. Thus, no need to convert it again.
    
    This commit removes needless conversions
    
    Fixes: 9edf723fd858('ALSA: firewire-digi00x: add skeleton for Digi 002/003 family')
    Fixes: c0949b278515('ALSA: firewire-tascam: add skeleton for TASCAM FireWire series')
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index c6747a45795b..c2f42cd3f3b8 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -73,8 +73,7 @@ static int identify_model(struct snd_tscm *tscm)
 	strcpy(tscm->card->mixername, model);
 	snprintf(tscm->card->longname, sizeof(tscm->card->longname),
 		 "TASCAM %s, GUID %08x%08x at %s, S%d", model,
-		 cpu_to_be32(fw_dev->config_rom[3]),
-		 cpu_to_be32(fw_dev->config_rom[4]),
+		 fw_dev->config_rom[3], fw_dev->config_rom[4],
 		 dev_name(&tscm->unit->device), 100 << fw_dev->max_speed);
 
 	return 0;

commit 53b3ffee788559fe26d32f21b223bf4bad959477
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 12 19:10:25 2015 +0900

    ALSA: firewire-tascam: change device probing processing
    
    Currently, this driver picks up model name with be32_to_cpu() macro
    to align characters. This is wrong operation because the result is
    different depending on CPU endiannness.
    
    Additionally, vendor released several versions of firmware for this
    series. It's not better to assign model-dependent information to
    device entry according to the version field.
    
    This commit fixes these bugs. The name of model is picked up correctly
    and used to identify model-dependent information.
    
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Fixes: c0949b278515 ('ALSA: firewire-tascam: add skeleton for TASCAM FireWire series')
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index dc07e3edbf5a..c6747a45795b 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -23,16 +23,6 @@ static struct snd_tscm_spec model_specs[] = {
 		.midi_playback_ports = 4,
 		.is_controller = true,
 	},
-	{
-		.name = "FW-1804",
-		.has_adat = true,
-		.has_spdif = true,
-		.pcm_capture_analog_channels = 8,
-		.pcm_playback_analog_channels = 2,
-		.midi_capture_ports = 2,
-		.midi_playback_ports = 4,
-		.is_controller = false,
-	},
 	{
 		.name = "FW-1082",
 		.has_adat = false,
@@ -43,34 +33,46 @@ static struct snd_tscm_spec model_specs[] = {
 		.midi_playback_ports = 2,
 		.is_controller = true,
 	},
+	/* FW-1804 may be supported. */
 };
 
-static int check_name(struct snd_tscm *tscm)
+static int identify_model(struct snd_tscm *tscm)
 {
 	struct fw_device *fw_dev = fw_parent_device(tscm->unit);
-	char vendor[8];
+	const u32 *config_rom = fw_dev->config_rom;
 	char model[8];
-	__u32 data;
-
-	/* Retrieve model name. */
-	data = be32_to_cpu(fw_dev->config_rom[28]);
-	memcpy(model, &data, 4);
-	data = be32_to_cpu(fw_dev->config_rom[29]);
-	memcpy(model + 4, &data, 4);
-	model[7] = '\0';
-
-	/* Retrieve vendor name. */
-	data = be32_to_cpu(fw_dev->config_rom[23]);
-	memcpy(vendor, &data, 4);
-	data = be32_to_cpu(fw_dev->config_rom[24]);
-	memcpy(vendor + 4, &data, 4);
-	vendor[7] = '\0';
+	unsigned int i;
+	u8 c;
+
+	if (fw_dev->config_rom_length < 30) {
+		dev_err(&tscm->unit->device,
+			"Configuration ROM is too short.\n");
+		return -ENODEV;
+	}
+
+	/* Pick up model name from certain addresses. */
+	for (i = 0; i < 8; i++) {
+		c = config_rom[28 + i / 4] >> (24 - 8 * (i % 4));
+		if (c == '\0')
+			break;
+		model[i] = c;
+	}
+	model[i] = '\0';
+
+	for (i = 0; i < ARRAY_SIZE(model_specs); i++) {
+		if (strcmp(model, model_specs[i].name) == 0) {
+			tscm->spec = &model_specs[i];
+			break;
+		}
+	}
+	if (tscm->spec == NULL)
+		return -ENODEV;
 
 	strcpy(tscm->card->driver, "FW-TASCAM");
 	strcpy(tscm->card->shortname, model);
 	strcpy(tscm->card->mixername, model);
 	snprintf(tscm->card->longname, sizeof(tscm->card->longname),
-		 "%s %s, GUID %08x%08x at %s, S%d", vendor, model,
+		 "TASCAM %s, GUID %08x%08x at %s, S%d", model,
 		 cpu_to_be32(fw_dev->config_rom[3]),
 		 cpu_to_be32(fw_dev->config_rom[4]),
 		 dev_name(&tscm->unit->device), 100 << fw_dev->max_speed);
@@ -108,13 +110,12 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	tscm = card->private_data;
 	tscm->card = card;
 	tscm->unit = fw_unit_get(unit);
-	tscm->spec = (const struct snd_tscm_spec *)entry->driver_data;
 
 	mutex_init(&tscm->mutex);
 	spin_lock_init(&tscm->lock);
 	init_waitqueue_head(&tscm->hwdep_wait);
 
-	err = check_name(tscm);
+	err = identify_model(tscm);
 	if (err < 0)
 		goto error;
 
@@ -172,27 +173,12 @@ static void snd_tscm_remove(struct fw_unit *unit)
 }
 
 static const struct ieee1394_device_id snd_tscm_id_table[] = {
-	/* FW-1082 */
-	{
-		.match_flags = IEEE1394_MATCH_VENDOR_ID |
-			       IEEE1394_MATCH_SPECIFIER_ID |
-			       IEEE1394_MATCH_VERSION,
-		.vendor_id = 0x00022e,
-		.specifier_id = 0x00022e,
-		.version = 0x800003,
-		.driver_data = (kernel_ulong_t)&model_specs[2],
-	},
-	/* FW-1884 */
 	{
 		.match_flags = IEEE1394_MATCH_VENDOR_ID |
-			       IEEE1394_MATCH_SPECIFIER_ID |
-			       IEEE1394_MATCH_VERSION,
+			       IEEE1394_MATCH_SPECIFIER_ID,
 		.vendor_id = 0x00022e,
 		.specifier_id = 0x00022e,
-		.version = 0x800000,
-		.driver_data = (kernel_ulong_t)&model_specs[0],
 	},
-	/* FW-1804 mey be supported if IDs are clear. */
 	/* FE-08 requires reverse-engineering because it just has faders. */
 	{}
 };

commit 0db18e7eec40a4331214185b37b0440856856775
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 12 19:10:23 2015 +0900

    ALSA: firewire-tascam: add support for MIDI functionality
    
    In former commits, this driver got functionalities to transfer/receive
    MIDI messages to/from TASCAM FireWire series.
    
    This commit adds some ALSA MIDI ports to enable userspace applications
    to use the functionalities.
    
    I note that this commit doesn't support virtual MIDI ports which console
    models support. A physical controls can be assigned to a certain MIDI
    ports including physical and virtual. But the way is not clear.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index de9e8df25569..dc07e3edbf5a 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -132,6 +132,10 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_tscm_create_midi_devices(tscm);
+	if (err < 0)
+		goto error;
+
 	err = snd_tscm_create_hwdep_device(tscm);
 	if (err < 0)
 		goto error;

commit 107cc0129a685e88d09af88b8a371caec5c51ff0
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Mon Oct 12 19:10:21 2015 +0900

    ALSA: firewire-tascam: add support for incoming MIDI messages by asynchronous transaction
    
    TASCAM FireWire series use asynchronous transaction to transfer MIDI
    messages. The transaction is sent to a registered address.
    
    This commit supports the incoming MIDI messages. The messages in the
    transaction include some quirks:
     * Two quadlets are used for one MIDI message and one timestamp.
     * Usually, the first byte of the first quadlet includes MIDI port and MSB
       4 bit of MIDI status. For system exclusive message, the first byte
       includes MIDI port and 0x04, or 0x07 in the end of the message.
     * The rest of the first quadlet includes MIDI bytes up to 3.
     * Several set of MIDI messages and timestamp can be transferred in one
       block transaction, up to 8 sets.
    
    I note that TASCAM FireWire series ignores ID bytes of system exclusive
    message. When receiving system exclusive messages with ID bytes on physical
    MIDI bus, the series transfers the messages without ID bytes on IEEE 1394
    bus, and vice versa.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index ee2f498dcce4..de9e8df25569 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -82,6 +82,7 @@ static void tscm_card_free(struct snd_card *card)
 {
 	struct snd_tscm *tscm = card->private_data;
 
+	snd_tscm_transaction_unregister(tscm);
 	snd_tscm_stream_destroy_duplex(tscm);
 
 	fw_unit_put(tscm->unit);
@@ -127,6 +128,10 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_tscm_transaction_register(tscm);
+	if (err < 0)
+		goto error;
+
 	err = snd_tscm_create_hwdep_device(tscm);
 	if (err < 0)
 		goto error;
@@ -147,6 +152,8 @@ static void snd_tscm_update(struct fw_unit *unit)
 {
 	struct snd_tscm *tscm = dev_get_drvdata(&unit->device);
 
+	snd_tscm_transaction_reregister(tscm);
+
 	mutex_lock(&tscm->mutex);
 	snd_tscm_stream_update_duplex(tscm);
 	mutex_unlock(&tscm->mutex);

commit e5e0c3dd257bf34cf001e10422943f90437f0f1b
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Oct 1 22:02:17 2015 +0900

    ALSA: firewire-tascam: add hwdep interface
    
    This commit adds hwdep interface so as the other IEEE 1394 sound devices
    has.
    
    This interface is designed for mixer/control applications. By using this
    interface, an application can get information about firewire node, can
    lock/unlock kernel streaming and can get notification at starting/stopping
    kernel streaming.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index bb4f70656f2f..ee2f498dcce4 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -110,6 +110,8 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	tscm->spec = (const struct snd_tscm_spec *)entry->driver_data;
 
 	mutex_init(&tscm->mutex);
+	spin_lock_init(&tscm->lock);
+	init_waitqueue_head(&tscm->hwdep_wait);
 
 	err = check_name(tscm);
 	if (err < 0)
@@ -125,6 +127,10 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_tscm_create_hwdep_device(tscm);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;

commit e453df44f0d6574e99fae990c89a22c6ec6bbb62
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Oct 1 22:02:16 2015 +0900

    ALSA: firewire-tascam: add PCM functionality
    
    This commit adds PCM functionality to transmit/receive PCM samples.
    
    When one of PCM substreams are running or external clock source is
    selected, current sampling rate is used. Else, the sampling rate is
    changed as an userspace application requests.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index c2563606ac70..bb4f70656f2f 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -121,6 +121,10 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	err = snd_tscm_create_pcm_devices(tscm);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;

commit 35efa5c489de63a9bdbb7ea4e66dcfadcca951b4
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Oct 1 22:02:15 2015 +0900

    ALSA: firewire-tascam: add streaming functionality
    
    This commit adds streaming functionality for both direction. To utilize
    the sequence of the number of data blocks in packets, full duplex with
    synchronization is applied.
    
    Besides, TASCAM FireWire series allows drivers to decide which PCM data
    channels are enabled. For convenience, this driver always enable whole the
    data channels.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index d7418c065f4e..c2563606ac70 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -82,6 +82,8 @@ static void tscm_card_free(struct snd_card *card)
 {
 	struct snd_tscm *tscm = card->private_data;
 
+	snd_tscm_stream_destroy_duplex(tscm);
+
 	fw_unit_put(tscm->unit);
 
 	mutex_destroy(&tscm->mutex);
@@ -115,6 +117,10 @@ static int snd_tscm_probe(struct fw_unit *unit,
 
 	snd_tscm_proc_init(tscm);
 
+	err = snd_tscm_stream_init_duplex(tscm);
+	if (err < 0)
+		goto error;
+
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;
@@ -129,7 +135,11 @@ static int snd_tscm_probe(struct fw_unit *unit,
 
 static void snd_tscm_update(struct fw_unit *unit)
 {
-	return;
+	struct snd_tscm *tscm = dev_get_drvdata(&unit->device);
+
+	mutex_lock(&tscm->mutex);
+	snd_tscm_stream_update_duplex(tscm);
+	mutex_unlock(&tscm->mutex);
 }
 
 static void snd_tscm_remove(struct fw_unit *unit)

commit 96e5fbb0dd128496378dbc404c2a894e49c1ac21
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Oct 1 22:02:13 2015 +0900

    ALSA: firewire-tascam: add proc node to show firmware information
    
    TASCAM FireWire series has certain registers for firmware information.
    
    This commit adds proc node to show the information.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index 9ac09cbb3b05..d7418c065f4e 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -113,6 +113,8 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	if (err < 0)
 		goto error;
 
+	snd_tscm_proc_init(tscm);
+
 	err = snd_card_register(card);
 	if (err < 0)
 		goto error;

commit 6f81ba19ace2282f2560f5ec3a827ec5370825cb
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Oct 1 22:02:12 2015 +0900

    ALSA: firewire-tascam: add a structure for model-dependent parameters.
    
    TASCAM FireWire series doesn't tell drivers their capabilities, thus
    the drivers should have model-dependent parameters and apply it to
    detected devices.
    
    This commit adds a structure to represent such parameters.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
index 9f2d2a33f58a..9ac09cbb3b05 100644
--- a/sound/firewire/tascam/tascam.c
+++ b/sound/firewire/tascam/tascam.c
@@ -12,6 +12,39 @@ MODULE_DESCRIPTION("TASCAM FireWire series Driver");
 MODULE_AUTHOR("Takashi Sakamoto <o-takashi@sakamocchi.jp>");
 MODULE_LICENSE("GPL v2");
 
+static struct snd_tscm_spec model_specs[] = {
+	{
+		.name = "FW-1884",
+		.has_adat = true,
+		.has_spdif = true,
+		.pcm_capture_analog_channels = 8,
+		.pcm_playback_analog_channels = 8,
+		.midi_capture_ports = 4,
+		.midi_playback_ports = 4,
+		.is_controller = true,
+	},
+	{
+		.name = "FW-1804",
+		.has_adat = true,
+		.has_spdif = true,
+		.pcm_capture_analog_channels = 8,
+		.pcm_playback_analog_channels = 2,
+		.midi_capture_ports = 2,
+		.midi_playback_ports = 4,
+		.is_controller = false,
+	},
+	{
+		.name = "FW-1082",
+		.has_adat = false,
+		.has_spdif = true,
+		.pcm_capture_analog_channels = 8,
+		.pcm_playback_analog_channels = 2,
+		.midi_capture_ports = 2,
+		.midi_playback_ports = 2,
+		.is_controller = true,
+	},
+};
+
 static int check_name(struct snd_tscm *tscm)
 {
 	struct fw_device *fw_dev = fw_parent_device(tscm->unit);
@@ -72,6 +105,7 @@ static int snd_tscm_probe(struct fw_unit *unit,
 	tscm = card->private_data;
 	tscm->card = card;
 	tscm->unit = fw_unit_get(unit);
+	tscm->spec = (const struct snd_tscm_spec *)entry->driver_data;
 
 	mutex_init(&tscm->mutex);
 
@@ -113,6 +147,7 @@ static const struct ieee1394_device_id snd_tscm_id_table[] = {
 		.vendor_id = 0x00022e,
 		.specifier_id = 0x00022e,
 		.version = 0x800003,
+		.driver_data = (kernel_ulong_t)&model_specs[2],
 	},
 	/* FW-1884 */
 	{
@@ -122,6 +157,7 @@ static const struct ieee1394_device_id snd_tscm_id_table[] = {
 		.vendor_id = 0x00022e,
 		.specifier_id = 0x00022e,
 		.version = 0x800000,
+		.driver_data = (kernel_ulong_t)&model_specs[0],
 	},
 	/* FW-1804 mey be supported if IDs are clear. */
 	/* FE-08 requires reverse-engineering because it just has faders. */

commit c0949b278515da948597b4a1a2726f42591ef385
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Thu Oct 1 22:02:11 2015 +0900

    ALSA: firewire-tascam: add skeleton for TASCAM FireWire series
    
    This commit adds a new driver for TASCAM FireWire series. In this commit,
    this driver just creates/removes card instance according to bus event.
    More functionalities will be added in following commits.
    
    TASCAM FireWire series consists of:
     * PDI 1394P23 for IEEE 1394 PHY layer
     * PDI 1394L40 for IEEE 1394 LINK layer and IEC 61883 interface
     * XILINX XC9536XL
     * XILINX Spartan-II XC2S100
     * ATMEL AT91M42800A
    
    Ilya Zimnovich had investigated TASCAM FireWire series in 2011, and
    discover some features of his FW-1804. You can see a part of his research
    in FFADO project.
    http://subversion.ffado.org/wiki/Tascam
    
    A part of my work are based on Ilya's investigation, while this series
    doesn't support the FW-1804, because of a lack of config ROM
    information and its protocol detail, especially for PCM channels.
    
    I observed that FW-1884 and FW-1082 don't work properly with 1394 OHCI
    controller based on VT6315. The controller can actually communicate packets
    to these models, while these models generate no sounds. It may be due to
    the PHY/LINK layer issues. Using 1394 OHCI controller produced by the other
    vendors such as Texas Instruments may work. Or adding another node on the
    bus.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/firewire/tascam/tascam.c b/sound/firewire/tascam/tascam.c
new file mode 100644
index 000000000000..9f2d2a33f58a
--- /dev/null
+++ b/sound/firewire/tascam/tascam.c
@@ -0,0 +1,155 @@
+/*
+ * tascam.c - a part of driver for TASCAM FireWire series
+ *
+ * Copyright (c) 2015 Takashi Sakamoto
+ *
+ * Licensed under the terms of the GNU General Public License, version 2.
+ */
+
+#include "tascam.h"
+
+MODULE_DESCRIPTION("TASCAM FireWire series Driver");
+MODULE_AUTHOR("Takashi Sakamoto <o-takashi@sakamocchi.jp>");
+MODULE_LICENSE("GPL v2");
+
+static int check_name(struct snd_tscm *tscm)
+{
+	struct fw_device *fw_dev = fw_parent_device(tscm->unit);
+	char vendor[8];
+	char model[8];
+	__u32 data;
+
+	/* Retrieve model name. */
+	data = be32_to_cpu(fw_dev->config_rom[28]);
+	memcpy(model, &data, 4);
+	data = be32_to_cpu(fw_dev->config_rom[29]);
+	memcpy(model + 4, &data, 4);
+	model[7] = '\0';
+
+	/* Retrieve vendor name. */
+	data = be32_to_cpu(fw_dev->config_rom[23]);
+	memcpy(vendor, &data, 4);
+	data = be32_to_cpu(fw_dev->config_rom[24]);
+	memcpy(vendor + 4, &data, 4);
+	vendor[7] = '\0';
+
+	strcpy(tscm->card->driver, "FW-TASCAM");
+	strcpy(tscm->card->shortname, model);
+	strcpy(tscm->card->mixername, model);
+	snprintf(tscm->card->longname, sizeof(tscm->card->longname),
+		 "%s %s, GUID %08x%08x at %s, S%d", vendor, model,
+		 cpu_to_be32(fw_dev->config_rom[3]),
+		 cpu_to_be32(fw_dev->config_rom[4]),
+		 dev_name(&tscm->unit->device), 100 << fw_dev->max_speed);
+
+	return 0;
+}
+
+static void tscm_card_free(struct snd_card *card)
+{
+	struct snd_tscm *tscm = card->private_data;
+
+	fw_unit_put(tscm->unit);
+
+	mutex_destroy(&tscm->mutex);
+}
+
+static int snd_tscm_probe(struct fw_unit *unit,
+			   const struct ieee1394_device_id *entry)
+{
+	struct snd_card *card;
+	struct snd_tscm *tscm;
+	int err;
+
+	/* create card */
+	err = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,
+			   sizeof(struct snd_tscm), &card);
+	if (err < 0)
+		return err;
+	card->private_free = tscm_card_free;
+
+	/* initialize myself */
+	tscm = card->private_data;
+	tscm->card = card;
+	tscm->unit = fw_unit_get(unit);
+
+	mutex_init(&tscm->mutex);
+
+	err = check_name(tscm);
+	if (err < 0)
+		goto error;
+
+	err = snd_card_register(card);
+	if (err < 0)
+		goto error;
+
+	dev_set_drvdata(&unit->device, tscm);
+
+	return err;
+error:
+	snd_card_free(card);
+	return err;
+}
+
+static void snd_tscm_update(struct fw_unit *unit)
+{
+	return;
+}
+
+static void snd_tscm_remove(struct fw_unit *unit)
+{
+	struct snd_tscm *tscm = dev_get_drvdata(&unit->device);
+
+	/* No need to wait for releasing card object in this context. */
+	snd_card_free_when_closed(tscm->card);
+}
+
+static const struct ieee1394_device_id snd_tscm_id_table[] = {
+	/* FW-1082 */
+	{
+		.match_flags = IEEE1394_MATCH_VENDOR_ID |
+			       IEEE1394_MATCH_SPECIFIER_ID |
+			       IEEE1394_MATCH_VERSION,
+		.vendor_id = 0x00022e,
+		.specifier_id = 0x00022e,
+		.version = 0x800003,
+	},
+	/* FW-1884 */
+	{
+		.match_flags = IEEE1394_MATCH_VENDOR_ID |
+			       IEEE1394_MATCH_SPECIFIER_ID |
+			       IEEE1394_MATCH_VERSION,
+		.vendor_id = 0x00022e,
+		.specifier_id = 0x00022e,
+		.version = 0x800000,
+	},
+	/* FW-1804 mey be supported if IDs are clear. */
+	/* FE-08 requires reverse-engineering because it just has faders. */
+	{}
+};
+MODULE_DEVICE_TABLE(ieee1394, snd_tscm_id_table);
+
+static struct fw_driver tscm_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "snd-firewire-tascam",
+		.bus = &fw_bus_type,
+	},
+	.probe    = snd_tscm_probe,
+	.update   = snd_tscm_update,
+	.remove   = snd_tscm_remove,
+	.id_table = snd_tscm_id_table,
+};
+
+static int __init snd_tscm_init(void)
+{
+	return driver_register(&tscm_driver.driver);
+}
+
+static void __exit snd_tscm_exit(void)
+{
+	driver_unregister(&tscm_driver.driver);
+}
+
+module_init(snd_tscm_init);
+module_exit(snd_tscm_exit);
